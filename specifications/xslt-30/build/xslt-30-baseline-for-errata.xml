<?xml version="1.0" encoding="UTF-8"?><!--DO NOT EDIT: GENERATED BY merge-element-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-element-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-element-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-element-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-element-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-element-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-element-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-element-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-element-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-element-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-element-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-element-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-element-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-element-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-element-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-element-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-element-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-element-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-element-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-element-specs.xsl-->
<spec w3c-doctype="rec" status="int-review">
   <header>
      <title>XSL Transformations (XSLT)</title>
      <version>Version 3.0</version>
      <w3c-designation>REC-xslt-30</w3c-designation>
      <w3c-doctype>W3C Recommendation</w3c-doctype>
      <pubdate>
         <day>8</day>
         <month>June</month>
         <year>2017</year>
      </pubdate>
      <publoc>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink"
            href="https://www.w3.org/TR/yyyy/WD-xslt-30-yyyymmdd/" xlink:type="simple"
            xlink:show="replace" xlink:actuate="onRequest"
            >https://www.w3.org/TR/yyyy/WD-xslt-30-yyyymmdd/</loc>
      </publoc>
      <altlocs>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="Overview.html" xlink:type="simple"
            xlink:show="replace" xlink:actuate="onRequest">Normative specification in HTML
            format</loc>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="Overview-diff.html"
            xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">HTML with revision
            markings (non-normative)</loc>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="schema-for-xslt30.xsd"
            xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XSD 1.1 Schema for
            XSLT 3.0 Stylesheets (non-normative)</loc>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="schema-for-xslt30.rnc"
            xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Relax-NG Schema for
            XSLT 3.0 Stylesheets (non-normative)</loc>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="schema-for-json.xsd"
            xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XSD 1.0 Schema for
            the XML representation of JSON used by fn:json-to-xml (non-normative)</loc>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="xml-to-json.xsl" xlink:type="simple"
            xlink:show="replace" xlink:actuate="onRequest">Stylesheet for XML-to-JSON conversion
            (non-normative)</loc>
      </altlocs>
      <latestloc>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/TR/xslt-30/"
            xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
      </latestloc>
      <prevlocs>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink"
            href="https://www.w3.org/TR/2017/PR-xslt-30-20170418/" xlink:type="simple"
            xlink:show="replace" xlink:actuate="onRequest"
            >https://www.w3.org/TR/2017/PR-xslt-30-20170418/</loc>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink"
            href="https://www.w3.org/TR/2017/CR-xslt-30-20170207/" xlink:type="simple"
            xlink:show="replace" xlink:actuate="onRequest"
            >https://www.w3.org/TR/2017/CR-xslt-30-20170207/</loc>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink"
            href="https://www.w3.org/TR/2015/CR-xslt-30-20151119/" xlink:type="simple"
            xlink:show="replace" xlink:actuate="onRequest"
            >https://www.w3.org/TR/2015/CR-xslt-30-20151119/</loc>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink"
            href="https://www.w3.org/TR/2014/WD-xslt-30-20141002/" xlink:type="simple"
            xlink:show="replace" xlink:actuate="onRequest"
            >https://www.w3.org/TR/2014/WD-xslt-30-20141002/</loc>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink"
            href="https://www.w3.org/TR/2013/WD-xslt-30-20131212/" xlink:type="simple"
            xlink:show="replace" xlink:actuate="onRequest"
            >https://www.w3.org/TR/2012/WD-xslt-30-20131212/</loc>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink"
            href="https://www.w3.org/TR/2012/WD-xslt-30-20120710/" xlink:type="simple"
            xlink:show="replace" xlink:actuate="onRequest"
            >https://www.w3.org/TR/2012/WD-xslt-30-20120710/</loc>
      </prevlocs>
      <authlist>
         <author>
            <name>Michael Kay</name>
            <affiliation>Saxonica</affiliation>
            <email xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.saxonica.com/"
               xlink:type="simple" xlink:show="new" xlink:actuate="onRequest"
               >http://www.saxonica.com/</email>
         </author>
      </authlist>
      <errataloc xmlns:xlink="http://www.w3.org/1999/xlink"
         href="http://www.w3.org/XML/2017/qt-errata/xslt-30-errata.html" xlink:type="simple"/>
      <translationloc xmlns:xlink="http://www.w3.org/1999/xlink"
         href="https://www.w3.org/2003/03/Translations/byTechnology?technology=xslt-30"
         xlink:type="simple"/>
      <status diff="chg" at="U">
         <p><emph>This section describes the status of this document at the time of its publication.
               Other documents may supersede this document. A list of current W3C publications and
               the latest revision of this technical report can be found in the <loc
                  xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/TR/"
                  xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">W3C technical
                  reports index at https://www.w3.org/TR/.</loc></emph></p>
         <p>This document is governed by the <loc xmlns:xlink="http://www.w3.org/1999/xlink"
               id="w3c_process_revision" href="https://www.w3.org/2017/Process-20170301/"
               xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">1 March 2017 W3C
               Process Document</loc>.</p>
         <p>This is a <loc xmlns:xlink="http://www.w3.org/1999/xlink"
               href="https://www.w3.org/2017/Process-20170301/#rec-publication" xlink:type="simple"
               xlink:show="replace" xlink:actuate="onRequest">Recommendation</loc> of the W3C. It
            was developed by the W3C <loc xmlns:xlink="http://www.w3.org/1999/xlink"
               href="https://www.w3.org/Style/XSL/" xlink:type="simple" xlink:show="replace"
               xlink:actuate="onRequest">XSLT Working Group</loc>.</p>
         <p>This Recommendation specifies XSLT version 3.0. Changes since <loc
               xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/TR/xslt20"
               xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XSLT 2.0</loc> are
            listed in <specref ref="changes-since-2.0"/>. The only incompatibilities with XSLT 2.0
            relate to the way in which certain error conditions are handled: the details are given
            in <specref ref="incompatibilities"/>.</p>
         <p>No substantive changes have been made to this specification since its publication as a
            Proposed Recommendation. A few corrections and clarifications have been made to
            non-normative text: these are listed in <specref ref="changes-since-apr-2017"/>.</p>
         <p>This document has been reviewed by W3C Members, by software developers, and by other W3C
            groups and interested parties, and is endorsed by the Director as a W3C Recommendation.
            It is a stable document and may be used as reference material or cited from another
            document. W3C's role in making the Recommendation is to draw attention to the
            specification and to promote its widespread deployment. This enhances the functionality
            and interoperability of the Web.</p>
         <p>A test suite for XSLT 3.0, containing over 11,000 test cases, is available at <loc
               xmlns:xlink="http://www.w3.org/1999/xlink" href="https://dvcs.w3.org/hg/xslt30-test/"
               xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>. The metadata
            for each test case describes any dependencies on optional or implementation-defined
            features of the specification, and provides expected results for each test.
            Documentation on how to run tests is available within the test suite. New tests may be
            added from time to time, and contributions are welcome.</p>
         <p>An <loc xmlns:xlink="http://www.w3.org/1999/xlink"
               href="https://dvcs.w3.org/hg/xslt30-test/raw-file/tip/report/simpleReportOut.html"
               xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">implementation
               report</loc> is available detailing test results for various implementations. This
            link points to the latest version of the report; older versions are available within the
            repository. New submissions of test results are welcome. Submitted test results and a
            stylesheet for generating the reports can be found within the repository.</p>
         <p diff="chg" at="S-bug24266">This specification has been developed in conjunction with
               <bibref ref="xpath-30"/> and other documents that underpin both XSLT and XQuery. XSLT
            3.0 <rfc2119>requires</rfc2119> support for XPath 3.0 augmented by a selection of
            features from XPath 3.1 which are described in <specref ref="map"/> and <specref
               ref="json"/>. XSLT 3.0 in addition allows a processor to support the whole of XPath
            3.1, in which case it must do so as described in <specref ref="xpath31-feature"/>. In
            the event that future versions of XPath are defined beyond XPath 3.1, this specification
            allows XSLT 3.0 processors to provide support for such versions, but leaves it <termref
               def="dt-implementation-defined"/> how this is done. References in this document to
            XPath and related specifications are by default to the 3.0 versions, but such references
            should be treated as version-agnostic unless the relevant prose indicates otherwise.</p>
         <p diff="chg" at="S-bug24266"><emph>XSLT 3.0 specifies extensions to the XDM 3.0 data
               model, to the XPath 3.0 language syntax, and to the XPath 3.0 function library to
               underpin the introduction of maps, which were found necessary to support some XSLT
               streaming use cases, to enable XSLT to process JSON data, and to make many other
               processing tasks easier. These extensions have been incorporated into XDM 3.1 and
               XPath 3.1. Although XDM 3.1 and XPath 3.1 have reached Recommendation status, XSLT
               3.0 has not been made dependent on XPath 3.1, other than those features needed to
               meet the XSLT 3.0 requirements. </emph></p>
         <p>Please report errors in this document using W3C’s <loc
               xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/"
               xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public Bugzilla
               system</loc> (instructions can be found at <loc
               xmlns:xlink="http://www.w3.org/1999/xlink"
               href="https://www.w3.org/XML/2005/04/qt-bugzilla" xlink:type="simple"
               xlink:show="replace" xlink:actuate="onRequest"/>). If access to that system is not
            feasible, you may send your comments to the W3C XSLT/XPath/XQuery public comments
            mailing list, <loc xmlns:xlink="http://www.w3.org/1999/xlink"
               href="mailto:public-qt-comments@w3.org" xlink:type="simple" xlink:show="replace"
               xlink:actuate="onRequest">public-qt-comments@w3.org</loc>. It will be very helpful if
            you include the string “[XSLT30]” in the subject line of your report, whether made in
            Bugzilla or in email. Please use multiple Bugzilla entries (or, if necessary, multiple
            email messages) if you have more than one comment to make. Archives of the comments and
            responses are available at <loc xmlns:xlink="http://www.w3.org/1999/xlink"
               href="https://lists.w3.org/Archives/Public/public-qt-comments/" xlink:type="simple"
               xlink:show="replace" xlink:actuate="onRequest"/>.</p>
         <p>The same mechanism may be used for reporting errors in the test suite.</p>
         <p>This document was produced by a group operating under the <loc
               xmlns:xlink="http://www.w3.org/1999/xlink"
               href="https://www.w3.org/Consortium/Patent-Policy-20040205/" xlink:type="simple"
               xlink:show="replace" xlink:actuate="onRequest">5 February 2004 W3C Patent
               Policy</loc>. W3C maintains a <loc xmlns:xlink="http://www.w3.org/1999/xlink"
               rel="disclosure" href="https://www.w3.org/2004/01/pp-impl/19552/status#disclosures"
               xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public list of any
               patent disclosures</loc> made in connection with the deliverables of the group; that
            page also includes instructions for disclosing a patent. An individual who has actual
            knowledge of a patent which the individual believes contains <loc
               xmlns:xlink="http://www.w3.org/1999/xlink"
               href="https://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential"
               xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Essential
               Claim(s)</loc> must disclose the information in accordance with <loc
               xmlns:xlink="http://www.w3.org/1999/xlink"
               href="https://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure"
               xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">section 6 of the
               W3C Patent Policy</loc>.</p>
      </status>
      <abstract diff="chg" at="D">
         <p>This specification defines the syntax and semantics of XSLT <phrase diff="chg" at="A"
               >3.0</phrase>, a language <phrase diff="add" at="S-bug27258">designed
               primarily</phrase> for transforming XML documents into other XML documents.</p>
         <p>XSLT 3.0 is a revised version of the XSLT 2.0 Recommendation <bibref ref="xslt20"/>
            published on 23 January 2007.</p>
         <p>The primary purpose of the changes in this version of the language is to enable
            transformations to be performed in streaming mode, where neither the source document nor
            the result document is ever held in memory in its entirety. Another important aim is to
            improve the modularity of large stylesheets, allowing stylesheets to be developed from
            independently-developed components with a high level of software engineering robustness. </p>
         <p>XSLT 3.0 is designed to be used in conjunction with XPath 3.0, which is defined in
               <bibref ref="xpath-30"/>. XSLT shares the same data model as XPath 3.0, which is
            defined in <bibref ref="xpath-datamodel-30"/>, and it uses the library of functions and
            operators defined in <bibref ref="xpath-functions-30"/>. XPath 3.0 and the underlying
            function library introduce a number of enhancements, for example the availability of
            higher-order functions. </p>
         <p diff="add" at="S-bug29150">As an implementer option, XSLT 3.0 can also be used with
            XPath 3.1. All XSLT 3.0 processors provide maps, an addition to the data model which is
            specified (identically) in both XSLT 3.0 and XPath 3.1. Other features from XPath 3.1,
            such as arrays, and new functions such as <xfunction spec="FO31"
               >random-number-generator</xfunction> and <xfunction spec="FO31">sort</xfunction>, are
            available in XSLT 3.0 stylesheets only if the implementer chooses to support XPath
            3.1.</p>
         <p>Some of the functions that were previously defined in <phrase diff="chg" at="F">the XSLT
               2.0</phrase> specification, such as the <xfunction>format-date</xfunction> and
               <xfunction>format-number</xfunction> functions, are now defined in the standard
            function library to make them available to other host languages.</p>
         <p>XSLT 3.0 also includes optional facilities to serialize the results of a transformation,
            by means of an interface to the serialization component described in <bibref
               ref="xslt-xquery-serialization-30"/>. <phrase diff="add" at="S-bug29150">Again, the
               new serialization capabilities of <bibref ref="xslt-xquery-serialization-31"/> are
               available at the implementer’s option.</phrase>
         </p>
         <p>
            <emph>This document contains hyperlinks to specific sections or definitions within other
               documents in this family of specifications. These links are indicated visually by a
               superscript identifying the target specification: for example XP30 for XPath 3.0,
               DM30 for the XDM data model version 3.0, FO30 for Functions and Operators version
               3.0.</emph>
         </p>
      </abstract>
      <langusage>
         <language id="EN">English</language>
      </langusage>
      <revisiondesc>
         <slist>
            <sitem>((not used)).</sitem>
         </slist>
      </revisiondesc>
   </header>
   <body>
      <div1 id="introduction">
         <head>Introduction</head>
         <div2 id="what-is-xslt">
            <head>What is XSLT?</head>
            <p>This specification defines the syntax and semantics of the XSLT <phrase diff="chg"
                  at="A">3.0</phrase> language.</p>
            <p diff="chg" at="R-bug24235">A transformation in the XSLT language is expressed in the
               form of a <term>stylesheet</term>. A stylesheet is made up of one or more well-formed
               XML <bibref ref="REC-xml"/> documents conforming to the Namespaces in XML
               Recommendation <bibref ref="xml-names"/>. </p>
            <p>A stylesheet generally includes elements that are defined by XSLT as well as elements
               that are not defined by XSLT. XSLT-defined elements are distinguished by use of the
               namespace <code>http://www.w3.org/1999/XSL/Transform</code> (see <specref
                  ref="xslt-namespace"/>), which is referred to in this specification as the
                  <termref def="dt-xslt-namespace">XSLT namespace</termref>. Thus this specification
               is a definition of the syntax and semantics of the XSLT namespace.</p>
            <p>The term <termref def="dt-stylesheet">stylesheet</termref> reflects the fact that one
               of the important roles of XSLT is to add styling information to an XML source
               document, by transforming it into a document consisting of XSL formatting objects
               (see <bibref ref="xsl11"/>), or into another presentation-oriented format such as
               HTML, XHTML, or SVG. However, XSLT is used for a wide range of transformation tasks,
               not exclusively for formatting and presentation applications.</p>
            <p>A transformation expressed in XSLT describes rules for transforming <phrase
                  diff="add" at="S-bug27258"> input data into output data. The inputs and outputs
                  will all be instances of the XDM data model, described in <bibref
                     ref="xpath-datamodel-30"/>. In the simplest and most common case, the input is
                  an XML document referred to as the source tree, and the output is an XML document
                  referred to as the result tree. It is also possible to process multiple source
                  documents, to generate multiple result documents, and to handle formats other than
                  XML.</phrase>
               <phrase diff="del" at="S-bug27258">zero or more source trees into one or more result
                  trees. The structure of these trees is described in <bibref
                     ref="xpath-datamodel-30"/>.</phrase> The transformation is achieved by a set of
                  <termref def="dt-template-rule">template rules</termref>. A template rule
               associates a <termref def="dt-pattern">pattern</termref>, which <phrase diff="add"
                  at="S-bug27258">typically</phrase> matches nodes in the source document, with a
                  <termref def="dt-sequence-constructor">sequence constructor</termref>. In many
               cases, evaluating the sequence constructor will cause new nodes to be constructed,
               which can be used to produce part of a result tree. The structure of the result trees
               can be completely different from the structure of the source trees. In constructing a
               result tree, nodes from the source trees can be filtered and reordered, and arbitrary
               structure can be added. This mechanism allows a <termref def="dt-stylesheet"
                  >stylesheet</termref> to be applicable to a wide class of documents that have
               similar source tree structures.</p>
            <p>Stylesheets have a modular structure; they may contain several packages developed
               independently of each other, and each package may consist of several stylesheet
               modules. </p>
            <p diff="chg" at="R-bug24235"><termdef id="dt-stylesheet" term="stylesheet">A
                     <term>stylesheet</term> consists of one or more packages: specifically, one
                     <termref def="dt-top-level-package">top-level package</termref> and zero or
                  more <termref def="dt-library-package">library packages</termref>.</termdef></p>
            <p diff="chg" at="R-bug24235"><termdef id="dt-top-level-package"
                  term="top-level package">For a given transformation, one <termref def="dt-package"
                     >package</termref> functions as the <term>top-level package</term>. The
                  complete <termref def="dt-stylesheet">stylesheet</termref> is assembled by finding
                  the packages referenced directly or indirectly from the top-level package using
                     <elcode>xsl:use-package</elcode> declarations: see <specref
                     ref="package-dependencies"/>.</termdef></p>
            <p diff="chg" at="R-bug24235"><termdef id="dt-library-package" term="library package"
                  >Every <termref def="dt-package">package</termref> within a <termref
                     def="dt-stylesheet">stylesheet</termref>, other than the <termref
                     def="dt-top-level-package">top-level package</termref>, is referred to as a
                     <term>library package</term>.</termdef></p>
            <p diff="chg" at="R-bug24235"><termdef id="dt-principal-stylesheet-module"
                  term="principal stylesheet module">Within a <termref def="dt-package"
                     >package</termref>, one <termref def="dt-stylesheet-module"/> functions as the
                     <term>principal stylesheet module</term>. The complete package is assembled by
                  finding the stylesheet modules referenced directly or indirectly from the
                  principal stylesheet module using <elcode>xsl:include</elcode> and
                     <elcode>xsl:import</elcode> elements: see <specref ref="include"/> and <specref
                     ref="import"/>.</termdef></p>
         </div2>
         <div2 id="whats-new-in-xslt3" diff="add" at="D">
            <head>What’s New in XSLT 3.0?</head>
            <p>A major focus for enhancements in XSLT 3.0 is the requirement to enable streaming of
               source documents. This is needed when source documents become too large to hold in
               main memory, and also for applications where it is important to start delivering
               results before the entire source document is available.</p>
            <p>While implementations of XSLT that use streaming have always been theoretically
               possible, the nature of the language has made it very difficult to achieve this in
               practice. The approach adopted in this specification is twofold: it identifies a set
               of restrictions which, if followed by stylesheet authors, will enable implementations
               to adopt a streaming mode of operation without placing excessive demands on the
               optimization capabilities of the processor; and it provides new constructs to
               indicate that streaming is required, or to express transformations in a way that
               makes it easier for the processor to adopt a streaming execution plan.</p>
            <p>Capabilities provided in this category include:</p>
            <ulist>
               <item>
                  <p>A new <elcode>xsl:source-document</elcode> instruction, which reads and
                     processes a source document, <phrase diff="add" at="T-bug29747"
                        >optionally</phrase> in streaming mode;</p>
               </item>
               <item>
                  <p>The ability to declare that a <termref def="dt-mode">mode</termref> is a
                     streaming mode, in which case all the template rules using that mode must be
                     streamable;</p>
               </item>
               <item>
                  <p>A new <elcode>xsl:iterate</elcode> instruction, which iterates over the items
                     in a sequence, allowing parameters for the processing of one item to be set
                     during the processing of the previous item;</p>
               </item>
               <item>
                  <p>A new <elcode>xsl:merge</elcode> instruction, allowing multiple input streams
                     to be merged into a single output stream;</p>
               </item>
               <item>
                  <p>A new <elcode>xsl:fork</elcode> instruction, allowing multiple computations to
                     be performed in parallel during a single pass through an input document;</p>
               </item>
               <item diff="add" at="L">
                  <p><termref def="dt-accumulator-function">Accumulators</termref>, which allow a
                     value to be computed progressively during streamed processing of a document,
                     and accessed as a function of a node in the document, without compromise to the
                     functional nature of the XSLT language.</p>
               </item>
            </ulist>
            <p>A second focus for enhancements in XSLT 3.0 is the introduction of a new mechanism
               for stylesheet modularity, called the package. Unlike the stylesheet modules of XSLT
               1.0 and 2.0 (which remain available), a package defines an interface that regulates
               which functions, variables, templates and other components are visible outside the
               package, and which can be overridden. There are two main goals for this facility: it
               is designed to deliver software engineering benefits by improving the reusability and
               maintainability of code, and it is intended to streamline stylesheet deployment by
               allowing packages to be compiled independently of each other, and compiled instances
               of packages to be shared between multiple applications.</p>
            <p>Other significant features in XSLT 3.0 include:</p>
            <ulist>
               <item>
                  <p>An <elcode>xsl:evaluate</elcode> instruction allowing evaluation of XPath
                     expressions that are dynamically constructed as strings, or that are read from
                     a source document;</p>
               </item>
               <item>
                  <p>Enhancements to the syntax of <termref def="dt-pattern">patterns</termref>, in
                     particular enabling the matching of atomic values as well as nodes;</p>
               </item>
               <item>
                  <p>An <elcode>xsl:try</elcode> instruction to allow recovery from dynamic
                     errors;</p>
               </item>
               <item>
                  <p>The element <elcode>xsl:global-context-item</elcode>, used to declare the
                     stylesheet’s expectations of the global context item (notably, its type);</p>
               </item>
               <item diff="add" at="L">
                  <p>A new instruction <elcode>xsl:assert</elcode> to assist developers in producing
                     correct and robust code.</p>
               </item>
            </ulist>
            <p>XSLT 3.0 also delivers enhancements made to the XPath language and to the standard
               function library, including the following:</p>
            <ulist>
               <item>
                  <p>Variables can now be bound in XPath using the <code>let</code> expression.</p>
               </item>
               <item>
                  <p>Functions are now first class values, and can be passed as arguments to other
                     (higher-order) functions, making XSLT a fully-fledged functional programming
                     language.</p>
               </item>
               <item>
                  <p>A number of new functions are available, for example trigonometric functions,
                     and the functions <xfunction>parse-xml</xfunction> and
                        <xfunction>serialize</xfunction> to convert between lexical and tree
                     representations of XML.</p>
               </item>
            </ulist>
            <p diff="chg" at="S+">XSLT 3.0 also includes support for maps (a data structure
               consisting of key/value pairs, sometimes referred to in other programming languages
               as dictionaries, hashes, or associative arrays). This feature extends the data model,
               provides new syntax in XPath, and adds a number of new functions and operators.
               Initially developed as XSLT-specific extensions, maps have now been integrated into
               XPath 3.1 (see <bibref ref="xpath-31"/>). XSLT 3.0 does not require implementations
               to support XPath 3.1 in its entirety, but it does requires support for these specific
               features.</p>
            <p diff="del" at="N">The XSL Working Group is designing other new features which it
               hopes to include in the final XSLT 3.0 Recommendation, but which are not yet advanced
               enough to include in this Working Draft.</p>
            <p diff="add" at="E">A full list of changes is at <specref ref="changes-since-2.0"
               />.</p>
         </div2>
      </div1>
      <div1 id="concepts">
         <head>Concepts</head>
         <div2 id="terminology">
            <head>Terminology</head>
            <p>For a full glossary of terms, see <specref ref="glossary"/>.</p>
            <p>
               <termdef id="dt-processor" term="processor">The software responsible for transforming
                  source trees into result trees using an XSLT stylesheet is referred to as the
                     <term>processor</term>. This is sometimes expanded to <emph>XSLT
                     processor</emph> to avoid any confusion with other processors, for example an
                  XML processor.</termdef>
            </p>
            <p>
               <termdef id="dt-implementation" term="implementation">A specific product that
                  performs the functions of an <termref def="dt-processor">XSLT processor</termref>
                  is referred to as an <term>implementation</term>.</termdef></p>
            <p diff="add" at="S-bug27258">
               <termdef id="dt-tree" term="tree">The term <term>tree</term> is used (as in <bibref
                     ref="xpath-datamodel-30"/>) to refer to the aggregate consisting of a
                  parentless node together with all its descendant nodes, plus all their attributes
                  and namespaces.</termdef>
            </p>
            <note diff="add" at="L">
               <p>The use of the term <term>tree</term> in this document does not imply the use of a
                  data structure in memory that holds the entire contents of the document at one
                  time. It implies rather a logical view of the XML input and output in which
                  elements have a hierarchic relationship to each other. When a source document is
                  being processed in a streaming manner, access to the nodes in this tree is
                  constrained, but it is still viewed and described as a tree.</p>
            </note>
            <p diff="add" at="S-bug27258">The output of a transformation consists of the
               following:</p>
            <olist diff="add" at="S-bug27258">
               <item>
                  <p><termdef id="dt-principal-result" term="principal result">A <term>principal
                           result</term>: this can be any sequence of items (as defined in <bibref
                           ref="xpath-datamodel-30"/>).</termdef> The principal result is the value
                     returned by the function or template in the stylesheet that is nominated as the
                     entry point, as described in <specref ref="initiating"/>.</p>
               </item>
               <item>
                  <p><termdef id="dt-secondary-result" term="secondary result">Zero or more
                           <term>secondary results</term>: each secondary result can be any sequence
                        of items (as defined in <bibref ref="xpath-datamodel-30"/>).</termdef> A
                     secondary result is the value returned by evaluating the body of an
                        <elcode>xsl:result-document</elcode> instruction.</p>
               </item>
               <item>
                  <p>Zero or more messages. Messages are generated by the
                        <elcode>xsl:message</elcode> and <elcode>xsl:assert</elcode> instructions,
                     and are described in <specref ref="message"/> and <specref ref="assertions"
                     />.</p>
               </item>
               <item>
                  <p>Static or dynamic errors: see <specref ref="errors"/>. </p>
               </item>
            </olist>
            <p diff="add" at="S-bug27258">The <termref def="dt-principal-result"/> and the <termref
                  def="dt-secondary-result">secondary results</termref> may be post-processed as
               described in <specref ref="post-processing"/>.</p>
            <p>
               <termdef id="dt-result-tree" term="result tree">The term <term>result tree</term> is
                  used to refer to any <termref def="dt-tree">tree</termref> constructed by <termref
                     def="dt-instruction">instructions</termref> in the stylesheet. A result tree is
                  either a <termref def="dt-final-result-tree">final result tree</termref> or a
                     <termref def="dt-temporary-tree">temporary tree</termref>.</termdef>
            </p>
            <p>
               <termdef id="dt-final-result-tree" term="final result tree">A <term>final result
                     tree</term> is a <termref def="dt-result-tree">result tree</termref> that forms
                  part of the output of a transformation: <phrase diff="add" at="S-bug27258"
                     >specifically, a tree built by post-processing the items in the <termref
                        def="dt-principal-result"/> or in a <termref def="dt-secondary-result"
                     /></phrase>. Once created, the contents of a final result tree are not
                  accessible within the stylesheet itself.</termdef>
               <phrase diff="del" at="S-bug27258">The <elcode>xsl:result-document</elcode>
                  instruction always creates a final result tree, and a final result tree may also
                  be created implicitly by post-processing the <termref def="dt-raw-result"/> of a
                  stylesheet evaluation. The conditions under which this happens are described in
                     <specref ref="executing-a-transformation"/>.</phrase> Any final result tree
                  <rfc2119>may</rfc2119> be serialized as described in <specref ref="serialization"
               />.</p>
            <p>
               <termdef id="dt-source-tree" term="source tree">The term <term>source tree</term>
                  means any tree provided as input to the transformation. This includes the document
                  containing the <phrase diff="chg" at="E"><termref def="dt-global-context-item"
                     /></phrase> if any, <phrase diff="add" at="R-bug24764">documents containing
                     nodes present in the <termref def="dt-initial-match-selection"/></phrase>,
                  documents containing nodes supplied as the values of <termref
                     def="dt-stylesheet-parameter">stylesheet parameters</termref>, documents
                  obtained from the results of functions such as <function>document</function>,
                     <xfunction>doc</xfunction>, and <xfunction>collection</xfunction>, <phrase
                     diff="add" at="C">documents read using the <elcode>xsl:source-document</elcode>
                     instruction,</phrase> and documents returned by extension functions or
                  extension instructions. In the context of a particular XSLT instruction, the term
                     <term>source tree</term> means any tree provided as input to that instruction;
                  this may be a source tree of the transformation as a whole, or it may be a
                     <termref def="dt-temporary-tree">temporary tree</termref> produced during the
                  course of the transformation.</termdef>
            </p>
            <p>
               <termdef id="dt-temporary-tree" term="temporary tree">The term <term>temporary
                     tree</term> means any tree that is neither a <termref def="dt-source-tree"
                     >source tree</termref> nor a <termref def="dt-final-result-tree">final result
                     tree</termref>.</termdef> Temporary trees are used to hold intermediate results
               during the execution of the transformation.</p>
            <p diff="add" at="C">The use of the term “tree” in phrases such as <term>source
                  tree</term>, <term>result tree</term>, and <term>temporary tree</term> is not
               confined to documents that the processor materializes in memory in their entirety.
               The processor <rfc2119>may</rfc2119>, and in some cases <rfc2119>must</rfc2119>, use
               streaming techniques to limit the amount of memory used to hold source and result
               documents. When streaming is used, the nodes of the tree may never all be in memory
               at the same time, but at an abstract level the information is still modeled as a tree
               of nodes, and the document is therefore still described as a tree. <phrase diff="add"
                  at="R-editorial">Unless otherwise stated, the term “tree” refers to a tree rooted
                  at a parentless node: that is, the term does not include subtrees of larger trees.
                  Every node therefore belongs to exactly one tree.</phrase></p>
            <p>In this specification the phrases <rfc2119>must</rfc2119>, <rfc2119>must
                  not</rfc2119>, <rfc2119>should</rfc2119>, <rfc2119>should not</rfc2119>,
                  <rfc2119>may</rfc2119>, <rfc2119>required</rfc2119>, and
                  <rfc2119>recommended</rfc2119>, <phrase diff="add" at="F">when used in normative
                  text and rendered in capitals,</phrase> are to be interpreted as described in
                  <bibref ref="rfc2119"/>.</p>
            <p>Where the phrase <rfc2119>must</rfc2119>, <rfc2119>must not</rfc2119>, or
                  <rfc2119>required</rfc2119> relates to the behavior of the XSLT processor, then an
               implementation is not conformant unless it behaves as specified, subject to the more
               detailed rules in <specref ref="conformance"/>. </p>
            <p>Where the phrase <rfc2119>must</rfc2119>, <rfc2119>must not</rfc2119>, or
                  <rfc2119>required</rfc2119> relates to a stylesheet then the processor
                  <rfc2119>must</rfc2119> enforce this constraint on stylesheets by reporting an
               error if the constraint is not satisfied.</p>
            <p>Where the phrase <rfc2119>should</rfc2119>, <rfc2119>should not</rfc2119>, or
                  <rfc2119>recommended</rfc2119> relates to a stylesheet then a processor
                  <rfc2119>may</rfc2119> produce warning messages if the constraint is not
               satisfied, but <rfc2119>must not</rfc2119> treat this as an error.</p>
            <p>
               <termdef id="dt-implementation-defined" term="implementation-defined">In this
                  specification, the term <term>implementation-defined</term> refers to a feature
                  where the implementation is allowed some flexibility, and where the choices made
                  by the implementation <rfc2119>must</rfc2119> be described in documentation that
                  accompanies any conformance claim.</termdef>
            </p>
            <p>
               <termdef id="dt-implementation-dependent" term="implementation-dependent">The term
                     <term>implementation-dependent</term> refers to a feature where the behavior
                     <rfc2119>may</rfc2119> vary from one implementation to another, and where the
                  vendor is not expected to provide a full specification of the behavior.</termdef>
               (This might apply, for example, to limits on the size of source documents that can be
               transformed.)</p>
            <p>In all cases where this specification leaves the behavior implementation-defined or
               implementation-dependent, the implementation has the option of providing mechanisms
               that allow the user to influence the behavior.</p>
            <p>A paragraph labeled as a <term>Note</term> or described as an <term>example</term> is
               non-normative.</p>
            <p>Many terms used in this document are defined in the XPath specification <bibref
                  ref="xpath-30"/> or the XDM specification <bibref ref="xpath-datamodel-30"/>.
               Particular attention is drawn to the following:</p>
            <ulist>
               <item>
                  <p>
                     <termdef id="dt-atomization" term="atomize">The term <term>atomization</term>
                        is defined in <xspecref spec="XP30" ref="id-atomization"/>. It is a process
                        that takes as input a sequence of <phrase diff="chg" at="C">items</phrase>,
                        and returns a sequence of atomic values, in which the nodes are replaced by
                        their typed values as defined in <bibref ref="xpath-datamodel-30"/>. <phrase
                           diff="add" at="S-bug29079">If the <termref def="dt-xpath31-feature"/> is
                           implemented, then arrays (see <specref ref="arrays"/>) are atomized by
                           atomizing their members, recursively.</phrase></termdef> For some <phrase
                        diff="chg" at="C">items</phrase> (for example, elements with element-only
                     content, <phrase diff="add" at="C">function items</phrase>, and <termref
                        def="dt-map">maps</termref>), atomization generates a <termref
                        def="dt-dynamic-error">dynamic error</termref>.</p>
               </item>
               <item>
                  <p>
                     <termdef id="dt-typed-value" term="typed value">The term <term>typed
                           value</term> is defined in <xspecref spec="DM30" ref="dm-typed-value"/>.
                        Every node, <phrase diff="chg" at="N">other than an element whose type
                           annotation identifies it as having</phrase> element-only content, has a
                           <termref def="dt-string-value">typed value</termref>. For example, the
                           <termref def="dt-typed-value">typed value</termref> of an attribute of
                        type <code>xs:IDREFS</code> is a sequence of zero or more
                           <code>xs:IDREF</code> values.</termdef>
                  </p>
               </item>
               <item>
                  <p>
                     <termdef id="dt-string-value" term="string value">The term <term>string
                           value</term> is defined in <xspecref spec="DM30" ref="dm-string-value"/>.
                        Every node has a <termref def="dt-string-value">string value</termref>. For
                        example, the <termref def="dt-string-value">string value</termref> of an
                        element is the concatenation of the <termref def="dt-string-value">string
                           values</termref> of all its descendant text nodes.</termdef>
                  </p>
               </item>
               <item>
                  <p>
                     <termdef id="dt-xpath-compat-mode" term="XPath 1.0 compatibility mode">The term
                           <term>XPath 1.0 compatibility mode</term> is defined in <xspecref
                           spec="XP30" ref="static_context"/>. This is a setting in the static
                        context of an XPath expression; it has two values, <code>true</code> and
                           <code>false</code>. When the value is set to true, the semantics of
                        function calls and certain other operations are adjusted to give a greater
                        degree of backwards compatibility between <phrase diff="chg" at="D">XPath
                           3.0</phrase> and XPath 1.0.</termdef>
                  </p>
               </item>
            </ulist>
         </div2>
         <div2 id="notation">
            <head>Notation</head>
            <p>
               <termdef id="dt-xslt-element" term="XSLT element">An <term>XSLT element</term> is an
                  element in the <termref def="dt-xslt-namespace">XSLT namespace</termref> whose
                  syntax and semantics are defined in this specification.</termdef> For a
               non-normative list of XSLT elements, see <specref ref="element-syntax-summary"/>.</p>
            <p>In this document the specification of each <termref def="dt-xslt-element">XSLT
                  element</termref> is preceded by a summary of its syntax in the form of a model
               for elements of that element type. A full list of all these specifications can be
               found in <specref ref="element-syntax-summary"/>. The meaning of the syntax summary
               notation is as follows:</p>
            <ulist>
               <item>
                  <p>An attribute that is <rfc2119>required</rfc2119> is shown with its name in
                     bold. An attribute that may be omitted is shown with a question mark following
                     its name.</p>
               </item>
               <item>
                  <p>An attribute that is <termref def="dt-deprecated">deprecated</termref> is shown
                     in a grayed font within square brackets.</p>
               </item>
               <item>
                  <p>The string that occurs in the place of an attribute value specifies the allowed
                     values of the attribute. If this is surrounded by curly brackets
                        (<code>{...}</code>), then the attribute value is treated as an <termref
                        def="dt-attribute-value-template">attribute value template</termref>, and
                     the string occurring within curly brackets specifies the allowed values of the
                     result of evaluating the attribute value template. Alternative allowed values
                     are separated by <code>|</code>. A quoted string indicates a value equal to
                     that specific string. An unquoted, italicized name specifies a particular type
                     of value.</p>
                  <p diff="add" at="K">The types used, and their meanings, are as follows:</p>
                  <glist>
                     <gitem diff="add" at="R-bug26308">
                        <label>
                           <code>boolean</code>
                        </label>
                        <def>
                           <p>One of the strings <code>"yes"</code>, <code>"true"</code>, or
                                 <code>"1"</code> to indicate the value <code>true</code>, or one of
                              the strings <code>"no"</code>, <code>"false"</code>, or
                                 <code>"0"</code> to indicate the value <code>false</code>. Note:
                              the values are synonyms; where this specification uses a phrase such
                              as “If <code>required='yes'</code> is specified ...” this is to be
                              interpreted as meaning “If the attribute named <code>required</code>
                              is present, and has the value <code>yes</code>, <code>true</code>, or
                                 <code>1</code> (after stripping leading and trailing whitespace)
                              ...”. </p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>string</code></label>
                        <def>
                           <p>Any string</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>expression</code></label>
                        <def>
                           <p>An XPath <termref def="dt-expression">expression</termref></p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>pattern</code></label>
                        <def>
                           <p>A <termref def="dt-pattern">pattern</termref> as described in <specref
                                 ref="patterns"/>.</p>
                        </def>
                     </gitem>
                     <gitem diff="add" at="S-bug27806">
                        <label><code>item-type</code></label>
                        <def>
                           <p>An <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                                 ref="prod-xpath30-ItemType" xlink:type="simple">ItemType</xnt> as
                              defined in the XPath 3.0 specification <phrase diff="add"
                                 at="S-bug24266">(or in XPath 3.1 if the processor implements the
                                    <termref def="dt-xpath31-feature"/>)</phrase></p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>sequence-type</code></label>
                        <def>
                           <p>A <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                                 ref="prod-xpath30-SequenceType" xlink:type="simple"
                                 >SequenceType</xnt> as defined in the XPath 3.0 specification
                                 <phrase diff="add" at="S-bug24266">(or in XPath 3.1 if the
                                 processor implements the <termref def="dt-xpath31-feature"
                                 />)</phrase></p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>uri; uris</code></label>
                        <def>
                           <p>A URI, for example a namespace URI or a collation URI; a
                              whitespace-separated list of URIs</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>qname</code></label>
                        <def>
                           <p>A <termref def="dt-lexical-qname">lexical QName</termref> as defined
                              in <specref ref="qname"/></p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>eqname; eqnames</code></label>
                        <def>
                           <p>An <termref def="dt-eqname">EQName</termref> as defined in <specref
                                 ref="qname"/>; a whitespace-separated list of EQNames</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>token; tokens</code></label>
                        <def>
                           <p>A string containing no significant whitespace; a whitespace-separated
                              list of such strings</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>nmtoken; nmtokens</code></label>
                        <def>
                           <p>A string conforming to the XML schema rules for the type
                                 <code>xs:NMTOKEN</code>; a whitespace-separated list of such
                              strings.</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>char</code></label>
                        <def>
                           <p>A string comprising a single Unicode character</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>integer</code></label>
                        <def>
                           <p>An integer, that is a string in the lexical space of the schema type
                                 <code>xs:integer</code></p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>decimal</code></label>
                        <def>
                           <p>A decimal value, that is a string in the lexical space of the schema
                              type <code>xs:decimal</code></p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>ncname</code></label>
                        <def>
                           <p>An unprefixed name: a string in the value space of the schema type
                                 <code>xs:NCName</code></p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>prefix</code></label>
                        <def>
                           <p>An <code>xs:NCName</code> representing a namespace prefix, which must
                              be in scope for the element on which it appears</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>id</code></label>
                        <def>
                           <p>An <code>xs:NCName</code> used as a unique identifier for an element
                              in the containing XML document</p>
                        </def>
                     </gitem>
                  </glist>
                  <p>Except where the set of allowed values of an attribute is specified using the
                     italicized name <emph>string</emph> or <emph>char</emph>, leading and trailing
                     whitespace in the attribute value is ignored. In the case of an <termref
                        def="dt-attribute-value-template">attribute value template</termref>, this
                     applies to the <termref def="dt-effective-value">effective value</termref>
                     obtained when the attribute value template is expanded.</p>
                  <p diff="add" at="T-bug29814">XPath comments (delimited by <code>(: ... :)</code>)
                     are permitted anywhere that inter-token whitespace is permitted in attributes
                     whose type is given as <emph>expression</emph>, <emph>pattern</emph>,
                        <emph>item-type</emph>, or <emph>sequence-type</emph>, and are not permitted
                     in attributes of other types (other than within expressions enclosed by curly
                     braces within an <termref def="dt-attribute-value-template"/>).</p>
               </item>
               <item>
                  <p>Unless the element is <rfc2119>required</rfc2119> to be empty, the model
                     element contains a comment specifying the allowed content. The allowed content
                     is specified in a similar way to an element type declaration in XML;
                        <emph>sequence constructor</emph> means that any mixture of text nodes,
                        <termref def="dt-literal-result-element">literal result elements</termref>,
                        <termref def="dt-extension-instruction">extension instructions</termref>,
                     and <termref def="dt-xslt-element">XSLT elements</termref> from the <termref
                        def="dt-instruction">instruction</termref> category is allowed;
                        <emph>other-declarations</emph> means that any mixture of XSLT elements from
                     the <termref def="dt-declaration">declaration</termref> category<phrase
                        diff="del" at="R-editorial">, other than
                        <elcode>xsl:import</elcode>,</phrase> is allowed, together with <termref
                        def="dt-data-element">user-defined data elements</termref>.</p>
               </item>
               <item>
                  <p>The element is prefaced by comments indicating if it belongs to the
                        <code>instruction</code> category or <code>declaration</code> category or
                     both. The category of an element only affects whether it is allowed in the
                     content of elements that allow a <termref def="dt-sequence-constructor"
                        >sequence constructor</termref> or <emph>other-declarations</emph>.</p>
               </item>
            </ulist>
            <example>
               <head>Syntax Notation</head>
               <p>This example illustrates the notation used to describe <termref
                     def="dt-xslt-element">XSLT elements</termref>.</p>
               <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
                  name="example-element">
                  <e:in-category name="instruction"/>
                  <e:attribute name="select" required="yes">
                     <e:data-type name="expression"/>
                  </e:attribute>
                  <e:attribute name="debug">
                     <e:data-type name="boolean"/>
                  </e:attribute>
                  <e:attribute name="validation">
                     <e:attribute-value-template>
                        <e:constant value="strict"/>
                        <e:constant value="lax"/>
                     </e:attribute-value-template>
                  </e:attribute>
                  <e:sequence>
                     <e:choice repeat="zero-or-more">
                        <e:element name="variable"/>
                        <e:element name="param"/>
                     </e:choice>
                     <e:element name="sequence"/>
                  </e:sequence>
                  <e:allowed-parents>
                     <e:parent-category name="sequence-constructor"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p>This example defines a (non-existent) element <code>xsl:example-element</code>.
                  The element is classified as an instruction. It takes the following
                  attributes:</p>
               <olist>
                  <item>
                     <p>A mandatory <code>select</code> attribute, whose value is an XPath <termref
                           def="dt-expression">expression</termref></p>
                  </item>
                  <item>
                     <p diff="add" at="R-bug26308">An optional <code>debug</code> attribute, whose
                        value <rfc2119>must</rfc2119> be <code>yes</code>, <code>true</code>, or
                           <code>1</code> to indicate <code>true</code>, or <code>no</code>,
                           <code>false</code>, or <code>0</code> to indicate <code>false</code>.</p>
                  </item>
                  <item>
                     <p>An optional <code>validation</code> attribute, whose value must be
                           <code>strict</code> or <code>lax</code>; the curly brackets indicate that
                        the value can be defined as an <termref def="dt-attribute-value-template"
                           >attribute value template</termref>, allowing a value such as
                           <code>validation="{$val}"</code>, where the <termref def="dt-variable"
                           >variable</termref>
                        <code>val</code> is evaluated to yield <code>"strict"</code> or
                           <code>"lax"</code> at run-time.</p>
                  </item>
               </olist>
               <p>The content of an <code>xsl:example-element</code> instruction is defined to be a
                  sequence of zero or more <elcode>xsl:variable</elcode> and
                     <elcode>xsl:param</elcode> elements, followed by an
                     <elcode>xsl:sequence</elcode> element.</p>
            </example>
            <p>
               <error spec="XT" type="static" class="SE" code="0010"><p>It is a <termref
                        def="dt-static-error">static error</termref> if an XSLT-defined element is
                     used in a context where it is not permitted, if a <rfc2119>required</rfc2119>
                     attribute is omitted, or if the content of the element does not correspond to
                     the content that is allowed for the element.</p></error>
            </p>
            <p diff="add" at="R-bug24619">The rules in the element syntax summary (both for the
               element structure and for its attributes) apply to the stylesheet content after
               preprocessing as described in <specref ref="preprocessing"/>.</p>
            <p>Attributes are validated as follows. These rules apply to the value of the attribute
               after removing leading and trailing whitespace.</p>
            <ulist>
               <item>
                  <p>
                     <error spec="XT" type="static" class="SE" code="0020"><p>It is a <termref
                              def="dt-static-error">static error</termref> if an attribute (other
                           than an attribute written using curly brackets in a position where an
                              <termref def="dt-attribute-value-template">attribute value
                              template</termref> is permitted) contains a value that is not one of
                           the permitted values for that attribute.</p></error>
                  </p>
               </item>
               <item>
                  <p>
                     <error spec="XT" type="dynamic" class="DE" code="0030"><p>It is a <termref
                              def="dt-dynamic-error"><phrase diff="del" at="M"
                                 >non-recoverable</phrase> dynamic error</termref> if the <termref
                              def="dt-effective-value">effective value</termref> of an attribute
                           written using curly brackets, in a position where an <termref
                              def="dt-attribute-value-template">attribute value template</termref>
                           is permitted, is a value that is not one of the permitted values for that
                           attribute. If the processor is able to detect the error statically (for
                           example, when any XPath expressions within the curly brackets can be
                           evaluated statically), then the processor may optionally signal this as a
                           static error.</p></error>
                  </p>
               </item>
            </ulist>
            <p>Special rules apply if the construct appears in part of the <termref
                  def="dt-stylesheet">stylesheet</termref> that is processed with <termref
                  def="dt-forwards-compatible-behavior"/>: see <specref ref="forwards"/>.</p>
            <p>
               <termdef id="dt-deprecated" term="deprecated">Some constructs defined in this
                  specification are described as being <term>deprecated</term>. The use of this term
                  implies that stylesheet authors <rfc2119>should not</rfc2119> use the construct,
                  and that the construct may be removed in a later version of this
                  specification.</termdef><phrase diff="del" at="M">All constructs that are <termref
                     def="dt-deprecated">deprecated</termref> in this specification are also (as it
                  happens) optional features that <termref def="dt-implementation"
                     >implementations</termref> are <rfc2119>not required</rfc2119> to
                  provide.</phrase></p>
            <note>
               <p>This specification includes a non-normative XML Schema for XSLT <termref
                     def="dt-stylesheet-module">stylesheet modules</termref> (see <specref
                     ref="schema-for-xslt"/>). The syntax summaries described in this section are
                  normative.</p>
            </note>
            <p>XSLT defines a set of standard functions which are additional to those defined in
                  <bibref ref="xpath-functions-30"/>. <phrase diff="add" at="L">A list of these
                  functions appears in <specref ref="XSLT-defined-functions"/>.</phrase> The
               signatures of these functions are described using the same notation as used in
                  <bibref ref="xpath-functions-30"/>. The names of <phrase diff="add" at="L">many
                  of</phrase> these functions are in the <termref
                  def="dt-standard-function-namespace">standard function namespace</termref>.</p>
         </div2>
         <div2 id="initiating">
            <head>Initiating a Transformation</head>
            <p>This document does not specify any application programming interfaces or other
               interfaces for initiating a transformation. This section, however, describes the
               information that is supplied when a transformation is initiated. Except where
               otherwise indicated, the information is <rfc2119>required</rfc2119>.</p>
            <p>The execution of a stylesheet necessarily involves two activities: static analysis
               and dynamic evaluation. Static analysis consists of those tasks that can be performed
               by inspection of the stylesheet alone, including <phrase diff="add" at="Q">the
                  binding of <termref def="dt-static-variable">static variables</termref>,</phrase>
               the evaluation of <code>[xsl:]use-when</code> expressions (see <specref
                  ref="conditional-inclusion"/>), <phrase diff="add" at="R">and shadow attributes
                  (see <specref ref="shadow-attributes"/>)</phrase> and detection of <termref
                  def="dt-static-error">static errors</termref>. Dynamic evaluation consists of
               tasks which in general cannot be carried out until a source document is
               available.</p>
            <p diff="add" at="Q">Dynamic evaluation is further divided into two activities:
                  <term>priming</term> the stylesheet, and <term>invoking</term> a selected
               component. </p>
            <ulist diff="add" at="Q">
               <item>
                  <p>Priming the stylesheet provides the dynamic context for evaluation, and
                     supplies all the information needed to establish the values of global
                     variables.</p>
               </item>
               <item>
                  <p>Invoking a component (such as a template or function) causes evaluation of that
                     template or function to produce a result, which is an arbitrary XDM value.</p>
                  <p><termdef id="dt-raw-result" term="raw result">The result of invoking the
                        selected component, after any required conversion to the declared result
                        type of the component, is referred to as the <term>raw
                        result</term>.</termdef></p>
                  <p diff="add" at="T-bug29442">The <termref def="dt-raw-result"/> of the invocation
                     is the <termref def="dt-immediate-result"/> of evaluating the <termref
                        def="dt-sequence-constructor"/> contained in the target template or
                     function, modified by applying the <termref def="dt-function-conversion-rules"
                     /> to convert the <termref def="dt-immediate-result"/> to the type declared in
                     the <code>as</code> attribute of the <elcode>xsl:template</elcode> or
                        <elcode>xsl:function</elcode> declaration, if present.</p>
                  <p>This raw result may optionally be post-processed to construct a result tree, to
                     serialize the result, or both, as described in <specref ref="post-processing"
                     />.</p>
               </item>
            </ulist>
            <p>Implementations <rfc2119>may</rfc2119> allow static analysis and dynamic evaluation
               to be initiated independently, so that the cost of static analysis can be amortized
               over multiple transformations using the same stylesheet. <phrase diff="add" at="Q"
                  >Implementations <rfc2119>may</rfc2119> also allow priming of a stylesheet and
                  invocation of components to be initiated independently, in which case a single act
                  of priming the stylesheet may be followed by a series of independent component
                  invocations. Although this specification does not require such a separation, this
                  section distinguishes information that is needed before static analysis can
                  proceed, information that is needed to prime the stylesheet, and information that
                  is needed when invoking components.</phrase></p>
            <p diff="chg" at="N">The language is designed to allow the static analysis of each
                  <termref def="dt-package"/> to be performed independently of other packages, with
               only basic knowledge of the properties of components made available by used packages.
               Beyond this, the specification leaves it to implementations to decide how to organize
               this process. When packages are not used explicitly, the entire stylesheet is treated
               as a single package.</p>
            <div3 id="info-for-static-analysis">
               <head>Information needed for Static Analysis</head>
               <p diff="chg" at="M">The following information is needed prior to static analysis
                     <phrase diff="add" at="N">of a package</phrase>:</p>
               <ulist>
                  <item>
                     <p diff="chg" at="N">The location of the <termref def="dt-package-manifest"/>,
                        or in the absence of a package manifest, the <termref
                           def="dt-stylesheet-module">stylesheet module</termref> that is to act as
                        the <termref def="dt-principal-stylesheet-module">principal stylesheet
                           module</termref>
                        <phrase diff="chg" at="R-bug24235">of the <termref def="dt-package"
                           /></phrase>. The complete <termref def="dt-package">package</termref> is
                        assembled by recursively expanding the <elcode>xsl:import</elcode> and
                           <elcode>xsl:include</elcode> declarations in the principal stylesheet
                        module, as described in <specref ref="include"/> and <specref ref="import"
                        />. </p>
                  </item>
                  <item>
                     <p diff="add" at="N">Information about the packages referenced from this
                        package using <elcode>xsl:use-package</elcode> declarations. The information
                        needed will include the names and signatures of public components exported
                        by the referenced package.</p>
                  </item>
                  <item>
                     <p diff="add" at="M">A set (possibly empty) of values for <termref
                           def="dt-static-parameter">static parameters</termref> (see <specref
                           ref="global-variables"/>). These values are available for use within
                           <termref def="dt-static-expression">static expressions</termref> (notably
                        in <code>[xsl:]use-when</code> expressions and shadow attributes) as well as
                        non-static expressions in the <termref def="dt-stylesheet"
                           >stylesheet</termref>. As a minimum, values <rfc2119>must</rfc2119> be
                        supplied for any static parameters declared with the attribute
                           <code>required="yes"</code>.</p>
                  </item>
               </ulist>
               <p diff="add" at="N">Conceptually, the output of the static analysis of a package is
                  an object which might be referred to (without constraining the implementation) as
                  a compiled package. Prior to dynamic evaluation, all the compiled packages needed
                  for execution must be checked for consistency, and component references must be
                  resolved. This process may be referred to, again without constraining the
                  implementation, as linking.</p>
            </div3>
            <div3 id="priming-stylesheet">
               <head>Priming a Stylesheet</head>
               <p diff="chg" at="Q">The information needed when priming a stylesheet is as
                  follows:</p>
               <ulist>
                  <item>
                     <p>A set (possibly empty) of values for <phrase diff="add" at="M"
                           >non-static</phrase>
                        <termref def="dt-stylesheet-parameter">stylesheet parameters</termref> (see
                           <specref ref="global-variables"/>). These values are available for use
                        within <termref def="dt-expression">expressions</termref> in the <termref
                           def="dt-stylesheet">stylesheet</termref>. As a minimum, values
                           <rfc2119>must</rfc2119> be supplied for any parameters declared with the
                        attribute <code>required="yes"</code>.</p>
                     <p diff="add" at="Q">A supplied value is converted if necessary to the declared
                        type of the stylesheet parameter using the <termref
                           def="dt-function-conversion-rules"/>.</p>
                     <note>
                        <p diff="add" at="R-bug24549">Non-static stylesheet parameters <phrase
                              diff="chg" at="S-bug28357">are implicitly</phrase>
                           <code>public</code>, which ensures that all the parameters in the
                           stylesheet for which values can be supplied externally have distinct
                           names. Static parameters, <phrase diff="chg" at="S-bug28357">by contrast,
                              are local to a package</phrase>.</p>
                     </note>
                  </item>
                  <item>
                     <p diff="chg" at="29802">
                        <termdef id="dt-global-context-item" term="global context item"><phrase
                              diff="chg" at="R-bug24764">An item that acts as the <term>global
                                 context item</term> for the transformation.</phrase> This item acts
                           as the <termref def="dt-context-item"/> when evaluating <phrase
                              diff="chg" at="R-bug24549"> the <code>select</code> expression or
                                 <termref def="dt-sequence-constructor"/> of a <termref
                                 def="dt-global-variable"/> declaration</phrase>
                           <phrase diff="add" at="R-bug25611">within the <termref
                                 def="dt-top-level-package"/></phrase>, as described in <specref
                              ref="focus"/>. The global context item may also be available in a
                              <termref def="dt-named-template"/> when the stylesheet is invoked as
                           described in <specref ref="invoking-initial-template"/></termdef>.</p>
                     <note diff="add" at="R-bug24549">
                        <p>In previous releases of this specification, a single node was typically
                           supplied to represent the source document for the transformation. This
                           node was used as the target node for the implicit call on
                              <elcode>xsl:apply-templates</elcode> used to start the transformation
                           process (now called the <termref def="dt-initial-match-selection"/>), and
                           the root node of the containing tree was used as the context item for
                           evaluation of global variables (now called the <termref
                              def="dt-global-context-item"/>). This relationship between the
                              <termref def="dt-initial-match-selection"/> and the <termref
                              def="dt-global-context-item"/> is likely to be found for compatibility
                           reasons in a transformation API designed to work with earlier versions of
                           this specification, but it is no longer a necessary relationship; the two
                           values can in principle be completely independent of each other.</p>
                        <p>Stylesheet authors wanting to write code that can be invoked using legacy
                           APIs should not rely on the caller being able to supply different values
                           for the <termref def="dt-initial-match-selection"/> and the <termref
                              def="dt-global-context-item"/>.</p>
                     </note>
                     <p diff="add" at="T-bug29696">The value given to the <termref
                           def="dt-global-context-item"/> (and the values given to <termref
                           def="dt-stylesheet-parameter">stylesheet parameters</termref>) cannot be
                        nodes in a streamed document. This rule ensures that all global variables
                        can freely navigate within the relevant tree, with no constraints imposed by
                        the streamability rules.</p>
                     <p diff="del" at="Q">The <termref def="dt-global-context-item"/> is required if
                        dynamic evaluation is to start with a <termref def="dt-template-rule"/>, and
                        is optional if it is to start with a <termref def="dt-named-template"/>
                        <phrase diff="add" at="Q">or with a <termref def="dt-stylesheet-function"
                           /></phrase>.</p>
                     <p diff="add" at="Q">The <termref def="dt-global-context-item"/> is potentially
                        used when initializing global variables and parameters. If the
                        initialization of any <termref def="dt-global-variable">global
                           variables</termref> or <termref def="dt-stylesheet-parameter"
                           >parameter</termref> depends on the context item, a dynamic error can
                        occur if the context item is absent. It is <termref
                           def="dt-implementation-defined"/> whether this error occurs during
                        priming of the stylesheet or subsequently when the variable is referenced;
                        and it is <termref def="dt-implementation-defined"/> whether the error
                        occurs at all if the variable or parameter is never referenced. The error
                        can be suppressed by use of <elcode>xsl:try</elcode> and
                           <elcode>xsl:catch</elcode> within the <phrase diff="add" at="R-bug24548"
                           >sequence constructor used to initialize the variable or parameter. It
                           cannot be suppressed by use of <elcode>xsl:try</elcode> around a
                           reference to the global variable.</phrase>
                     </p>
                     <imp-def-feature id="idf-api-globalcontext">If the initialization of any
                           <termref def="dt-global-variable">global variables</termref> or <termref
                           def="dt-stylesheet-parameter">parameter</termref> depends on the context
                        item, a dynamic error can occur if the context item is absent. It is
                           <termref def="dt-implementation-defined"/> whether this error occurs
                        during priming of the stylesheet or subsequently when the variable is
                        referenced; and it is <termref def="dt-implementation-defined"/> whether the
                        error occurs at all if the variable or parameter is never referenced. </imp-def-feature>
                     <p diff="del" at="Q">The value that can be supplied as the <phrase diff="chg"
                           at="E"><termref def="dt-global-context-item"/></phrase> is constrained by
                        the xsl:context-item element.</p>
                     <p><phrase diff="add" at="R-bug25611">In a <termref def="dt-library-package"/>,
                           the <termref def="dt-context-item">context item</termref>, <termref
                              def="dt-context-position">context position</termref>, and <termref
                              def="dt-context-size">context size</termref> used for evaluation of
                           global variables will be <termref def="dt-absent">absent</termref>, and
                           the evaluation of any expression that references these values will result
                           in a dynamic error. </phrase>
                        <phrase diff="chg" at="R-bug24764">This will also be the case in the
                              <termref def="dt-top-level-package"/> if no <termref
                              def="dt-global-context-item"/> is supplied.</phrase></p>
                     <note>
                        <p>If a context item is available within a global variable declaration, then
                           the <termref def="dt-context-position">context position</termref> and
                              <termref def="dt-context-size">context size</termref> will always be 1
                           (one).</p>
                     </note>
                     <note diff="add" at="R-bug25611">
                        <p>For maximum reusability of code, it is best to avoid use of the context
                           item when initializing global variables and parameters. Instead, all
                           external information should be supplied using named <termref
                              def="dt-stylesheet-parameter">stylesheet parameters</termref>.
                           Especially when these use namespaces to avoid conflicts, there is then no
                           risk of confusion between the information supplied externally to
                           different packages.</p>
                        <p>When a stylesheet parameter is defined in a library package, it is
                           possible for a using package to supply a value for the parameter by
                           overriding the parameter declaration within an
                              <elcode>xsl:override</elcode> element. If the using package is the
                              <termref def="dt-top-level-package"/> then the overriding declaration
                           can refer to the <termref def="dt-global-context-item"/>.</p>
                     </note>
                  </item>
                  <item>
                     <p>A mechanism for obtaining a document node and a media type, given an
                        absolute URI. The total set of available documents (modeled as a mapping
                        from URIs to document nodes) forms part of the context for evaluating XPath
                        expressions, specifically the <xfunction>doc</xfunction> function. The XSLT
                           <function>document</function> function additionally requires the media
                        type of the resource representation, for use in interpreting any fragment
                        identifier present within a URI Reference.</p>
                     <note>
                        <p>The set of documents that are available to the stylesheet is <termref
                              def="dt-implementation-dependent">implementation-dependent</termref>,
                           as is the processing that is carried out to construct a tree representing
                           the resource retrieved using a given URI. Some possible ways of
                           constructing a document (specifically, rules for constructing a document
                           from an Infoset or from a PSVI) are described in <bibref
                              ref="xpath-datamodel-30"/>.</p>
                     </note>
                  </item>
               </ulist>
               <p diff="add" at="Q">Once a stylesheet is primed, the values of global variables
                  remain stable through all component invocations. In addition, priming a stylesheet
                  creates an <xtermref spec="FO30" ref="execution-scope">execution scope</xtermref>
                  during which the dynamic context and all <phrase diff="chg" at="R-bug24549">calls
                     on <xtermref spec="FO30" ref="dt-deterministic">deterministic</xtermref>
                     functions</phrase> remain stable; for example two calls on the
                     <xfunction>current-dateTime</xfunction> function within an execution scope are
                  defined to return the same result.</p>
               <p>Parameters passed to the transformation by the client application <phrase
                     diff="add" at="Q">when a stylesheet is primed</phrase> are matched against
                     <termref def="dt-stylesheet-parameter">stylesheet parameters</termref> (see
                     <specref ref="global-variables"/>), not against the <termref
                     def="dt-template-parameter">template parameters</termref> of any template
                  executed during the course of the transformation. <phrase diff="del" at="Q">All
                        <termref def="dt-template-parameter">template parameters</termref> within
                     the initial template to be executed will take their default
                  values.</phrase></p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="0050"><p>It is a <termref
                           def="dt-dynamic-error"> dynamic error</termref> if a stylesheet declares
                        a visible <termref def="dt-stylesheet-parameter">stylesheet
                           parameter</termref>
                        <phrase diff="chg" at="S-bug28355">that is <termref
                              def="dt-explicitly-mandatory">explicitly</termref> or <termref
                              def="dt-implicitly-mandatory">implicitly</termref> mandatory,</phrase>
                        and no value for this parameter is supplied when the stylesheet is primed. A
                        stylesheet parameter is visible if it is not masked by another global
                        variable or parameter with the same name and higher <termref
                           def="dt-import-precedence">import precedence</termref>. <phrase
                           diff="add" at="M">If the parameter is a <termref
                              def="dt-static-parameter"/> then the value <rfc2119>must</rfc2119> be
                           supplied prior to the static analysis phase.</phrase></p></error>
               </p>
               <imp-def-feature id="idf-api-input">The way in which an XSLT processor is invoked,
                  and the way in which values are supplied for the source document, starting node,
                     <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>, and
                     <termref def="dt-base-output-uri">base output URI</termref>, are
                  implementation-defined.</imp-def-feature>
            </div3>
            <div3 id="invoking-initial-mode">
               <head>Apply-Templates Invocation</head>
               <p diff="add" at="R-bug24550"><termdef id="dt-initial-match-selection"
                     term="initial match selection">A stylesheet may be evaluated by supplying a
                     value to be processed, together with an <termref def="dt-initial-mode"/>. The
                     value (which can be any sequence of items) is referred to as the <term>initial
                        match selection</term>. The processing then corresponds to the effect of the
                        <elcode>xsl:apply-templates</elcode> instruction.</termdef></p>
               <p diff="add" at="R-bug24550">The <termref def="dt-initial-match-selection"/> will
                  often be a single document node, traditionally called the source document of the
                  transformation; but in general, it can be any sequence. <phrase diff="add" at="S+"
                     >If the initial match selection is an empty sequence, the result of the
                     transformation will be empty, since no template rules are
                  evaluated.</phrase></p>
               <p diff="chg" at="R-bug24550">Processing proceeds by finding the <termref
                     def="dt-template-rule">template rules</termref> that match the items in the
                     <termref def="dt-initial-match-selection"/>, and evaluating these template
                  rules with a <termref def="dt-focus"/> based on the <termref
                     def="dt-initial-match-selection"/>. The template rules are evaluated in
                     <termref def="dt-final-output-state"/>.</p>
               <p diff="add" at="M">The following information is needed when dynamic evaluation is
                  to start with a <termref def="dt-template-rule"/>:</p>
               <ulist>
                  <item>
                     <p diff="chg" at="R-bug24550">The <termref def="dt-initial-match-selection"/>.
                        An API that chooses to maintain compatibility with previous versions of this
                        specification <rfc2119>should</rfc2119> allow a method of invocation in
                        which a singleton node is provided, which is then used in two ways: the node
                        itself acts as the <termref def="dt-initial-match-selection"/>, and the
                           <phrase diff="chg" at="S-bug29150">root node of the containing
                           tree</phrase> acts as the <termref def="dt-global-context-item"/>. </p>
                     <note diff="del" at="R-bug24550">
                        <p>In earlier versions of this specification, the initial input sequence (to
                           which templates are applied) was always the same as the initial context
                           item (used for computing the values of global variables), and since this
                           is the most common scenario, it is likely to affect the design of
                           APIs.</p>
                     </note>
                  </item>
                  <item>
                     <p>Optionally, an initial <termref def="dt-mode">mode</termref>.</p>
                     <p diff="add" at="T-bug29827"><termdef id="dt-initial-mode" term="initial mode"
                           >The <term>initial mode</term> is the <termref def="dt-mode"
                              >mode</termref> used to select <termref def="dt-template-rule"
                              >template rules</termref> for processing items in the <termref
                              def="dt-initial-match-selection"/> when apply-templates invocation is
                           used to initiate a transformation.</termdef></p>
                     <p>In searching for the <termref def="dt-template-rule">template rule</termref>
                        that best matches the <phrase diff="chg" at="R-bug24764">items in the
                              <termref def="dt-initial-match-selection"/></phrase>, the processor
                        considers only those rules that apply to the <termref def="dt-initial-mode"
                        />.</p>
                     <p>If no <termref def="dt-initial-mode"/> is supplied explicitly, then the
                        initial mode is that named in the <code>default-mode</code> attribute of the
                           <phrase diff="add" at="R-bug24235">(explicit or implicit)
                              <elcode>xsl:package</elcode> element of the <termref
                              def="dt-top-level-package"/></phrase> or in the absence of such an
                        attribute, the <termref def="dt-unnamed-mode"/>.</p>
                     <p diff="add" at="Q">
                        <error spec="XT" type="dynamic" class="DE" code="0044"><p>It is a <termref
                                 def="dt-dynamic-error">dynamic error</termref> if the invocation of
                              the <termref def="dt-stylesheet">stylesheet</termref> specifies an
                                 <termref def="dt-initial-mode"/> when no <phrase diff="chg"
                                 at="R-bug24764"><termref def="dt-initial-match-selection"/> is
                                 supplied (either explicitly, or defaulted to the <termref
                                    def="dt-global-context-item"/>)</phrase>.</p></error>
                     </p>
                     <p diff="add" at="T-bug29827">A (named or unnamed) <termref def="dt-mode"/>
                        <var>M</var> is <term>eligible as an initial mode</term> if one of the
                        following conditions applies, where <var>P</var> is the <termref
                           def="dt-top-level-package"/> of the stylesheet:</p>
                     <olist diff="add" at="T-bug29827">
                        <item>
                           <p><var>M</var> is explicitly declared in an <elcode>xsl:mode</elcode>
                              declaration within <var>P</var>, and has <code>public</code> or
                                 <code>final</code>
                              <termref def="dt-visibility"/> (either by virtue of its
                                 <code>visibility</code> attribute, or by virtue of an
                                 <elcode>xsl:expose</elcode> declaration).</p>
                        </item>
                        <item>
                           <p><var>M</var> is the unnamed mode.</p>
                        </item>
                        <item>
                           <p><var>M</var> is named in the <code>default-mode</code> attribute of
                              the (explicit or implicit) <elcode>xsl:package</elcode> element of
                                 <var>P</var>.</p>
                        </item>
                        <item>
                           <p><var>M</var> is declared in a package used by <var>P</var>, and is
                              given <code>public</code> or <code>final</code>
                              <termref def="dt-visibility"/> in <var>P</var> by means of an
                                 <elcode>xsl:accept</elcode> declaration.</p>
                        </item>
                        <item>
                           <p>The effective value of the <code>declared-modes</code> attribute of
                              the explicit or implicit <elcode>xsl:package</elcode> element of
                                 <var>P</var> is <code>no</code>, and <var>M</var> appears as a
                              mode-name in the <code>mode</code> attribute of a <termref
                                 def="dt-template-rule"/> declared within <var>P</var>.</p>
                        </item>
                     </olist>
                     <p diff="chg" at="T-bug29827">
                        <error spec="XT" type="dynamic" class="DE" code="0045"><p>It is a <termref
                                 def="dt-dynamic-error">dynamic error</termref> if the invocation of
                              the <termref def="dt-stylesheet">stylesheet</termref> specifies an
                                 <termref def="dt-initial-mode"/> and the specified mode is not
                              eligible as an initial mode (as defined above).</p></error>
                     </p>
                  </item>
                  <item>
                     <p diff="add" at="Q">Parameters, which will be passed to the template rules
                        used to process items in the input sequence. The parameters consist of two
                        sets of (QName, value) pairs, one set for <termref def="dt-tunnel-parameter"
                           >tunnel parameters</termref> and one for non-tunnel parameters, in which
                        the QName identifies the name of a parameter and the value provides the
                        value of the parameter. Either or both sets of parameters may be empty. The
                        effect is the same as when a template is invoked using
                           <elcode>xsl:apply-templates</elcode> with an
                           <elcode>xsl:with-param</elcode> child specifying
                           <code>tunnel="yes"</code> or <code>tunnel="no"</code> as appropriate. If
                        a parameter is supplied that is not declared or used, the value is simply
                        ignored. These parameters are <emph>not</emph> used to set <termref
                           def="dt-stylesheet-parameter">stylesheet parameters</termref>.</p>
                     <p diff="add" at="Q">A supplied value is converted if necessary to the declared
                        type of the template parameter using the <termref
                           def="dt-function-conversion-rules"/>.</p>
                  </item>
                  <item diff="add" at="T-bug29431">
                     <p>Details of how the result of the initial template is to be returned. For
                        details, see <specref ref="post-processing"/></p>
                  </item>
               </ulist>
               <p diff="add" at="Q">The <termref def="dt-raw-result"/> of the invocation is the
                  result of processing the supplied input sequence as if by a call on
                     <elcode>xsl:apply-templates</elcode> in the specified mode: specifically, each
                  item in the input sequence is processed by selecting and evaluating the best
                  matching template rule, and converting the result (if necessary) to the type
                  declared in the <code>as</code> attribute of that template using the <termref
                     def="dt-function-conversion-rules"/>; and the results of processing each item
                  are then concatenated into a single sequence, respecting the order of items in the
                  input sequence.</p>
               <note diff="chg" at="C">
                  <p diff="del" at="T-bug29690">If the initial mode is a <termref
                        def="dt-streamable-mode">streamable mode,</termref> then streaming will only
                     be possible if nodes in the input sequence are supplied in a form that allows
                     such processing: for example, as a reference to a stream of parsing events.</p>
                  <p diff="add" at="T-bug29690">If the initial mode is <termref
                        def="dt-declared-streamable"/>, then a streaming processor
                        <rfc2119>should</rfc2119> allow some or all of the items in the <termref
                        def="dt-initial-match-selection"/> to be nodes supplied in streamable form,
                     and any nodes that are supplied in this form <rfc2119>must</rfc2119> then be
                     processed using streaming.</p>
                  <p diff="add" at="T-bug29696">Since the <termref def="dt-global-context-item"/>
                     cannot be a streamed node, in cases where the transformation is to proceed by
                     applying streamable templates to a streamed input document, the <termref
                        def="dt-global-context-item"/> must either be absent, or must be something
                     that differs from the <termref def="dt-initial-match-selection"/>.</p>
               </note>
               <note diff="add" at="E">
                  <p>The design of the API for invoking a transformation should provide some means
                     for users to designate the <termref def="dt-unnamed-mode"/> as the <termref
                        def="dt-initial-mode"/> in cases where it is not the default mode.</p>
               </note>
               <p diff="chg" at="R-bug24864">It is a <termref def="dt-dynamic-error"/>
                  <errorref spec="XT" type="dynamic" class="DE" code="0700"/> if the <termref
                     def="dt-template-rule"/> selected for processing any item in the <termref
                     def="dt-initial-match-selection"/> defines a <termref
                     def="dt-template-parameter"/> that specifies <code>required="yes"</code>
                  <phrase diff="add" at="Q">and no value is supplied for that
                  parameter.</phrase></p>
               <note>
                  <p>A <termref def="dt-stylesheet">stylesheet</termref> can process further source
                     documents in addition to those supplied when the transformation is invoked.
                     These additional documents can be loaded using the functions
                        <function>document</function> (see <specref ref="func-document"/>) or
                        <xfunction>doc</xfunction> or <xfunction>collection</xfunction> (see <bibref
                        ref="xpath-functions-30"/>), <phrase diff="add" at="F">or using the
                           <elcode>xsl:source-document</elcode> instruction</phrase>; alternatively,
                     they can be supplied as <termref def="dt-stylesheet-parameter">stylesheet
                        parameters</termref> (see <specref ref="global-variables"/>), or returned as
                     the result of an <termref def="dt-extension-function">extension
                        function</termref> (see <specref ref="extension-functions"/>).</p>
               </note>
            </div3>
            <div3 id="invoking-initial-template">
               <head>Call-Template Invocation</head>
               <p diff="chg" at="R-bug24864"><termdef id="dt-initial-named-template"
                     term="initial named template">A stylesheet may be evaluated by selecting a
                     named template to be evaluated; this is referred to as the <term>initial named
                        template</term>.</termdef> The effect is analogous to the effect of
                  executing an <elcode>xsl:call-template</elcode> instruction. The following
                  information is needed in this case:</p>
               <ulist>
                  <item>
                     <p>Optionally, the name of the <termref def="dt-initial-named-template">initial
                           named template</termref> which is to be executed as the entry point to
                        the transformation. <phrase diff="add" at="M">If no template name is
                           supplied, the default template name is
                           <code>xsl:initial-template</code>.</phrase> The selected template
                           <rfc2119>must</rfc2119> exist within the <termref def="dt-stylesheet"
                           >stylesheet</termref>. </p>
                  </item>
                  <item>
                     <p diff="add" at="Q">Optionally, a context item for evaluation of this named
                        template, defaulting to the <termref def="dt-global-context-item"/> if it
                        exists. <phrase diff="chg" at="R-bug24864">This is constrained by any
                              <elcode>xsl:context-item</elcode> element appearing within the
                           selected <elcode>xsl:template</elcode> element. The initial named
                           template is evaluated with a <termref def="dt-singleton-focus"/> based on
                           this context item if it exists, or with an <termref def="dt-absent"/>
                           focus otherwise.</phrase></p>
                  </item>
                  <item>
                     <p diff="add" at="Q">Parameters, which will be passed to the selected template
                        rule. The parameters consist of two sets of (QName, value) pairs, one set
                        for <termref def="dt-tunnel-parameter">tunnel parameters</termref> and one
                        for non-tunnel parameters, in which the QName identifies the name of a
                        parameter and the value provides the value of the parameter. Either or both
                        sets of parameters may be empty. The effect is the same as when a template
                        is invoked using <elcode>xsl:call-template</elcode> with an
                           <elcode>xsl:with-param</elcode> child specifying
                           <code>tunnel="yes"</code> or <code>tunnel="no"</code> as appropriate. If
                        a parameter is supplied that is not declared or used, the value is simply
                        ignored. These parameters are <emph>not</emph> used to set <termref
                           def="dt-stylesheet-parameter">stylesheet parameters</termref>.</p>
                     <p diff="add" at="Q">A supplied value is converted if necessary to the declared
                        type of the template parameter using the <termref
                           def="dt-function-conversion-rules"/>.</p>
                  </item>
                  <item diff="add" at="T-bug29431">
                     <p>Details of how the result of the initial named template is to be returned.
                        For details, see <specref ref="post-processing"/></p>
                  </item>
               </ulist>
               <p diff="add" at="Q">The <termref def="dt-raw-result"/> of the invocation is the
                  result of evaluating the <termref def="dt-initial-named-template"/>, after
                  conversion of the result to the type declared in the <code>as</code> attribute of
                  that template using the <termref def="dt-function-conversion-rules"/>, if such
                  conversion is necessary.</p>
               <p diff="add" at="R-bug24864">The <termref def="dt-initial-named-template"/> is
                  evaluated in <termref def="dt-final-output-state"/>.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="0040"><p>It is a <termref
                           def="dt-dynamic-error"><phrase diff="del" at="M">non-recoverable</phrase>
                           dynamic error</termref> if the invocation of the <termref
                           def="dt-stylesheet">stylesheet</termref> specifies a template name that
                        does not match the <termref def="dt-expanded-qname">expanded QName</termref>
                        of a named template defined in the <termref def="dt-stylesheet"
                           >stylesheet</termref>, <phrase diff="add" at="Q">whose visibility is
                              <code>public</code> or <code>final</code></phrase>.</p></error>
               </p>
               <p diff="del" at="Q">
                  <error spec="XT" type="dynamic" class="DE" code="0047"><p>It is a <termref
                           def="dt-dynamic-error"><phrase diff="del" at="M">non-recoverable</phrase>
                           dynamic error</termref> if the invocation of the <termref
                           def="dt-stylesheet">stylesheet</termref> specifies both an initial
                           <termref def="dt-mode">mode</termref> and an initial
                     template.</p></error>
               </p>
               <p diff="del" at="R-bug24864"> The transformation is performed by evaluating an
                     <term>initial template</term>. If a <termref def="dt-named-template">named
                     template</termref> is supplied when the transformation is initiated, then this
                  is the initial template; otherwise, the initial template is the <termref
                     def="dt-template-rule">template rule</termref> selected according to the rules
                  of the <elcode>xsl:apply-templates</elcode> instruction for processing the <phrase
                     diff="chg" at="E"><termref def="dt-global-context-item"/></phrase> in the
                  initial <termref def="dt-mode">mode</termref>. </p>
               <p diff="chg" at="R-bug24539"> It is a <termref def="dt-dynamic-error"><phrase
                        diff="del" at="M">non-recoverable</phrase> dynamic error</termref>
                  <phrase diff="chg" at="R-bug24864"><errorref spec="XT" type="dynamic" class="DE"
                        code="0700"/></phrase> if the <termref def="dt-initial-named-template"
                     >initial named template</termref>, or any of the template rules invoked to
                  process items in the <termref def="dt-initial-match-selection"/>, defines a
                     <termref def="dt-template-parameter">template parameter</termref> that
                  specifies <code>required="yes"</code>
                  <phrase diff="add" at="Q">and no value is supplied for that parameter.</phrase>
               </p>
            </div3>
            <div3 id="invoking-initial-function" diff="add" at="Q">
               <head>Function Call Invocation</head>
               <p diff="chg" at="R-bug24864"><termdef id="dt-initial-function"
                     term="initial function">A stylesheet may be evaluated by calling a named
                        <termref def="dt-stylesheet-function"/>, referred to as the <term>initial
                        function</term>.</termdef> The following additional information is needed in
                  this case:</p>
               <ulist>
                  <item>
                     <p>The name and arity of a <termref def="dt-stylesheet-function"/> which is to
                        be executed as the entry point to the transformation.</p>
                     <note>
                        <p>In the design of a concrete API, the arity may be inferred from the
                           length of the parameter list.</p>
                     </note>
                  </item>
                  <item>
                     <p>A list of values to act as parameters to the <termref
                           def="dt-initial-function"/>. The number of values in the list must be the
                        same as the arity of the function.</p>
                     <p diff="add" at="Q">A supplied value is converted if necessary to the declared
                        type of the function parameter using the <termref
                           def="dt-function-conversion-rules"/>.</p>
                  </item>
                  <item diff="add" at="T-bug29431">
                     <p>Details of how the result of the initial function is to be returned. For
                        details, see <specref ref="post-processing"/></p>
                  </item>
               </ulist>
               <p diff="add" at="Q">The <termref def="dt-raw-result"/> of the invocation is the
                  result of evaluating the <termref def="dt-initial-function"/>, after conversion of
                  the result to the type declared in the <code>as</code> attribute of that function
                  using the <termref def="dt-function-conversion-rules"/>, if such conversion is
                  necessary.</p>
               <note>
                  <p> The <termref def="dt-initial-function"/> (like all stylesheet functions) is
                     evaluated with an <termref def="dt-absent"/>
                     <termref def="dt-focus"/>.</p>
               </note>
               <p diff="add" at="T-bug29690">If the <termref def="dt-initial-function"/> is <termref
                     def="dt-declared-streamable"/>, a streaming processor <rfc2119>should</rfc2119>
                  allow the value of the first argument to be supplied in streamable form, and if it
                  is supplied in this form, then it <rfc2119>must</rfc2119> be processed using
                  streaming.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="0041"><p>It is a <termref
                           def="dt-dynamic-error"/> if the invocation of the <termref
                           def="dt-stylesheet">stylesheet</termref> specifies a function name and
                        arity that does not match the <termref def="dt-expanded-qname">expanded
                           QName</termref> and arity of a named <termref
                           def="dt-stylesheet-function"/> defined in the <termref
                           def="dt-stylesheet">stylesheet</termref>, whose visibility is
                           <code>public</code> or <code>final</code>.</p></error>
               </p>
               <p diff="del" at="Q">
                  <error spec="XT" type="dynamic" class="DE" code="0047"><p>It is a <termref
                           def="dt-dynamic-error"><phrase diff="del" at="M">non-recoverable</phrase>
                           dynamic error</termref> if the invocation of the <termref
                           def="dt-stylesheet">stylesheet</termref> specifies both an initial
                           <termref def="dt-mode">mode</termref> and an <termref
                           def="dt-initial-named-template"/>.</p></error>
               </p>
               <p diff="add" at="R-bug24690">When a transformation is invoked by calling an <termref
                     def="dt-initial-function"/>, the entire transformation executes in <termref
                     def="dt-temporary-output-state"/>, which means that calls on
                     <elcode>xsl:result-document</elcode> are not permitted.</p>
            </div3>
            <div3 id="post-processing">
               <head>Post-processing the Raw Result</head>
               <p diff="add" at="T-bug29431">There are three ways the result of a transformation may
                  be delivered. (This applies both to the principal result, described here, and also
                  to secondary results, generated using <elcode>xsl:result-document</elcode>.)</p>
               <olist diff="add" at="T-bug29431">
                  <item>
                     <p>The <termref def="dt-raw-result"/> (a sequence of values) may be returned
                        directly to the calling application.</p>
                  </item>
                  <item>
                     <p>A result tree may be constructed from the <termref def="dt-raw-result"/>. By
                        default, a result tree is constructed if the <code>build-tree</code>
                        attribute of the unnamed <termref def="dt-output-definition"/> has the
                        effective value <code>yes</code>. An API for invoking transformations
                           <rfc2119>may</rfc2119> allow this setting to be overridden by the calling
                        application. If result tree construction is requested, it is performed as
                        described in <specref ref="result-tree-construction"/>. </p>
                  </item>
                  <item>
                     <p>Alternatively, the <termref def="dt-raw-result"/> may be serialized as
                        described in <specref ref="result-serialization"/>. The decision whether or
                        not to serialize the result is determined by the rules of transformation API
                        provided by the <termref def="dt-processor"/>, and is not influenced by
                        anything in the stylesheet.</p>
                  </item>
               </olist>
               <note>
                  <p>This specification does not constrain the design of application programming
                     interfaces or the choice of defaults. In previous versions of this
                     specification, result tree construction was a mandatory process, while
                     serialization was optional. When invoking stylesheet functions directly,
                     however, result tree construction and serialization may be inappropriate as
                     defaults. These considerations may affect the design of APIs.</p>
                  <p diff="add" at="T-bug29431">In previous versions of XSLT, results were delivered
                     either in serialized form (as a character or byte stream), or as a tree. In the
                     latter case processors typically would use either their own tree
                     representation, or a standardized tree representation such as the W3C Document
                     Object Model (DOM) (see <bibref ref="DOM-Level-2-Core"/>), adapted to the data
                     structures offered by the programming language in which the API is defined. To
                     deliver a raw result, processors need to define a representation not only of
                     XDM nodes but also of sequences, atomic values, maps and even functions. As
                     with the return of a simple tree, this may involve a trade-off between strict
                     fidelity to the XDM data model and usability in the particular programming
                     language environment. It is <emph>not</emph> a requirement that an API should
                     return results in a way that exposes every property of the XDM data model; for
                     example there may be APIs that do not expose the precise type annotation of a
                     returned node or atomic value, or that fail to expose the base URI or document
                     URI of a node, or that provide no way of determining whether two nodes in the
                     result sequence are the same node in the sense of the XPath <code>is</code>
                     operator. The way in which maps and functions (and where XPath 3.1 is
                     supported, arrays) are returned requires careful design choices. It is
                        <rfc2119>recommended</rfc2119> that an API should be capable of returning
                     any XDM value without error, and that there should be minimal loss of
                     information if the raw results output by one transformation are subsequently
                     used as input to another transformation.</p>
               </note>
               <div4 id="result-tree-construction">
                  <head>Result Tree Construction</head>
                  <p diff="chg" at="T-bug29431">If a result tree is to be constructed from the
                        <termref def="dt-raw-result"/>, then this is done by applying the rules for
                     the process of <xtermref spec="SER30" ref="sequence-normalization"/> as defined
                     in <bibref ref="xslt-xquery-serialization-30"/>. This process takes as input
                     the serialization parameters defined in the unnamed <termref
                        def="dt-output-definition"/> of the <termref def="dt-top-level-package"/>;
                     though the only parameter that is actually used by this process is
                        <code>item-separator</code>. In particular, sequence normalization is
                     carried out regardless of any <code>method</code> attribute in the unnamed
                        <termref def="dt-output-definition"/>.</p>
                  <p diff="chg" at="T-bug29431">The sequence normalization process either returns a
                     document node, or raises a serialization error. The content of the document
                     node is not necessarily well-formed (the document node may have any number of
                     element or text nodes among its children).</p>
                  <note>
                     <p>More specifically, the process raises a serialization error if any item in
                        the <termref def="dt-raw-result"/> is an attribute node, a namespace node,
                        or a function (including a map, <phrase diff="chg" at="V-bug30089">but not
                           an array: arrays are flattened</phrase>).</p>
                  </note>
                  <p>The tree that is constructed is referred to as a <termref
                        def="dt-final-result-tree">final result tree</termref>.</p>
                  <p>If the <termref def="dt-raw-result"/> is an empty sequence, the <termref
                        def="dt-final-result-tree"/> will consist of a document node with no
                     children.</p>
                  <p diff="chg" at="T-bug29432">The base URI of the document node is set to the
                        <termref def="dt-base-output-uri"/>.</p>
                  <note diff="add" at="T-bug29431">
                     <p>The <code>item-separator</code> property has no effect if the raw result of
                        the transformation is a sequence of length zero or one, which in practice
                        will often be the case, especially in a traditional scenario such as
                        transformation of an XML document to HTML.</p>
                     <p>If there is no <code>item-separator</code>, then a single space is inserted
                        between adjacent atomic values; for example if the raw result is the
                        sequence <code>1 to 5</code>, then sequence normalization produces a tree
                        comprising a document node with a single child, the child being a text node
                        with the string value <code>1 2 3 4 5</code>.</p>
                     <p>If there is an <code>item-separator</code>, then it is used not only between
                        adjacent atomic values, but between any pair of items in the raw result. For
                        example if the raw result is a sequence of two element nodes <code>A</code>
                        and <code>B</code>, and the <code>item-separator</code> is a comma, then the
                        result of sequence normalization will be a document node with three
                        children: a copy of <code>A</code>, a text node whose string value is a
                        single comma, and a copy of <code>B</code>.</p>
                  </note>
               </div4>
               <div4 id="result-serialization">
                  <head>Serializing the Result</head>
                  <p>See <specref ref="parsing-and-serialization"/>.</p>
                  <p diff="chg" at="T-bug29431">The <termref def="dt-raw-result"/> may optionally be
                     serialized as described in <specref ref="serialization"/>. The serialization is
                     controlled by the serialization parameters defined in the unnamed <termref
                        def="dt-output-definition"/> of the <termref def="dt-top-level-package"
                     />.</p>
                  <note diff="add" at="T-bug29431">
                     <p>The first phase of serialization, called <xtermref spec="SER30"
                           ref="sequence-normalization"/>, takes place for some output methods but
                        not others. For example, if the <code>json</code> output method (defined in
                           <bibref ref="xslt-xquery-serialization-31"/>) is selected, then the
                        process of constructing a tree is bypassed.</p>
                  </note>
                  <p diff="chg" at="T-bug29431">The effect of serialization is to generate a
                     sequence of octets, representing the serialized result in some character
                     encoding. The processor’s API may define mechanisms enabling this sequence of
                     octets to be written to persistent storage at some location. The default
                     location is the location identified by the <termref def="dt-base-output-uri"
                     />.</p>
                  <note diff="del">
                     <p>The first phase of serialization, called <term>sequence
                        normalization</term>, has no effect if the supplied value is a single
                        document node, which will be the case if serialization is preceded by result
                        tree construction. In the case of any other supplied value, the effect of
                        sequence normalization is very similar to the effect of result tree
                        construction, except where an <code>item-separator</code> serialization
                        parameter is present. Use of <code>item-separator</code> allows, for
                        example, a sequence of strings returned by invoking a stylesheet function to
                        be output with newline separators. </p>
                  </note>
                  <p diff="chg" at="T-bug29431">In previous versions of this specification it was
                     stated that when the <termref def="dt-raw-result"/> of the initial template or
                     function is an empty sequence, a result tree should be produced if and only if
                     the transformation generates no secondary results (that is, if it does not
                     invoke <elcode>xsl:result-document</elcode>). This provision is most likely to
                     have a noticeable effect if the transformation produces serialized results, and
                     these results are written to persistent storage: the effect is then that a
                     transformation producing an empty principal result will overwrite any existing
                     content at the base output URI location if and only if the transformation
                     produces no other output. Processor APIs offering backwards compatibility with
                     earlier versions of XSLT must respect this behavior, but there is no
                     requirement for new processor APIs to do so.</p>
                  <p diff="chg" at="R-bug24551"><termdef id="dt-base-output-uri"
                        term="base output URI"> The <term>base output URI</term> is a URI to be used
                        as the base URI when resolving a relative URI <phrase diff="add" at="F"
                           >reference</phrase> allocated to a <termref def="dt-final-result-tree"
                           >final result tree</termref>. If the transformation generates more than
                        one final result tree, then typically each one will be allocated a URI
                        relative to this base URI.</termdef> The way in which a base output URI is
                     established is <termref def="dt-implementation-defined"
                        >implementation-defined</termref>. Each invocation of the stylesheet may
                     supply a different base output URI. It is acceptable for the base output URI to
                     be <termref def="dt-absent"/>, provided no constructs (such as
                        <elcode>xsl:result-document</elcode>) are evaluated that depend on the value
                     of the base output URI.</p>
                  <note diff="add" at="R-bug24551">
                     <p>It will often be convenient for the base output URI to be the same as the
                        location to which the principal result document is serialized, but this
                        relationship is not a necessary one.</p>
                  </note>
                  <imp-def-feature id="idf-api-baseoutputuri">The way in which a <termref
                        def="dt-base-output-uri"/> is established is <termref
                        def="dt-implementation-defined"
                     >implementation-defined</termref></imp-def-feature>
               </div4>
            </div3>
         </div2>
         <div2 id="executing-a-transformation" diff="add" at="T-bug29669">
            <head>Instructions</head>
            <p>The main executable components of a stylesheet are templates and functions. The body
               of a template or function is a <termref def="dt-sequence-constructor"/>, which is a
               sequence of elements and text nodes that can be evaluated to produce a result.</p>
            <p>A <termref def="dt-sequence-constructor"/> is a sequence of sibling nodes in the
               stylesheet, each of which is either an <termref def="dt-xslt-instruction">XSLT
                  instruction</termref>, a <termref def="dt-literal-result-element">literal result
                  element</termref>, a text node, or an <termref def="dt-extension-instruction"
                  >extension instruction</termref>.</p>
            <p>
               <termdef id="dt-instruction" term="instruction">An <term>instruction</term> is either
                  an <termref def="dt-xslt-instruction">XSLT instruction</termref> or an <termref
                     def="dt-extension-instruction">extension instruction</termref>.</termdef>
            </p>
            <p>
               <termdef id="dt-xslt-instruction" term="XSLT instruction">An <term>XSLT
                     instruction</term> is an <termref def="dt-xslt-element">XSLT element</termref>
                  whose syntax summary in this specification contains the annotation <code>&lt;!--
                     category: instruction --&gt;</code>.</termdef>
            </p>
            <p>
               <termref def="dt-extension-instruction">Extension instructions</termref> are
               described in <specref ref="extension-instruction"/>.</p>
            <p>The main categories of <termref def="dt-xslt-instruction">XSLT instruction</termref>
               are as follows:</p>
            <ulist>
               <item>
                  <p>instructions that create new nodes: <elcode>xsl:document</elcode>,
                        <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                        <elcode>xsl:processing-instruction</elcode>, <elcode>xsl:comment</elcode>,
                        <elcode>xsl:value-of</elcode>, <elcode>xsl:text</elcode>,
                        <elcode>xsl:namespace</elcode>;</p>
               </item>
               <item diff="add" at="S-bug28865">
                  <p>instructions that copy nodes: <elcode>xsl:copy</elcode>,
                        <elcode>xsl:copy-of</elcode>;</p>
               </item>
               <item>
                  <p>an instruction that returns an arbitrary sequence by evaluating an XPath
                     expression: <elcode>xsl:sequence</elcode>;</p>
               </item>
               <item>
                  <p>instructions that cause conditional or repeated evaluation of nested
                     instructions: <elcode>xsl:if</elcode>, <elcode>xsl:choose</elcode>, <phrase
                        diff="add" at="F"><elcode>xsl:try</elcode>,</phrase>
                     <elcode>xsl:for-each</elcode>, <elcode>xsl:for-each-group</elcode>, <phrase
                        diff="add" at="F"><elcode>xsl:fork</elcode>, <elcode>xsl:iterate</elcode>
                        and its subordinate instructions <elcode>xsl:next-iteration</elcode> and
                           <elcode>xsl:break</elcode></phrase>;</p>
               </item>
               <item diff="add" at="S-bug28865">
                  <p>instructions that generate output conditionally if elements are or are not
                     empty: <elcode>xsl:on-empty</elcode>, <elcode>xsl:on-non-empty</elcode>,
                        <elcode>xsl:where-populated</elcode>;</p>
               </item>
               <item>
                  <p>instructions that invoke templates: <elcode>xsl:apply-templates</elcode>,
                        <elcode>xsl:apply-imports</elcode>, <elcode>xsl:call-template</elcode>,
                        <elcode>xsl:next-match</elcode>;</p>
               </item>
               <item>
                  <p>Instructions that declare variables: <elcode>xsl:variable</elcode><phrase
                        diff="del" at="S-bug28865">, <elcode>xsl:param</elcode></phrase>;</p>
               </item>
               <item>
                  <p>Instructions to assist debugging: <elcode>xsl:message</elcode>,
                        <elcode>xsl:assert</elcode>;</p>
               </item>
               <item>
                  <p>other specialized instructions: <elcode>xsl:number</elcode>,
                        <elcode>xsl:analyze-string</elcode>, <phrase diff="add" at="S-bug28865"
                           ><elcode>xsl:fork</elcode>, </phrase>
                     <elcode>xsl:result-document</elcode>, <phrase diff="add" at="F"
                           ><elcode>xsl:source-document</elcode>, <elcode>xsl:perform-sort</elcode>,
                           <elcode>xsl:merge</elcode></phrase>.</p>
               </item>
            </ulist>
         </div2>
         <div2 id="rule-based-processing" diff="add" at="T-bug29669">
            <head>Rule-Based Processing</head>
            <p diff="chg" at="Q">The classic method of executing an XSLT transformation is to apply
               template rules to the root node of an input document (see <specref
                  ref="invoking-initial-mode"/>). The operation of applying templates to a node
               searches the stylesheet for the best matching template rule for that node. This
               template rule is then evaluated. A common coding pattern, especially when XSLT is
               used to convert XML documents into display formats such as HTML, is to have one
               template rule for each kind of element in the source document, and for that template
               rule to generate some appropriate markup elements, and to apply templates recursively
               to its own children. The effect is to perform a recursive traversal of the source
               tree, in which each node is processed using the best-fit template rule for that node.
               The final result of the transformation is then the tree produced by this recursive
               process. This result can then be optionally serialized (see <specref
                  ref="post-processing"/>). </p>
            <example id="rule-based-processing-example">
               <head>Example of Rule-Based Processing</head>
               <p>This example uses rule-based processing to convert a simple XML input document
                  into an HTML output document.</p>
               <p>The input document takes the form:</p>
               <eg role="xml" xml:space="preserve">

  &lt;PERSONAE PLAY="OTHELLO"&gt;
    &lt;TITLE&gt;Dramatis Personae&lt;/TITLE&gt;
    &lt;PERSONA&gt;DUKE OF VENICE&lt;/PERSONA&gt;
    &lt;PERSONA&gt;BRABANTIO, a senator.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;Other Senators.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;GRATIANO, brother to Brabantio.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;LODOVICO, kinsman to Brabantio.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;OTHELLO, a noble Moor in the service of the Venetian state.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;CASSIO, his lieutenant.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;IAGO, his ancient.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;RODERIGO, a Venetian gentleman.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;MONTANO, Othello's predecessor in the government of Cyprus.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;Clown, servant to Othello. &lt;/PERSONA&gt;
    &lt;PERSONA&gt;DESDEMONA, daughter to Brabantio and wife to Othello.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;EMILIA, wife to Iago.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;BIANCA, mistress to Cassio.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;Sailor, Messenger, Herald, Officers, 
             Gentlemen, Musicians, and Attendants.&lt;/PERSONA&gt;
  &lt;/PERSONAE&gt;</eg>
               <p>The stylesheet to render this as HTML can be written as a set of template
                  rules:</p>
               <eg role="xslt" xml:space="preserve">
 &lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    version="3.0"
    expand-text="yes"&gt;
    
 &lt;xsl:strip-space elements="PERSONAE"/&gt;   
    
 &lt;xsl:template match="PERSONAE"&gt;
   &lt;html&gt;
     &lt;head&gt;
       &lt;title&gt;The Cast of {@PLAY}&lt;/title&gt;
     &lt;/head&gt;
     &lt;body&gt;
       &lt;xsl:apply-templates/&gt;
     &lt;/body&gt;
   &lt;/html&gt;
 &lt;/xsl:template&gt;
 
 &lt;xsl:template match="TITLE"&gt;
   &lt;h1&gt;{.}&lt;/h1&gt;
 &lt;/xsl:template&gt;
 
 &lt;xsl:template match="PERSONA[count(tokenize(., ',') = 2]"&gt;
   &lt;p&gt;&lt;b&gt;{substring-before(., ',')}&lt;/b&gt;: {substring-after(., ',')}&lt;/p&gt;
 &lt;/xsl:template&gt; 

 &lt;xsl:template match="PERSONA"&gt;
   &lt;p&gt;&lt;b&gt;{.}&lt;/b&gt;&lt;/p&gt;
 &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg>
               <p>There are four template rules here:</p>
               <ulist>
                  <item>
                     <p>The first rule matches the outermost element, named <code>PERSONAE</code>
                        (it could equally have used <code>match="/"</code> to match the document
                        node). The effect of this rule is to create the skeleton of the output HTML
                        page. Technically, the body of the template is a sequence constructor
                        comprising a single <termref def="dt-literal-result-element"/> (the
                           <code>html</code> element); this in turn contains a sequence constructor
                        comprising two literal result elements (the <code>head</code> and
                           <code>body</code> elements). The <code>head</code> element is populated
                        with a literal <code>title</code> element whose content is computed as a
                        mixture of fixed and variable text using a <termref
                           def="dt-text-value-template"/>. The <code>body</code> element is
                        populated by evaluating an <elcode>xsl:apply-templates</elcode>
                        instruction.</p>
                     <p>The effect of the <elcode>xsl:apply-templates</elcode> instruction is to
                        process the children of the <code>PERSONAE</code> element in the source
                        tree: that is, the <code>TITLE</code> and <code>PERSONA</code> elements. (It
                        would also process any whitespace text node children, but these have been
                        stripped by virtue of the <elcode>xsl:strip-space</elcode> declaration.)
                        Each of these child elements is processed by the best matching template rule
                        for that element, which will be one of the other three rules in the
                        stylesheet.</p>
                  </item>
                  <item>
                     <p>The template rule for the <code>TITLE</code> element outputs an
                           <code>h1</code> element to the HTML result document, and populates this
                        with the value of ".", the context item. That is, it copies the text content
                        of the <code>TITLE</code> element to the output <code>h1</code> element.</p>
                  </item>
                  <item>
                     <p>The last two rules match <code>PERSONA</code> element. The first rule
                        matches <code>PERSONA</code> elements whose text content contains exactly
                        one comma; the second rule matches all <code>PERSONA</code> elements, but it
                        has lower priority than the first rule, so in practice it only applies to
                           <code>PERSONA</code> elements that contain no comma or multiple
                        commas.</p>
                     <p>For both rules the body of the rule is a sequence constructor containing a
                        single literal result element, the <code>p</code> element. These literal
                        result elements contain further sequence constructors comprising literal
                        result elements and text nodes. In each of these examples the text nodes are
                        in the form of a <termref def="dt-text-value-template"/>: in general this is
                        a combination of fixed text together with XPath expressions enclosed in
                        curly braces, which are evaluated to form the content of the containing
                        literal result element. </p>
                  </item>
               </ulist>
            </example>
            <p>
               <termdef id="dt-template-rule" term="template rule">A stylesheet contains a set of
                     <term>template rules</term> (see <specref ref="rules"/>). A template rule has
                  three parts: a <termref def="dt-pattern">pattern</termref> that is matched against
                  selected items (often but not necessarily nodes), a (possibly empty) set of
                     <termref def="dt-template-parameter">template parameters</termref>, and a
                     <termref def="dt-sequence-constructor">sequence constructor</termref> that is
                  evaluated to produce a sequence of items.</termdef> In many cases these items are
               newly constructed nodes, which are then written to a <termref def="dt-result-tree"
                  >result tree</termref>.</p>
         </div2>
         <div2 id="context">
            <head>The Evaluation Context</head>
            <p>The results of some expressions and instructions in a stylesheet may depend on
               information provided contextually. This context information is divided into two
               categories: the static context, which is known during static analysis of the
               stylesheet, and the dynamic context, which is not known until the stylesheet is
               evaluated. Although information in the static context is known at analysis time, it
               is sometimes used during stylesheet evaluation.</p>
            <p>Some context information can be set by means of declarations within the stylesheet
               itself. For example, the namespace bindings used for any XPath expression are
               determined by the namespace declarations present in containing elements in the
               stylesheet. Other information may be supplied externally or implicitly: an example is
               the current date and time.</p>
            <p>The context information used in processing an XSLT stylesheet includes as a subset
               all the context information required when evaluating XPath expressions. The <phrase
                  diff="chg" at="D">XPath 3.0</phrase> specification defines a static and dynamic
               context that the host language (in this case, XSLT) may initialize, which affects the
               results of XPath expressions used in that context. XSLT augments the context with
               additional information: this additional information is used firstly by XSLT
               constructs outside the scope of XPath (for example, the <elcode>xsl:sort</elcode>
               element), and secondly, by functions that are defined in the XSLT specification (such
               as <function>key</function> and <function>current-group</function>) that are
               available for use in XPath expressions appearing within a stylesheet.</p>
            <p>The static context for an expression or other construct in a stylesheet is determined
               by the place in which it appears lexically. The details vary for different components
               of the static context, but in general, elements within a stylesheet module affect the
               static context for their descendant elements within the same stylesheet module.</p>
            <p>The dynamic context is maintained as a stack. When an instruction or expression is
               evaluated, it may add dynamic context information to the stack; when evaluation is
               complete, the dynamic context reverts to its previous state. An expression that
               accesses information from the dynamic context always uses the value at the top of the
               stack.</p>
            <p>The most commonly used component of the dynamic context is the <termref
                  def="dt-context-item">context item</termref>. This is an implicit variable whose
               value is the item currently being processed (it may be a node, an atomic value,
                  <phrase diff="add" at="C">or a function item</phrase>). The value of the context
               item can be referenced within an XPath expression using the expression <code>.</code>
               (dot).</p>
            <p>Full details of the static and dynamic context are provided in <specref
                  ref="static-and-dynamic-context"/>.</p>
         </div2>
         <div2 id="parsing-and-serialization">
            <head>Parsing and Serialization</head>
            <p diff="del" at="S-bug27258">An XSLT <termref def="dt-stylesheet">stylesheet</termref>
               describes a process that constructs a set of <termref def="dt-final-result-tree"
                  >final result trees</termref> from a set of <termref def="dt-source-tree">source
                  trees</termref>.</p>
            <p diff="add" at="S-bug27258">An XSLT <termref def="dt-stylesheet">stylesheet</termref>
               describes a process that constructs a set of results from a set of inputs. The inputs
               are the data provided at stylesheet invocation, as described in <specref
                  ref="initiating"/>. The results include the <termref def="dt-principal-result"/>
               (an arbitrary sequence), which is the result of the initial component invocation,
               together with any <termref def="dt-secondary-result">secondary results</termref>
               produced using <elcode>xsl:result-document</elcode> instructions. </p>
            <p>The <termref def="dt-stylesheet">stylesheet</termref> does not describe how a
                  <termref def="dt-source-tree">source tree</termref> is constructed. Some possible
               ways of constructing source trees are described in <bibref ref="xpath-datamodel-30"
               />. Frequently an <termref def="dt-implementation">implementation</termref> will
               operate in conjunction with an XML parser (or more strictly, in the terminology of
                  <bibref ref="REC-xml"/>, an <emph>XML processor</emph>), to build a source tree
               from an input XML document. An implementation <rfc2119>may</rfc2119> also provide an
               application programming interface allowing the tree to be constructed directly, or
               allowing it to be supplied in the form of a DOM Document object (see <bibref
                  ref="DOM-Level-2-Core"/>). This is outside the scope of this specification. Users
               should be aware, however, that since the input to the transformation is a tree
               conforming to the XDM data model as described in <bibref ref="xpath-datamodel-30"/>,
               constructs that might exist in the original XML document, or in the DOM, but which
               are not within the scope of the data model, cannot be processed by the <termref
                  def="dt-stylesheet">stylesheet</termref> and cannot be guaranteed to remain
               unchanged in the transformation output. Such constructs include CDATA section
               boundaries, the use of entity references, and the DOCTYPE declaration and internal
               DTD subset.</p>
            <p>
               <termdef id="dt-serialization" term="serialization">A frequent requirement is to
                  output a <termref def="dt-final-result-tree">final result tree</termref> as an XML
                  document (or in other formats such as HTML). This process is referred to as
                     <term>serialization</term>.</termdef>
            </p>
            <p>Like parsing, serialization is not part of the transformation process, and it is not
                  <rfc2119>required</rfc2119> that an XSLT processor <rfc2119>must</rfc2119> be able
               to perform serialization. However, for pragmatic reasons, this specification
               describes declarations (the <elcode>xsl:output</elcode> element and the
                  <elcode>xsl:character-map</elcode> declarations, see <specref ref="serialization"
               />), and attributes on the <elcode>xsl:result-document</elcode> instruction, that
               allow a <termref def="dt-stylesheet">stylesheet</termref> to specify the desired
               properties of a serialized output file. When serialization is not being performed,
               either because the implementation does not support the serialization option, or
               because the user is executing the transformation in a way that does not invoke
               serialization, then the content of the <elcode>xsl:output</elcode> and
                  <elcode>xsl:character-map</elcode> declarations has no effect. Under these
               circumstances the processor <rfc2119>may</rfc2119> report any errors in an
                  <elcode>xsl:output</elcode> or <elcode>xsl:character-map</elcode> declaration, or
               in the serialization attributes of <elcode>xsl:result-document</elcode>, but is not
                  <rfc2119>required</rfc2119> to do so.</p>
         </div2>
         <div2 id="packages-and-modules" diff="add" at="I">
            <head>Packages and Modules</head>
            <p>In previous versions of the XSLT language, it has been possible to structure a
               stylesheet as a collection of modules, using the <elcode>xsl:include</elcode> and
                  <elcode>xsl:import</elcode> declarations to express the dependency of one module
               on others.</p>
            <p>In XSLT 3.0 an additional layer of modularization of stylesheet code is enabled
               through the introduction of <termref def="dt-package">packages</termref>. A package
               is a collection of stylesheet modules with a controlled interface to the packages
               that use it: for example, it defines which functions and templates defined in the
               package are visible to callers, which are purely internal, and which are not only
               public but capable of being overridden by other functions and templates supplied by
               the using package.</p>
            <p>Packages are introduced with several motivations, which broadly divide into two
               categories:</p>
            <olist>
               <item>
                  <p>Software engineering benefits: greater re-use of code, greater robustness
                     through ease of testing, controlled evolution of code in response to new
                     requirements, ability to deliver code that users cannot see or modify.</p>
               </item>
               <item>
                  <p>Efficiency benefits: the ability to avoid compiling libraries repeatedly when
                     they are used in multiple stylesheets, and to avoid holding multiple copies of
                     the same library in memory simultaneously.</p>
               </item>
            </olist>
            <p>Packages are designed to allow separate compilation: that is, a package can be
               compiled independently of the packages that use it. This specification does not
               define a process model for compilation, or expand on what it means to compile
               different packages independently. Nor does it mandate that implementations offer any
               feature along these lines. It merely defines language features that are designed to
               make separate compilation of packages possible.</p>
            <p>To achieve this, packages (unlike modules):</p>
            <ulist>
               <item>
                  <p>Must not contain unresolved references to functions, templates, or variables
                     declared in other packages;</p>
               </item>
               <item>
                  <p>Have strict rules governing the ability to override declarations in a <termref
                        def="dt-library-package">library package</termref> with declarations in a
                     package that uses the library;</p>
               </item>
               <item>
                  <p>Constrain the visibility of component names and of context declarations such as
                     the declarations of keys and decimal formats;</p>
               </item>
               <item>
                  <p>Can declare a mode (a collection of template rules) as final, which disallows
                     the addition of new overriding template rules in a using package;</p>
               </item>
               <item>
                  <p>Require explicit disambiguation where naming conflicts arise, for example when
                     a package uses two other packages that both export like-named components;</p>
               </item>
               <item>
                  <p>Allow multiple specializations of library components to coexist in the same
                     application.</p>
               </item>
            </ulist>
            <p diff="chg" at="R-bug26468">A package is defined <phrase diff="add" at="T-bug29460">in
                  XSLT</phrase> by means of an XML document whose outermost element is an
                  <elcode>xsl:package</elcode> element. This is referred to as the <termref
                  def="dt-package-manifest"/>. The <elcode>xsl:package</elcode> element has optional
               child elements <elcode>xsl:use-package</elcode> and <elcode>xsl:expose</elcode>
               describing properties of the package. The package manifest may refer to an external
               top-level stylesheet module using an <elcode>xsl:include</elcode> or
                  <elcode>xsl:import</elcode> declaration, or it may contain the body of a
               stylesheet module inline (the two approaches can also be mixed).</p>
            <p diff="add" at="T-bug29460">Although this specification defines packages as constructs
               written using a defined XSLT syntax, implementations <rfc2119>may</rfc2119> provide
               mechanisms that allow packages to be written using other languages (for example,
               XQuery).</p>
            <p diff="chg" at="R-bug26468">When no packages are explicitly defined, the entire
               stylesheet is treated as a single package; the effect is as if the
                  <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element of the
                  <termref def="dt-principal-stylesheet-module">principal stylesheet
                  module</termref> were replaced by an <elcode>xsl:package</elcode> element with no
               other information in the package manifest.</p>
         </div2>
         <div2 id="extensibility">
            <head>Extensibility</head>
            <p>XSLT defines a number of features that allow the language to be extended by
               implementers, or, if implementers choose to provide the capability, by users. These
               features have been designed, so far as possible, so that they can be used without
               sacrificing interoperability. Extensions other than those explicitly defined in this
               specification are not permitted.</p>
            <p>These features are all based on XML namespaces; namespaces are used to ensure that
               the extensions provided by one implementer do not clash with those of a different
               implementer.</p>
            <p>The most common way of extending the language is by providing additional functions,
               which can be invoked from XPath expressions. These are known as <termref
                  def="dt-extension-function">extension functions</termref>, and are described in
                  <specref ref="extension-functions"/>.</p>
            <p>It is also permissible to extend the language by providing new <termref
                  def="dt-instruction">instructions</termref>. These are referred to as <termref
                  def="dt-extension-instruction">extension instructions</termref>, and are described
               in <specref ref="extension-instruction"/>. A stylesheet that uses extension
               instructions in a particular namespace must declare that it is doing so by using the
                  <code>[xsl:]extension-element-prefixes</code> attribute.</p>
            <p>Extension instructions and extension functions defined according to these rules
                  <rfc2119>may</rfc2119> be provided by the implementer of the XSLT processor, and
               the implementer <rfc2119>may</rfc2119> also provide facilities to allow users to
               create further extension instructions and extension functions.</p>
            <p>This specification defines how extension instructions and extension functions are
               invoked, but the facilities for creating new extension instructions and extension
               functions are <termref def="dt-implementation-defined"
                  >implementation-defined</termref>. For further details, see <specref
                  ref="extension"/>.</p>
            <imp-def-feature id="idf-ext-mechanisms">The mechanisms for creating new <termref
                  def="dt-extension-instruction">extension instructions</termref> and <termref
                  def="dt-extension-function">extension functions</termref> are <termref
                  def="dt-implementation-defined"/>. It is not <rfc2119>required</rfc2119> that
               implementations provide any such mechanism.</imp-def-feature>
            <p>The XSLT language can also be extended by the use of <termref
                  def="dt-extension-attribute">extension attributes</termref> (see <specref
                  ref="extension-attributes"/>), and by means of <termref def="dt-data-element"
                  >user-defined data elements</termref> (see <specref ref="user-defined-top-level"
               />).</p>
         </div2>
         <div2 id="stylesheets-and-schemas">
            <head>Stylesheets and XML Schemas</head>
            <p>An XSLT <termref def="dt-stylesheet">stylesheet</termref> can make use of information
               from a schema. An XSLT transformation can take place in the absence of a schema (and,
               indeed, in the absence of a DTD), but where the source document has undergone schema
               validity assessment, the XSLT processor has access to the type information associated
               with individual nodes, not merely to the untyped text.</p>
            <p>Information from a schema can be used both statically (when the <termref
                  def="dt-stylesheet">stylesheet</termref> is compiled), and dynamically (during
               evaluation of the stylesheet to transform a source document).</p>
            <p>There are places within a <termref def="dt-stylesheet">stylesheet</termref>, and
               within XPath <termref def="dt-expression">expressions</termref> and <termref
                  def="dt-pattern">patterns</termref> in a <termref def="dt-stylesheet"
                  >stylesheet</termref>, where it is possible to refer to named type definitions in
               a schema, or to element and attribute declarations. For example, it is possible to
               declare the types expected for the parameters of a function. This is done using a
                  <termref def="dt-sequence-type"/>.</p>
            <p diff="add" at="S-bug29079"><termdef id="dt-sequence-type" term="SequenceType">A
                     <term>SequenceType</term> constrains the type and number of items in a
                  sequence. The term is used both to denote the concept, and to refer to the
                  syntactic form in which sequence types are expressed in the XPath grammar:
                  specifically <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                     ref="prod-xpath30-SequenceType" xlink:type="simple">SequenceType</xnt> in
                     <bibref ref="xpath-30"/>, or <xnt xmlns:xlink="http://www.w3.org/1999/xlink"
                     spec="XP31" ref="prod-xpath31-SequenceType" xlink:type="simple"
                     >SequenceType</xnt> in <bibref ref="xpath-31"/>, depending on whether or not
                  the <termref def="dt-xpath31-feature"/> is implemented.</termdef></p>
            <p>
               <termdef id="dt-schema-component" term="schema component">Type definitions and
                  element and attribute declarations are referred to collectively as <term>schema
                     components</term>.</termdef>
            </p>
            <p>
               <termdef id="dt-in-scope-schema-component" term="in-scope schema component">The
                     <termref def="dt-schema-component">schema components</termref> that may be
                  referenced by name in a <phrase diff="chg" at="S-bug-28805"><termref
                        def="dt-package">package</termref></phrase> are referred to as the
                     <term>in-scope schema components</term>.</termdef></p>
            <p diff="add" at="S-bug-28805">The set of in-scope schema components may vary between
               one package and another, but as explained in <specref ref="import-schema"/>, the
               schema components used in different packages must be consistent with each other.</p>
            <p>The conformance rules for XSLT <phrase diff="chg" at="A">3.0</phrase>, defined in
                  <specref ref="conformance"/>, distinguish between a <termref
                  def="dt-basic-xslt-processor">basic XSLT processor</termref> and a <termref
                  def="dt-schema-aware-xslt-processor">schema-aware XSLT processor</termref>. As the
               names suggest, a basic XSLT processor does not support the features of XSLT that
               require access to schema information, either statically or dynamically. A <termref
                  def="dt-stylesheet">stylesheet</termref> that works with a basic XSLT processor
               will produce the same results with a schema-aware XSLT processor provided that the
               source documents are untyped (that is, they are not validated against a schema).
               However, if source documents are validated against a schema then the results may be
               different from the case where they are not validated. Some constructs that work on
               untyped data may fail with typed data (for example, an attribute of type
                  <code>xs:date</code> cannot be used as an argument of the
                  <xfunction>substring</xfunction> function) and other constructs may produce
               different results depending on the datatype (for example, given the element
                  <code>&lt;product price="10.00" discount="2.00"/&gt;</code>, the expression
                  <code>@price gt @discount</code> will return true if the attributes have type
                  <code>xs:decimal</code>, but will return false if they are untyped).</p>
            <p>There is a standard set of type definitions that are always available as <termref
                  def="dt-in-scope-schema-component">in-scope schema components</termref> in every
               stylesheet. These are defined in <specref ref="built-in-types"/>. <phrase diff="del"
                  at="E">The set of built-in types varies between a <termref
                     def="dt-basic-xslt-processor">basic XSLT processor</termref> and a <termref
                     def="dt-schema-aware-xslt-processor">schema-aware XSLT
                  processor</termref>.</phrase></p>
            <p>The remainder of this section describes facilities that are available only with a
                  <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT
                  processor</termref>.</p>
            <p>Additional <termref def="dt-schema-component">schema components</termref> (type
               definitions, element declarations, and attribute declarations) may be added to the
                  <termref def="dt-in-scope-schema-component">in-scope schema components</termref>
               by means of the <elcode>xsl:import-schema</elcode> declaration in a stylesheet.</p>
            <p>The <elcode>xsl:import-schema</elcode> declaration may reference an external schema
               document by means of a URI, or it may contain an inline <code>xs:schema</code>
               element.</p>
            <p>It is only necessary to import a schema explicitly if one or more of its <termref
                  def="dt-schema-component">schema components</termref> are referenced explicitly by
               name in the <termref def="dt-stylesheet">stylesheet</termref>; it is not necessary to
               import a schema merely because the stylesheet is used to process a source document
               that has been assessed against that schema. It is possible to make use of the
               information resulting from schema assessment (for example, the fact that a particular
               attribute holds a date) even if no schema has been imported by the stylesheet.</p>
            <p>Importing a schema does not of itself say anything about the type of the source
               document that the <termref def="dt-stylesheet">stylesheet</termref> is expected to
               process. The imported type definitions can be used for temporary nodes or for nodes
               on a <termref def="dt-result-tree">result tree</termref> just as much as for nodes in
               source documents. It is possible to make assertions about the type of an input
               document by means of tests within the <termref def="dt-stylesheet"
                  >stylesheet</termref>. For example:</p>
            <example diff="chg" at="S-bug27152">
               <head>Asserting the Required Type of the Source Document</head>
               <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:mode typed="lax"/&gt;
&lt;xsl:global-context-item use="required"
            as="document-node(schema-element(my:invoice))"/&gt;</eg>
               <p>This example will cause the transformation to fail with an error message, unless
                  the <termref def="dt-global-context-item"/> is valid against the top-level element
                  declaration <code>my:invoice</code>, and has been annotated as such.</p>
               <p diff="chg" at="I">The setting <code>typed="lax"</code> further ensures that in any
                  match pattern for a template rule in this mode, an element name that corresponds
                  to the name of an element declaration in the schema is taken as referring to
                  elements validated against that declaration: for example,
                     <code>match="employee"</code> will only match a validated <code>employee</code>
                  element. Selecting this option enables the XSLT processor to do more compile-time
                  type-checking against the schema, for example it allows the processor to produce
                  warning or error messages when path expressions contain misspelt element names, or
                  confuse an element with an attribute.</p>
            </example>
            <p diff="add" at="D">It is also true that importing a schema does not of itself say
               anything about the structure of the result tree. It is possible to request validation
               of a result tree against the schema by using the <elcode>xsl:result-document</elcode>
               instruction, for example:</p>
            <example diff="add" at="D">
               <head>Requesting Validation of the Result Document</head>
               <eg role="xslt-declaration xmlns:xhtml='xhtml'" xml:space="preserve">&lt;xsl:template match="/"&gt;
  &lt;xsl:result-document validation="strict"&gt;
    &lt;xhtml:html&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xhtml:html&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;
               </eg>
               <p>This example will cause the transformation to fail with an error message unless
                  the document element of the result document is valid against the top-level element
                  declaration <code>xhtml:html</code>.</p>
            </example>
            <p>It is possible that a source document may contain nodes whose <termref
                  def="dt-type-annotation">type annotation</termref> is not one of the types
               imported by the stylesheet. This creates a potential problem because in the case of
               an expression such as <code>data(.) instance of xs:integer</code> the system needs to
               know whether the type named in the type annotation of the context node is derived by
               restriction from the type <code>xs:integer</code>. This information is not explicitly
               available in an XDM tree, as defined in <bibref ref="xpath-datamodel-30"/>. The
               implementation may choose one of several strategies for dealing with this
               situation:</p>
            <olist>
               <item>
                  <p>The processor may signal a <termref def="dt-dynamic-error"><phrase diff="del"
                           at="M">non-recoverable</phrase> dynamic error</termref> if a source
                     document is found to contain a <termref def="dt-type-annotation"/> that is not
                     known to the processor.</p>
               </item>
               <item>
                  <p>The processor may maintain additional metadata, beyond that described in
                        <bibref ref="xpath-datamodel-30"/>, that allows the source document to be
                     processed as if all the necessary schema information had been imported using
                        <elcode>xsl:import-schema</elcode>. Such metadata might be held in the data
                     structure representing the source document itself, or it might be held in a
                     system catalog or repository.</p>
               </item>
               <item>
                  <p>The processor may be configured to use a fixed set of schemas, which are
                     automatically used to validate all source documents before they can be supplied
                     as input to a transformation. In this case it is impossible for a source
                     document to have a <termref def="dt-type-annotation"/> that the processor is
                     not aware of.</p>
               </item>
               <item>
                  <p>The processor may be configured to treat the source document as if no schema
                     processing had been performed, that is, effectively to strip all type
                     annotations from elements and attributes on input, marking them instead as
                     having type <code>xs:untyped</code> and <code>xs:untypedAtomic</code>
                     respectively.</p>
               </item>
            </olist>
            <p>Where a stylesheet author chooses to make assertions about the types of nodes or of
                  <termref def="dt-variable">variables</termref> and <termref def="dt-parameter"
                  >parameters</termref>, it is possible for an XSLT processor to perform static
               analysis of the <termref def="dt-stylesheet">stylesheet</termref> (that is, analysis
               in the absence of any source document). Such analysis <rfc2119>may</rfc2119> reveal
               errors that would otherwise not be discovered until the transformation is actually
               executed. An XSLT processor is not <rfc2119>required</rfc2119> to perform such static
               type-checking. Under some circumstances (see <specref ref="errors"/>) type errors
               that are detected early <rfc2119>may</rfc2119> be reported as static errors. In
               addition an implementation <rfc2119>may</rfc2119> report any condition found during
               static analysis as a warning, provided that this does not prevent the stylesheet
               being evaluated as described by this specification.</p>
            <p>A <termref def="dt-stylesheet">stylesheet</termref> can also control the <termref
                  def="dt-type-annotation">type annotations</termref> of nodes that it constructs in
               a <phrase diff="chg" at="S-bug27258"><termref def="dt-result-tree">result
                     tree</termref></phrase>. This can be done in a number of ways.</p>
            <ulist>
               <item>
                  <p>It is possible to request explicit validation of a complete document, that is,
                     a <phrase diff="chg" at="S-bug27258"><termref def="dt-result-tree">result
                           tree</termref></phrase> rooted at a document node. <phrase diff="del"
                        at="S-bug27258">This applies both to temporary trees constructed using the
                           <elcode>xsl:document</elcode> (or <elcode>xsl:copy</elcode>) instruction
                        and also to <termref def="dt-final-result-tree">final result trees</termref>
                        constructed using <elcode>xsl:result-document</elcode>.</phrase> Validation
                     is either strict or lax, as described in <bibref ref="xmlschema-1"/>. If
                     validation of a <termref def="dt-result-tree">result tree</termref> fails
                     (strictly speaking, if the outcome of the validity assessment is
                        <code>invalid</code>), then the transformation fails, but in all other
                     cases, the element and attribute nodes of the tree will be annotated with the
                     names of the types to which these nodes conform. These <termref
                        def="dt-type-annotation">type annotations</termref> will be discarded if the
                     result tree is serialized as an XML document, but they remain available when
                     the result tree is passed to an application (perhaps another <termref
                        def="dt-stylesheet">stylesheet</termref>) for further processing.</p>
               </item>
               <item>
                  <p>It is also possible to validate individual element and attribute nodes as they
                     are constructed. This is done using the <code>type</code> and
                        <code>validation</code> attributes of the <elcode>xsl:element</elcode>,
                        <elcode>xsl:attribute</elcode>, <elcode>xsl:copy</elcode>, and
                        <elcode>xsl:copy-of</elcode> instructions, or the <code>xsl:type</code> and
                        <code>xsl:validation</code> attributes of a literal result element.</p>
               </item>
               <item>
                  <p>When elements, attributes, or document nodes are copied, either explicitly
                     using the <elcode>xsl:copy</elcode> or <elcode>xsl:copy-of</elcode>
                     instructions, or implicitly when nodes in a sequence are attached to a new
                     parent node, the options <code>validation="strip"</code> and
                        <code>validation="preserve"</code> are available, to control whether
                     existing <termref def="dt-type-annotation">type annotations</termref> are to be
                     retained or not.</p>
               </item>
            </ulist>
            <p>When nodes in a <termref def="dt-temporary-tree">temporary tree</termref> are
               validated, type information is available for use by operations carried out on the
               temporary tree, in the same way as for a source document that has undergone schema
               assessment.</p>
            <p>For details of how validation of element and attribute nodes works, see <specref
                  ref="validation"/>.</p>
         </div2>
         <div2 id="streaming-concepts" diff="add" at="A">
            <head>Streaming</head>
            <p><termdef id="dt-streaming" term="streaming">The term <term>streaming</term> refers to
                  a manner of processing in which XML documents (such as source and result
                  documents) are not represented by a complete tree of nodes occupying memory
                  proportional to document size, but instead are processed “on the fly” as a
                  sequence of events, similar in concept to the stream of events notified by an XML
                  parser to represent markup in lexical XML.</termdef></p>
            <p><termdef id="dt-streamed-document" term="streamed document">A <term>streamed
                     document</term> is a <termref def="dt-source-tree">source tree</termref> that
                  is processed using streaming, that is, without constructing a complete tree of
                  nodes in memory.</termdef></p>
            <p><termdef id="dt-streamed-node" term="streamed node">A <term>streamed node</term> is a
                  node in a <termref def="dt-streamed-document">streamed
                  document</termref>.</termdef></p>
            <p>Many processors implementing earlier versions of this specification have adopted an
               architecture that allows streaming of the <termref def="dt-result-tree">result
                  tree</termref> directly to a serializer, without first materializing the complete
               result tree in memory. Streaming of the <termref def="dt-source-tree">source
                  tree</termref>, however, has proved to be more difficult without subsetting the
               language. This has created a situation where documents exceeding the capacity of
               virtual memory could not be transformed. XSLT 3.0 therefore introduces facilities
               allowing stylesheets to be written in a way that makes streaming of source documents
               possible, without excessive reliance on processor-specific optimization
               techniques.</p>
            <p>Streaming achieves two important objectives: it allows large documents to be
               transformed without requiring correspondingly large amounts of memory; and it allows
               the processor to start producing output before it has finished receiving its input,
               thus reducing latency.</p>
            <p>This specification does not attempt to legislate precisely which implementation
               techniques fall under the definition of streaming, and which do not. A number of
               techniques are available that reduce memory requirements, while still requiring a
               degree of buffering, or allocation of memory to partial results. A stylesheet that
               requests streaming of a source document is indicating that the processor should avoid
               assuming that the entire source document will fit in memory; in return, the
               stylesheet must be written in a way that makes streaming possible. This specification
               does not attempt to describe the algorithms that the processor should actually use,
               or to impose quantitative constraints on the resources that these algorithms should
               consume.</p>
            <p>Nothing in this specification, nor in its predecessors <bibref ref="xslt"/> and
                  <bibref ref="xslt20"/>, prevents a processor using streaming whenever it sees an
               opportunity to do so. However, experience has shown that in order to achieve
               streaming, it is often necessary to write stylesheet code in such a way as to make
               this possible. Therefore, XSLT 3.0 provides explicit constructs allowing the
               stylesheet author to request streaming, and defines explicit static constraints on
               the structure of the code which are designed to make streaming possible.</p>
            <p>A processor that claims conformance with the streaming option offers a guarantee that
               when streaming is requested for a source document, and when the stylesheet conforms
               to the rules that make the processing <termref def="dt-guaranteed-streamable"/>, then
               an algorithm will be adopted in which memory consumption is either completely
               independent of document size, or increases only very slowly as document size
               increases, allowing documents to be processed that are orders-of-magnitude larger
               than the physical memory available. A processor that does not claim conformance with
               the streaming option must still process a stylesheet and deliver the correct results,
               but is not required to use streaming algorithms, and may therefore fail with
               out-of-memory errors when presented with large source documents.</p>
            <p>Apart from the fact that there are constructs to request streaming, and rules that
               must be followed to guarantee that streaming is possible, the language has been
               designed so there are as few differences as possible between streaming and
               non-streaming evaluation. The semantics of the language continue to be expressed in
               terms of the XDM data model, which is substantively unchanged; but readers must take
               care to observe that when terms like “node” and “axis” are used, the concepts are
               completely abstract and may have no direct representation in the run-time execution
               environment.</p>
            <p>Streamed processing of a document can be initiated in one of <phrase diff="chg"
                  at="R-bug24538">three</phrase> ways:</p>
            <ulist>
               <item>
                  <p>The <termref def="dt-initial-mode">initial mode</termref> can be declared as a
                        <termref def="dt-streamable-mode">streamable mode</termref>. In this case
                     the <phrase diff="chg" at="R-bug24764"><termref
                           def="dt-initial-match-selection"/> will generally be a document node (or
                        sequence of document nodes),</phrase> supplied by the calling application in
                     a form that allows streaming (that is, in some form other than a tree in
                     memory; for example, as a reference to a push or pull XML parser primed to
                     deliver a stream of events). <phrase diff="chg" at="R-bug24764">The type of
                        these nodes can be constrained by using the attribute
                           <code>on-no-match="fail"</code> on the <termref def="dt-initial-mode"/>,
                        and using this mode only for processing the top-level nodes.</phrase>
                     <phrase diff="del" at="P">In this case the <termref def="dt-template-rule"
                           >template rule</termref> that matches the document node (in this mode)
                        must be a guaranteed-streamable template, which means that it (as well as
                        all other template rules using this <termref def="dt-mode">mode</termref>)
                        must satisfy certain statically checkable constraints to ensure that
                        streaming is possible.</phrase></p>
               </item>
               <item>
                  <p>Streamed processing of any document can be initiated using the
                        <elcode>xsl:source-document</elcode> instruction. This has an attribute
                        <code>href</code> whose value is the URI of a document to be processed,
                        <phrase diff="add" at="T-bug29747">and an attribute <code>streamable</code>
                        that indicates whether it is to be processed</phrase> using streaming; the
                     actual processing to be applied is defined by the instructions written as
                     children of the <elcode>xsl:source-document</elcode> instruction. <phrase
                        diff="del" at="P">These instructions must satisfy the same rules as for a
                        guaranteed-streamable template.</phrase></p>
               </item>
               <item diff="chg" at="R-bug24538">
                  <p>Streamed merging of a set of input documents can be initiated using the
                        <elcode>xsl:merge</elcode> instruction.</p>
               </item>
            </ulist>
            <p>The rules for streamability, which are defined in detail in <specref
                  ref="streamability"/>, impose two main constraints:</p>
            <ulist>
               <item>
                  <p>The only nodes reachable from the node that is currently being processed are
                     its attributes and namespaces, its ancestors and their attributes and
                     namespaces, and its descendants and their attributes and namespaces. The
                     siblings of the node, and the siblings of its ancestors, are not reachable in
                     the tree, and any attempt to use their values is a <termref
                        def="dt-static-error">static error</termref>. <phrase diff="del"
                        at="R-bug26742">However, constructs (for example, simple forms of
                           <elcode>xsl:number</elcode>, and simple positional <termref
                           def="dt-pattern">patterns</termref>) that require knowledge of the number
                        of preceding elements by name are permitted.</phrase></p>
               </item>
               <item>
                  <p>When processing a given node in the tree, each descendant node can only be
                     visited once. Essentially this allows two styles of processing: either visit
                     each of the children once, and then process that child with the same
                     restrictions applied; or process all the descendants in a single pass, in which
                     case it is not possible while processing a descendant to make any further
                     downward selection.</p>
               </item>
            </ulist>
            <p diff="chg" at="F">The second restriction, that only one visit to the children is
               allowed, means that XSLT code that was not designed with streaming in mind will often
               need to be rewritten to make it streamable. In many cases it is possible to do this
               using a technique sometimes called <emph>windowing</emph> or <emph>burst-mode
                  streaming</emph> (note this is not quite the same meaning as
                  <emph>windowing</emph> in XQuery 3.0). Many XML documents consist of a large
               number of elements, each of manageable size, representing transactions or business
               objects where each such element can be processed independently: in such cases, an
               effective design pattern is to write a streaming transformation that takes a snapshot
               of each element in turn, processing the snapshot using the full power of the XSLT
               language. Each snapshot is a tree built in memory and is therefore fully navigable.
               For details see the <function>snapshot</function> and <function>copy-of</function>
               functions.</p>
            <p diff="add" at="K">The new facility of <emph>accumulators</emph> allows applications
               complete control over how much information is retained (and by implication, how much
               memory is required) in the course of a pass over a <termref
                  def="dt-streamed-document"/>. An accumulator computes a value for every node in a
               streamed document: or more accurately, two values, one for the first visit to a node
               (before visiting its descendants), and a second value for the second visit to the
               node (after visiting the descendants). The computation is structured in such a way
               that the value for a given node can depend only on the value for the previous node in
               document order together with the data available when positioned at the current node
               (for example, the attribute values). Based on the well-established fold operation of
               functional programming languages, accumulators provide the convenience and economy of
               mutable variables while remaining within the constraints of a purely declarative
               processing model.</p>
            <p diff="add" at="S-bug27660">When streaming is initiated, for example using the
                  <elcode>xsl:source-document</elcode> instruction, it is necessary to declare which
               accumulators are applicable to the streamed document.</p>
            <p>Streaming applications often fall into one of the following categories:</p>
            <ulist>
               <item>
                  <p>Aggregation applications, where a single aggregation operation (perhaps
                        <xfunction>count</xfunction>, <xfunction>sum</xfunction>,
                        <xfunction>exists</xfunction>, or <xfunction>distinct-values</xfunction>) is
                     applied to a set of elements selected from the streamed source document by
                     means of a path expression.</p>
               </item>
               <item>
                  <p>Record-at-a-time applications, where the source document consists of a long
                     sequence of elements with similar structure (“records”), and each “record” is
                     processed using the same logic, independently of any other “records”. This kind
                     of processing is facilitated using the <function>snapshot</function> and
                        <function>copy-of</function> function mentioned earlier.</p>
               </item>
               <item>
                  <p>Grouping applications, where the output follows the structure of the input,
                     except that an extra layer of hierarchy is added. For example, the input might
                     be a flat series of banking transactions in date/time order, and the output
                     might contain the same transactions grouped by date.</p>
               </item>
               <item>
                  <p>Accumulator applications, which are the same as record-at-a-time applications,
                     except that the processing of one “record” might depend on data encountered
                     earlier in the document. A classic example is processing a sequence of banking
                     transactions in which the input transaction contains a debit or credit amount,
                     and the output adds a running total (the account balance). The
                        <elcode>xsl:iterate</elcode> instruction has been introduced to facilitate
                     this style of processing.</p>
               </item>
               <item>
                  <p>Isomorphic transformations, in which there is an ordered (often largely
                     one-to-one) relationship between the nodes of the source tree and the nodes of
                     the result tree: for example, transformations that involve only the renaming or
                     selective deletion of nodes, or scalar manipulations of the values held in the
                     leaf nodes. Such transformations are most conveniently expressed using
                     recursive application of template rules. This is possible with a streamed input
                     document only if all the template rules adhere to the constraints required for
                     streamability. To enforce these rules, while still allowing unrestricted
                     processing of other documents within the same transformation, all streaming
                     evaluation must be carried out using a specific <termref def="dt-mode"
                        >mode</termref>, which is declared to be a streaming mode by means of an
                        <elcode>xsl:mode</elcode> declaration in the stylesheet.</p>
               </item>
            </ulist>
            <p>There are important classes of application in which streaming is possible only if
               multiple streams can be processed in parallel. This specification therefore provides
               facilities:</p>
            <olist>
               <item>
                  <p>allowing multiple sorted input sequences to be merged into one sorted output
                     sequence (the <elcode>xsl:merge</elcode> instruction)</p>
               </item>
               <item>
                  <p>allowing multiple output sequences to be generated during a single pass of an
                     input sequence (the <elcode>xsl:fork</elcode> instruction).</p>
               </item>
            </olist>
            <p>These facilities have been designed in such a way that they can readily be
               implemented using streaming, that is, without materializing the input or output
               sequences in memory.</p>
         </div2>
         <div2 id="streamed-validation" diff="add" at="S-bug29206">
            <head>Streamed Validation</head>
            <p>Streaming can be combined with schema-aware processing: that is, the streamed input
               to a transformation can be subjected to on-the-fly validation, a process which
               typically accepts an input stream from the XML parser and delivers an output stream
               (of type-annotated nodes) to the transformation processor. The XSD specification is
               designed so that validation is, with one or two exceptions, a streamable process. The
               exceptions include: </p>
            <ulist>
               <item>
                  <p>There may be a need to allocate memory to hold keys, in order to enforce
                     uniqueness and referential integrity constraints (<code>xs:unique</code>,
                        <code>xs:key</code>, <code>xs:keyref</code>). </p>
               </item>
               <item>
                  <p>In XSD 1.1, assertions can be defined by means of XPath expressions. These are
                     not constrained to be streamable; in the general case, any subtree of the
                     document that is validated using an assertion may need to be buffered in memory
                     while the assertion is processed. </p>
               </item>
            </ulist>
            <p>Applications that need to run in finite memory may therefore need to avoid these XSD
               features, or to use them with care. </p>
            <p>XSD is designed so that the intended type of an element (the “governing type”) can be
               determined as soon as the start tag of the element is encountered: the process of
               validation checks whether the content of the element actually conforms to this type,
               and by the time the end tag is encountered, the process will have established either
               that the element is valid against the governing type, or that it is invalid. </p>
            <p>By default, dynamic errors occurring during streamed processing are fatal: they
               typically cause the transformation to fail immediately. XSLT 3.0 introduces the
               ability to catch dynamic errors and recover from them. Schema invalidity, however, is
               treated as a dynamic error of the instruction that processes the entire input stream,
               so after a validation failure, no further processing of that input stream is
               possible. </p>
            <p>In consequence, a streamed validator that is running in tandem with a streamed
               transformation can present the transformer with element nodes that carry a
               provisional type annotation representing the type that the element will have if it
               turns out to be valid. As soon as a node is encountered that violates this
               assumption, the validator should stop the flow of data to the transformer, so that
               the transformer never sees invalid data. This allows the stylesheet code to be
               compiled with the assumption of type-safety: at run-time, all nodes seen by the
               transformation will conform to their XSLT-declared types (for example, a type
               declared implicitly using <code>match="schema-element(invoice)"</code> on an
                  <elcode>xsl:template</elcode> element). </p>
            <p>A streamed transformation that only accesses part of the input document (for example,
               a header at the start of a document) is not required to continue reading once the
               data it needs has been read. This means that XML well-formedness or validity errors
               occurring in the unread part of the input stream may go undetected. </p>
         </div2>
         <div2 id="streaming-non-xml" diff="add" at="T-bug29889">
            <head>Streaming of non-XML data</head>
            <p>The facilities in this specification designed to enable large data sets to be
               processed in a streaming manner are oriented almost entirely to XML data. This does
               not mean that there is never a requirement to stream non-XML data, or that the
               Working Group has ignored this requirement; rather, the Working Group has concluded
               that for the most part, streaming of non-XML data can be achieved by implementations
               without the need for specific language features in XSLT.</p>
            <p>To make streamed processing of unparsed text files easier, the function
                  <xfunction>unparsed-text-lines</xfunction> has been introduced. This is not only
               more convenient for stylesheet authors than reading the entire input using the
                  <xfunction>unparsed-text</xfunction> function and then tokenizing the result, it
               is also easier for implementations to optimize, allowing each line of text to be
               discarded from memory after it has been processed.</p>
            <p>For all functions that access external data, including <function>document</function>,
                  <xfunction>doc</xfunction>, <xfunction>collection</xfunction>,
                  <xfunction>unparsed-text</xfunction>, <xfunction>unparsed-text-lines</xfunction>,
               and (in XPath 3.1) <xfunction spec="FO31">json-doc</xfunction>, the requirements on
               determinism can now be relaxed using <termref def="dt-implementation-defined"/>
               configuration options. This is significant because it means that when a
               transformation reads the same external resource more than once, it becomes legitimate
               for the contents of the resource to be different on different invocations, and this
               eliminates the need for the processor to cache the contents of the resource in
               memory.</p>
            <p>In the XDM data model, every value is a sequence, and (as with most functional
               programming languages), processing of sequences of items is pervasive throughout the
               XSLT and XPath languages and their function library. Good performance of a functional
               programming language often depends on sequence-based operations being pipelined, and
               being evaluated in a lazy fashion (that is, many operations process items in a
               sequence one at a time, in order; and many operations can deliver a result without
               processing the entire sequence). The semantics of XSLT and XPath permit pipelined and
               lazy evaluation (for example, the error handling semantics are carefully written to
               ensure this), but they do not require it: the details are left to implementations.
               Pipelined processing of a sequence is not the same thing as streamed processing of a
               tree, and where the XSLT specification talks of operations being “guaranteed
               streamable”, this is always referring to processing of trees, not of sequences.</p>
            <p>The facilities for streaming of XML trees include operations such as
                  <function>copy-of</function> and <function>snapshot</function> which are able to
               take a sequence of streamed nodes as input, and produce a sequence of in-memory
               (unstreamed) nodes as output. It is also possible to generate a sequence of strings
               or other atomic values through the process of <termref def="dt-atomization"
                  >atomization</termref>. The actual memory usage of a streamed XSLT application may
               depend significantly on whether the processing of the resulting sequence of in-memory
               nodes or atomic values is pipelined or not. The specification, however, has nothing
               to say on this matter: it is considered an area where implementers can exercise their
               discretion and ingenuity.</p>
            <p>Streaming of JSON input receives little attention in this specification. One can
               envisage an implementation of the <function>json-to-xml</function> function in which
               the XML delivered by the function consists of streamed nodes; but the Working Group
               has not researched the feasibility of such an implementation in any detail.</p>
         </div2>
         <div2 id="errors">
            <head>Error Handling</head>
            <p>
               <termdef id="dt-static-error" term="static error">An error that can be detected by
                  examining a <termref def="dt-stylesheet">stylesheet</termref> before execution
                  starts (that is, before the source document and values of stylesheet parameters
                  are available) is referred to as a <term>static error</term>.</termdef>
            </p>
            <p diff="del" at="T-bug29960">Errors classified in this specification as static errors
                  <rfc2119>must</rfc2119> be signaled by all implementations: that is, the <termref
                  def="dt-processor">processor</termref>
               <rfc2119>must</rfc2119> indicate that the error is present. A static error
                  <rfc2119>must</rfc2119> be signaled even if it occurs in a part of the <termref
                  def="dt-stylesheet">stylesheet</termref> that is never evaluated. Static errors
               are never recoverable. After signaling a static error, a processor
                  <rfc2119>may</rfc2119> continue for the purpose of signaling additional errors,
               but it <rfc2119>must</rfc2119> eventually terminate abnormally without producing
                  <phrase diff="add" at="S-bug27258">a <termref def="dt-principal-result"/></phrase>
               <phrase diff="del" at="S-bug27258">any <termref def="dt-final-result-tree">final
                     result tree</termref></phrase>.</p>
            <p diff="del" at="T-bug29960">There is an exception to this rule when the stylesheet
               specifies <termref def="dt-forwards-compatible-behavior"/> (see <specref
                  ref="forwards"/>).</p>
            <p>Generally, errors in the structure of the <termref def="dt-stylesheet"
                  >stylesheet</termref>, or in the syntax of XPath <termref def="dt-expression"
                  >expressions</termref> contained in the stylesheet, are classified as <termref
                  def="dt-static-error">static errors</termref>. Where this specification states
               that an element in the stylesheet <rfc2119>must</rfc2119> or <rfc2119>must
                  not</rfc2119> appear in a certain position, or that it <rfc2119>must</rfc2119> or
                  <rfc2119>must not</rfc2119> have a particular attribute, or that an attribute
                  <rfc2119>must</rfc2119> or <rfc2119>must not</rfc2119> have a value satisfying
               specified conditions, then any contravention of this rule is a static error unless
               otherwise specified. </p>
            <p diff="add" at="T-bug29960">A processor <rfc2119>must</rfc2119> provide a mode of
               operation that takes a (possibly erroneous) stylesheet <termref def="dt-package"
                  >package</termref> as input and enables the user to determine whether or not that
               package contains any <termref def="dt-static-error">static errors</termref>. </p>
            <note diff="add" at="T-bug29960">
               <p>The manner in which static errors are reported, and the behavior when there are
                  multiple static errors, are left as design choices for the implementer. It is
                     <rfc2119>recommended</rfc2119> that the error codes defined in this
                  specification should be made available in any diagnostics. </p>
            </note>
            <p diff="add" at="T-bug29960">A processor <rfc2119>may</rfc2119> also provide a mode of
               operation in which <termref def="dt-static-error">static errors</termref> in parts of
               the stylesheet that are not evaluated can go unreported. </p>
            <note diff="add" at="T-bug29960">
               <p>For example, when operating in this mode, a processor might report static errors
                  in a template rule only if the input document contains nodes that match that
                  template rule. Such a mode of operation can provide performance benefits when
                  large and well-tested stylesheets are used to process source documents that might
                  only use a small part of the XML vocabulary that the stylesheet is designed to
                  handle. </p>
            </note>
            <p>
               <termdef id="dt-dynamic-error" term="dynamic error">An error that is not <phrase
                     diff="add" at="T-bug29960">capable of detection</phrase> until a source
                  document is being transformed is referred to as a <term>dynamic
                  error</term>.</termdef>
            </p>
            <p diff="add" at="L">When a <termref def="dt-dynamic-error"/> occurs, and is not caught
               using <elcode>xsl:catch</elcode>, the <termref def="dt-processor">processor</termref>
               <rfc2119>must</rfc2119> signal the error, and the transformation fails.</p>
            <p diff="del" at="M"> Some dynamic errors are classed as <term>recoverable
               errors</term>. When a recoverable error occurs, this specification allows the
               processor either to signal the error (by reporting the error condition and
               terminating execution) or to take a defined recovery action and continue processing.
               It is <termref def="dt-implementation-defined">implementation-defined</termref>
               whether the error is signaled or the recovery action is taken. If the processor
               chooses to signal the error rather than taking the recovery action, the error is then
               treated in the same way as a <termref def="dt-dynamic-error"/> and is therefore
               eligible to be caught using <elcode>xsl:try</elcode>/<elcode>xsl:catch</elcode>.</p>
            <p diff="del" at="M">
               <termdef id="dt-optional-recovery-action" term="optional recovery action">If an
                  implementation chooses to recover from a recoverable dynamic error, it
                     <rfc2119>must</rfc2119> take the <term>optional recovery action</term> defined
                  for that error condition in this specification.</termdef>
            </p>
            <p diff="del" at="M">When the implementation makes the choice between signaling a
               dynamic error or recovering, it is not restricted in how it makes the choice; for
               example, it <rfc2119>may</rfc2119> provide options that can be set by the user. When
               an implementation chooses to recover from a dynamic error, it <rfc2119>may</rfc2119>
               also take other action, such as logging a warning message.</p>
            <p diff="del" at="M">
               <termdef id="dt-nonrec-dynamic-error" term="non-recoverable dynamic error">A <termref
                     def="dt-dynamic-error">dynamic error</termref> that is not recoverable is
                  referred to as a <term>non-recoverable dynamic error</term>. When a
                  non-recoverable dynamic error occurs, the <termref def="dt-processor"
                     >processor</termref>
                  <rfc2119>must</rfc2119> signal the error, and <phrase diff="add" at="B">(unless
                     the error is caught using <elcode>xsl:catch</elcode>)</phrase> the
                  transformation fails.</termdef>
            </p>
            <note diff="del" at="M">
               <p>The term <term>non-recoverable</term> is retained from earlier XSLT versions, and
                  implies that the processor will not recover from the error on its own initiative.
                  However, the introduction of <elcode>xsl:try</elcode> and
                     <elcode>xsl:catch</elcode> in XSLT 3.0 means that such errors can now be
                  recovered by means of application logic.</p>
            </note>
            <p>Because different implementations may optimize execution of the <termref
                  def="dt-stylesheet">stylesheet</termref> in different ways, the detection of
               dynamic errors is to some degree <termref def="dt-implementation-dependent"
                  >implementation-dependent</termref>. In cases where an implementation is able to
               produce <phrase diff="add" at="S-bug27258">a <termref def="dt-principal-result"/> or
                     <termref def="dt-secondary-result"/></phrase>
               <phrase diff="del" at="S-bug27258">the <termref def="dt-final-result-tree">final
                     result trees</termref></phrase> without evaluating a particular construct, the
               implementation is never <rfc2119>required</rfc2119> to evaluate that construct solely
               in order to determine whether doing so causes a dynamic error. For example, if a
                  <termref def="dt-variable">variable</termref> is declared but never referenced, an
               implementation <rfc2119>may</rfc2119> choose whether or not to evaluate the variable
               declaration, which means that if evaluating the variable declaration causes a dynamic
               error, some implementations will signal this error and others will not.</p>
            <p>There are some cases where this specification requires that a construct <rfc2119>must
                  not</rfc2119> be evaluated: for example, the content of an <elcode>xsl:if</elcode>
               instruction <rfc2119>must not</rfc2119> be evaluated if the test condition is false.
               This means that an implementation <rfc2119>must not</rfc2119> signal any dynamic
               errors that would arise if the construct were evaluated.</p>
            <p>An implementation <rfc2119>may</rfc2119> signal a <termref def="dt-dynamic-error"
                  >dynamic error</termref> before any source document is available, but only if it
               can determine that the error would be signaled for every possible source document and
               every possible set of parameter values. For example, some <termref
                  def="dt-circularity">circularity</termref> errors fall into this category: see
                  <specref ref="circularity"/>.</p>
            <p diff="add" at="B">There are also some <termref def="dt-dynamic-error">dynamic
                  errors</termref> where the specification gives a processor license to signal the
               error during the analysis phase even if the construct might never be executed; an
               example is the use of an invalid QName as a literal argument to a function such as
                  <function>key</function>, or the use of an invalid regular expression in the
                  <code>regex</code> attribute of the <elcode>xsl:analyze-string</elcode>
               instruction.</p>
            <p diff="add" at="M">A <termref def="dt-dynamic-error"/>
               <phrase diff="chg" at="S-bug28205">is also</phrase> signaled during the static
               analysis phase if the error occurs during evaluation of a <termref
                  def="dt-static-expression"/>.</p>
            <p>The XPath specification states (see <xspecref spec="XP30" ref="id-kinds-of-errors"/>)
               that if any expression (at any level) can be evaluated during the analysis phase
               (because all its explicit operands are known and it has no dependencies on the
               dynamic context), then any error in performing this evaluation <rfc2119>may</rfc2119>
               be reported as a static error. For XPath expressions used in an XSLT stylesheet,
               however, any such errors <rfc2119>must not</rfc2119> be reported as static errors in
               the stylesheet unless they would occur in every possible evaluation of that
               stylesheet; instead, they must be signaled as dynamic errors, and signaled only if
               the XPath expression is actually evaluated.</p>
            <example>
               <head>Errors in Constant Subexpressions</head>
               <p>An XPath processor may report statically that the expression <code>1 div 0</code>
                  fails with a “divide by zero” error. But suppose this XPath expression occurs in
                  an XSLT construct such as:</p>
               <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:choose&gt;
  &lt;xsl:when test="system-property('xsl:version') = '1.0'"&gt;
    &lt;xsl:value-of select="1 div 0"/&gt;
  &lt;/xsl:when&gt;
  &lt;xsl:otherwise&gt;
    &lt;xsl:value-of select="xs:double('INF')"/&gt;
  &lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;</eg>
               <p>Then the XSLT processor must not report an error, because the relevant XPath
                  construct appears in a context where it will never be executed by an XSLT 2.0
                     <phrase diff="chg" at="A">or 3.0</phrase> processor. (An XSLT 1.0 processor
                  will execute this code successfully, returning positive infinity, because it uses
                  double arithmetic rather than decimal arithmetic.)</p>
            </example>
            <p>
               <termdef id="dt-type-error" term="type error">Certain errors are classified as
                     <term>type errors</term>. A type error occurs when the value supplied as input
                  to an operation is of the wrong type for that operation, for example when an
                  integer is supplied to an operation that expects a node.</termdef> If a type error
               occurs in an instruction that is actually evaluated, then it <rfc2119>must</rfc2119>
               be signaled in the same way as a <termref def="dt-dynamic-error"><phrase diff="del"
                     at="M">non-recoverable</phrase> dynamic error</termref>. Alternatively, an
               implementation <rfc2119>may</rfc2119> signal a type error during the analysis phase
               in the same way as a <termref def="dt-static-error">static error</termref>, even if
               it occurs in part of the stylesheet that is never evaluated, provided it can
               establish that execution of a particular construct would never succeed.</p>
            <p>It is <termref def="dt-implementation-defined"/> whether type errors are signaled
               statically.</p>
            <imp-def-feature id="idf-err-statictypechecking">It is <termref
                  def="dt-implementation-defined"/> whether type errors are signaled
               statically.</imp-def-feature>
            <example>
               <head>A Type Error</head>
               <p diff="chg" at="D">The following construct contains a type error, because
                     <code>42</code> is not allowed as the value of the <code>select</code>
                  expression of the <elcode>xsl:number</elcode> instruction (it must be a node). An
                  implementation <rfc2119>may</rfc2119> optionally signal this as a static error,
                  even though the offending instruction will never be evaluated, and the type error
                  would therefore never be signaled as a dynamic error.</p>
               <eg role="error" xml:space="preserve">&lt;xsl:if test="false()"&gt;
  &lt;xsl:number select="42"/&gt;
&lt;/xsl:if&gt;</eg>
               <p>On the other hand, in the following example it is not possible to determine
                  statically whether the operand of <phrase diff="chg" at="D"
                        ><elcode>xsl:number</elcode></phrase> will have a suitable dynamic type. An
                  implementation <rfc2119>may</rfc2119> produce a warning in such cases, but it
                     <rfc2119>must not</rfc2119> treat it as an error.</p>
               <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:template match="para"&gt;
  &lt;xsl:param name="p" as="item()"/&gt;
  &lt;xsl:number select="$p"/&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <p>If more than one error arises, an implementation is not <rfc2119>required</rfc2119>
               to signal any errors other than the first one that it detects. It is <termref
                  def="dt-implementation-dependent">implementation-dependent</termref> which of the
               several errors is signaled. This applies both to static errors and to dynamic errors.
               An implementation is allowed to signal more than one error, but if any errors have
               been signaled, it <rfc2119>must not</rfc2119> finish as if the transformation were
               successful.</p>
            <p>When a transformation signals one or more dynamic errors, the final state of any
               persistent resources updated by the transformation is <termref
                  def="dt-implementation-dependent">implementation-dependent</termref>.
               Implementations are not <rfc2119>required</rfc2119> to restore such resources to
               their initial state. In particular, where a transformation produces multiple result
               documents, it is possible that one or more serialized result documents
                  <rfc2119>may</rfc2119> be written successfully before the transformation
               terminates, but the application cannot rely on this behavior.</p>
            <p>Everything said above about error handling applies equally to errors in evaluating
               XSLT instructions, and errors in evaluating XPath <termref def="dt-expression"
                  >expressions</termref>. Static errors and dynamic errors may occur in both
               cases.</p>
            <p>
               <termdef id="dt-serialization-error" term="serialization error">If a transformation
                  has successfully produced a <phrase diff="add" at="S-bug27258"><termref
                        def="dt-principal-result"/> or <termref def="dt-secondary-result"/>, it is
                     still possible that errors may occur in serializing that result</phrase>
                  <phrase diff="del" at="S-bug27258"><termref def="dt-final-result-tree">final
                        result tree</termref>, it is still possible that errors may occur in
                     serializing the result tree</phrase>. For example, it may be impossible to
                  serialize the result <phrase diff="del" at="S-bug27258">tree</phrase> using the
                  encoding selected by the user. Such an error is referred to as a
                     <term>serialization error</term>.</termdef> If the processor performs
               serialization, then it <rfc2119>must</rfc2119> do so as specified in <specref
                  ref="serialization"/>, and in particular it <rfc2119>must</rfc2119> signal any
               serialization errors that occur.</p>
            <p>Errors are identified by a QName. For errors defined in this specification, the
               namespace of the QName is always <code>http://www.w3.org/2005/xqt-errors</code> (and
               is therefore not given explicitly), while the local part is an 8-character code in
               the form <var>PPSSNNNN</var>. Here <var>PP</var> is always <code>XT</code> (meaning
               XSLT), and <var>SS</var> is one of <code>SE</code> (static error), <code>DE</code>
               (dynamic error), <phrase diff="del" at="S"><code>RE</code> (recoverable dynamic
                  error),</phrase> or <code>TE</code> (type error). Note that the allocation of an
               error to one of these categories is purely for convenience and carries no normative
               implications about the way the error is handled. Many errors, for example, can be
               reported either dynamically or statically. These error codes are used to label error
               conditions in this specification, and are summarized in <specref ref="error-summary"
               />. <phrase diff="del" at="B">They are provided primarily for ease of reference.
                  Implementations <rfc2119>may</rfc2119> use these error codes when signaling
                  errors, but they are not <rfc2119>required</rfc2119> to do so. An API
                  specification, however, <rfc2119>may</rfc2119> require the use of error codes
                  based on these QNames.</phrase></p>
            <p>Errors defined in related specifications (<bibref ref="xpath-30"/>, <bibref
                  ref="xpath-functions-30"/>
               <bibref ref="xslt-xquery-serialization-30"/>) use QNames with a similar structure, in
               the same namespace. When errors occur in processing XPath expressions, an XSLT
               processor <rfc2119>should</rfc2119> use the original error code reported by the XPath
               processor, unless a more specific XSLT error code is available.</p>
            <p><phrase diff="add" at="B">Implementations <rfc2119>must</rfc2119> use the codes
                  defined in these specifications when signaling <phrase diff="add" at="T-bug29960"
                     >dynamic</phrase> errors, to ensure that <elcode>xsl:catch</elcode> behaves in
                  an interoperable way across implementations. Stylesheet authors should note,
                  however, that there are many examples of errors where more than one rule in this
                  specification is violated, and where the processor therefore has discretion in
                  deciding which error code to associate with the condition: there is therefore no
                  guarantee that different processors will always use the same error code for the
                  same erroneous input.</phrase></p>
            <p>Additional errors defined by an implementation (or by an application)
                  <rfc2119>may</rfc2119> use QNames in an implementation-defined (or user-defined)
               namespace without risk of collision.</p>
         </div2>
      </div1>
      <div1 id="stylesheet-structure">
         <head>Stylesheet Structure</head>
         <p>This section describes the overall structure of a stylesheet as a collection of XML
            documents.</p>
         <div2 id="xslt-namespace">
            <head>XSLT Namespace</head>
            <p>
               <termdef id="dt-xslt-namespace" term="XSLT namespace">The <term>XSLT namespace</term>
                  has the URI <code>http://www.w3.org/1999/XSL/Transform</code>. It is used to
                  identify elements, attributes, and other names that have a special meaning defined
                  in this specification.</termdef>
            </p>
            <note>
               <p>The <code>1999</code> in the URI indicates the year in which the URI was allocated
                  by the W3C. It does not indicate the version of XSLT being used, which is
                  specified by attributes (see <specref ref="stylesheet-element"/> and <specref
                     ref="simplified-stylesheet"/>).</p>
            </note>
            <p>XSLT <termref def="dt-processor">processors</termref>
               <rfc2119>must</rfc2119> use the XML namespaces mechanism <bibref ref="xml-names"/> to
               recognize elements and attributes from this namespace. Elements from the XSLT
               namespace are recognized only in the <termref def="dt-stylesheet"
                  >stylesheet</termref> and not in the source document. The complete list of
               XSLT-defined elements is specified in <specref ref="element-syntax-summary"/>.
                  <termref def="dt-implementation">Implementations</termref>
               <rfc2119>must not</rfc2119> extend the XSLT namespace with additional elements or
               attributes. Instead, any extension <rfc2119>must</rfc2119> be in a separate
               namespace. Any namespace that is used for additional instruction elements
                  <rfc2119>must</rfc2119> be identified by means of the <termref
                  def="dt-extension-instruction">extension instruction</termref> mechanism specified
               in <specref ref="extension-instruction"/>.</p>
            <p>This specification uses a prefix of <code>xsl:</code> for referring to elements in
               the XSLT namespace. However, XSLT stylesheets are free to use any prefix, provided
               that there is a namespace declaration that binds the prefix to the URI of the XSLT
               namespace.</p>
            <note>
               <p>Throughout this specification, an element or attribute that is in no namespace, or
                  an <termref def="dt-expanded-qname">expanded QName</termref> whose namespace part
                  is an empty sequence, is referred to as having a <term>null namespace
                  URI</term>.</p>
            </note>
            <note>
               <p>By convention, the names of <termref def="dt-xslt-element">XSLT
                  elements</termref>, attributes and functions are all lower-case; they use hyphens
                  to separate words, and they use abbreviations only if these already appear in the
                  syntax of a related language such as XML or HTML. Names of types defined in XML
                  Schema are regarded as single words and are capitalized exactly as in XML Schema.
                  This sometimes leads to composite function names such as
                     <xfunction>current-dateTime</xfunction>.</p>
            </note>
         </div2>
         <div2 id="extension-attributes">
            <head>Extension Attributes</head>
            <p>
               <termdef id="dt-extension-attribute" term="extension attribute">An element from the
                  XSLT namespace may have any attribute not from the XSLT namespace, provided that
                  the <termref def="dt-expanded-qname">expanded QName</termref> (see <bibref
                     ref="xpath-30"/>) of the attribute has a non-null namespace URI. These
                  attributes are referred to as <term>extension attributes</term>.</termdef> The
               presence of an extension attribute <rfc2119>must not</rfc2119> cause the <phrase
                  diff="add" at="S-bug27258"><termref def="dt-principal-result"/> or any <termref
                     def="dt-secondary-result"/> of the transformation to be different from the
                  results</phrase>
               <phrase diff="del" at="S-bug27258"><termref def="dt-final-result-tree">final result
                     trees</termref> produced by the transformation to be different from the result
                  trees</phrase> that a conformant XSLT <phrase diff="chg" at="A">3.0</phrase>
               processor might produce. They <rfc2119>must not</rfc2119> cause the processor to fail
               to signal an error that a conformant processor is required to signal. This means that
               an extension attribute <rfc2119>must not</rfc2119> change the effect of any <termref
                  def="dt-instruction">instruction</termref> except to the extent that the effect is
                  <termref def="dt-implementation-defined">implementation-defined</termref> or
                  <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p>
            <p>Furthermore, if serialization is performed using one of the serialization methods
                  <phrase diff="del" at="S-bug27258"><code>xml</code>, <code>xhtml</code>,
                     <code>html</code>, or <code>text</code></phrase> described in <bibref
                  ref="xslt-xquery-serialization-30"/>, the presence of an extension attribute must
               not cause the serializer to behave in a way that is inconsistent with the mandatory
               provisions of that specification.</p>
            <note>
               <p>
                  <termref def="dt-extension-attribute">Extension attributes</termref> may be used
                  to modify the behavior of <termref def="dt-extension-function">extension
                     functions</termref> and <termref def="dt-extension-instruction">extension
                     instructions</termref>. They may be used to select processing options in cases
                  where the specification leaves the behavior <termref
                     def="dt-implementation-defined">implementation-defined</termref> or <termref
                     def="dt-implementation-dependent">implementation-dependent</termref>. They may
                  also be used for optimization hints, for diagnostics, or for documentation.</p>
               <p>
                  <termref def="dt-extension-attribute">Extension attributes</termref> may also be
                  used to influence the behavior of the serialization methods <code>xml</code>,
                     <code>xhtml</code>, <code>html</code>, or <code>text</code>, to the extent that
                  the behavior of the serialization method is <termref
                     def="dt-implementation-defined"/> or <termref def="dt-implementation-dependent"
                     >implementation-dependent</termref>. For example, an extension attribute might
                  be used to define the amount of indentation to be used when
                     <code>indent="yes"</code> is specified. If a serialization method other than
                  one of these four is requested (using a prefixed QName in the method parameter)
                  then extension attributes may influence its behavior in arbitrary ways. Extension
                  attributes must not be used to cause the <phrase diff="del" at="V-bug30090"
                     >four</phrase> standard serialization methods to behave in a non-conformant
                  way, for example by failing to report serialization errors that a serializer is
                  required to report. An implementation that wishes to provide such options must
                  create a new serialization method for the purpose.</p>
               <p>An implementation that does not recognize the name of an extension attribute, or
                  that does not recognize its value, must perform the transformation as if the
                  extension attribute were not present. As always, it is permissible to produce
                  warning messages.</p>
               <p>The namespace used for an extension attribute will be copied to the <termref
                     def="dt-result-tree">result tree</termref> in the normal way if it is in scope
                  for a <termref def="dt-literal-result-element">literal result element</termref>.
                  This can be prevented using the <code>[xsl:]exclude-result-prefixes</code>
                  attribute.</p>
            </note>
            <example>
               <head>An Extension Attribute for <code>xsl:message</code>
               </head>
               <p>The following code might be used to indicate to a particular implementation that
                  the <elcode>xsl:message</elcode> instruction is to ask the user for confirmation
                  before continuing with the transformation:</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:message abc:pause="yes"
    xmlns:abc="http://vendor.example.com/xslt/extensions"&gt;
       Phase 1 complete
&lt;/xsl:message&gt;
</eg>
               <p>Implementations that do not recognize the namespace
                     <code>http://vendor.example.com/xslt/extensions</code> will simply ignore the
                  extra attribute, and evaluate the <elcode>xsl:message</elcode> instruction in the
                  normal way.</p>
            </example>
            <p>
               <error spec="XT" type="static" class="SE" code="0090"><p>It is a <termref
                        def="dt-static-error">static error</termref> for an element from the XSLT
                     namespace to have an attribute whose namespace is either null (that is, an
                     attribute with an unprefixed name) or the XSLT namespace, other than attributes
                     defined for the element in this document.</p></error>
            </p>
         </div2>
         <div2 id="xslt-media-type">
            <head>XSLT Media Type</head>
            <p>The media type <code>application/xslt+xml</code>
               <phrase diff="chg" at="A">has been</phrase> registered for XSLT stylesheet
               modules.</p>
            <p>The definition of the media type is at <bibref ref="XSLT-Mime-Type"/>.</p>
            <p>This media type <rfc2119>should</rfc2119> be used for an XML document containing a
                  <termref def="dt-standard-stylesheet-module">standard stylesheet module</termref>
               at its top level, and it <rfc2119>may</rfc2119> also be used for a <termref
                  def="dt-simplified-stylesheet-module">simplified stylesheet module</termref>. It
                  <rfc2119>should not</rfc2119> be used for an XML document containing an <termref
                  def="dt-embedded-stylesheet-module">embedded stylesheet module</termref>.</p>
         </div2>
         <div2 id="standard-attributes">
            <head>Standard Attributes</head>
            <p>
               <termdef id="dt-standard-attributes" term="standard attributes">There are a number of
                     <term>standard attributes</term> that may appear on any <termref
                     def="dt-xslt-element">XSLT element</termref>: specifically
                     <code>default-collation</code>, <code diff="add" at="P">default-mode</code>,
                     <code diff="add" at="P">default-validation</code>,
                     <code>exclude-result-prefixes</code>, <phrase diff="add" at="M"
                        ><code>expand-text</code>, </phrase><code>extension-element-prefixes</code>,
                     <code>use-when</code>, <code>version</code>, and
                     <code>xpath-default-namespace</code>.</termdef>
            </p>
            <p>These attributes may also appear on a <termref def="dt-literal-result-element"
                  >literal result element</termref>, but in this case, to distinguish them from
               user-defined attributes, the names of the attributes are in the <termref
                  def="dt-xslt-namespace">XSLT namespace</termref>. They are thus typically written
               as <code>xsl:default-collation</code>, <code diff="add" at="P"
                  >xsl:default-mode</code>, <code diff="add" at="P">xsl:default-validation</code>,
                  <code>xsl:exclude-result-prefixes</code>, <phrase diff="add" at="M"
                     ><code>xsl:expand-text</code>, </phrase>
               <code>xsl:extension-element-prefixes</code>, <code>xsl:use-when</code>,
                  <code>xsl:version</code>, or <code>xsl:xpath-default-namespace</code>.</p>
            <p>It is <rfc2119>recommended</rfc2119> that all these attributes should also be
               permitted on <termref def="dt-extension-instruction">extension
               instructions</termref>, but this is at the discretion of the implementer of each
               extension instruction. They <rfc2119>may</rfc2119> also be permitted on <termref
                  def="dt-data-element">user-defined data elements</termref>, though they will only
               have any useful effect in the case of data elements that are designed to behave like
               XSLT declarations or instructions.</p>
            <p>In the following descriptions, these attributes are referred to generically as
                  <code>[xsl:]version</code>, and so on.</p>
            <p>These attributes all affect the element they appear on, together with any elements
               and attributes that have that element as an ancestor. The two forms with and without
               the XSLT namespace have the same effect; the XSLT namespace is used for the attribute
               if and only if its parent element is <emph>not</emph> in the XSLT namespace.</p>
            <p>In the case of <code>[xsl:]default-collation</code>, <phrase diff="add" at="M"
                     ><code>[xsl:]expand-text</code>, </phrase>
               <code>[xsl:]version</code>, and <code>[xsl:]xpath-default-namespace</code>, the value
               can be overridden by a different value for the same attribute appearing on a
               descendant element. The effective value of the attribute for a particular stylesheet
               element is determined by the innermost ancestor-or-self element on which the
               attribute appears.</p>
            <p>In an <termref def="dt-embedded-stylesheet-module">embedded stylesheet
                  module</termref>, <termref def="dt-standard-attributes">standard
                  attributes</termref> appearing on ancestors of the outermost element of the
               stylesheet module have no effect.</p>
            <p>In the case of <code>[xsl:]exclude-result-prefixes</code> and
                  <code>[xsl:]extension-element-prefixes</code> the values are cumulative. For these
               attributes, the value is given as a whitespace-separated list of namespace prefixes,
               and the effective value for an element is the combined set of namespace URIs
               designated by the prefixes that appear in this attribute for that element and any of
               its ancestor elements. Again, the two forms with and without the XSLT namespace are
               equivalent.</p>
            <p>The effect of the <code>[xsl:]use-when</code> attribute is described in <specref
                  ref="conditional-inclusion"/>.</p>
            <p>Because these attributes may appear on any <termref def="dt-xslt-element">XSLT
                  element</termref>, they are not listed in the syntax summary of each individual
               element. Instead they are listed and described in the entry for the
                  <elcode>xsl:stylesheet</elcode>, <elcode>xsl:transform</elcode>, <phrase
                  diff="add" at="M">and <elcode>xsl:package</elcode></phrase> elements only. This
               reflects the fact that these attributes are often used on the <phrase diff="chg"
                  at="P">outermost element of the stylesheet</phrase>, in which case they apply to
               the entire <termref def="dt-stylesheet-module"/>
               <phrase diff="add" at="M">or <termref def="dt-package-manifest"/></phrase>.</p>
            <p>Note that the effect of these attributes does <emph>not</emph> extend to <termref
                  def="dt-stylesheet-module">stylesheet modules</termref> referenced by
                  <elcode>xsl:include</elcode> or <elcode>xsl:import</elcode> declarations, <phrase
                  diff="add" at="M">nor to packages referenced using
                     <elcode>xsl:use-package</elcode></phrase>.</p>
            <p>For the detailed effect of each attribute, see the following sections:</p>
            <glist>
               <gitem>
                  <label>
                     <code>[xsl:]default-collation</code>
                  </label>
                  <def>
                     <p>see <specref ref="default-collation-attribute"/>
                     </p>
                  </def>
               </gitem>
               <gitem diff="add" at="P">
                  <label>
                     <code>[xsl:]default-mode</code>
                  </label>
                  <def>
                     <p>see <specref ref="default-mode"/>
                     </p>
                  </def>
               </gitem>
               <gitem diff="add" at="P">
                  <label>
                     <code>[xsl:]default-validation</code>
                  </label>
                  <def>
                     <p>see <specref ref="validation"/>
                     </p>
                  </def>
               </gitem>
               <gitem>
                  <label>
                     <code>[xsl:]exclude-result-prefixes</code>
                  </label>
                  <def>
                     <p>see <specref ref="lre-namespaces"/>
                     </p>
                  </def>
               </gitem>
               <gitem diff="add" at="M">
                  <label>
                     <code>[xsl:]expand-text</code>
                  </label>
                  <def>
                     <p>see <specref ref="text-value-templates"/>
                     </p>
                  </def>
               </gitem>
               <gitem>
                  <label>
                     <code>[xsl:]extension-element-prefixes</code>
                  </label>
                  <def>
                     <p>see <specref ref="extension-instruction"/>
                     </p>
                  </def>
               </gitem>
               <gitem>
                  <label>
                     <code>[xsl:]use-when</code>
                  </label>
                  <def>
                     <p>see <specref ref="conditional-inclusion"/>
                     </p>
                  </def>
               </gitem>
               <gitem>
                  <label>
                     <code>[xsl:]version</code>
                  </label>
                  <def>
                     <p>see <specref ref="backwards"/> and <specref ref="forwards"/>
                     </p>
                  </def>
               </gitem>
               <gitem>
                  <label>
                     <code>[xsl:]xpath-default-namespace</code>
                  </label>
                  <def>
                     <p>see <specref ref="unprefixed-qnames"/>
                     </p>
                  </def>
               </gitem>
            </glist>
         </div2>
         <div2 id="packages" at="I" diff="chg">
            <head>Packages</head>
            <p><termdef id="dt-package" term="package">An explicit <term>package</term> is
                  represented by an <elcode>xsl:package</elcode> element, which will generally be
                  the outermost element of an XML document. <phrase diff="add" at="26422">When the
                        <elcode>xsl:package</elcode> element is not used explicitly, the entire
                     stylesheet comprises a single implicit package.</phrase></termdef> (This
               specification does not preclude the <elcode>xsl:package</elcode> being embedded in
               another XML document, but it will never have any other XSLT element as an
               ancestor).</p>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="package">
               <e:attribute name="id" required="no">
                  <e:data-type name="id"/>
               </e:attribute>
               <e:attribute name="name" required="no">
                  <e:data-type name="uri"/>
               </e:attribute>
               <e:attribute name="package-version" required="no">
                  <e:data-type name="string"/>
               </e:attribute>
               <e:attribute name="version" required="yes">
                  <e:data-type name="decimal"/>
               </e:attribute>

               <e:attribute name="input-type-annotations">
                  <e:constant value="preserve"/>
                  <e:constant value="strip"/>
                  <e:constant value="unspecified"/>
               </e:attribute>
               <e:attribute name="declared-modes" required="no">
                  <e:data-type name="boolean"/>
               </e:attribute>
               <e:attribute name="default-mode">
                  <e:data-type name="eqname"/>
                  <e:constant value="#unnamed"/>
               </e:attribute>
               <e:attribute name="default-validation">
                  <e:constant value="preserve"/>
                  <e:constant value="strip"/>
               </e:attribute>

               <e:attribute name="default-collation" required="no">
                  <e:data-type name="uris"/>
               </e:attribute>
               <e:attribute name="extension-element-prefixes" required="no">
                  <e:data-type name="prefixes"/>
               </e:attribute>
               <e:attribute name="exclude-result-prefixes" required="no">
                  <e:data-type name="prefixes"/>
               </e:attribute>
               <e:attribute name="expand-text" required="no">
                  <e:data-type name="boolean"/>
               </e:attribute>
               <e:attribute name="use-when" required="no">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="xpath-default-namespace" required="no">
                  <e:data-type name="uri"/>
               </e:attribute>

               <e:sequence>
                  <e:choice repeat="zero-or-more">
                     <e:element name="expose"/>
                     <e:model name="declarations"/>
                  </e:choice>
               </e:sequence>
               <e:allowed-parents/>
            </e:element-syntax>
            <p><termdef id="dt-package-manifest" term="package manifest">The content of the
                     <elcode>xsl:package</elcode> element is referred to as the <term>package
                     manifest</term></termdef>.</p>
            <p>The <phrase diff="chg" at="M"><code>version</code></phrase> attribute indicates the
               version of the XSLT language specification to which the package manifest conforms.
                  <phrase diff="chg" at="R-bug26780">The value <rfc2119>should</rfc2119> normally be
                     <code>3.0</code>. If the value is numerically less than <code>3.0</code>, the
                  content of the <elcode>xsl:package</elcode> element is processed using the rules
                  for <termref def="dt-backwards-compatible-behavior">backwards compatible
                     behavior</termref> (see <specref ref="backwards"/>). If the value is
                  numerically greater than <code>3.0</code>, it is processed using the rules for
                     <termref def="dt-forwards-compatible-behavior"/> (see <specref ref="forwards"
                  />).</phrase></p>
            <p diff="chg" at="O">A package typically has a name, given in its <code>name</code>
               attribute, which <rfc2119>must</rfc2119> be an absolute URI. Unnamed packages are
               allowed, but they can only be used as the “top level” of an application; they cannot
               be the target of an <elcode>xsl:use-package</elcode> declaration in another
               package.</p>
            <p><phrase diff="chg" at="O">A package may have</phrase> a version identifier, given in
               its <code>package-version</code> attribute. This is used to distinguish different
               versions of a package. <phrase diff="chg" at="P-bug22733">The value of the version
                  attribute, after trimming leading and trailing whitespace, <rfc2119>must</rfc2119>
                  conform to the syntax given in <specref ref="package-versions"/>. If no version
                  number is specified for a package, version <code>1</code> is assumed.</phrase></p>
            <p diff="add" at="M">The attributes <code>default-collation</code>, <code diff="add"
                  at="P">default-mode</code>, <code diff="add" at="P">default-validation</code>,
                  <code>exclude-result-prefixes</code>, <code>expand-text</code>,
                  <code>extension-element-prefixes</code>, <code>use-when</code>,
                  <code>version</code>, and <code>xpath-default-namespace</code> are standard
               attributes that can appear on any XSLT element, and potentially affect all descendant
               elements. Their meaning is described in <specref ref="standard-attributes"/>.</p>
            <p>The package manifest <phrase diff="chg" at="R-bug23944">contains the following
                  elements, arbitrarily ordered</phrase>:</p>
            <olist>
               <item>
                  <p>Zero or more <elcode>xsl:expose</elcode> declarations that define the interface
                     offered by this package to the outside world. An <elcode>xsl:expose</elcode>
                     declaration may appear only as a child of <elcode>xsl:package</elcode>.</p>
               </item>
               <item>
                  <p>Zero or more additional <termref def="dt-declaration">declarations</termref>.
                     These are the same as the declarations permitted as children of
                        <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode>.</p>
                  <p>Some declarations of particular relevance to packages include:</p>
                  <olist>
                     <item diff="add" at="R-bug29121">
                        <p>The <elcode>xsl:use-package</elcode> declaration, which declares the
                           names and versions of the packages on which this package is
                           dependant.</p>
                     </item>
                     <item diff="add" at="R-bug24764">
                        <p>The optional <elcode>xsl:global-context-item</elcode> element; if present
                           this element defines constraints on the existence and type of the
                              <termref def="dt-global-context-item"/>.</p>
                     </item>
                     <item>
                        <p>Zero or more <elcode>xsl:include</elcode> and <elcode>xsl:import</elcode>
                           declarations, which define additional stylesheet modules to be
                           incorporated into this package.</p>
                     </item>
                     <item>
                        <p>Zero or more ordinary <termref def="dt-declaration"
                              >declarations</termref>, that is, elements that are permitted as
                           children of <elcode>xsl:stylesheet</elcode> or
                              <elcode>xsl:transform</elcode>. One possible coding style is to
                           include in the package manifest just a single <elcode>xsl:import</elcode>
                           or <elcode>xsl:include</elcode> declaration as a reference to the
                           effective top-level stylesheet module; this approach is particularly
                           suitable when writing code that is required to run under earlier releases
                           of XSLT as well as under XSLT 3.0. Another approach is to include the
                           substance of the top-level stylesheet module inline within the package
                           manifest.</p>
                     </item>
                  </olist>
               </item>
            </olist>
            <example diff="add" at="R-bug26468">
               <head>An example package</head>
               <p>The following example shows a package that offers a number of functions for
                  manipulating complex numbers. A complex number is represented as a map with two
                  entries, the keys being 0 for the real part, and 1 for the imaginary part.</p>
               <eg role="xslt-document" xml:space="preserve">
&lt;xsl:package
  name="http://example.org/complex-arithmetic.xsl"
  package-version="1.0"
  version="3.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:f="http://example.org/complex-arithmetic.xsl"&gt;
  
  &lt;xsl:function name="f:complex-number" 
                as="map(xs:integer, xs:double)" visibility="public"&gt;
    &lt;xsl:param name="real" as="xs:double"/&gt;
    &lt;xsl:param name="imaginary" as="xs:double"/&gt;
    &lt;xsl:sequence select="map{ 0:$real, 1:$imaginary }"/&gt;
  &lt;/xsl:function&gt;
  
  &lt;xsl:function name="f:real" 
                as="xs:double" visibility="public"&gt;
    &lt;xsl:param name="complex" as="map(xs:integer, xs:double)"/&gt;
    &lt;xsl:sequence select="$complex(0)"/&gt;
  &lt;/xsl:function&gt;
  
  &lt;xsl:function name="f:imag" 
                as="xs:double" visibility="public"&gt;
    &lt;xsl:param name="complex" as="map(xs:integer, xs:double)"/&gt;
    &lt;xsl:sequence select="$complex(1)"/&gt;
  &lt;/xsl:function&gt;
  
  &lt;xsl:function name="f:add" 
                as="map(xs:integer, xs:double)" visibility="public"&gt;
    &lt;xsl:param name="x" as="map(xs:integer, xs:double)"/&gt;
    &lt;xsl:param name="y" as="map(xs:integer, xs:double)"/&gt;
    &lt;xsl:sequence select="
         f:complex-number(
           f:real($x) + f:real($y), 
           f:imag($x) + f:imag($y))"/&gt;
  &lt;/xsl:function&gt;
  
  &lt;xsl:function name="f:multiply" 
                as="map(xs:integer, xs:double)" visibility="public"&gt;
    &lt;xsl:param name="x" as="map(xs:integer, xs:double)"/&gt;
    &lt;xsl:param name="y" as="map(xs:integer, xs:double)"/&gt;
    &lt;xsl:sequence select="
         f:complex-number(
           f:real($x)*f:real($y) - f:imag($x)*f:imag($y),
           f:real($x)*f:imag($y) + f:imag($x)*f:real($y))"/&gt;
  &lt;/xsl:function&gt;
  
  &lt;!-- etc. --&gt;
  
&lt;/xsl:package&gt;</eg>
               <p>A more complex package might include private or abstract functions as well as
                  public functions; it might expose components other than functions (for example,
                  templates or global variables), and it might contain
                     <elcode>xsl:use-package</elcode> elements to allow it to call on the services
                  of other packages.</p>
               <note>
                  <p>In this example, the way in which complex numbers are represented is exposed to
                     users of the package. It would be possible to hide the representation by
                     declaring the types on public functions simply as <code>item()</code>; but this
                     would be at the cost of type safety.</p>
               </note>
            </example>
            <p diff="chg" at="R-bug24307">A package that does not itself expose any components
                  <phrase diff="del" at="S">or use any <termref def="dt-library-package">library
                     packages</termref></phrase> may be written using a simplified syntax: the
                  <elcode>xsl:package</elcode> element is omitted, and the
                  <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element is now
               the outermost element of the stylesheet module. For compatibility reasons, all the
               named templates and modes declared in the package are made public. More formally, the
               principal stylesheet module of the <termref def="dt-top-level-package">top-level
                  package</termref> may be expressed as an <elcode>xsl:stylesheet</elcode> or
                  <elcode>xsl:transform</elcode> element, which is equivalent to the package
               represented by the output of the following transformation, preserving the base URI of
               the source:</p>
            <eg diff="chg" at="R-bug26468" role="xslt-document" xml:space="preserve">
 &lt;xsl:transform version="3.0" 
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:t="http://www.w3.org/1999/XSL/TransformAlias"&gt;
 
    &lt;xsl:namespace-alias stylesheet-prefix="t" result-prefix="xsl"/&gt;
    
    &lt;xsl:template match="xsl:stylesheet|xsl:transform"&gt;
      &lt;t:package declared-modes="no"&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        &lt;t:expose component="mode" names="*" visibility="public"/&gt;
        &lt;t:expose component="template" names="*" visibility="public"/&gt;
        &lt;xsl:copy-of select="node()"/&gt;
      &lt;/t:package&gt;
    &lt;/xsl:template&gt;
 &lt;/xsl:transform&gt;
       </eg>
            <p diff="add" at="P-bug22733">The effect of the <code>input-type-annotations</code>
               attribute is defined in <specref ref="stripping-annotations"/>.</p>
            <p diff="add" at="S+">A more extensive example of a package, illustrating how components
               in a package can be overridden in a client package, is given in <specref
                  ref="packages-csv-library-example"/>.</p>
            <div3 id="package-versions" diff="add" at="R-bug26443">
               <head>Versions of a Package</head>
               <p>If a package has a version number, the version number must conform to the
                  grammar:</p>
               <eg role="non-xml" xml:space="preserve">
        PackageVersion   ::= NumericPart ( "-" NamePart )?
        NumericPart      ::= IntegerLiteral ( "." IntegerLiteral )*
        NamePart         ::= NCName
               </eg>
               <p>Here <phrase diff="chg" at="R-bug26649"><xnt
                        xmlns:xlink="http://www.w3.org/1999/xlink" ref="prod-xpath30-IntegerLiteral"
                        spec="XP30" xlink:type="simple">IntegerLiteral</xnt> and <code>NCName</code>
                     are as defined in the XPath 3.0 grammar productions of the same name (including
                     rules on limits)</phrase>. Leading and trailing whitespace is ignored; no other
                  whitespace is allowed.</p>
               <p>Examples of valid version numbers are <code>2.0.5</code> or
                     <code>3.10-alpha</code>.</p>
               <p><termdef id="dt-portion" term="portion">The integer literals and the optional
                        <code>NamePart</code> within the version number are referred to as the
                        <term>portions</term> of the version number.</termdef></p>
               <note diff="add" at="S-bug28215">
                  <p>This means that <code>1-alpha-2</code> is a valid version number, with two
                        <termref def="dt-portion">portions</termref>: <code>1</code> and
                        <code>alpha-2</code>. The second hyphen is part of the <code>NCName</code>,
                     it does not act as a portion separator.</p>
               </note>
               <p>Versions are ordered. When comparing two versions:</p>
               <olist>
                  <item>
                     <p>Trailing zero <termref def="dt-portion">portions</termref> (that is, any
                        zero-valued integer that is not followed by another integer) are
                        discarded.</p>
                  </item>
                  <item>
                     <p>Comparison proceeds by comparing <termref def="dt-portion"
                           >portions</termref> pairwise from the left.</p>
                  </item>
                  <item>
                     <p>If both versions have the same number of <termref def="dt-portion"
                           >portions</termref> and all <termref def="dt-portion">portions</termref>
                        compare equal <phrase diff="add" at="R-bug26648">(under the rules of the
                           XPath <code>eq</code> operator using the Unicode codepoint
                           collation)</phrase>, then the versions compare equal.</p>
                  </item>
                  <item>
                     <p>If the number of <termref def="dt-portion">portions</termref> in the two
                        versions <var>V1</var> and <var>V2</var> is <var>N1</var> and <var>N2</var>,
                        with <var>N1</var>&lt;<var>N2</var>, and if all <termref def="dt-portion"
                           >portions</termref> in positions 1 to <var>N</var> compare equal, then
                           <var>V1</var> is less than <var>V2</var> if the <termref def="dt-portion"
                        /> of <var>V2</var> in position <var>N1+1</var> is an integer, and is
                        greater than <var>V2</var> if this <termref def="dt-portion"/> is an
                           <code>NCName</code>. For example, <code>1.2</code> is less than
                           <code>1.2.5</code>, while <code>2.0</code> is greater than
                           <code>2.0-rc1</code>.</p>
                  </item>
                  <item>
                     <p><termref def="dt-portion">Portions</termref> are compared as follows:</p>
                     <olist>
                        <item>
                           <p>If both <termref def="dt-portion">portions</termref> are integers,
                              they are compared <phrase diff="add" at="R-bug26648">using the rules
                                 of XPath value comparisons</phrase>.</p>
                        </item>
                        <item>
                           <p>If both <termref def="dt-portion">portions</termref> are NCNames, they
                              are compared <phrase diff="add" at="R-bug26648">using the rules of
                                 XPath value comparisons</phrase>, using the Unicode Codepoint
                              Collation.</p>
                        </item>
                        <item>
                           <p>If one <termref def="dt-portion"/> is an integer and the other is an
                                 <code>NCName</code>, the <code>NCName</code> comes first.</p>
                        </item>
                     </olist>
                  </item>
               </olist>
               <p>For example, the following shows a possible ordered sequence of version
                  numbers:</p>
               <eg role="non-xml" xml:space="preserve">0-rc1 &lt; 0-rc2 &lt; 0 &lt; 1 = 1.0 &lt; 1.0.2 
   &lt; 1.0.3-rc1 &lt; 1.0.3 &lt; 1.0.3.2 &lt; 1.0.10</eg>
               <note>
                  <p>The version number format defined here is designed to be general enough to
                     accommodate a variety of conventions in common use, and to allow useful
                     semantics for matching of versions and ranges of versions, without being
                     over-prescriptive. It is influenced by <bibref ref="SemVer"/>, but is not as
                     prescriptive, and it imposes no assumptions about backwards compatibility of
                     packages between successive versions.</p>
               </note>
               <p diff="add" at="T-bug29880">Implementations <rfc2119>may</rfc2119> impose limits on
                  the values used in a version number (or a version range: see below). Such limits
                  are <termref def="dt-implementation-defined"/>. As a minimum, a processor
                     <rfc2119>must</rfc2119> accept version numbers including:</p>
               <ulist diff="add" at="T-bug29880">
                  <item>
                     <p>A numeric part containing four integers;</p>
                  </item>
                  <item>
                     <p>Each integer being in the range 0 to 999999;</p>
                  </item>
                  <item>
                     <p>An <code>NCName</code> of up to 100 characters</p>
                  </item>
               </ulist>
               <p>Dependencies between packages may specify a version range (see <specref
                     ref="package-dependencies"/>). A version range represents a set of accepted
                  versions. <phrase diff="chg" at="R-bug26649">The syntax of a version range is
                     shown below. Whitespace is permitted only where indicated, using the terminal
                     symbol <var>S</var>.</phrase></p>
               <eg role="non-xml" xml:space="preserve">
        PackageVersionRange    ::=  AnyVersion | VersionRanges
        AnyVersion             ::=  "*"
        VersionRanges          ::=  <phrase diff="chg" at="S-bug26997">VersionRange (S? "," S? VersionRange)*</phrase>
        VersionRange           ::=  <phrase diff="chg" at="S-bug28215">PackageVersion |</phrase> VersionPrefix | 
                                      VersionFrom | VersionTo | VersionFromTo
        VersionPrefix          ::=  PackageVersion ".*"
        VersionFrom            ::=  PackageVersion "+"
        VersionTo              ::=  "to" S <phrase diff="chg" at="S-bug28215">(PackageVersion | VersionPrefix)</phrase>
        VersionFromTo          ::=  PackageVersion S "to" S <phrase diff="chg" at="S-bug26997">(PackageVersion | VersionPrefix)</phrase>     
               </eg>
               <p diff="chg" at="R-bug26649">The meanings of the various forms of version range are
                  defined below:</p>
               <ulist diff="chg" at="R-bug26649">
                  <item>
                     <p>The range <code>AnyVersion</code> matches any version.</p>
                  </item>
                  <item>
                     <p>The range <code>VersionRanges</code> matches a version if any constituent
                           <code>VersionRange</code> matches that version.</p>
                     <p diff="add" at="S-bug28215">For example, <code>9.5.0.8, 9.6.1.2</code>
                        matches those specific versions only, while <code>9.5.0.8, 9.6+</code>
                        matches either version 9.5.0.8 or any version from 9.6 onwards.</p>
                  </item>
                  <item diff="add" at="S-bug28215">
                     <p>A range that is a <code>PackageVersion</code> matches that version only.</p>
                  </item>
                  <item>
                     <p>The range <code>VersionPrefix</code> matches any version whose leading
                           <termref def="dt-portion">portions</termref> are the same as the <termref
                           def="dt-portion">portions</termref> in the <phrase diff="add"
                           at="S-bug28215"><code>PackageVersion</code> part of the
                              <code>VersionPrefix</code></phrase>.</p>
                     <p>For example, <code>1.3.*</code> matches <code>1.3</code>, 
                           <code>1.3.5</code>,  <code>1.3.10.2</code>,  and <code>1.3-beta</code>
                        <phrase diff="add" at="S-bug28215">(but not <code>1</code> or
                              <code>1.4</code>)</phrase>.</p>
                     <note diff="add" at="S-bug28215">
                        <p>The <code>.*</code> indicates that additional <termref def="dt-portion"
                              >portions</termref> may follow; it does not indicate a substring match
                           on the final <termref def="dt-portion">portion</termref>. So
                              <code>1.3.*</code> does not match <code>1.35</code>, and
                              <code>3.3-beta.*</code> does not match <code>3.3-beta12</code>. Also,
                              <code>3.3-beta.*</code> does not match <code>3.3-beta.5</code>: this
                           is because the last dot is not a portion separator, but is part of the
                           final <code>NCName</code>. In fact, using <code>.*</code> after a version
                           number that includes an <code>NCName</code> portion is pointless, because
                           an <code>NCName</code> portion can never be followed by further
                           portions.</p>
                     </note>
                  </item>
                  <item>
                     <p>The range <code>VersionFrom</code> matches any version that is greater than
                        or equal to the version supplied.</p>
                     <p diff="add" at="S-bug28215">For example <code>1.3+</code> matches
                           <code>1.3</code>,  <code>1.3.2</code>,  <code>1.4</code>,  and
                           <code>2.1</code> (but not <code>1.3-beta</code> or <code>1.2</code>). And
                           <code>1.3-beta+</code> matches <code>1.3-beta</code>, 
                           <code>1.3-gamma</code>,  <code>1.3.0</code>,  <code>1.4</code>, and
                           <code>8.0</code>, but not <code>1.3-alpha</code> or <code>1.2</code>.</p>
                  </item>
                  <item>
                     <p>The range <code>VersionTo</code> matches any version that is less than or
                        equal to some version that matches the <code>VersionPrefix</code>.</p>
                     <p>For example, <code>to 4.0</code> matches <code>1.5</code>, 
                        <code>2.3</code>,  <code>3.8</code>,  <code>4.0</code>,  and
                           <code>4.0-beta</code> (but not <code>4.0.1</code>), while <code>to
                           3.3.*</code> matches <code>1.5</code> or <code>2.0.6</code> or
                           <code>3.3.4621</code>, but not <code>3.4.0</code> or
                           <code>3.4.0-beta</code>. </p>
                  </item>
                  <item>
                     <p>The range <code>VersionFromTo</code> matches any version that is greater
                        than or equal to the starting <code>PackageVersion</code>, and less than or
                        equal to some version that matches the <code>VersionPrefix</code>.</p>
                     <p>For example, <code>1 to 5</code> matches <code>1.1</code>, 
                        <code>2.1</code>,  <code>3.1</code>,  or <code>5.0</code> (but not
                           <code>5.1</code>), while <code>1 to 5.*</code> matches all of these, plus
                        versions such as <code>5.7.2</code> (but not <code>6.0</code> or
                           <code>6.0-beta</code>). <phrase diff="add" at="S-bug28215">Similarly,
                              <code>1.0-beta to 1.0</code> matches <code>1.0-beta</code>,
                              <code>1.0-beta.2</code>, <code>1.0-gamma</code>, and <code>1.0</code>,
                           but not <code>1.0-alpha</code> or <code>1.0.1</code>.</phrase></p>
                  </item>
               </ulist>
            </div3>
            <div3 id="package-dependencies">
               <head>Dependencies between Packages</head>
               <p>When <termref def="dt-component">components</termref> in one <termref
                     def="dt-package"/> reference components in another, the dependency of the first
                  package on the second must be represented by an <elcode>xsl:use-package</elcode>
                  element. <phrase diff="chg" at="T-bug29453">This may appear in the <termref
                        def="dt-principal-stylesheet-module"/> of the first package (which may be a
                        <termref def="dt-package-manifest"/>), or it may appear in a <termref
                        def="dt-stylesheet-module"/> that is referenced from the <termref
                        def="dt-principal-stylesheet-module"/> via one or more
                        <elcode>xsl:include</elcode> declarations; however it must not be referenced
                     via <elcode>xsl:import</elcode> declarations (this is to avoid complications
                     caused by multiple <elcode>xsl:use-package</elcode> declarations with different
                        <termref def="dt-import-precedence"/>).</phrase></p>
               <p><termdef id="dt-use" term="use">If a package <var>Q</var> contains an
                        <elcode>xsl:use-package</elcode> element that references package
                        <var>P</var>, then package <var>Q</var> is said to <term>use</term> package
                        <var>P</var>. In this relationship package <var>Q</var> is referred to as
                     the <term>using</term> package, package <var>P</var> as the <term>used</term>
                     package.</termdef></p>
               <p>The phrase <term>directly uses</term> is synonymous with <term>uses</term> as
                  defined above, while <term>directly or indirectly uses</term> refers to the
                  transitive closure of this relationship.</p>
               <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
                  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="use-package">
                  <e:in-category name="declaration"/>
                  <e:attribute name="name" required="yes">
                     <e:data-type name="uri"/>
                  </e:attribute>
                  <e:attribute name="package-version" required="no">
                     <e:data-type name="string"/>
                  </e:attribute>
                  <e:choice repeat="zero-or-more">
                     <e:element name="accept"/>
                     <e:element name="override"/>
                  </e:choice>
                  <e:allowed-parents>
                     <e:parent name="package"/>
                     <e:parent name="stylesheet"/>
                     <e:parent name="transform"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p>A <termref def="dt-package">package</termref> may be <termref def="dt-use"
                     >used</termref> by more than one other package, but the relationship
                     <rfc2119>must not</rfc2119> be cyclic. It is possible, but by no means
                  inevitable, that using the same package in more than one place within a stylesheet
                  will cause static errors due to the presence of conflicting components according
                  to the above rules. Where a package is successfully used by more than one other
                  package, its components may be overridden in different ways by different using
                  packages.</p>
               <p>The <code>name</code> and <code>package-version</code> attributes together
                  identify the used package. <phrase diff="add" at="P-bug22733">The value of the
                        <code>package-version</code> attribute, if present, must conform to the
                     rules for a <phrase diff="chg" at="P-bug28215"
                        ><code>PackageVersionRange</code></phrase> given in <specref
                        ref="package-versions"/>; if omitted the value <code>*</code> is assumed,
                     which matches any version. The used package must have a name that is an exact
                     match for the name in the <code>name</code> attribute (using codepoint
                     comparison), and its explicit or implicit <code>package-version</code> must
                     match the version range given in the <code>package-version</code>
                     attribute</phrase>.</p>
               <p diff="del" at="P-bug22733">The value of the <code>package-version</code> attribute
                  consists of a prefix and a suffix separated by a hash sign (#); if there is no
                  hash sign, the entire string is used as the prefix, and the suffix is empty; if
                  there is more than one hash sign, the first one is taken as the separator and
                  others as part of the suffix; if the hash sign is the last character in the string
                  then a suffix of <code>.*</code> is assumed. The pattern matches a package version
                  if the package version can be divided into two substrings such that the first
                  substring matches the prefix literally (using codepoint comparison), and the
                  second substring matches the suffix considered as a regular expression (matched
                  according to the rules of the <xfunction>matches</xfunction> function with the
                     <code>$flags</code> argument set to a zero length string). Thus the version
                  pattern <code>3.1</code> matches version <code>3.1</code> only; the pattern
                     <code>3.1#</code> matches <code>3.1</code>, <code>3.1.2</code>, and
                     <code>3.17</code>; the pattern <code>3.1#(\.\d+)?</code> matches
                     <code>3.1</code> and <code>3.1.5</code>; and the pattern
                     <code>3.1#(\.\d+)*</code> matches <code>3.1</code>, <code>3.1.5</code>, and
                     <code>3.1.5.2</code>.</p>
               <p>This specification does not define how the implementation locates a package given
                  its name and version. <phrase diff="add" at="P-bug22733">If several matching
                     versions of a package are available, it does not define which of them is
                     chosen.</phrase> Nor does it define whether this process locates source code or
                  some other representation of the package contents. Such mechanisms are <termref
                     def="dt-implementation-defined"/>. Use of the package name as a dereferenceable
                  URI is <rfc2119>not recommended</rfc2119>, because the intent of the packaging
                  feature is to allow a package to be distributed as reusable code and therefore to
                  exist in many different locations.</p>
               <imp-def-feature id="idf-api-packageversions">It is <termref
                     def="dt-implementation-defined"/> how a package is located given its name and
                  version, and which version of a package is chosen if several are
                  available.</imp-def-feature>
               <p diff="add" at="R-bug26477"><error spec="XT" type="static" class="SE" code="3000"
                        ><p>It is a <termref def="dt-static-error"/> if no package matching the
                        package name and version specified in an <elcode>xsl:use-package</elcode>
                        declaration can be located.</p></error></p>
               <p diff="add" at="S+"><error spec="XT" type="static" class="SE" code="3005"><p>It is
                        a <termref def="dt-static-error"/> if a package is dependent on itself,
                        where package <var>A</var> is defined as being dependent on package
                           <var>B</var> if <var>A</var> contains an <elcode>xsl:use-package</elcode>
                        declaration that references <var>B</var>, or if <var>A</var> contains an
                           <elcode>xsl:use-package</elcode> declaration that references a package
                           <var>C</var> that is itself dependent on <var>B</var>.</p></error></p>
               <p diff="add" at="T-bug29453"><error spec="XT" type="static" class="SE" code="3008"
                        ><p>It is a <termref def="dt-static-error"/> if an
                           <elcode>xsl:use-package</elcode> declaration appears in a <termref
                           def="dt-stylesheet-module"/> that is not in the same <termref
                           def="dt-stylesheet-level"/> as the <termref
                           def="dt-principal-stylesheet-module"/> of the <termref def="dt-package"
                        />.</p></error></p>
               <note>
                  <p>Depending on the implementation architecture, there may be a need to locate
                     used packages both during static analysis (for example, to get information
                     about the names and type signatures of the components exposed by the used
                     package), and also at evaluation time (to link to the implementation of these
                     components so they can be invoked). A failure to locate a package may cause an
                     error at either stage.</p>
               </note>
               <p>The <elcode>xsl:accept</elcode> and <elcode>xsl:override</elcode> elements are
                  used to modify the visibility or behavior of components acquired from the used
                  package; they are described in <specref ref="accepting-components"/> below.</p>
               <p diff="del" at="R">An <elcode>xsl:use-package</elcode> element whose parent element
                  is <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> is allowed
                  only if the <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> does
                  not form part of an explicit package.</p>
               <note>
                  <p diff="add" at="T-bug29667">It is not intrinsically an error to have two
                        <elcode>xsl:use-package</elcode> declarations that identify the same package
                     (or different versions of the same package). This has the same effect as having
                     two declarations that identify packages with different names but identical
                     content. In most cases it will result in an error (<errorref spec="XT"
                        class="SE" code="3050"/>) due to the presence of multiple components with
                     the same name; but no error would occur, for example, if the used package is
                     empty, or if the two <elcode>xsl:use-package</elcode> declarations use
                        <elcode>xsl:accept</elcode> to accept non-overlapping subsets of the
                     components in the used package.</p>
               </note>
            </div3>
            <div3 id="named-components">
               <head>Named Components in Packages</head>
               <p>This section discusses the use of named components in packages.</p>
               <p diff="chg" at="S-bug27340">The components which can be declared in one package and
                  referenced in another are: <termref def="dt-stylesheet-function"
                     >functions</termref>, <termref def="dt-named-template">named
                     templates</termref>, <termref def="dt-attribute-set">attribute sets</termref>,
                     <termref def="dt-mode">modes</termref>, <phrase diff="del" at="S-bug27648"
                        ><termref def="dt-accumulator">accumulators</termref>,</phrase> and <termref
                     def="dt-global-variable">global variables</termref> and <termref
                     def="dt-stylesheet-parameter">parameters</termref>.</p>
               <p diff="chg" at="S-bug27340">In addition, <phrase diff="add" at="P-bug22877"
                        ><termref def="dt-key">keys</termref></phrase> and <phrase diff="add"
                     at="S-bug27648"><termref def="dt-accumulator">accumulators</termref></phrase>
                  are classified as named components because they can contain references to
                  components in another package, even though they cannot themselves be referenced
                  from outside the package.</p>
               <p diff="chg" at="S-bug27340">Named and unnamed <termref def="dt-mode"
                     >modes</termref> come within the scope of this section, but there are
                  differences noted in <specref ref="modes-and-packages"/>.</p>
               <p>Not all <termref def="dt-declaration">declarations</termref> result in <termref
                     def="dt-component">components</termref>:</p>
               <ulist>
                  <item diff="chg" at="S-bug27340">
                     <p>Named <termref def="dt-declaration">declarations</termref> that can neither
                        be referenced from outside their containing package, nor can contain
                        references to components in other packages (examples are
                           <elcode>xsl:output</elcode>, <elcode>xsl:character-map</elcode>, and
                           <elcode>xsl:decimal-format</elcode>) are not considered to be components
                        and are therefore outside the scope of this section.</p>
                  </item>
                  <item>
                     <p>Some declarations, such as <elcode>xsl:decimal-format</elcode> and
                           <elcode>xsl:strip-space</elcode>, declare aspects of the processing
                        context which are not considered to be components as defined here.</p>
                  </item>
                  <item>
                     <p><termref def="dt-template-rule">Template rules</termref>
                           (<elcode>xsl:template</elcode> with a <code>match</code> attribute) are
                        also not considered to be components for the purposes of this section, which
                        is concerned only with components that are bound by name. However, when an
                           <elcode>xsl:template</elcode> has both a <code>match</code> attribute and
                        a <code>name</code> attribute, then it establishes both a template rule and
                        a <termref def="dt-named-template">named template</termref>, and in its role
                        as a named template it comes within the scope of this discussion.</p>
                  </item>
                  <item>
                     <p>A named declaration, for example a named template, a function, <phrase
                           diff="del" at="S-bug27648">an accumulator,</phrase>
                        <phrase diff="del" at="P-bug22747">an attribute set,</phrase> or a global
                        variable, may be overridden within the same package by another like-named
                        declaration having higher <termref def="dt-import-precedence">import
                           precedence</termref>. When a declaration is overridden in this way it
                        cannot be referenced <phrase diff="chg" at="S">by name</phrase> either from
                        within its containing package or from outside that package. <phrase
                           diff="del" at="T-bug29474">it can however be referenced from the
                           overriding declaration using the special name <code>xsl:original</code>,
                           as described in <specref ref="refer-to-overridden"/></phrase></p>
                  </item>
                  <item>
                     <p diff="add" at="P-bug22747">In the case of <elcode>xsl:attribute-set</elcode>
                        and <elcode>xsl:key</elcode> declarations, several declarations combine to
                        form a single component.</p>
                  </item>
               </ulist>
               <p>The section is largely concerned with details of the rules that affect references
                  from one component to another by name, whether the components are in the same
                  package or in different packages. The rules are designed to meet a number of
                  requirements:</p>
               <ulist>
                  <item>
                     <p>A component defined in one package can be overridden by a component in
                        another package, provided the signatures are type-compatible.</p>
                  </item>
                  <item>
                     <p>The author of a package can declare whether the components in the package
                        are public or private (that is, whether or not they can be used from outside
                        the package) and whether they are final, overridable, or abstract (that is
                        whether they can or must be overridden by the using package).</p>
                  </item>
                  <item>
                     <p>Within an application, two packages can make use of a common library and
                        override its components in different ways.</p>
                  </item>
                  <item>
                     <p>Visibility of components can be defined either as part of the declaration of
                        the component, or in the package manifest.</p>
                  </item>
                  <item>
                     <p>An application that wishes to make use of a <termref
                           def="dt-library-package">library package</termref> can be selective about
                        which components from the library it acquires, perhaps to avoid name clashes
                        between components acquired from different libraries.</p>
                  </item>
               </ulist>
               <p><termdef id="dt-component" term="component">The term <term>component</term> is
                     used to refer to any of the following: a <termref def="dt-stylesheet-function"
                        >stylesheet function</termref>, a <termref def="dt-named-template">named
                        template</termref>, a <termref def="dt-mode">mode</termref>, <phrase
                        diff="add" at="N">an <termref def="dt-accumulator-function"
                           >accumulator</termref>,</phrase> an <termref def="dt-attribute-set"
                        >attribute set</termref>, a <phrase diff="add" at="P-bug22877"><termref
                           def="dt-key">key</termref></phrase>, <termref def="dt-global-variable"
                        >global variable</termref>, or a <termref def="dt-mode"
                     >mode</termref>.</termdef></p>
               <p><termdef id="dt-symbolic-identifier" term="symbolic identifier">The <term>symbolic
                        identifier</term> of a <termref def="dt-component">component</termref> is a
                     composite name used to identify the component uniquely within a package. The
                     symbolic identifier comprises the kind of component (stylesheet function, named
                     template, <phrase diff="add" at="N">accumulator</phrase>, attribute set, global
                     variable, key, or mode), the <termref def="dt-expanded-qname">expanded
                        QName</termref> of the component (namespace URI plus local name), and in the
                     case of stylesheet functions, the <termref def="dt-arity"
                     >arity</termref>.</termdef></p>
               <note>
                  <p diff="add" at="S-bug28931">In the case of the <termref def="dt-unnamed-mode"/>,
                     the expanded QName of the component may be considered to be some
                     system-allocated name different from any user-defined mode name.</p>
               </note>
               <p><termdef id="dt-homonymous" term="homonymous">Two <termref def="dt-component"
                        >components</termref> are said to be <term>homonymous</term> if they have
                     the same <termref def="dt-symbolic-identifier">symbolic
                     identifier</termref>.</termdef></p>
               <p>Every <termref def="dt-component">component</termref> has a <termref
                     def="dt-declaration">declaration</termref> in some <termref
                     def="dt-stylesheet-module"/> and therefore within some <termref
                     def="dt-package">package</termref>. <phrase diff="add" at="P-bug22747">In the
                     case of <termref def="dt-attribute-set">attribute sets</termref> and <termref
                        def="dt-key">keys</termref>, there may be several declarations.</phrase> The
                  declaration is an element in an XDM tree representing the stylesheet module.
                  Declarations therefore have identity, based on XDM node identity.</p>
               <p><termdef id="dt-declaring-package" term="declaring package">The <term>declaring
                        package</term> of a <termref def="dt-component">component</termref> is the
                     package that contains the declaration <phrase diff="add" at="P-bug22747">(or,
                        in the case of <elcode>xsl:attribute-set</elcode> and
                           <elcode>xsl:key</elcode>, multiple declarations)</phrase> of the
                     component.</termdef></p>
               <p>When a <termref def="dt-component">component</termref> declared in one <termref
                     def="dt-package">package</termref> is made available in another, the using
                  package will contain a separate component that can be regarded as a modified copy
                  of the original. The new component shares the same <termref
                     def="dt-symbolic-identifier">symbolic identifier</termref> as the original, and
                  it has the same <termref def="dt-declaration">declaration</termref>, but it has
                  other properties such as its <termref def="dt-visibility">visibility</termref>
                  that may differ from the original.</p>
               <p diff="add" at="O"><termdef id="dt-containing-package" term="containing package">A
                     component declaration results in multiple components, one in the package in
                     which the declaration appears, and potentially one in each package that uses
                     the declaring package, directly or indirectly, subject to the visibility of the
                     component. Each of these multiple components has the same <termref
                        def="dt-declaring-package"/>, but each has a different <term>containing
                        package</term>. For the original component, the declaring package and the
                     containing package are the same; for a copy of a component made as a result of
                     an <elcode>xsl:use-package</elcode> declaration, the declaring package will be
                     the original package, and the containing package will be the package in which
                     the <elcode>xsl:use-package</elcode> declaration appears.</termdef></p>
               <note>
                  <p diff="add" at="S-bug28931">Within this specification, we generally use the
                     notation <var>C/P</var> for a component named C whose declaring package and
                     containing package are both <var>P</var>; and the notation <var>C/PQ</var> for
                     a component whose containing package is <var>P</var> and whose declaring
                     package is <var>Q</var> (that is, a component in <var>P</var> that is derived
                     from a component <var>C/Q</var> in the used package <var>Q</var>).</p>
               </note>
               <p>The properties of a <termref def="dt-component">component</termref> are as
                  follows:</p>
               <ulist>
                  <item>
                     <p>The original <termref def="dt-declaration">declaration</termref> of the
                        component.</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-package">package</termref> to which the component
                        belongs (called its <term>containing</term> package, not to be confused with
                        the <termref def="dt-declaring-package">declaring package</termref>).</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-symbolic-identifier">symbolic identifier</termref> of
                        the component.</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-visibility">visibility</termref> of the component,
                        which determines the way in which the component is seen by other components
                        within the same package and within using packages. This is one of
                           <code>public</code>, <code>private</code>, <code>abstract</code>,
                           <code>final</code>, or <code>hidden</code>. The visibility of components
                        is discussed further in <specref ref="visibility"/>.</p>
                  </item>
                  <item>
                     <p>A set of bindings for the <termref def="dt-symbolic-reference">symbolic
                           references</termref> in the component. The way in which these bindings
                        are established is discussed further in <specref ref="component-references"
                        />.</p>
                  </item>
               </ulist>
               <note>
                  <p>When a function <var>F</var> defined in a package <var>P</var> is acquired by
                     two using packages <var>Q</var> and <var>R</var>, we may think of <var>P</var>,
                        <var>Q</var>, and <var>R</var> as all providing access to the “same”
                     function. The detailed semantics, however, demand an understanding that there
                     is one function declaration, but three components. The three components
                     representing the function <var>F</var> within packages <var>P</var>,
                        <var>Q</var>, and <var>R</var> have some properties in common (the same
                     symbolic identifier, the same declaration), but other properties (the
                     visibility and the bindings of symbolic references) that may vary from one of
                     these components to another.</p>
               </note>
               <p><termdef id="dt-symbolic-reference" term="symbolic reference">The <termref
                        def="dt-declaration">declaration</termref> of a component includes
                     constructs that can be interpreted as references to other <termref
                        def="dt-component">components</termref> by means of their <termref
                        def="dt-symbolic-identifier">symbolic identifiers</termref>. These
                     constructs are generically referred to as <term>symbolic references</term>.
                     Examples of constructs that give rise to symbolic references are the
                        <code>name</code> attribute of <elcode>xsl:call-template</elcode>; the
                        <code>[xsl:]use-attribute-sets</code> attribute of
                     <elcode>xsl:copy</elcode>, <elcode>xsl:element</elcode>, and <termref
                        def="dt-literal-result-element">literal result elements</termref>; the
                        <phrase diff="add" at="S-bug28931">explicit or implicit</phrase>
                     <code>mode</code> attribute of <elcode>xsl:apply-templates</elcode>; XPath
                     variable references referring to global variables; XPath <phrase diff="chg"
                        at="S-bug27648">static function calls (including partial function
                        applications)</phrase> referring to <termref def="dt-stylesheet-function"
                        >stylesheet functions</termref>; <phrase diff="add" at="S-bug27648">and
                        named function references (example: <code>my:f#1</code>) referring to
                        stylesheet functions.</phrase>
                     <phrase diff="del" at="S-bug27648">or <termref def="dt-accumulator-function"
                           >accumulator functions</termref>.</phrase></termdef></p>
               <p>Symbolic references exist as properties of the <termref def="dt-declaration"
                     >declaration</termref> of a <termref def="dt-component">component</termref>.
                  The <termref def="dt-symbolic-identifier">symbolic identifier</termref> being
                  referred to can be determined straightforwardly from the syntactic form and
                  context of the reference: for example, the instruction <code>&lt;xsl:value-of
                     select="f:price($o)" xmlns:f="http://f.com/"/&gt;</code> contains a symbolic
                  reference to a function with expanded name <code>{http://f.com/}price</code> and
                  with arity=1. However, because there may be several (homonymous) function
                  components with this symbolic identifier, translating this symbolic reference into
                  a reference to a specific component (a process called “binding”) is less
                  straightforward, and is described in the text that follows. </p>
               <p>The process of assembling a stylesheet from its constituent packages is primarily
                  a process of binding these symbolic references to actual components. Within any
                     <termref def="dt-component">component</termref> whose <termref
                     def="dt-declaration">declaration</termref> is <var>D</var>, there is a set of
                  bindings; each binding is an association between a <termref
                     def="dt-symbolic-reference">symbolic reference</termref> in <var>D</var> and a
                     <termref def="dt-component">component</termref> whose <termref
                     def="dt-symbolic-identifier">symbolic identifier</termref> matches the outward
                  reference. Outward references for which a component <var>C</var> contains a
                  binding are said to be <term>bound</term> in <var>C</var>; those for which
                     <var>C</var> contains no binding are said to be <term>unbound</term>.</p>
               <p>For example, suppose that in some package <var>Q</var>, function <var>A</var>
                  calls <var>B</var>, which in turn calls <var>C</var>, and that <var>B</var> is
                     <code>private</code>. Now suppose that in some package <var>P</var> which uses
                     <var>Q</var>, <var>C</var> is overridden. The effect of the binding process is
                  that <var>P</var> will contain three components corresponding to <var>A</var>,
                     <var>B</var>, and <var>C</var>, which we might call <var>A/P</var>,
                     <var>B/P</var>, and <var>C/P</var>. The <termref def="dt-declaration"
                     >declarations</termref> of <var>A/P</var> and <var>B/P</var> are in package
                     <var>Q</var>, but the declaration of <var>C/P</var> is in <var>P</var>. The
                  internal visibility of <var>B/P</var> will be <code>hidden</code> (meaning that it
                  cannot be referenced from within <var>P</var>), and <var>B/P</var> will contain a
                  binding for the component <var>C/P</var> that corresponds to the outward reference
                  from <var>B</var> to <var>C</var>. The effect is that when <var>A</var> calls
                     <var>B</var> and <var>B</var> calls <var>C</var>, it is the overriding version
                  of <var>C</var> that is executed.</p>
               <p>In another package <var>R</var> that uses <var>Q</var> without overriding
                     <var>C</var>, there will be three different components <var>A/R</var>,
                     <var>B/R</var>, and <var>C/R</var>. This time the declaration of all three
                  components is in the original package <var>Q</var>. Component <var>B/R</var> will
                  contain a binding to <var>C/R</var>, so in this package, the original version of
                     <var>C</var> is executed. The fact that one package <var>P</var> overrides
                     <var>C</var> thus has no effect on <var>R</var>, which does not override
                  it.</p>
               <p>The binding process outlined above is described in more detail in <specref
                     ref="component-references"/>.</p>
               <p diff="add" at="P-bug22876">Template rules are not components in their own right;
                  unlike named templates, they are never referenced by name. Component references
                  within a template rule (for example, references to functions, global variables, or
                  named templates) are treated as occurring within the component that represents the
                  containing mode. This includes component references within the match patterns of
                  template rules. If a template rule lists several modes, it is treated as if there
                  were multiple template rules one in each mode.</p>
               <p diff="add" at="S-bug28931">An <elcode>xsl:apply-templates</elcode> instruction
                  with no <code>mode</code> attribute is treated as a reference to the default mode
                  defined for that <termref def="dt-instruction"/> (see <specref ref="default-mode"
                  />), which in turn defaults to the <termref def="dt-unnamed-mode"/>. An implicit
                  reference to the unnamed made is treated in the same way as any other <termref
                     def="dt-symbolic-reference"/>. Note that there is an unnamed mode in every
                  package, and the unnamed mode always has private visibility.</p>
               <p diff="add" at="S-bug28931">Where an <elcode>xsl:template</elcode> element has both
                  a <code>name</code> and a <code>match</code> attribute, it is treated as if there
                  were two separate <elcode>xsl:template</elcode> elements, one with a
                     <code>name</code> attribute and one with a <code>match</code> attribute. </p>
               <p diff="add" at="P-bug22877"><termref def="dt-key">Keys</termref>
                  <phrase diff="add" at="S-bug27648">and <termref def="dt-accumulator"
                        >accumulators</termref></phrase> behave rather differently from other
                  components. Their visibility is always private, which means they can only be used
                  within their declaring package. In addition, the component binding is generally
                  made dynamically rather than statically, <phrase diff="chg" at="S-bug27468">by
                     virtue of a string passed as an argument to the function
                        <function>key</function>, <function>accumulator-before</function>, or
                        <function>accumulator-after</function>. (In the case of accumulators, there
                     can also be static references: see the <code>use-accumulators</code> attribute
                     of <elcode>xsl:source-document</elcode>, </phrase>
                  <phrase diff="add" at="T-bug29803"><elcode>xsl:merge-source</elcode>, and
                        <elcode>xsl:mode</elcode></phrase>.) However, outward references from key
                  definitions <phrase diff="add" at="S-bug27648">and <termref def="dt-accumulator"
                        >accumulators</termref></phrase> to other components (such as global
                  variables and functions) behave in the same way as component references contained
                  in any other private component, in that they may be re-bound to an overriding
                  declaration of the target component.</p>
               <div4 id="visibility">
                  <head>Visibility of Components</head>
                  <p><termdef id="dt-visibility" term="visibility">The <term>visibility</term> of a
                           <termref def="dt-component">component</termref> is one of:
                           <code>private</code>, <code>public</code>, <code>abstract</code>,
                           <code>final</code>, or <code>hidden</code>.</termdef></p>
                  <p>The meanings of these visibility values is as follows:</p>
                  <glist>
                     <gitem>
                        <label>public</label>
                        <def>
                           <p>The component can be referenced from other components in this package
                              or in any using package; it can be overridden by a different component
                              in any using package.</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label>private</label>
                        <def>
                           <p>The component can be referenced from other components in this package;
                              it cannot be referenced or overridden within a using package.</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label>abstract</label>
                        <def>
                           <p>The component can be referenced from other components in this package
                              or in any using package; in a using package it can either remain
                              abstract or be overridden by a different component. <phrase diff="del"
                                 at="O">(In the top-level package of a stylesheet, it must be
                                 overridden by a non-abstract component.)</phrase></p>
                        </def>
                     </gitem>
                     <gitem>
                        <label>final</label>
                        <def>
                           <p>The component can be referenced from other components in this package
                              or in any using package; it cannot be overridden by a different
                              component in any using package.</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label>hidden</label>
                        <def>
                           <p>The component cannot be referenced from other components in this
                              package; it cannot be referenced or overridden within a using
                              package.</p>
                        </def>
                     </gitem>
                  </glist>
                  <note>
                     <p>The visibility of a component in a package <var>P</var> primarily affects
                        how the component can be used in other packages, specifically, packages that
                        use <var>P</var>. There is one exception: if the visibility is
                           <code>hidden</code>, it also affects how the component can be used within
                           <var>P</var>.</p>
                  </note>
                  <p diff="chg" at="R-bug26781">When a component is declared within a particular
                     package, its <termref def="dt-visibility">visibility</termref>, which affects
                     how it can be used in other (using) packages, depends on two factors: the value
                     of the <code>visibility</code> declaration on the declaration itself (if
                     present), and the rules given in the <elcode>xsl:expose</elcode> declarations
                     of the package manifest.</p>
                  <p>The <elcode>xsl:function</elcode>, <elcode>xsl:template</elcode>,
                        <elcode>xsl:attribute-set</elcode>, <elcode>xsl:variable</elcode>, <phrase
                        diff="del" at="S-bug27648"><elcode>xsl:accumulator</elcode></phrase>
                     <phrase diff="del" at="R-bug26740"><elcode>xsl:param</elcode>, </phrase> and
                        <elcode>xsl:mode</elcode>
                     <termref def="dt-declaration">declarations</termref> each have an optional
                        <code>visibility</code> attribute. The value is one of <code>private</code>,
                        <code>public</code>, <code>abstract</code>, or <code>final</code> (never
                        <code>hidden</code>). <phrase diff="add" at="T-bug29763">In the case of an
                           <elcode>xsl:param</elcode> element there is no explicit
                           <code>visibility</code> attribute; rather the declaration has the
                        implicit attribute <code>visibility="public"</code>.</phrase></p>
                  <p diff="chg" at="R-bug26781">Any <elcode>xsl:expose</elcode> declarations that
                     appear as children of <elcode>xsl:package</elcode> define the visibility of
                     components whose declaration has no explicit <code>visibility</code> attribute,
                     and can also be used to reduce the visibility of components where this
                     attribute is present.</p>
                  <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
                     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="expose">
                     <e:attribute name="component" required="yes">
                        <e:constant value="template"/>
                        <e:constant value="function"/>
                        <e:constant value="attribute-set"/>
                        <e:constant value="variable"/>
                        <e:constant value="mode"/>
                        <e:constant value="*"/>
                     </e:attribute>
                     <e:attribute name="names" required="yes">
                        <e:data-type name="tokens"/>
                     </e:attribute>
                     <e:attribute name="visibility" required="yes">
                        <e:constant value="public"/>
                        <e:constant value="private"/>
                        <e:constant value="final"/>
                        <e:constant value="abstract"/>
                        <!--<e:constant value="hidden"/>-->
                     </e:attribute>
                     <e:empty/>
                     <e:allowed-parents>
                        <e:parent name="package"/>
                     </e:allowed-parents>
                  </e:element-syntax>
                  <p>The <elcode>xsl:expose</elcode> element allows the <termref def="dt-visibility"
                     /> of selected components within a package to be defined.</p>
                  <p>The components in question are identified using their <termref
                        def="dt-symbolic-identifier">symbolic identifiers</termref>. The
                        <code>component</code> attribute defines the kind of component that is
                        selected<phrase diff="del" at="R-bug26740"> (<code>variable</code> embraces
                           <elcode>xsl:variable</elcode> and <elcode>xsl:param</elcode>)</phrase>.
                        <phrase diff="add" at="T-bug29478">The value <code>*</code> means “all
                        component kinds”; in this case the value of the <code>names</code> attribute
                        must be a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                           ref="prod-xpath30-Wildcard" xlink:type="simple"
                     >Wildcard</xnt>.</phrase></p>
                  <p diff="add" at="29889">An <elcode>xsl:expose</elcode> declaration has no effect
                     on the <termref def="dt-unnamed-mode"/>, which is always private to a
                     package.</p>
                  <p>The <code>names</code> attribute selects a subset of these components by name
                     (and in the case of functions, arity); its value is a whitespace-separated
                     sequence of tokens each of which is either a <xnt
                        xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                        ref="prod-xpath30-NameTest" xlink:type="simple">NameTest</xnt> or a <xnt
                        xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                        ref="prod-xpath30-NamedFunctionRef" xlink:type="simple"
                        >NamedFunctionRef</xnt>. (Examples are <code>*</code>, <code>p:*</code>,
                        <code>*:local</code>, <code>p:local</code>, and <code>p:local#2</code>.)</p>
                  <p>The value may be a <code>NamedFunctionRef</code> only in the case of stylesheet
                     functions, and distinguishes functions with the same name and different
                     arity.</p>
                  <p diff="chg" at="R-bug26781">The visibility of a <phrase diff="chg"
                        at="S-bug29088">named template, function, variable, attribute set, or
                        mode</phrase> declared within a package is the first of the following that
                     applies, subject to consistency constraints which are defined below:</p>
                  <olist diff="chg" at="R-bug26781">
                     <item>
                        <p diff="add" at="T-bug29763">The visibility of a variable declared using an
                              <elcode>xsl:param</elcode> element is always <code>public</code>. No
                              <elcode>xsl:expose</elcode> element ever matches an
                              <elcode>xsl:param</elcode> component.</p>
                        <note diff="add" at="T-bug29763">
                           <p>Attempting to match an <elcode>xsl:param</elcode> with an explicit
                                 <code>EQName</code> will therefore always give an error, while
                              using a wildcard has no effect.</p>
                        </note>
                     </item>
                     <item>
                        <p>If the package manifest contains an <elcode>xsl:expose</elcode> element
                           that matches this component by virtue of an explicit <code>EQName</code>
                           or <code>NamedFunctionRef</code> (that is, not by virtue of a wildcard
                           match), then the value of the <code>visibility</code> attribute of the
                           last such <elcode>xsl:expose</elcode> element in document order (call
                           this the <term>explicit exposed visibility</term>).</p>
                     </item>
                     <item>
                        <p>If the declaration of the component has a <code>visibility</code>
                           attribute, then the value of this attribute (call this the <term>declared
                              visibility</term>).</p>
                     </item>
                     <item>
                        <p>If the package manifest contains an <elcode>xsl:expose</elcode> element
                           that matches this component by virtue of a wildcard match that specifies
                           either the namespace part of the component name or the local part of the
                           name (for example, <code>prefix:*</code> or <code>*:local</code> or
                              <code>Q{uri}*</code>), then the value of the <code>visibility</code>
                           attribute of the last such <elcode>xsl:expose</elcode> element in
                           document order.</p>
                     </item>
                     <item>
                        <p>If the package manifest contains an <elcode>xsl:expose</elcode> element
                           that matches this component by virtue of a wildcard match that matches
                           all names (that is, <code>*</code>), then the value of the
                              <code>visibility</code> attribute of the last such
                              <elcode>xsl:expose</elcode> element in document order.</p>
                     </item>
                     <item>
                        <p>Otherwise, <code>private</code>.</p>
                     </item>
                  </olist>
                  <note>
                     <p diff="add" at="T-bug29478">In the above rules, no distinction is made
                        between declarations that specify a specific component kind, and those that
                        specify <code>component="*"</code>. If both match, the value of the
                           <code>component</code> attribute plays no role in deciding which
                        declaration wins.</p>
                  </note>
                  <p diff="chg" at="R-bug26781">If both a declared visibility and an explicit
                     exposed visibility exist for the same component, then as mentioned above, they
                     must be consistent. This is determined by reference to the following table,
                     where the entry N/P means “not permitted”. (In cases where the combination is
                     permitted, the actual visibility is always the same as the visibility
                     determined by <elcode>xsl:expose</elcode>.)</p>
                  <table class="data">
                     <caption>Relationship of Exposed Visibility to Potential Visibility</caption>
                     <thead>
                        <tr>
                           <th rowspan="2" colspan="1">Explicit exposed visibility</th>
                           <th colspan="4" rowspan="1">Declared visibility</th>
                        </tr>
                        <tr>
                           <th rowspan="1" colspan="1">public</th>
                           <th rowspan="1" colspan="1">private</th>
                           <th rowspan="1" colspan="1">final</th>
                           <th rowspan="1" colspan="1">abstract</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <th rowspan="1" colspan="1">public</th>
                           <td rowspan="1" colspan="1">public</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">N/P</td>
                        </tr>
                        <tr>
                           <th rowspan="1" colspan="1">private</th>
                           <td rowspan="1" colspan="1">private</td>
                           <td rowspan="1" colspan="1">private</td>
                           <td rowspan="1" colspan="1">private</td>
                           <td rowspan="1" colspan="1">N/P</td>
                        </tr>
                        <tr>
                           <th rowspan="1" colspan="1">final</th>
                           <td rowspan="1" colspan="1">final</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">final</td>
                           <td rowspan="1" colspan="1">N/P</td>
                        </tr>
                        <tr>
                           <th rowspan="1" colspan="1">abstract</th>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">abstract</td>
                        </tr>
                     </tbody>
                  </table>
                  <p>
                     <error spec="XT" type="static" class="SE" code="3010"><p>It is a <termref
                              def="dt-static-error">static error</termref> if the explicit exposed
                           visibility of a component is inconsistent with its declared visibility,
                           as defined in the above table. (This error occurs only when the component
                           declaration has an explicit <code>visibility</code> attribute, and the
                           component is also listed explicitly by name in an
                              <elcode>xsl:expose</elcode> declaration.)</p></error>
                  </p>
                  <p diff="chg" at="R-bug26679">
                     <error spec="XT" type="static" class="SE" code="3020"><p>It is a <termref
                              def="dt-static-error">static error</termref> if a token in the
                              <code>names</code> attribute of <elcode>xsl:expose</elcode>, other
                           than a wildcard, matches no component in the containing
                        package.</p></error>
                  </p>
                  <p diff="chg" at="T-bug29478">
                     <error spec="XT" type="static" class="SE" code="3022"><p>It is a <termref
                              def="dt-static-error">static error</termref> if the
                              <code>component</code> attribute of <elcode>xsl:expose</elcode>
                           specifies <code>*</code> (meaning all component kinds) and the
                              <code>names</code> attribute is not a wildcard.</p></error>
                  </p>
                  <note diff="add" at="R-editorial">
                     <p>There is no ambiguity, and no error, if several tokens within the same
                           <elcode>xsl:expose</elcode> element match the same component.</p>
                  </note>
                  <p diff="add" at="S-bug29088">If the visibility of a component as established by
                     the above rules is <code>abstract</code>, then the component must have a
                     declared visibility of <code>abstract</code>.</p>
                  <note>
                     <p>In other words, the <elcode>xsl:expose</elcode> declaration cannot be used
                        to make a component abstract unless it was declared as abstract to start
                        with.</p>
                  </note>
                  <p diff="add" at="S-bug29088">
                     <error spec="XT" type="static" class="SE" code="3025"><p>It is a <termref
                              def="dt-static-error">static error</termref> if the effect of an
                              <elcode>xsl:expose</elcode> declaration would be to make a component
                              <code>abstract</code>, unless the component is already
                              <code>abstract</code> in the absence of the
                              <elcode>xsl:expose</elcode> declaration. </p></error>
                  </p>
                  <p diff="chg" at="R-bug26781">For a component accepted into a package <var>P</var>
                     from another package <var>Q</var>, the <termref def="dt-visibility"
                        >visibility</termref> of the component in <var>P</var> (which primarily
                     affects how it can be used in a package <var>R</var> that uses <var>P</var>)
                     depends on the visibility declared in the relevant <elcode>xsl:accept</elcode>
                     or <elcode>xsl:override</elcode> element in <var>P</var> (see <specref
                        ref="accepting-components"/>); this in turn has a default that depends on
                     the visibility of the corresponding component in <var>Q</var>. In this case the
                     visibility is unaffected by any <elcode>xsl:expose</elcode> declaration in
                        <var>P</var>.</p>
               </div4>
               <div4 id="accepting-components">
                  <head>Accepting Components</head>
                  <p>When a package <var>P</var> uses a package <var>Q</var>, by virtue of an
                        <elcode>xsl:use-package</elcode> element in the <termref
                        def="dt-package-manifest">package manifest</termref> of <var>P</var>, then
                        <var>P</var> will contain a <termref def="dt-component">component</termref>
                     corresponding to every component in <var>Q</var>. The <termref
                        def="dt-visibility">visibility</termref> of the component within
                        <var>P</var> depends on the <termref def="dt-visibility"
                        >visibility</termref> of the component in <var>Q</var>, optionally modified
                     by two elements that may appear as children of the
                        <elcode>xsl:use-package</elcode> element, namely <elcode>xsl:accept</elcode>
                     and <elcode>xsl:override</elcode>.</p>
                  <p>For every component <var>C/Q</var> in package <var>Q</var> that is not matched
                     by any <elcode>xsl:override</elcode> or <elcode>xsl:accept</elcode> element in
                     the package manifest of <var>P</var>, there will be a corresponding component
                        <var>C/P</var> in package <var>P</var> that has the same <termref
                        def="dt-symbolic-identifier">symbolic identifier</termref> and <termref
                        def="dt-declaration">declaration</termref> as <var>C/Q</var>.</p>
                  <p diff="add" at="T-bug29763">If <var>C/Q</var> is an <elcode>xsl:param</elcode>
                     component, then the <termref def="dt-visibility"/> of <var>C/P</var> is
                        <code>public</code>.</p>
                  <p>In other cases, the <termref def="dt-visibility"/> of <var>C/P</var>
                     <phrase diff="chg" at="T-bug29574">depends on the <termref def="dt-visibility"
                        /> of <var>C/Q</var>, as defined by the following table:</phrase></p>
                  <table diff="add" at="T-bug29574" class="data">
                     <caption>Visibility of Components in Used and Using Packages</caption>
                     <thead>
                        <tr>
                           <th rowspan="1" colspan="1">Visibility in used package
                              <var>C/Q</var></th>
                           <th rowspan="1" colspan="1">Visibility in using package
                              <var>C/P</var></th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td rowspan="1" colspan="1">public</td>
                           <td rowspan="1" colspan="1">private</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">final</td>
                           <td rowspan="1" colspan="1">private</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">private</td>
                           <td rowspan="1" colspan="1">hidden</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">hidden</td>
                           <td rowspan="1" colspan="1">hidden</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">abstract</td>
                           <td rowspan="1" colspan="1">hidden</td>
                        </tr>
                     </tbody>
                  </table>
                  <note diff="add" at="T-bug29574">
                     <p>The effect of these rules is as follows:</p>
                     <ulist>
                        <item>
                           <p>Components that are public or final in the used package <var>Q</var>
                              become private in the using package <var>P</var>. This means that they
                              can be referenced within <var>P</var> but are not (by default) visible
                              within a package <var>R</var> that uses <var>P</var>.</p>
                        </item>
                        <item>
                           <p>Components that are private or hidden in the used package <var>Q</var>
                              become hidden in the using package <var>P</var>. This means that they
                              cannot be referenced within <var>P</var>; but if they contain
                              references to components that are overridden in <var>P</var>, the
                              hidden component’s references are bound to the overriding components
                              in <var>P</var>.</p>
                        </item>
                        <item>
                           <p>Components that are abstract in the used package <var>Q</var> become
                              hidden in the using package <var>P</var>. The hidden component in this
                              case raises a dynamic error if it is invoked. Such an invocation
                              cannot originate within <var>P</var>, because the component is not
                              visible within <var>P</var>; but it can occur if a public component in
                                 <var>Q</var> is invoked, which in turn invokes the abstract
                              component.</p>
                        </item>
                     </ulist>
                  </note>
                  <p diff="del" at="T-bug29574">A component <var>C/Q</var> in package <var>Q</var>
                     whose <termref def="dt-visibility">visibility</termref> is <code>hidden</code>
                     will never be matched by an <elcode>xsl:override</elcode> or
                        <elcode>xsl:accept</elcode> element in the package manifest of <var>P</var>,
                     and therefore <var>P</var> will contain a <code>hidden</code> component
                        <var>C/P</var> corresponding to <var>C/Q</var>.</p>
                  <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
                     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="accept">
                     <e:attribute name="component" required="yes">
                        <e:constant value="template"/>
                        <e:constant value="function"/>
                        <e:constant value="attribute-set"/>
                        <e:constant value="variable"/>
                        <e:constant value="mode"/>
                        <e:constant value="*"/>
                     </e:attribute>
                     <e:attribute name="names" required="yes">
                        <e:data-type name="tokens"/>
                     </e:attribute>
                     <e:attribute name="visibility" required="yes">
                        <e:constant value="public"/>
                        <e:constant value="private"/>
                        <e:constant value="final"/>
                        <e:constant value="abstract"/>
                        <e:constant value="hidden"/>
                     </e:attribute>
                     <e:empty/>
                     <e:allowed-parents>
                        <e:parent name="use-package"/>
                     </e:allowed-parents>
                  </e:element-syntax>
                  <p>The <elcode>xsl:accept</elcode> element has very similar syntax and semantics
                     to <elcode>xsl:expose</elcode>. Whereas <elcode>xsl:expose</elcode> allows a
                     package to restrict the visibility of its own components to other (using)
                     packages, <elcode>xsl:accept</elcode> allows a package to restrict the
                     visibility of components exposed by a package that it uses. This may be
                     necessary if, for example, it uses two different packages whose component names
                     conflict. It may also simply be good practice if the package author knows that
                     only a small subset of the functionality of a used package is required.</p>
                  <p>The rules for determining whether an <elcode>xsl:accept</elcode> element
                     matches a particular component, and for which element to use if there are
                     several matches, are the same as the rules for the <elcode>xsl:expose</elcode>
                     element.</p>
                  <p diff="add" at="T-bug29763">No <elcode>xsl:accept</elcode> element ever matches
                     a variable declared using <elcode>xsl:param</elcode>.</p>
                  <note diff="add" at="T-bug29763">
                     <p>Attempting to match an <elcode>xsl:param</elcode> with an explicit
                           <code>EQName</code> will therefore always give an error, while using a
                        wildcard has no effect.</p>
                  </note>
                  <p diff="chg" at="R-bug26679">
                     <error spec="XT" type="static" class="SE" code="3030"><p>It is a <termref
                              def="dt-static-error">static error</termref> if a token in the
                              <code>names</code> attribute of <elcode>xsl:accept</elcode>, other
                           than a wildcard, matches no component in the used package.</p></error>
                  </p>
                  <p diff="chg" at="T-bug29478">
                     <error spec="XT" type="static" class="SE" code="3032"><p>It is a <termref
                              def="dt-static-error">static error</termref> if the
                              <code>component</code> attribute of <elcode>xsl:accept</elcode>
                           specifies <code>*</code> (meaning all component kinds) and the
                              <code>names</code> attribute is not a wildcard.</p></error>
                  </p>
                  <p>In the absence of a matching <elcode>xsl:override</elcode> element (see
                        <specref ref="package-overriding-components"/>), the <termref
                        def="dt-visibility"/> of a component that matches an
                        <elcode>xsl:accept</elcode> element depends both on the
                        <code>visibility</code> attribute of the best-matching
                        <elcode>xsl:accept</elcode> element and on the <termref def="dt-visibility"
                        >visibility</termref> of the corresponding component in the used package,
                     according to the following table. In this table the entry “N/P” means “not
                     permitted”.</p>
                  <table class="data">
                     <caption>Relationship of the Visibility given in xsl:accept to Visibility in
                        the Used Package</caption>
                     <thead>
                        <tr>
                           <th rowspan="2" colspan="1">Visibility in <elcode>xsl:accept</elcode>
                              element</th>
                           <th colspan="4" rowspan="1">Visibility in used package</th>
                        </tr>
                        <tr>
                           <th rowspan="1" colspan="1">public</th>
                           <th rowspan="1" colspan="1">private</th>
                           <th rowspan="1" colspan="1">final</th>
                           <th rowspan="1" colspan="1">abstract</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <th rowspan="1" colspan="1">public</th>
                           <td rowspan="1" colspan="1">public</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">N/P</td>
                        </tr>
                        <tr>
                           <th rowspan="1" colspan="1">private</th>
                           <td rowspan="1" colspan="1">private</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">private</td>
                           <td rowspan="1" colspan="1">N/P</td>
                        </tr>
                        <tr>
                           <th rowspan="1" colspan="1">final</th>
                           <td rowspan="1" colspan="1">final</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">final</td>
                           <td rowspan="1" colspan="1">N/P</td>
                        </tr>
                        <tr>
                           <th rowspan="1" colspan="1">abstract</th>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">abstract</td>
                        </tr>
                        <tr>
                           <th rowspan="1" colspan="1">hidden</th>
                           <td rowspan="1" colspan="1">hidden</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">hidden</td>
                           <td rowspan="1" colspan="1"><phrase diff="chg" at="T-bug29574"
                                 >hidden</phrase></td>
                        </tr>
                     </tbody>
                  </table>
                  <p>
                     <error spec="XT" type="static" class="SE" code="3040"><p>It is a <termref
                              def="dt-static-error">static error</termref> if the visibility
                           assigned to a component by an <elcode>xsl:accept</elcode> element is
                           incompatible with the visibility of the corresponding component in the
                           used package, as defined by the above table, unless the token that
                           matches the component name is a wildcard, in which case the
                              <elcode>xsl:accept</elcode> element is treated as not matching that
                           component.</p></error>
                  </p>
                  <p>
                     <error spec="XT" type="static" class="SE" code="3050"><p>It is a <termref
                              def="dt-static-error">static error</termref> if the
                              <elcode>xsl:use-package</elcode> elements in a <termref
                              def="dt-package-manifest">package manifest</termref> cause two or more
                              <termref def="dt-homonymous">homonymous</termref> components to be
                           accepted with a visibility other than <code>hidden</code>.</p></error>
                  </p>
                  <p>Conflicts between the components accepted from used packages and those declared
                     within the package itself are handled as follows:</p>
                  <olist>
                     <item>
                        <p>If the conflict is between two components both declared within the
                           package itself, then it is resolved by the rules relating to <termref
                              def="dt-import-precedence">import precedence</termref> defined for
                           each kind of component.</p>
                     </item>
                     <item>
                        <p>If the conflict is between two components both accepted from used
                           packages, or between a component declared within the package and an
                           accepted component, then a static error occurs.</p>
                     </item>
                     <item diff="add" at="S-bug29094">
                        <p>If a component is explicitly accepted from a used package (by name,
                           rather than by a matching wildcard), and if the same component is the
                           subject of an <elcode>xsl:override</elcode> declaration, then a static
                           error occurs (see below). There is no conflict, however, if a component
                           declared within <elcode>xsl:override</elcode> also matches a wildcard in
                           an <elcode>xsl:accept</elcode> element.</p>
                        <p>
                           <error spec="XT" type="static" class="SE" code="3051"><p>It is a <termref
                                    def="dt-static-error">static error</termref> if a token in the
                                    <code>names</code> attribute of <elcode>xsl:accept</elcode>,
                                 other than a wildcard, matches the symbolic name of a component
                                 declared within an <elcode>xsl:override</elcode> child of the same
                                    <elcode>xsl:use-package</elcode> element.</p></error>
                        </p>
                     </item>
                  </olist>
                  <p diff="del" at="T-bug29574">The value <code>visibility="absent"</code> may be
                     used only in the case of a component that is present in the used package with
                     exposed visibility <code>abstract</code>. It is used to indicate that the using
                     package does not intend to provide an implementation of the abstract component,
                     and that any invocation of the abstract component is therefore to result in an
                     error. Specifically:</p>
                  <p diff="add" at="T-bug29574">Where the used package <var>Q</var> contains a
                     component whose visibility is <code>abstract</code>, the using package
                        <var>P</var> has three options:</p>
                  <olist diff="add" at="T-bug29574">
                     <item>
                        <p><var>P</var> can accept the component with
                              <code>visibility="abstract"</code>. In this case <var>P</var> can
                           contain references to the component, but invocation via these references
                           will fail unless a non-abstract overriding component has been supplied in
                           some package <var>R</var> that (directly or indirectly) uses
                           <var>P</var>.</p>
                     </item>
                     <item>
                        <p><var>P</var> can accept the component with
                              <code>visibility="hidden"</code>. In this case <var>P</var> cannot
                           contain references to the component, and invocation via references in
                              <var>Q</var> will always fail with a dynamic error. This is the
                           default if <var>P</var> does not explicitly accept or override the
                           component.</p>
                     </item>
                     <item>
                        <p><var>P</var> can provide a concrete implementation of the component
                           within an <elcode>xsl:override</elcode> element.</p>
                     </item>
                  </olist>
                  <p>Any invocation of the absent component (typically from within its declaring
                     package) causes a dynamic error, as if the component were overridden by a
                     component that unconditionally raises a dynamic error.</p>
                  <p>
                     <error spec="XT" type="dynamic" class="DE" code="3052"><p>It is a <termref
                              def="dt-dynamic-error">dynamic error</termref> if an invocation of an
                           abstract component is evaluated. </p></error>
                  </p>
                  <note diff="add" at="T-bug29574">
                     <p>This can occur when a public component in the used package invokes an
                        abstract component in the used package, and the using package provides no
                        concrete implementation for the component in an
                           <elcode>xsl:override</elcode> element.</p>
                  </note>
                  <note>
                     <p>To override a component accepted from a used package, the overriding
                        declaration must appear as a child of the <elcode>xsl:override</elcode>
                        element.</p>
                  </note>
                  <note>
                     <p>There is no rule that prevents a function (say) being declared in the using
                        package with the same name as a <code>private</code> function in the used
                        package. This does not create a conflict, since all references in the used
                        package are bound to one function and all those in the using package are
                        bound to another.</p>
                  </note>
               </div4>
               <div4 id="package-overriding-components">
                  <head>Overriding Components from a Used Package</head>
                  <p><termdef id="dt-override" term="override">A component in a using package may
                           <term>override</term> a component in a used package, provided that the
                           <termref def="dt-visibility">visibility</termref> of the component in the
                        used package is either <code>abstract</code> or <code>public</code>. The
                        overriding declaration is written as a child of the
                           <elcode>xsl:override</elcode> element, which in turn appears as a child
                        of <elcode>xsl:use-package</elcode>.</termdef></p>
                  <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
                     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="override">
                     <e:choice repeat="zero-or-more">
                        <e:element name="template"/>
                        <e:element name="function"/>
                        <e:element name="variable"/>
                        <e:element name="param"/>
                        <e:element name="attribute-set"/>
                        <!--<e:element name="mode"/>-->
                     </e:choice>
                     <e:allowed-parents>
                        <e:parent name="use-package"/>
                     </e:allowed-parents>
                  </e:element-syntax>
                  <note>
                     <p>This mechanism is distinct from the mechanism for overriding declarations
                        within the same package by relying on <termref def="dt-import-precedence"
                           >import precedence</termref>. It imposes stricter rules: the overriding
                        component is required to be type-compatible with the component that it
                        overrides.</p>
                  </note>
                  <p>If the used package <var>Q</var> contains a <termref def="dt-component"
                        >component</termref>
                     <var>C/Q</var> and the <elcode>xsl:use-package</elcode> element contains an
                        <elcode>xsl:override</elcode> element which contains a declaration
                        <var>D</var> whose <termref def="dt-symbolic-identifier">symbolic
                        identifier</termref> matches the symbolic identifier of <var>C/Q</var>, then
                     the using package <var>P</var> will contain a component <var>C/P</var> whose
                     declaration is D, whose symbolic identifier is that of D, and whose <termref
                        def="dt-visibility"/> is equal to the value of the <code>visibility</code>
                     attribute of <var>D</var>, or <code>private</code> if this is absent, <phrase
                        diff="chg" at="T-bug29473">except in the case of <elcode>xsl:param</elcode>,
                        which is implicitly <code>public</code></phrase>.</p>
                  <p>The using package <var>P</var> will also contain a component <var>C/PQ</var>
                     whose body is the same as the body of <var>C/Q</var> and whose <termref
                        def="dt-visibility">visibility</termref> is <code>hidden</code>. This
                     component is used as the target of a binding for the symbolic reference
                        <code>xsl:original</code> described below.</p>
                  <p>Other than its appearance as a child of <elcode>xsl:override</elcode>, the
                     overriding declaration is a normal <elcode>xsl:function</elcode>,
                        <elcode>xsl:template</elcode>, <phrase diff="del" at="S-bug27648"
                           ><elcode>xsl:accumulator</elcode></phrase>,
                     <elcode>xsl:variable</elcode>, <elcode>xsl:param</elcode>, or
                        <elcode>xsl:attribute-set</elcode><phrase diff="del" at="R-bug24308">, or
                           <elcode>xsl:mode</elcode></phrase> element. In the case of
                        <elcode>xsl:variable</elcode> and <elcode>xsl:param</elcode>, the variable
                     that is declared is a <termref def="dt-global-variable">global
                        variable</termref>.</p>
                  <p diff="add" at="R-bug24308">The rules in the remainder of this section apply to
                     components having a <code>name</code> attribute (<term>named
                     components</term>). The only element with no <code>name</code> attribute that
                     can appear as a child of <elcode>xsl:override</elcode> is an
                        <elcode>xsl:template</elcode> declaration having a <code>match</code>
                     attribute (that is, a <termref def="dt-template-rule"/>). The rules for
                     overriding of template rules appear in <specref ref="modes-and-packages"/>. If
                     an <elcode>xsl:template</elcode> element has both a <code>name</code> attribute
                     and a <code>match</code> attribute, then it defines both a named component and
                     a template rule, and both sections apply.</p>
                  <p>
                     <error spec="XT" type="static" class="SE" code="3055"><p>It is a <termref
                              def="dt-static-error">static error</termref> if a component
                           declaration appearing as a child of <elcode>xsl:override</elcode> is
                              <termref def="dt-homonymous">homonymous</termref> with any other
                           declaration in the using package, regardless of <termref
                              def="dt-import-precedence">import precedence</termref>, including any
                           other overriding declaration in the package manifest of the using
                           package.</p></error></p>
                  <note>
                     <p diff="add" at="P-bug22747">When an attribute set is overridden, the
                        overriding attribute set must be defined using a single
                           <elcode>xsl:attribute-set</elcode> element. Attribute sets defined in
                        different packages are never merged by virtue of having the same name,
                        though they may be merged explicitly by using the
                           <code>use-attribute-sets</code> attribute.</p>
                  </note>
                  <p>
                     <error spec="XT" type="static" class="SE" code="3058"><p>It is a <termref
                              def="dt-static-error">static error</termref> if a component
                           declaration appearing as a child of <elcode>xsl:override</elcode> does
                           not match (is not <termref def="dt-homonymous">homonymous</termref> with)
                           some component in the used package.</p></error></p>
                  <p>
                     <error spec="XT" type="static" class="SE" code="3060"><p>It is a <termref
                              def="dt-static-error">static error</termref> if the component
                           referenced by an <elcode>xsl:override</elcode> declaration has <termref
                              def="dt-visibility">visibility</termref> other than
                              <code>public</code> or <code>abstract</code></p></error>
                  </p>
                  <p>A package is executable if and only if it contains no <termref
                        def="dt-component">component</termref> whose <termref def="dt-visibility"
                        >visibility</termref> is <code>abstract</code>. A package that is not
                     executable is not a <termref def="dt-stylesheet">stylesheet</termref>, and
                     therefore cannot be nominated as the stylesheet to be used when initiating a
                     transformation.</p>
                  <note>
                     <p>In other words, if a component is declared as abstract, then some package
                        that uses the declaring package of that component directly or indirectly
                        must override that component with one that is not abstract. It is not
                        necessary for the override to happen in the immediately using package.</p>
                  </note>
                  <p>
                     <error spec="XT" type="static" class="SE" code="3070"><p>It is a <termref
                              def="dt-static-error">static error</termref> if the signature of an
                           overriding component is not <termref def="dt-compatible"
                              >compatible</termref> with the signature of the component that it is
                           overriding.</p></error>
                  </p>
                  <p><termdef id="dt-compatible" term="compatible">The signatures of two <termref
                           def="dt-component">components</termref> are <term>compatible</term> if
                        they present the same interface to the user of the component. The additional
                        rules depend on the kind of component.</termdef></p>
                  <p>Compatibility is only relevant when comparing two components that have the same
                        <termref def="dt-symbolic-identifier"/>. The compatibility rules for each
                     kind of component are as follows:</p>
                  <ulist>
                     <item>
                        <p diff="chg" at="P">Two attribute sets with the same name are compatible if
                           and only if they satisfy the following rule:</p>
                        <olist>
                           <item>
                              <p>If the overridden attribute set specifies
                                    <code>streamable="yes"</code> then the overriding attribute set
                                 also specifies <code>streamable="yes"</code>.</p>
                           </item>
                        </olist>
                     </item>
                     <item>
                        <p>Two functions with the same name and arity are compatible if and only if
                           they satisfy all the following rules:</p>
                        <olist>
                           <item>
                              <p>The <phrase diff="chg" at="T-bug29686">declared types of the
                                    arguments (defaulting to <code>item()*</code>)</phrase> are
                                 pairwise <termref def="dt-identical-types">identical</termref>.</p>
                           </item>
                           <item>
                              <p>The <phrase diff="chg" at="T-bug29686">declared return types
                                    (defaulting to <code>item()*</code>)</phrase> are <termref
                                    def="dt-identical-types">identical</termref>.</p>
                           </item>
                           <item>
                              <p diff="chg" at="P-bug22878">The effective value of the <phrase
                                    diff="chg" at="29060"><code>new-each-time</code></phrase>
                                 attribute on the overriding function is the same as its value on
                                 the overridden function.</p>
                           </item>
                           <item>
                              <p diff="chg" at="R-bug25679">If the overridden function specifies
                                    <code>streamable="yes"</code> then the overriding function also
                                 specifies <code>streamable="yes"</code>, and in addition, it has
                                 the same <termref def="dt-posture"/> and <termref def="dt-sweep"/>
                                 as the function that it overrides.</p>
                           </item>
                        </olist>
                     </item>
                     <item diff="del" at="S-bug27648">
                        <p>Two accumulators with the same name are compatible if and only if they
                           satisfy all the following rules:</p>
                        <olist>
                           <item>
                              <p>The types (defined in the <code>as</code> attribute) are <termref
                                    def="dt-identical-types">identical</termref>.</p>
                           </item>
                           <item>
                              <p diff="chg" at="P">If the overridden accumulator specifies
                                    <code>streamable="yes"</code> then the overriding accumulator
                                 also specifies <code>streamable="yes"</code>.</p>
                           </item>
                        </olist>
                     </item>
                     <item>
                        <p>Two named templates with the same name are compatible if and only if they
                           satisfy all the following rules:</p>
                        <olist>
                           <item>
                              <p>Their return types are <termref def="dt-identical-types"
                                    >identical</termref>.</p>
                           </item>
                           <item>
                              <p diff="chg" at="T-bug29982">For every non-tunnel parameter on the
                                 overridden template, there is a non-tunnel parameter on the
                                 overriding template that has the same name, an <termref
                                    def="dt-identical-types">identical</termref> required type, and
                                 the same effective value for the <code>required</code>
                                 attributes.</p>
                           </item>
                           <item>
                              <p diff="chg" at="T-bug29982">For every tunnel parameter <var>P</var>
                                 on the overridden template, if there is a parameter <var>Q</var> on
                                 the overriding template that has the same name as <var>P</var> then
                                    <var>Q</var> is also a tunnel parameter, and <var>P</var> and
                                    <var>Q</var> have <termref def="dt-identical-types"
                                    >identical</termref> required types.</p>
                           </item>
                           <item>
                              <p>Any parameter on the overriding template for which there is no
                                 corresponding parameter on the overridden template specifies
                                    <code>required="no"</code>.</p>
                           </item>
                           <item>
                              <p diff="add" at="P-bug22722">The two templates have equivalent
                                    <elcode>xsl:context-item</elcode> children, where equivalence
                                 means that the <code>use</code> attributes are the same and the
                                 required types are <termref def="dt-identical-types"
                                    >identical</termref>; an absent
                                    <elcode>xsl:context-item</elcode> is equivalent to one that
                                 specifies <code>use="optional"</code> and
                                 <code>as="item()"</code>.</p>
                           </item>
                        </olist>
                     </item>
                     <item diff="chg" at="O">
                        <p>Two variables (including parameters) with the same name are compatible if
                           and only if they satisfy all the following rules:</p>
                        <olist>
                           <item>
                              <p>Their declared types are <termref def="dt-identical-types"
                                    >identical</termref>.</p>
                           </item>
                           <item diff="del" at="S-bug29242">
                              <p>If the overridden variable is a parameter that specifies
                                    <code>required="yes"</code> then the overriding variable is
                                 either a non-parameter variable, or a parameter that specifies
                                    <code>required="yes"</code></p>
                           </item>
                        </olist>
                        <note>
                           <p>A variable may override a parameter or vice-versa, and the initial
                              value may differ.</p>
                           <p diff="chg" at="P">Because static variables and parameters are
                              constrained to have visibility <code>private</code>
                              <phrase diff="del" at="R-bug26740">or <code>final</code></phrase>,
                              they cannot be overridden in another package. The compatibility rules
                              therefore do not arise. The reason that such variables cannot be
                              overridden is that they are typically used during stylesheet
                              compilation (for example, in <code>[xsl:]use-when</code> expressions
                              and shadow attributes) and it is a design goal that packages should be
                              capable of independent compilation.</p>
                        </note>
                     </item>
                  </ulist>
                  <p><termdef id="dt-identical-types" term="identical (types)" diff="add" at="O"
                        >Types S and T are considered <term>identical</term> for the purpose of
                        these rules if and only if <code>subtype(S, T)</code> and <code>subtype(T,
                           S)</code> both hold, where the subtype relation is defined in <xspecref
                           spec="XP30" ref="id-seqtype-subtype"/>.</termdef></p>
                  <note diff="add" at="O">
                     <olist>
                        <item>
                           <p>One consequence of this rule is that two plain union types are
                              considered identical if they have the same set of member types, even
                              if the union types have different names or the ordering of the member
                              types is different.</p>
                           <p diff="add" at="T-bug29686">Consider a function that accepts an
                              argument whose declared type is a union type with member types
                                 <code>xs:double</code> and <code>xs:decimal</code>, in that order
                              (we might write this as <code>union(xs:double, xs:decimal)</code>).
                              Using the same notation, this can be overridden by a function that
                              declares the argument type as <code>union(xs:decimal,
                                 xs:double)</code>. This does not affect type checking: a function
                              call that passes the type checking rules with one signature will also
                              pass the type checking rules with the other. It does however affect
                              the way that the function conversion rules work: a call that passes
                              the <code>xs:untypedAtomic</code> value <code>"93.7"</code> (or an
                              untyped node with this as its string value) will be converted to an
                                 <code>xs:decimal</code> in one case and an <code>xs:double</code>
                              in the other.</p>
                        </item>
                        <item>
                           <p>While this rule may appear formal, it is not as straightforward as
                              might be supposed, because the subtype relation in XPath has a
                              dependency on the “Type derivation OK (Simple)” relation in XML
                              Schema, which itself appeals to a judgement as to whether the two type
                              definitions being compared “are the same type definition”. Both XSD
                              1.0 and XSD 1.1 add the note “The wording of [this rule] appeals to a
                              notion of component identity which is only incompletely defined by
                              this version of this specification.” However, they go on to say that
                              component identity is well defined if the components are named simple
                              type definitions, which will always apply in this case. For named
                              atomic types, the final result of these rules is that two atomic types
                              are identical if and only if they have the same name.</p>
                        </item>
                     </olist>
                  </note>
                  <p>Modes are not overridable, so the <elcode>xsl:mode</elcode> declaration cannot
                     appear as a child of <elcode>xsl:override</elcode>.</p>
               </div4>
               <div4 id="refer-to-overridden" diff="chg" at="S-bug28122">
                  <head>Referring to Overridden Components</head>
                  <p>Within the declaration of an overriding named <termref def="dt-component"/>
                     (that is, a component whose declaration is a child of
                        <elcode>xsl:override</elcode>, and has a <code>name</code> attribute), where
                     the overridden component has public <termref def="dt-visibility"/>, it is
                     possible to use the name <code>xsl:original</code> as a symbolic reference to
                     the overridden component. More specifically: </p>
                  <ulist>
                     <item>
                        <p>Within a <termref def="dt-named-template"/> appearing as a child of
                              <elcode>xsl:override</elcode>, the name <code>xsl:original</code> may
                           appear as the value of the <code>name</code> attribute of
                              <elcode>xsl:call-template</elcode>: for example,
                              <code>&lt;xsl:call-template name="xsl:original"/&gt;</code>. </p>
                     </item>
                     <item>
                        <p>Within a <termref def="dt-stylesheet-function"/> appearing as a child of
                              <elcode>xsl:override</elcode>, the static context for contained XPath
                           expressions (other than <termref def="dt-static-expression">static
                              expressions</termref>) is augmented as follows: the <term>statically
                              known function signatures</term> includes a mapping from the name
                              <code>xsl:original</code> to the signature of the overridden function
                           (which is the same as the signature of the overriding function). This
                           means that the name <code>xsl:original</code> can be used in static
                           function calls, including calls that use partial function application
                           (where one of the arguments is given as "?"), and also in named function
                           references. For example: <code>xsl:original($x)</code>,
                              <code>xsl:original($x, ?)</code>, <code>xsl:original#2</code>.</p>
                        <note>
                           <p>The result of calling <code>function-name(xsl:original#2)</code> is
                              the name of the overridden function, not
                              <code>xsl:original</code>.</p>
                        </note>
                        <p>Neither <code>xsl:original</code>, nor the overridden function, is added
                           to the <term>named functions</term> component of the dynamic context for
                           XPath expressions within the overriding function. This means that any
                           attempt to bind the function name <code>xsl:original</code> dynamically
                           (for example using <xfunction>function-lookup</xfunction>, or
                              <function>function-available</function>, or
                              <elcode>xsl:evaluate</elcode>) will fail, and any attempt to bind the
                           name of the overriding/overridden function dynamically will return the
                           overriding function. </p>
                     </item>
                     <item>
                        <p>Within a <termref def="dt-global-variable"/> or parameter appearing as a
                           child of <elcode>xsl:override</elcode>, the static context for contained
                           XPath expressions (other than <termref def="dt-static-expression">static
                              expressions</termref>) is augmented as follows: the <term>in-scope
                              variables</term> includes a mapping from the name
                              <code>xsl:original</code> to the declared type of the overridden
                           variable or parameter (which is the same as the type of the overriding
                           global variable or parameter). </p>
                     </item>
                     <item>
                        <p>Within an <termref def="dt-attribute-set"/> appearing as a child of
                              <elcode>xsl:override</elcode>, any
                              <code>[xsl:]use-attribute-sets</code> attribute (whether on the
                              <elcode>xsl:attribute-set</elcode> element itself, or on any
                           descendant element) may include the name <code>xsl:original</code> as a
                           reference to the overridden attribute set. </p>
                     </item>
                  </ulist>
                  <p>Within the overriding component <var>C/P</var>, the <termref
                        def="dt-symbolic-reference"/>
                     <code>xsl:original</code> is bound to the hidden component <var>C/PQ</var>
                     described earlier, whose body is that of the component <var>C/Q</var> in the
                     used package. </p>
                  <p>
                     <error spec="XT" type="static" class="SE" code="3075"><p>It is a <termref
                              def="dt-static-error">static error</termref> to use the component
                           reference <code>xsl:original</code> when the overridden component has
                              <code>visibility="abstract"</code>.</p></error>
                  </p>
                  <p diff="add" at="S-bug28931">Modes are not overridable, so the name
                        <code>xsl:original</code> cannot be used to refer to a <termref
                        def="dt-mode"/> (for example in the <code>mode</code> attribute of
                        <elcode>xsl:apply-templates</elcode>). </p>
                  <note>
                     <p>In the case of variables, templates, and attribute sets, the invocation of
                        the overridden component can occur only within the lexical scope of the
                        overriding component. With functions, however, there is greater flexibility.
                        The overriding component can obtain a reference to the overridden component
                        in the form of a function item, and can export this value by passing it to
                        other functions or returning it in its result. A dynamic invocation of this
                        function item (and hence, of the overridden function) can thus occur
                        anywhere. </p>
                  </note>
               </div4>
               <div4 id="component-references" diff="chg" at="S-bug28931">
                  <head>Binding References to Components</head>
                  <p><termdef id="dt-reference-binding" term="reference binding">The process of
                        identifying the <termref def="dt-component">component</termref> to which a
                           <termref def="dt-symbolic-reference">symbolic reference</termref> applies
                        (possibly chosen from several <termref def="dt-homonymous"
                           >homonymous</termref> alternatives) is called <term>reference
                           binding</term>.</termdef>
                  </p>
                  <p>The process of <termref def="dt-reference-binding"/> in the presence of
                     overriding declarations is best illustrated by an example. The formal rules
                     follow later in the section.</p>
                  <example id="example-of-component-binding">
                     <head>Binding References to Named Components</head>
                     <p>Consider a package <var>Q</var> defined as follows:</p>
                     <eg role="xslt-document" xml:space="preserve">&lt;xsl:package name="Q"
        version="3.0"                
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:variable name="A" visibility="final" select="$B + 1"/&gt;
  &lt;xsl:variable name="B" visibility="private" select="$C * 2"/&gt;
  &lt;xsl:variable name="C" visibility="public" select="22"/&gt;
&lt;/xsl:package&gt;</eg>
                     <p>(The process is illustrated here using variables as the components, but the
                        logic would be the same if the example used functions, named templates, or
                        attribute sets.)</p>
                     <p>There are three components in this package, and their properties are
                        illustrated in the following table. (The ID column is an arbitrary component
                        identifier used only for the purposes of this exposition.)</p>
                     <table class="data">
                        <caption>Components in the above Package and their Properties</caption>
                        <thead>
                           <tr>
                              <th rowspan="1" colspan="1">ID</th>
                              <th rowspan="1" colspan="1">Symbolic Name</th>
                              <th rowspan="1" colspan="1">Declaring Package</th>
                              <th rowspan="1" colspan="1">Containing Package</th>
                              <th rowspan="1" colspan="1">Visibility</th>
                              <th rowspan="1" colspan="1">Body</th>
                              <th rowspan="1" colspan="1">Bindings</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr>
                              <td rowspan="1" colspan="1"><var>A/Q</var></td>
                              <td rowspan="1" colspan="1">variable <var>A</var></td>
                              <td rowspan="1" colspan="1">Q</td>
                              <td rowspan="1" colspan="1">Q</td>
                              <td rowspan="1" colspan="1">final</td>
                              <td rowspan="1" colspan="1"><code>$B + 1</code></td>
                              <td rowspan="1" colspan="1">$B → <var>B/Q</var></td>
                           </tr>
                           <tr>
                              <td rowspan="1" colspan="1"><var>B/Q</var></td>
                              <td rowspan="1" colspan="1">variable <var>B</var></td>
                              <td rowspan="1" colspan="1">Q</td>
                              <td rowspan="1" colspan="1">Q</td>
                              <td rowspan="1" colspan="1">private</td>
                              <td rowspan="1" colspan="1"><code>$C * 2</code></td>
                              <td rowspan="1" colspan="1">$C → <var>C/Q</var></td>
                           </tr>
                           <tr>
                              <td rowspan="1" colspan="1"><var>C/Q</var></td>
                              <td rowspan="1" colspan="1">variable <var>C</var></td>
                              <td rowspan="1" colspan="1">Q</td>
                              <td rowspan="1" colspan="1">Q</td>
                              <td rowspan="1" colspan="1">public</td>
                              <td rowspan="1" colspan="1"><code>22</code></td>
                              <td rowspan="1" colspan="1">none</td>
                           </tr>
                        </tbody>
                     </table>
                     <p>Now consider a package <var>P</var> that uses <var>Q</var>, and that
                        overrides one of the variables declared in <var>Q</var>:</p>
                     <eg role="xslt-document" xml:space="preserve">&lt;xsl:package name="P"
        version="3.0"                
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:use-package name="Q"&gt;
    &lt;xsl:override&gt;
      &lt;xsl:variable name="C" visibility="private" select="$xsl:original + 3"/&gt;
    &lt;/xsl:override&gt;
  &lt;/xsl:use-package&gt;
  
  &lt;xsl:template name="T" visibility="public"&gt;
    &lt;xsl:value-of select="$A"/&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:package&gt;</eg>
                     <p>Package <var>P</var> has five components, whose properties are shown in the
                        following table:</p>
                     <table class="data">
                        <caption>Components in the above Package and their Properties</caption>
                        <thead>
                           <tr>
                              <th rowspan="1" colspan="1">ID</th>
                              <th rowspan="1" colspan="1">Symbolic Name</th>
                              <th rowspan="1" colspan="1">Declaring Package</th>
                              <th rowspan="1" colspan="1">Containing Package</th>
                              <th rowspan="1" colspan="1">Visibility</th>
                              <th rowspan="1" colspan="1">Body</th>
                              <th rowspan="1" colspan="1">Bindings</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr>
                              <td rowspan="1" colspan="1"><var>A/PQ</var></td>
                              <td rowspan="1" colspan="1">variable <var>A</var></td>
                              <td rowspan="1" colspan="1">Q</td>
                              <td rowspan="1" colspan="1">P</td>
                              <td rowspan="1" colspan="1">final</td>
                              <td rowspan="1" colspan="1"><code>$B + 1</code></td>
                              <td rowspan="1" colspan="1">$B → <var>B/PQ</var></td>
                           </tr>
                           <tr>
                              <td rowspan="1" colspan="1"><var>B/PQ</var></td>
                              <td rowspan="1" colspan="1">variable <var>B</var></td>
                              <td rowspan="1" colspan="1">Q</td>
                              <td rowspan="1" colspan="1">P</td>
                              <td rowspan="1" colspan="1">hidden</td>
                              <td rowspan="1" colspan="1"><code>$C * 2</code></td>
                              <td rowspan="1" colspan="1">$C → <var>C/P</var></td>
                           </tr>
                           <tr>
                              <td rowspan="1" colspan="1"><var>C/PQ</var></td>
                              <td rowspan="1" colspan="1">variable <var>C</var></td>
                              <td rowspan="1" colspan="1">Q</td>
                              <td rowspan="1" colspan="1">P</td>
                              <td rowspan="1" colspan="1">hidden</td>
                              <td rowspan="1" colspan="1"><code>22</code></td>
                              <td rowspan="1" colspan="1">none</td>
                           </tr>
                           <tr>
                              <td rowspan="1" colspan="1"><var>C/P</var></td>
                              <td rowspan="1" colspan="1">variable <var>C</var></td>
                              <td rowspan="1" colspan="1">P</td>
                              <td rowspan="1" colspan="1">P</td>
                              <td rowspan="1" colspan="1"><phrase diff="chg" at="T-bug29468"
                                    >private</phrase></td>
                              <td rowspan="1" colspan="1"><code>$xsl:original + 3</code></td>
                              <td rowspan="1" colspan="1">$xsl:original → <var>C/PQ</var></td>
                           </tr>
                           <tr>
                              <td rowspan="1" colspan="1"><var>T/P</var></td>
                              <td rowspan="1" colspan="1">template <var>T</var></td>
                              <td rowspan="1" colspan="1">P</td>
                              <td rowspan="1" colspan="1">P</td>
                              <td rowspan="1" colspan="1">public</td>
                              <td rowspan="1" colspan="1"><code>value-of select="$A</code></td>
                              <td rowspan="1" colspan="1">$A → <var>A/PQ</var></td>
                           </tr>
                        </tbody>
                     </table>
                     <p>The effect of these bindings is that when template <var>T</var> is called,
                        the result is <code>51</code>. This is why:</p>
                     <olist>
                        <item>
                           <p>The result of <var>T</var> is the value of <var>A/PQ</var>.</p>
                        </item>
                        <item>
                           <p>The value of <var>A/PQ</var> is the value of <var>B/PQ</var> plus
                              1.</p>
                        </item>
                        <item>
                           <p>The value of <var>B/PQ</var> is the value of <var>C/P</var> times
                              2.</p>
                        </item>
                        <item>
                           <p>The value of <var>C/P</var> is the value of <var>C/PQ</var> plus
                              3.</p>
                        </item>
                        <item>
                           <p>The value of <var>C/PQ</var> is 22.</p>
                        </item>
                        <item>
                           <p>So the final result is ((22 + 3) * 2) + 1</p>
                        </item>
                     </olist>
                     <p>In this example, the components of <var>P</var> are established in three
                        different ways:</p>
                     <olist>
                        <item>
                           <p>Components <var>A/PQ</var>, <var>B/PQ</var>, and <var>C/PQ</var> are
                              modified copies of the corresponding component <var>A/Q</var>,
                                 <var>B/Q</var>, and <var>C/Q</var> in the used package
                              <var>Q</var>. The properties of these components are modified as
                              follows:</p>
                           <olist>
                              <item>
                                 <p>The <termref def="dt-symbolic-identifier"/>, <termref
                                       def="dt-declaring-package"/>, and body are unchanged.</p>
                              </item>
                              <item>
                                 <p>The <termref def="dt-containing-package"/> is changed to
                                       <var>P</var>.</p>
                              </item>
                              <item>
                                 <p>The <termref def="dt-visibility"/> is changed according to the
                                    rules in <specref ref="accepting-components"/>: in particular,
                                       <code>visibility="private"</code> changes to
                                       <code>visibility="hidden"</code>.</p>
                              </item>
                              <item>
                                 <p>The references to other components are rebound as described in
                                    this section.</p>
                              </item>
                           </olist>
                        </item>
                        <item>
                           <p>Component <var>C/P</var> is the overriding component. Its properties
                              are exactly as if it were declared as a top-level component in
                                 <var>P</var> (outside the <elcode>xsl:use-package</elcode>
                              element), except that (a) it must adhere to the constraints on
                              overriding components (see <specref
                                 ref="package-overriding-components"/>), (b) it is allowed to use
                              the variable reference <code>$xsl:original</code>, and (c) the fact
                              that it overrides <var>C/Q</var> affects the way that references from
                              other components are rebound.</p>
                        </item>
                        <item>
                           <p>Component <var>T/P</var> is a new component declared locally in
                                 <var>P</var>.</p>
                        </item>
                     </olist>
                  </example>
                  <p>The general rules for <termref def="dt-reference-binding"/> can now be
                     stated:</p>
                  <olist>
                     <item>
                        <p>If the <termref def="dt-containing-package"/> of a component
                              <var>C/P</var> is <var>P</var>, then all <termref
                              def="dt-symbolic-reference">symbolic references</termref> in
                              <var>C/P</var> are bound to components whose <termref
                              def="dt-containing-package"/> is <var>P</var>.</p>
                     </item>
                     <item>
                        <p>When a package <var>P</var> uses a package <var>Q</var>, then for every
                           component <var>C/Q</var> in <var>Q</var>, there is a <term>corresponding
                              component</term>
                           <var>C/P</var> in <var>P</var>, as described in <specref
                              ref="accepting-components"/>.</p>
                     </item>
                     <item>
                        <p>Given a component <var>C/P</var> whose <termref
                              def="dt-containing-package"/> and <termref def="dt-declaring-package"
                           /> are the same package <var>P</var>, then (as a consequence of rules
                           elsewhere in this specification) for every <termref
                              def="dt-symbolic-reference"/>
                           <var>D</var> within <var>C/P</var>, other than a reference using the name
                              <code>xsl:original</code>, there will always be exactly one non-hidden
                           component <var>D/P</var> whose containing package is <var>P</var> and
                           whose <termref def="dt-symbolic-identifier"/> matches <var>D</var>
                           (otherwise a static error will have been reported). The reference is then
                           bound to <var>D/P</var>.</p>
                     </item>
                     <item>
                        <p>In the case of a component reference using the name
                              <code>xsl:original</code>, this will in general appear within a
                           component <var>C/P</var> that overrides a component <var>C/Q</var> whose
                           corresponding component in <var>P</var> is <var>C/PQ</var>, and the
                              <code>xsl:original</code> reference is bound to <var>C/PQ</var>.</p>
                     </item>
                     <item>
                        <p>Given a component <var>C/P</var> whose <termref
                              def="dt-containing-package"/>
                           <var>P</var> is a different package from its <termref
                              def="dt-declaring-package"/>
                           <var>R</var> (that is, <var>C/P</var> is present in <var>P</var> by
                           virtue of an <elcode>xsl:use-package</elcode> declaration referencing
                           package <var>Q</var>, which may or may not be the same as <var>R</var>),
                           then the component bindings in <var>C/P</var> are derived from the
                           component bindings in the corresponding component <var>C/Q</var> as
                           follows: if the component binding within <var>C/Q</var> is to a component
                              <var>D/Q</var>, then:</p>
                        <olist>
                           <item>
                              <p>If <var>D/Q</var> is overridden within <var>P</var> by a component
                                    <var>D/P</var>, then the reference is bound to
                                 <var>D/P</var>;</p>
                           </item>
                           <item>
                              <p>Otherwise, the reference is bound to the component <var>D/PQ</var>
                                 in <var>P</var> whose corresponding component in <var>Q</var> is
                                    <var>D/Q</var>.</p>
                           </item>
                        </olist>
                     </item>
                  </olist>
                  <p>When reference resolution is performed on a package that is intended to be used
                     as a <termref def="dt-stylesheet">stylesheet</termref> (that is, for the
                        <termref def="dt-top-level-package">top-level package</termref>), there must
                     be no symbolic references referring to components whose visibility is
                        <code>abstract</code> (that is, an implementation must be provided for every
                     abstract component). </p>
                  <p>
                     <error spec="XT" type="static" class="SE" code="3080"><p>It is a <termref
                              def="dt-static-error">static error</termref> if a <termref
                              def="dt-top-level-package">top-level package</termref> (as distinct
                           from a <termref def="dt-library-package">library package</termref>)
                           contains <phrase diff="del" at="T-bug29256">symbolic references referring
                              to</phrase> components whose visibility is
                        <code>abstract</code>.</p></error>
                  </p>
                  <note>
                     <p>This means that abstract components must either be overridden in a using
                        package by a component that supplies a real implementation, or they must be
                        accepted with <code diff="chg" at="T-bug29574">visibility="hidden"</code>
                        (see <specref ref="accepting-components"/>), which has the effect that any
                        invocation of the component raises a <termref def="dt-dynamic-error"/>.</p>
                  </note>
                  <note>
                     <p>Unresolved references are allowed at the module level but not at the package
                        level. A stylesheet module can contain references to components that are
                        satisfied only when the module is imported into another module that declares
                        the missing component.</p>
                  </note>
                  <note>
                     <p>The process of resolving references (or linking) is critical to an
                        implementation that uses separate compilation. One of the aims of these
                        rules is to ensure that when compiling a package, it is always possible to
                        determine the signature of called functions, templates, and other
                        components. A further aim is to establish unambiguously in what
                        circumstances components can be overridden, so that compilers know when it
                        is possible to perform optimizations such as inlining of function and
                        variable references.</p>
                     <p>Suppose a public template <var>T</var> calls a private function
                        <var>F</var>. When the package containing these two components is referenced
                        by a using package, the template remains public, while the function becomes
                        hidden. Because the function becomes hidden, it can no longer conflict with
                        any other function of the same name, or be overridden by any other function;
                        at this stage the compiler knows exactly which function <var>T</var> will be
                        calling, and can perform optimizations based on this knowledge.</p>
                  </note>
                  <p diff="add" at="P">The mechanism for resolving component references described in
                     this section is consistent with the mechanism used for binding function and
                     variable references described in the XPath specification. XPath requires these
                     variable and function names to be present in the static context for an XPath
                     expression. XSLT ensures that all the non-hidden functions, global variables,
                     and global parameters in a package are present in the static context for every
                     XPath expression that appears in that package, along with required information
                     such as the type of a variable and the signature of a function.</p>
                  <example diff="add" at="T">
                     <head>Named Component References in Inline Functions</head>
                     <p>Named component references within inline functions follow the standard
                        rules, but the rules need to be interpreted with care. Suppose that in
                        package <var>P</var> we find the declarations:</p>
                     <eg role="xslt-declarations" xml:space="preserve">
&lt;xsl:variable name="v" as="xs:integer" visibility="public" select="3"/&gt;

&lt;xsl:function name="f:factory" as="function(*)" visibility="final"&gt;
  &lt;xsl:sequence select="function() {$v}"/&gt;
&lt;/xsl:function&gt;  
                  </eg>
                     <p>and that in a using package Q we find:</p>
                     <eg role="xslt-declarations" xml:space="preserve">
      
&lt;xsl:use-package name="P"&gt;
  &lt;xsl:override&gt;
    &lt;xsl:variable name="v" as="xs:integer" select="4"/&gt;
  &lt;/xsl:override&gt;
&lt;/xsl:use-package&gt;

&lt;xsl:template name="xsl:initial-template"&gt;
  &lt;v value="{f:factory()()}"/&gt;
&lt;/xsl:template&gt;  
      </eg>
                     <p>The correct output here is <code>&lt;v value="4"/&gt;</code>.</p>
                     <p>The explanation for this is as follows. Package <var>Q</var> contains a
                        function <var>f:factory/QP</var> whose declaring package is <var>P</var> and
                        whose containing package is <var>Q</var>. The symbolic reference
                           <code>$v</code> within the body of this function is resolved in the
                        normal way; since the containing package is <var>Q</var>, it is resolved to
                        the global variable <var>v/Q</var>: that is, the overriding declaration of
                           <code>$v</code> that appears within the <elcode>xsl:override</elcode>
                        element within package <var>Q</var>, whose value is 4.</p>
                     <p>In terms of internal implementation, one way of looking at this is that the
                        anonymous function returned by <code>f:factory</code> contains within its
                        closure bindings for the global variables and functions that the anonymous
                        function references; these bindings are inherited from the component
                        bindings of the component that lexically contains these symbolic references,
                        which in this case is <code>f:factory</code>, and more specifically the
                        version of the <code>f:factory</code> component in package <var>Q</var>.</p>
                  </example>
               </div4>
               <div4 id="dynamic-component-references" diff="add" at="S-bug27648">
                  <head>Dynamic References to Components</head>
                  <p>There are several functions in which a dynamically-evaluated QName is used to
                     identify a component: these include <function>key</function>,
                        <function>accumulator-before</function>,
                        <function>accumulator-after</function>,
                        <xfunction>function-lookup</xfunction>, and
                        <function>function-available</function>. Dynamic references can also occur
                     in the XPath expression supplied to the <elcode>xsl:evaluate</elcode>
                     instruction. </p>
                  <p>In all these cases, the set of components that are available to be referenced
                     are those that are declared in the package where this function call appears,
                     including components declared within an <elcode>xsl:override</elcode>
                     declaration in that package, but excluding components declared with
                        <code>visibility="abstract"</code>. If the relevant component has been
                     overridden in a different package, the overriding declarations are not
                     considered. </p>
                  <p>If one of these functions (for example <function>key</function> or
                        <function>accumulator-before</function>) is invoked via a dynamic function
                     invocation, then the relevant package is the one in which the function item is
                     created (using a construct such as <code>key#2</code>, <code>key('my-key',
                        ?)</code>, or <code>function-lookup($KEYFN, 2)</code>). Function items
                     referring to context-dependent functions bind the context at the point where
                     the function item is created, not the context at the point where the function
                     item is invoked.</p>
                  <note>
                     <p>This means that if a package wishes to make a key available for use by a
                        calling package, it can do so by creating a public global variable whose
                        value is a partial application of the <function>key</function> function:</p>
                     <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:variable name="get-order" select="key('orders-key', ?, ?)"/&gt;</eg>
                     <p>which the calling code can invoke as <code>$get-order('123-456',
                        /)</code>.</p>
                  </note>
               </div4>
            </div3>
            <div3 id="modes-and-packages">
               <head>Overriding Template Rules from a Used Package</head>
               <p>The rules in the previous section apply to named components including functions,
                  named templates, global variables, and named attribute sets. The rules for
                     <termref def="dt-mode">modes</termref>, and the <termref def="dt-template-rule"
                     >template rules</termref> appearing within a mode, are slightly different.</p>
               <p>The unnamed mode is local to a package: in effect, each package has its own
                  private unnamed mode, and the unnamed mode of one package does not interact with
                  the unnamed mode of any other package. <phrase diff="add" at="S-bug28931">An
                        <elcode>xsl:apply-templates</elcode> instruction with no <code>mode</code>
                     attribute is treated as a <termref def="dt-symbolic-reference"/> to the default
                     mode defined for that instruction (see <specref ref="default-mode"/>), which in
                     turn defaults to the <termref def="dt-unnamed-mode"/>. Because the unnamed mode
                     always has private visibility, it cannot be overridden in another
                     package.</phrase></p>
               <p>A named mode may be declared in an <elcode>xsl:mode</elcode> declaration as being
                  either <code>public</code>, <code>private</code>, or <code>final</code>. The
                  values of the <code>visibility</code> attribute are interpreted as follows:</p>
               <table class="def">
                  <caption>Visibility Values for Named Modes, and their Meaning</caption>
                  <thead>
                     <tr>
                        <th rowspan="1" colspan="1">Value</th>
                        <th rowspan="1" colspan="1">Meaning</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td rowspan="1" colspan="1">public</td>
                        <td rowspan="1" colspan="1">A <term>using</term> package may use
                              <elcode>xsl:apply-templates</elcode> to invoke templates in this mode;
                           it may also declare additional template rules in this mode, which are
                           selected in preference to template rules in the used package. These may
                           appear only as children of the <elcode>xsl:override</elcode> element
                           within the <elcode>xsl:use-package</elcode> element.</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">private</td>
                        <td rowspan="1" colspan="1">A <term>using</term> package may neither
                           reference the mode nor provide additional templates in this mode; the
                           name of the mode is not even visible in the using package, so no such
                           attempt is possible. The using package can use the same name for its own
                           modes without risk of conflict. </td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">final</td>
                        <td rowspan="1" colspan="1">A <term>using</term> package may use
                              <elcode>xsl:apply-templates</elcode> to invoke templates in this mode,
                           but it must not provide additional template rules in this mode. </td>
                     </tr>
                  </tbody>
               </table>
               <p>As with other named components, an <elcode>xsl:use-package</elcode> declaration
                  may contain an <elcode>xsl:accept</elcode> element to control the visibility of a
                  mode acquired from the <term>used</term> package. The allowed values of its
                     <code>visibility</code> attribute are <code>public</code>,
                  <code>private</code>, and <code>final</code><phrase diff="del" at="R-bug24308">,
                     and <code>hidden</code></phrase>.</p>
               <p>The <elcode>xsl:mode</elcode> declaration itself must not be overridden. A using
                  package must not contain an <elcode>xsl:mode</elcode> declaration whose name
                  matches that of a <code>public</code> or <code>final</code>
                  <elcode>xsl:mode</elcode> component accepted from a used package.</p>
               <p>The <elcode>xsl:expose</elcode> and <elcode>xsl:accept</elcode> elements may be
                  used to reduce the visibility of a mode in a using package; the same rules apply
                  in general, though some of the rules are not applicable because, for example,
                  modes cannot be <code>abstract</code>.</p>
               <p>It is not possible for a package to combine the template rules from two other
                  packages into a single mode. When <elcode>xsl:apply-templates</elcode> is used
                  without specifying a mode, the chosen template rules will always come from the
                  same package; when it is used with a named mode, then they will come from the
                  package where the mode is defined, or any package that uses that package and adds
                  template rules to the mode. If two template rules defined in different packages
                  match the same node, then the rule in the using package wins over any rule in the
                  used package; this decision is made before taking other factors such as import
                  precedence and priority into account.</p>
               <p>A static error occurs if two modes with the same name are visible within a
                  package, either because they are both declared within the package, or because one
                  is declared within the package and the other is acquired from a used package, or
                  because both are accepted from different used packages.</p>
               <p>The rules for matching template rules by <termref def="dt-import-precedence"/> and
                     <termref def="dt-priority"/> operate as normal, with the addition that template
                  rules declared within an <elcode>xsl:use-package</elcode> element have higher
                  precedence than any template rule declared in the used package. <phrase diff="add"
                     at="S-bug28931">More specifically, given an
                        <elcode>xsl:apply-templates</elcode> instruction in package <var>P</var>,
                     naming a mode <var>M</var> that is declared in a used package <var>Q</var> and
                     is overridden in <var>P</var>, the search order for template rules
                  is:</phrase></p>
               <olist diff="add" at="S-bug28931">
                  <item>
                     <p>Rules declared within <var>P</var> (specifically,
                           <elcode>xsl:template</elcode> rules declared as children of an
                           <elcode>xsl:override</elcode> element within the
                           <elcode>xsl:use-package</elcode> element that references package
                           <var>Q</var>). If there are multiple rules declared within <var>P</var>
                        that match a selected node,<phrase diff="add" at="S-bug29210"> they are
                           resolved on the basis of their explicit or implicit <termref
                              def="dt-priority"/>, and if the priorities are equal,</phrase> the
                        last one in <termref def="dt-declaration-order"/> wins.</p>
                  </item>
                  <item>
                     <p>Rules declared within <var>Q</var>, taking <termref
                           def="dt-import-precedence"/>, <termref def="dt-priority"/>, and <termref
                           def="dt-declaration-order"/> into account in the usual way (see <specref
                           ref="conflict"/>).</p>
                  </item>
                  <item>
                     <p>Built-in template rules (see <specref ref="built-in-rule"/>) selected
                        according to the <code>on-no-match</code> attribute of the
                           <elcode>xsl:mode</elcode> declaration (in <var>Q</var>), or its
                        default.</p>
                  </item>
               </olist>
               <p diff="add" at="S-bug28931">If the mode is overridden again in a package
                     <var>R</var> that uses <var>P</var>, then this search order is extended by
                  adding <var>R</var> at the start of the search list, and so on recursively.</p>
               <note>
                  <p>If existing XSLT code has been written to use template rules in the unnamed
                     mode, a convenient way to incorporate this code into a <termref
                        def="dt-library-package">library package</termref> is to add a stub module
                     that defines a new named <code>public</code> or <code>final</code> mode, in
                     which there is a single template rule whose content is the single instruction
                        <phrase diff="chg" at="V-bug30091"><code>&lt;xsl:apply-templates
                           select="."/&gt;</code></phrase>. This in effect redirects
                        <elcode>xsl:apply-templates</elcode> instructions using the named mode to
                     the rules defined in the unnamed mode.</p>
               </note>
               <div4 id="requiring-explicit-modes" diff="add" at="R-bug26438">
                  <head>Requiring Explicit Mode Declarations</head>
                  <p>In previous versions of XSLT, modes were implicitly declared by simply using a
                     mode name in the <code>mode</code> attribute of <elcode>xsl:template</elcode>
                     or <elcode>xsl:apply-templates</elcode>. XSLT 3.0 introduces the ability to
                     declare a mode explicitly using an <elcode>xsl:mode</elcode> declaration (see
                        <specref ref="declaring-modes"/>).</p>
                  <p>By default, within a package that is defined using an explicit
                        <elcode>xsl:package</elcode> element, all modes must be explicitly declared.
                     In an implicit package, however (that is, one rooted at an
                        <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element),
                     modes can be implicitly declared as in previous XSLT versions.</p>
                  <p>The <phrase diff="chg" at="S-bug28232"><code>declared-modes</code></phrase>
                     attribute of <elcode>xsl:package</elcode> determines whether or not modes that
                     are referenced within the package must be explicitly declared. If the value is
                        <code>yes</code> (the default), <phrase diff="chg" at="S-bug29122">then it
                        is an error to use a mode name unless the package either contains an
                        explicit <elcode>xsl:mode</elcode> declaration for that mode, or accepts the
                        mode from a used package. If the value is <code>no</code>, then this is not
                        an error.</phrase>
                  </p>
                  <p>This attribute affects all modules making up the package, it is not confined to
                     declarations appearing as children of the <elcode>xsl:package</elcode>
                     element.</p>
                  <p diff="chg" at="S-bug29122">
                     <error spec="XT" type="static" class="SE" code="3085"><p>It is a <termref
                              def="dt-static-error">static error</termref>, when the effective value
                           of the <code>declared-modes</code> attribute of an
                              <elcode>xsl:package</elcode> element is <code>yes</code>, if the
                           package contains an explicit reference to an undeclared mode, or if it
                           implicitly uses the unnamed mode and the unnamed mode is
                        undeclared.</p></error></p>
                  <p diff="chg" at="T-bug29699">For the purposes of the above rule:</p>
                  <olist>
                     <item>
                        <p>A mode is <term>declared</term> if either of the following conditions is
                           true:</p>
                        <olist>
                           <item>
                              <p>The package contains an <elcode>xsl:mode</elcode> declaration for
                                 that mode.</p>
                           </item>
                           <item>
                              <p>The mode is a public or final mode accepted from a used package.
                              </p>
                           </item>
                        </olist>
                     </item>
                     <item>
                        <p>The offending reference may be either an explicit mode name, or the token
                              <code>#unnamed</code> treated as a reference to the unnamed mode, or a
                           defaulted mode attribute, and it may occur in any of the following:</p>
                        <olist>
                           <item>
                              <p>The <code>mode</code> attribute of an <elcode>xsl:template</elcode>
                                 declaration</p>
                           </item>
                           <item>
                              <p>The <code>mode</code> attribute of an
                                    <elcode>xsl:apply-templates</elcode> instruction</p>
                           </item>
                           <item>
                              <p>An <code>[xsl:]default-mode</code> attribute.</p>
                           </item>
                        </olist>
                     </item>
                     <item>
                        <p>A package <term>implicitly uses the unnamed mode</term> if either of the
                           following conditions is true:</p>
                        <olist diff="chg" at="T-bug29699">
                           <item>
                              <p>There is an <elcode>xsl:apply-templates</elcode> element with no
                                    <code>mode</code> attribute, and with no ancestor-or-self having
                                 an <code>[xsl:]default-mode</code> attribute.</p>
                           </item>
                           <item>
                              <p>There is an <elcode>xsl:template</elcode> element with a
                                    <code>match</code> attribute and no <code>mode</code> attribute,
                                 and with no ancestor-or-self having an
                                    <code>[xsl:]default-mode</code> attribute.</p>
                           </item>
                        </olist>
                     </item>
                  </olist>
               </div4>
            </div3>
            <div3 id="package-local-declarations">
               <head>Declarations Local to a Package</head>
               <p diff="add" at="R-bug24309">The <elcode>xsl:import</elcode> and
                     <elcode>xsl:include</elcode> declarations are local to a package.</p>
               <p>Declarations of <termref def="dt-key">keys</termref>, <phrase diff="add"
                     at="S-bug27648"><termref def="dt-accumulator">accumulators</termref>, </phrase>
                  <termref def="dt-decimal-format">decimal formats</termref>, namespace aliases (see
                     <specref ref="namespace-aliasing"/>), <termref def="dt-output-definition"
                     >output definitions</termref>, and <termref def="dt-character-map">character
                     maps</termref> within a package have local scope within that package — they are
                  all effectively private. The elements that declare these constructs do not have a
                     <code>visibility</code> attribute. The unnamed decimal format and the unnamed
                  output format are also local to a package.</p>
               <p>If <elcode>xsl:strip-space</elcode> or <elcode>xsl:preserve-space</elcode>
                  declarations appear within a <termref def="dt-library-package">library
                     package</termref>, they only affect calls to the <xfunction>doc</xfunction> or
                     <function>document</function> functions appearing within that package. <phrase
                     diff="chg" at="R-bug25611">Such a declaration within the <termref
                        def="dt-top-level-package"/> additionally affects stripping of whitespace in
                     the document that contains the <termref def="dt-global-context-item"
                  /></phrase>.</p>
               <p>An <elcode>xsl:decimal-format</elcode> declaration within a package applies only
                  to calls on <xfunction>format-number</xfunction> appearing within that
                  package.</p>
               <p>An <elcode>xsl:namespace-alias</elcode> declaration within a package applies only
                  to literal result elements within the same package.</p>
               <p>An <elcode>xsl:import-schema</elcode> declaration within a package adds the names
                  of the imported schema components to the static context for that package only;
                  these names are effectively private, in the sense that they do not become
                  available for use in any other packages. However, the names of schema components
                  must be consistent across the stylesheet as a whole: it is not possible for two
                  different packages within a stylesheet to use a type-name such as
                     <code>part-number</code> to refer to different schema-defined simple or complex
                  types.</p>
               <p>Type names used in the interface of public components in a package (for example,
                  in the arguments of a function) must be respected by callers of those components,
                  in the sense that the caller must supply values of the correct type. Often this
                  will mean that the using component, if it contains calls on such interfaces, must
                  itself import the necessary schema components. However, the requirement for an
                  explicit schema import applies only where the package contains explicit use of the
                  names of schema components required to call such interfaces.</p>
               <note>
                  <p>For example, suppose a <termref def="dt-library-package">library
                        package</termref> contains a function which requires an argument of type
                        <code>mfg:part-number</code>. The caller of this function must supply an
                     argument of the correct type, but does not need to import the schema unless it
                     explicitly uses the schema type name <code>mfg:part-number</code>. If it
                     obtains an instance of this type from outside the package, for example as the
                     result of another function call, then it can supply this instance to the
                     acquired function even though it has not imported a schema that defines this
                     type.</p>
               </note>
               <p>At execution time, the schema available for validating instance documents contains
                  (at least) the union of the schema components imported into all constituent
                  packages of the stylesheet.</p>
            </div3>
            <div3 id="declaring-global-context-item" diff="add" at="R-bug24764">
               <head diff="chg" at="P">Declaring the Global Context Item</head>
               <p>The <elcode>xsl:global-context-item</elcode> element is used to declare whether a
                     <termref def="dt-global-context-item"/> is required, and if so, what its
                     <termref def="dt-required-type"/> is.</p>
               <p diff="chg" at="S-bug28129">The element is a <termref def="dt-declaration"/> that
                  can appear at most once in any stylesheet module; and if more than one
                     <elcode>xsl:global-context-item</elcode> declaration appears within a <termref
                     def="dt-package"/>, then the declarations must be consistent. Specifically, all
                  the attributes <rfc2119>must</rfc2119> have semantically-equivalent values.</p>
               <note diff="chg" at="S-bug28129">
                  <p>This means that omitting an attribute is equivalent to specifying its default
                     value explicitly; and purely lexical variations, <phrase diff="chg"
                        at="T-bug29696">such as the presence of whitespace in an attribute
                        value</phrase>, are not considered significant.</p>
               </note>
               <p>
                  <error spec="XT" type="static" class="SE" code="3087"><p>It is a <termref
                           def="dt-static-error">static error</termref> if more than one
                           <elcode>xsl:global-context-item</elcode> declaration appears within a
                           <termref def="dt-stylesheet-module"/>, or if several modules within a
                        single <termref def="dt-package"/> contain inconsistent
                           <elcode>xsl:global-context-item</elcode> declarations</p></error></p>
               <p>If there is no <elcode>xsl:global-context-item</elcode> declaration for a package,
                  this is equivalent to specifying the empty element
                     <code>&lt;xsl:global-context-item/&gt;</code>, which imposes no
                  constraints.</p>
               <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
                  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="global-context-item">
                  <e:in-category name="declaration"/>
                  <e:attribute name="as">
                     <e:data-type name="item-type"/>
                  </e:attribute>
                  <e:attribute name="use">
                     <e:constant value="required"/>
                     <e:constant value="optional"/>
                     <e:constant value="absent"/>
                  </e:attribute>
                  <e:empty/>
                  <e:allowed-parents>
                     <e:parent name="package"/>
                     <e:parent name="stylesheet"/>
                     <e:parent name="transform"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p>The <code>use</code> attribute takes the value <code>required</code>,
                     <code>optional</code>, or <code diff="chg" at="S-bug27015">absent</code>. The
                  default is <code>optional</code>.</p>
               <ulist>
                  <item>
                     <p>If the value <code>required</code> is specified, then there must be a global
                        context item. </p>
                  </item>
                  <item>
                     <p>If the value <code>optional</code> is specified, or if the attribute is
                        omitted, or if the <elcode>xsl:global-context-item</elcode> element is
                        omitted, then there may or may not be a global context item.</p>
                  </item>
                  <item diff="chg" at="S-bug27015">
                     <p>If the value <code>absent</code> is specified, then the global focus
                        (context item, position, and size) will be <termref def="dt-absent"/></p>
                     <note>
                        <p>This specification does not define whether supplying a global context
                           item in this situation results in an error or warning, or whether the
                           supplied context item is simply ignored.</p>
                     </note>
                  </item>
               </ulist>
               <p>If the <code>as</code> attribute is present then its value must be an <xnt
                     xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                     ref="prod-xpath30-ItemType" xlink:type="simple">ItemType</xnt>. If the
                  attribute is omitted this is equivalent to specifying
                  <code>as="item()"</code>.</p>
               <p>The <code>as</code> attribute defines the required type of the global context
                  item. The default value is <code>as="item()"</code>. If a global context item is
                  supplied then it must conform to the required type, after conversion (if
                  necessary) using the <termref def="dt-function-conversion-rules"/>.</p>
               <p diff="add" at="S-bug27014"><error spec="XT" type="static" class="SE" code="3089"
                        ><p>It is a <termref def="dt-static-error"/> if the <code>as</code>
                        attribute is present <error.extra>on the
                              <elcode>xsl:global-context-item</elcode> element</error.extra> when
                           <code>use="absent"</code> is specified.</p></error></p>
               <p diff="del" at="T-bug29696">If the <code>streamable</code> attribute is present
                  with the value <code>yes</code>, then the <code>select</code> expression or
                  contained sequence constructor of every global <elcode>xsl:variable</elcode> and
                     <elcode>xsl:param</elcode> declaration in the containing package<phrase
                     diff="add" at="t-bug29499">, unless it is overridden by another declaration of
                     higher <termref def="dt-import-precedence"/></phrase>, <rfc2119>must</rfc2119>
                  be <termref def="dt-grounded"/> and <termref def="dt-motionless"/>, when assessed
                  with a <termref def="dt-context-posture"/> of <termref def="dt-striding"/>, and a
                     <termref def="dt-context-item-type"/> based on the declared type of the global
                  context item. The consequences of violating this rule depend on the conformance
                  level of the processor, as described in <specref ref="streamability-guarantees"
                  />.</p>
               <p diff="del" at="T-bug29696">
                  <error spec="XT" type="dynamic" class="DE" code="3205"><p>It is a <termref
                           def="dt-dynamic-error"/> if, when a stylesheet is primed (see <specref
                           ref="initiating"/>), the supplied <termref def="dt-global-context-item"/>
                        is a node in a <termref def="dt-streamed-document"/>, unless the <termref
                           def="dt-top-level-package"/> has a
                           <elcode>xsl:global-context-item</elcode> declaration that specifies
                           <code>streamable=yes</code>.</p></error>
               </p>
               <p diff="del" at="T-bug29696">The <code>use-accumulators</code> attribute defines
                  which <termref def="dt-accumulator">accumulators</termref> are available with the
                  document containing the global context item. Details are given in <specref
                     ref="applicability-of-accumulators"/>.</p>
               <p>The global context item is available only within the <termref
                     def="dt-top-level-package"/>. If a valid
                     <elcode>xsl:global-context-item</elcode> declaration appears within a <termref
                     def="dt-library-package"/>, then it is ignored, unless it specifies
                     <code>use="required"</code>, in which case an error is signaled: <errorref
                     spec="XT" class="TE" code="0590"/>.</p>
               <note diff="chg" at="T-bug29696">
                  <p>In earlier releases of this specification, the <termref
                        def="dt-global-context-item"/> and the <termref
                        def="dt-initial-match-selection"/> were essentially the same thing, often
                     referred to as the <emph>principal source document</emph>. In XSLT 3.0, they
                     have been separated: the global context item is a single item accessible to the
                     initializers of global variables as the value of the expression <code>.</code>
                     (dot), while the initial match selection is a sequence of nodes or other items
                     supplied to an initial implicit <elcode>xsl:apply-templates</elcode>
                     invocation.</p>
                  <p>APIs that were originally designed for use with earlier versions of XSLT are
                     likely to bundle the two concepts together.</p>
                  <p>With a streamable processor, the <termref def="dt-initial-match-selection"/>
                     can consist of streamed nodes, but the <termref def="dt-global-context-item"/>
                     is always <termref def="dt-grounded"/>, because it is available to all global
                     variables and there is no control over the sequence of processing.</p>
                  <p diff="del" at="T-bug29696">Use of a global context item is not encouraged,
                     especially in a complex stylesheet made up of several packages. There is only
                     one global context item shared between all packages, which does not work well
                     when multiple packages are developed independently. Named <termref
                        def="dt-stylesheet-parameter">stylesheet parameters</termref>, perhaps in
                     distinct namespaces, are more flexible.</p>
               </note>
               <p diff="chg" at="R-bug26467">A <termref def="dt-type-error"/> is signaled if there
                  is a <termref def="dt-package"/> with an <elcode>xsl:global-context-item</elcode>
                  declaration specifying a required type that does not match the supplied <termref
                     def="dt-global-context-item"/>. The error code is the same as for
                     <elcode>xsl:param</elcode>: <errorref spec="XT" class="TE" code="0590"/>.</p>
               <note>
                  <p>If the <code>ItemType</code> is one that can only be satisfied by a
                     schema-validated input document, for example
                        <code>as="schema-element(invoice)"</code>, the <termref def="dt-processor"
                        >processor</termref> may interpret this as a request to apply schema
                     validation to the input. Similarly, if the <code>KindTest</code> indicates that
                     an element node is required, the processor may interpret this as a request to
                     supply the document element rather than the document node of a supplied input
                     document.</p>
               </note>
            </div3>
            <div3 id="packages-csv-library-example" diff="add" at="S+">
               <head>Worked Example of a Library Package</head>
               <p>The example in this section illustrates the use of overrides to customize or
                  extend a (fictional) library package named
                     <code>http://example.com/csv-parser</code>, which provides a parsing function
                  for data formatted as lines containing comma-separated values. For simplicity of
                  exposition, the example shows a simple, naive implementation; a realistic CSV
                  parser would be more complicated and make the example harder to follow.</p>
               <div4 id="csv-example-default-functionality">
                  <head>Default Functionality of the CSV Package</head>
                  <p>The basic functionality of the package is provided by the function
                        <code>csv:parse</code>, which expects a string parameter named
                        <code>input</code>. By default, the function parses the input into lines,
                     and breaks lines on commas, returning as result an element named
                        <code>csv</code> containing one <code>row</code> element per line, each
                        <code>row</code> containing a sequence of <code>field</code> elements.</p>
                  <p>A simple stylesheet which uses this library and applies it to a string might
                     look like the following. The initial template applies <code>csv:parse</code> to
                     a suitable string and returns a copy of the result:</p>
                  <eg role="xslt-document" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"
   xmlns:csv="http://example.com/csv"
   exclude-result-prefixes="xs csv"
   version="3.0"&gt;

   &lt;xsl:output indent="yes" /&gt;

   &lt;xsl:use-package name="http://example.com/csv-parser" 
                    package-version="*" /&gt;

   &lt;!-- example input "file"  --&gt;
   &lt;xsl:variable name="input" as="xs:string"&gt;
       name,id,postal code
       "Abel Braaksma",34291,1210 KA
       "Anders Berglund",473892,9843 ZD
   &lt;/xsl:variable&gt;

   &lt;!-- entry point --&gt;
   &lt;xsl:template name="xsl:initial-template"&gt;
       &lt;xsl:copy-of select="csv:parse($input)" /&gt;
   &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</eg>
                  <p>The result returned by this stylesheet would be:</p>
                  <eg role="xml" xml:space="preserve">&lt;csv&gt;
  &lt;row&gt;
    &lt;field quoted="no"&gt;name&lt;/field&gt;
    &lt;field quoted="no"&gt;id&lt;/field&gt;
    &lt;field quoted="no"&gt;postal code&lt;/field&gt;
  &lt;/row&gt;
  &lt;row&gt;
    &lt;field quoted="yes"&gt;Abel Braaksma&lt;/field&gt;
    &lt;field quoted="no"&gt;34291&lt;/field&gt;
    &lt;field quoted="no"&gt;1210 KA&lt;/field&gt;
  &lt;/row&gt;
  &lt;row&gt;
    &lt;field quoted="yes"&gt;Anders Berglund&lt;/field&gt;
    &lt;field quoted="no"&gt;473892&lt;/field&gt;
    &lt;field quoted="no"&gt;9843 ZD&lt;/field&gt;
  &lt;/row&gt;
&lt;/csv&gt;
</eg>
                  <p>Variations on this default behavior are achieved by overriding selected
                     declarations in the package, as described below.</p>
               </div4>
               <div4 id="csv-example-package-structure">
                  <head>Package Structure</head>
                  <p>The package module itself is version 1.0.0 of a package called
                        <code>http://example.com/csv-parser</code>; it has the following
                     structure:</p>
                  <eg role="xslt-document" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:package
   name="http://example.com/csv-parser"
   package-version="1.0.0"
   xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"
   xmlns:csv="http://example.com/csv"
   exclude-result-prefixes="xs csv"
   declared-modes="yes"
   version="3.0"&gt;

   &lt;!--* Mode declarations ... *--&gt;
   &lt;!--* Variable declarations ... *--&gt;
   &lt;!--* Attribute-set declaration ... *--&gt;
   &lt;!--* Function declarations ... *--&gt;
   &lt;!--* Templates ... *--&gt;

&lt;/xsl:package&gt;</eg>
                  <p>The contents of the package (represented here by comments) are described more
                     fully below.</p>
               </div4>
               <div4 id="csv-example-customizing-parse">
                  <head>The <code>csv:parse</code> Function and its User-customization Hooks</head>
                  <p>The <code>csv:parse</code> function is final and cannot be overridden. As can
                     be seen from the code below, it (1) parses its <code>input</code> parameter
                     into lines, (2) calls function <code>csv:preprocess-line</code> on each line,
                     then (3) applies the templates of mode <code>csv:parse-line</code> to the
                     pre-processed value. The result is then (4) processed again by mode
                        <code>csv:post-process</code>.</p>
                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:function name="csv:parse" visibility="final"&gt;
    &lt;xsl:param name="input" as="xs:string" /&gt;   
    &lt;xsl:variable name="result" as="element()"&gt;
        &lt;csv&gt;
            &lt;xsl:apply-templates 
                select="(tokenize($input, $csv:line-separator) 
                        ! csv:preprocess-line(.))" 
                mode="csv:parse-line" /&gt;
        &lt;/csv&gt;
    &lt;/xsl:variable&gt;
    &lt;xsl:apply-templates select="$result" 
                         mode="csv:post-process" /&gt;
&lt;/xsl:function&gt;
</eg>
                  <p>The default code for this processing is given below. Each part of the
                     processing except the first (the tokenization into lines) can be overridden by
                     the user of the package.</p>
               </div4>
               <div4 id="csv-example-line-breaking">
                  <head>Breaking the Input into Lines</head>
                  <p>The first user-customization hook is given by the global variable
                        <code>csv:line-separator</code>, which specifies the line separator used to
                     break the input string into lines. It can be overridden by the user if need be.
                     The default declaration attempts to handle the line-separator sequences used by
                     most common operating systems in text files:</p>
                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:variable name="csv:line-separator" 
              as="xs:string" 
              select="'\r\n?|\n\r?'" 
              visibility="public"/&gt;
</eg>
               </div4>
               <div4 id="csv-example-preprocessing-lines">
                  <head>Pre-processing the Lines</head>
                  <p>The function <code>csv:preprocess-line</code> calls
                        <code>normalize-space()</code> on its argument:</p>
                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:function name="csv:preprocess-line" 
                 as="xs:string?" 
                 visibility="public"&gt;
    &lt;xsl:param name="line" as="xs:string" /&gt;
    &lt;xsl:sequence select="normalize-space($line)" /&gt;
&lt;/xsl:function&gt;
</eg>
                  <p>Because the function is declared <code>public</code>, it can be overridden by a
                     user. (This might be necessary, for example, if whitespace within quoted
                     strings needs to be preserved.)</p>
               </div4>
               <div4 id="example-csv-mode-parse-line">
                  <head>The Mode <code>csv:parse-line</code></head>
                  <p>By default, the mode <code>csv:parse-line</code> parses the current item (this
                     will be one line of the input data) into fields, using mode
                        <code>csv:parse-field</code> on the individual fields and (by default)
                     wrapping the result in a <code>row</code> element.</p>
                  <p>The mode is declared with <code>visibility="public"</code> to allow it to be
                     called from elsewhere and overridden:</p>
                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:mode name="csv:parse-line" visibility="public"/&gt;</eg>
                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:template match="." mode="csv:parse-line"&gt;
    &lt;row&gt;
        &lt;xsl:apply-templates 
            select="tokenize(., $csv:field-separator)" 
            mode="csv:parse-field" /&gt;
    &lt;/row&gt;
&lt;/xsl:template&gt;
</eg>
                  <p>This relies on the variable <code>csv:field-separator</code>, which is a comma
                     by default but which can be overridden by the user to parse tab-separated data
                     or data with other delimiters.</p>
                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:variable name="csv:field-separator" 
              as="xs:string" 
              select="','" 
              visibility="public"/&gt;
</eg>
                  <p>The default implementation of <code>csv:parse-line</code> does not handle
                     occurrences of the field separator occurring within quoted strings. The user
                     can add templates to the mode to provide that functionality. </p>
               </div4>
               <div4 id="csv-example-mode">
                  <head>Mode <code>csv:parse-field</code></head>
                  <p>Mode <code>csv:parse-field</code> processes the current item as a field; by
                     default it strips quotation marks from the value, calls the function
                        <code>csv:preprocess-field()</code> on it, and wraps the result in a
                        <code>field</code> element, which carries the attributes declared in the
                     attribute set <code>csv:field-attributes</code>.</p>
                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">
&lt;xsl:template match="." 
              mode="csv:parse-field" 
              expand-text="yes"&gt;
    &lt;xsl:variable name="string-body-pattern"
                  as="xs:string"
                  select="'([^' || $csv:validated-quote || ']*)'"/&gt;
    &lt;xsl:variable name="quoted-value"
                  as="xs:string"
                  select="$csv:validated-quote 
                          || $string-body-pattern 
                          || $csv:validated-quote"/&gt;
    &lt;xsl:variable name="unquoted-value"
                  as="xs:string"
                  select="'(.+)'"/&gt;

    &lt;field xsl:use-attribute-sets="csv:field-attributes"&gt;{
        csv:preprocess-field(
          replace(., 
                  $quoted-value || '|' || $unquoted-value, 
                  '$1$2'))
    }&lt;/field&gt;
&lt;/xsl:template&gt;
</eg>
                  <p>The attribute set <code>csv:field-attributes</code> includes, by default, a
                        <code>quoted</code> attribute which has the values <code>yes</code> or
                        <code>no</code> to show whether the input value was quoted or not.</p>
                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:attribute-set name="csv:field-attributes" 
                   visibility="public"&gt;
    &lt;xsl:attribute name="quoted" 
                   select="if (starts-with(., $csv:validated-quote)) 
                           then 'yes' 
                           else 'no'" /&gt;
&lt;/xsl:attribute-set&gt;
</eg>
                  <p>The mode <code>csv:parse-field</code> is declared with
                        <code>visibility="public"</code> to allow it to be called from elsewhere and
                     overridden; it specifies <code>on-no-match="shallow-copy"</code> so that any
                     string not matching a template will simply be copied:</p>
                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:mode name="csv:parse-field"
          on-no-match="shallow-copy" 
          visibility="public"/&gt;
</eg>
               </div4>
               <div4 id="csv-example-variable">
                  <head>The <code>csv:quote</code> Variable</head>
                  <p>The variable <code>csv:quote</code> can be used to specify the character used
                     in a particular input stream to quote values.</p>
                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:variable name="csv:quote" 
              as="xs:string" 
              select="'&amp;quot;'" 
              visibility="public"/&gt;
</eg>
                  <p>The template given above assumes that the variable is one character long. To
                     ensure that any overriding value of the variable is properly checked,
                     references to the value use a second variable <code>csv:validated-quote</code>,
                     which is declared <code>private</code> to ensure that the checking cannot be
                     disabled.</p>
                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:variable name="csv:validated-quote" visibility="private"
   as="xs:string" select="
       if (string-length($csv:quote) ne 1) 
       then error(xs:QName('csv:ERR001'), 
                  'Incorrect length for $csv:quote, should be 1') 
       else $csv:quote" /&gt;
</eg>
                  <p>When the value of <code>csv:quote</code> is not exactly one character long, the
                     reference to <code>csv:validated-quote</code> will cause an error (csv:ERR001)
                     to be raised.</p>
               </div4>
               <div4 id="csv-example-preprocess-field">
                  <head>The <code>csv:preprocess-field</code> Function</head>
                  <p>The function <code>csv:preprocess-field</code> is called on each field after
                     any quotation marks are stripped and before it is written out as the value of a
                        <code>field</code> element:</p>
                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:function name="csv:preprocess-field" 
              as="xs:string"&gt;
    &lt;xsl:param name="field" 
               as="xs:string" /&gt;
    &lt;xsl:sequence select="$field" /&gt;
&lt;/xsl:function&gt;
</eg>
                  <p>As can be seen, the function does nothing but return its input; its only
                     purpose is to provide the opportunity for the user to supply a suitable
                     function to be invoked at this point in the processing of each field.</p>
               </div4>
               <div4 id="csv-example-postprocess">
                  <head>The Mode <code>csv:post-process</code></head>
                  <p>The mode <code>csv:post-process</code> is intended solely as a hook for user
                     code. By default, it does nothing.</p>
                  <p>The package defines no templates for this mode; the mode definition makes it
                     return a copy of its input:</p>
                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:mode name="csv:post-process" 
          on-no-match="shallow-copy" 
          visibility="public"/&gt;
</eg>
               </div4>
               <div4 id="csv-example-overriding">
                  <head>Overriding the Default Behavior</head>
                  <p>As can be seen from the code shown above, the package provides several
                     opportunities for users to override the default behavior:</p>
                  <ulist>
                     <item>
                        <p>The global variables <code>csv:line-separator</code>,
                              <code>csv:field-separator</code>, and <code>csv:quote</code> can be
                           overridden to specify the character strings used to separate lines and
                           fields and to quote individual field values.</p>
                     </item>
                     <item>
                        <p>The function <code>csv:preprocess-line</code> can be overridden to do
                           more (or less) than stripping white space; the function
                              <code>csv:preprocess-field</code> can be overridden to process
                           individual field values.</p>
                     </item>
                     <item>
                        <p>Templates can be added to the modes <code>csv:parse-line</code>,
                              <code>csv:parse-field</code>, and <code>csv:post-process</code> to
                           change their behavior.</p>
                     </item>
                     <item>
                        <p>The attribute set <code>csv:field-attributes</code> can be overridden to
                           specify a different set of attributes (or none) for <code>field</code>
                           elements.</p>
                     </item>
                  </ulist>
                  <p>The following using stylesheet illustrates the use of the
                        <elcode>xsl:override</elcode> element to take advantage of several of these
                     opportunities:</p>
                  <eg role="xslt-document" xml:space="preserve">
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"
   xmlns:csv="http://example.com/csv"
   exclude-result-prefixes="xs csv"
   version="3.0"&gt;

   &lt;xsl:output indent="yes" /&gt;

   &lt;xsl:use-package name="http://example.com/csv-parser" 
                    package-version="*"&gt;
       &lt;xsl:override&gt;
           &lt;!-- Change the root element from 'csv' to 'root' --&gt;
           &lt;xsl:template match="csv" mode="csv:post-process"&gt;
               &lt;root&gt;
                   &lt;xsl:apply-templates mode="csv:post-process" /&gt;
               &lt;/root&gt;
           &lt;/xsl:template&gt;

           &lt;!-- add an extra attribute that uses the context item --&gt;
           &lt;xsl:attribute-set name="csv:field-attributes" 
                              use-attribute-sets="xsl:original"&gt;
               &lt;xsl:attribute name="type" 
                              select="if (. castable as xs:decimal) 
                                      then 'numeric' 
                                      else 'string'" /&gt;
           &lt;/xsl:attribute-set&gt;          

           &lt;!-- use semicolon not comma between fields --&gt;
           &lt;xsl:variable name="csv:field-separator" 
                         as="xs:string" select="';'" 
                         visibility="public"/&gt;

           &lt;!-- prevent empty rows from appearing with empty lines --&gt;
           &lt;xsl:function name="csv:preprocess-line" 
                         as="xs:string?" 
                         visibility="public"&gt;
               &lt;xsl:param name="line" as="xs:string" /&gt;
               &lt;xsl:variable name="norm-line" 
                             select="normalize-space(xsl:original($line))" /&gt;
               &lt;xsl:sequence select="if (string-length($norm-line) &gt; 0) 
                                     then $norm-line 
                                     else ()" /&gt;
           &lt;/xsl:function&gt;
       &lt;/xsl:override&gt;
   &lt;/xsl:use-package&gt;

   &lt;!-- example input "file"  --&gt;
   &lt;xsl:variable name="input" as="xs:string"&gt;
       name;id;postal code
       "Braaksma Abel";34291;1210 KA
       "Berglund Anders";473892;9843 ZD
   &lt;/xsl:variable&gt;

   &lt;!-- entry point --&gt;
   &lt;xsl:template name="xsl:initial-template"&gt;
       &lt;xsl:copy-of select="csv:parse($input)" /&gt;
   &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg>
                  <note>
                     <ulist>
                        <item>
                           <p>As it does elsewhere, the visibility of components declared within
                                 <elcode>xsl:override</elcode> defaults to <code>private</code>; to
                              keep the component public, it is necessary to specify visibility
                              explicitly.</p>
                        </item>
                        <item>
                           <p>The types and optionality of all function parameters must match those
                              of the function being overridden; for function overriding to be
                              feasible, packages must document the function signature
                              thoroughly.</p>
                        </item>
                        <item>
                           <p>The names, types, and optionality of all named-template parameters
                              must match those of the template being overridden; for overriding to
                              be feasible, packages must document the template signature
                              thoroughly.</p>
                        </item>
                        <item>
                           <p>The values for the attributes in the attribute set
                                 <code>csv:field-attributes</code> are calculated once for each
                              element for which the attribute set is supplied; the
                                 <code>select</code> attributes which determine the values can thus
                              refer to the context item. Here, the value specification for the
                                 <code>type</code> attribute checks to see whether the string value
                              of the context item is numeric by inquiring whether it can be cast to
                              decimal, and sets the value for the <code>type</code> attribute
                              accordingly.</p>
                        </item>
                     </ulist>
                  </note>
                  <p>The result returned by this stylesheet would be:</p>
                  <eg role="xml" xml:space="preserve">&lt;root&gt;
  &lt;row&gt;
    &lt;field quoted="no" type="string"&gt;name&lt;/field&gt;
    &lt;field quoted="no" type="string"&gt;id&lt;/field&gt;
    &lt;field quoted="no" type="string"&gt;postal code&lt;/field&gt;
  &lt;/row&gt;
  &lt;row&gt;
    &lt;field quoted="yes" type="string"&gt;Braaksma Abel&lt;/field&gt;
    &lt;field quoted="no" type="numeric"&gt;34291&lt;/field&gt;
    &lt;field quoted="no" type="string"&gt;1210 KA&lt;/field&gt;
  &lt;/row&gt;
  &lt;row&gt;
    &lt;field quoted="yes" type="string"&gt;Berglund Anders&lt;/field&gt;
    &lt;field quoted="no" type="numeric"&gt;473892&lt;/field&gt;
    &lt;field quoted="no" type="string"&gt;9843 ZD&lt;/field&gt;
  &lt;/row&gt;
&lt;/root&gt;
</eg>
               </div4>
            </div3>
            <div3 id="xquery-packages" diff="del" at="S-bug29251">
               <head>Using an XQuery Library Package</head>
               <p><emph>The capability described in this section is an optional feature that
                     processors are not <rfc2119>required</rfc2119> to provide.</emph></p>
               <p>A processor <rfc2119>may</rfc2119> recognize the URI supplied in the
                     <code>name</code> attribute of an <elcode>xsl:use-package</elcode> element as
                  the module URI of an XQuery library module.</p>
               <p>In this case all public functions and global variables declared in the XQuery
                  library module become available for use in the using package as if they were
                  declared as public functions or global variables in an XSLT 3.0 package. XQuery
                  external variables are treated as if they were XSLT stylesheet parameters.</p>
               <p>There are some minor differences in semantics between XSLT and XQuery, for example
                  XSLT uses the function conversion rules when initializing a global variable (in
                  XSLT, a node will be atomized if the required type is atomic) whereas XQuery
                  requires the computed value to match the declared type precisely. The way in which
                  such differences are handled is <termref def="dt-implementation-defined"/>; a
                  conformant implementation may use either the XQuery semantics or the XSLT
                  semantics.</p>
               <p diff="chg" at="O">It is <termref def="dt-implementation-defined"/> whether an
                  XQuery expression that is evaluated in the course of a transformation is evaluated
                  within the same <xtermref spec="FO30" ref="execution-scope"/> as the calling XSLT
                  code. (It if is, then, for example, calls to <code>current-dateTime</code> will
                  deliver the same result whether called from the XSLT code or the XQuery code.)</p>
               <p diff="add" at="O">It is <termref def="dt-implementation-defined"/> whether node
                  identity is preserved when calling XQuery code from XSLT code.</p>
               <imp-def-feature id="idf-ext-xquery">When XQuery functions and variables are used
                  from XSLT, it is <termref def="dt-implementation-defined"/> how any differences
                  between XSLT and XQuery semantics are handled; it is <termref
                     def="dt-implementation-defined"/> whether XQuery code is evaluated within the
                  same <xtermref spec="FO30" ref="execution-scope"/> as XSLT code; and it is
                     <termref def="dt-implementation-defined"/> whether node identity is preserved
                  across the interface. The effect of calling XQuery functions that are updateing or
                  nondeterministic is also <termref def="dt-implementation-defined"
                  />.</imp-def-feature>
               <note>
                  <p diff="add" at="O">Where the XSLT implementation invokes an XQuery processor
                     developed by a third party, it may be necessary to convert nodes to a different
                     internal representation as part of the calling mechanism, and it may be
                     difficult to do this conversion in a way that retains node identity. It is
                     required, however, that nodes passed to the XQuery processor, or returned in
                     the result, retain all their relationships to other nodes in the same tree.
                     Furthermore, this specification provides no license to drop type
                     annotations.</p>
               </note>
               <p>As when using multiple XSLT packages, it is required that any schema imported by
                  the XQuery library module must be consistent with the schema imported by the using
                  package, and that any <termref def="dt-type-annotation"/> on a node passed from
                  one package to another must refer unambiguously to the same type.</p>
               <p>The effect of using an XQuery library module in which there are functions that are
                  updating or nondeterministic is <termref def="dt-implementation-defined"/>.</p>
               <p>Processors <rfc2119>may</rfc2119> impose additional restrictions on the use of
                  XQuery library modules; for example they may treat variables and functions
                  declared in the library module as <code>final</code>, or they may require that the
                  module uses a particular version of XQuery.</p>
            </div3>
         </div2>
         <div2 id="stylesheet-modules">
            <head>Stylesheet Modules</head>
            <p>
               <termdef id="dt-stylesheet-module" term="stylesheet module">A <phrase diff="chg"
                     at="I"><termref def="dt-package">package</termref></phrase> consists of one or
                  more <term>stylesheet modules</term>, each one forming all or part of an XML
                  document.</termdef>
            </p>
            <note>
               <p>A stylesheet module is represented by an XDM element node (see <bibref
                     ref="xpath-datamodel-30"/>). In the case of a standard stylesheet module, this
                  will be an <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode>
                  element. In the case of a simplified stylesheet module, it can be any element (not
                  in the <termref def="dt-xslt-namespace">XSLT namespace</termref>) that has an
                     <code>xsl:version</code> attribute.</p>
               <p>Although stylesheet modules will commonly be maintained in the form of documents
                  conforming to XML 1.0 or XML 1.1, this specification does not mandate such a
                  representation. As with <termref def="dt-source-tree">source trees</termref>, the
                  way in which stylesheet modules are constructed, from textual XML or otherwise, is
                  outside the scope of this specification.</p>
            </note>
            <p diff="chg" at="R-bug24310">The principal stylesheet module of a package may take one
               of three forms:</p>
            <ulist diff="chg" at="R-bug24310">
               <item>
                  <p>A package manifest, as described in <specref ref="packages"/>, which is a
                     subtree rooted at an <elcode>xsl:package</elcode> element</p>
               </item>
               <item>
                  <p>An implicit package, which is a subtree rooted at an
                        <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element.
                     This is transformed automatically to a package as described in <specref
                        ref="packages"/>. </p>
               </item>
               <item>
                  <p>A simplified stylesheet, which is a subtree rooted at a literal result element,
                     as described in <specref ref="simplified-stylesheet"/>. This is first converted
                     to an implicit package by wrapping it in an <elcode>xsl:stylesheet</elcode>
                     element using the transformation described in <specref
                        ref="simplified-stylesheet"/>, and then to an explicit package (rooted at an
                        <elcode>xsl:package</elcode> element) using the transformation described in
                        <specref ref="packages"/>. </p>
               </item>
            </ulist>
            <p diff="chg" at="R-bug24310">A stylesheet module other than the principal stylesheet
               module of a package may take either of two forms:</p>
            <ulist diff="chg" at="R-bug24310">
               <item>
                  <p><termdef id="dt-standard-stylesheet-module" term="standard stylesheet module">A
                           <term>standard stylesheet module</term>, which is a subtree rooted at an
                           <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode>
                        element.</termdef></p>
               </item>
               <item>
                  <p><termdef id="dt-simplified-stylesheet-module" term="simplified stylesheet">A
                           <term>simplified stylesheet</term>, which is a subtree rooted at a
                           <termref def="dt-literal-result-element">literal result
                        element</termref>, as described in <specref ref="simplified-stylesheet"/>.
                        This is first converted to a <termref def="dt-standard-stylesheet-module"
                           >standard stylesheet module</termref> by wrapping it in an xsl:stylesheet
                        element using the transformation described in <specref
                           ref="simplified-stylesheet"/>.</termdef>
                  </p>
               </item>
            </ulist>
            <p diff="chg" at="R-bug24310">Whichever of the above forms a module takes, the outermost
               element (<elcode>xsl:package</elcode>, <elcode>xsl:stylesheet</elcode>, or a <termref
                  def="dt-literal-result-element"/>) <rfc2119>may</rfc2119> either be the outermost
               element of an XML document, or it <rfc2119>may</rfc2119> be a child of some
               (non-XSLT) element in a host document. </p>
            <p diff="chg" at="R-bug24310"><termdef id="dt-embedded-stylesheet-module"
                  term="embedded stylesheet module">A stylesheet module whose outermost element is
                  the child of a non-XSLT element in a host document is referred to as an
                     <term>embedded stylesheet module</term>. See <specref ref="embedded"
                  />.</termdef>
            </p>
         </div2>
         <div2 id="stylesheet-element">
            <head>Stylesheet Element</head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="stylesheet">
               <e:attribute name="id">
                  <e:data-type name="id"/>
               </e:attribute>
               <e:attribute name="version" required="yes">
                  <e:data-type name="decimal"/>
               </e:attribute>
               <e:attribute name="default-mode">
                  <e:data-type name="eqname"/>
                  <e:constant value="#unnamed"/>
               </e:attribute>
               <e:attribute name="default-validation">
                  <e:constant value="preserve"/>
                  <e:constant value="strip"/>
               </e:attribute>
               <e:attribute name="input-type-annotations">
                  <e:constant value="preserve"/>
                  <e:constant value="strip"/>
                  <e:constant value="unspecified"/>
               </e:attribute>
               <e:attribute name="default-collation">
                  <e:data-type name="uris"/>
               </e:attribute>
               <e:attribute name="extension-element-prefixes">
                  <e:data-type name="prefixes"/>
               </e:attribute>
               <e:attribute name="exclude-result-prefixes">
                  <e:data-type name="prefixes"/>
               </e:attribute>
               <e:attribute name="expand-text">
                  <e:data-type name="boolean"/>
               </e:attribute>
               <e:attribute name="use-when">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="xpath-default-namespace">
                  <e:data-type name="uri"/>
               </e:attribute>
               <e:sequence>
                  <e:model name="declarations"/>
               </e:sequence>
            </e:element-syntax>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="transform">
               <e:attribute name="id">
                  <e:data-type name="id"/>
               </e:attribute>
               <e:attribute name="version" required="yes">
                  <e:data-type name="decimal"/>
               </e:attribute>
               <e:attribute name="default-mode">
                  <e:data-type name="eqname"/>
                  <e:constant value="#unnamed"/>
               </e:attribute>
               <e:attribute name="default-validation">
                  <e:constant value="preserve"/>
                  <e:constant value="strip"/>
               </e:attribute>
               <e:attribute name="input-type-annotations">
                  <e:constant value="preserve"/>
                  <e:constant value="strip"/>
                  <e:constant value="unspecified"/>
               </e:attribute>
               <e:attribute name="default-collation">
                  <e:data-type name="uris"/>
               </e:attribute>
               <e:attribute name="extension-element-prefixes">
                  <e:data-type name="prefixes"/>
               </e:attribute>
               <e:attribute name="exclude-result-prefixes">
                  <e:data-type name="prefixes"/>
               </e:attribute>
               <e:attribute name="expand-text">
                  <e:data-type name="boolean"/>
               </e:attribute>
               <e:attribute name="use-when">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="xpath-default-namespace">
                  <e:data-type name="uri"/>
               </e:attribute>
               <e:sequence>
                  <e:model name="declarations"/>
               </e:sequence>
            </e:element-syntax>
            <p>A stylesheet module is represented by an <elcode>xsl:stylesheet</elcode> element in
               an XML document. <elcode>xsl:transform</elcode> is allowed as a synonym for
                  <elcode>xsl:stylesheet</elcode>; everything this specification says about the
                  <elcode>xsl:stylesheet</elcode> element applies equally to
                  <elcode>xsl:transform</elcode>.</p>
            <p diff="chg" at="P-bug22595">The <code>version</code> attribute indicates the version
               of XSLT that the stylesheet module requires. The attribute is
                  <rfc2119>required</rfc2119><phrase diff="del" at="R-bug26468">, unless the
                     <elcode>xsl:stylesheet</elcode> element is a child of an
                     <elcode>xsl:package</elcode> element, in which case it is optional: the default
                  is then taken from the parent <elcode>xsl:package</elcode> element</phrase>.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0110"><p>The value of the
                        <code>version</code> attribute <phrase diff="del" at="R-bug26468">if present
                        </phrase><rfc2119>must</rfc2119> be a number: specifically, it
                        <rfc2119>must</rfc2119> be a valid instance of the type
                        <code>xs:decimal</code> as defined in <bibref ref="xmlschema-2"
                  />.</p></error>
            </p>
            <p diff="chg" at="D">The <code>version</code> attribute is intended to indicate the
               version of the XSLT specification against which the stylesheet is written. In a
               stylesheet written to use XSLT 3.0, the value <rfc2119>should</rfc2119> normally be
               set to <code>3.0</code>. If the value is numerically less than <code>3.0</code>, the
               stylesheet is processed using the rules for <termref
                  def="dt-backwards-compatible-behavior">backwards compatible behavior</termref>
               (see <specref ref="backwards"/>). If the value is numerically greater than
                  <code>3.0</code>, the stylesheet is processed using the rules for <termref
                  def="dt-forwards-compatible-behavior"/> (see <specref ref="forwards"/>).</p>
            <p>The effect of the <code>input-type-annotations</code> attribute is described in
                  <specref ref="stripping-annotations"/>.</p>
            <p>The <code>[xsl:]default-validation</code> attribute defines the default value of the
                  <code>validation</code> attribute of all relevant instructions appearing within
               its scope. For details of the effect of this attribute, see <specref ref="validation"
               />.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0120"><p>An
                        <elcode>xsl:stylesheet</elcode><phrase diff="add" at="T-bug29978">,
                           <elcode>xsl:transform</elcode>, or <elcode>xsl:package</elcode></phrase>
                     element <rfc2119>must not</rfc2119> have any text node children.</p></error>
               (This rule applies after stripping of <termref def="dt-whitespace-text-node"
                  >whitespace text nodes</termref> as described in <specref
                  ref="stylesheet-stripping"/>.)</p>
            <p>
               <termdef id="dt-top-level" term="top-level">An element occurring as a child of an
                     <phrase diff="add" at="S-bug28462"><elcode>xsl:package</elcode></phrase>,
                     <elcode>xsl:stylesheet</elcode><phrase diff="add" at="M">,
                        <elcode>xsl:transform</elcode>, or <elcode>xsl:override</elcode></phrase>
                  element is called a <term>top-level</term> element.</termdef>
            </p>
            <p>
               <termdef id="dt-declaration" term="declaration">Top-level elements fall into two
                  categories: declarations, and user-defined data elements. Top-level elements whose
                  names are in the <termref def="dt-xslt-namespace">XSLT namespace</termref> are
                     <term>declarations</term>. Top-level elements in any other namespace are
                     <termref def="dt-data-element">user-defined data elements</termref> (see
                     <specref ref="user-defined-top-level"/>)</termdef>.</p>
            <p>The <termref def="dt-declaration">declaration</termref> elements permitted in the
                  <elcode>xsl:stylesheet</elcode> element are:</p>
            <slist>
               <sitem>
                  <elcode>xsl:accumulator</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:attribute-set</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:character-map</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:decimal-format</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:function</elcode>
               </sitem>
               <sitem>
                  <phrase diff="add" at="S-bug28129"
                     ><elcode>xsl:global-context-item</elcode></phrase>
               </sitem>
               <sitem>
                  <elcode>xsl:import</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:import-schema</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:include</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:key</elcode>
               </sitem>
               <sitem>
                  <phrase diff="add" at="A">
                     <elcode>xsl:mode</elcode>
                  </phrase>
               </sitem>
               <sitem>
                  <elcode>xsl:namespace-alias</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:output</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:param</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:preserve-space</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:strip-space</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:template</elcode>
               </sitem>
               <sitem>
                  <phrase diff="add" at="S-bug29121"><elcode>xsl:use-package</elcode></phrase>
               </sitem>
               <sitem>
                  <elcode>xsl:variable</elcode>
               </sitem>
            </slist>
            <p>Note that the <elcode>xsl:variable</elcode> and <elcode>xsl:param</elcode> elements
               can act either as <termref def="dt-declaration">declarations</termref> or as <termref
                  def="dt-instruction">instructions</termref>. A global variable or parameter is
               defined using a declaration; a local variable or parameter using an instruction.</p>
            <p><phrase diff="del" at="R-bug24438">If there are <elcode>xsl:use-package</elcode>
                  elements, these <rfc2119>must</rfc2119> come before any other elements. If there
                  are <elcode>xsl:import</elcode> elements, these <rfc2119>must</rfc2119> come after
                  any <elcode>xsl:use-package</elcode> elements but before any other elements. Apart
                  from this, </phrase>The child elements of the <elcode>xsl:stylesheet</elcode>
               element may appear in any order. In most cases, the ordering of these elements does
               not affect the results of the transformation; however:</p>
            <ulist>
               <item>
                  <p>As described in <specref ref="conflict"/>, when two template rules with the
                     same <termref def="dt-priority">priority</termref> match the same nodes, there
                     are situations where the order of the template rules will affect which is
                     chosen.</p>
               </item>
               <item>
                  <p diff="add" at="R">Forwards references to <termref def="dt-static-variable"
                        >static variables</termref> are not allowed in <termref
                        def="dt-static-expression">static expressions</termref>.</p>
               </item>
            </ulist>
            <p diff="del" at="R-bug24438">For the meaning of the <elcode>xsl:use-package</elcode>
               element, see <specref ref="packages"/>.</p>
            <div3 id="default-collation-attribute">
               <head>The <code>default-collation</code> Attribute</head>
               <p>The <code>default-collation</code> attribute is a <termref
                     def="dt-standard-attributes">standard attribute</termref> that may appear on
                  any element in the XSLT namespace, or (as <code>xsl:default-collation</code>) on a
                     <termref def="dt-literal-result-element">literal result element</termref>.</p>
               <p>The attribute, <phrase diff="chg" at="M">when it appears on an element
                        <var>E</var>, is used to specify the default collation used by all XPath
                     expressions appearing in attributes or <termref def="dt-text-value-template"
                        >text value templates</termref> that have <var>E</var> as an
                     ancestor</phrase>, unless overridden by another <code>default-collation</code>
                  attribute on an inner element. It also determines the collation used by certain
                  XSLT constructs (such as <elcode>xsl:key</elcode> and
                     <elcode>xsl:for-each-group</elcode>) within its scope.</p>
               <p>The value of the attribute is a whitespace-separated list of collation URIs. If
                  any of these URIs is a relative URI <phrase diff="add" at="F">reference</phrase>,
                  then it is resolved relative to the base URI of the attribute’s parent element. If
                  the implementation recognizes one or more of the resulting absolute collation
                  URIs, then it uses the first one that it recognizes as the default collation.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0125"><p>It is a <termref
                           def="dt-static-error">static error</termref> if the value of an
                           <code>[xsl:]default-collation</code> attribute, after resolving against
                        the base URI, contains no URI that the implementation recognizes as a
                        collation URI.</p></error>
               </p>
               <note>
                  <p>The reason the attribute allows a list of collation URIs is that collation URIs
                     will often be meaningful only to one particular XSLT implementation.
                     Stylesheets designed to run with several different implementations can
                     therefore specify several different collation URIs, one for use with each. To
                     avoid the above error condition, it is possible to include as the last
                     collation URI in the list either the Unicode Codepoint Collation <phrase
                        diff="add" at="N">or a collation in the UCA family (see <specref
                           ref="uca-collations"/>) with the parameter
                        <code>fallback=yes</code></phrase>.</p>
               </note>
               <p>The <code>[xsl:]default-collation</code> attribute does not affect the collation
                  used by <elcode>xsl:sort</elcode>
                  <phrase diff="add" at="S-bug29117">or by <elcode>xsl:merge</elcode></phrase>.</p>
               <p diff="add" at="P-erratumE36">In the absence of an
                     <code>[xsl:]default-collation</code> attribute, the default collation
                     <rfc2119>may</rfc2119> be set by the calling application in an <termref
                     def="dt-implementation-defined"/> way. The recommended default, unless the user
                  chooses otherwise, is to use the Unicode codepoint collation.</p>
               <imp-def-feature id="idf-api-defaultcollation">In the absence of an
                     <code>[xsl:]default-collation</code> attribute, the default collation
                     <rfc2119>may</rfc2119> be set by the calling application in an <termref
                     def="dt-implementation-defined"/> way.</imp-def-feature>
            </div3>
            <div3 id="default-mode" diff="add" at="A">
               <head>The <code>default-mode</code> Attribute</head>
               <p>The <code>[xsl:]default-mode</code> attribute defines the default value for the
                     <termref def="dt-mode">mode</termref> attribute of all
                     <elcode>xsl:template</elcode> and <elcode>xsl:apply-templates</elcode> elements
                     <phrase diff="chg" at="P">within its scope</phrase>.</p>
               <p diff="chg" at="S-bug29084">More specifically, when an element <var>E</var> matches
                  the pattern <code>(xsl:template[@match] | xsl:apply-templates)[not(@mode) or
                     normalize-space(@mode) eq "#default"]</code> (using the Unicode codepoint
                  collation), then the effective value of the <code>mode</code> attribute is taken
                  from the value of the <code>[xsl:]default-mode</code> attribute of the innermost
                  ancestor-or-self element of <var>E</var> that has such an attribute. If there is
                  no such element, then the default is the <termref def="dt-unnamed-mode">unnamed
                     mode</termref>. This is equivalent to specifying <code>#unnamed</code>.</p>
               <p diff="add" at="T-bug29827">In addition, when the attribute appears on the
                     <elcode>xsl:package</elcode>, <elcode>xsl:stylesheet</elcode>, or
                     <elcode>xsl:transform</elcode> element of the <termref
                     def="dt-principal-stylesheet-module"/> of the <termref
                     def="dt-top-level-package"/>, it provides a default value for the <termref
                     def="dt-initial-mode"/> used on stylesheet invocation.</p>
               <p>The value of the <code>[xsl:]default-mode</code> attribute <rfc2119>must</rfc2119>
                  either be <phrase diff="chg" at="K">an <termref def="dt-eqname"
                     >EQName</termref></phrase>, or the token <code>#unnamed</code> which refers to
                  the <termref def="dt-unnamed-mode">unnamed mode</termref>.</p>
               <note>
                  <p>This attribute is provided to support an approach to stylesheet modularity in
                     which all the template rules for one <termref def="dt-mode">mode</termref> are
                     collected together into a single <termref def="dt-stylesheet-module">stylesheet
                        module</termref>. Using this attribute reduces the risk of forgetting to
                     specify the mode in one or more places where it is needed, and it also makes it
                     easier to reuse an existing stylesheet module that does not use modes in an
                     application where modes are needed to avoid conflicts with existing template
                     rules.</p>
                  <p diff="chg" at="S-bug28453">It is not necessary for the referenced mode to be
                     explicitly declared in an <elcode>xsl:mode</elcode> declaration, unless this is
                     mandated by the <code>declared-modes</code> attribute (which defaults to
                        <code>yes</code> on an <elcode>xsl:package</elcode> element).</p>
               </note>
            </div3>
            <div3 id="user-defined-top-level">
               <head>User-defined Data Elements</head>
               <p>
                  <termdef id="dt-data-element" term="user-defined data element">In addition to
                        <termref def="dt-declaration">declarations</termref>, the
                        <elcode>xsl:stylesheet</elcode> element may contain among its children any
                     element not from the <termref def="dt-xslt-namespace">XSLT namespace</termref>,
                     provided that the <termref def="dt-expanded-qname">expanded QName</termref> of
                     the element has a non-null namespace URI. Such elements are referred to as
                        <term>user-defined data elements</term>.</termdef>
               </p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0130"><p>It is a <termref
                           def="dt-static-error">static error</termref> if an
                           <elcode>xsl:stylesheet</elcode><phrase diff="add" at="T-bug29978">,
                              <elcode>xsl:transform</elcode>, or
                           <elcode>xsl:package</elcode></phrase> element has a child element whose
                        name has a null namespace URI.</p></error>
               </p>
               <p>An implementation <rfc2119>may</rfc2119> attach an <termref
                     def="dt-implementation-defined"/> meaning to user-defined data elements that
                  appear in particular namespaces. The set of namespaces that are recognized for
                  such data elements is <termref def="dt-implementation-defined"
                     >implementation-defined</termref>. The presence of a user-defined data element
                     <rfc2119>must not</rfc2119> change the behavior of <termref
                     def="dt-xslt-element">XSLT elements</termref> and functions defined in this
                  document; for example, it is not permitted for a user-defined data element to
                  specify that <elcode>xsl:apply-templates</elcode> should use different rules to
                  resolve conflicts. The constraints on what user-defined data elements can and
                  cannot do are exactly the same as the constraints on <termref
                     def="dt-extension-attribute">extension attributes</termref>, described in
                     <specref ref="extension-attributes"/>. Thus, an implementation is always free
                  to ignore user-defined data elements, and <rfc2119>must</rfc2119> ignore such data
                  elements without giving an error if it does not recognize the namespace URI. </p>
               <imp-def-feature id="idf-ext-namespaces">The set of namespaces that are specially
                  recognized by the implementation (for example, for user-defined data elements, and
                     <termref def="dt-extension-attribute">extension attributes</termref>) is
                     <termref def="dt-implementation-defined"/>.</imp-def-feature>
               <imp-def-feature id="idf-ext-dataelements">The effect of user-defined data elements
                  whose name is in a namespace recognized by the implementation is <termref
                     def="dt-implementation-defined"/>.</imp-def-feature>
               <p>User-defined data elements can provide, for example,</p>
               <ulist>
                  <item>
                     <p>information used by <termref def="dt-extension-instruction">extension
                           instructions</termref> or <termref def="dt-extension-function">extension
                           functions</termref> (see <specref ref="extension"/>),</p>
                  </item>
                  <item>
                     <p>information about what to do with any <termref def="dt-final-result-tree"
                           >final result tree</termref>,</p>
                  </item>
                  <item>
                     <p>information about how to construct <termref def="dt-source-tree">source
                           trees</termref>,</p>
                  </item>
                  <item>
                     <p>optimization hints for the <termref def="dt-processor"
                        >processor</termref>,</p>
                  </item>
                  <item>
                     <p>metadata about the stylesheet,</p>
                  </item>
                  <item>
                     <p>structured documentation for the stylesheet.</p>
                  </item>
               </ulist>
               <p diff="del" at="Q">A <termref def="dt-data-element">user-defined data
                     element</termref>
                  <rfc2119>must not</rfc2119> precede an <elcode>xsl:import</elcode> element within
                  a <termref def="dt-stylesheet-module">stylesheet module</termref>
               </p>
            </div3>
         </div2>
         <div2 id="simplified-stylesheet">
            <head>Simplified Stylesheet Modules</head>
            <p>A simplified syntax is allowed for a <termref def="dt-stylesheet-module">stylesheet
                  module</termref> that defines only a single template rule for the document node.
               The stylesheet module may consist of just a <termref def="dt-literal-result-element"
                  >literal result element</termref> (see <specref ref="literal-result-element"/>)
               together with its contents. The literal result element must have an
                  <code>xsl:version</code> attribute (and it must therefore also declare the XSLT
               namespace). Such a stylesheet module is equivalent to a standard stylesheet module
               whose <elcode>xsl:stylesheet</elcode> element contains a <termref
                  def="dt-template-rule">template rule</termref> containing the literal result
               element, minus its <code>xsl:version</code> attribute; the template rule has a match
                  <termref def="dt-pattern">pattern</termref> of <code>/</code>.</p>
            <example>
               <head>A Simplified Stylesheet</head>
               <p>For example:</p>
               <eg xml:space="preserve" role="xml">&lt;html xsl:version="3.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns="http://www.w3.org/1999/xhtml"&gt;
  &lt;head&gt;
    &lt;title&gt;Expense Report Summary&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Total Amount: &lt;xsl:value-of select="expense-report/total"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</eg>
               <p>has the same meaning as</p>
               <eg xml:space="preserve" role="xslt-document">&lt;xsl:stylesheet version="3.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;xsl:template match="/"&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Expense Report Summary&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Total Amount: &lt;xsl:value-of select="expense-report/total"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</eg>
               <p>Note that it is not possible, using a simplified stylesheet, to request that the
                  serialized output contains a <code>DOCTYPE</code> declaration. This can only be
                  done by using a standard stylesheet module, and using the
                     <elcode>xsl:output</elcode> element.</p>
            </example>
            <p>More formally, a simplified stylesheet module is equivalent to the standard
               stylesheet module that would be generated by applying the following transformation to
               the simplified stylesheet module, invoking the transformation by calling the <termref
                  def="dt-named-template">named template</termref>
               <code>expand</code>, with the containing literal result element as the <termref
                  def="dt-context-node">context node</termref>: </p>
            <eg xml:space="preserve" role="xslt-document">&lt;xsl:stylesheet version="3.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template name="expand"&gt;
  &lt;xsl:element name="xsl:stylesheet"&gt;
    &lt;xsl:attribute name="version" select="@xsl:version"/&gt;
    &lt;xsl:element name="xsl:template"&gt;
      &lt;xsl:attribute name="match" select="'/'"/&gt;
      &lt;xsl:copy-of select="."/&gt;
    &lt;/xsl:element&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;  

&lt;/xsl:stylesheet&gt;</eg>
            <p>
               <error spec="XT" type="static" class="SE" code="0150"><p>A <termref
                        def="dt-literal-result-element">literal result element</termref> that is
                     used as the outermost element of a simplified stylesheet module
                        <rfc2119>must</rfc2119> have an <code>xsl:version</code>
                  attribute.</p></error> This indicates the version of XSLT that the stylesheet
               requires. For this version of XSLT, the value will normally be <code>
                  <phrase diff="chg" at="A">3.0</phrase>
               </code>; the value <rfc2119>must</rfc2119> be a valid instance of the type
                  <code>xs:decimal</code> as defined in <bibref ref="xmlschema-2"/>.</p>
            <p diff="del" at="D">Other <termref def="dt-literal-result-element">literal result
                  elements</termref> may also have an <code>xsl:version</code> attribute. When the
                  <code>xsl:version</code> attribute is numerically less than <code>2.0</code>,
                  <termref def="dt-backwards-compatible-behavior"/> is enabled (see <specref
                  ref="backwards"/>). When the <code>xsl:version</code> attribute is numerically
               greater than <code>2.0</code>, <termref def="dt-forwards-compatible-behavior"/> is
               enabled (see <specref ref="forwards"/>).</p>
            <p>The allowed content of a literal result element when used as a simplified stylesheet
               is the same as when it occurs within a <termref def="dt-sequence-constructor"
                  >sequence constructor</termref>. Thus, a literal result element used as the
               document element of a simplified stylesheet cannot contain <termref
                  def="dt-declaration">declarations</termref>. Simplified stylesheets therefore
               cannot use <termref def="dt-template-rule">template rules</termref>, <termref
                  def="dt-global-variable">global variables</termref>, <termref
                  def="dt-stylesheet-parameter">stylesheet parameters</termref>, <termref
                  def="dt-stylesheet-function">stylesheet functions</termref>, <termref def="dt-key"
                  >keys</termref>, <termref def="dt-attribute-set">attribute-sets</termref>, or
                  <termref def="dt-output-definition">output definitions</termref>. In turn this
               means that the only useful way to initiate the transformation is to supply a document
               node as the <phrase diff="chg" at="R-bug24764"><termref
                     def="dt-initial-match-selection"/></phrase>, to be matched by the implicit
                  <code>match="/"</code> template rule using the <termref def="dt-unnamed-mode"
                  >unnamed mode</termref>. </p>
         </div2>
         <div2 id="backwards" diff="chg" at="D">
            <head>Backwards Compatible Processing</head>
            <p><termdef id="dt-effective-version" term="effective version">The <term>effective
                     version</term> of an element in a <phrase diff="chg" at="M"><termref
                        def="dt-stylesheet-module"/> or <termref def="dt-package-manifest"
                     /></phrase> is the decimal value of the <code>[xsl:]version</code> attribute
                  (see <specref ref="standard-attributes"/>) on that element or on the innermost
                  ancestor element that has such an attribute, excluding the <code>version</code>
                  attribute on an <elcode>xsl:output</elcode> element.</termdef></p>
            <p>
               <termdef id="dt-backwards-compatible-behavior" term="backwards compatible behavior"
                  >An element is processed with <term>backwards compatible behavior</term> if its
                     <termref def="dt-effective-version">effective version</termref> is less than
                     <code diff="chg" at="D">3.0</code>.</termdef>
            </p>
            <p>Specifically:</p>
            <ulist>
               <item>
                  <p>If the <termref def="dt-effective-version">effective version</termref> is equal
                     to 1.0, then the element is processed with XSLT 1.0 behavior as described in
                        <specref ref="backwards-1.0"/>.</p>
               </item>
               <item>
                  <p>If the <termref def="dt-effective-version">effective version</termref> is equal
                     to 2.0, then the element is processed with XSLT 2.0 behavior as described in
                        <specref ref="backwards-2.0"/>.</p>
               </item>
               <item>
                  <p>If the <termref def="dt-effective-version">effective version</termref> is any
                     other value less than 3.0, the <rfc2119>recommended</rfc2119> action is to
                     report a static error; however, processors <rfc2119>may</rfc2119> recognize
                     such values and process the element in an <termref
                        def="dt-implementation-defined"/> way.</p>
                  <imp-def-feature id="idf-err-unknownversion">If the <termref
                        def="dt-effective-version">effective version</termref> of any element in the
                     stylesheet is not 1.0 or 2.0 but is less than 3.0, the
                        <rfc2119>recommended</rfc2119> action is to report a static error; however,
                     processors <rfc2119>may</rfc2119> recognize such values and process the element
                     in an <termref def="dt-implementation-defined"/> way.</imp-def-feature>
                  <note>
                     <p>XSLT 1.0 allowed the <code>version</code> attribute to take any decimal
                        value, and invoked forwards compatible processing for any value other than
                        1.0. XSLT 2.0 allowed the attribute to take any decimal value, and invoked
                        backwards compatible (i.e. 1.0-compatible) processing for any value less
                        than 2.0. Some stylesheets may therefore be encountered that use values
                        other than 1.0 or 2.0. In particular, the value 1.1 is sometimes
                        encountered, as it was used at one stage in a draft language proposal.</p>
                  </note>
               </item>
            </ulist>
            <p>These rules do not apply to the <elcode>xsl:output</elcode> element, whose
                  <code>version</code> attribute has an entirely different purpose: it is used to
               define the version of the output method to be used for serialization.</p>
            <p diff="del" at="D">An element that has an <code>[xsl:]version</code> attribute whose
               value is greater than or equal to <code>2.0</code> disables backwards compatible
               behavior for itself, its attributes, its descendants and their attributes. The
               compatibility behavior established by an element overrides any compatibility behavior
               established by an ancestor element.</p>
            <p>It is <termref def="dt-implementation-defined"/> whether a particular XSLT 3.0
               implementation supports backwards compatible behavior for any XSLT version earlier
               than XSLT 3.0.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0160"><p diff="chg" at="D">It is a
                        <termref def="dt-dynamic-error"><phrase diff="del" at="M"
                           >non-recoverable</phrase> dynamic error</termref> if an element has an
                        <termref def="dt-effective-version">effective version</termref> of
                        <var>V</var> (with <var>V</var> &lt; 3.0) when the implementation does not
                     support backwards compatible behavior for XSLT version
                  <var>V</var>.</p></error>
            </p>
            <imp-def-feature id="idf-feature-backwardscompatibility">It is implementation-defined
               whether an <phrase diff="chg" at="D">XSLT 3.0</phrase> processor supports backwards
               compatible behavior for any XSLT version earlier than XSLT 3.0.</imp-def-feature>
            <note>
               <p>By making use of backwards compatible behavior, it is possible to write the
                  stylesheet in a way that ensures that its results when processed with an XSLT 3.0
                  processor are identical to the effects of processing the same stylesheet using
                     <phrase diff="chg" at="D">a processor for an earlier version of XSLT</phrase>.
                  To assist with transition, some parts of a stylesheet may be processed with
                  backwards compatible behavior enabled, and other parts with this behavior
                  disabled.</p>
               <p>All data values manipulated by an <phrase diff="chg" at="D">XSLT 3.0</phrase>
                  processor are defined by the XDM data model, whether or not the relevant
                  expressions use backwards compatible behavior. Because the same data model is used
                  in both cases, expressions are fully composable. The result of evaluating
                  instructions or expressions with backwards compatible behavior is fully defined in
                  the <phrase diff="chg" at="D">XSLT 3.0</phrase> and <phrase diff="chg" at="D"
                     >XPath 3.0</phrase> specifications, it is not defined by reference to <phrase
                     diff="chg" at="D">earlier versions of the XSLT and XPath
                     specifications</phrase>. </p>
               <p>To write a stylesheet that makes use of <phrase diff="chg" at="D">features that
                     are new in version <var>N</var>, while also working with a processor that only
                     supports XSLT version <var>M</var> (<var>M</var> &lt; <var>N</var>)</phrase>,
                  it is necessary to understand both the rules for backwards compatible behavior in
                     <phrase diff="chg" at="D">XSLT version <var>N</var></phrase>, and the rules for
                  forwards compatible behavior in <phrase diff="chg" at="D">XSLT version
                        <var>M</var></phrase>. If the <elcode>xsl:stylesheet</elcode> element
                  specifies <code>version="2.0"</code>
                  <phrase diff="add" at="D">or <code>version="3.0"</code></phrase>, then an XSLT 1.0
                  processor will ignore XSLT 2.0 <phrase diff="add" at="D">and XSLT 3.0</phrase>
                  <termref def="dt-declaration">declarations</termref> that were not defined in XSLT
                  1.0, for example <elcode>xsl:function</elcode> and
                     <elcode>xsl:import-schema</elcode>. If any new <phrase diff="chg" at="D">XSLT
                     3.0</phrase> instructions are used (for example <elcode>xsl:evaluate</elcode>
                  or <elcode>xsl:source-document</elcode>), or if new <phrase diff="chg" at="D"
                     >XPath 3.0</phrase> features are used (for example, new functions, or <phrase
                     diff="chg" at="D">let</phrase> expressions), then the stylesheet must provide
                  fallback behavior that relies only on facilities <phrase diff="chg" at="D"
                     >available in the earliest XSLT version supported</phrase>. The fallback
                  behavior can be invoked by using the <elcode>xsl:fallback</elcode> instruction, or
                  by testing the results of the <function>function-available</function> or
                     <function>element-available</function> functions, or by testing the value of
                  the <code>xsl:version</code> property returned by the
                     <function>system-property</function> function.</p>
            </note>
            <div3 id="backwards-1.0" diff="add" at="D">
               <head>XSLT 1.0 Compatibility Mode</head>
               <p><termdef id="dt-xslt-10-behavior" term="XSLT 1.0 behavior">An element in the
                     stylesheet is processed with <term>XSLT 1.0 behavior</term> if its <termref
                        def="dt-effective-version">effective version</termref> is equal to
                     1.0.</termdef></p>
               <p>In this mode, if any attribute contains an XPath <termref def="dt-expression"
                     >expression</termref>, then the expression is evaluated with <termref
                     def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> set to
                     <code>true</code>. For details of this mode, see <xspecref spec="XP30"
                     ref="static_context"/>. <phrase diff="add" at="M">Expressions contained in
                        <termref def="dt-text-value-template">text value templates</termref> are
                     always evaluated with <termref def="dt-xpath-compat-mode">XPath 1.0
                        compatibility mode</termref> set to <code>false</code>, since this construct
                     was not available in XSLT 1.0.</phrase></p>
               <p>Furthermore, in such an expression any function call for which no implementation
                  is available (unless it uses the <termref def="dt-standard-function-namespace"
                     >standard function namespace</termref>) is bound to a fallback error function
                  whose effect when evaluated is to raise a dynamic error <errorref spec="XT"
                     class="DE" code="1425"/> . The effect is that with backwards compatible
                  behavior enabled, calls on <termref def="dt-extension-function">extension
                     functions</termref> that are not available in a particular implementation do
                  not cause an error unless the function call is actually evaluated. For further
                  details, see <specref ref="extension-functions"/>.</p>
               <note>
                  <p>This might appear to contradict the specification of XPath <phrase diff="chg"
                        at="D">3.0</phrase>, which states that a static error [XPST0017] is raised
                     when an expression contains a call to a function that is not present (with
                     matching name and arity) in the static context. This apparent contradiction is
                     resolved by specifying that the XSLT processor constructs a static context for
                     the expression in which every possible function name and arity (other than
                     names in the <termref def="dt-standard-function-namespace">standard function
                        namespace</termref>) is present; when no other implementation of the
                     function is available, the function call is bound to a fallback error function
                     whose run-time effect is to raise a dynamic error.</p>
               </note>
               <p>Certain XSLT constructs also produce different results when XSLT 1.0 compatibility
                  mode is enabled. This is described separately for each such construct.</p>
               <p diff="add" at="R-bug24506">Processing an <termref def="dt-instruction"/> with XSLT
                  1.0 behavior is not compatible with streaming. More specifically, and
                  notwithstanding anything stated in <specref ref="streamability"/>, an instruction
                  that is processed with XSLT 1.0 behavior is <termref def="dt-roaming"/> and
                     <termref def="dt-free-ranging"/>, which has the effect that any construct
                  containing such an instruction is not <termref def="dt-guaranteed-streamable"
                  />.</p>
            </div3>
            <div3 id="backwards-2.0" diff="add" at="D">
               <head>XSLT 2.0 Compatibility Mode</head>
               <p><termdef id="dt-xslt-20-behavior" term="XSLT 2.0 behavior">An element is processed
                     with <term>XSLT 2.0 behavior</term> if its <termref def="dt-effective-version"
                        >effective version</termref> is equal to 2.0.</termdef></p>
               <p>In this specification, no differences are defined for XSLT 2.0 behavior. An XSLT
                  3.0 processor will therefore produce the same results whether the <termref
                     def="dt-effective-version">effective version</termref> of an element is set to
                  2.0 or 3.0.</p>
               <note>
                  <p>An XSLT 2.0 processor, by contrast, will in some cases produce different
                     results in the two cases. For example, if the stylesheet contains an
                        <elcode>xsl:iterate</elcode> instruction with an
                        <elcode>xsl:fallback</elcode> child, an XSLT 3.0 processor will process the
                        <elcode>xsl:iterate</elcode> instruction regardless whether the effective
                     version is 2.0 or 3.0, while an XSLT 2.0 processor will report a static error
                     if the effective version is 2.0, and will take the fallback action if the
                     effective version is 3.0.</p>
               </note>
            </div3>
         </div2>
         <div2 id="forwards">
            <head>Forwards Compatible Processing</head>
            <p>The intent of forwards compatible behavior is to make it possible to write a
               stylesheet that takes advantage of features introduced in some version of XSLT
               subsequent to <phrase diff="chg" at="D">XSLT 3.0</phrase>, while retaining the
               ability to execute the stylesheet with an <phrase diff="chg" at="D">XSLT 3.0</phrase>
               processor using appropriate fallback behavior.</p>
            <p>It is always possible to write conditional code to run under different XSLT versions
               by using the <code>use-when</code> feature described in <specref
                  ref="conditional-inclusion"/>. The rules for forwards compatible behavior
               supplement this mechanism in two ways:</p>
            <ulist>
               <item>
                  <p>certain constructs in the stylesheet that mean nothing to an <phrase diff="chg"
                        at="D">XSLT 3.0</phrase> processor are ignored, rather than being treated as
                     errors.</p>
               </item>
               <item>
                  <p>explicit fallback behavior can be defined for instructions defined in a future
                     XSLT release, using the <elcode>xsl:fallback</elcode> instruction.</p>
               </item>
            </ulist>
            <p>The detailed rules follow.</p>
            <p diff="chg" at="D">
               <termdef id="dt-forwards-compatible-behavior" term="forwards compatible behavior">An
                  element is processed with <term>forwards compatible behavior</term> if its
                     <termref def="dt-effective-version">effective version</termref> is greater than
                     <code diff="chg" at="D">3.0</code>.</termdef>
            </p>
            <p diff="del" at="D">An element that has an <code>[xsl:]version</code> attribute whose
               value is less than or equal to <code>
                  <phrase diff="chg" at="A">3.0</phrase>
               </code> disables forwards compatible behavior for itself, its attributes, its
               descendants and their attributes. The compatibility behavior established by an
               element overrides any compatibility behavior established by an ancestor element.</p>
            <p>These rules do not apply to the <code>version</code> attribute of the
                  <elcode>xsl:output</elcode> element, which has an entirely different purpose: it
               is used to define the version of the output method to be used for serialization.</p>
            <p diff="chg" at="D">When an element is processed with forwards compatible behavior:</p>
            <ulist>
               <item>
                  <p>If the element is in the XSLT namespace and appears as a child of the
                        <elcode>xsl:stylesheet</elcode> element, and XSLT <phrase diff="chg" at="A"
                        >3.0</phrase> does not allow the element to appear as a child of the
                        <elcode>xsl:stylesheet</elcode> element, then the element and its content
                        <rfc2119>must</rfc2119> be ignored.</p>
               </item>
               <item>
                  <p>If the element has an attribute that XSLT <phrase diff="chg" at="A"
                        >3.0</phrase> does not allow the element to have, then the attribute
                        <rfc2119>must</rfc2119> be ignored.</p>
               </item>
               <item>
                  <p>If the element is in the XSLT namespace and appears as <phrase diff="chg"
                        at="R-bug7394">a child of an element whose content model requires a</phrase>
                     <termref def="dt-sequence-constructor">sequence constructor</termref>, and XSLT
                        <phrase diff="chg" at="A">3.0</phrase> does not allow such elements to
                     appear as part of a sequence constructor, then:</p>
                  <olist>
                     <item>
                        <p>If the element has one or more <elcode>xsl:fallback</elcode> children,
                           then no error is reported either statically or dynamically, and the
                           result of evaluating the instruction is the concatenation of the
                           sequences formed by evaluating the sequence constructors within its
                              <elcode>xsl:fallback</elcode> children, in document order. Siblings of
                           the <elcode>xsl:fallback</elcode> elements are ignored, even if they are
                           valid XSLT <phrase diff="chg" at="A">3.0</phrase> instructions.</p>
                     </item>
                     <item>
                        <p>If the element has no <elcode>xsl:fallback</elcode> children, then a
                           static error is reported in the same way as if forwards compatible
                           behavior were not enabled.</p>
                     </item>
                  </olist>
               </item>
            </ulist>
            <example>
               <head>Forwards Compatible Behavior</head>
               <p>For example, an XSLT <phrase diff="chg" at="A">3.0</phrase>
                  <termref def="dt-processor">processor</termref> will process the following
                  stylesheet without error, although the stylesheet includes elements from the
                     <termref def="dt-xslt-namespace">XSLT namespace</termref> that are not defined
                  in this specification:</p>
               <eg xml:space="preserve" role="xml">&lt;xsl:stylesheet version="17.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:template match="/"&gt;
    &lt;xsl:exciting-new-17.0-feature&gt;
      &lt;xsl:fly-to-the-moon/&gt;
      &lt;xsl:fallback&gt;
        &lt;html&gt;
          &lt;head&gt;
            &lt;title&gt;XSLT 17.0 required&lt;/title&gt;
          &lt;/head&gt;
          &lt;body&gt;
            &lt;p&gt;Sorry, this stylesheet requires XSLT 17.0.&lt;/p&gt;
          &lt;/body&gt;
        &lt;/html&gt;
      &lt;/xsl:fallback&gt;
    &lt;/xsl:exciting-new-17.0-feature&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</eg>
            </example>
            <note>
               <p>If a stylesheet depends crucially on a <termref def="dt-declaration"
                     >declaration</termref> introduced by a version of XSLT after <phrase diff="chg"
                     at="A">3.0</phrase>, then the stylesheet can use an
                     <elcode>xsl:message</elcode> element with <code>terminate="yes"</code> (see
                     <specref ref="message"/>) to ensure that implementations that conform to an
                  earlier version of XSLT will not silently ignore the <termref def="dt-declaration"
                     >declaration</termref>.</p>
            </note>
            <example>
               <head>Testing the XSLT Version</head>
               <p>For example,</p>
               <eg xml:space="preserve" role="xml">&lt;xsl:stylesheet version="18.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:important-new-17.0-declaration/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="number(system-property('xsl:version')) lt 17.0"&gt;
        &lt;xsl:message terminate="yes"&gt;
          &lt;xsl:text&gt;Sorry, this stylesheet requires XSLT 17.0.&lt;/xsl:text&gt;
        &lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        ...
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
  ...
&lt;/xsl:stylesheet&gt;</eg>
            </example>
            <note>
               <p diff="add" at="M">The XSLT 1.0 and XSLT 2.0 specifications did not anticipate the
                  introduction of the <elcode>xsl:package</elcode> element. An XSLT 1.0 or 2.0
                  processor encountering this element will report a static error, regardless of the
                     <code>version</code> setting.</p>
               <p diff="add" at="M">This problem can be circumvented by using the simplified package
                  syntax <phrase diff="chg" at="R-bug24438">(whereby an
                        <elcode>xsl:stylesheet</elcode> element is implicitly treated as
                        <elcode>xsl:package</elcode>)</phrase>, or by writing the stylesheet code in
                  a separate module from the package manifest, and using the separate module as the
                  version of the stylesheet that is presented to a 2.0 processor.</p>
            </note>
         </div2>
         <div2 id="combining-modules">
            <head>Combining Stylesheet Modules</head>
            <p>XSLT provides two mechanisms to construct a <phrase diff="chg" at="R-bug24310"
                     ><termref def="dt-package">package</termref></phrase> from multiple <termref
                  def="dt-stylesheet-module">stylesheet modules</termref>:</p>
            <ulist>
               <item>
                  <p>an inclusion mechanism that allows stylesheet modules to be combined without
                     changing the semantics of the modules being combined, and</p>
               </item>
               <item>
                  <p>an import mechanism that allows stylesheet modules to override each other.</p>
               </item>
            </ulist>
            <div3 id="locating-modules">
               <head>Locating Stylesheet Modules</head>
               <p>The include and import mechanisms use two declarations,
                     <elcode>xsl:include</elcode> and <elcode>xsl:import</elcode>, which are defined
                  in the sections that follow.</p>
               <p>These declarations use an <code>href</code> attribute, whose value is a <termref
                     def="dt-uri-reference">URI reference</termref>, to identify the <termref
                     def="dt-stylesheet-module">stylesheet module</termref> to be included or
                  imported. If the value of this attribute is a relative URI <phrase diff="add"
                     at="F">reference</phrase>, it is resolved as described in <specref
                     ref="uri-references"/>.</p>
               <p>After resolving against the base URI, the way in which the URI reference is used
                  to locate a representation of a <termref def="dt-stylesheet-module">stylesheet
                     module</termref>, and the way in which the stylesheet module is constructed
                  from that representation, are <termref def="dt-implementation-defined"
                     >implementation-defined</termref>. In particular, it is implementation-defined
                  which URI schemes are supported, whether fragment identifiers are supported, and
                  what media types are supported. Conventionally, the URI is a reference to a
                  resource containing the stylesheet module as a source XML document, or it may
                  include a fragment identifier that selects an embedded stylesheet module within a
                  source XML document; but the implementation is free to use other mechanisms to
                  locate the stylesheet module identified by the URI reference.</p>
               <imp-def-feature id="idf-api-moduleuri"> It is implementation-defined what forms of
                  URI reference are acceptable in the <code>href</code> attribute of the
                     <elcode>xsl:include</elcode> and <elcode>xsl:import</elcode> elements, for
                  example, the URI schemes that may be used, the forms of fragment identifier that
                  may be used, and the media types that are supported. The way in which the URI
                  reference is used to locate a representation of a <termref
                     def="dt-stylesheet-module">stylesheet module</termref>, and the way in which
                  the stylesheet module is constructed from that representation, are also
                  implementation-defined.</imp-def-feature>
               <p diff="chg" at="R-bug24310">The referenced <termref def="dt-stylesheet-module"
                     >stylesheet module</termref>
                  <rfc2119>must</rfc2119> be either a <termref def="dt-standard-stylesheet-module"/>
                  or a <termref def="dt-simplified-stylesheet-module"/>. It <rfc2119>must
                     not</rfc2119> be a <termref def="dt-package-manifest"/>. If it is a simplified
                  stylesheet module then it is transformed into the equivalent standard stylesheet
                  module by applying the transformation described in <specref
                     ref="simplified-stylesheet"/>. </p>
               <p>Implementations <rfc2119>may</rfc2119> choose to accept URI references containing
                  a fragment identifier defined by reference to the XPointer specification (see
                     <bibref ref="xptr-framework"/>). Note that if the implementation does not
                  support the use of fragment identifiers in the URI reference, then it will not be
                  possible to include an <termref def="dt-embedded-stylesheet-module">embedded
                     stylesheet module</termref>.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0165"><p>It is a <termref
                           def="dt-static-error">static error</termref> if the processor is not able
                        to retrieve the resource identified by the URI reference<error.extra> in the
                              <code>href</code> attribute of <elcode>xsl:include</elcode> or
                              <elcode>xsl:import</elcode>
                        </error.extra>, or if the resource that is retrieved does not contain a
                        stylesheet module<phrase diff="del" at="I"> conforming to this
                           specification</phrase>.</p></error>
               </p>
               <note>
                  <p diff="add" at="I"> It is appropriate to use this error code when the resource
                     cannot be retrieved, or when the retrieved resource is not well formed XML. If
                     the resource contains XML that can be parsed but that violates the rules for
                     stylesheet modules, then a more specific error code may be more
                     appropriate.</p>
               </note>
            </div3>
            <div3 id="include">
               <head>Stylesheet Inclusion</head>
               <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
                  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="include">
                  <e:in-category name="declaration"/>
                  <e:attribute name="href" required="yes">
                     <e:data-type name="uri"/>
                  </e:attribute>
                  <e:empty/>
                  <e:allowed-parents>
                     <e:parent name="package"/>
                     <e:parent name="stylesheet"/>
                     <e:parent name="transform"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p>A stylesheet module may include another stylesheet module using an
                     <elcode>xsl:include</elcode> declaration.</p>
               <p>The <elcode>xsl:include</elcode> declaration has a <rfc2119>required</rfc2119>
                  <code>href</code> attribute whose value is a URI reference identifying the
                  stylesheet module to be included. This attribute is used as described in <specref
                     ref="locating-modules"/>.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0170"><p>An
                           <elcode>xsl:include</elcode> element <rfc2119>must</rfc2119> be a
                           <termref def="dt-top-level">top-level</termref> element.</p></error>
               </p>
               <p>
                  <termdef id="dt-stylesheet-level" term="stylesheet level">A <term>stylesheet
                        level</term> is a collection of <termref def="dt-stylesheet-module"
                        >stylesheet modules</termref> connected using <elcode>xsl:include</elcode>
                     declarations: specifically, two stylesheet modules <var>A</var> and
                        <var>B</var> are part of the same stylesheet level if one of them includes
                     the other by means of an <elcode>xsl:include</elcode> declaration, or if there
                     is a third stylesheet module <var>C</var> that is in the same stylesheet level
                     as both <var>A</var> and <var>B</var>.</termdef>
               </p>
               <note diff="add" at="T-bug29666">
                  <p>A stylesheet level thus groups the <termref def="dt-declaration"
                        >declarations</termref> in a <termref def="dt-package"/> by <termref
                        def="dt-import-precedence"/>: two declarations within a package are in the
                     same stylesheet level if and only if they have the same import precedence.</p>
               </note>
               <p>
                  <termdef id="dt-declaration-order" term="declaration order">The <termref
                        def="dt-declaration">declarations</termref> within a <termref
                        def="dt-stylesheet-level">stylesheet level</termref> have a total ordering
                     known as <term>declaration order</term>. The order of declarations within a
                     stylesheet level is the same as the document order that would result if each
                     stylesheet module were inserted textually in place of the
                        <elcode>xsl:include</elcode> element that references it.</termdef> In other
                  respects, however, the effect of <elcode>xsl:include</elcode> is not equivalent to
                  the effect that would be obtained by textual inclusion.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0180"><p>It is a <termref
                           def="dt-static-error">static error</termref> if a stylesheet module
                        directly or indirectly includes itself.</p></error>
               </p>
               <note>
                  <p>It is not intrinsically an error for a <termref def="dt-stylesheet"
                        >stylesheet</termref> to include the same module more than once. However,
                     doing so can cause errors because of duplicate definitions. Such multiple
                     inclusions are less obvious when they are indirect. For example, if stylesheet
                        <var>B</var> includes stylesheet <var>A</var>, stylesheet <var>C</var>
                     includes stylesheet <var>A</var>, and stylesheet <var>D</var> includes both
                     stylesheet <var>B</var> and stylesheet <var>C</var>, then <var>A</var> will be
                     included indirectly by <var>D</var> twice. If all of <var>B</var>, <var>C</var>
                     and <var>D</var> are used as independent stylesheets, then the error can be
                     avoided by separating everything in <var>B</var> other than the inclusion of
                        <var>A</var> into a separate stylesheet <var>B'</var> and changing
                        <var>B</var> to contain just inclusions of <var>B'</var> and <var>A</var>,
                     similarly for <var>C</var>, and then changing <var>D</var> to include
                        <var>A</var>, <var>B'</var>, <var>C'</var>.</p>
               </note>
            </div3>
            <div3 id="import">
               <head>Stylesheet Import</head>
               <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
                  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="import">
                  <e:in-category name="declaration"/>
                  <e:attribute name="href" required="yes">
                     <e:data-type name="uri"/>
                  </e:attribute>
                  <e:empty/>
                  <e:allowed-parents>
                     <e:parent name="package"/>
                     <e:parent name="stylesheet"/>
                     <e:parent name="transform"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p>A stylesheet module may import another <termref def="dt-stylesheet-module"
                     >stylesheet module</termref> using an <elcode>xsl:import</elcode>
                  <termref def="dt-declaration">declaration</termref>. Importing a stylesheet module
                  is the same as including it (see <specref ref="include"/>) except that <termref
                     def="dt-template-rule">template rules</termref> and other <termref
                     def="dt-declaration">declarations</termref> in the importing module take
                  precedence over template rules and declarations in the imported module; this is
                  described in more detail below.</p>
               <p>The <elcode>xsl:import</elcode> declaration has a <rfc2119>required</rfc2119>
                  <code>href</code> attribute whose value is a URI reference identifying the
                  stylesheet module to be included. This attribute is used as described in <specref
                     ref="locating-modules"/>.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0190"><p>An
                           <elcode>xsl:import</elcode> element <rfc2119>must</rfc2119> be a <termref
                           def="dt-top-level">top-level</termref> element.</p></error>
               </p>
               <p diff="del" at="M">
                  <error spec="XT" type="static" class="SE" code="0200"><p>The
                           <elcode>xsl:import</elcode> element children <rfc2119>must</rfc2119>
                        precede all other element children of an <elcode>xsl:stylesheet</elcode>
                        element, including any <elcode>xsl:include</elcode> element children and any
                           <termref def="dt-data-element">user-defined data
                     elements</termref>.</p></error>
               </p>
               <example>
                  <head>Using <elcode>xsl:import</elcode>
                  </head>
                  <p>For example,</p>
                  <eg xml:space="preserve" role="xslt-document">&lt;xsl:stylesheet version="3.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:import href="article.xsl"/&gt;
  &lt;xsl:import href="bigfont.xsl"/&gt;
  &lt;xsl:attribute-set name="note-style"&gt;
    &lt;xsl:attribute name="font-style"&gt;italic&lt;/xsl:attribute&gt;
  &lt;/xsl:attribute-set&gt;
&lt;/xsl:stylesheet&gt;</eg>
               </example>
               <p>
                  <termdef id="dt-import-tree" term="import tree">The <termref
                        def="dt-stylesheet-level">stylesheet levels</termref> making up a <termref
                        def="dt-stylesheet">stylesheet</termref> are treated as forming an
                        <term>import tree</term>. In the import tree, each stylesheet level has one
                     child for each <elcode>xsl:import</elcode> declaration that it
                     contains.</termdef> The ordering of the children is the <termref
                     def="dt-declaration-order">declaration order</termref> of the
                     <elcode>xsl:import</elcode> declarations within their stylesheet level.</p>
               <p>
                  <termdef id="dt-import-precedence" term="import precedence">A <termref
                        def="dt-declaration">declaration</termref>
                     <var>D</var> in the stylesheet is defined to have lower <term>import
                        precedence</term> than another declaration <var>E</var> if the stylesheet
                     level containing <var>D</var> would be visited before the stylesheet level
                     containing <var>E</var> in a post-order traversal of the import tree (that is,
                     a traversal of the import tree in which a stylesheet level is visited after its
                     children). Two declarations within the same stylesheet level have the same
                     import precedence.</termdef>
               </p>
               <p>For example, suppose</p>
               <ulist>
                  <item>
                     <p>stylesheet module <var>A</var> imports stylesheet modules <var>B</var> and
                           <var>C</var> in that order;</p>
                  </item>
                  <item>
                     <p>stylesheet module <var>B</var> imports stylesheet module <var>D</var>;</p>
                  </item>
                  <item>
                     <p>stylesheet module <var>C</var> imports stylesheet module <var>E</var>.</p>
                  </item>
               </ulist>
               <p>Then the import tree has the following structure:</p>
               <g:graph xmlns:g="http://www.martin-loetzsch.de/DOTML" rankdir="LR">
                  <g:node label="A" shape="box">
                     <g:node label="B" shape="box">
                        <g:node label="D" shape="box"/>
                     </g:node>
                     <g:node label="C" shape="box">
                        <g:node label="E" shape="box"/>
                     </g:node>
                  </g:node>
               </g:graph>
               <p>The order of import precedence (lowest first) is <var>D</var>, <var>B</var>,
                     <var>E</var>, <var>C</var>, <var>A</var>.</p>
               <p>In general, a <termref def="dt-declaration">declaration</termref> with higher
                  import precedence takes precedence over a declaration with lower import
                  precedence. This is defined in detail for each kind of declaration.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0210"><p>It is a <termref
                           def="dt-static-error">static error</termref> if a stylesheet module
                        directly or indirectly imports itself.</p></error>
               </p>
               <note>
                  <p>The case where a stylesheet module with a particular URI is imported several
                     times is not treated specially. The effect is exactly the same as if several
                     stylesheet modules with different URIs but identical content were imported.
                     This might or might not cause an error, depending on the content of the
                     stylesheet module.</p>
               </note>
            </div3>
         </div2>
         <div2 id="embedded">
            <head>Embedded Stylesheet Modules</head>
            <p>An <termref def="dt-embedded-stylesheet-module">embedded stylesheet module</termref>
               is a <termref def="dt-stylesheet-module">stylesheet module</termref> whose containing
               element is not the outermost element of the containing XML document. Both <termref
                  def="dt-standard-stylesheet-module">standard stylesheet modules</termref> and
                  <termref def="dt-simplified-stylesheet-module">simplified stylesheet
                  modules</termref> may be embedded in this way.</p>
            <p>Two situations where embedded stylesheets may be useful are:</p>
            <ulist>
               <item>
                  <p>The stylesheet may be embedded in the source document to be transformed.</p>
               </item>
               <item>
                  <p>The stylesheet may be embedded in an XML document that describes a sequence of
                     processing of which the XSLT transformation forms just one part.</p>
               </item>
            </ulist>
            <p>The <elcode>xsl:stylesheet</elcode> element <rfc2119>may</rfc2119> have an
                  <code>id</code> attribute to facilitate reference to the stylesheet module within
               the containing document.</p>
            <note>
               <p>In order for such an attribute value to be used as a fragment identifier in a URI,
                  the XDM attribute node must generally have the <code>is-id</code> property: see
                     <xspecref spec="DM30" ref="dm-is-id"/>. This property will typically be set if
                  the attribute is defined in a DTD as being of type <code>ID</code>, or if it is
                  defined in a schema as being of type <code>xs:ID</code>. It is also necessary that
                  the media type of the containing document should support the use of ID values as
                  fragment identifiers. <phrase diff="del" at="F">Such support is widespread in
                     existing products, and is expected to be endorsed in respect of the media type
                        <code>application/xml</code> by a future revision of [RFC 3023]</phrase>
                  <phrase diff="add" at="F">Such support is widespread in existing products, and is
                     endorsed in respect of the media type <code>application/xml</code> by <bibref
                        ref="rfc7303"/></phrase>.</p>
               <p>An alternative, if the implementation supports it, is to use an
                     <code>xml:id</code> attribute. XSLT allows this attribute (like other
                  namespaced attributes) to appear on any <termref def="dt-xslt-element">XSLT
                     element</termref>.</p>
            </note>
            <example>
               <head>The <code>xml-stylesheet</code> Processing Instruction</head>
               <p>The following example shows how the <code>xml-stylesheet</code> processing
                  instruction (see <bibref ref="xml-stylesheet"/>) can be used to allow a source
                  document to contain its own stylesheet. The URI reference uses <phrase diff="del"
                     at="F">a relative URI with</phrase> a fragment identifier to locate the
                     <elcode>xsl:stylesheet</elcode> element:</p>
               <eg xml:space="preserve" role="xml">&lt;?xml-stylesheet type="application/xslt+xml" href="#style1"?&gt;
&lt;!DOCTYPE doc SYSTEM "doc.dtd"&gt;
&lt;doc&gt;
  &lt;head&gt;
    &lt;xsl:stylesheet id="style1"
                    version="3.0"
                    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                    xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;
    &lt;xsl:import href="doc.xsl"/&gt;
    &lt;xsl:template match="id('foo')"&gt;
      &lt;fo:block font-weight="bold"&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="xsl:stylesheet"&gt;
      &lt;!-- ignore --&gt;
    &lt;/xsl:template&gt;
    &lt;/xsl:stylesheet&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;para id="foo"&gt;
    ...
    &lt;/para&gt;
  &lt;/body&gt;
&lt;/doc&gt;
</eg>
            </example>
            <note>
               <p>A stylesheet module that is embedded in the document to which it is to be applied
                  typically needs to contain a <termref def="dt-template-rule">template
                     rule</termref> that specifies that <elcode>xsl:stylesheet</elcode> elements are
                  to be ignored.</p>
            </note>
            <note>
               <p diff="chg" at="C">The above example uses the pseudo-attribute
                     <code>type="application/xslt+xml"</code> in the <code>xml-stylesheet</code>
                  processing instruction to denote an XSLT stylesheet. This is the officially
                  registered media type for XSLT: see <specref ref="xslt-media-type"/>. However,
                  browsers developed before this media type was registered are more likely to accept
                  the unofficial designation <code>type="text/xsl"</code>.</p>
            </note>
            <note>
               <p>Support for the <code>xml-stylesheet</code> processing instruction is not required
                  for conformance with this Recommendation. Implementations are not constrained in
                  the mechanisms they use to identify a stylesheet when a transformation is
                  initiated: see <specref ref="initiating"/>.</p>
            </note>
         </div2>
         <div2 id="preprocessing">
            <head>Stylesheet Preprocessing</head>
            <p diff="add" at="R-bug24619">This specification provides two features that cause the
               raw stylesheet to be preprocessed as the first stage of static processing: elements
               may be conditionally included or excluded by means of an <code>[xsl:]use-when</code>
               attribute as described in <specref ref="conditional-inclusion"/>, and attributes may
               be conditionally computed as described in <specref ref="shadow-attributes"/>.</p>
            <p diff="add" at="R-bug24619">Note that many of the rules affecting the validity of
               stylesheet documents apply to a stylesheet after this preprocessing phase has been
               carried out.</p>
            <div3 id="conditional-inclusion">
               <head>Conditional Element Inclusion</head>
               <p>Any element in the XSLT namespace may have a <code>use-when</code> attribute whose
                  value is an XPath expression that can be evaluated statically. A <termref
                     def="dt-literal-result-element">literal result element</termref>, or any other
                  element within a <termref def="dt-stylesheet-module">stylesheet module</termref>
                  that is not in the XSLT namespace, may similarly carry an
                     <code>xsl:use-when</code> attribute. If the attribute is present and the
                     <xtermref spec="XP30" ref="dt-ebv">effective boolean value</xtermref> of the
                  expression is false, then the element, together with all the nodes having that
                  element as an ancestor, is effectively excluded from the <termref
                     def="dt-stylesheet-module">stylesheet module</termref>. When a node is
                  effectively excluded from a stylesheet module the stylesheet module has the same
                  effect as if the node were not there. Among other things this means that no static
                  or dynamic errors will be reported in respect of the element and its contents,
                  other than errors in the <code>use-when</code> attribute itself.</p>
               <note>
                  <p>This does not apply to XML parsing or validation errors, which will be reported
                     in the usual way. It also does not apply to attributes that are necessarily
                     processed before <code>[xsl:]use-when</code>, examples being
                        <code>xml:space</code> and <code>[xsl:]xpath-default-namespace</code>.</p>
               </note>
               <p>If the <phrase diff="add" at="T-bug29919"><elcode>xsl:package</elcode>,
                     </phrase><elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode>
                  element itself is effectively excluded, the effect is to exclude all the children
                  of the <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element,
                  but not the <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode>
                  element or its attributes.</p>
               <note>
                  <p>This allows all the declarations that depend on the same condition to be
                     included in one stylesheet module, and for their inclusion or exclusion to be
                     controlled by a single <code>use-when</code> attribute at the level of the
                     module.</p>
               </note>
               <p>Conditional element exclusion happens after stripping of whitespace text nodes
                  from the stylesheet, as described in <specref ref="stylesheet-stripping"/>.</p>
               <p diff="chg" at="M">The XPath expression used as the value of the
                     <code>xsl:use-when</code> attribute follows the rules for <termref
                     def="dt-static-expression">static expressions</termref>, <phrase diff="add"
                     at="S-bug28205">including the rules for handling errors.</phrase></p>
               <p>The use of <code>[xsl:]use-when</code> is illustrated in the following
                  examples.</p>
               <example>
                  <head>Using Conditional Exclusion to Achieve Portability</head>
                  <p>This example demonstrates the use of the <code>use-when</code> attribute to
                     achieve portability of a stylesheet across schema-aware and non-schema-aware
                     processors.</p>
                  <eg xml:space="preserve" role="xslt-declarations">&lt;xsl:import-schema schema-location="http://example.com/schema"
              use-when="system-property('xsl:is-schema-aware')='yes'"/&gt;

&lt;xsl:template match="/" 
              use-when="system-property('xsl:is-schema-aware')='yes'" 
              priority="2"&gt;
  &lt;xsl:result-document validation="strict"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;</eg>
                  <p>The effect of these declarations is that a non-schema-aware processor ignores
                     the <elcode>xsl:import-schema</elcode> declaration and the first template rule,
                     and therefore generates no errors in respect of the schema-related constructs
                     in these declarations.</p>
               </example>
               <example>
                  <head>Including Variant Stylesheet Modules</head>
                  <p>This example includes different stylesheet modules depending on which XSLT
                     processor is in use.</p>
                  <eg xml:space="preserve" role="xslt-declarations">&lt;xsl:include href="module-A.xsl" 
     use-when="system-property('xsl:vendor')='vendor-A'"/&gt;
&lt;xsl:include href="module-B.xsl" 
     use-when="system-property('xsl:vendor')='vendor-B'"/&gt;</eg>
               </example>
            </div3>
            <div3 id="shadow-attributes" diff="add" at="R-bug24619">
               <head>Shadow Attributes</head>
               <p diff="chg" at="T-29920">When a no-namespace attribute name <var>N</var> is
                  permitted to appear on an element in the <termref def="dt-xslt-namespace"/>
                  (provided that <var>N</var> does not start with an underscore), then a value
                     <var>V</var> can be supplied for <var>N</var> in one of two ways: </p>
               <ulist diff="chg" at="T-29920">
                  <item>
                     <p>The conventional way is for an attribute node with name <var>N</var> and
                        value <var>V</var> to appear in the XDM representation of the element node
                        in the stylesheet tree. </p>
                  </item>
                  <item>
                     <p>As an alternative, a shadow attribute may be supplied allowing the value
                           <var>V</var> to be statically computed during the preprocessing phase.
                        The shadow attribute has a name that is the same as the name <var>N</var>
                        prefixed with an underscore, and the value of the shadow attribute is a
                           <termref def="dt-value-template"/> in which all expressions enclosed
                        between curly braces must be <termref def="dt-static-expression">static
                           expressions</termref>. The value <var>V</var> is the result of evaluating
                        the value template. If a shadow attribute is present, then any attribute
                        node with name <var>N</var> (sharing the same parent element) is ignored.
                     </p>
                  </item>
               </ulist>
               <p>For example, an <elcode>xsl:include</elcode> element might be written:</p>
               <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:include _href="common{$VERSION}.xsl"/&gt;</eg>
               <p>allowing the stylesheet to include a specific version of a library module based on
                  the value of a <termref def="dt-static-parameter"/>.</p>
               <p>Similarly, a <termref def="dt-mode"/> might be declared like this:</p>
               <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:param name="streamable" as="xs:boolean" 
                  required="yes" static="yes"/&gt;
&lt;xsl:mode _streamable="{$streamable}" on-no-match="shallow-skip"/&gt;</eg>
               <p>this allowing the streamability of the mode to be controlled using a <termref
                     def="dt-static-parameter"/>
                  <phrase diff="add" at="R-bug26308">(Note: this example relies on the fact that the
                        <code>streamable</code> attribute accepts a boolean value, which means that
                     the values <code>true</code> and <code>false</code> are accepted as synonyms of
                        <code>yes</code> and <code>no</code>)</phrase>.</p>
               <p>This mechanism applies to all attributes in the stylesheet where the attribute
                  name is in no namespace and the name of the parent element is in the <termref
                     def="dt-xslt-namespace"/>. This includes attributes that have static
                  significance such as the <code>use-when</code> attribute, the <code>version</code>
                  attribute, and the <code>static</code> attribute on <elcode>xsl:variable</elcode>.
                  The mechanism does not apply to shadow attributes (that is, it is not possible to
                  invoke two stages of preprocessing by using two leading underscores). It does not
                  apply to attributes of literal result elements, nor to attributes in a namespace
                  such as the XML or XSLT namespace, nor to namespace declarations.</p>
               <note>
                  <p>If a shadow attribute and its corresponding target attribute are both present
                     in the stylesheet, the non-shadow attribute is ignored. This may be useful to
                     make stylesheet code compatible across XSLT versions; an XSLT 2.0 processor
                     operating in forwards compatible mode will ignore shadow attributes, and will
                     require the target attribute to be valid.</p>
               </note>
               <note>
                  <p diff="add" at="S-bug28205">The statement that the non-shadow attribute is
                     ignored extends to error detection: it is not an error if the non-shadow
                     attribute has an invalid value. However, this is not reflected in the schema
                     for XSLT stylesheets, so validation using this schema may report errors in such
                     cases.</p>
               </note>
               <note>
                  <p diff="add" at="S-bug29205">An attribute whose name begins with an underscore is
                     treated specially only when it appears on an element in the XSLT namespace. On
                     a <termref def="dt-literal-result-element"/>, it is treated in the same way as
                     any other attribute (that is, its effective value is copied to the result
                     tree). On an <termref def="dt-extension-instruction"/> or <termref
                        def="dt-data-element"/>, as with other attributes on these elements, its
                     meaning is entirely <termref def="dt-implementation-defined"/>.</p>
               </note>
               <example>
                  <head>Using Shadow Attributes to Parameterize XPath Default Namespace</head>
                  <p>Although it is not usually considered good practice, it sometimes happens that
                     variants or versions of an XML vocabulary exist in which the same local names
                     are used, but in different namespaces. There is then a requirement to write
                     code that will process source documents in a variety of different
                     namespaces.</p>
                  <p>It is possible to define a static stylesheet parameter containing the target
                     namespace, for example:</p>
                  <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:param name="NS" as="xs:string" static="yes" 
                          select="'http://example.com/ns/one'"/&gt;</eg>
                  <p>And this can then be used to set the default namespace for XPath
                     expressions:</p>
                  <eg role="non-xml" xml:space="preserve">_xpath-default-namespace="{$NS}"</eg>
                  <p>However, it is not possible to put this shadow attribute on the
                        <elcode>xsl:stylesheet</elcode> or <elcode>xsl:package</elcode> element of
                     the principal stylesheet module, because at that point the variable
                        <code>$NS</code> is not in scope. A workaround is to create a stub
                     stylesheet module which contains nothing but the static parameter declaration
                     and an <elcode>xsl:include</elcode> of the stylesheet module containing the
                     real logic. The static stylesheet parameter will then be in scope on the
                        <elcode>xsl:stylesheet</elcode> element of the included stylesheet module,
                     and the shadow attribute <code>_xpath-default-namespace="{$NS}"</code> can
                     therefore appear on this <elcode>xsl:stylesheet</elcode> element.</p>
               </example>
               <example>
                  <head>Using Shadow Attributes to Parameterize Selection of Elements</head>
                  <p>The following stylesheet produces a report giving information about selected
                     employees. The predicate defining which employees are to be included in the
                     report is supplied (as a string containing an XPath expression) in a static
                     stylesheet parameter:</p>
                  <eg role="xslt-declaration xmlns:local='local'" xml:space="preserve">
&lt;xsl:param name="filter" static="yes"
           as="xs:string" select="'true()'"/&gt;
&lt;xsl:function name="local:filter" as="xs:boolean"&gt;
   &lt;xsl:param name="e" as="element(employee)"/&gt;
   &lt;xsl:sequence _select="$e/({$filter})"/&gt;
&lt;/xsl:function&gt;
&lt;xsl:template match="/"&gt;
   &lt;report&gt;
      &lt;xsl:apply-templates mode="report" select="//employee[local:filter(.)]"/&gt;
   &lt;/report&gt;
&lt;/xsl:template&gt;</eg>
                  <p>If the supplied value of the filter parameter is, say <code>location =
                        "UK"</code>, then the report will cover employees based in the UK.</p>
                  <note>
                     <p>The stylesheet function <code>local:filter</code> is used here in preference
                        to direct use of the supplied predicate within the <code>select</code>
                        attribute of the <elcode>xsl:apply-templates</elcode> instruction because it
                        reduces exposure to code injection attacks. It does not necessarily
                        eliminate all such risks, however. For example, it would be possible for a
                        caller to supply an expression that never terminates, thus creating a
                        denial-of-service risk.</p>
                  </note>
               </example>
            </div3>
         </div2>
         <div2 id="built-in-types">
            <head>Built-in Types</head>
            <p>Every XSLT <phrase diff="chg" at="A">3.0</phrase> processor includes the following
               named type definitions in the <termref def="dt-in-scope-schema-component">in-scope
                  schema components</termref>:</p>
            <ulist>
               <item>
                  <p><phrase diff="del" at="C">All the primitive atomic types defined in <bibref
                           ref="xmlschema-2"/> with the exception of <code>xs:NOTATION</code>. That
                        is: <code>xs:string</code>, <code>xs:boolean</code>,
                        <code>xs:decimal</code>, <code>xs:double</code>, <code>xs:float</code>,
                           <code>xs:date</code>, <code>xs:time</code>, <code>xs:dateTime</code>,
                           <code>xs:duration</code>, <code>xs:QName</code>, <code>xs:anyURI</code>,
                           <code>xs:gDay</code>, <code>xs:gMonthDay</code>, <code>xs:gMonth</code>,
                           <code>xs:gYearMonth</code>, <code>xs:gYear</code>,
                           <code>xs:base64Binary</code>, and <code>xs:hexBinary</code>.</phrase>
                     <phrase diff="add" at="F">All built-in types defined in <bibref
                           ref="xmlschema-2"/>, including <code>xs:anyType</code> and
                           <code>xs:anySimpleType</code>.</phrase></p>
               </item>
               <item>
                  <p>The following types defined in <bibref ref="xpath-30"/>:
                        <code>xs:yearMonthDuration</code>, <code>xs:dayTimeDuration</code>,
                        <code>xs:anyAtomicType</code>, <code>xs:untyped</code>, and
                        <code>xs:untypedAtomic</code>.</p>
               </item>
            </ulist>
            <p diff="add" at="I">XSLT 3.0 processors <rfc2119>may</rfc2119> optionally include types
               defined in XSD 1.1 (see <bibref ref="xmlschema11-1"/>). XSD 1.1 adopts the types
                  <code>xs:yearMonthDuration</code>, <code>xs:dayTimeDuration</code>, and
                  <code>xs:anyAtomicType</code> previously defined in XPath 2.0, and adds one new
               type: <code>xs:dateTimeStamp</code>. XSD 1.1 also allows implementers to define
               additional primitive types, and XSLT 3.0 permits such types to be supported by an
               XSLT processor.</p>
            <p>A <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT processor</termref>
               additionally supports:</p>
            <ulist>
               <item diff="del" at="C">
                  <p>All other built-in types defined in <bibref ref="xmlschema-2"/>
                  </p>
               </item>
               <item>
                  <p>User-defined types, and element and attribute declarations, that are imported
                     using an <elcode>xsl:import-schema</elcode> declaration as described in
                        <specref ref="import-schema"/>. These may include both simple and complex
                     types.</p>
               </item>
            </ulist>
            <note>
               <p>The names that are imported from the XML Schema namespace do not include all the
                  names of top-level types defined in either the Schema for Schema Documents or the
                  Schema for Schema Documents (Datatypes). The Schema for Schema Documents, as well
                  as defining built-in types such as <code>xs:integer</code> and
                     <code>xs:double</code>, also defines types that are intended for use only
                  within that schema, such as <code>xs:derivationControl</code>. A <termref
                     def="dt-stylesheet">stylesheet</termref> that is designed to process XML Schema
                  documents as its input or output may import the Schema for Schema Documents.</p>
            </note>
            <p>An implementation may define mechanisms that allow additional <termref
                  def="dt-schema-component">schema components</termref> to be added to the <termref
                  def="dt-in-scope-schema-component">in-scope schema components</termref> for the
               stylesheet. For example, the mechanisms used to define <termref
                  def="dt-extension-function">extension functions</termref> (see <specref
                  ref="extension-functions"/>) may also be used to import the types used in the
               interface to such functions.</p>
            <imp-def-feature id="idf-ext-importtypes">An implementation may define mechanisms, above
               and beyond <elcode>xsl:import-schema</elcode>, that allow <termref
                  def="dt-schema-component">schema components</termref> such as type definitions to
               be made available within a stylesheet.</imp-def-feature>
            <p>These <termref def="dt-schema-component">schema components</termref> are the only
               ones that may be referenced in XPath expressions within the stylesheet, or in the
                  <code>[xsl:]type</code> and <code>as</code> attributes of those elements that
               permit these attributes.</p>
            <p diff="del" at="C">For a Basic XSLT Processor, schema built-in types that are not
               included in the static context (for example, <code>xs:NCName</code>) are “unknown
               types” in the sense of <xspecref spec="XP30" ref="id-sequencetype-matching"/>. In the
               language of that section, a Basic XSLT Processor <rfc2119>must</rfc2119> be able to
               determine whether these unknown types are derived from known schema types such as
                  <code>xs:string</code>. The purpose of this rule is to ensure that system
               functions such as <xfunction>local-name-from-QName</xfunction>, which is defined to
               return an <code>xs:NCName</code>, behave correctly. A stylesheet that uses a Basic
               XSLT Processor will not be able to test whether the returned value is an
                  <code>xs:NCName</code>, but it will be able to use it as if it were an
                  <code>xs:string</code>. </p>
         </div2>
         <div2 id="import-schema">
            <head>Importing Schema Components</head>
            <note>
               <p>The facilities described in this section are not available with a <termref
                     def="dt-basic-xslt-processor">basic XSLT processor</termref>. They require a
                     <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT
                     processor</termref>, as described in <specref ref="conformance"/>.</p>
            </note>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="import-schema">
               <e:in-category name="declaration"/>
               <e:attribute name="namespace">
                  <e:data-type name="uri"/>
               </e:attribute>
               <e:attribute name="schema-location">
                  <e:data-type name="uri"/>
               </e:attribute>
               <e:element repeat="zero-or-one" name="xs:schema"/>
               <e:allowed-parents>
                  <e:parent name="package"/>
                  <e:parent name="stylesheet"/>
                  <e:parent name="transform"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:import-schema</elcode> declaration is used to identify <termref
                  def="dt-schema-component">schema components</termref> (that is, top-level type
               definitions and top-level element and attribute declarations) that need to be
               available statically, that is, before any source document is available. Names of such
               components used statically within the <termref def="dt-stylesheet"
                  >stylesheet</termref> must refer to an <termref def="dt-in-scope-schema-component"
                  >in-scope schema component</termref>, which means they must either be built-in
               types as defined in <specref ref="built-in-types"/>, or they must be imported using
               an <elcode>xsl:import-schema</elcode> declaration.</p>
            <p>The <elcode>xsl:import-schema</elcode> declaration identifies a namespace containing
               the names of the components to be imported (or indicates that components whose names
               are in no namespace are to be imported). The effect is that the names of top-level
               element and attribute declarations and type definitions from this namespace (or
               non-namespace) become available for use within XPath expressions in the <phrase
                  diff="chg" at="I"><termref def="dt-package">package</termref></phrase>, and within
               other stylesheet constructs such as the <code>type</code> and <code>as</code>
               attributes of various <termref def="dt-xslt-element">XSLT elements</termref>.</p>
            <p diff="chg" at="I">The same schema components are available in all stylesheet modules
                  <phrase diff="chg" at="I">within the <termref def="dt-declaring-package">declaring
                     package</termref></phrase>; importing components in one stylesheet module makes
               them available throughout the <termref def="dt-package">package</termref>.</p>
            <p diff="add" at="I">The schema components imported into different <termref
                  def="dt-package">packages</termref> within a <termref def="dt-stylesheet"
                  >stylesheet</termref> must be consistent. Specifically, it is not permitted to use
               the same name in the same XSD symbol space to refer to different schema components
               within different packages; and the union of the schema components imported into the
               packages of a stylesheet must constitute a valid schema (as well as the set of schema
               components imported into each package forming a valid schema in its own right).</p>
            <p>The <code>namespace</code> and <code>schema-location</code> attributes are both
               optional.</p>
            <p>If the <elcode>xsl:import-schema</elcode> element contains an <code>xs:schema</code>
               element, then the <code>schema-location</code> attribute <rfc2119>must</rfc2119> be
               absent, and one of the following <rfc2119>must</rfc2119> be true:</p>
            <ulist>
               <item>
                  <p>the <code>namespace</code> attribute of the <elcode>xsl:import-schema</elcode>
                     element and the <code>targetNamespace</code> attribute of the
                        <code>xs:schema</code> element are both absent (indicating a no-namespace
                     schema), or</p>
               </item>
               <item>
                  <p>the <code>namespace</code> attribute of the <elcode>xsl:import-schema</elcode>
                     element and the <code>targetNamespace</code> attribute of the
                        <code>xs:schema</code> element are both present and both have the same
                     value, or</p>
               </item>
               <item>
                  <p>the <code>namespace</code> attribute of the <elcode>xsl:import-schema</elcode>
                     element is absent and the <code>targetNamespace</code> attribute of the
                        <code>xs:schema</code> element is present, in which case the target
                     namespace is as given on the <code>xs:schema</code> element.</p>
               </item>
            </ulist>
            <p>
               <error spec="XT" type="static" class="SE" code="0215"><p>It is a <termref
                        def="dt-static-error">static error</termref> if an
                        <elcode>xsl:import-schema</elcode> element that contains an
                        <code>xs:schema</code> element has a <code>schema-location</code> attribute,
                     or if it has a <code>namespace</code> attribute that conflicts with the target
                     namespace of the contained schema.</p></error>
            </p>
            <p>If two <elcode>xsl:import-schema</elcode> declarations specify the same namespace, or
               if both specify no namespace, then only the one with highest <termref
                  def="dt-import-precedence">import precedence</termref> is used. If this leaves
               more than one, then all the declarations at the highest import precedence are used
               (which may cause conflicts, as described below).</p>
            <p>After discarding any <elcode>xsl:import-schema</elcode> declarations under the above
               rule, the effect of the remaining <elcode>xsl:import-schema</elcode> declarations is
               defined in terms of a hypothetical document called the synthetic schema document,
               which is constructed as follows. The synthetic schema document defines an arbitrary
               target namespace that is different from any namespace actually used by the
               application, and it contains <code>xs:import</code> elements corresponding
               one-for-one with the <elcode>xsl:import-schema</elcode> declarations in the <termref
                  def="dt-stylesheet">stylesheet</termref>, with the following correspondence:</p>
            <ulist>
               <item>
                  <p>The <code>namespace</code> attribute of the <code>xs:import</code> element is
                     copied from the <code>namespace</code> attribute of the
                        <elcode>xsl:import-schema</elcode> declaration if it is explicitly present,
                     or is implied by the <code>targetNamespace</code> attribute of a contained
                        <code>xs:schema</code> element, and is absent if it is absent.</p>
               </item>
               <item>
                  <p>The <code>schemaLocation</code> attribute of the <code>xs:import</code> element
                     is copied from the <code>schema-location</code> attribute of the
                        <elcode>xsl:import-schema</elcode> declaration if present, and is absent if
                     it is absent. If there is a contained <code>xs:schema</code> element, the
                     effective value of the <code>schemaLocation</code> attribute is a URI
                     referencing a document containing a copy of the <code>xs:schema</code>
                     element.</p>
               </item>
               <item>
                  <p>The base URI of the <code>xs:import</code> element is the same as the base URI
                     of the <elcode>xsl:import-schema</elcode> declaration.</p>
               </item>
            </ulist>
            <p>The schema components included in the <termref def="dt-in-scope-schema-component"
                  >in-scope schema components</termref> (that is, the components whose names are
               available for use within the stylesheet) are the top-level element and attribute
               declarations and type definitions that are available for reference within the
               synthetic schema document. See <bibref ref="xmlschema-1"/> (section 4.2.3,
                  <emph>References to schema components across namespaces</emph>).</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0220"><p>It is a <termref
                        def="dt-static-error">static error</termref> if the synthetic schema
                     document does not satisfy the constraints described in <bibref
                        ref="xmlschema-1"/> (section 5.1, <emph>Errors in Schema Construction and
                        Structure</emph>). This includes, without loss of generality, conflicts such
                     as multiple definitions of the same name.</p></error>
            </p>
            <note>
               <p>The synthetic schema document does not need to be constructed by a real
                  implementation. It is purely a mechanism for defining the semantics of
                     <elcode>xsl:import-schema</elcode> in terms of rules that already exist within
                  the XML Schema specification. In particular, it implicitly defines the rules that
                  determine whether the set of <elcode>xsl:import-schema</elcode> declarations are
                  mutually consistent.</p>
               <p>These rules do not cause names to be imported transitively. The fact that a name
                  is available for reference within a schema document A does not of itself make the
                  name available for reference in a stylesheet that imports the target namespace of
                  schema document A. (See <bibref ref="xmlschema-1"/> section 3.15.3, Constraints on
                  XML Representations of Schemas.) The stylesheet must import all the namespaces
                  containing names that it actually references.</p>
               <p>The <code>namespace</code> attribute indicates that a schema for the given
                  namespace is required by the <termref def="dt-stylesheet">stylesheet</termref>.
                  This information may be enough on its own to enable an implementation to locate
                  the required schema components. The <code>namespace</code> attribute may be
                  omitted to indicate that a schema for names in no namespace is being imported. The
                  zero-length string is not a valid namespace URI, and is therefore not a valid
                  value for the <code>namespace</code> attribute.</p>
               <p>The <code>schema-location</code> attribute is a <termref def="dt-uri-reference"
                     >URI Reference</termref> that gives a hint indicating where a schema document
                  or other resource containing the required definitions may be found. It is likely
                  that a <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT
                     processor</termref> will be able to process a schema document found at this
                  location.</p>
               <p>The XML Schema specification gives implementations flexibility in how to handle
                  multiple imports for the same namespace. Multiple imports do not cause errors if
                  the definitions do not conflict.</p>
               <p>A consequence of these rules is that it is not intrinsically an error if no schema
                  document can be located for a namespace identified in an
                     <elcode>xsl:import-schema</elcode> declaration. This will cause an error only
                  if it results in the stylesheet containing references to names that have not been
                  imported.</p>
               <p>An inline schema document (using an <code>xs:schema</code> element as a child of
                  the <code>xsl:import-schema</code> element) has the same status as an external
                  schema document, in the sense that it acts as a hint for a source of schema
                  components in the relevant namespace. To ensure that the inline schema document is
                  always used, it is advisable to use a target namespace that is unique to this
                  schema document.</p>
            </note>
            <p>The use of a namespace in an <elcode>xsl:import-schema</elcode> declaration does not
               by itself associate any namespace prefix with the namespace. If names from the
               namespace are used within the stylesheet module then a namespace declaration must be
               included in the stylesheet module, in the usual way.</p>
            <example>
               <head>An Inline Schema Document</head>
               <p>The following example shows an inline schema document. This declares a simple type
                     <code>local:yes-no</code>, which the stylesheet then uses in the declaration of
                  a variable.</p>
               <p>The example assumes the namespace declaration
                     <code>xmlns:local="http://example.com/ns/yes-no"</code>
               </p>
               <eg xml:space="preserve" role="xslt-declarations">&lt;xsl:import-schema&gt;
  &lt;xs:schema targetNamespace="http://example.com/ns/yes-no"
             xmlns:xs="http://www.w3.org/2001/XMLSchema"
             xmlns:local="http://example.com/ns/yes-no"&gt;
    &lt;xs:simpleType name="yes-no"&gt;
      &lt;xs:restriction base="xs:string"&gt;
        &lt;xs:enumeration value="yes"/&gt;
        &lt;xs:enumeration value="no"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:schema&gt;
&lt;/xsl:import-schema&gt;

&lt;xsl:variable name="condition" select="local:yes-no('yes')" 
                               as="local:yes-no"/&gt;
</eg>
            </example>
            <p diff="add" at="S-bug28174">There are two built-in functions
                  (<xfunction>analyze-string</xfunction> and <function>json-to-xml</function>) whose
               result is an XML structure for which a schema is defined. The namespace for these
               schema definitions is (in both cases)
                  <code>http://www.w3.org/2005/xpath-functions</code>. Schema components for these
               namespaces are available for reference within the stylesheet if and only if an
                  <elcode>xsl:import-schema</elcode> declaration is present referencing this
               namespace. If such a declaration is present, then the schema that is imported is the
               schema defined in the specification of these functions: the
                  <code>schemaLocation</code> attribute has no effect.</p>
         </div2>
      </div1>
      <div1 id="data-model">
         <head>Data Model</head>
         <p>The data model used by XSLT is the <phrase diff="chg" at="F">XPath 3.0 and XQuery
               3.0</phrase> data model (XDM), as defined in <bibref ref="xpath-datamodel-30"/>. XSLT
            operates on source, result and stylesheet documents using the same data model.</p>
         <p>This section elaborates on some particular features of XDM as it is used by XSLT:</p>
         <p>The rules in <specref ref="stylesheet-stripping"/> and <specref ref="strip"/> make use
            of the concept of a whitespace text node.</p>
         <p>
            <termdef id="dt-whitespace-text-node" term="whitespace text node">A <term>whitespace
                  text node</term> is a text node whose content consists entirely of whitespace
               characters (that is, #x09, #x0A, #x0D, or #x20).</termdef>
         </p>
         <note>
            <p>Features of a source XML document that are not represented in the XDM tree will have
               no effect on the operation of an XSLT stylesheet. Examples of such features are
               entity references, CDATA sections, character references, whitespace within element
               tags, and the choice of single or double quotes around attribute values.</p>
         </note>
         <div2 id="xml-versions">
            <head>XML Versions</head>
            <p>The XDM data model defined in <bibref ref="xpath-datamodel-30"/> is capable of
               representing either an XML 1.0 document (conforming to <bibref ref="REC-xml"/> and
                  <bibref ref="xml-names"/>) or an XML 1.1 document (conforming to <bibref
                  ref="xml11"/> and <bibref ref="xml-names11"/>), and it makes no distinction
               between the two. In principle, therefore, XSLT <phrase diff="chg" at="A">3.0</phrase>
               can be used with either of these XML versions.</p>
            <p>Construction of the XDM tree is outside the scope of this specification, so XSLT
                  <phrase diff="chg" at="A">3.0</phrase> places no formal requirements on an XSLT
               processor to accept input from either XML 1.0 documents or XML 1.1 documents or both.
               This specification does define a serialization capability (see <specref
                  ref="serialization"/>), though from a conformance point of view it is an optional
               feature. Although facilities are described for serializing the XDM tree as either XML
               1.0 or XML 1.1 (and controlling the choice), there is again no formal requirement on
               an XSLT processor to support either or both of these XML versions as serialization
               targets.</p>
            <p>Because the XDM tree is the same whether the original document was XML 1.0 or XML
               1.1, the semantics of XSLT processing do not depend on the version of XML used by the
               original document. There is no reason in principle why all the input and output
               documents used in a single transformation must conform to the same version of
               XML.</p>
            <p>Some of the syntactic constructs in XSLT <phrase diff="chg" at="A">3.0</phrase> and
                  <phrase diff="chg" at="F">XPath 3.0</phrase>, for example the productions <xnt
                  xmlns:xlink="http://www.w3.org/1999/xlink" spec="XML" ref="Char"
                  xlink:type="simple">Char</xnt> and <xnt xmlns:xlink="http://www.w3.org/1999/xlink"
                  spec="Names" ref="NT-NCName" xlink:type="simple">NCName</xnt>, are defined by
               reference to the XML and XML Namespaces specifications. There are slight variations
               between the XML 1.0 and XML 1.1 versions of these productions <phrase diff="add"
                  at="D">(and, indeed, between different editions of XML 1.0)</phrase>.
               Implementations <rfc2119>may</rfc2119> support <phrase diff="chg" at="D">any</phrase>
               version; it is <rfc2119>recommended</rfc2119> that an XSLT <phrase diff="chg" at="A"
                  >3.0</phrase> processor that implements the 1.1 versions <rfc2119>should</rfc2119>
               also provide a mode that supports the 1.0 versions. It is thus <termref
                  def="dt-implementation-defined">implementation-defined</termref> which versions
               and editions of XML and XML Namespaces are supported by the implementation.</p>
            <note>
               <p>The specification referenced as <bibref ref="xml-names"/> was actually published
                  without a version number.</p>
            </note>
            <imp-def-feature id="idf-spec-xml">It is implementation-defined which versions and
               editions of XML and XML Namespaces (1.0 and/or 1.1) are supported.</imp-def-feature>
            <p><phrase diff="chg" at="R-bug25701">The current version of <bibref ref="xmlschema11-2"
                  /> references the XML 1.1 specifications, but the previous version (<bibref
                     ref="xmlschema-2"/>) (that is, XSD 1.0) remains in widespread use, and only
                  references XML 1.0.</phrase> With processors lacking support for XSD 1.1,
               therefore, datatypes such as <code>xs:NCName</code> and <code>xs:ID</code> may be
               constrained by the XML 1.0 rules, and not allow the full range of values permitted by
               XML 1.1. It is <rfc2119>recommended</rfc2119> that implementers wishing to support
               XML 1.1 should consult <bibref ref="SCHEMA-AND-XML-1.1"/> for guidance.</p>
         </div2>
         <div2 id="xdm-versions" diff="add" at="S-bug24266">
            <head>XDM versions</head>
            <p>XSLT 3.0 <rfc2119>requires</rfc2119> a processor to support XDM 3.0 as defined in
                  <bibref ref="xpath-datamodel-30"/>, augmented with support for maps as described
               in <specref ref="map"/>.</p>
            <p>A processor <rfc2119>may</rfc2119> also provide a user option to support XDM 3.1 as
               defined in <bibref ref="xpath-datamodel-31"/>, in which case it must do so as defined
               in <specref ref="xpath31-feature"/>.</p>
            <note>
               <p>The essential differences between XDM 3.0 (with the extensions defined in this
                  specification) and XDM 3.1 are that XDM 3.1 adds support for arrays, and for the
                     <code>xs:numeric</code> union type.</p>
            </note>
            <p>A processor <rfc2119>may</rfc2119> also provide a user option to support versions of
               XDM later than 3.1, in which case the way it does so is <termref
                  def="dt-implementation-defined"/>.</p>
         </div2>
         <div2 id="stylesheet-stripping">
            <head>Stripping Whitespace from the Stylesheet</head>
            <p>The tree representing the stylesheet is preprocessed as follows:</p>
            <olist>
               <item>
                  <p>All comments and processing instructions are removed.</p>
               </item>
               <item>
                  <p>Any text nodes that are now adjacent to each other are merged.</p>
               </item>
               <item>
                  <p>Any <termref def="dt-whitespace-text-node">whitespace text node</termref> that
                     satisfies both the following conditions is removed from the tree:</p>
                  <ulist>
                     <item>
                        <p>The parent of the text node is not an <elcode>xsl:text</elcode>
                           element</p>
                     </item>
                     <item>
                        <p>The text node does not have an ancestor element that has an
                              <code>xml:space</code> attribute with a value of
                           <code>preserve</code>, unless there is a closer ancestor element having
                           an <code>xml:space</code> attribute with a value of
                           <code>default</code>.</p>
                     </item>
                  </ulist>
               </item>
               <item>
                  <p>Any <termref def="dt-whitespace-text-node">whitespace text node</termref> whose
                     parent is one of the following elements is removed from the tree, regardless of
                     any <code>xml:space</code> attributes:</p>
                  <slist>
                     <sitem>
                        <phrase diff="add" at="L">
                           <elcode>xsl:accumulator</elcode>
                        </phrase>
                     </sitem>
                     <sitem>
                        <elcode>xsl:analyze-string</elcode>
                     </sitem>
                     <sitem>
                        <elcode>xsl:apply-imports</elcode>
                     </sitem>
                     <sitem>
                        <elcode>xsl:apply-templates</elcode>
                     </sitem>
                     <sitem>
                        <elcode>xsl:attribute-set</elcode>
                     </sitem>
                     <sitem>
                        <elcode>xsl:call-template</elcode>
                     </sitem>
                     <sitem>
                        <elcode>xsl:character-map</elcode>
                     </sitem>
                     <sitem>
                        <elcode>xsl:choose</elcode>
                     </sitem>
                     <sitem>
                        <phrase diff="add" at="B">
                           <elcode>xsl:evaluate</elcode>
                        </phrase>
                     </sitem>
                     <sitem>
                        <phrase diff="add" at="O">
                           <elcode>xsl:fork</elcode>
                        </phrase>
                     </sitem>
                     <sitem>
                        <phrase diff="add" at="D">
                           <elcode>xsl:merge</elcode>
                        </phrase>
                     </sitem>
                     <sitem>
                        <phrase diff="add" at="D">
                           <elcode>xsl:merge-source</elcode>
                        </phrase>
                     </sitem>
                     <sitem>
                        <phrase diff="add" at="O">
                           <elcode>xsl:mode</elcode>
                        </phrase>
                     </sitem>
                     <sitem>
                        <phrase diff="add" at="D">
                           <elcode>xsl:next-iteration</elcode>
                        </phrase>
                     </sitem>
                     <sitem>
                        <elcode>xsl:next-match</elcode>
                     </sitem>
                     <sitem>
                        <phrase diff="add" at="O">
                           <elcode>xsl:override</elcode>
                        </phrase>
                     </sitem>
                     <sitem>
                        <phrase diff="add" at="O">
                           <elcode>xsl:package</elcode>
                        </phrase>
                     </sitem>
                     <sitem>
                        <elcode>xsl:stylesheet</elcode>
                     </sitem>
                     <sitem>
                        <elcode>xsl:transform</elcode>
                     </sitem>
                     <sitem>
                        <phrase diff="add" at="O">
                           <elcode>xsl:use-package</elcode>
                        </phrase>
                     </sitem>
                  </slist>
               </item>
               <item>
                  <p>Any <termref def="dt-whitespace-text-node">whitespace text node</termref> whose
                     immediate following-sibling node is an <elcode>xsl:param</elcode> or
                        <elcode>xsl:sort</elcode>
                     <phrase diff="add" at="R-bug24179">or <elcode>xsl:context-item</elcode> or
                           <elcode>xsl:on-completion</elcode></phrase> element is removed from the
                     tree, regardless of any <code>xml:space</code> attributes.</p>
               </item>
               <item>
                  <p diff="add" at="B">Any <termref def="dt-whitespace-text-node">whitespace text
                        node</termref> whose immediate preceding-sibling node is an
                        <elcode>xsl:catch</elcode>
                     <phrase diff="del" at="R-bug24179">or
                        <elcode>xsl:on-completion</elcode></phrase> element is removed from the
                     tree, regardless of any <code>xml:space</code> attributes.</p>
               </item>
            </olist>
            <p>
               <error spec="XT" type="static" class="SE" code="0260"><p>Within an <termref
                        def="dt-xslt-element">XSLT element</termref> that is
                        <rfc2119>required</rfc2119> to be empty, any content other than comments or
                     processing instructions, including any <termref def="dt-whitespace-text-node"
                        >whitespace text node</termref> preserved using the
                        <code>xml:space="preserve"</code> attribute, is a <termref
                        def="dt-static-error">static error</termref>.</p></error>
            </p>
            <note>
               <p>Using <code>xml:space="preserve"</code> in parts of the stylesheet that contain
                     <termref def="dt-sequence-constructor">sequence constructors</termref> will
                  cause <phrase diff="chg" at="M">whitespace text nodes in that part of the
                     stylesheet to be copied to the result of the sequence constructor</phrase>.
                  When the result of the sequence constructor is used to form the content of an
                  element, this can cause errors if such text nodes are followed by attribute nodes
                  generated using <elcode>xsl:attribute</elcode>.</p>
            </note>
            <note>
               <p>If an <code>xml:space</code> attribute is specified on a <termref
                     def="dt-literal-result-element">literal result element</termref>, it will be
                  copied to the result tree in the same way as any other attribute.</p>
            </note>
         </div2>
         <div2 id="preprocessing-source-docs">
            <head>Preprocessing Source Documents</head>
            <p diff="chg" at="T-bug29692">Source documents supplied as input to a transformation may
               be subject to preprocessing. Two kinds of preprocessing are defined: stripping of
               type annotations (see <specref ref="stripping-annotations"/>), and stripping of
               whitespace text nodes (see <specref ref="strip"/>). </p>
            <p diff="chg" at="T-bug29692">Stripping of type annotations happens before stripping of
               whitespace text nodes. </p>
            <p diff="chg" at="T-bug29692">The source documents to which this applies are as follows: </p>
            <ulist diff="chg" at="T-bug29692">
               <item>
                  <p>The document containing the <termref def="dt-global-context-item"/> if it is a
                     node;</p>
               </item>
               <item>
                  <p>Any documents containing a node present in the <termref
                        def="dt-initial-match-selection"/>;</p>
               </item>
               <item>
                  <p>Any document containing a node that is returned by the functions
                        <function>document</function>, <xfunction>doc</xfunction>, or
                        <xfunction>collection</xfunction>;</p>
               </item>
               <item>
                  <p>Any document read using <code>xsl:source-document</code>.</p>
               </item>
            </ulist>
            <note diff="chg" at="T-bug29692">
               <p>This list excludes documents passed as the values of <termref
                     def="dt-stylesheet-parameter">stylesheet parameters</termref> or parameters of
                  the <termref def="dt-initial-named-template"/> or <termref
                     def="dt-initial-function"/>, trees created by functions such as
                     <xfunction>parse-xml</xfunction>, <code>parse-xml-fragment</code>,
                     <xfunction>analyze-string</xfunction>, or <function>json-to-xml</function>, nor
                  values returned from <termref def="dt-extension-function">extension
                     functions</termref>. </p>
            </note>
            <p diff="chg" at="T-bug29692">If a node other than a document node is supplied (for
               example as the global context item), then the preprocessing is applied to the entire
               document containing that node. If several nodes within the same document are supplied
               (for example as nodes in the initial match selection, or as nodes returned by the
                  <xfunction>collection</xfunction> function), then the preprocessing is only
               applied to that document once. If a whitespace text node is supplied (for example as
               the global context item) and the rules cause this node to be stripped from its
               containing tree, then the behavior is as if this node had not been supplied (which
               may cause an error, for example if a global context item is required.) </p>
            <p diff="chg" at="T-bug29692">The rules determining whether or not stripping of
               annotations and/or whitespace happens are defined at the level of a <termref
                  def="dt-package"/>. Declarations within a <termref def="dt-library-package"/> only
               affect the handling of documents loaded using a call on the
                  <function>document</function>, <xfunction>doc</xfunction>, or
                  <xfunction>collection</xfunction> functions or an evaluation of an
                  <elcode>xsl:source-document</elcode> instruction appearing lexically within the
               same package. Declarations within the <termref def="dt-top-level-package"/> also
               affect the processing of the <termref def="dt-global-context-item"/> and the <termref
                  def="dt-initial-match-selection"/>. </p>
            <p diff="chg" at="T-bug29692">The semantics of the <function>document</function>,
                  <xfunction>doc</xfunction>, and <xfunction>collection</xfunction> functions are
               formally defined in terms of mappings from URIs to document nodes maintained within
               the dynamic context (see <specref ref="xpath-dynamic-context"/>). The effect of the
               declarations that control stripping of type annotations and whitespace is therefore
               to modify this mapping (so it now maps the URI to a stripped document). The
               modification applies to the dynamic context for calls to these function appearing
               within a particular package; each package therefore has a different set of mappings.
               This means that when two calls to the <xfunction>doc</xfunction> function appear in
               different packages, specifying the same absolute URI, then in general different
               documents are returned. An implementation <rfc2119>may</rfc2119> return the same
               document for two such calls if it is able to determine that the effect of the
               annotation and whitespace stripping rules in both packages is the same. </p>
            <p diff="chg" at="T-bug29692">The effect of dynamic calls to the
                  <function>document</function>, <xfunction>doc</xfunction>, and
                  <xfunction>collection</xfunction> functions is defined in the same way as for
               other functions with dependencies on the dynamic context. As described in <specref
                  ref="additional-dynamic-context"/>, named function references (such as
                  <code>doc#1</code>) and calls on <xfunction>function-lookup</xfunction> (for
               example, <code>function-lookup("doc", 1)</code>) are defined to retain the XPath
               static and dynamic context at the point of invocation as part of the closure of the
               resulting function item, and to use this preserved context when a dynamic function
               call is subsequently made using the function item. </p>
            <div3 id="stripping-annotations">
               <head>Stripping Type Annotations from a Source Tree</head>
               <p>
                  <termdef id="dt-type-annotation" term="type annotation">The term <term>type
                        annotation</term> is used in this specification to refer to the value
                     returned by the <code>dm:type-name</code> accessor of a node: see <xspecref
                        spec="DM30" ref="dm-type-name"/>.</termdef>
               </p>
               <p>There is sometimes a requirement to write stylesheets that produce the same
                  results whether or not the source documents have been validated against a schema.
                  To achieve this, an option is provided to remove any <termref
                     def="dt-type-annotation">type annotations</termref> on element and attribute
                  nodes in a <termref def="dt-source-tree">source tree</termref>, replacing them
                  with an annotation of <code>xs:untyped</code> in the case of element nodes, and
                     <code>xs:untypedAtomic</code> in the case of attribute nodes.</p>
               <p>Such stripping of <termref def="dt-type-annotation">type annotations</termref> can
                  be requested by specifying <code>input-type-annotations="strip"</code> on the
                     <phrase diff="chg" at="P-bug22733"><elcode>xsl:package</elcode></phrase>
                  element. This attribute has three permitted values: <code>strip</code>,
                     <code>preserve</code>, and <code>unspecified</code>. The default value is
                     <code>unspecified</code>. <phrase diff="del" at="P-bug22733">Stripping of type
                     annotations takes place if at least one <termref def="dt-stylesheet-module"
                        >stylesheet module</termref> in the <termref def="dt-stylesheet"
                        >stylesheet</termref> specifies
                     <code>input-type-annotations="strip"</code>.</phrase></p>
               <p diff="add" at="P-bug22733">The <code>input-type-annotations</code> attribute may
                  also be specified on the <elcode>xsl:stylesheet</elcode> element; if it is
                  specified at this level then it must be consistent for all stylesheet modules
                  within the same package.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0265"><p> It is a <termref
                           def="dt-static-error">static error</termref> if there is a <termref
                           def="dt-stylesheet-module">stylesheet module</termref> in a <termref
                           def="dt-package">package</termref> that specifies
                           <code>input-type-annotations="strip"</code> and another <termref
                           def="dt-stylesheet-module">stylesheet module</termref> that specifies
                           <code>input-type-annotations="preserve"</code>, <phrase diff="add"
                           at="P-bug22733">or if a stylesheet module specifies the value
                              <code>strip</code> or <code>preserve</code> and the same value is not
                           specified on the <elcode>xsl:package</elcode> element of the containing
                           package.</phrase></p></error>
               </p>
               <p diff="del" at="T-bug29692">The <termref def="dt-source-tree">source
                     trees</termref> to which this applies are the same as those affected by
                     <elcode>xsl:strip-space</elcode> and <elcode>xsl:preserve-space</elcode>: see
                     <specref ref="strip"/>. (However, the attribute applies to documents read using
                     <elcode>xsl:source-document</elcode> only in the absence of a
                     <code>validation</code> or <code>type</code> attribute on that instruction.)
                     <phrase diff="add" at="P-bug22663">As with whitespace stripping, the rules for
                     stripping of <termref def="dt-type-annotation">type annotations</termref> may
                     vary from one package to another, and have the effect of modifying the mapping
                     from URIs to document nodes defined in the XPath dynamic context; this means
                     that two calls to the <xfunction>doc</xfunction> function (for example)
                     supplying the same URI may produce different document nodes if the calls appear
                     in different packages.</phrase></p>
               <p>When type annotations are stripped, the following changes are made to the source
                  tree:</p>
               <ulist>
                  <item>
                     <p>The type annotation of every element node is changed to
                           <code>xs:untyped</code>
                     </p>
                  </item>
                  <item>
                     <p>The type annotation of every attribute node is changed to
                           <code>xs:untypedAtomic</code>
                     </p>
                  </item>
                  <item>
                     <p>The typed value of every element and attribute node is set to be the same as
                        its string value, as an instance of <code>xs:untypedAtomic</code>.</p>
                  </item>
                  <item>
                     <p>The <code>is-nilled</code> property of every element node is set to
                           <code>false</code>.</p>
                  </item>
               </ulist>
               <p>The values of the <code>is-id</code> and <code>is-idrefs</code> properties are not
                  changed.</p>
               <note>
                  <p>Stripping <termref def="dt-type-annotation">type annotations</termref> does not
                     necessarily return the document to the state it would be in had validation not
                     taken place. In particular, any defaulted elements and attributes that were
                     added to the tree by the validation process will still be present, and elements
                     and attributes validated as IDs will still be accessible using the
                        <xfunction>id</xfunction> function.</p>
               </note>
            </div3>
            <div3 id="strip">
               <head>Stripping Whitespace from a Source Tree</head>
               <p>A <termref def="dt-source-tree">source tree</termref> supplied as input to the
                  transformation process may contain <termref def="dt-whitespace-text-node"
                     >whitespace text nodes</termref> that are of no interest, and that do not need
                  to be retained by the transformation. Conceptually, an XSLT <termref
                     def="dt-processor">processor</termref> makes a copy of the source tree from
                  which unwanted <termref def="dt-whitespace-text-node">whitespace text
                     nodes</termref> have been removed. This process is referred to as whitespace
                  stripping. </p>
               <p diff="del" at="T-bug29692">For the purposes of this section, the term <term>source
                     tree</term> means the document containing the <phrase diff="chg"
                     at="R-bug24764"><termref def="dt-global-context-item"/> if it is a node, any
                     documents containing nodes present in the <termref
                        def="dt-initial-match-selection"/>,</phrase> any document returned by the
                  functions <function>document</function>, <xfunction>doc</xfunction>, or
                     <xfunction>collection</xfunction>, <phrase diff="add" at="P-bug23326">and any
                     document read using <elcode>xsl:source-document</elcode></phrase>. It does not
                  include documents passed as the values of <termref def="dt-stylesheet-parameter"
                     >stylesheet parameters</termref>
                  <phrase diff="add" at="Q">or parameters of the initial template or
                     function</phrase>, <phrase diff="add" at="T-bug29544">trees created by
                     functions such as <xfunction>parse-xml</xfunction>,
                        <code>parse-xml-fragment</code>, <xfunction>analyze-string</xfunction>, or
                        <function>json-to-xml</function></phrase>, nor values returned from <termref
                     def="dt-extension-function">extension functions</termref>.</p>
               <p diff="del" at="T-bug29692">Each source tree is associated with a package: the
                  relevant package for the <termref def="dt-global-context-item"/> is the <termref
                     def="dt-top-level-package">top-level package</termref>; the relevant package
                  for a call on <function>document</function>, <xfunction>doc</xfunction>, or
                     <xfunction>collection</xfunction>; is the package in which that call appears;
                  and the relevant package for evaluation of <elcode>xsl:source-document</elcode> is
                  the package in which that instruction appears.</p>
               <p>The stripping process takes as input a set of element names whose child <termref
                     def="dt-whitespace-text-node">whitespace text nodes</termref> are to be
                  preserved. The way in which this set of element names is established using the
                     <elcode>xsl:strip-space</elcode> and <elcode>xsl:preserve-space</elcode>
                  declarations is described later in this section.</p>
               <p diff="del" at="T-bug29692">Formally, the stripping process modifies the mapping
                  from URIs to document nodes defined in the XPath dynamic context. This mapping can
                  therefore vary from one package to another. The mapping that applies to a
                  particular call on <function>document</function>, <xfunction>doc</xfunction>, or
                     <xfunction>collection</xfunction>, or a particular evaluation of
                     <elcode>xsl:source-document</elcode>, is affected by the
                     <elcode>xsl:strip-space</elcode> and <elcode>xsl:preserve-space</elcode>
                  declarations within the package in which that construct appears. This means that
                  two calls on the <xfunction>doc</xfunction> function (for example) may return
                  different nodes if the calls appear in different packages.</p>
               <p diff="add" at="T-bug29692">The stripping process that applies for a particular
                     <termref def="dt-package"/> is determined by the
                     <elcode>xsl:strip-space</elcode> and <elcode>xsl:preserve-space</elcode>
                  declarations within that package.</p>
               <p>A <termref def="dt-whitespace-text-node">whitespace text node</termref> is
                  preserved if either of the following apply:</p>
               <ulist>
                  <item>
                     <p>The element name of the parent of the text node is in the set of
                        whitespace-preserving element names.</p>
                  </item>
                  <item>
                     <p>An ancestor element of the text node has an <code>xml:space</code> attribute
                        with a value of <code>preserve</code>, and no closer ancestor element has
                           <code>xml:space</code> with a value of <code>default</code>.</p>
                  </item>
               </ulist>
               <p>Otherwise, the <termref def="dt-whitespace-text-node">whitespace text
                     node</termref> is stripped.</p>
               <p>The <code>xml:space</code> attributes are not removed from the tree.</p>
               <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
                  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="strip-space">
                  <e:in-category name="declaration"/>
                  <e:attribute name="elements" required="yes">
                     <e:data-type name="tokens"/>
                  </e:attribute>
                  <e:empty/>
                  <e:allowed-parents>
                     <e:parent name="package"/>
                     <e:parent name="stylesheet"/>
                     <e:parent name="transform"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
                  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="preserve-space">
                  <e:in-category name="declaration"/>
                  <e:attribute name="elements" required="yes">
                     <e:data-type name="tokens"/>
                  </e:attribute>
                  <e:empty/>
                  <e:allowed-parents>
                     <e:parent name="package"/>
                     <e:parent name="stylesheet"/>
                     <e:parent name="transform"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p>The set of whitespace-preserving element names is specified by
                     <elcode>xsl:strip-space</elcode> and <elcode>xsl:preserve-space</elcode>
                  <termref def="dt-declaration">declarations</termref>. Whether an element name is
                  included in the set of whitespace-preserving names is determined by the best match
                  among all the <elcode>xsl:strip-space</elcode> or
                     <elcode>xsl:preserve-space</elcode> declarations: it is included if and only if
                  there is no match or the best match is an <elcode>xsl:preserve-space</elcode>
                  element. The <elcode>xsl:strip-space</elcode> and
                     <elcode>xsl:preserve-space</elcode> elements each have an <code>elements</code>
                  attribute whose value is a whitespace-separated list of <xnt
                     xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                     ref="prod-xpath30-NameTest" xlink:type="simple">NameTests</xnt>; an element
                  name matches an <elcode>xsl:strip-space</elcode> or
                     <elcode>xsl:preserve-space</elcode> element if it matches one of the <xnt
                     xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                     ref="prod-xpath30-NameTest" xlink:type="simple">NameTests</xnt>. An element
                  matches a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                     ref="prod-xpath30-NameTest" xlink:type="simple">NameTest</xnt> if and only if
                  the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                     ref="prod-xpath30-NameTest" xlink:type="simple">NameTest</xnt> would be true
                  for the element as an XPath node test.</p>
               <p diff="del" at="T-bug29692">The effect of <elcode>xsl:strip-space</elcode> and
                     <elcode>xsl:preserve-space</elcode> is local to the <termref def="dt-package"
                     >package</termref> in which they appear. Declarations within a library package
                  only affect the handling of documents loaded using a call on the
                     <function>document</function>, <xfunction>doc</xfunction>, or
                     <xfunction>collection</xfunction> functions <phrase diff="add" at="P">or an
                     evaluation of an <elcode>xsl:source-document</elcode> instruction</phrase>
                  appearing lexically within the same package. Declarations within the <termref
                     def="dt-top-level-package">top-level package</termref> also affect the
                  processing of the main input document.</p>
               <p diff="add" at="G"><error spec="XT" type="static" class="SE" code="0270"><p>It is a
                           <termref def="dt-static-error">static error</termref> if <phrase
                           diff="add" at="I">within any <termref def="dt-package"
                           >package</termref></phrase> the same <xnt
                           xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                           ref="prod-xpath30-NameTest" xlink:type="simple">NameTest</xnt> appears in
                        both an <elcode>xsl:strip-space</elcode> and an
                           <elcode>xsl:preserve-space</elcode> declaration if both have the same
                           <termref def="dt-import-precedence">import precedence</termref>. Two
                        NameTests are considered the same if they match the same set of names (which
                        can be determined by comparing them after expanding namespace prefixes to
                        URIs).</p></error></p>
               <p><phrase diff="add" at="G">Otherwise,</phrase> when more than one
                     <elcode>xsl:strip-space</elcode> and <elcode>xsl:preserve-space</elcode>
                  element <phrase diff="add" at="I">within the relevant <termref def="dt-package"
                        >package</termref></phrase> matches, the best matching element is determined
                  by the best matching <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                     ref="prod-xpath30-NameTest" xlink:type="simple">NameTest</xnt>. <phrase
                     diff="del" at="G">This is determined in the same way as with</phrase>
                  <phrase diff="add" at="G">The rules are similar to those for</phrase>
                  <termref def="dt-template-rule">template rules</termref>:</p>
               <ulist>
                  <item>
                     <p>First, any match with lower <termref def="dt-import-precedence">import
                           precedence</termref> than another match is ignored.</p>
                  </item>
                  <item>
                     <p>Next, any match that has a lower <termref def="dt-default-priority">default
                           priority</termref> than the <termref def="dt-default-priority">default
                           priority</termref> of another match is ignored.</p>
                  </item>
                  <item>
                     <p diff="chg" at="G">If several matches have the same <termref
                           def="dt-default-priority">default priority</termref> (which can only
                        happen if one of the NameTests takes the form <code>*:local</code> and the
                        other takes the form <code>prefix:*</code>), then the declaration that
                        appears last in <termref def="dt-declaration-order">declaration
                           order</termref> is used.</p>
                  </item>
               </ulist>
               <p diff="del" at="G">
                  <error spec="XT" type="dynamic" class="RE" code="0270"><p>It is a recoverable
                        dynamic error if this <error.extra>the process of finding an
                              <elcode>xsl:strip-space</elcode> or
                              <elcode>xsl:preserve-space</elcode> declaration to match an element in
                           the source document</error.extra> leaves more than one match, unless all
                        the matched declarations are equivalent (that is, they are all
                           <elcode>xsl:strip-space</elcode> or they are all
                           <elcode>xsl:preserve-space</elcode>). <error.action>The optional recovery
                           action is to select, from the matches that are left, the one that occurs
                           last in <termref def="dt-declaration-order">declaration order</termref>.
                        </error.action>
                     </p></error>
               </p>
               <p>If an element in a source document has a <termref def="dt-type-annotation">type
                     annotation</termref> that is a simple type or a complex type with simple
                  content, then any whitespace text nodes among its children are preserved,
                  regardless of any <elcode>xsl:strip-space</elcode> declarations. The reason for
                  this is that stripping a whitespace text node from an element with simple content
                  could make the element invalid: for example, it could cause the
                     <code>minLength</code> facet to be violated.</p>
               <p>Stripping of <termref def="dt-type-annotation">type annotations</termref> happens
                  before stripping of whitespace text nodes, so this situation will not occur if
                     <code>input-type-annotations="strip"</code> is specified.</p>
               <note>
                  <p>In <bibref ref="xpath-datamodel-30"/>, processes are described for constructing
                     an XDM tree from an Infoset or from a PSVI. Those processes deal with
                     whitespace according to their own rules, and the provisions in this section
                     apply to the resulting tree. In practice this means that elements that are
                     defined in a DTD or a Schema to contain element-only content will have <termref
                        def="dt-whitespace-text-node">whitespace text nodes</termref> stripped,
                     regardless of the <elcode>xsl:strip-space</elcode> and
                        <elcode>xsl:preserve-space</elcode> declarations in the stylesheet.</p>
                  <p>However, source trees are not necessarily constructed using those processes;
                     indeed, they are not necessarily constructed by parsing XML documents. Nothing
                     in the XSLT specification constrains how the source tree is constructed, or
                     what happens to <termref def="dt-whitespace-text-node">whitespace text
                        nodes</termref> during its construction. The provisions in this section
                     relate only to whitespace text nodes that are present in the tree supplied as
                     input to the XSLT processor. The XSLT processor cannot preserve whitespace text
                     nodes unless they were actually present in the supplied tree.</p>
               </note>
            </div3>
         </div2>
         <div2 id="id-in-data-model">
            <head>Attribute Types and DTD Validation</head>
            <p>The mapping from the Infoset to the XDM data model, described in <bibref
                  ref="xpath-datamodel-30"/>, does not retain attribute types. This means, for
               example, that an attribute described in the DTD as having attribute type
                  <code>NMTOKENS</code> will be annotated in the XDM tree as
                  <code>xs:untypedAtomic</code> rather than <code>xs:NMTOKENS</code>, and its typed
               value will consist of a single <code>xs:untypedAtomic</code> value rather than a
               sequence of <code>xs:NMTOKEN</code> values.</p>
            <p>Attributes with a DTD-derived type of ID, IDREF, or IDREFS will be marked in the XDM
               tree as having the <code>is-id</code> or <code>is-idrefs</code> properties. It is
               these properties, rather than any <termref def="dt-type-annotation">type
                  annotation</termref>, that are examined by the functions <xfunction>id</xfunction>
               and <xfunction>idref</xfunction> described in <bibref ref="xpath-functions-30"/>.</p>
         </div2>
         <div2 id="model-for-streaming" diff="add" at="C">
            <head>Data Model for Streaming</head>
            <div3 id="streamed-documents">
               <head>Streamed Documents</head>
               <p>The data model for nodes in a document that is being streamed is no different from
                  the standard XDM data model, in that it contains the same objects (nodes) with the
                  same properties and relationships. The facilities for streaming do not change the
                  data model; instead they impose rules that limit the ability of stylesheets to
                  navigate the data model.</p>
               <p>A useful way to visualize streaming is to suppose that at any point in time, there
                  is a current position in the streamed input document which may be the start or end
                  of the document, the start or end tag of an element, or a text, comment, or
                  processing instruction node. From this position, the stylesheet has access to the
                  following information: </p>
               <ulist>
                  <item>
                     <p>Properties intrinsic to the node, such as its name, its base URI, its type
                        annotation, and its <code>is-id</code> and <code>is-idref</code>
                        properties.</p>
                  </item>
                  <item>
                     <p>The ancestors of the node (but navigation downwards from the ancestors is
                        not permitted).</p>
                  </item>
                  <item>
                     <p>The attributes of the node, and the attributes of its ancestors. For each
                        such attribute, all the properties of the node including its string value
                        and typed value are available, but there are limitations that restrict
                        navigation from the attribute node to other nodes in the document.</p>
                  </item>
                  <item>
                     <p>The in-scope namespace bindings of the node.</p>
                  </item>
                  <item>
                     <p>In the case of attributes, text nodes, comments, and processing
                        instructions, the string value and typed value of the node.</p>
                  </item>
                  <item diff="del" at="R-bug26742">
                     <p>Summary data about the preceding siblings of the node, and of each of its
                        ancestor nodes: specifically, for each distinct combination of node kind,
                        node name, and <termref def="dt-type-annotation"/>, a count of the number of
                        preceding siblings that have that combination of properties. This
                        information allows patterns such as <code>match="para[1]"</code> to be used,
                        and it permits some limited use of the <elcode>xsl:number</elcode>
                        instruction.</p>
                  </item>
                  <item diff="add" at="S-bug28202">
                     <p>In the case of element nodes, whether or not the element has children. This
                        information is obtained by calling the <xfunction>has-children</xfunction>
                        function. This implies that the processor performs look-ahead (limited to a
                        single token) to determine whether the start tag is immediately followed by
                        a matching end tag.</p>
                  </item>
                  <item diff="add" at="S-bug28202">
                     <p>In the case of document nodes, details of unparsed entities in the document.
                        This information is obtained by calling the
                           <function>unparsed-entity-uri</function> and
                           <function>unparsed-entity-public-id</function> functions. A processor
                        might enable this by reading the DTD as soon as the document is opened.
                        Since comments and processing instructions that precede the DOCTYPE
                        declaration are available as children of the document node, this also
                        implies that a streaming processor needs sufficient memory to hold these
                        comments and processing instructions until the start tag of the first
                        element is encountered. Information about unparsed entities remains
                        available for the duration of processing, in the same way as attributes of
                        ancestor elements.</p>
                  </item>
               </ulist>
               <p>The children and other descendants of a node are not accessible except as a
                  by-product of changing the current position in the document. The same applies to
                  properties of an element or document node that require examination of the node’s
                  descendants, that is, the string value and typed value. This is enforced by means
                  of a rule that only one expression requiring downward navigation from a node is
                  permitted.</p>
               <p diff="chg" at="S-bug28202">Information about the type of a node is in general
                  considered a property intrinsic to the node, and is available without advancing
                  the input stream. There is an exception for an expression of the form <code>(/)
                     instance of document-node(element(invoice))</code>. This is not guaranteed
                  streamable, because it requires reading ahead to check that the document node has
                  only one element child. However, a processor that knows that the parser delivering
                  the document stream is only capable of delivering well-formed documents may use
                  this knowledge (along with the limited look-ahead needed to get the name of the
                  outermost element) to make this expression streamable.</p>
               <p diff="add" at="I">A streaming processor is <phrase diff="chg" at="S-bug28202">not
                     required to read any more</phrase> of the source document than is needed to
                  generate correct stylesheet output. It is not required to read the full source
                  document merely in order to satisfy the requirement imposed by the XML
                  Recommendation that an XML Processor must report violations of well-formedness in
                  the input.</p>
               <p>More detailed rules are defined in <specref ref="streamability"/>.</p>
            </div3>
            <div3 id="streaming-other-types" diff="add" at="S-bug29229">
               <head>Other Data Structures</head>
               <p>Two new data structures have been added to the data model: maps and arrays. Both
                  are defined in XPath 3.1, but maps are also available in XSLT processors that only
                  support XPath 3.0 (see <specref ref="map"/>). </p>
               <p>Streaming facilities in this specification are, for the most part, relevant only
                  to streamed processing of XML trees, and not to other structures such as
                  sequences, maps and arrays, which will typically be held in memory unless the
                  processor is capable of avoiding this. </p>
               <p>Maps, however, play in important role in enabling streamed applications to be
                  written. For example, a map can be used as the data structure maintained by an
                  accumulator (see <specref ref="accumulators"/>) to remember information that has
                  been retrieved from a streamed document, given that it is not possible to revisit
                  the same nodes later. There is also a special streamability rule for map
                  constructor expressions (see <specref ref="maps-streaming"/>) that allows such an
                  expression to make multiple downward selections in the streamed input document:
                  for example one can write <code>map{'authors':data(author),
                     'editors':data(editor)}</code>, which gathers the values of these these two
                  elements, or sets of elements, from the input stream, regardless what order they
                  appear in — even if they are interleaved.</p>
               <p>The rules for creating maps and arrays are designed to ensure that the entries in
                  a map, and the members of an array, cannot contain nodes from a streamed document.
                  This is achieved by the way in which the streamability properties of the relevant
                  expressions and functions are defined. </p>
               <p>By contrast, sequences can and often do contain nodes from streamed documents, and
                  a major purpose of the rules for streamability is to make this possible. </p>
            </div3>
         </div2>
         <div2 id="limits">
            <head>Limits</head>
            <p>The XDM data model (see <bibref ref="xpath-datamodel-30"/>) leaves it to the host
               language to define limits. This section describes the limits that apply to XSLT.</p>
            <p>Limits on some primitive datatypes are defined in <bibref ref="xmlschema-2"/>. Other
               limits, listed below, are <termref def="dt-implementation-defined"
                  >implementation-defined</termref>. Note that this does not necessarily mean that
               each limit must be a simple constant: it may vary depending on environmental factors
               such as available resources.</p>
            <imp-def-feature id="idf-defaults-limits">Limits on the value space of primitive
               datatypes, where not fixed by <bibref ref="xmlschema-2"/>, are
               implementation-defined.</imp-def-feature>
            <p>The following limits are <termref def="dt-implementation-defined"
                  >implementation-defined</termref>:</p>
            <olist>
               <item>
                  <p>For the <code>xs:decimal</code> type, the maximum number of decimal digits (the
                        <code>totalDigits</code> facet). This must be at least 18 digits. (Note,
                     however, that support for the full value range of <code>xs:unsignedLong</code>
                     requires 20 digits.) </p>
               </item>
               <item>
                  <p>For the types <code>xs:date</code>, <code>xs:time</code>,
                        <code>xs:dateTime</code>, <code>xs:gYear</code>, and
                        <code>xs:gYearMonth</code>: the range of values of the year component, which
                     must be at least +0001 to +9999; and the maximum number of fractional second
                     digits, which must be at least 3.</p>
               </item>
               <item>
                  <p>For the <code>xs:duration</code> type: the maximum absolute values of the
                     years, months, days, hours, minutes, and seconds components. </p>
               </item>
               <item>
                  <p>For the <code>xs:yearMonthDuration</code> type: the maximum absolute value,
                     expressed as an integer number of months.</p>
               </item>
               <item>
                  <p>For the <code>xs:dayTimeDuration</code> type: the maximum absolute value,
                     expressed as a decimal number of seconds.</p>
               </item>
               <item>
                  <p>For the types <code>xs:string</code>, <code>xs:hexBinary</code>,
                        <code>xs:base64Binary</code>, <code>xs:QName</code>, <code>xs:anyURI</code>,
                        <code>xs:NOTATION</code>, and types derived from them: the maximum length of
                     the value. </p>
               </item>
               <item>
                  <p>For sequences, the maximum number of items in a sequence.</p>
               </item>
            </olist>
         </div2>
         <div2 id="d-o-e-in-data-model">
            <head>Disable Output Escaping</head>
            <p>For backwards compatibility reasons, XSLT <phrase diff="chg" at="A">3.0</phrase>
               continues to support the <code>disable-output-escaping</code> feature introduced in
               XSLT 1.0. This is an optional feature and implementations are not
                  <rfc2119>required</rfc2119> to support it. A new facility, that of named <termref
                  def="dt-character-map">character maps</termref> (see <specref ref="character-maps"
               />) <phrase diff="chg" at="A">was</phrase> introduced in XSLT 2.0. It provides
               similar capabilities to <code>disable-output-escaping</code>, but without distorting
               the data model.</p>
            <p>If an <termref def="dt-implementation">implementation</termref> supports the
                  <code>disable-output-escaping</code> attribute of <elcode>xsl:text</elcode> and
                  <elcode>xsl:value-of</elcode>, (see <specref ref="disable-output-escaping"/>),
               then the data model for trees constructed by the <termref def="dt-processor"
                  >processor</termref> is augmented with a boolean value representing the value of
               this property. This boolean value, however, can be set only within a <termref
                  def="dt-final-result-tree">final result tree</termref> that is being passed to the
               serializer.</p>
            <p>Conceptually, each character in a text node on such a result tree has a boolean
               property indicating whether the serializer is to disable the normal rules for
               escaping of special characters (for example, outputting of <code>&amp;</code> as
                  <code>&amp;amp;</code>) in respect of this character<phrase diff="del" at="L"> or
                  attribute node</phrase>.</p>
            <note>
               <p>In practice, the nodes in a <termref def="dt-final-result-tree">final result
                     tree</termref> will often be streamed directly from the XSLT processor to the
                  serializer. In such an implementation, <code>disable-output-escaping</code> can be
                  viewed not so much a property stored with nodes in the tree, but rather as
                  additional information passed across the interface between the XSLT processor and
                  the serializer.</p>
            </note>
         </div2>
      </div1>
      <div1 id="constructs">
         <head>Features of the XSLT Language</head>
         <div2 id="names">
            <head>Names</head>
            <div3 id="qname" diff="chg" at="K">
               <head>Qualified Names</head>
               <p>Many constructs appearing in a stylesheet, for example <termref
                     def="dt-named-template">named templates</termref>, <termref def="dt-mode"
                     >modes</termref>, and <termref def="dt-attribute-set">attribute sets</termref>,
                  are named using a qualified name: this consists of a local name and an optional
                  namespace URI.</p>
               <p>In most cases where such names are written in a <termref def="dt-stylesheet"
                     >stylesheet</termref>, the syntax for expressing the name is given by the
                  production <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                     ref="prod-xpath30-EQName" xlink:type="simple">EQName</xnt> in the XPath
                  specification. In practice, this means that three forms are permitted:</p>
               <ulist>
                  <item>
                     <p>A simple <code>NCName</code> appearing on its own (without any prefix). This
                        represents the local name of the object. The interpretation of unprefixed
                        names is described below.</p>
                  </item>
                  <item>
                     <p>A <termref def="dt-lexical-qname">lexical QName</termref> written in the
                        form <code>NCName ":" NCName</code> where the first part is a namespace
                        prefix and the second part is the local name. The namespace part of the
                        object’s name is then derived from the prefix by examining the in-scope
                        namespace bindings of the element node in the stylesheet where the name
                        appears.</p>
                  </item>
                  <item>
                     <p>A <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                           ref="prod-xpath30-URIQualifiedName" xlink:type="simple"
                           >URIQualifiedName</xnt> in the form <code>"Q{" URI? "}" NCName</code>
                        where the two parts of the name, that is the namespace part and the local
                        part, both appear explicitly. If the URI part is omitted (for example
                           <code>Q{}local</code>), the resulting expanded QName is a QName whose
                        namespace part is absent.</p>
                  </item>
               </ulist>
               <note>
                  <p>There are a few places where the third form, a URIQualifiedName, is not
                     permitted. These include the <code>name</code> attribute of
                        <elcode>xsl:element</elcode> and <elcode>xsl:attribute</elcode> (which have
                     a separate <code>namespace</code> attribute for the purpose), and constructs
                     defined by other specifications. For example, names appearing within an
                     embedded <code>xs:schema</code> element must follow the XSD rules.</p>
               </note>
               <p>
                  <termdef id="dt-expanded-qname" term="expanded QName">An <term>expanded
                        QName</term> is a value in the value space of the <code>xs:QName</code>
                     datatype as defined in the XDM data model (see <bibref ref="xpath-datamodel-30"
                     />): that is, a triple containing namespace prefix (optional), namespace URI
                     (optional), and local name. Two expanded QNames are equal if the namespace URIs
                     are the same (or both absent) and the local names are the same. The prefix
                     plays no part in the comparison, but is used only if the expanded QName needs
                     to be converted back to a string.</termdef>
               </p>
               <p><termdef id="dt-eqname" term="EQName">An <term>EQName</term> is a string
                     representing an <termref def="dt-expanded-qname">expanded QName</termref> where
                     the string, after removing leading and trailing whitespace, is in the form
                     defined by the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                        ref="prod-xpath30-EQName" xlink:type="simple">EQName</xnt> production in the
                     XPath specification.</termdef></p>
               <p>
                  <termdef id="dt-lexical-qname" term="lexical QName">A <term>lexical QName</term>
                     is a string representing an <termref def="dt-expanded-qname">expanded
                        QName</termref> where the string, after removing leading and trailing
                     whitespace, is within the lexical space of the <code>xs:QName</code> datatype
                     as defined in XML Schema (see <bibref ref="xmlschema-2"/>): that is, a local
                     name optionally preceded by a namespace prefix and a colon.</termdef>
               </p>
               <p>Note that every <termref def="dt-lexical-qname">lexical QName</termref> is an
                     <termref def="dt-eqname">EQName</termref>, but the converse is not true.</p>
               <p>The following rules are used when interpreting a <termref def="dt-lexical-qname"
                     >lexical QName</termref>:</p>
               <olist>
                  <item>
                     <p>
                        <termdef id="dt-defining-element" term="defining element">A string in the
                           form of a lexical QName may occur as the value of an attribute node in a
                           stylesheet module, or within an XPath <termref def="dt-expression"
                              >expression</termref> contained in an attribute <phrase diff="add"
                              at="M">or text node within a stylesheet module</phrase>, or as the
                           result of evaluating an XPath expression contained in such a node. The
                           element containing this attribute <phrase diff="add" at="M">or
                              text</phrase> node is referred to as the <term>defining element</term>
                           of the lexical QName.</termdef>
                     </p>
                  </item>
                  <item>
                     <p>If the lexical QName has a prefix, then the prefix is expanded into a URI
                        reference using the namespace declarations in effect on its <termref
                           def="dt-defining-element">defining element</termref>. The <termref
                           def="dt-expanded-qname">expanded QName</termref> consisting of the local
                        part of the name and the possibly null URI reference is used as the name of
                        the object. The default namespace of the defining element (see <xspecref
                           spec="DM30" ref="ElementNode"/>) is <emph>not</emph> used for unprefixed
                        names.</p>
                     <p>
                        <error spec="XT" type="static" class="SE" code="0280"><p>In the case of a
                              prefixed <termref def="dt-lexical-qname">lexical QName</termref> used
                              as the value <phrase diff="add" at="G">(or as part of the
                                 value)</phrase> of an attribute in the <termref def="dt-stylesheet"
                                 >stylesheet</termref>, or appearing within an XPath <termref
                                 def="dt-expression">expression</termref> in the stylesheet, it is a
                                 <termref def="dt-static-error">static error</termref> if the
                                 <termref def="dt-defining-element">defining element</termref> has
                              no namespace node whose name matches the prefix of the <termref
                                 def="dt-lexical-qname">lexical QName</termref>.</p></error>
                     </p>
                     <p>
                        <error spec="XT" type="dynamic" class="DE" code="0290"><p>Where the result
                              of evaluating an XPath expression (or an attribute value template) is
                              required to be a <termref def="dt-lexical-qname">lexical
                                 QName</termref>, or if it is permitted to be a <termref
                                 def="dt-lexical-qname">lexical QName</termref> and the actual value
                              takes the form of a <termref def="dt-lexical-qname">lexical
                                 QName</termref>, then unless otherwise specified it is a <termref
                                 def="dt-dynamic-error"><phrase diff="del" at="M"
                                    >non-recoverable</phrase> dynamic error</termref> if the value
                              has a prefix and the <termref def="dt-defining-element">defining
                                 element</termref> has no namespace node whose name matches that
                              prefix. This error <rfc2119>may</rfc2119> be signaled as a <termref
                                 def="dt-static-error">static error</termref> if the value of the
                              expression can be determined statically.</p></error>
                     </p>
                  </item>
                  <item>
                     <p>If the lexical QName has no prefix, then:</p>
                     <olist>
                        <item>
                           <p>In the case of an unprefixed QName used as a <code>NameTest</code>
                              within an XPath <termref def="dt-expression">expression</termref> (see
                                 <specref ref="expressions"/>), and in certain other contexts, the
                              namespace to be used in expanding the QName may be specified by means
                              of the <code>[xsl:]xpath-default-namespace</code> attribute, as
                              specified in <specref ref="unprefixed-qnames"/>.</p>
                        </item>
                        <item>
                           <p>If the name is in one of the following categories, then the default
                              namespace of the <termref def="dt-defining-element">defining
                                 element</termref> is used:</p>
                           <olist>
                              <item>
                                 <p>Where a QName is used to define the name of an element being
                                    constructed. This applies both to cases where the name is known
                                    statically (that is, the name of a literal result element) and
                                    to cases where it is computed dynamically (the value of the
                                       <code>name</code> attribute of the
                                       <elcode>xsl:element</elcode> instruction).</p>
                              </item>
                              <item>
                                 <p>The default namespace is used when expanding the first argument
                                    of the function <function>element-available</function>.</p>
                              </item>
                              <item>
                                 <p>The default namespace applies to any unqualified element names
                                    appearing in the <code>cdata-section-elements</code>
                                    <phrase diff="add" at="S-bug28341">or
                                          <code>suppress-indentation</code></phrase> attributes of
                                       <elcode>xsl:output</elcode> or
                                       <elcode>xsl:result-document</elcode>
                                 </p>
                              </item>
                           </olist>
                        </item>
                        <item>
                           <p>In all other cases, a <termref def="dt-lexical-qname">lexical
                                 QName</termref> with no prefix represents an <termref
                                 def="dt-expanded-qname">expanded QName</termref> in no namespace
                              (that is, an <code>xs:QName</code> value in which both the prefix and
                              the namespace URI are absent).</p>
                        </item>
                     </olist>
                  </item>
               </olist>
            </div3>
            <div3 id="unprefixed-qnames">
               <head>Unprefixed Lexical QNames in Expressions and Patterns</head>
               <p>The attribute <code>[xsl:]xpath-default-namespace</code> (see <specref
                     ref="standard-attributes"/>) may be used on an element in the <termref
                     def="dt-stylesheet">stylesheet</termref> to define the namespace that will be
                  used for an unprefixed element name or type name within an XPath expression, and
                  in certain other contexts listed below.</p>
               <p>The value of the attribute is the namespace URI to be used.</p>
               <p>For any element in the <termref def="dt-stylesheet">stylesheet</termref>, this
                  attribute has an effective value, which is the value of the
                     <code>[xsl:]xpath-default-namespace</code> on that element or on the innermost
                  containing element that specifies such an attribute, or the zero-length string if
                  no containing element specifies such an attribute.</p>
               <p>For any element in the <termref def="dt-stylesheet">stylesheet</termref>, the
                  effective value of this attribute determines the value of the <emph>default
                     namespace for element and type names</emph> in the static context of any XPath
                  expression contained in an attribute <phrase diff="add" at="M">or text
                     node</phrase> of that element (including XPath expressions in <termref
                     def="dt-attribute-value-template">attribute value templates</termref>
                  <phrase diff="add" at="M">and <termref def="dt-text-value-template">text value
                        templates</termref></phrase>). The effect of this is specified in <bibref
                     ref="xpath-30"/>; in summary, it determines the namespace used for any
                  unprefixed type name in the <termref def="dt-sequence-type"/> production, and for
                  any element name appearing in a path expression or in the <termref
                     def="dt-sequence-type"/> production.</p>
               <p>The effective value of this attribute similarly applies to any of the following
                  constructs appearing within its scope:</p>
               <ulist>
                  <item>
                     <p>any unprefixed element name or type name used in a <termref def="dt-pattern"
                           >pattern</termref>
                     </p>
                  </item>
                  <item>
                     <p>any unprefixed element name used in the <code>elements</code> attribute of
                        the <elcode>xsl:strip-space</elcode> or <elcode>xsl:preserve-space</elcode>
                        instructions</p>
                  </item>
                  <item>
                     <p>any unprefixed element name or type name used in the <code>as</code>
                        attribute of an <termref def="dt-xslt-element">XSLT element</termref>
                     </p>
                  </item>
                  <item>
                     <p>any unprefixed type name used in the <code>type</code> attribute of an
                           <termref def="dt-xslt-element">XSLT element</termref>
                     </p>
                  </item>
                  <item>
                     <p>any unprefixed type name used in the <code>xsl:type</code> attribute of a
                           <termref def="dt-literal-result-element">literal result
                        element</termref>.</p>
                  </item>
               </ulist>
               <p>The <code>[xsl:]xpath-default-namespace</code> attribute <rfc2119>must</rfc2119>
                  be in the <termref def="dt-xslt-namespace">XSLT namespace</termref> if and only if
                  its parent element is <emph>not</emph> in the XSLT namespace.</p>
               <p>If the effective value of the attribute is a zero-length string, which will be the
                  case if it is explicitly set to a zero-length string or if it is not specified at
                  all, then an unprefixed element name or type name refers to a name that is in no
                  namespace. The default namespace of the parent element (see <xspecref spec="DM30"
                     ref="ElementNode"/>) is <emph>not</emph> used.</p>
               <p>The attribute does not affect other names, for example function names, variable
                  names, or template names, or strings that are interpreted as <termref
                     def="dt-lexical-qname">lexical QNames</termref> during stylesheet evaluation,
                  such as the <termref def="dt-effective-value">effective value</termref> of the
                     <code>name</code> attribute of <elcode>xsl:element</elcode> or the string
                  supplied as the first argument to the <function>key</function> function.</p>
            </div3>
            <div3 id="reserved-namespaces">
               <head>Reserved Namespaces</head>
               <p>
                  <termdef id="dt-reserved-namespace" term="reserved namespace">The XSLT namespace,
                     together with certain other namespaces recognized by an XSLT processor, are
                     classified as <term>reserved namespaces</term> and <rfc2119>must</rfc2119> be
                     used only as specified in this and related specifications.</termdef> The
                  reserved namespaces are those listed below.</p>
               <ulist>
                  <item>
                     <p>The <termref def="dt-xslt-namespace">XSLT namespace</termref>, described in
                           <specref ref="xslt-namespace"/>, is reserved.</p>
                  </item>
                  <item>
                     <p>
                        <termdef id="dt-standard-function-namespace"
                           term="standard function namespace">The <term>standard function
                              namespace</term>
                           <code>http://www.w3.org/2005/xpath-functions</code> is used for functions
                           in the function library defined in <bibref ref="xpath-functions-30"/> and
                           for standard functions defined in this specification.</termdef>
                     </p>
                  </item>
                  <item>
                     <p diff="add" at="E"> The namespace
                           <code>http://www.w3.org/2005/xpath-functions/math</code> is used for
                        mathematical functions in the function library defined in <bibref
                           ref="xpath-functions-30"/>. </p>
                  </item>
                  <item>
                     <p diff="add" at="I"> The namespace
                           <code>http://www.w3.org/2005/xpath-functions/map</code> is used for
                        functions defined in this specification relating to the manipulation of
                           <termref def="dt-map">maps</termref>. </p>
                  </item>
                  <item>
                     <p diff="add" at="S-bug24266"> The namespace
                           <code>http://www.w3.org/2005/xpath-functions/array</code> is reserved for
                        use as described in <bibref ref="xpath-functions-31"/>. The namespace is
                        reserved whether or not the processor actually supports XPath 3.1.</p>
                  </item>
                  <item>
                     <p>
                        <termdef id="xml-namespace" term="XML namespace">The <term>XML
                              namespace</term>, defined in <bibref ref="xml-names"/> as
                              <code>http://www.w3.org/XML/1998/namespace</code>, is used for
                           attributes such as <code>xml:lang</code>, <code>xml:space</code>, and
                              <code>xml:id</code>.</termdef>
                     </p>
                  </item>
                  <item>
                     <p><termdef id="dt-schema-namespace" term="schema namespace">The <term>schema
                              namespace</term>
                           <code>http://www.w3.org/2001/XMLSchema</code> is used as defined in
                              <bibref ref="xmlschema-1"/></termdef>. In a <termref
                           def="dt-stylesheet">stylesheet</termref> this namespace may be used to
                        refer to built-in schema datatypes and to the constructor functions
                        associated with those datatypes.</p>
                  </item>
                  <item>
                     <p><termdef id="dt-schema-instance-namespace" term="schema instance namespace"
                           >The <term>schema instance namespace</term>
                           <code>http://www.w3.org/2001/XMLSchema-instance</code> is used as defined
                           in <bibref ref="xmlschema-1"/></termdef>. Attributes in this namespace,
                        if they appear in a <termref def="dt-stylesheet">stylesheet</termref>, are
                        treated by the XSLT processor in the same way as any other attributes.</p>
                  </item>
                  <item>
                     <p diff="add" at="B"><termdef id="dt-standard-error-namespace"
                           term="standard error namespace">The <term>standard error namespace</term>
                           <code>http://www.w3.org/2005/xqt-errors</code> is used for error codes
                           defined in this specification and related specifications. It is also used
                           for the names of certain predefined variables accessible within the scope
                           of an <elcode>xsl:catch</elcode> element.</termdef></p>
                  </item>
                  <item>
                     <p>The namespace <code>http://www.w3.org/2000/xmlns/</code> is reserved for use
                        as described in <bibref ref="xml-names"/>. No element or attribute node can
                        have a name in this namespace, and although the prefix <code>xmlns</code> is
                        implicitly bound to this namespace, no namespace node will ever define this
                        binding.</p>
                  </item>
               </ulist>
               <note>
                  <p>With the exception of the XML namespace, any of the above namespaces that are
                     used in a stylesheet must be explicitly declared with a namespace declaration.
                     Although conventional prefixes are used for these namespaces in this
                     specification, any prefix may be used in a user stylesheet.</p>
               </note>
               <p>Reserved namespaces may be used without restriction to refer to the names of
                  elements and attributes in source documents and result documents. As far as the
                  XSLT processor is concerned, reserved namespaces other than the XSLT namespace may
                  be used without restriction in the names of <termref
                     def="dt-literal-result-element">literal result elements</termref> and <termref
                     def="dt-data-element">user-defined data elements</termref>, and in the names of
                  attributes of literal result elements or of <termref def="dt-xslt-element">XSLT
                     elements</termref>: but other processors <rfc2119>may</rfc2119> impose
                  restrictions or attach special meaning to them. Reserved namespaces <rfc2119>must
                     not</rfc2119> be used, however, in the names of stylesheet-defined objects such
                  as <termref def="dt-variable">variables</termref> and <termref
                     def="dt-stylesheet-function">stylesheet functions</termref><phrase diff="add"
                     at="S-bug29081">, nor in the names of <termref def="dt-extension-function"
                        >extension functions</termref> or <termref def="dt-extension-instruction"
                        >extension instructions</termref>.</phrase></p>
               <p diff="add" at="S-bug29081">It is not an error to use a reserved namespace in the
                  name of an <termref def="dt-extension-attribute">extension attribute</termref>:
                  attributes such as <code>xml:space</code> and <code>xsi:type</code> fall into this
                  category. XSLT processors <rfc2119>must not</rfc2119> reject such attributes, and
                     <rfc2119>must not</rfc2119> attach any meaning to them other than any meaning
                  defined by the relevant specification.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0080"><p>It is a <termref
                           def="dt-static-error">static error</termref> to use a <termref
                           def="dt-reserved-namespace">reserved namespace</termref> in the name of a
                           <termref def="dt-named-template">named template</termref>, a <termref
                           def="dt-mode">mode</termref>, an <termref def="dt-attribute-set"
                           >attribute set</termref>, a <termref def="dt-key">key</termref>, a
                           <termref def="dt-decimal-format">decimal-format</termref>, a <termref
                           def="dt-variable">variable</termref> or <termref def="dt-parameter"
                           >parameter</termref>, a <termref def="dt-stylesheet-function">stylesheet
                           function</termref>, a named <termref def="dt-output-definition">output
                           definition</termref>, <phrase diff="add" at="R">an <termref
                              def="dt-accumulator"/>,</phrase> or a <termref def="dt-character-map"
                           >character map</termref><phrase>; except that the name
                              <code>xsl:initial-template</code> is permitted as a template
                           name.</phrase></p></error>
               </p>
               <note diff="add" at="S-bug28116">
                  <p>The name <code>xsl:original</code> is used within <elcode>xsl:override</elcode>
                     to refer to a <termref def="dt-component"/> that is being overridden. Although
                     the name <code>xsl:original</code> is used to refer to the component, the
                     component has its own name, and no component ever has the name
                        <code>xsl:original</code>. </p>
               </note>
            </div3>
         </div2>
         <div2 id="expressions">
            <head>Expressions</head>
            <p>XSLT uses the expression language defined by <phrase>XPath 3.0</phrase>
               <bibref ref="xpath-30"/>. Expressions are used in XSLT for a variety of purposes
               including:</p>
            <ulist>
               <item>
                  <p>selecting nodes for processing;</p>
               </item>
               <item>
                  <p>specifying conditions for different ways of processing a node;</p>
               </item>
               <item>
                  <p>generating text to be inserted in a <termref def="dt-result-tree">result
                        tree</termref>.</p>
               </item>
            </ulist>
            <p>
               <termdef id="dt-expression" term="expression">Within this specification, the term
                     <term>XPath expression</term>, or simply <term>expression</term>, means a
                  string that matches the production <xnt xmlns:xlink="http://www.w3.org/1999/xlink"
                     spec="XP30" ref="prod-xpath30-Expr" xlink:type="simple">Expr</xnt> defined in
                     <bibref ref="xpath-30"/>, <phrase diff="add" at="S-bug24266"> with the
                     extensions defined in <specref ref="map"/></phrase>.</termdef>
            </p>
            <p diff="add" at="S-bug24266">If the processor implements the <termref
                  def="dt-xpath31-feature"/>, then the definition of the production
                  <code>Expr</code> from XPath 3.1 is used.</p>
            <p diff="add" at="S-bug24266">If the processor is configured to use a version of XPath
               later than XPath 3.1, then the syntax of an XPath expression is <termref
                  def="dt-implementation-defined"/>.</p>
            <p>An XPath expression may occur as the value of certain attributes on XSLT-defined
               elements, and also within curly brackets in <termref
                  def="dt-attribute-value-template">attribute value templates</termref>
               <phrase diff="add" at="M">and <termref def="dt-text-value-template">text value
                     templates</termref></phrase>.</p>
            <p>Except where <termref def="dt-forwards-compatible-behavior"/> is enabled (see
                  <specref ref="forwards"/>), it is a <termref def="dt-static-error">static
                  error</termref> if the value of such an attribute, <error.extra>an attribute
                  defined as containing an XPath <termref def="dt-expression">expression</termref>
               </error.extra> or the text between curly brackets in an <termref
                  def="dt-attribute-value-template">attribute value template</termref>
               <phrase diff="add" at="M">or <termref def="dt-text-value-template">text value
                     template</termref></phrase>, does not match the XPath production <xnt
                  xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-Expr"
                  xlink:type="simple">Expr</xnt>, or if it fails to satisfy other static constraints
               defined in the XPath specification, for example that all variable references
                  <rfc2119>must</rfc2119> refer to <termref def="dt-variable">variables</termref>
               that are in scope. Error codes are defined in <bibref ref="xpath-30"/>.</p>
            <p>The transformation fails with a <termref def="dt-dynamic-error"><phrase diff="del"
                     at="M">non-recoverable</phrase> dynamic error</termref> if any XPath <termref
                  def="dt-expression">expression</termref> is evaluated and raises a dynamic error.
               Error codes are defined in <bibref ref="xpath-30"/>.</p>
            <p>The transformation fails with a <termref def="dt-type-error">type error</termref> if
               an XPath <termref def="dt-expression">expression</termref> raises a type error, or if
               the result of evaluating the XPath <termref def="dt-expression">expression</termref>
               is evaluated and raises a type error, or if the XPath processor signals a type error
               during static analysis of an <termref def="dt-expression">expression</termref>. Error
               codes are defined in <bibref ref="xpath-30"/>.</p>
            <p>
               <termdef id="dt-required-type" term="required type">The context within a <termref
                     def="dt-stylesheet">stylesheet</termref> where an XPath <termref
                     def="dt-expression">expression</termref> appears may specify the <term>required
                     type</term> of the expression. The required type indicates the type of the
                  value that the expression is expected to return.</termdef> If no required type is
               specified, the expression may return any value: in effect, the required type is then
                  <code>item()*</code>. </p>
            <p diff="del" at="R-bug8217"> Except where otherwise indicated, the actual value of an
                  <termref def="dt-expression">expression</termref> is converted to the <termref
                  def="dt-required-type">required type</termref> using the <term>function conversion
                  rules</term>. These are the rules defined in <bibref ref="xpath-30"/> for
               converting the supplied argument of a function call to the required type of that
               argument, as defined in the function signature. The relevant rules are those that
               apply when <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref>
               is set to <code>false</code>. </p>
            <p diff="add" at="R-bug8217">
               <termdef id="dt-function-conversion-rules" term="function conversion rules"> When
                  used in this specification without further qualification, the term <term>function
                     conversion rules</term> means the function conversion rules defined in <bibref
                     ref="xpath-30"/>, applied with XPath 1.0 compatibility mode set to
                  false.</termdef>
            </p>
            <note diff="add" at="R-bug8217">
               <p> These are the rules defined in <bibref ref="xpath-30"/> for converting the
                  supplied argument of a function call to the required type of that argument, as
                  defined in the function signature. The same rules are used in XSLT for converting
                  the value of a variable to the declared type of the variable, or the result of
                  evaluating a function or template body to the declared type of the function or
                  template. They are also used when parameters are supplied to a template using
                     <elcode>xsl:with-param</elcode>. In all such cases, the rules that apply are
                  the XPath 3.0 rules without XPath 1.0 compatibility mode. The rules with XPath 1.0
                  compatibility mode set to true are used only for XPath function calls, and for the
                  operands of certain XPath operators. </p>
            </note>
            <p>This specification also invokes the <phrase diff="chg" at="D">XPath 3.0</phrase>
               <termref def="dt-function-conversion-rules">function conversion rules</termref> to
               convert the result of evaluating an XSLT <termref def="dt-sequence-constructor"
                  >sequence constructor</termref> to a required type (for example, the sequence
               constructor enclosed in an <elcode>xsl:variable</elcode>,
                  <elcode>xsl:template</elcode>, or <elcode>xsl:function</elcode> element).</p>
            <p>Any <termref def="dt-dynamic-error">dynamic error</termref> or <termref
                  def="dt-type-error">type error</termref> that occurs when applying the <termref
                  def="dt-function-conversion-rules">function conversion rules</termref> to convert
               a value to a required type results in the transformation failing, in the same way as
               if the error had occurred while evaluating an expression.</p>
            <note>
               <p>Note the distinction between the two kinds of error that may occur. Attempting to
                  convert an integer to a date is a type error, because such a conversion is never
                  possible. Type errors can be reported statically if they can be detected
                  statically, whether or not the construct in question is ever evaluated. Attempting
                  to convert the string <code>2003-02-29</code> to a date is a dynamic error rather
                  than a type error, because the problem is with this particular value, not with its
                  type. Dynamic errors are reported only if the instructions or expressions that
                  cause them are actually evaluated.</p>
            </note>
            <p diff="add" at="S-bug28216">The XPath specification states that the host language must
               specify whether the XPath processor normalizes all line breaks on input, before
               parsing, and if it does so, whether it uses the rules of [XML 1.0] or [XML 1.1]. In
               the case of XSLT, all handling of line breaks is the responsibility of the XML parser
               (which may support either XML 1.0 or XML 1.1); the XSLT and XPath processors perform
               no further changes.</p>
            <note>
               <p diff="add" at="S-bug28216">Most XPath expressions in a stylesheet appear within
                  XML attributes. They are therefore subject to XML line-ending normalization (for
                  example, a CRLF sequence is normalized to LF) and also to XML attribute-value
                  normalization, which replaces tabs and newlines by spaces. XPath expressions
                  appearing in text value templates, however (see <specref
                     ref="text-value-templates"/>) are subject to line-ending normalization but not
                  attribute-value normalization. In both cases, normalization of whitespace can be
                  prevented by using character references such as <code>&amp;#x9;</code>.</p>
            </note>
         </div2>
         <div2 id="static-and-dynamic-context">
            <head>The Static and Dynamic Context</head>
            <p>XPath defines the concept of an <xtermref spec="XP30" ref="dt-expression-context"
                  >expression context</xtermref> which contains all the information that can affect
               the result of evaluating an <termref def="dt-expression">expression</termref>. The
               expression context has two parts, the <xtermref spec="XP30" ref="dt-static-context"
                  >static context</xtermref>, and the <xtermref spec="XP30" ref="dt-dynamic-context"
                  >dynamic context</xtermref>. The components that make up the expression context
               are defined in the XPath specification (see <xspecref spec="XP30" ref="context"/>).
               This section describes the way in which these components are initialized when an
               XPath expression is contained within an XSLT stylesheet.</p>
            <p>As well as providing values for the static and dynamic context components defined in
               the XPath specification, XSLT defines additional context components of its own. These
               context components are used by XSLT instructions (for example,
                  <elcode>xsl:next-match</elcode> and <elcode>xsl:apply-imports</elcode>), and also
               by the functions in the extended function library described in this
               specification.</p>
            <p>The following four sections describe:</p>
            <slist>
               <sitem>
                  <specref ref="static-context"/>
               </sitem>
               <sitem>
                  <specref ref="additional-static-context"/>
               </sitem>
               <sitem>
                  <specref ref="xpath-dynamic-context"/>
               </sitem>
               <sitem>
                  <specref ref="additional-dynamic-context"/>
               </sitem>
            </slist>
            <div3 id="static-context">
               <head>Initializing the Static Context</head>
               <p>The <xtermref spec="XP30" ref="dt-static-context">static context</xtermref> of an
                  XPath expression appearing in an XSLT stylesheet is initialized as follows. In
                  these rules, the term <term>containing element</term> means the element within the
                  stylesheet that is the parent of the attribute <phrase diff="add" at="M">or text
                     node</phrase> whose value contains the XPath expression in question, and the
                  term <term>enclosing element</term> means the containing element or any of its
                  ancestors.</p>
               <ulist>
                  <item>
                     <p diff="chg" at="D">
                        <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref>
                        is set to true if and only if the containing element is processed with
                           <termref def="dt-xslt-10-behavior">XSLT 1.0 behavior</termref> (see
                           <specref ref="backwards"/>).</p>
                  </item>
                  <item>
                     <p>The <xtermref spec="XP30" ref="dt-static-namespaces">statically known
                           namespaces</xtermref> are the namespace declarations that are in scope
                        for the containing element.</p>
                  </item>
                  <item>
                     <p>The <xtermref spec="XP30" ref="dt-def-elemtype-ns">default element/type
                           namespace</xtermref> is the namespace defined by the
                           <code>[xsl:]xpath-default-namespace</code> attribute on the innermost
                        enclosing element that has such an attribute, as described in <specref
                           ref="unprefixed-qnames"/>. The value of this attribute is a namespace
                        URI. If there is no <code>[xsl:]xpath-default-namespace</code> attribute on
                        an enclosing element, the default namespace for element names and type names
                        is the null namespace.</p>
                  </item>
                  <item>
                     <p>The <xtermref spec="XP30" ref="dt-def-fn-ns">default function
                           namespace</xtermref> is the <termref def="dt-standard-function-namespace"
                           >standard function namespace</termref>, defined in <bibref
                           ref="xpath-functions-30"/>. This means that it is not necessary to
                        declare this namespace in the <termref def="dt-stylesheet"
                           >stylesheet</termref>, nor is it necessary to use the prefix
                           <code>fn</code> (or any other prefix) in calls to <phrase diff="chg"
                           at="R-bug24970">functions</phrase>
                        <phrase diff="add" at="R-bug24521">in this namespace</phrase>.</p>
                  </item>
                  <item>
                     <p>The <xtermref spec="XP30" ref="dt-issd">in-scope schema
                           definitions</xtermref> for the XPath expression are the same as the
                           <termref def="dt-in-scope-schema-component">in-scope schema
                           components</termref> for the <termref def="dt-stylesheet"
                           >stylesheet</termref>, and are as specified in <specref
                           ref="built-in-types"/>.</p>
                  </item>
                  <item>
                     <p>The <xtermref spec="XP30" ref="dt-in-scope-variables">in-scope
                           variables</xtermref> are defined by the <termref
                           def="dt-variable-binding-element">variable binding elements</termref>
                        that are in scope for the containing element (see <specref
                           ref="variables-and-parameters"/>).</p>
                  </item>
                  <item diff="add" at="D">
                     <p>The <xtermref spec="XP30" ref="dt-context-item-static-type">context item
                           static type</xtermref> may be determined by an XSLT processor that
                        performs static type inferencing, using rules that are outside the scope of
                        this specification; if no static type inferencing is done, then the context
                        item static type for every XPath expression is <code>item()</code>. <phrase
                           diff="add" at="Q">Note that some limited static type inferencing is
                           required in the case of a processor that performs streamability analysis:
                           see <specref ref="determining-static-type"/>.</phrase></p>
                  </item>
                  <item>
                     <p>The <xtermref spec="XP30" ref="dt-known-func-signatures">statically known
                           function signatures</xtermref> are:</p>
                     <ulist diff="chg" at="R-bug24970">
                        <item>
                           <p>The functions defined in <bibref ref="xpath-functions-30"/> in
                              namespaces <code>http://www.w3.org/2005/xpath-functions</code> and
                                 <code>http://www.w3.org/2005/xpath-functions/math</code>;</p>
                        </item>
                        <item>
                           <p>The functions defined in this specification in namespaces
                                 <code>http://www.w3.org/2005/xpath-functions</code> and
                                 <code>http://www.w3.org/2005/xpath-functions/map</code>;</p>
                        </item>
                        <item>
                           <p>Constructor functions for all the <phrase diff="chg" at="O"
                                 >simple</phrase> types in the <xtermref spec="XP30" ref="dt-issd"
                                 >in-scope schema definitions</xtermref>, including both built-in
                              types and user-defined types;</p>
                        </item>
                        <item>
                           <p>The <termref def="dt-stylesheet-function">stylesheet
                                 functions</termref> defined in the containing <termref
                                 def="dt-package"/>;</p>
                        </item>
                        <item>
                           <p>Stylesheet functions defined in used packages, subject to visibility:
                              see <specref ref="package-dependencies"/>;</p>
                        </item>
                        <item>
                           <p>any <termref def="dt-extension-function">extension functions</termref>
                              bound using <termref def="dt-implementation-defined"
                                 >implementation-defined</termref> mechanisms (see <specref
                                 ref="extension"/>).</p>
                           <note>
                              <p>The term <termref def="dt-extension-function"/> includes both
                                 vendor-supplied and user-written extension functions.</p>
                           </note>
                        </item>
                     </ulist>
                     <note>
                        <p>It follows from the above that a conformant XSLT processor must implement
                           the entire library of functions <phrase diff="chg" at="T-bug29819"
                              >defined in <bibref ref="xpath-functions-30"/> as well as those
                              defined in this specification.</phrase></p>
                     </note>
                  </item>
                  <item>
                     <p>The <xtermref spec="XP30" ref="dt-static-collations">statically known
                           collations</xtermref> are <termref def="dt-implementation-defined"
                           >implementation-defined</termref>, <phrase diff="chg" at="S-bug27167"
                           >except that they <rfc2119>must</rfc2119> always include (a) the Unicode
                           codepoint collation, defined in <xspecref spec="FO30"
                              ref="string-compare"/>, and (b) the family of UCA collations described
                           in <specref ref="uca-collations"/></phrase>.</p>
                  </item>
                  <item>
                     <p>The <xtermref spec="XP30" ref="dt-def-collation">default
                           collation</xtermref> is defined by the value of the
                           <code>[xsl:]default-collation</code> attribute on the innermost enclosing
                        element that has such an attribute. For details, see <specref
                           ref="default-collation-attribute"/>.</p>
                     <p>
                        <termdef id="dt-default-collation" term="default collation">In this
                           specification the term <term>default collation</term> means the collation
                           that is used by XPath operators such as <code>eq</code> and
                              <code>lt</code> appearing in XPath expressions within the
                           stylesheet.</termdef>
                     </p>
                     <p>This collation is also used by default when comparing strings in the
                        evaluation of the <elcode>xsl:key</elcode> and
                           <elcode>xsl:for-each-group</elcode> elements. This <rfc2119>may</rfc2119>
                        also (but need not necessarily) be the same as the default collation used
                        for <elcode>xsl:sort</elcode> elements within the stylesheet. Collations
                        used by <elcode>xsl:sort</elcode> are described in <specref
                           ref="collating-sequences"/>.</p>
                  </item>
                  <item>
                     <p diff="chg" at="T-bug29461"><term>Static base URI</term>: In a conventional
                        interpreted environment, the static base URI of an expression in the
                        stylesheet is the base URI of the containing element in the stylesheet. The
                        concept of the base URI of a node is defined in <xspecref spec="DM30"
                           ref="dm-base-uri"/>.</p>
                     <p diff="add" at="T-bug29461">When stylesheets are executed in an environment
                        where no source code is present (for example, because the code of the
                        stylesheet has been compiled and is distributed as executable object code),
                        it is <rfc2119>recommended</rfc2119> (subject to operational constraints
                        such as security) that the static base URI used during stylesheet evaluation
                        should be the location from which the stylesheet was loaded for execution
                        (its “deployed location”). This means, for example, that when the
                           <xfunction>doc</xfunction> or <function>document</function> functions are
                        called with a relative URI, the required document is by default located
                        relative to the deployed location of the stylesheet. </p>
                     <p diff="add" at="T-bug29461">Whether or not the stylesheet is executed
                        directly from source code, it is possible that no static base URI is
                        available, for example because the code was supplied as an anonymous input
                        stream, or because security policies are set to prevent executable code
                        discovering the location from which it was loaded. If the static base URI is
                        not known, the <xfunction>static-base-uri</xfunction> function returns an
                        empty sequence, and other operations that depend on the static base URI may
                        fail with a dynamic error.</p>
                  </item>
                  <item diff="add" at="D">
                     <p>The set of <xtermref spec="XP30" ref="dt-known-docs">statically known
                           documents</xtermref> is <termref def="dt-implementation-defined"
                           >implementation-defined</termref><phrase diff="del" at="I">, and by
                           default is empty</phrase>. </p>
                     <imp-def-feature id="idf-api-staticallyknowndocs">The <xtermref spec="XP30"
                           ref="dt-known-docs">statically known documents</xtermref>, <xtermref
                           spec="XP30" ref="dt-known-collections">statically known
                           collections</xtermref>, and the <xtermref spec="XP30"
                           ref="dt-known-default-collection">statically known default collection
                           type</xtermref> are <termref def="dt-implementation-defined"
                           >implementation-defined</termref>.</imp-def-feature>
                  </item>
                  <item diff="add" at="D">
                     <p>The set of <xtermref spec="XP30" ref="dt-known-collections">statically known
                           collections</xtermref> is <termref def="dt-implementation-defined"
                           >implementation-defined</termref><phrase diff="del" at="I">, and by
                           default is empty</phrase>. </p>
                  </item>
                  <item diff="add" at="D">
                     <p>The <xtermref spec="XP30" ref="dt-known-default-collection">statically known
                           default collection type</xtermref> is <termref
                           def="dt-implementation-defined">implementation-defined</termref><phrase
                           diff="del" at="I">, and by default is <code>node()*</code></phrase>. </p>
                  </item>
                  <item diff="add" at="D">
                     <p>The set of <xtermref spec="XP30" ref="dt-static-decimal-formats">statically
                           known decimal formats</xtermref> is the set of decimal formats defined by
                           <elcode>xsl:decimal-format</elcode> declarations in the stylesheet. </p>
                     <note diff="add" at="S-bug24266">
                        <p>XSLT 3.0 provides support for the <code>exponent-separator</code>
                           property which is added to the static context in XPath 3.1; when XSLT 3.0
                           is used with XPath 3.0, this property is ignored.</p>
                     </note>
                  </item>
               </ulist>
            </div3>
            <div3 id="additional-static-context">
               <head>Additional Static Context Components used by XSLT</head>
               <p>Some of the components of the XPath static context are used also by <termref
                     def="dt-xslt-element">XSLT elements</termref>. For example, the
                     <elcode>xsl:sort</elcode> element makes use of the collations defined in the
                  static context, and attributes such as <code>type</code> and <code>as</code> may
                  reference types defined in the <termref def="dt-in-scope-schema-component"
                     >in-scope schema components</termref>.</p>
               <p>Many top-level declarations in a stylesheet, and attributes on the
                     <elcode>xsl:stylesheet</elcode> element, affect the behavior of instructions
                  within the stylesheet. Each of these constructs is described in its appropriate
                  place in this specification.</p>
               <p>A number of these constructs are of particular significance because they are used
                  by functions defined in XSLT, which are added to the library of functions
                  available for use in XPath expressions within the stylesheet. These are:</p>
               <ulist>
                  <item>
                     <p>The set of named keys, used by the <function>key</function> function</p>
                  </item>
                  <item diff="del" at="D">
                     <p>The set of named decimal formats, used by the
                           <xfunction>format-number</xfunction> function</p>
                  </item>
                  <item>
                     <p>The values of system properties, used by the
                           <function>system-property</function> function</p>
                  </item>
                  <item>
                     <p>The set of available instructions, used by the
                           <function>element-available</function> function</p>
                  </item>
               </ulist>
               <p diff="add" at="Q-bug23631">A dynamic function call clears the first of these
                  components: this means that a dynamic call to the <function>key</function>
                  function will always raise a dynamic error (the key name is unknown). The values
                  of system properties and the set of available instructions, by contrast, reflect
                  the capabilities and configuration of the processor rather than values specific to
                  the stylesheet code itself; the result of a dynamic call to
                     <function>system-property</function> or <function>element-available</function>
                  will reflect the information available to the processor at evaluation time.</p>
               <note>
                  <p diff="add" at="Q-bug23631">If these functions are called within a <termref
                        def="dt-static-expression"/>, the results will reflect the capabilities and
                     configuration of the processor used to perform static analysis, while if they
                     are called elsewhere, the results should reflect the capabilities and
                     configuration of the processor used to perform dynamic evaluation, which might
                     give a different result. These calls should not be pre-evaluated at compile
                     time unless it is known that this will give the same result.</p>
               </note>
            </div3>
            <div3 id="xpath-dynamic-context">
               <head>Initializing the Dynamic Context</head>
               <p>For convenience, the dynamic context is described in two parts: the <termref
                     def="dt-focus">focus</termref>, which represents the place in the source
                  document that is currently being processed, and a collection of additional context
                  variables.</p>
               <p>A number of functions specified in <bibref ref="xpath-functions-30"/> are defined
                  to be <xtermref spec="FO30" ref="dt-deterministic">deterministic</xtermref>,
                  meaning that if they are called twice during the same <xtermref spec="FO30"
                     ref="execution-scope">execution scope</xtermref>, with the same arguments, then
                  they return the same results (see <xspecref spec="FO30" ref="terminology"/>). In
                  XSLT, the execution of a stylesheet defines the execution scope. This means, for
                  example, that if the function <xfunction>current-dateTime</xfunction> is called
                  repeatedly during a transformation, it produces the same result each time. By
                  implication, the components of the dynamic context on which these functions depend
                  are also stable for the duration of the transformation. Specifically, the
                  following components defined in <xspecref spec="XP30" ref="eval_context"/> must be
                  stable: <emph>function implementations</emph>, <emph>current dateTime</emph>,
                     <emph>implicit timezone</emph>, <emph>available documents</emph>,
                     <emph>available collections</emph>, and <emph>default collection</emph>. The
                  values of global variables and stylesheet parameters are also stable for the
                  duration of a transformation. The focus is <emph>not</emph> stable; the additional
                  dynamic context components defined in <specref ref="additional-dynamic-context"/>
                  are also <emph>not</emph> stable.</p>
               <p>As specified in <bibref ref="xpath-functions-30"/>, implementations may provide
                  user options that relax the requirement for the <xfunction>doc</xfunction> and
                     <xfunction>collection</xfunction> functions (and therefore, by implication, the
                     <function>document</function> function) to return stable results. By default,
                  however, the functions must be stable. The manner in which such user options are
                  provided, if at all, is <termref def="dt-implementation-defined"
                     >implementation-defined</termref>.</p>
               <imp-def-feature id="idf-api-stability">Implementations may provide user options that
                  relax the requirement for the <xfunction>doc</xfunction> and
                     <xfunction>collection</xfunction> functions (and therefore, by implication, the
                     <function>document</function> function) to return stable results. The manner in
                  which such user options are provided, if at all, is <termref
                     def="dt-implementation-defined"/>. </imp-def-feature>
               <p>XPath expressions contained in <code>[xsl:]use-when</code> attributes are not
                  considered to be evaluated “during the transformation” as defined above. For
                  details see <specref ref="conditional-inclusion"/>.</p>
               <p diff="add" at="K"><termdef id="dt-absent" term="absent">A component of the context
                     that has no value is said to be <term>absent</term>.</termdef> This is a
                  distinguishable state, and is not the same as having the empty sequence as its
                  value.</p>
               <div4 id="focus">
                  <head>Maintaining Position: the Focus</head>
                  <p>
                     <termdef id="dt-focus" term="focus">When a <termref
                           def="dt-sequence-constructor">sequence constructor</termref> is
                        evaluated, the <termref def="dt-processor">processor</termref> keeps track
                        of which items are being processed by means of a set of implicit variables
                        referred to collectively as the <term>focus</term>.</termdef> More
                     specifically, the focus consists of the following three values:</p>
                  <ulist>
                     <item>
                        <p><termdef id="dt-context-item" term="context item">The <term>context
                                 item</term> is the item currently being processed. An item (see
                                 <bibref ref="xpath-datamodel-30"/>) is either an atomic value (such
                              as an integer, date, or string), a node, <phrase diff="add" at="C">or
                                 a function item</phrase>. It changes whenever instructions such as
                                 <elcode>xsl:apply-templates</elcode> and
                                 <elcode>xsl:for-each</elcode> are used to process a sequence of
                              items; each item in such a sequence becomes the context item while
                              that item is being processed.</termdef> The context item is returned
                           by the XPath <termref def="dt-expression">expression</termref>
                           <code>.</code> (dot).</p>
                     </item>
                     <item>
                        <p><termdef id="dt-context-position" term="context position">The
                                 <term>context position</term> is the position of the context item
                              within the sequence of items currently being processed. It changes
                              whenever the context item changes. When an instruction such as
                                 <elcode>xsl:apply-templates</elcode> or
                                 <elcode>xsl:for-each</elcode> is used to process a sequence of
                              items, the first item in the sequence is processed with a context
                              position of 1, the second item with a context position of 2, and so
                              on.</termdef> The context position is returned by the XPath <termref
                              def="dt-expression">expression</termref>
                           <code>position()</code>.</p>
                     </item>
                     <item>
                        <p><termdef id="dt-context-size" term="context size">The <term>context
                                 size</term> is the number of items in the sequence of items
                              currently being processed. It changes whenever instructions such as
                                 <elcode>xsl:apply-templates</elcode> and
                                 <elcode>xsl:for-each</elcode> are used to process a sequence of
                              items; during the processing of each one of those items, the context
                              size is set to the count of the number of items in the sequence (or
                              equivalently, the position of the last item in the
                              sequence).</termdef> The context size is returned by the XPath
                              <termref def="dt-expression">expression</termref>
                           <code>last()</code>.</p>
                     </item>
                  </ulist>
                  <p>
                     <termdef id="dt-context-node" term="context node">If the <termref
                           def="dt-context-item">context item</termref> is a node (as distinct from
                        an atomic value such as an integer), then it is also referred to as the
                           <term>context node</term>. The context node is not an independent
                        variable, it changes whenever the context item changes. When the context
                        item is an atomic value <phrase diff="add" at="C">or a function
                           item</phrase>, there is no context node.</termdef> The context node is
                     returned by the XPath <termref def="dt-expression">expression</termref>
                     <code>self::node()</code>, and it is used as the starting node for all relative
                     path expressions.</p>
                  <p>Where the containing element of an XPath expression is an <termref
                        def="dt-instruction">instruction</termref> or a <termref
                        def="dt-literal-result-element">literal result element</termref>, the
                     initial context item, context position, and context size for the XPath <termref
                        def="dt-expression">expression</termref> are the same as the <termref
                        def="dt-context-item">context item</termref>, <termref
                        def="dt-context-position">context position</termref>, and <termref
                        def="dt-context-size">context size</termref> for the evaluation of the
                     containing instruction or literal result element.</p>
                  <p><phrase diff="chg" at="R-bug24764">The context item for evaluating global
                        variables in the <termref def="dt-top-level-package"/> is set to the <phrase
                           diff="chg" at="E"><termref def="dt-global-context-item"/></phrase>
                        supplied when the transformation is invoked (see <specref ref="initiating"
                        />).</phrase>
                     <phrase diff="add" at="R-bug25611">In <termref def="dt-library-package">library
                           packages</termref>, the context item for evaluating global variables is
                           <termref def="dt-absent"/></phrase>.</p>
                  <p diff="add" at="M">For an XPath expression contained in a <termref
                        def="dt-value-template"/>, the initial context item, context position, and
                     context size for the XPath <termref def="dt-expression">expression</termref>
                     are the same as the <termref def="dt-context-item">context item</termref>,
                        <termref def="dt-context-position">context position</termref>, and <termref
                        def="dt-context-size">context size</termref> for the evaluation of the
                     containing <termref def="dt-sequence-constructor"/>.</p>
                  <p>In other cases (for example, where the containing element is
                        <elcode>xsl:sort</elcode>, <elcode>xsl:with-param</elcode>, or
                        <elcode>xsl:key</elcode>), the rules are given in the specification of the
                     containing element.</p>
                  <p>The <function>current</function> function can be used within any XPath <termref
                        def="dt-expression">expression</termref> to select the item that was
                     supplied as the context item to the XPath expression by the XSLT processor.
                     Unlike <code>.</code> (dot) this is unaffected by changes to the context item
                     that occur within the XPath expression. The <function>current</function>
                     function is described in <specref ref="func-current"/>.</p>
                  <p>On completion of an instruction that changes the <termref def="dt-focus"
                        >focus</termref> (such as <elcode>xsl:apply-templates</elcode> or
                        <elcode>xsl:for-each</elcode>), the focus reverts to its previous value.</p>
                  <p>When a <termref def="dt-stylesheet-function">stylesheet function</termref> is
                     called, the focus within the body of the function is initially <termref
                        def="dt-absent">absent</termref>.</p>
                  <p>When the focus is <termref def="dt-absent">absent</termref>, evaluation of any
                        <termref def="dt-expression">expression</termref> that references the
                     context item, context position, or context size results in a <termref
                        def="dt-dynamic-error"><phrase diff="del" at="M">non-recoverable</phrase>
                        dynamic error</termref>
                     <xerrorref spec="XP30" class="DY" code="0002"/></p>
                  <p>The description above gives an outline of the way the <termref def="dt-focus"
                        >focus</termref> works. Detailed rules for the effect of each instruction
                     are given separately with the description of that instruction. In the absence
                     of specific rules, an instruction uses the same focus as its parent
                     instruction. </p>
                  <p>
                     <termdef id="dt-singleton-focus" term="singleton focus">A <term>singleton
                           focus</term> based on an item <var>J</var> has the <phrase diff="chg"
                           at="F"><termref def="dt-context-item">context item</termref> (and
                           therefore the <termref def="dt-context-node">context node</termref>, if
                              <var>J</var> is a node)</phrase> set to <var>J</var>, and the <termref
                           def="dt-context-position">context position</termref> and <termref
                           def="dt-context-size">context size</termref> both set to 1
                        (one).</termdef>
                  </p>
               </div4>
               <div4 id="evaluation-context">
                  <head>Other Components of the XPath Dynamic Context</head>
                  <p>The previous section explained how the <termref def="dt-focus">focus</termref>
                     for an XPath expression appearing in an XSLT stylesheet is initialized. This
                     section explains how the other components of the <xtermref spec="XP30"
                        ref="dt-dynamic-context">dynamic context</xtermref> of an XPath expression
                     are initialized.</p>
                  <ulist>
                     <item>
                        <p>The <xtermref spec="XP30" ref="dt-variable-values">dynamic
                              variables</xtermref> are the current values of the in-scope <termref
                              def="dt-variable-binding-element">variable binding
                           elements</termref>.</p>
                     </item>
                     <item>
                        <p diff="add" at="T-bug30049">The <xtermref spec="XP30"
                              ref="dt-named-functions">named functions</xtermref> (representing the
                           functions accessible using <function>function-available</function> or
                              <xfunction>function-lookup</xfunction>) include all the functions
                           available in the static context, and may also include an additional
                              <termref def="dt-implementation-defined"/> set of functions that are
                           available dynamically but not statically. </p>
                        <note diff="add" at="T-bug30049">
                           <p>This set therefore includes some functions that are not available for
                              dynamic calling using <elcode>xsl:evaluate</elcode>, for example
                                 <termref def="dt-stylesheet-function">stylesheet
                                 functions</termref> whose visibility is private, and XSLT-defined
                              functions such as <function>current</function> and
                                 <function>key</function>.</p>
                        </note>
                        <note diff="add" at="T-bug30049">
                           <p>The rule that all functions present in the static context must always
                              be present in the dynamic context is a consistency constraint. The
                              effect of violating a consistency constraint is <termref
                                 def="dt-implementation-defined"/>: it does not necessarily lead to
                              an error. For example, if the version of a used package that is
                              available at evaluation time does not include all public user-defined
                              functions that were available in the version that was used at analysis
                              time, then a processor <rfc2119>may</rfc2119> recover by signaling an
                              error only if the function is actually called. Conversely, if the
                              evaluation-time version of the package includes additional public
                              functions, these <rfc2119>may</rfc2119> be included in the dynamic
                              context even though they were absent from the static context. Dynamic
                              calling of functions using <xfunction>function-lookup</xfunction> may
                              therefore be an effective strategy for coping with variations between
                              versions of a library package on which a stylesheet depends.</p>
                        </note>
                     </item>
                     <item>
                        <p>The <xtermref spec="XP30" ref="dt-known-docs">available
                              documents</xtermref> are defined as part of the <phrase diff="chg"
                              at="F">XPath 3.0</phrase> dynamic context to support the
                              <xfunction>doc</xfunction> function, but this component is also
                           referenced by the similar XSLT <function>document</function> function:
                           see <specref ref="func-document"/>. This variable defines a mapping
                           between URIs passed to the <xfunction>doc</xfunction> or
                              <function>document</function> function and the document nodes that are
                           returned.</p>
                        <p diff="add" at="P-bug22663">The mapping from URIs to document nodes is
                           affected by <elcode>xsl:strip-space</elcode> declarations and by the
                              <code>input-type-annotations</code> attribute, and may therefore vary
                           from one package to another.</p>
                        <note>
                           <p>Defining this as part of the evaluation context is a formal way of
                              specifying that the way in which URIs get turned into document nodes
                              is outside the control of the language specification, and depends
                              entirely on the run-time environment in which the transformation takes
                              place.</p>
                        </note>
                        <p>The XSLT-defined <function>document</function> function allows the use of
                           URI references containing fragment identifiers. The interpretation of a
                           fragment identifier depends on the media type of the resource
                           representation. Therefore, the information supplied in <xtermref
                              spec="XP30" ref="dt-known-docs">available documents</xtermref> for
                           XSLT processing must provide not only a mapping from URIs to document
                           nodes as required by XPath, but also a mapping from URIs to media
                           types.</p>
                     </item>
                     <item>
                        <p diff="add" at="T-bug30049">All other aspects of the dynamic context (for
                           example, the current date and time, the implicit timezone, the default
                           language, calendar, and place, the available documents, text resources,
                           and collections, and the default collection — details vary slightly
                           between XPath 3.0 and XPath 3.1) are <termref
                              def="dt-implementation-defined"/>, and do not change in the course of
                           a single transformation, except to the extent that they
                              <rfc2119>may</rfc2119> be different from one <termref def="dt-package"
                           /> to another.</p>
                     </item>
                  </ulist>
               </div4>
            </div3>
            <div3 id="additional-dynamic-context">
               <head>Additional Dynamic Context Components used by XSLT</head>
               <p>In addition to the values that make up the <termref def="dt-focus"
                  >focus</termref>, an XSLT processor maintains a number of other dynamic context
                  components that reflect aspects of the evaluation context. These components are
                  fully described in the sections of the specification that maintain and use them.
                  They are:</p>
               <ulist>
                  <item>
                     <p>The <termref def="dt-current-template-rule">current template rule</termref>,
                        which is the <termref def="dt-template-rule">template rule</termref> most
                        recently invoked by an <elcode>xsl:apply-templates</elcode>,
                           <elcode>xsl:apply-imports</elcode>, or <elcode>xsl:next-match</elcode>
                        instruction: see <specref ref="apply-imports"/>; </p>
                  </item>
                  <item>
                     <p>The <termref def="dt-current-mode">current mode</termref>, which is the
                           <termref def="dt-mode">mode</termref> set by the most recent call of
                           <elcode>xsl:apply-templates</elcode> (for a full definition see <specref
                           ref="modes"/>);</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-current-group">current group</termref> and <termref
                           def="dt-current-grouping-key">current grouping key</termref>, which
                        provide information about the collection of items currently being processed
                        by an <elcode>xsl:for-each-group</elcode>
                        <phrase diff="del" at="R-bug24510">or <elcode>xsl:merge</elcode></phrase>
                        instruction: see <specref ref="func-current-group"/> and <specref
                           ref="func-current-grouping-key"/><phrase diff="del" at="R-bug24510">, and
                              <specref ref="merging"/></phrase>;</p>
                     <note>
                        <p>In XSLT 3.0 the initial value of these two properties is “absent”, which
                           means that any reference to their values causes a dynamic error.
                           Previously, the initial value was an empty sequence. <phrase diff="del"
                              at="R-bug24510">The value is also set to “absent” by an
                                 <elcode>xsl:for-each-group</elcode> instruction that binds
                              variables to the <termref def="dt-current-group"/> and/or <termref
                                 def="dt-current-grouping-key"/> using the <code>bind-group</code>
                              or <code>bind-grouping-key</code> attributes.</phrase></p>
                     </note>
                  </item>
                  <item diff="add" at="R-bug24510">
                     <p>The <termref def="dt-current-merge-group"/> and <termref
                           def="dt-current-merge-key"/>, which provide information about the
                        collection of items currently being processed by an
                           <elcode>xsl:merge</elcode> instruction.</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-current-captured-substrings">current captured
                           substrings</termref>: this is a sequence of strings, which is maintained
                        when a string is matched against a regular expression using the
                           <elcode>xsl:analyze-string</elcode> instruction, and which is accessible
                        using the <function>regex-group</function> function: see <specref
                           ref="func-regex-group"/>.</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-output-state">output state</termref>: this is a flag
                        whose two possible values are <termref def="dt-final-output-state">final
                           output state</termref> and <termref def="dt-temporary-output-state"
                           >temporary output state</termref>. <phrase diff="del" at="S-bug27258"
                           >This flag indicates whether instructions are currently writing to a
                              <termref def="dt-final-result-tree">final result tree</termref> or to
                           an internal data structure.</phrase> The initial setting <phrase
                           diff="add" at="R">when the stylesheet is invoked by executing a
                           template</phrase> is <termref def="dt-final-output-state">final output
                           state</termref>, and it is switched to <termref
                           def="dt-temporary-output-state">temporary output state</termref> by
                        instructions such as <elcode>xsl:variable</elcode>. For more details, see
                           <specref ref="result-document-restrictions"/>.</p>
                  </item>
                  <item diff="add" at="R-bug24551">
                     <p>The <termref def="dt-current-output-uri">current output URI</termref>: this
                        is the URI associated with the result tree to which instructions are
                        currently writing. The current output URI is initially the same as the
                           <termref def="dt-base-output-uri"/>. During the evaluation of an
                           <elcode>xsl:result-document</elcode> instruction, the current output URI
                        is set to the absolute URI identified by the <code>href</code> attribute of
                        that instruction.</p>
                  </item>
               </ulist>
               <p>The following non-normative table summarizes the initial state of each of the
                  components in the evaluation context, and the instructions which cause the state
                  of the component to change.</p>
               <table class="data">
                  <caption>Components of the Dynamic Evaluation Context</caption>
                  <thead>
                     <tr>
                        <th align="left" rowspan="1" colspan="1">Component</th>
                        <th align="left" rowspan="1" colspan="1">Initial Setting</th>
                        <th align="left" rowspan="1" colspan="1">Set by</th>
                        <th align="left" rowspan="1" colspan="1">Cleared by</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-focus">focus</termref>
                        </td>
                        <td valign="top" diff="chg" at="R-bug25611" rowspan="1" colspan="1">See
                              <specref ref="initiating"/>.</td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:apply-templates</elcode>, <elcode>xsl:for-each</elcode>,
                              <elcode>xsl:for-each-group</elcode>,
                              <elcode>xsl:analyze-string</elcode>, <phrase diff="add" at="M"
                              >evaluation of <termref def="dt-pattern">patterns</termref></phrase>
                        </td>
                        <td valign="top" rowspan="1" colspan="1"><phrase diff="chg" at="Q-bug23631"
                              >Calls to <termref def="dt-stylesheet-function">stylesheet
                                 functions</termref></phrase>
                        </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-template-rule">current template rule</termref>
                        </td>
                        <td valign="top" diff="chg" at="T-bug29716" rowspan="1" colspan="1">If
                           apply-templates invocation is used (see <specref
                              ref="invoking-initial-mode"/>), then for each item in the <termref
                              def="dt-initial-match-selection"/>, the <termref
                              def="dt-current-template-rule"/> is initially set to the template rule
                           chosen for processing that item. Otherwise, <termref def="dt-absent"/>. </td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>,
                              <elcode>xsl:next-match</elcode>
                        </td>
                        <td valign="top" rowspan="1" colspan="1"><phrase diff="chg" at="T-bug29716"
                              >See <specref ref="apply-imports"/>.</phrase>
                        </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-mode">current mode</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">the initial <termref def="dt-mode"
                              >mode</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:apply-templates</elcode>
                        </td>
                        <td valign="top" rowspan="1" colspan="1"><phrase diff="chg" at="Q-bug23631"
                              >Calls to <termref def="dt-stylesheet-function">stylesheet
                                 functions</termref></phrase>. Also cleared while evaluating global
                           variables and stylesheet parameters, <phrase diff="add" at="M"><termref
                                 def="dt-pattern">patterns</termref></phrase>, and the sequence
                           constructor contained in <elcode>xsl:key</elcode> or
                              <elcode>xsl:sort</elcode>. Clearing the current mode causes the
                           current mode to be set to the default (unnamed) mode.</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-group">current group</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1"><phrase diff="chg" at="K"
                              >absent</phrase></td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:for-each-group</elcode><phrase diff="del" at="R-bug24510">,
                                 <elcode>xsl:merge</elcode></phrase>
                        </td>
                        <td valign="top" rowspan="1" colspan="1"><phrase diff="chg" at="Q-bug23631"
                              >See <specref ref="func-current-group"/>.</phrase></td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-grouping-key">current grouping key</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1"><phrase diff="chg" at="K"
                              >absent</phrase></td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:for-each-group</elcode><phrase diff="del" at="R-bug24510">,
                                 <elcode>xsl:merge</elcode></phrase>
                        </td>
                        <td valign="top" rowspan="1" colspan="1"><phrase diff="chg" at="Q-bug23631"
                              >See <specref ref="func-current-grouping-key"/>.</phrase></td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-merge-group"><phrase diff="add" at="R-bug24510"
                                 >current merge group</phrase></termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1"><phrase diff="add" at="R-bug24510"
                              >absent</phrase></td>
                        <td valign="top" rowspan="1" colspan="1">
                           <phrase diff="add" at="R-bug24510"><elcode>xsl:merge</elcode></phrase>
                        </td>
                        <td valign="top" rowspan="1" colspan="1"><phrase diff="add" at="R-bug24510"
                              >See <specref ref="func-current-merge-group"/>.</phrase></td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <phrase diff="add" at="R-bug24510"><termref def="dt-current-merge-key"
                                 >current merge key</termref></phrase>
                        </td>
                        <td valign="top" diff="add" at="R-bug24510" rowspan="1" colspan="1"
                              ><phrase>absent</phrase></td>
                        <td valign="top" rowspan="1" colspan="1">
                           <phrase diff="add" at="R-bug24510"><elcode>xsl:merge</elcode></phrase>
                        </td>
                        <td valign="top" rowspan="1" colspan="1"><phrase diff="add" at="R-bug24510"
                              >See <specref ref="func-current-merge-key"/>.</phrase></td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-captured-substrings">current captured
                              substrings</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">empty sequence</td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:matching-substring</elcode>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:non-matching-substring</elcode>; <phrase diff="chg"
                              at="Q-bug23631">Calls to <termref def="dt-stylesheet-function"
                                 >stylesheet functions</termref>, dynamic function calls</phrase>,
                              <phrase diff="add" at="M">evaluation of global variables, stylesheet
                              parameters, and <termref def="dt-pattern">patterns</termref></phrase>
                        </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-output-state">output state</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-final-output-state">final output state</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">Set to <termref
                              def="dt-temporary-output-state">temporary output state</termref> by
                           instructions such as <elcode>xsl:variable</elcode>,
                              <elcode>xsl:attribute</elcode>, etc., and by calls on <termref
                              def="dt-stylesheet-function">stylesheet functions</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">None</td>
                     </tr>
                     <tr diff="add" at="R-bug24551">
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-output-uri">current output URI</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-base-output-uri">base output URI</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1"
                              ><elcode>xsl:result-document</elcode></td>
                        <td valign="top" rowspan="1" colspan="1">Calls to <termref
                              def="dt-stylesheet-function">stylesheet functions</termref>, dynamic
                           function calls, evaluation of <termref def="dt-global-variable">global
                              variables</termref>, <termref def="dt-stylesheet-parameter">stylesheet
                              parameters</termref>, and <termref def="dt-pattern"
                           >patterns</termref>.</td>
                     </tr>
                  </tbody>
               </table>
               <p diff="add" at="R-bug26751"><termdef id="dt-initial-setting" term="initial setting"
                     >The <term>initial setting</term> of a component of the dynamic context is used
                     when evaluating <termref def="dt-global-variable">global variables</termref>
                     and <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>,
                     when evaluating the <code>use</code> and <code>match</code> attributes of
                        <elcode>xsl:key</elcode>, and when evaluating the <code>initial-value</code>
                     of <elcode>xsl:accumulator</elcode> and the <code>select</code> expressions or
                     contained sequence constructors of
                     <elcode>xsl:accumulator-rule</elcode></termdef>.</p>
               <p diff="add" at="D"><termdef id="dt-non-contextual-function-call"
                     term="non-contextual function call">The term <term>non-contextual function
                        call</term> is used to refer to function calls that do not pass the dynamic
                     context to the called function. This includes all calls on <termref
                        def="dt-stylesheet-function">stylesheet functions</termref> and all
                        <xtermref spec="XP30" ref="dt-dynamic-function-invocation">dynamic function
                        invocations</xtermref>, (that is calls to function items as permitted by
                     XPath 3.0). <phrase diff="chg" at="R-bug24970">It excludes calls to some
                        functions in the namespace
                           <code>http://www.w3.org/2005/xpath-functions</code></phrase>, in
                     particular those that explicitly depend on the context, such as the
                        <function>current-group</function> and <function>regex-group</function>
                     functions. It is <termref def="dt-implementation-defined"
                        >implementation-defined</termref> whether, and under what circumstances,
                     calls to <termref def="dt-extension-function">extension functions</termref> are
                     non-contextual.</termdef></p>
               <imp-def-feature id="id-ext-accesstoconttext">The availability of dynamic context
                  information within <termref def="dt-extension-function">extension
                     functions</termref> is <termref def="dt-implementation-defined"
                     >implementation-defined</termref>.</imp-def-feature>
               <p diff="add" at="Q">Named function references (such as <code>position#0</code>) and
                  calls on <xfunction>function-lookup</xfunction> (for example,
                     <code>function-lookup("position", 0)</code>) are defined to retain the XPath
                  static and dynamic context at the point of invocation as part of the closure of
                  the resulting function item, and to use this preserved context when a dynamic
                  function call is subsequently made using the function item. This rule does not
                  extend to the XSLT extensions to the dynamic context defined in this section. If a
                  dynamic function call is made that depends on the XSLT part of the dynamic context
                  (for example, <code>regex-group#1(2)</code>), then the relevant components of the
                  context are cleared as described in the table above. </p>
               <note diff="del" at="M">
                  <p>A contextual function call such as <code>current-group()</code> cannot be used
                     in a dynamic function invocation: it is not possible to form a function item
                     such as <code>current-group#0</code>.</p>
               </note>
            </div3>
         </div2>
         <div2 id="defining-decimal-format">
            <head>Defining a Decimal Format</head>
            <p diff="chg" at="D">The definition of the <xfunction>format-number</xfunction> function
               is now in <bibref ref="xpath-functions-30"/>. What remains here is the definition of
               the <elcode>xsl:decimal-format</elcode> declaration, which provides the context for
               this function when used in an XSLT stylesheet.</p>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="decimal-format">
               <e:in-category name="declaration"/>
               <e:attribute name="name">
                  <e:data-type name="eqname"/>
               </e:attribute>
               <e:attribute name="decimal-separator">
                  <e:data-type name="char"/>
               </e:attribute>
               <e:attribute name="grouping-separator">
                  <e:data-type name="char"/>
               </e:attribute>
               <e:attribute name="infinity">
                  <e:data-type name="string"/>
               </e:attribute>
               <e:attribute name="minus-sign">
                  <e:data-type name="char"/>
               </e:attribute>
               <e:attribute name="exponent-separator">
                  <e:data-type name="char"/>
               </e:attribute>
               <e:attribute name="NaN">
                  <e:data-type name="string"/>
               </e:attribute>
               <e:attribute name="percent">
                  <e:data-type name="char"/>
               </e:attribute>
               <e:attribute name="per-mille">
                  <e:data-type name="char"/>
               </e:attribute>
               <e:attribute name="zero-digit">
                  <e:data-type name="char"/>
               </e:attribute>
               <e:attribute name="digit">
                  <e:data-type name="char"/>
               </e:attribute>
               <e:attribute name="pattern-separator">
                  <e:data-type name="char"/>
               </e:attribute>
               <e:empty/>
               <e:allowed-parents>
                  <e:parent name="package"/>
                  <e:parent name="stylesheet"/>
                  <e:parent name="transform"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:decimal-format</elcode> element <phrase diff="add" at="O">sets the
                     <term>statically known decimal formats</term> component of the static context
                  for XPath expressions, which</phrase> controls the interpretation of a <termref
                  def="dt-picture-string">picture string</termref> used by the
                  <xfunction>format-number</xfunction> function.</p>
            <p><termdef id="dt-picture-string" term="picture string">The <term>picture string</term>
                  is the string supplied as the second argument of the
                     <xfunction>format-number</xfunction> function.</termdef>
            </p>
            <note diff="add" at="D">
               <p>The <xfunction>format-number</xfunction> function, previously defined in this
                  specification, is now defined in <bibref ref="xpath-functions-30"/>. </p>
            </note>
            <p>A <phrase diff="chg" at="I"><termref def="dt-package">package</termref></phrase> may
               contain multiple <elcode>xsl:decimal-format</elcode> declarations and may include or
               import <termref def="dt-stylesheet-module">stylesheet modules</termref> that also
               contain <elcode>xsl:decimal-format</elcode> declarations. The name of an
                  <elcode>xsl:decimal-format</elcode> declaration is the value of its
                  <code>name</code> attribute, if any.</p>
            <p>
               <termdef id="dt-decimal-format" term="decimal format">All the
                     <elcode>xsl:decimal-format</elcode> declarations in a <phrase diff="chg" at="I"
                     >package</phrase> that share the same name are grouped into a named
                     <term>decimal format</term>; those that have no name are grouped into a single
                  unnamed decimal format.</termdef>
            </p>
            <p diff="add" at="O"> The attributes of the <elcode>xsl:decimal-format</elcode>
               declaration define the value of the corresponding property in the relevant decimal
               format in the <xtermref spec="XP30" ref="dt-static-decimal-formats">statically known
                  decimal formats</xtermref> component of the static context for all XPath
               expressions in the package. The attribute names used in the XSLT 3.0 syntax are the
               same as the property names used in the definition of the static context. </p>
            <p diff="add" at="R-bug24266"> The <code>exponent-separator</code> attribute is provided
               for use with XPath 3.1. It has no effect when used with XPath 3.0. </p>
            <p diff="add" at="I">The scope of an <elcode>xsl:decimal-format</elcode> name is the
               package in which it is declared; the name is available for use only in calls to
                  <xfunction>format-number</xfunction> that appear within the same package.</p>
            <p>If a <termref def="dt-package">package</termref> does not contain a declaration of
               the unnamed decimal format, a declaration equivalent to an
                  <elcode>xsl:decimal-format</elcode> element with no attributes is implied.</p>
            <p>The attributes of the <elcode>xsl:decimal-format</elcode> declaration establish
               values for a number of variables used as input to the algorithm followed by the
                  <xfunction>format-number</xfunction> function. An outline of the purpose of each
               attribute is given below; however, the definitive explanations are given <phrase
                  diff="chg" at="D">as part of the specification of
                     <xfunction>format-number</xfunction></phrase>.</p>
            <p>For any named <termref def="dt-decimal-format">decimal format</termref>, the
               effective value of each attribute is taken from an
                  <elcode>xsl:decimal-format</elcode> declaration that has that name, and that
               specifies an explicit value for the required attribute. If there is no such
               declaration, the default value of the attribute is used. If there is more than one
               such declaration, the one with highest <termref def="dt-import-precedence">import
                  precedence</termref> is used.</p>
            <p>For any unnamed <termref def="dt-decimal-format">decimal format</termref>, the
               effective value of each attribute is taken from an
                  <elcode>xsl:decimal-format</elcode> declaration that is unnamed, and that
               specifies an explicit value for the required attribute. If there is no such
               declaration, the default value of the attribute is used. If there is more than one
               such declaration, the one with highest <termref def="dt-import-precedence">import
                  precedence</termref> is used.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="1290"><p>It is a <termref
                        def="dt-static-error">static error</termref> if a named or unnamed <termref
                        def="dt-decimal-format">decimal format</termref> contains two conflicting
                     values for the same attribute in different <elcode>xsl:decimal-format</elcode>
                     declarations having the same <termref def="dt-import-precedence">import
                        precedence</termref>, unless there is another definition of the same
                     attribute with higher import precedence.</p></error>
            </p>
            <p>The following attributes control the interpretation of characters in the <termref
                  def="dt-picture-string">picture string</termref> supplied to the
                  <xfunction>format-number</xfunction> function, and also specify characters that
               may appear in the result of formatting the number. In each case the value
                  <rfc2119>must</rfc2119> be a single character <errorref class="SE" code="0020"
               />.</p>
            <ulist>
               <item>
                  <p>
                     <code>decimal-separator</code> specifies the character used to separate the
                     integer part from the fractional part of the formatted number; the default
                     value is the period character (<code>.</code>)</p>
               </item>
               <item>
                  <p>
                     <code>grouping-separator</code> specifies the character typically used as a
                     thousands separator; the default value is the comma character
                     (<code>,</code>)</p>
               </item>
               <item>
                  <p>
                     <code>percent</code> specifies the character used to indicate that the number
                     is represented as a per-hundred fraction; the default value is the percent
                     character (<code>%</code>)</p>
               </item>
               <item>
                  <p>
                     <code>per-mille</code> specifies the character used to indicate that the number
                     is represented as a per-thousand fraction; the default value is the Unicode
                     per-mille character (#x2030)</p>
               </item>
               <item>
                  <p>
                     <code>zero-digit</code> specifies the character used to represent the digit
                     zero; the default value is the Western digit zero (<code>0</code>). This
                     character <rfc2119>must</rfc2119> be a digit (category <code>Nd</code> in the
                     Unicode property database), and it <rfc2119>must</rfc2119> have the numeric
                     value zero. This attribute implicitly defines the Unicode character that is
                     used to represent each of the values 0 to 9 in the final result string: Unicode
                     is organized so that each set of decimal digits forms a contiguous block of
                     characters in numerical sequence.</p>
               </item>
            </ulist>
            <p>
               <error spec="XT" type="static" class="SE" code="1295"><p>It is a <termref
                        def="dt-static-error">static error</termref> if the character specified in
                     the <code>zero-digit</code> attribute is not a digit or is a digit that does
                     not have the numeric value zero. </p></error>
            </p>
            <p>The following attributes control the interpretation of characters in the <termref
                  def="dt-picture-string">picture string</termref> supplied to the
                  <xfunction>format-number</xfunction> function. In each case the value
                  <rfc2119>must</rfc2119> be a single character <errorref class="SE" code="0020"
               />.</p>
            <ulist>
               <item>
                  <p>
                     <code>digit</code> specifies the character used in the <termref
                        def="dt-picture-string">picture string</termref> as a place-holder for an
                     optional digit; the default value is the number sign character
                     (<code>#</code>)</p>
               </item>
               <item>
                  <p>
                     <code>pattern-separator</code> specifies the character used to separate
                     positive and negative sub-pictures in a <termref def="dt-picture-string"
                        >picture string</termref>; the default value is the semi-colon character
                        (<code>;</code>)</p>
               </item>
            </ulist>
            <p>The following attributes specify characters or strings that may appear in the result
               of formatting the number:</p>
            <ulist>
               <item>
                  <p>
                     <code>infinity</code> specifies the string used to represent the
                        <code>xs:double</code> value <code>INF</code>; the default value is the
                     string <code>Infinity</code>
                  </p>
               </item>
               <item>
                  <p>
                     <code>NaN</code> specifies the string used to represent the
                        <code>xs:double</code> value <code>NaN</code> (not-a-number); the default
                     value is the string <code>NaN</code>
                  </p>
               </item>
               <item>
                  <p>
                     <code>minus-sign</code> specifies the character used to signal a negative
                     number; the default value is the hyphen-minus character (<code>-</code>, #x2D).
                     The value <rfc2119>must</rfc2119> be a single character.</p>
               </item>
            </ulist>
            <p>
               <error spec="XT" type="static" class="SE" code="1300"><p>It is a <termref
                        def="dt-static-error">static error</termref> if, for any named or unnamed
                     decimal format, the variables representing characters used in a <termref
                        def="dt-picture-string">picture string</termref> do not each have distinct
                     values. These variables are <var>decimal-separator-sign</var>,
                        <var>grouping-sign</var>, <var>percent-sign</var>,
                     <var>per-mille-sign</var>, <var>digit-zero-sign</var>, <var>digit-sign</var>,
                     and <var>pattern-separator-sign</var>.</p></error>
            </p>
            <p diff="add" at="I">Every (named or unnamed) decimal format defined in a <termref
                  def="dt-stylesheet">package</termref> is added to the <xtermref spec="XP30"
                  ref="dt-static-decimal-formats">statically known decimal formats</xtermref> in the
                  <xtermref spec="XP30" ref="dt-static-context">static context</xtermref> of every
               expression in the <termref def="dt-package">package</termref>, excluding expressions
               appearing in <code>[xsl:]use-when</code> attributes.</p>
         </div2>
         <div2 id="patterns">
            <head>Patterns</head>
            <p diff="add" at="C">In XSLT 3.0, patterns can match any kind of item: atomic values and
               function items as well as nodes.</p>
            <p>A <termref def="dt-template-rule">template rule</termref> identifies the <phrase
                  diff="chg" at="C">items</phrase> to which it applies by means of a pattern. As
               well as being used in template rules, patterns are used for numbering (see <specref
                  ref="number"/>), for grouping (see <specref ref="grouping"/>), and for declaring
                  <termref def="dt-key">keys</termref> (see <specref ref="key"/>).</p>
            <p><termdef id="dt-pattern" term="pattern">A <term>pattern</term> specifies a set of
                  conditions on an <phrase diff="chg" at="C">item</phrase>. An <phrase diff="chg"
                     at="C">item</phrase> that satisfies the conditions matches the pattern; an
                     <phrase diff="chg" at="C">item</phrase> that does not satisfy the conditions
                  does not match the pattern.</termdef></p>
            <p diff="chg" at="R-bug24540">There are two kinds of pattern: <termref
                  def="dt-predicate-pattern">predicate patterns</termref>, and <termref
                  def="dt-selection-pattern">selection patterns</termref>:</p>
            <ulist>
               <item>
                  <p diff="add" at="R-bug24540"><termdef id="dt-predicate-pattern"
                        term="predicate pattern">A <term>predicate pattern</term> is written as
                           <code>.</code> (dot) followed by zero or more predicates in square
                        brackets, and it matches any item for which each of the predicates evaluates
                        to <code>true</code>.</termdef></p>
                  <p diff="add" at="R-bug24540">The detailed semantics are given in <specref
                        ref="pattern-semantics"/>. This construct can be used to match items of any
                     kind (nodes, atomic values, and function items). For example, the pattern
                        <code>.[starts-with(., '$')]</code> matches any string that starts with the
                     character "$", or a node whose atomized value starts with "$". This example
                     shows a predicate pattern with a single predicate, but the grammar allows any
                     number of predicates (zero or more).</p>
               </item>
               <item>
                  <p diff="add" at="R-bug24540"><termdef id="dt-selection-pattern"
                        term="selection pattern">A <term>selection pattern</term> uses a subset of
                        the syntax for path expressions, and is defined to match a node if the
                        corresponding path expression would select the node. Selection patterns may
                        also be formed by combining other patterns using union, intersection, and
                        difference operators.</termdef></p>
                  <p>The syntax for <phrase diff="chg" at="R-bug24540">selection</phrase> patterns
                        <phrase diff="add" at="R-bug24540">(<code>UnionExprP</code> in the grammar:
                        see <specref ref="pattern-syntax"/>)</phrase> is a subset of the syntax for
                        <termref def="dt-expression">expressions</termref>. <phrase diff="add"
                        at="C"><phrase diff="chg" at="R-bug24540">Selection</phrase> patterns are
                        used only for matching nodes; an item other than a node will never match a
                           <phrase diff="chg" at="R-bug24540">selection</phrase> pattern.</phrase>
                     As explained in detail below, a node matches a <phrase diff="chg"
                        at="R-bug24540">selection</phrase> pattern if the node can be selected by
                     deriving an equivalent expression, and evaluating this expression with respect
                     to some possible context.</p>
               </item>
            </ulist>
            <p diff="del" at="N">A type pattern is written with a leading <code>~</code> (tilde)
               followed by an <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                  ref="prod-xpath30-ItemType" xlink:type="simple">ItemType</xnt> and an optional
               list of predicates: for example, <code>~xs:anyAtomicValue</code> matches any atomic
               value, <code>~xs:integer[. mod 2 = 0]</code> matches any even integer,
                  <code>~node()</code> matches any node, and
                  <code>~function(*)[empty(function-name(.))]</code> matches any function item that
               refers to an anonymous function. An item matches a type pattern if and only if the
               item is an instance of the specified type and satisfies all the predicates. </p>
            <note>
               <p>The specification uses the phrases <emph>an item matches a pattern</emph> and
                     <emph>a pattern matches an item</emph> interchangeably. They are equivalent: an
                  item matches a pattern if and only if the pattern matches the item.</p>
            </note>
            <div3 id="pattern-examples">
               <head>Examples of Patterns</head>
               <example id="pattern-examples-1">
                  <head>Patterns</head>
                  <p>Here are some examples of patterns:</p>
                  <ulist>
                     <item>
                        <p diff="add" at="O"><code>.</code> matches any item.</p>
                     </item>
                     <item>
                        <p><code>*</code> matches any element.</p>
                     </item>
                     <item>
                        <p><code>para</code> matches any <code>para</code> element.</p>
                     </item>
                     <item>
                        <p><code>chapter|appendix</code> matches any <code>chapter</code> element
                           and any <code>appendix</code> element.</p>
                     </item>
                     <item>
                        <p><code>olist/entry</code> matches any <code>entry</code> element with an
                              <code>olist</code> parent.</p>
                     </item>
                     <item>
                        <p><code>appendix//para</code> matches any <code>para</code> element with an
                              <code>appendix</code> ancestor element.</p>
                     </item>
                     <item>
                        <p><code>schema-element(us:address)</code> matches any element that is
                           annotated as an instance of the type defined by the schema element
                           declaration <code>us:address</code>, and whose name is either
                              <code>us:address</code> or the name of another element in its
                           substitution group. </p>
                     </item>
                     <item>
                        <p><code>attribute(*, xs:date)</code> matches any attribute annotated as
                           being of type <code>xs:date</code>.</p>
                     </item>
                     <item>
                        <p><code>/</code> matches a document node.</p>
                     </item>
                     <item>
                        <p><code>document-node()</code> matches a document node.</p>
                     </item>
                     <item>
                        <p><code>document-node(schema-element(my:invoice))</code> matches the
                           document node of a document whose document element is named
                              <code>my:invoice</code> and matches the type defined by the global
                           element declaration <code>my:invoice</code>.</p>
                     </item>
                     <item>
                        <p><code>text()</code> matches any text node.</p>
                     </item>
                     <item>
                        <p diff="add" at="C"><code>namespace-node()</code> matches any namespace
                           node.</p>
                     </item>
                     <item>
                        <p><code>node()</code> matches any node other than an attribute node,
                           namespace node, or document node.</p>
                     </item>
                     <item>
                        <p><code>id("W33")</code> matches the element with unique ID
                              <code>W33</code>. </p>
                     </item>
                     <item>
                        <p><code>para[1]</code> matches any <code>para</code> element that is the
                           first <code>para</code> child element of its parent. It also matches a
                           parentless <code>para</code> element.</p>
                     </item>
                     <item>
                        <p><code>//para</code> matches any <code>para</code> element <phrase
                              diff="del" at="V-bug30093">that has a parent node</phrase><phrase
                              diff="add" at="V-bug30093">in a tree that is rooted at a document
                              node</phrase>.</p>
                     </item>
                     <item>
                        <p><code>bullet[position() mod 2 = 0]</code> matches any <code>bullet</code>
                           element that is an even-numbered <code>bullet</code> child of its
                           parent.</p>
                     </item>
                     <item>
                        <p><code>div[@class="appendix"]//p</code> matches any <code>p</code> element
                           with a <code>div</code> ancestor element that has a <code>class</code>
                           attribute with value <code>appendix</code>. </p>
                     </item>
                     <item>
                        <p><code>@class</code> matches any <code>class</code> attribute
                              (<emph>not</emph> any element that has a <code>class</code>
                           attribute).</p>
                     </item>
                     <item>
                        <p><code>@*</code> matches any attribute node.</p>
                     </item>
                     <item>
                        <p diff="add" at="C"><code>$xyz</code> matches any node that is present in
                           the value of the variable <code>$xyz</code>.</p>
                     </item>
                     <item>
                        <p diff="add" at="C"><code>$xyz//*</code> matches any element that is a
                           descendant of a node that is present in the value of the variable
                              <code>$xyz</code>.</p>
                     </item>
                     <item>
                        <p diff="add" at="C"><code>doc('product.xml')//*</code> matches any element
                           within the document whose document URI is 'product.xml'.</p>
                     </item>
                     <item>
                        <p diff="chg" at="O"><code>.[. instance of node()]</code> matches any node.
                           (Note the distinction from the pattern <code>node()</code>.)</p>
                     </item>
                     <item>
                        <p diff="chg" at="O"><code>.[. instance of xs:date]</code> matches any
                           atomic value of type <code>xs:date</code> (or a type derived by
                           restriction from <code>xs:date</code>).</p>
                     </item>
                     <item>
                        <p diff="chg" at="O"><code>.[. gt current-date()]</code> matches any date in
                           the future. It can match an atomic value of type <code>xs:date</code> or
                              <code>xs:untypedAtomic</code>, or a node whose atomized value is an
                              <code>xs:date</code> or <code>xs:untypedAtomic</code> value.</p>
                     </item>
                     <item>
                        <p diff="chg" at="O"><code>.[starts-with(., 'e')]</code> matches any node or
                           atomic value that after conversion to a string using the function
                           conversion rules starts with the letter 'e'.</p>
                     </item>
                     <item>
                        <p diff="chg" at="O"><code>.[. instance of function(*)]</code> matches any
                           function item.</p>
                     </item>
                     <item>
                        <p diff="add" at="O"><code>.[$f(.)]</code> matches any item provided that
                           the call on the function bound to the variable <code>$f</code> returns a
                           result whose effective boolean value is true.</p>
                     </item>
                  </ulist>
               </example>
            </div3>
            <div3 id="pattern-syntax">
               <head>Syntax of Patterns</head>
               <p>
                  <error spec="XT" type="static" class="SE" code="0340"><p>Where an attribute is
                        defined to contain a <termref def="dt-pattern">pattern</termref>, it is a
                           <termref def="dt-static-error">static error</termref> if the pattern does
                        not match the production <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                           def="doc-xslt30-patterns-Pattern30" xlink:type="simple"
                        >Pattern30</nt>.</p></error></p>
               <p diff="add" at="C">The grammar for patterns uses the notation defined in <xspecref
                     spec="XP30" ref="EBNFNotation">Notation</xspecref>. </p>
               <p diff="add" at="C">The lexical rules for patterns are the same as the lexical rules
                  for XPath expressions, as defined in <xspecref spec="XP30" ref="lexical-structure"
                     >Lexical structure</xspecref>. Comments are permitted between tokens, using the
                  syntax <code>(: ... :)</code>. All other provisions of the XPath grammar apply
                  where relevant, for example the rules for whitespace handling and
                  extra-grammatical constraints.</p>
               <p diff="del" at="C"> Every pattern is a valid XPath <termref def="dt-expression"
                     >expression</termref>, but the converse is not true: <code>2+2</code> is an
                  example of a valid XPath expression that is not a pattern. The XPath expressions
                  that can be used as patterns are those that match the grammar for <nt
                     xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xslt30-patterns-Pattern30"
                     xlink:type="simple">Pattern</nt>, given below.</p>
               <p diff="del" at="C">Informally, a <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                     def="doc-xslt30-patterns-Pattern30" xlink:type="simple">Pattern</nt> is a set
                  of path expressions separated by <code>|</code>, where each step in the path
                  expression is constrained to be an <xnt xmlns:xlink="http://www.w3.org/1999/xlink"
                     spec="XP30" ref="prod-xpath30-AxisStep" xlink:type="simple">AxisStep</xnt> that
                  uses only the <code>child</code> or <code>attribute</code> axes. Patterns may also
                  use the <code>//</code> operator. A <xnt
                     xmlns:xlink="http://www.w3.org/1999/xlink" ref="prod-xpath30-Predicate"
                     spec="XP30" xlink:type="simple">Predicate</xnt> within the <xnt
                     xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                     ref="prod-xpath30-PredicateList" xlink:type="simple">PredicateList</xnt> in a
                  pattern can contain arbitrary XPath expressions (enclosed between square brackets)
                  in the same way as a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                     ref="prod-xpath30-Predicate" xlink:type="simple">predicate</xnt> in a path
                  expression.</p>
               <p diff="del" at="C">Patterns may start with an <xfunction>id</xfunction> or
                     <function>key</function> function call, provided that the value to be matched
                  is supplied as either a literal or a reference to a <termref def="dt-variable"
                     >variable</termref> or <termref def="dt-parameter">parameter</termref>, and the
                  key name (in the case of the <function>key</function> function) is supplied as a
                  string literal. These patterns will never match a node in a tree whose root is not
                  a document node.</p>
               <scrap headstyle="show" diff="chg" at="O" id="Patterns-scrap">
                  <head>Patterns</head>
                  <prod num="1" id="doc-xslt30-patterns-Pattern30">
                     <lhs>Pattern30</lhs>
                     <rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink"
                           def="doc-xslt30-patterns-PredicatePattern" xlink:type="simple"
                           >PredicatePattern</nt> | <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                           def="doc-xslt30-patterns-UnionExprP" xlink:type="simple"
                        >UnionExprP</nt></rhs>
                  </prod>
                  <prod num="2" id="doc-xslt30-patterns-PredicatePattern">
                     <lhs>PredicatePattern</lhs>
                     <rhs>"." <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                           ref="prod-xpath30-PredicateList" xlink:type="simple"
                        >PredicateList</xnt></rhs>
                  </prod>
                  <prod num="3" id="doc-xslt30-patterns-UnionExprP">
                     <lhs>UnionExprP</lhs>
                     <rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink"
                           def="doc-xslt30-patterns-IntersectExceptExprP" xlink:type="simple"
                           >IntersectExceptExprP</nt> (("union" | "|") <nt
                           xmlns:xlink="http://www.w3.org/1999/xlink"
                           def="doc-xslt30-patterns-IntersectExceptExprP" xlink:type="simple"
                           >IntersectExceptExprP</nt>)*</rhs>
                  </prod>
                  <prod num="4" id="doc-xslt30-patterns-IntersectExceptExprP">
                     <lhs>IntersectExceptExprP</lhs>
                     <rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink"
                           def="doc-xslt30-patterns-PathExprP" xlink:type="simple">PathExprP</nt>
                        (("intersect" | "except") <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                           def="doc-xslt30-patterns-PathExprP" xlink:type="simple"
                        >PathExprP</nt>)*</rhs>
                  </prod>
                  <prod num="5" id="doc-xslt30-patterns-PathExprP">
                     <lhs>PathExprP</lhs>
                     <rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink"
                           def="doc-xslt30-patterns-RootedPath" xlink:type="simple"
                        >RootedPath</nt><br/>| ("/" <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                           def="doc-xslt30-patterns-RelativePathExprP" xlink:type="simple"
                           >RelativePathExprP</nt>?)<br/>| ("//" <nt
                           xmlns:xlink="http://www.w3.org/1999/xlink"
                           def="doc-xslt30-patterns-RelativePathExprP" xlink:type="simple"
                           >RelativePathExprP</nt>)<br/>| <nt
                           xmlns:xlink="http://www.w3.org/1999/xlink"
                           def="doc-xslt30-patterns-RelativePathExprP" xlink:type="simple"
                           >RelativePathExprP</nt></rhs>
                  </prod>
                  <prod num="6" id="doc-xslt30-patterns-RootedPath">
                     <lhs>RootedPath</lhs>
                     <rhs>(<xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                           ref="prod-xpath30-VarRef" xlink:type="simple">VarRef</xnt> | <nt
                           xmlns:xlink="http://www.w3.org/1999/xlink"
                           def="doc-xslt30-patterns-FunctionCallP" xlink:type="simple"
                           >FunctionCallP</nt>) <xnt xmlns:xlink="http://www.w3.org/1999/xlink"
                           spec="XP30" ref="prod-xpath30-PredicateList" xlink:type="simple"
                           >PredicateList</xnt> (("/" | "//") <nt
                           xmlns:xlink="http://www.w3.org/1999/xlink"
                           def="doc-xslt30-patterns-RelativePathExprP" xlink:type="simple"
                           >RelativePathExprP</nt>)?</rhs>
                  </prod>
                  <prod num="7" id="doc-xslt30-patterns-FunctionCallP">
                     <lhs>FunctionCallP</lhs>
                     <rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink"
                           def="doc-xslt30-patterns-OuterFunctionName" xlink:type="simple"
                           >OuterFunctionName</nt>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                           def="doc-xslt30-patterns-ArgumentListP" xlink:type="simple"
                           >ArgumentListP</nt></rhs>
                  </prod>
                  <prod num="8" id="doc-xslt30-patterns-OuterFunctionName">
                     <lhs>OuterFunctionName</lhs>
                     <rhs>"doc" | "id" | "element-with-id" | "key" | "root" | <xnt
                           xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                           ref="prod-xpath30-URIQualifiedName" xlink:type="simple"
                           >URIQualifiedName</xnt></rhs>
                  </prod>
                  <prod num="9" id="doc-xslt30-patterns-ArgumentListP">
                     <lhs>ArgumentListP</lhs>
                     <rhs>"(" (<nt xmlns:xlink="http://www.w3.org/1999/xlink"
                           def="doc-xslt30-patterns-ArgumentP" xlink:type="simple">ArgumentP</nt>
                        ("," <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                           def="doc-xslt30-patterns-ArgumentP" xlink:type="simple"
                        >ArgumentP</nt>)*)? ")"</rhs>
                  </prod>
                  <prod num="10" id="doc-xslt30-patterns-ArgumentP">
                     <lhs>ArgumentP</lhs>
                     <rhs><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                           ref="prod-xpath30-VarRef" xlink:type="simple">VarRef</xnt> | <xnt
                           xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                           ref="prod-xpath30-Literal" xlink:type="simple">Literal</xnt></rhs>
                  </prod>
                  <prod num="11" id="doc-xslt30-patterns-RelativePathExprP">
                     <lhs>RelativePathExprP</lhs>
                     <rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink"
                           def="doc-xslt30-patterns-StepExprP" xlink:type="simple">StepExprP</nt>
                        (("/" | "//") <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                           def="doc-xslt30-patterns-StepExprP" xlink:type="simple"
                        >StepExprP</nt>)*</rhs>
                  </prod>
                  <prod num="12" id="doc-xslt30-patterns-StepExprP">
                     <lhs>StepExprP</lhs>
                     <rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink"
                           def="doc-xslt30-patterns-PostfixExprP" xlink:type="simple"
                           >PostfixExprP</nt> | <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                           def="doc-xslt30-patterns-AxisStepP" xlink:type="simple"
                        >AxisStepP</nt></rhs>
                  </prod>
                  <prod num="13" id="doc-xslt30-patterns-PostfixExprP">
                     <lhs>PostfixExprP</lhs>
                     <rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink"
                           def="doc-xslt30-patterns-ParenthesizedExprP" xlink:type="simple"
                           >ParenthesizedExprP</nt>
                        <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                           ref="prod-xpath30-PredicateList" xlink:type="simple"
                        >PredicateList</xnt></rhs>
                  </prod>
                  <prod num="14" id="doc-xslt30-patterns-ParenthesizedExprP">
                     <lhs>ParenthesizedExprP</lhs>
                     <rhs>"(" <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                           def="doc-xslt30-patterns-UnionExprP" xlink:type="simple">UnionExprP</nt>
                        ")"</rhs>
                  </prod>
                  <prod num="15" id="doc-xslt30-patterns-AxisStepP">
                     <lhs>AxisStepP</lhs>
                     <rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink"
                           def="doc-xslt30-patterns-ForwardStepP" xlink:type="simple"
                           >ForwardStepP</nt>
                        <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                           ref="prod-xpath30-PredicateList" xlink:type="simple"
                        >PredicateList</xnt></rhs>
                  </prod>
                  <prod num="16" id="doc-xslt30-patterns-ForwardStepP">
                     <lhs>ForwardStepP</lhs>
                     <rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink"
                           def="doc-xslt30-patterns-ForwardAxisP" xlink:type="simple"
                           >ForwardAxisP</nt>
                        <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                           ref="prod-xpath30-NodeTest" xlink:type="simple">NodeTest</xnt>) | <xnt
                           xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                           ref="prod-xpath30-AbbrevForwardStep" xlink:type="simple"
                           >AbbrevForwardStep</xnt></rhs>
                  </prod>
                  <prod num="17" id="doc-xslt30-patterns-ForwardAxisP">
                     <lhs>ForwardAxisP</lhs>
                     <rhs>("child" "::")<br/>| ("descendant" "::")<br/>| ("attribute" "::")<br/>|
                        ("self" "::")<br/>| ("descendant-or-self" "::")<br/>| ("namespace"
                        "::")</rhs>
                  </prod>
               </scrap>
               <p>The names of these constructs are chosen to align with the XPath 3.0 grammar.
                  Constructs whose names are suffixed with <code>P</code> are restricted forms of
                  the corresponding XPath 3.0 construct without the suffix. Constructs labeled with
                  the suffix “XP30” are defined in <bibref ref="xpath-30"/>.</p>
               <p diff="add" at="S-bug24266">Where the XSLT 3.0 processor implements the <termref
                     def="dt-xpath31-feature"/>, the definitions that apply to constructs labeled
                  with the suffix “XP30” are those in <bibref ref="xpath-31"/></p>
               <p diff="add" at="N">In a <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                     def="doc-xslt30-patterns-FunctionCallP" xlink:type="simple">FunctionCallP</nt>,
                  the <code>EQName</code> used for the function name must have local part
                     <code>doc</code>, <code>id</code>, <code>element-with-id</code>,
                     <code>key</code>, <phrase diff="add" at="S-bug27126">or
                     <code>root</code></phrase>, and must use the <termref
                     def="dt-standard-function-namespace"/> either explicitly or implicitly.</p>
               <p diff="add" at="S-bug27126">In the case of a call to the
                     <xfunction>root</xfunction> function, the argument list must be empty: that is,
                  only the zero-arity form of the function is allowed.</p>
               <note>
                  <p>As with XPath expressions, the pattern <code>/ union /*</code> can be parsed in
                     two different ways, and the chosen interpretation is to treat
                        <code>union</code> as an element name rather than as an operator. The other
                     interpretation can be achieved by writing <code>(/) union (/*)</code></p>
               </note>
            </div3>
            <div3 id="pattern-semantics" diff="chg" at="K">
               <head>The Meaning of a Pattern</head>
               <p>The meaning of a pattern is defined formally as follows, where “if” is to be read
                  as “if and only if”.</p>
               <p diff="chg" at="O">If the pattern is a <nt
                     xmlns:xlink="http://www.w3.org/1999/xlink"
                     def="doc-xslt30-patterns-PredicatePattern" xlink:type="simple"
                     >PredicatePattern</nt>
                  <var>PP</var>, then it matches an item <var>J</var> if the XPath expression taking
                  the same form as <var>PP</var> returns a non-empty sequence when evaluated with a
                     <termref def="dt-singleton-focus"/> based on <var>J</var>.</p>
               <note diff="add" at="O">
                  <p>The pattern <code>.</code>, which is a <code>PredicatePattern</code> with an
                     empty <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                        ref="prod-xpath30-PredicateList" xlink:type="simple">PredicateList</xnt>,
                     matches every item.</p>
                  <p>A predicate with the numeric value 1 (one) always matches, and a predicate with
                     any other numeric value never matches. Numeric predicates in a
                        <code>PredicatePattern</code> are therefore not useful, but are defined this
                     way in the interests of consistency with XPath.</p>
               </note>
               <p>Otherwise (the pattern is a <phrase diff="chg" at="R-bug24540">selection
                     pattern</phrase>), the pattern is converted to an <termref def="dt-expression"
                     >expression</termref>, called the <term>equivalent expression</term>. The
                  equivalent expression to a <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                     def="doc-xslt30-patterns-Pattern30" xlink:type="simple">Pattern</nt> is the
                  XPath expression that takes the same lexical form as the <code>Pattern</code> as
                  written, with the following adjustment:</p>
               <ulist>
                  <item diff="del" at="N">
                     <p>Any occurrence of <code>~ ItemType</code> in a <code>TypePattern</code> is
                        replaced by <code>.[. instance of ItemType]</code>. For example, the
                        equivalent expression for the pattern <code>~xs:integer[. gt 5]</code> is
                           <code>.[. instance of xs:integer][. gt 5]</code></p>
                  </item>
                  <item>
                     <p><phrase diff="chg" at="O">If any <code>PathExprP</code> in the
                              <code>Pattern</code> is a <code>RelativePathExprP</code>, then the
                           first <code>StepExprP</code>
                           <var>PS</var> of this <code>RelativePathExprP</code></phrase> is adjusted
                        to allow it to match a parentless element, attribute, or namespace node. The
                        adjustment depends on the axis used in this step, whether it appears
                        explicitly or implicitly (according to the rules of <xspecref spec="XP30"
                           ref="abbrev"/>), and is made as follows:</p>
                     <olist>
                        <item>
                           <p>If the <code>NodeTest</code> in <var>PS</var> is
                                 <code>document-node()</code> (optionally with arguments), and if no
                              explicit axis is specified, then the axis in step <var>PS</var> is
                              taken as <code>self</code> rather than <code>child</code>.</p>
                        </item>
                        <item>
                           <p>If <var>PS</var> uses the child axis (explicitly or implicitly), and
                              if the <code>NodeTest</code> in <var>PS</var> is not
                                 <code>document-node()</code> (optionally with arguments), then the
                              axis in step <var>PS</var> is replaced by <code>child-or-top</code>,
                              which is defined as follows. If the context node is a parentless
                              element, comment, processing-instruction, or text node then the
                                 <code>child-or-top</code> axis selects the context node; otherwise
                              it selects the children of the context node. It is a forwards axis
                              whose principal node kind is element.</p>
                        </item>
                        <item>
                           <p>If <var>PS</var> uses the attribute axis (explicitly or implicitly),
                              then the axis in step <var>PS</var> is replaced by
                                 <code>attribute-or-top</code>, which is defined as follows. If the
                              context node is an attribute node with no parent, then the
                                 <code>attribute-or-top</code> axis selects the context node;
                              otherwise it selects the attributes of the context node. It is a
                              forwards axis whose principal node kind is attribute.</p>
                        </item>
                        <item>
                           <p>If <var>PS</var> uses the namespace axis <phrase diff="chg" at="M"
                                 >(explicitly or implicitly)</phrase>, then the axis in step
                                 <var>PS</var> is replaced by <code>namespace-or-top</code>, which
                              is defined as follows. If the context node is a namespace node with no
                              parent, then the <code>namespace-or-top</code> axis selects the
                              context node; otherwise it selects the namespace nodes of the context
                              node. It is a forwards axis whose principal node kind is
                              namespace.</p>
                        </item>
                     </olist>
                     <p>The axes <code>child-or-top</code>, <code>attribute-or-top</code>, and
                           <code>namespace-or-top</code> are introduced only for definitional
                        purposes. They cannot be used explicitly in a user-written pattern or
                        expression.</p>
                     <note>
                        <p>The purpose of this adjustment is to ensure that a pattern such as
                              <code>person</code> matches any element named <code>person</code>,
                           even if it has no parent; and similarly, that the pattern
                              <code>@width</code> matches any attribute named <code>width</code>,
                           even a parentless attribute. The rule also ensures that a pattern using a
                              <code>NodeTest</code> of the form <code>document-node(...)</code>
                           matches a document node. The pattern <code>node()</code> will match any
                           element, text node, comment, or processing instruction, whether or not it
                           has a parent. For backwards compatibility reasons, the pattern
                              <code>node()</code>, when used without an explicit axis, does not
                           match document nodes, attribute nodes, or namespace nodes. The rules are
                           also phrased to ensure that positional patterns of the form
                              <code>para[1]</code> continue to count nodes relative to their parent,
                           if they have one. <phrase diff="add" at="O">To match any node at all,
                              XSLT 3.0 allows the pattern <code>.[. instance of node()]</code> to be
                              used.</phrase></p>
                     </note>
                  </item>
               </ulist>
               <p>The meaning of the pattern is then defined in terms of the semantics of the
                  equivalent expression, denoted below as <code>EE</code>.</p>
               <p>Specifically, an item <var>N</var> matches a pattern <var>P</var> if <phrase
                     diff="del" at="N">either of</phrase> the following applies, where
                     <code>EE</code> is the <term>equivalent expression</term> to <var>P</var>:</p>
               <olist>
                  <item>
                     <p><var>N</var> is a node, and the result of evaluating the expression
                           <code>root(.)//(EE)</code> with a <termref def="dt-singleton-focus"
                           >singleton focus</termref> based on <var>N</var> is a sequence that
                        includes the node <var>N</var>
                     </p>
                  </item>
                  <item diff="del" at="N">
                     <p><var>N</var> is not a node, and the result of evaluating the expression
                           <code>exists(EE)</code> with a <termref def="dt-singleton-focus"
                           >singleton focus</termref> based on <var>N</var> is the boolean value
                           <code>true</code>.</p>
                  </item>
               </olist>
               <p>If a pattern appears <phrase diff="chg" at="D">in an attribute of an element that
                     is processed with <termref def="dt-xslt-10-behavior">XSLT 1.0
                        behavior</termref></phrase> (see <specref ref="backwards"/>), then the
                  semantics of the pattern are defined on the basis that the equivalent XPath
                  expression is evaluated with <termref def="dt-xpath-compat-mode">XPath 1.0
                     compatibility mode</termref> set to true.</p>
               <example>
                  <head>The Semantics of Selection Patterns</head>
                  <p>The <phrase diff="chg" at="R-bug24540"><termref def="dt-selection-pattern"
                        /></phrase>
                     <code>p</code> matches any <code>p</code> element, because a <code>p</code>
                     element will always be present in the result of evaluating the <termref
                        def="dt-expression">expression</termref>
                     <code>root(.)//(child-or-top::p)</code>. Similarly, <code>/</code> matches a
                     document node, and only a document node, because the result of the <termref
                        def="dt-expression">expression</termref>
                     <code>root(.)//(/)</code> returns the root node of the tree containing the
                     context node if and only if it is a document node.</p>
                  <p>The <phrase diff="chg" at="R-bug24540"><termref def="dt-selection-pattern"
                        /></phrase>
                     <code>node()</code> matches all nodes selected by the expression
                        <code>root(.)//(child-or-top::node())</code>, that is, all element, text,
                     comment, and processing instruction nodes, whether or not they have a parent.
                     It does not match attribute or namespace nodes because the expression does not
                     select nodes using the attribute or namespace axes. It does not match document
                     nodes because for backwards compatibility reasons the <code>child-or-top</code>
                     axis does not match a document node.</p>
                  <p>The <phrase diff="chg" at="R-bug24540"><termref def="dt-selection-pattern"
                        /></phrase>
                     <code>$V</code> matches all nodes selected by the expression
                        <code>root(.)//($V)</code>, that is, all nodes in the value of $V (which
                     will typically be a global variable, though when the pattern is used in
                     contexts such as the <elcode>xsl:number</elcode> or
                        <elcode>xsl:for-each-group</elcode> instructions, it can also be a local
                     variable).</p>
                  <p>The <phrase diff="chg" at="R-bug24540"><termref def="dt-selection-pattern"
                        /></phrase>
                     <code>doc('product.xml')//product</code> matches all nodes selected by the
                     expression <code>root(.)//(doc('product.xml')//product)</code>, that is, all
                        <code>product</code> elements in the document whose URI is
                        <code>product.xml</code>.</p>
                  <p diff="add" at="S-bug27126">The <termref def="dt-selection-pattern"/>
                     <code>root(.)/self::E</code> matches an <code>E</code> element that is the root
                     of a tree (that is, an <code>E</code> element with no parent node).</p>
               </example>
               <p>Although the semantics of <phrase diff="chg" at="R-bug24540"><termref
                        def="dt-selection-pattern">selection patterns</termref></phrase> are
                  specified formally in terms of expression evaluation, it is possible to understand
                  pattern matching using a different model. A <phrase diff="chg" at="R-bug24540"
                        ><termref def="dt-selection-pattern"/></phrase> such as
                     <code>book/chapter/section</code> can be examined from right to left. A node
                  will only match this pattern if it is a <code>section</code> element; and then,
                  only if its parent is a <code>chapter</code>; and then, only if the parent of that
                     <code>chapter</code> is a <code>book</code>. When the pattern uses the
                     <code>//</code> operator, one can still read it from right to left, but this
                  time testing the ancestors of a node rather than its parent. For example
                     <code>appendix//section</code> matches every <code>section</code> element that
                  has an ancestor <code>appendix</code> element.</p>
               <p>The formal definition, however, is useful for understanding the meaning of a
                  pattern such as <code>para[1]</code>. This matches any node selected by the
                  expression <code>root(.)//(child-or-top::para[1])</code>: that is, any
                     <code>para</code> element that is the first <code>para</code> child of its
                  parent, or a <code>para</code> element that has no parent.</p>
               <note>
                  <p>An implementation, of course, may use any algorithm it wishes for evaluating
                     patterns, so long as the result corresponds with the formal definition above.
                     An implementation that followed the formal definition by evaluating the
                     equivalent expression and then testing the membership of a specific node in the
                     result would probably be very inefficient.</p>
               </note>
            </div3>
            <div3 id="pattern-errors" diff="chg" at="N">
               <head>Errors in Patterns</head>
               <p>A <termref def="dt-dynamic-error">dynamic error</termref> or <termref
                     def="dt-type-error">type error</termref> that occurs during the evaluation of a
                     <termref def="dt-pattern">pattern</termref> against a particular <phrase
                     diff="chg" at="C">item</phrase> has the effect that the item being tested is
                  treated as not matching the pattern. The error does not cause the transformation
                  to fail, and cannot be caught by a try/catch expression surrounding the
                  instruction that causes the pattern to be evaluated.</p>
               <note>
                  <p>The reason for this provision is that it is difficult for the stylesheet author
                     to predict which predicates in a pattern will actually be evaluated. In the
                     case of match patterns in template rules, it is not even possible to predict
                     which patterns will be evaluated against a particular node.</p>
                  <p>There is a risk that ignoring errors in this way may make programming mistakes
                     harder to debug. Implementations may mitigate this by providing warnings or
                     other diagnostics when evaluation of a pattern triggers an error condition.</p>
                  <p>Static errors in patterns, including dynamic and type errors that are signaled
                     statically as permitted by the specification, are reported in the normal way
                     and cause the transformation to fail.</p>
               </note>
               <p diff="add" at="R-bug26543">The requirement to detect and report a <termref
                     def="dt-circularity"/> as a dynamic error overrides this rule.</p>
            </div3>
         </div2>
         <div2 id="value-templates" diff="add" at="M">
            <head>Value Templates</head>
            <p>The string value of an attribute or text node in the stylesheet may in particular
               circumstances contain embedded expressions enclosed between curly brackets.
               Attributes and text nodes that use (or are permitted to use) this mechanism are
               referred to respectively as <termref def="dt-attribute-value-template">attribute
                  value templates</termref> and <termref def="dt-text-value-template">text value
                  templates</termref>.</p>
            <p diff="chg" at="O"><termdef id="dt-value-template" term="value template">Collectively,
                  attribute value templates and text value templates are referred to as <term>value
                     templates</term>.</termdef></p>
            <p>A value template is a string consisting of an alternating sequence of fixed parts and
               variable parts:</p>
            <ulist>
               <item>
                  <p>A variable part consists of an <phrase diff="add" at="S-bug29226"
                        >optional</phrase> XPath <termref def="dt-expression">expression</termref>
                     enclosed in curly brackets (<code>{}</code>): <phrase diff="add"
                        at="S-bug29226">more specifically, a string conforming to the XPath
                        production <code>Expr?</code>.</phrase></p>
                  <note>
                     <p>An expression within a variable part may contain an unescaped curly bracket
                        within a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                           ref="prod-xpath30-StringLiteral" xlink:type="simple">StringLiteral</xnt>
                        or within a comment.</p>
                     <p diff="chg" at="Q">Currently no XPath expression starts with an opening curly
                        bracket, so the use of <code>{{</code> creates no ambiguity. If an enclosed
                        expression ends with a closing curly bracket, no whitespace is required
                        between this and the closing delimiter.</p>
                     <p diff="add" at="S-bug29226">The fact that the expression is optional means
                        that the string contained between the curly brackets may be zero-length, may
                        comprise whitespace only, or may contain XPath comments. The effective value
                        in this case is a zero-length string, which is equivalent to omitting the
                        variable part entirely, together with its curly-bracket delimiters. </p>
                  </note>
               </item>
               <item>
                  <p>A fixed part may contain any characters, except that a left curly bracket
                        <rfc2119>must</rfc2119> be written as <code>{{</code> and a right curly
                     bracket <rfc2119>must</rfc2119> be written as <code>}}</code>. </p>
               </item>
            </ulist>
            <p>
               <error spec="XT" type="static" class="SE" code="0350"><p>It is a <termref
                        def="dt-static-error">static error</termref> if an unescaped left curly
                     bracket appears in a fixed part of a value template without a matching right
                     curly bracket.</p></error>
            </p>
            <p>It is a <termref def="dt-static-error">static error</termref> if the string contained
               between matching curly brackets in a value template does not match the XPath
               production <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                  ref="prod-xpath30-Expr" xlink:type="simple">Expr?</xnt>, or if it contains other
               XPath static errors. The error is signaled using the appropriate XPath error
               code.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0370"><p>It is a <termref
                        def="dt-static-error">static error</termref> if an unescaped right curly
                     bracket occurs in a fixed part of a value template.</p></error>
            </p>
            <p>
               <termdef id="dt-effective-value" term="effective value">The result of evaluating a
                  value template is referred to as its <term>effective value</term>.</termdef> The
               effective value is the string obtained by concatenating the expansions of the fixed
               and variable parts:</p>
            <ulist>
               <item>
                  <p>The expansion of a fixed part is obtained by replacing any double curly
                     brackets (<code>{{</code> or <code>}}</code>) by the corresponding single curly
                     bracket.</p>
               </item>
               <item>
                  <p>The expansion of a variable part is as follows:</p>
                  <ulist>
                     <item>
                        <p>If an expression is present, the result of evaluating the enclosed XPath
                              <termref def="dt-expression">expression</termref> and converting the
                           resulting value to a string. This conversion is done using the rules
                           given in <specref ref="constructing-simple-content"/>.</p>
                     </item>
                     <item>
                        <p diff="add" at="S-bug29226">If the expression is omitted, a zero-length
                           string.</p>
                     </item>
                  </ulist>
               </item>
            </ulist>
            <note>
               <p>This process can generate dynamic errors, for example if the sequence contains an
                  element with a complex content type (which cannot be atomized).</p>
            </note>
            <p>In the case of an attribute value template, the effective value becomes the string
               value of the new attribute node. In the case of a text value template, the effective
               value becomes the string value of the new text node.</p>
            <div3 id="attribute-value-templates">
               <head>Attribute Value Templates</head>
               <p>
                  <termdef id="dt-attribute-value-template" term="attribute value template">In an
                     attribute that is designated as an <term>attribute value template</term>, such
                     as an attribute of a <termref def="dt-literal-result-element">literal result
                        element</termref>, an <termref def="dt-expression">expression</termref> can
                     be used by surrounding the expression with curly brackets (<code>{}</code>),
                     following the general rules for <termref def="dt-value-template">value
                        templates</termref></termdef>.</p>
               <p>Curly brackets are not treated specially in an attribute value in an XSLT <termref
                     def="dt-stylesheet">stylesheet</termref> unless the attribute is specifically
                  designated as one that permits an attribute value template; in an element syntax
                  summary, the value of such attributes is surrounded by curly brackets.</p>
               <note>
                  <p>Not all attributes are designated as attribute value templates. Attributes
                     whose value is an <termref def="dt-expression">expression</termref> or <termref
                        def="dt-pattern">pattern</termref>, attributes of <termref
                        def="dt-declaration">declaration</termref> elements and attributes that
                     refer to named XSLT objects are generally not designated as attribute value
                     templates (an exception is the <code>format</code> attribute of
                        <elcode>xsl:result-document</elcode>). Namespace declarations are not XDM
                     attribute nodes and are therefore never treated as attribute value
                     templates.</p>
               </note>
               <p><phrase diff="chg" at="D">If the element containing the attribute is processed
                     with <termref def="dt-xslt-10-behavior">XSLT 1.0 behavior</termref>, then the
                     rules for converting the value of the expression to a string (given in <specref
                        ref="value-templates"/>) are modified as follows. After <termref
                        def="dt-atomization">atomizing</termref> the result of the expression, all
                     items other than the first item in the resulting sequence are discarded, and
                     the effective value is obtained by converting the first item in the sequence to
                     a string. If the atomized sequence is empty, the result is a zero-length
                     string.</phrase></p>
               <note>
                  <p diff="add" at="M">The above rule applies to attribute value templates but not
                     to text value templates, since the latter were not available in XSLT 1.0.</p>
               </note>
               <example>
                  <head>Attribute Value Templates</head>
                  <p>The following example creates an <code>img</code> result element from a
                        <code>photograph</code> element in the source; the value of the
                        <code>src</code> and <code>width</code> attributes are computed using XPath
                     expressions enclosed in attribute value templates:</p>
                  <eg xml:space="preserve" role="xslt-declarations">&lt;xsl:variable name="image-dir" select="'/images'"/&gt;

&lt;xsl:template match="photograph"&gt;
  &lt;img src="{$image-dir}/{href}" width="{size/@width}"/&gt;
&lt;/xsl:template&gt;</eg>
                  <p>With this source</p>
                  <eg xml:space="preserve" role="xml">&lt;photograph&gt;
  &lt;href&gt;headquarters.jpg&lt;/href&gt;
  &lt;size width="300"/&gt;
&lt;/photograph&gt;</eg>
                  <p>the result would be</p>
                  <eg xml:space="preserve" role="xml">&lt;img src="/images/headquarters.jpg" width="300"/&gt;</eg>
               </example>
               <example>
                  <head>Producing a Space-Separated List</head>
                  <p>The following example shows how the values in a sequence are output as a
                     space-separated list. The following literal result element:</p>
                  <eg xml:space="preserve" role="xml">&lt;temperature readings="{10.32, 5.50, 8.31}"/&gt;</eg>
                  <p>produces the output node:</p>
                  <eg xml:space="preserve" role="xml">&lt;temperature readings="10.32 5.5 8.31"/&gt;</eg>
               </example>
               <p>Curly brackets are <emph>not</emph> recognized recursively inside expressions.</p>
               <example>
                  <head>Curly Brackets cannot be Nested</head>
                  <p>For example:</p>
                  <eg role="error" xml:space="preserve">&lt;a href="#{id({@ref})/title}"/&gt;</eg>
                  <p>is <emph>not</emph> allowed. Instead, use simply:</p>
                  <eg xml:space="preserve" role="xml">&lt;a href="#{id(@ref)/title}"/&gt;</eg>
               </example>
            </div3>
            <div3 id="text-value-templates">
               <head>Text Value Templates</head>
               <p>The <termref def="dt-standard-attributes">standard attribute</termref>
                  <code>[xsl:]expand-text</code> may appear on any element in the stylesheet, and
                  determines whether descendant text nodes of that element are treated as text value
                  templates. A text node in the stylesheet is treated as a text value template if
                  (a) it is part of a <termref def="dt-sequence-constructor">sequence
                     constructor</termref>
                  <phrase diff="add" at="R-bug26525">or a child of an <elcode>xsl:text</elcode>
                     instruction</phrase>, (b) there is an ancestor element with an
                     <code>[xsl:]expand-text</code> attribute, and (c) on the innermost ancestor
                  element that has such an attribute, the value of the attribute is
                  <code>yes</code>. <phrase diff="chg" at="R-bug26308">The attribute is boolean and
                        <rfc2119>must</rfc2119> therefore take one of the values <code>yes</code>
                     (synonyms <code>true</code> or <code>1</code>) or <code>no</code> (synonyms
                        <code>false</code> or <code>0</code>)</phrase>. </p>
               <p>This section describes how text nodes <phrase diff="del" at="R-bug26525">appearing
                     in sequence constructors</phrase> are processed when the effective value is
                     <code>yes</code>. Such text nodes are referred to as text value templates.</p>
               <p>
                  <termdef id="dt-text-value-template" term="text value template">In a text node
                     that is designated as a <term>text value template</term>, <termref
                        def="dt-expression">expressions</termref> can be used by surrounding each
                     expression with curly brackets (<code>{}</code>).</termdef></p>
               <p>The rules for text value templates are given in <specref ref="value-templates"/>.
                  A text node <phrase diff="del" at="R-bug26525">in a sequence constructor</phrase>
                  whose value is a text value template results in the construction of a text node in
                  the result of the <phrase diff="chg" at="R-bug26525">containing sequence
                     constructor or <elcode>xsl:text</elcode> instruction</phrase>. The string value
                  of that text node is obtained by computing the effective value of the value
                  template.</p>
               <note>
                  <p diff="del" at="R-bug26525">The content of an <elcode>xsl:text</elcode> element
                     is not a sequence constructor, and therefore cannot contain a text value
                     template.</p>
                  <p>The result of evaluating a text value template is a (possibly zero-length) text
                     node. This text node becomes part of the result of the containing sequence
                     constructor or <elcode>xsl:text</elcode> instruction, and is thereafter handled
                     exactly as if the value had appeared explicitly as a text node in the
                     stylesheet.</p>
                  <p>The way in which the effective value is computed does not depend on any
                        <code>separator</code> attribute on a containing
                        <elcode>xsl:value-of</elcode> or <elcode>xsl:attribute</elcode> instruction.
                     The <code>separator</code> attribute only affects how the text node is combined
                     with adjacent items in the result of the containing sequence constructor.</p>
                  <p>Fixed parts consisting entirely of whitespace are significant and are handled
                     in the same way as any other fixed part. This is different from the default
                     treatment of “boundary space” in XQuery.</p>
               </note>
               <example>
                  <head>Using a text value template to construct message output</head>
                  <eg role="xslt-instructions" xml:space="preserve">&lt;xsl:variable name="id" select="'A123'"/&gt;
&lt;xsl:variable name="step" select="5"/&gt;
&lt;xsl:message expand-text="yes"
     &gt;Processing id={$id}, step={$step}&lt;/xsl:message&gt;
</eg>
                  <p>This will typically output the message text <code>Processing id=A123,
                        step=5</code>.</p>
               </example>
               <example>
                  <head>Using a text value template to define the result of a function</head>
                  <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">&lt;xsl:function name="f:sum" expand-text="yes" as="xs:integer"&gt;
&lt;xsl:param name="x" as="xs:integer"/&gt;
&lt;xsl:param name="y" as="xs:integer"/&gt;
  {$x + $y}
&lt;/xsl:function&gt;</eg>
                  <p>Note that although this is a very readable way of expressing the computation
                     performed by the function, the semantics are somewhat complex, and this could
                     mean that execution is inefficient. The function computes the value of <code>$x
                        + $y</code> as an integer, and then constructs a text node containing the
                     string representation of this integer (preceded and followed by whitespace).
                     Because the declared result type of the function is <code>xs:integer</code>,
                     this text node is then atomized, giving an <code>xs:untypedAtomic</code> value,
                     and the <code>xs:untypedAtomic</code> value is then cast to an
                        <code>xs:integer</code>.</p>
               </example>
               <note>
                  <p>The main motivations for adding text value templates to the XSLT language are
                     firstly, to make it easier to construct parameterized text in contexts such as
                        <elcode>xsl:value-of</elcode> and <elcode>xsl:message</elcode>, and
                     secondly, to allow use of complex multi-line XPath expressions where
                     maintaining correct indentation is important for readability. The fact that XML
                     processors are required to normalize whitespace in attribute values means that
                     writing such expressions within a <code>select</code> attribute is not
                     ideal.</p>
                  <p>The facility is only present if enabled using the
                        <code>[xsl:]expand-text</code> attribute. This is partly for backwards
                     compatibility, and partly to avoid creating difficulties when constructing
                     content that is rich in curly brackets, for example JavaScript code or CSS
                     style sheets.</p>
               </note>
            </div3>
         </div2>
         <div2 id="sequence-constructors">
            <head>Sequence Constructors</head>
            <p>
               <termdef id="dt-sequence-constructor" term="sequence constructor">A <term>sequence
                     constructor</term> is a sequence of zero or more sibling nodes in the <termref
                     def="dt-stylesheet">stylesheet</termref> that can be evaluated to return a
                  sequence of nodes, atomic values, <phrase diff="add" at="C">and function
                     items</phrase>. The way that the resulting sequence is used depends on the
                  containing instruction.</termdef>
            </p>
            <p>Many <termref def="dt-xslt-element">XSLT elements</termref>, and also <termref
                  def="dt-literal-result-element">literal result elements</termref>, are defined to
               take a <termref def="dt-sequence-constructor"/> as their content.</p>
            <p>Four kinds of nodes may be encountered in a sequence constructor:</p>
            <olist diff="chg" at="F">
               <item>
                  <p> A <emph>Text node</emph> appearing in the <termref def="dt-stylesheet"
                        >stylesheet</termref> (if it has not been removed in the process of
                     whitespace stripping: see <specref ref="stylesheet-stripping"/>) is <phrase
                        diff="chg" at="M">processed as follows:</phrase></p>
                  <olist diff="add" at="M">
                     <item>
                        <p>if the effective value of the standard attribute
                              <code>[xsl:]expand-text</code> is <code>no</code>, or in the absence
                           of this attribute, the text node in the stylesheet is copied to create a
                           new parentless text node in the result of the sequence constructor.</p>
                        <note diff="del" at="R-bug26525">
                           <p>For an <elcode>xsl:text</elcode> element, the effective value of
                                 <code>[xsl:]expand-text</code> is always <code>no</code>.</p>
                        </note>
                     </item>
                     <item>
                        <p>Otherwise (the effective value of <code>[xsl:]expand-text</code> is
                              <code>yes</code>), the text node in the stylesheet is processed as
                           described in <specref ref="text-value-templates"/>.</p>
                     </item>
                  </olist>
               </item>
               <item>
                  <p> A <termref def="dt-literal-result-element">literal result element</termref> is
                     evaluated to create a new parentless element node, having the same <termref
                        def="dt-expanded-qname">expanded QName</termref> as the literal result
                     element: see <specref ref="literal-result-element"/>. </p>
               </item>
               <item>
                  <p>An XSLT <termref def="dt-instruction">instruction</termref> produces a sequence
                     of zero, one, or more items as its result. For most XSLT instructions, these
                     items are nodes, but some instructions (<phrase diff="add" at="D">such
                        as</phrase>
                     <elcode>xsl:sequence</elcode> and <elcode>xsl:copy-of</elcode>) can also
                     produce atomic values <phrase diff="add" at="C">or function items</phrase>.
                     Several instructions, such as <elcode>xsl:element</elcode>, return a newly
                     constructed parentless node (which may have its own attributes, namespaces,
                     children, and other descendants). Other instructions, such as
                        <elcode>xsl:if</elcode>, pass on the items produced by their own nested
                     sequence constructors. The <elcode>xsl:sequence</elcode> instruction may return
                     atomic values, <phrase diff="add" at="C">function items</phrase>, or existing
                     nodes.</p>
               </item>
               <item>
                  <p> An <termref def="dt-extension-instruction"/> (see <specref
                        ref="extension-instruction"/>) also produces a sequence of items as its
                     result.</p>
               </item>
            </olist>
            <p><termdef id="dt-immediate-result" term="immediate result">The result of evaluating a
                     <termref def="dt-sequence-constructor"/> is the sequence of items formed by
                  concatenating the results of evaluating each of the nodes in the sequence
                  constructor, retaining order. <phrase diff="add" at="T-bug29442">This is referred
                     to as the <term>immediate result</term> of the sequence
                  constructor.</phrase></termdef></p>
            <p diff="add" at="S-bug27189">However:</p>
            <ulist diff="add" at="S-bug27189">
               <item>
                  <p>For the effect of the <elcode>xsl:fallback</elcode> instruction, see <specref
                        ref="fallback"/>.</p>
               </item>
               <item>
                  <p>For the effect of the <elcode>xsl:on-empty</elcode> and
                        <elcode>xsl:on-non-empty</elcode> instructions, see <specref
                        ref="conditional-content-construction"/>.</p>
               </item>
            </ulist>
            <p>The way that <termref def="dt-immediate-result"/> of a <termref
                  def="dt-sequence-constructor"/> is used depends on the containing element in the
               stylesheet, and is specified in the rules for that element. It is typically one of
               the following:</p>
            <ulist>
               <item>
                  <p diff="chg" at="T-bug29442">The <termref def="dt-immediate-result"/> may be
                     bound to a <termref def="dt-variable"/> or delivered as the result of a
                        <termref def="dt-stylesheet-function"/>. In this case the <code>as</code>
                     attribute of the containing <elcode>xsl:variable</elcode> or
                        <elcode>xsl:function</elcode> element may be used to declare its required
                     type, and the <termref def="dt-immediate-result"/> is then converted to the
                     required type by applying the <termref def="dt-function-conversion-rules"
                     />.</p>
                  <note diff="chg" at="T-bug29442">
                     <ulist>
                        <item>
                           <p>In the absence of an <code>as</code> attribute, the result of a
                              function is the <termref def="dt-immediate-result"/> of the sequence
                              constructor; but the value of a variable (for backwards compatibility
                              reasons) is a document node whose content is formed by applying the
                              rules in <specref ref="constructing-complex-content"/> to the <termref
                                 def="dt-immediate-result"/>. </p>
                        </item>
                        <item>
                           <p>The function conversion rules do not merge adjacent text nodes or
                              insert separators between adjacent items. This means it is often
                              inappropriate to use <elcode>xsl:value-of</elcode> in the body of
                                 <elcode>xsl:variable</elcode> or <elcode>xsl:function</elcode>,
                              especially when the intent is to return an atomic result. The
                                 <elcode>xsl:sequence</elcode> instruction is designed for this
                              purpose, and is usually a better choice. </p>
                        </item>
                        <item>
                           <p>The result of a function, or the value of a variable, may contain
                              nodes (such as elements, attributes, and text nodes) that are not
                              attached to any parent node in a <termref def="dt-result-tree"/>. The
                              semantics of XPath expressions when applied to parentless nodes are
                              well-defined; however, such expressions should be used with care. For
                              example, the expression <code>/</code> causes a type error if the root
                              of the tree containing the context node is not a document node. </p>
                        </item>
                        <item>
                           <p>Parentless attribute nodes require particular care because they have
                              no namespace nodes associated with them. A parentless attribute node
                              is not permitted to contain namespace-sensitive content (for example,
                              a QName or an XPath expression) because there is no information
                              enabling the prefix to be resolved to a namespace URI. Parentless
                              attributes can be useful in an application (for example, they provide
                              an alternative to the use of attribute sets: see <specref
                                 ref="attribute-sets"/>) but they need to be handled with care.</p>
                        </item>
                     </ulist>
                  </note>
               </item>
               <item>
                  <p>The sequence may be returned as the result of the containing element. This
                     happens, <phrase diff="chg" at="T-bug29436">for example, </phrase>when the
                        <phrase diff="chg" at="C">element</phrase> containing the sequence
                     constructor is <phrase diff="chg" at="T-bug29436"><elcode>xsl:break</elcode>,
                           <elcode>xsl:catch</elcode>, <elcode>xsl:fallback</elcode>,
                           <elcode>xsl:for-each</elcode>, <elcode>xsl:for-each-group</elcode>,
                           <phrase diff="add" at="C"><elcode>xsl:fork</elcode></phrase>,
                           <elcode>xsl:if</elcode>, <phrase diff="add" at="C"
                              ><elcode>xsl:iterate</elcode></phrase>,
                           <elcode>xsl:matching-substring</elcode>,
                           <elcode>xsl:non-matching-substring</elcode>, <phrase diff="add" at="C"
                              ><elcode>xsl:on-completion</elcode></phrase>,
                           <elcode>xsl:otherwise</elcode>, <elcode>xsl:perform-sort</elcode>,
                           <elcode>xsl:sequence</elcode>, <phrase diff="add" at="B"
                              ><elcode>xsl:try</elcode></phrase>, or
                        <elcode>xsl:when</elcode></phrase>. </p>
               </item>
               <item>
                  <p>The sequence may be used to construct the content of a new element or document
                     node. This happens when the sequence constructor appears as the content of a
                        <termref def="dt-literal-result-element">literal result element</termref>,
                     or of one of the instructions <elcode>xsl:copy</elcode>,
                        <elcode>xsl:element</elcode>, <elcode>xsl:document</elcode>,
                        <elcode>xsl:result-document</elcode>, <phrase diff="add" at="L"
                           ><elcode>xsl:assert</elcode></phrase>, or <elcode>xsl:message</elcode>.
                     It also happens when the sequence constructor is contained in one of the
                     elements <elcode>xsl:variable</elcode>, <elcode>xsl:param</elcode>, or
                        <elcode>xsl:with-param</elcode>, <phrase diff="del" at="P"> or
                           <elcode>xsl:context-item</elcode></phrase> when this instruction has no
                        <code>as</code> attribute. For details, see <specref
                        ref="constructing-complex-content"/>.</p>
               </item>
               <item>
                  <p>The sequence may be used to construct the <termref def="dt-string-value">string
                        value</termref> of an attribute node, text node, namespace node, comment
                     node, or processing instruction node. This happens when the sequence
                     constructor is contained in one of the elements <elcode>xsl:attribute</elcode>,
                        <elcode>xsl:value-of</elcode>, <elcode>xsl:namespace</elcode>,
                        <elcode>xsl:comment</elcode>, or
                     <elcode>xsl:processing-instruction</elcode>. For details, see <specref
                        ref="constructing-simple-content"/>.</p>
               </item>
            </ulist>
            <note diff="del" at="A">
               <p>The term <emph>sequence constructor</emph> replaces <emph>template</emph> as used
                  in XSLT 1.0. The change is made partly for clarity (to avoid confusion with
                     <termref def="dt-template-rule">template rules</termref> and <termref
                     def="dt-named-template">named templates</termref>), but also to reflect a more
                  formal definition of the semantics. Whereas XSLT 1.0 described a template as a
                  sequence of instructions that write to the result tree, XSLT 2.0 describes a
                  sequence constructor as something that can be evaluated to return a sequence of
                  items; what happens to these items depends on the containing instruction.</p>
            </note>
            <div3 id="constructing-complex-content">
               <head>Constructing Complex Content</head>
               <p diff="chg" at="T-bug29442">Many instructions, for example
                     <elcode>xsl:copy</elcode>, <elcode>xsl:element</elcode>,
                     <elcode>xsl:document</elcode>, <elcode>xsl:result-document</elcode>, and
                     <termref def="dt-literal-result-element">literal result elements</termref>,
                  create a new parent node, and evaluate a <termref def="dt-sequence-constructor"/>
                  forming the content of the instruction to create the attributes, namespaces, and
                  children of the new parent node. The <termref def="dt-immediate-result"/> of the
                  sequence constructor is processed to create the content of the new parent node as
                  described in this section.</p>
               <p>When constructing the content of an element, the <code>inherit-namespaces</code>
                  attribute of the <elcode>xsl:element</elcode> or <elcode>xsl:copy</elcode>
                  instruction, or the <code>xsl:inherit-namespaces</code> property of the literal
                  result element, determines whether namespace nodes are to be inherited. The effect
                  of this attribute is described in the rules that follow.</p>
               <p>The <termref def="dt-immediate-result"/> of the <termref
                     def="dt-sequence-constructor"/> is processed as follows (applying the rules in
                  the order they are listed):</p>
               <olist>
                  <item>
                     <p>The containing instruction may generate attribute nodes and/or namespace
                        nodes, as specified in the rules for the individual instruction. For
                        example, these nodes may be produced by expanding an
                           <code>[xsl:]use-attribute-sets</code> attribute, or by expanding the
                        attributes of a <termref def="dt-literal-result-element">literal result
                           element</termref>. Any such nodes are prepended to the <termref
                           def="dt-immediate-result"/> of the <termref def="dt-sequence-constructor"
                        />.</p>
                  </item>
                  <item diff="add" at="S-bug29079">
                     <p>Any array item in the sequence (see <specref ref="arrays"/>) is replaced by
                        its members, recursively. This is equivalent to applying the <xfunction
                           spec="FO31">array:flatten</xfunction> function defined in <bibref
                           ref="xpath-functions-31"/>.</p>
                     <note>
                        <p>This situation only arises if the <termref def="dt-xpath31-feature"/> is
                           implemented. Note that if the array contains nodes, this operation leaves
                           the nodes in the sequence: they are not <termref def="dt-atomization"
                              >atomized</termref>.</p>
                     </note>
                  </item>
                  <item>
                     <p>Any atomic value in the sequence is cast to a string.</p>
                     <note>
                        <p>Casting from <code>xs:QName</code> or <code>xs:NOTATION</code> to
                              <code>xs:string</code> always succeeds, because these values retain a
                           prefix for this purpose. However, there is no guarantee that the prefix
                           used will always be meaningful in the context where the resulting string
                           is used.</p>
                     </note>
                  </item>
                  <item>
                     <p>Any consecutive sequence of strings in the sequence is converted to a single
                        text node, whose <termref def="dt-string-value">string value</termref>
                        contains the content of each of the strings in turn, with a single space
                        (#x20) used as a separator between successive strings.</p>
                  </item>
                  <item>
                     <p>Any document node within the sequence is replaced by a sequence containing
                        each of its children, in document order.</p>
                  </item>
                  <item>
                     <p>Zero-length text nodes within the sequence are removed.</p>
                  </item>
                  <item>
                     <p>Adjacent text nodes within the sequence are merged into a single text
                        node.</p>
                  </item>
                  <item>
                     <p>Invalid <phrase diff="chg" at="C">items in the sequence</phrase> are
                        detected as follows.</p>
                     <p>
                        <error spec="XT" type="dynamic" class="DE" code="0410"><p>It is a <termref
                                 def="dt-dynamic-error"><phrase diff="del" at="M"
                                    >non-recoverable</phrase> dynamic error</termref> if the
                              sequence used to construct the content of an element node contains a
                              namespace node or attribute node that is preceded in the sequence by a
                              node that is neither a namespace node nor an attribute
                           node.</p></error>
                     </p>
                     <p>
                        <error spec="XT" type="dynamic" class="DE" code="0420"><p>It is a <termref
                                 def="dt-dynamic-error"><phrase diff="del" at="M"
                                    >non-recoverable</phrase> dynamic error</termref> if the
                              sequence used to construct the content of a document node contains a
                              namespace node or attribute node.</p></error>
                     </p>
                     <p>
                        <error spec="XT" type="dynamic" class="DE" code="0430"><p>It is a <termref
                                 def="dt-dynamic-error"><phrase diff="del" at="M"
                                    >non-recoverable</phrase> dynamic error</termref> if the
                              sequence contains two or more namespace nodes having the same name but
                              different <termref def="dt-string-value">string values</termref> (that
                              is, namespace nodes that map the same prefix to different namespace
                              URIs).</p></error>
                     </p>
                     <p>
                        <error spec="XT" type="dynamic" class="DE" code="0440"><p>It is a <termref
                                 def="dt-dynamic-error"><phrase diff="del" at="M"
                                    >non-recoverable</phrase> dynamic error</termref> if the
                              sequence contains a namespace node with no name and the element node
                              being constructed has a null namespace URI (that is, it is an error to
                              define a default namespace when the element is in no namespace).
                           </p></error>
                     </p>
                     <p diff="add" at="C">
                        <error spec="XT" type="dynamic" class="DE" code="0450"><p>It is a <termref
                                 def="dt-dynamic-error"><phrase diff="del" at="M"
                                    >non-recoverable</phrase> dynamic error</termref> if the result
                              sequence contains a function item. </p></error>
                     </p>
                  </item>
                  <item>
                     <p>If the sequence contains two or more namespace nodes with the same name (or
                        no name) and the same <termref def="dt-string-value">string value</termref>
                        (that is, two namespace nodes mapping the same prefix to the same namespace
                        URI), then all but one of the duplicate nodes are discarded.</p>
                     <note>
                        <p>Since the order of namespace nodes is <termref
                              def="dt-implementation-dependent">implementation-dependent</termref>,
                           it is not significant which of the duplicates is retained.</p>
                     </note>
                  </item>
                  <item>
                     <p>If an attribute <var>A</var> in the sequence has the same name as another
                        attribute <var>B</var> that appears later in the sequence, then attribute
                           <var>A</var> is discarded from the sequence. Before discarding attribute
                           <var>A</var>, the processor <rfc2119>may</rfc2119> signal any <termref
                           def="dt-type-error">type errors</termref> that would be signaled if
                        attribute <var>B</var> were not present. </p>
                  </item>
                  <item>
                     <p>Each node in the resulting sequence is attached as a namespace, attribute,
                        or child of the newly constructed element or document node. Conceptually
                        this involves making a deep copy of the node; in practice, however, copying
                        the node will only be necessary if the existing node can be referenced
                        independently of the parent to which it is being attached. When copying an
                        element or processing instruction node, its base URI property is changed to
                        be the same as that of its new parent, unless it has an
                           <code>xml:base</code> attribute (see <bibref ref="xmlbase"/>) that
                        overrides this. If the copied element has an <code>xml:base</code>
                        attribute, its base URI is the value of that attribute, resolved (if it is
                        relative) against the base URI of the new parent node.</p>
                     <p diff="add" at="S-bug28565">Except for the handling of base URI, the copying
                        of a node follows the rules of the <elcode>xsl:copy-of</elcode> instruction
                        with attributes <code>copy-namespaces="yes" copy-accumulators="no"
                           validation="preserve"</code>.</p>
                     <note>
                        <p>This has the consequence that the type annotation and the values of the
                              <code>nilled</code>, <code>is-id</code>, and <code>is-idrefs</code>
                           properties are retained. However, if the node under construction (the new
                           parent of the node being copied) uses a validation mode other than
                              <code>preserve</code>, this will be transient: the values will be
                           recomputed when the new parent node is validated.</p>
                     </note>
                  </item>
                  <item>
                     <p>If the newly constructed node is an element node, then namespace fixup is
                        applied to this node, as described in <specref ref="namespace-fixup"/>.</p>
                  </item>
                  <item>
                     <p>If the newly constructed node is an element node, and if namespaces are
                        inherited, then each namespace node of the newly constructed element
                        (including any produced as a result of the namespace fixup process) is
                        copied to each descendant element of the newly constructed element, unless
                        that element or an intermediate element already has a namespace node with
                        the same name (or absence of a name) or that descendant element or an
                        intermediate element is in no namespace and the namespace node has no
                        name.</p>
                  </item>
               </olist>
               <example>
                  <head>A Sequence Constructor for Complex Content</head>
                  <p>Consider the following stylesheet fragment:</p>
                  <eg xml:space="preserve" role="xslt-instruction">&lt;td&gt;
  &lt;xsl:attribute name="valign"&gt;top&lt;/xsl:attribute&gt;
  &lt;xsl:value-of select="@description"/&gt;
&lt;/td&gt;</eg>
                  <p>This fragment consists of a literal result element <code>td</code>, containing
                     a sequence constructor that consists of two instructions:
                        <elcode>xsl:attribute</elcode> and <elcode>xsl:value-of</elcode>. The
                     sequence constructor is evaluated to produce a sequence of two nodes: a
                     parentless attribute node, and a parentless text node. The <code>td</code>
                     instruction causes a <code>td</code> element to be created; the new attribute
                     therefore becomes an attribute of the new <code>td</code> element, while the
                     text node created by the <elcode>xsl:value-of</elcode> instruction becomes a
                     child of the <code>td</code> element (unless it is zero-length, in which case
                     it is discarded).</p>
               </example>
               <example>
                  <head>Space Separators in Element Content</head>
                  <p>Consider the following stylesheet fragment:</p>
                  <eg xml:space="preserve" role="xslt-instruction">&lt;doc&gt;
  &lt;e&gt;&lt;xsl:sequence select="1 to 5"/&gt;&lt;/e&gt;
  &lt;f&gt;
    &lt;xsl:for-each select="1 to 5"&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/f&gt;
&lt;/doc&gt;</eg>
                  <p>This produces the output (when indented):</p>
                  <eg xml:space="preserve" role="xml">&lt;doc&gt;
  &lt;e&gt;1 2 3 4 5&lt;/e&gt;
  &lt;f&gt;12345&lt;/f&gt;
&lt;/doc&gt;</eg>
                  <p>The difference between the two cases is that for the <code>e</code> element,
                     the sequence constructor generates a sequence of five atomic values, which are
                     therefore separated by spaces. For the <code>f</code> element, the content is a
                     sequence of five text nodes, which are concatenated without space
                     separation.</p>
                  <p>It is important to be aware of the distinction between
                        <elcode>xsl:sequence</elcode>, which returns the value of its
                        <code>select</code> expression unchanged, and <elcode>xsl:value-of</elcode>,
                     which constructs a text node.</p>
               </example>
            </div3>
            <div3 id="constructing-simple-content">
               <head>Constructing Simple Content</head>
               <p>The instructions <elcode>xsl:attribute</elcode>, <elcode>xsl:comment</elcode>,
                     <elcode>xsl:processing-instruction</elcode>, <elcode>xsl:namespace</elcode>,
                  and <elcode>xsl:value-of</elcode> all create nodes that cannot have children.
                  Specifically, the <elcode>xsl:attribute</elcode> instruction creates an attribute
                  node, <elcode>xsl:comment</elcode> creates a comment node,
                     <elcode>xsl:processing-instruction</elcode> creates a processing instruction
                  node, <elcode>xsl:namespace</elcode> creates a namespace node, and
                     <elcode>xsl:value-of</elcode> creates a text node. The string value of the new
                  node is constructed using either the <code>select</code> attribute of the
                  instruction, or the <termref def="dt-sequence-constructor">sequence
                     constructor</termref> that forms the content of the instruction. The
                     <code>select</code> attribute allows the content to be specified by means of an
                  XPath expression, while the sequence constructor allows it to be specified by
                  means of a sequence of XSLT instructions. The <code>select</code> attribute or
                  sequence constructor is evaluated to produce a result sequence, and the <termref
                     def="dt-string-value">string value</termref> of the new node is derived from
                  this result sequence according to the rules below.</p>
               <p>These rules are also used to compute the <termref def="dt-effective-value"
                     >effective value</termref> of a <phrase diff="chg" at="M"><termref
                        def="dt-value-template">value template</termref></phrase>. In this case the
                  sequence being processed is the result of evaluating an XPath expression enclosed
                  between curly brackets, and the separator is a single space character.</p>
               <olist>
                  <item>
                     <p>Zero-length text nodes in the sequence are discarded.</p>
                  </item>
                  <item>
                     <p>Adjacent text nodes in the sequence are merged into a single text node.</p>
                  </item>
                  <item>
                     <p>The sequence is <termref def="dt-atomization">atomized</termref>
                        <phrase diff="add" at="C">(which may cause a dynamic error)</phrase>.</p>
                  </item>
                  <item>
                     <p>Every value in the atomized sequence is cast to a string.</p>
                  </item>
                  <item>
                     <p>The strings within the resulting sequence are concatenated, with a (possibly
                        zero-length) separator inserted between successive strings. <phrase
                           diff="chg" at="T-bug29445">The default separator depends on the
                           containing instruction; except where otherwise specified, it is a single
                           space.</phrase></p>
                     <p diff="chg" at="T-bug29445">In the case of <elcode>xsl:attribute</elcode> and
                           <elcode>xsl:value-of</elcode>, the default separator is a single space
                        when the <code>select</code> attribute is used, or a zero-length string
                        otherwise; a different separator can be specified using the
                           <code>separator</code> attribute of the instruction.</p>
                     <p>In the case of <elcode>xsl:comment</elcode>,
                           <elcode>xsl:processing-instruction</elcode>, and
                           <elcode>xsl:namespace</elcode>, and when expanding a <phrase diff="chg"
                           at="M"><termref def="dt-value-template">value
                        template</termref></phrase>, the default separator cannot be changed.</p>
                  </item>
                  <item>
                     <p>In the case of <elcode>xsl:processing-instruction</elcode>, any leading
                        spaces in the resulting string are removed.</p>
                  </item>
                  <item>
                     <p>The resulting string forms the <termref def="dt-string-value">string
                           value</termref> of the new attribute, namespace, comment,
                        processing-instruction, or text node.</p>
                  </item>
               </olist>
               <example>
                  <head>Space Separators in Attribute Content</head>
                  <p>Consider the following stylesheet fragment:</p>
                  <eg xml:space="preserve" diff="chg" at="M" role="xslt-instruction">&lt;doc&gt;
  &lt;xsl:attribute name="e" select="1 to 5"/&gt;
  &lt;xsl:attribute name="f"&gt;
    &lt;xsl:for-each select="1 to 5"&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="g" expand-text="yes"&gt;{1 to 5}&lt;/xsl:attribute&gt;
&lt;/doc&gt;</eg>
                  <p diff="chg" at="M">This produces the output:</p>
                  <eg xml:space="preserve" role="xml">&lt;doc e="1 2 3 4 5" f="12345" g="1 2 3 4 5"/&gt;</eg>
                  <p diff="chg" at="M">The difference between the three cases is as follows. For the
                        <code>e</code> attribute, the sequence constructor generates a sequence of
                     five atomic values, which are therefore separated by spaces. For the
                        <code>f</code> attribute, the content is supplied as a sequence of five text
                     nodes, which are concatenated without space separation. For the <code>g</code>
                     attribute, the <termref def="dt-text-value-template"/> constructs a text node
                     using the rules for constructing simple content, which insert space separators
                     between atomic values; the text node is then atomized to form the value of the
                     attribute.</p>
                  <p>Specifying <code>separator=""</code> on the first
                        <elcode>xsl:attribute</elcode> instruction would cause the attribute value
                     to be <code>e="12345"</code>. A <code>separator</code> attribute on the second
                        <elcode>xsl:attribute</elcode> instruction would have no effect, since the
                     separator only affects the way adjacent atomic values are handled: separators
                     are never inserted between adjacent text nodes. <phrase diff="add" at="M">A
                           <code>separator</code> on the third <elcode>xsl:attribute</elcode>
                        instruction would also have no effect, because text value templates are
                        evaluated without regard to the containing instruction.</phrase></p>
               </example>
               <note>
                  <p>If an attribute value template contains a sequence of fixed and variable parts,
                     no additional whitespace is inserted between the expansions of the fixed and
                     variable parts. For example, the <termref def="dt-effective-value">effective
                        value</termref> of the attribute <code>a="chapters{4 to 6}"</code> is
                        <code>a="chapters4 5 6"</code>.</p>
               </note>
            </div3>
            <div3 id="namespace-fixup">
               <head>Namespace Fixup</head>
               <p>In a tree supplied to or constructed by an XSLT processor, the constraints
                  relating to namespace nodes that are specified in <bibref ref="xpath-datamodel-30"/>
                  <rfc2119>must</rfc2119> be satisfied. For example:</p>
               <ulist>
                  <item>
                     <p>If an element node has an <termref def="dt-expanded-qname">expanded
                           QName</termref> with a non-null namespace URI, then that element node
                           <rfc2119>must</rfc2119> have at least one namespace node whose <termref
                           def="dt-string-value">string value</termref> is the same as that
                        namespace URI.</p>
                  </item>
                  <item>
                     <p>If an element node has an attribute node whose <termref
                           def="dt-expanded-qname">expanded QName</termref> has a non-null namespace
                        URI, then the element <rfc2119>must</rfc2119> have at least one namespace
                        node whose <termref def="dt-string-value">string value</termref> is the same
                        as that namespace URI and whose name is non-empty.</p>
                  </item>
                  <item>
                     <p>Every element <rfc2119>must</rfc2119> have a namespace node whose <termref
                           def="dt-expanded-qname">expanded QName</termref> has local-part
                           <code>xml</code> and whose <termref def="dt-string-value">string
                           value</termref> is <code>http://www.w3.org/XML/1998/namespace</code>. The
                        namespace prefix <code>xml</code>
                        <rfc2119>must</rfc2119> not be associated with any other namespace URI, and
                        the namespace URI <code>http://www.w3.org/XML/1998/namespace</code>
                        <rfc2119>must</rfc2119> not be associated with any other prefix.</p>
                  </item>
                  <item>
                     <p>A namespace node <rfc2119>must not</rfc2119> have the name
                           <code>xmlns</code> or the string value
                           <code>http://www.w3.org/2000/xmlns/</code>.</p>
                  </item>
               </ulist>
               <p>
                  <termdef id="dt-namespace-fixup" term="namespace fixup">The rules for the
                     individual XSLT instructions that construct a <termref def="dt-result-tree"
                        >result tree</termref> (see <specref ref="creating-new-nodes"/>) prescribe
                     some of the situations in which namespace nodes are written to the tree. These
                     rules, however, are not sufficient to ensure that the prescribed constraints
                     are always satisfied. The XSLT processor <rfc2119>must</rfc2119> therefore add
                     additional namespace nodes to satisfy these constraints. This process is
                     referred to as <term>namespace fixup</term>.</termdef>
               </p>
               <p>The actual namespace nodes that are added to the tree by the namespace fixup
                  process are <termref def="dt-implementation-dependent"
                     >implementation-dependent</termref>, provided firstly, that at the end of the
                  process the above constraints <rfc2119>must</rfc2119> all be satisfied, and
                  secondly, that a namespace node <rfc2119>must not</rfc2119> be added to the tree
                  unless the namespace node is necessary either to satisfy these constraints, or to
                  enable the tree to be serialized using the original namespace prefixes from the
                  source document or <termref def="dt-stylesheet">stylesheet</termref>.</p>
               <p>Namespace fixup <rfc2119>must not</rfc2119> result in an element having multiple
                  namespace nodes with the same name.</p>
               <p>Namespace fixup <rfc2119>may</rfc2119>, if necessary to resolve conflicts, change
                  the namespace prefix contained in the QName value that holds the name of an
                  element or attribute node. This includes the option to add or remove a prefix.
                  However, namespace fixup <rfc2119>must not</rfc2119> change the prefix component
                  contained in a value of type <code>xs:QName</code> or <code>xs:NOTATION</code>
                  that forms the typed value of an element or attribute node.</p>
               <note>
                  <p>Namespace fixup is not used to create namespace declarations for
                        <code>xs:QName</code> or <code>xs:NOTATION</code> values appearing in the
                     content of an element or attribute.</p>
                  <p>Where values acquire such types as the result of validation, namespace fixup
                     does not come into play, because namespace fixup happens before validation: in
                     this situation, it is the user’s responsibility to ensure that the element
                     being validated has the required namespace nodes to enable validation to
                     succeed.</p>
                  <p>Where existing elements are copied along with their existing <termref
                        def="dt-type-annotation">type annotations</termref>
                        (<code>validation="preserve"</code>) the rules require that existing
                     namespace nodes are also copied, so that any namespace-sensitive values remain
                     valid.</p>
                  <p>Where existing attributes are copied along with their existing type
                     annotations, the rules of the XDM data model require that a parentless
                     attribute node cannot contain a namespace-sensitive typed value; this means
                     that it is an error to copy an attribute using
                        <code>validation="preserve"</code> if it contains namespace-sensitive
                     content.</p>
               </note>
               <p>Namespace fixup is applied to every element that is constructed using a <termref
                     def="dt-literal-result-element">literal result element</termref>, or one of the
                  instructions <elcode>xsl:element</elcode>, <elcode>xsl:copy</elcode>, or
                     <elcode>xsl:copy-of</elcode>. An implementation is not
                     <rfc2119>required</rfc2119> to perform namespace fixup for elements in any
                  source document, that is, for a document in the <termref
                     def="dt-initial-match-selection"/>, documents loaded using the
                     <function>document</function>, <xfunction>doc</xfunction> or
                     <xfunction>collection</xfunction> function, documents supplied as the value of
                  a <termref def="dt-stylesheet-parameter">stylesheet parameter</termref>, or
                  documents returned by an <termref def="dt-extension-function">extension
                     function</termref> or <termref def="dt-extension-instruction">extension
                     instruction</termref>.</p>
               <note>
                  <p>A source document (an input document, a document returned by the
                        <function>document</function>, <xfunction>doc</xfunction> or
                        <xfunction>collection</xfunction> functions, a document returned by an
                     extension function or extension instruction, or a document supplied as a
                     stylesheet parameter) is required to satisfy the constraints described in
                        <bibref ref="xpath-datamodel-30"/>, including the constraints imposed by the
                     namespace fixup process. The effect of supplying a pseudo-document that does
                     not meet these constraints is <termref def="dt-implementation-dependent"
                        >implementation-dependent</termref>.</p>
               </note>
               <p>In an Infoset (see <bibref ref="xml-infoset"/>) created from a document conforming
                  to <bibref ref="xml-names"/>, it will always be true that if a parent element has
                  an in-scope namespace with a non-empty namespace prefix, then its child elements
                  will also have an in-scope namespace with the same namespace prefix, though
                  possibly with a different namespace URI. This constraint is removed in <bibref
                     ref="xml-names11"/>. XSLT <phrase diff="chg" at="A">3.0</phrase> supports the
                  creation of result trees that do not satisfy this constraint: the namespace fixup
                  process does not add a namespace node to an element merely because its parent node
                  in the <termref def="dt-result-tree">result tree</termref> has such a namespace
                  node. However, the process of constructing the children of a new element, which is
                  described in <specref ref="constructing-complex-content"/>, does cause the
                  namespaces of a parent element to be inherited by its children unless this is
                  prevented using <code>[xsl:]inherit-namespaces="no"</code> on the instruction that
                  creates the parent element.</p>
               <note>
                  <p>This has implications on serialization, defined in <bibref
                        ref="xslt-xquery-serialization-30"/>. It means that it is possible to create
                        <termref def="dt-final-result-tree">final result trees</termref> that cannot
                     be faithfully serialized as XML 1.0 documents. When such a result tree is
                     serialized as XML 1.0, namespace declarations written for the parent element
                     will be inherited by its child elements as if the corresponding namespace nodes
                     were present on the child element, except in the case of the default namespace,
                     which can be undeclared using the construct <code>xmlns=""</code>. When the
                     same result tree is serialized as XML 1.1, however, it is possible to undeclare
                     any namespace on the child element (for example, <code>xmlns:foo=""</code>) to
                     prevent this inheritance taking place.</p>
               </note>
            </div3>
         </div2>
         <div2 id="uri-references">
            <head>URI References</head>
            <p>
               <termdef id="dt-uri-reference" term="URI Reference">Within this specification, the
                  term <term>URI Reference</term>, unless otherwise stated, refers to a string in
                  the lexical space of the <code>xs:anyURI</code> datatype as defined in <bibref
                     ref="xmlschema-2"/>.</termdef> Note that this is a wider definition than that
               in <bibref ref="RFC3986"/>: in particular, it is designed to accommodate
               Internationalized Resource Identifiers (IRIs) as described in <bibref ref="RFC3987"
               />, and thus allows the use of non-ASCII characters without escaping.</p>
            <p>URI References are used in XSLT with three main roles:</p>
            <ulist>
               <item>
                  <p>As namespace URIs</p>
               </item>
               <item>
                  <p>As collation URIs</p>
               </item>
               <item>
                  <p>As identifiers for resources such as stylesheet modules; these resources are
                     typically accessible using a protocol such as HTTP. Examples of such
                     identifiers are the URIs used in the <code>href</code> attributes of
                        <elcode>xsl:import</elcode>, <elcode>xsl:include</elcode>, and
                        <elcode>xsl:result-document</elcode>.</p>
               </item>
            </ulist>
            <p>The rules for namespace URIs are given in <bibref ref="xml-names"/> and <bibref
                  ref="xml-names11"/>. Those specifications deprecate the use of relative URI
                  <phrase diff="add" at="F">references</phrase> as namespace URIs.</p>
            <p>The rules for collation URIs are given in <bibref ref="xpath-functions-30"/>.</p>
            <p>URI references used to identify external resources must conform to the same rules as
               the locator attribute (<code>href</code>) defined in section 5.4 of <bibref
                  ref="xlink"/>. If the URI reference is relative, then it is resolved (unless
               otherwise specified) against the base URI of the containing element node, according
               to the rules of <bibref ref="RFC3986"/>, after first escaping all characters that
               need to be escaped to make it a valid RFC3986 URI reference. (But a relative URI
                  <phrase diff="add" at="F">reference</phrase> in the <code>href</code> attribute of
                  <elcode>xsl:result-document</elcode> is resolved against the <termref
                  def="dt-base-output-uri">Base Output URI</termref>.)</p>
            <p>Other URI references appearing in an XSLT stylesheet document, for example the system
               identifiers of external entities or the value of the <code>xml:base</code> attribute,
               must follow the rules in their respective specifications.</p>
            <p diff="add" at="M">The base URI of an element node in the stylesheet is determined as
               defined in <xspecref spec="DM30" ref="dm-base-uri"/>. Some implementations may allow
               the output of the static analysis phase of stylesheet processing (a “compiled
               stylesheet”) to be evaluated in a different location from that where static analysis
               took place. Furthermore, stylesheet authors may in such cases wish to avoid exposing
               the location of resources that are private to the development environment. If the
               base URI of an element in the stylesheet is defined by an absolute URI appearing in
               an <code>xml:base</code> attribute within the stylesheet, this value
                  <rfc2119>must</rfc2119> be used as the static base URI. In other cases where
               processing depends on the static base URI of a stylesheet module, implementations
                  <rfc2119>may</rfc2119> use different values for the static base URI during static
               analysis and during dynamic evaluation (for example, an implementation
                  <rfc2119>may</rfc2119> use different base URIs for resolving
                  <elcode>xsl:import</elcode> module references and for resolving a relative
               reference used as an argument to the <xfunction>doc</xfunction> function). In such
               cases an implementation <rfc2119>must</rfc2119> document how the static base URI is
               computed for each situation in which it is required. </p>
         </div2>
      </div1>
      <div1 id="rules">
         <head>Template Rules</head>
         <p>Template rules define the processing that can be applied to <phrase diff="chg" at="D"
               >items</phrase> that match a particular <termref def="dt-pattern"
            >pattern</termref>.</p>
         <div2 id="defining-templates">
            <head>Defining Templates</head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="template">
               <e:in-category name="declaration"/>
               <e:attribute name="match">
                  <e:data-type name="pattern"/>
               </e:attribute>
               <e:attribute name="name">
                  <e:data-type name="eqname"/>
               </e:attribute>
               <e:attribute name="priority">
                  <e:data-type name="decimal"/>
               </e:attribute>
               <e:attribute name="mode">
                  <e:data-type name="tokens"/>
               </e:attribute>
               <e:attribute name="as">
                  <e:data-type name="sequence-type"/>
               </e:attribute>
               <e:attribute name="visibility">
                  <e:constant value="public"/>
                  <e:constant value="private"/>
                  <e:constant value="final"/>
                  <e:constant value="abstract"/>
               </e:attribute>
               <e:sequence>
                  <e:element repeat="zero-or-one" name="context-item"/>
                  <e:element repeat="zero-or-more" name="param"/>
                  <e:model name="sequence-constructor"/>
               </e:sequence>
               <e:allowed-parents>
                  <e:parent name="package"/>
                  <e:parent name="stylesheet"/>
                  <e:parent name="transform"/>
                  <e:parent name="override"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>
               <termdef id="dt-template" term="template">An <elcode>xsl:template</elcode>
                  declaration defines a <term>template</term>, which contains a <termref
                     def="dt-sequence-constructor">sequence constructor</termref>; <phrase
                     diff="chg" at="I">this sequence constructor is evaluated to determine the
                     result of the template</phrase>. A template can serve either as a <termref
                     def="dt-template-rule">template rule</termref>, invoked by matching <phrase
                     diff="chg" at="C">items</phrase> against a <termref def="dt-pattern"
                     >pattern</termref>, or as a <termref def="dt-named-template">named
                     template</termref>, invoked explicitly by name. It is also possible for the
                  same template to serve in both capacities.</termdef>
            </p>
            <p>
               <error spec="XT" type="static" class="SE" code="0500"><p>An
                        <elcode>xsl:template</elcode> element <rfc2119>must</rfc2119> have either a
                        <code>match</code> attribute or a <code>name</code> attribute, or both. An
                        <elcode>xsl:template</elcode> element that has no <code>match</code>
                     attribute <rfc2119>must</rfc2119> have no <code>mode</code> attribute and no
                        <code>priority</code> attribute. <phrase diff="add" at="I">An
                           <elcode>xsl:template</elcode> element that has no <code>name</code>
                        attribute <rfc2119>must</rfc2119> have no <code>visibility</code>
                        attribute.</phrase></p></error>
            </p>
            <p>If an <elcode>xsl:template</elcode> element has a <code>match</code> attribute, then
               it is a <termref def="dt-template-rule">template rule</termref>. If it has a
                  <code>name</code> attribute, then it is a <termref def="dt-named-template">named
                  template</termref>.</p>
            <p>A <termref def="dt-template">template</termref> may be invoked in a number of ways,
               depending on whether it is a <termref def="dt-template-rule">template rule</termref>,
               a <termref def="dt-named-template">named template</termref>, or both. The result of
               invoking the template is the result of evaluating the <termref
                  def="dt-sequence-constructor">sequence constructor</termref> contained in the
                  <elcode>xsl:template</elcode> element (see <specref ref="sequence-constructors"
               />).</p>
            <p diff="chg" at="P">For details of the optional <elcode>xsl:context-item</elcode> child
               element, see <specref ref="declaring-context-item"/>.</p>
            <p>If an <code>as</code> attribute of the <elcode>xsl:template</elcode> element is
               present, the <code>as</code> attribute defines the required type of the result. The
               result of evaluating the <termref def="dt-sequence-constructor">sequence
                  constructor</termref> is then converted to the required type using the <termref
                  def="dt-function-conversion-rules">function conversion rules</termref>. If no
                  <code>as</code> attribute is specified, the default value is <code>item()*</code>,
               which permits any value. No conversion then takes place.</p>
            <p>
               <error spec="XT" type="type" class="TE" code="0505"><p>It is a <termref
                        def="dt-type-error">type error</termref> if the result of evaluating the
                        <termref def="dt-sequence-constructor">sequence constructor</termref> cannot
                     be converted to the required type.</p></error>
            </p>
            <p diff="add" at="I">If the <code>visibility</code> attribute is present with the value
                  <code>abstract</code> then (a) the <termref def="dt-sequence-constructor"/>
               defining the template body <rfc2119>must</rfc2119> be empty: that is, the only
               permitted children are <elcode>xsl:context-item</elcode> and
                  <elcode>xsl:param</elcode>, and (b) there <rfc2119>must</rfc2119> be no
                  <code>match</code> attribute.</p>
            <p diff="chg" at="S-bug29209">If the parent of the <elcode>xsl:template</elcode> element
               is an <elcode>xsl:override</elcode> element, then either or both of the following
               conditions must be true:</p>
            <olist diff="chg" at="S-bug29209">
               <item>
                  <p>There is a <code>name</code> attribute, and the <termref def="dt-package"
                        >package</termref> identified by the containing
                        <elcode>xsl:use-package</elcode> element contains among its <termref
                        def="dt-component">components</termref> a <termref def="dt-named-template"
                        >named template</termref> whose <termref def="dt-symbolic-identifier"
                        >symbolic identifier</termref> is the same as that of this named template,
                     and which has a <termref def="dt-compatible">compatible</termref>
                     signature.</p>
               </item>
               <item>
                  <p>Both the following conditions are true:</p>
                  <olist>
                     <item>
                        <p>There is a <code>match</code> attribute.</p>
                     </item>
                     <item>
                        <p>The value of the <code>mode</code> attribute, or in its absence the
                           string <code>#default</code>, is a whitespace-separated sequence of
                           tokens in which each token satisfies one of the following conditions:</p>
                        <olist>
                           <item>
                              <p>The token is an EQName representing the name of a mode that is
                                 exposed, with visibility equal to <code>public</code>, by the
                                 package identified by the containing
                                    <elcode>xsl:use-package</elcode> element.</p>
                           </item>
                           <item>
                              <p>The token is <code>#default</code>, and there is an
                                 ancestor-or-self element with a <code>default-mode</code> attribute
                                 whose value is an EQName representing the name of a mode that is
                                 exposed, with visibility equal to <code>public</code>, by the
                                 package identified by the containing
                                    <elcode>xsl:use-package</elcode> element.</p>
                           </item>
                        </olist>
                     </item>
                  </olist>
                  <note>
                     <p>The token <code>#unnamed</code> is not allowed because the unnamed mode
                        never has public visibility. The token <code>#all</code> is not allowed
                        because its intended meaning would not be obvious. </p>
                  </note>
               </item>
            </olist>
         </div2>
         <div2 id="defining-template-rules">
            <head>Defining Template Rules</head>
            <p>This section describes <termref def="dt-template-rule">template rules</termref>.
                  <termref def="dt-named-template">Named templates</termref> are described in
                  <specref ref="named-templates"/>.</p>
            <p>A <termref def="dt-template-rule">template rule</termref> is specified using the
                  <elcode>xsl:template</elcode> element with a <code>match</code> attribute. The
                  <code>match</code> attribute is a <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                  def="doc-xslt30-patterns-Pattern30" xlink:type="simple">Pattern</nt> that
               identifies the <phrase diff="chg" at="C">items</phrase> to which the rule applies.
               The result of applying the template rule is the result of evaluating the sequence
               constructor contained in the <elcode>xsl:template</elcode> element, with the matching
                  <phrase diff="chg" at="C">item</phrase> used as the <phrase diff="chg" at="C"
                     ><termref def="dt-context-item">context item</termref></phrase>.</p>
            <example>
               <head>A Simple Template Rule</head>
               <p>For example, an XML document might contain:</p>
               <eg xml:space="preserve" role="xml">This is an &lt;emph&gt;important&lt;/emph&gt; point.</eg>
               <p>The following <termref def="dt-template-rule">template rule</termref> matches
                     <code>emph</code> elements and produces a <code>fo:wrapper</code> element with
                  a <code>font-weight</code> property of <code>bold</code>.</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="emph"&gt;
  &lt;fo:wrapper font-weight="bold" 
              xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:wrapper&gt;
&lt;/xsl:template&gt;
</eg>
            </example>
            <p>A <termref def="dt-template-rule">template rule</termref> is evaluated when an
                  <elcode>xsl:apply-templates</elcode> instruction selects <phrase diff="chg" at="C"
                  >an item</phrase> that matches the pattern specified in the <code>match</code>
               attribute. The <elcode>xsl:apply-templates</elcode> instruction is described in the
               next section. If several template rules match a selected <phrase diff="chg" at="C"
                  >item</phrase>, only one of them is evaluated, as described in <specref
                  ref="conflict"/>.</p>
         </div2>
         <div2 id="applying-templates">
            <head>Applying Template Rules</head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="apply-templates">
               <e:in-category name="instruction"/>
               <e:attribute name="select">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="mode">
                  <e:data-type name="token"/>
               </e:attribute>
               <e:choice repeat="zero-or-more">
                  <e:element name="sort"/>
                  <e:element name="with-param"/>
               </e:choice>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:apply-templates</elcode> instruction takes as input a sequence of
                  <phrase diff="chg" at="C">items</phrase> (typically nodes in a <termref
                  def="dt-source-tree">source tree</termref>), and produces as output a sequence of
               items; these will often be nodes to be added to a <termref def="dt-result-tree"
                  >result tree</termref>.</p>
            <p>If the instruction has one or more <elcode>xsl:sort</elcode> children, then the input
               sequence is sorted as described in <specref ref="sorting"/>. The result of this sort
               is referred to below as the <term>sorted sequence</term>; if there are no
                  <elcode>xsl:sort</elcode> elements, then the sorted sequence is the same as the
               input sequence.</p>
            <p>Each <phrase diff="chg" at="C">item</phrase> in the input sequence is processed by
               finding a <termref def="dt-template-rule">template rule</termref> whose <termref
                  def="dt-pattern">pattern</termref> matches that <phrase diff="chg" at="C"
                  >item</phrase>. If there is more than one such template rule, the best among them
               is chosen, using rules described in <specref ref="conflict"/>. If there is no
               template rule whose pattern matches the <phrase diff="chg" at="C">item</phrase>, a
               built-in template rule is used (see <specref ref="built-in-rule"/>). The chosen
               template rule is evaluated. The rule that matches the <var>N</var>th <phrase
                  diff="chg" at="C">item</phrase> in the sorted sequence is evaluated with that
                  <phrase diff="chg" at="C">item</phrase> as the <termref def="dt-context-item"
                  >context item</termref>, with <var>N</var> as the <termref
                  def="dt-context-position">context position</termref>, and with the length of the
               sorted sequence as the <termref def="dt-context-size">context size</termref>. Each
               template rule that is evaluated produces a sequence of items as its result. The
               resulting sequences (one for each <phrase diff="chg" at="C">item</phrase> in the
               sorted sequence) are then concatenated, to form a single sequence. They are
               concatenated retaining the order of the <phrase diff="chg" at="C">items</phrase> in
               the sorted sequence. The final concatenated sequence forms the result of the
                  <elcode>xsl:apply-templates</elcode> instruction. </p>
            <example>
               <head>Applying Template Rules</head>
               <p>Suppose the source document is as follows:</p>
               <eg xml:space="preserve" role="xml">&lt;message&gt;Proceed &lt;emph&gt;at once&lt;/emph&gt; to the exit!&lt;/message&gt;</eg>
               <p>This can be processed using the two template rules shown below.</p>
               <eg xml:space="preserve" role="xslt-declarations">&lt;xsl:template match="message"&gt;
  &lt;p&gt;
    &lt;xsl:apply-templates select="child::node()"/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="emph"&gt;
  &lt;b&gt;
    &lt;xsl:apply-templates select="child::node()"/&gt;
  &lt;/b&gt;
&lt;/xsl:template&gt;</eg>
               <p>There is no template rule for the document node; the built-in template rule for
                  this node will cause the <code>message</code> element to be processed. The
                  template rule for the <code>message</code> element causes a <code>p</code> element
                  to be written to the <termref def="dt-result-tree">result tree</termref>; the
                  contents of this <code>p</code> element are constructed as the result of the
                     <elcode>xsl:apply-templates</elcode> instruction. This instruction selects the
                  three child nodes of the <code>message</code> element (a text node containing the
                  value <code>Proceed </code>, an <code>emph</code> element node, and a text node
                  containing the value <code> to the exit!</code>). The two text nodes are processed
                  using the built-in template rule for text nodes, which returns a copy of the text
                  node. The <code>emph</code> element is processed using the explicit template rule
                  that specifies <code>match="emph"</code>.</p>
               <p>When the <code>emph</code> element is processed, this template rule constructs a
                     <code>b</code> element. The contents of the <code>b</code> element are
                  constructed by means of another <elcode>xsl:apply-templates</elcode> instruction,
                  which in this case selects a single node (the text node containing the value
                     <code>at once</code>). This is again processed using the built-in template rule
                  for text nodes, which returns a copy of the text node.</p>
               <p>The final result of the <code>match="message"</code> template rule thus consists
                  of a <code>p</code> element node with three children: a text node containing the
                  value <code>Proceed </code>, a <code>b</code> element that is the parent of a text
                  node containing the value <code>at once</code>, and a text node containing the
                  value <code> to the exit!</code>. This <termref def="dt-result-tree">result
                     tree</termref> might be serialized as:</p>
               <eg xml:space="preserve" role="xml">&lt;p&gt;Proceed &lt;b&gt;at once&lt;/b&gt; to the exit!&lt;/p&gt;</eg>
            </example>
            <p>The default value of the <code>select</code> attribute is <code>child::node()</code>,
               which causes all the children of the context node to be processed.</p>
            <p>
               <error spec="XT" type="type" class="TE" code="0510"><p>It is a <termref
                        def="dt-type-error">type error</termref> if an
                        <elcode>xsl:apply-templates</elcode> instruction with no <code>select</code>
                     attribute is evaluated when the <termref def="dt-context-item">context
                        item</termref> is not a node. </p></error>
            </p>
            <p>A <code>select</code> attribute can be used to process <phrase diff="chg" at="C"
                  >items</phrase> selected by an expression instead of processing all children. The
               value of the <code>select</code> attribute is an <termref def="dt-expression"
                  >expression</termref>. <phrase diff="del" at="C">The expression
                     <rfc2119>must</rfc2119> evaluate to a sequence of nodes (it can contain zero,
                  one, or more nodes).</phrase></p>
            <p diff="del" at="C">
               <error spec="XT" type="type" class="TE" code="0520"><p>It is a <termref
                        def="dt-type-error">type error</termref> if the sequence returned by the
                        <code>select</code> expression <error.extra>of
                           <elcode>xsl:apply-templates</elcode>
                     </error.extra> contains an item that is not a node.</p></error>
            </p>
            <note diff="del" at="A">
               <p>In XSLT 1.0, the <code>select</code> attribute selected a set of nodes, which by
                  default were processed in document order. In XSLT 2.0, it selects a sequence of
                  nodes. In cases that would have been valid in XSLT 1.0, the expression will return
                  a sequence of nodes in document order, so the effect is the same.</p>
            </note>
            <example>
               <head>Applying Templates to Selected Nodes</head>
               <p>The following example processes all of the <code>given-name</code> children of the
                     <code>author</code> elements that are children of
                  <code>author-group</code>:</p>
               <eg xml:space="preserve" role="xslt-declaration xmlns:fo='fo'">&lt;xsl:template match="author-group"&gt;
  &lt;fo:wrapper&gt;
    &lt;xsl:apply-templates select="author/given-name"/&gt;
  &lt;/fo:wrapper&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <example>
               <head>Applying Templates to Nodes that are not Descendants</head>
               <p>It is also possible to process elements that are not descendants of the context
                  node. This example assumes that a <code>department</code> element has
                     <code>group</code> children and <code>employee</code> descendants. It finds an
                  employee’s department and then processes the <code>group</code> children of the
                     <code>department</code>.</p>
               <eg xml:space="preserve" role="xslt-declaration xmlns:fo='fo'">&lt;xsl:template match="employee"&gt;
  &lt;fo:block&gt;
    Employee &lt;xsl:apply-templates select="name"/&gt; belongs to group
    &lt;xsl:apply-templates select="ancestor::department/group"/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <example>
               <head>Matching Nodes by Schema-Defined Types</head>
               <p>It is possible to write template rules that are matched according to the
                  schema-defined type of an element or attribute. The following example applies
                  different formatting to the children of an element depending on their type:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="product"&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/*" priority="3"&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;xsl:value-of select="name()"/&gt;&lt;/td&gt;
    &lt;td&gt;&lt;xsl:next-match/&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/element(*, xs:decimal) | 
                     product/element(*, xs:double)" priority="2"&gt;  
  &lt;xsl:value-of select="format-number(xs:double(.), '#,###0.00')"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/element(*, xs:date)" priority="2"&gt;
  &lt;xsl:value-of select="format-date(., '[Mn] [D], [Y]')"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/*" priority="1.5"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;</eg>
               <p>The <elcode>xsl:next-match</elcode> instruction is described in <specref
                     ref="apply-imports"/>.</p>
            </example>
            <example>
               <head>Re-ordering Elements in the Result Tree</head>
               <p>Multiple <elcode>xsl:apply-templates</elcode> elements can be used within a single
                  template to do simple reordering. The following example creates two HTML tables.
                  The first table is filled with domestic sales while the second table is filled
                  with foreign sales.</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="product"&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="sales/domestic"/&gt;
  &lt;/table&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="sales/foreign"/&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <example>
               <head>Processing Recursive Structures</head>
               <p>It is possible for there to be two matching descendants where one is a descendant
                  of the other. This case is not treated specially: both descendants will be
                  processed as usual.</p>
               <p> For example, given a source document</p>
               <eg xml:space="preserve" role="xml">&lt;doc&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/doc&gt;</eg>
               <p>the rule</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="doc"&gt;
  &lt;xsl:apply-templates select=".//div"/&gt;
&lt;/xsl:template&gt;</eg>
               <p>will process both the outer <code>div</code> and inner <code>div</code>
                  elements.</p>
               <p>This means that if the template rule for the <code>div</code> element processes
                  its own children, then these grandchildren will be processed more than once, which
                  is probably not what is required. The solution is to process one level at a time
                  in a recursive descent, by using <code>select="div"</code> in place of
                     <code>select=".//div"</code>
               </p>
            </example>
            <example diff="chg" at="O">
               <head>Applying Templates to Atomic Values</head>
               <p>This example reads a non-XML text file and processes it line-by-line, applying
                  different template rules based on the content of each line:</p>
               <eg xml:space="preserve" role="xslt-declarations">&lt;xsl:template name="main"&gt;
  &lt;xsl:apply-templates select="unparsed-text-lines('input.txt')"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match=".[starts-with(., '==')]"&gt;
  &lt;h2&gt;&lt;xsl:value-of select="replace(., '==', '')"/&gt;&lt;/h2&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match=".[starts-with(., '::')]"&gt;
  &lt;p class="indent"&gt;&lt;xsl:value-of select="replace(., '::', '')"/&gt;&lt;/p&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="."&gt;
  &lt;p class="body"&gt;&lt;xsl:value-of select="."/&gt;&lt;/p&gt;
&lt;/xsl:template&gt;

</eg>
            </example>
            <note>
               <p>The <elcode>xsl:apply-templates</elcode> instruction is most commonly used to
                  process nodes that are descendants of the context node. Such use of
                     <elcode>xsl:apply-templates</elcode> cannot result in non-terminating
                  processing loops. However, when <elcode>xsl:apply-templates</elcode> is used to
                  process elements that are not descendants of the context node, the possibility
                  arises of non-terminating loops. For example,</p>
               <eg role="error" xml:space="preserve">&lt;xsl:template match="foo"&gt;
  &lt;xsl:apply-templates select="."/&gt;
&lt;/xsl:template&gt;</eg>
               <p>Implementations may be able to detect such loops in some cases, but the
                  possibility exists that a <termref def="dt-stylesheet">stylesheet</termref> may
                  enter a non-terminating loop that an implementation is unable to detect. This may
                  present a denial of service security risk.</p>
            </note>
         </div2>
         <div2 id="conflict">
            <head>Conflict Resolution for Template Rules</head>
            <p>It is possible for <phrase diff="chg" at="C">a selected item</phrase> to match more
               than one <termref def="dt-template-rule">template rule</termref> with a given
                  <termref def="dt-mode">mode</termref>
               <var>M</var>. When this happens, only one template rule is evaluated for the <phrase
                  diff="chg" at="C">item</phrase>. The template rule to be used is determined as
               follows:</p>
            <olist>
               <item>
                  <p>First, only the matching template rule or rules with the highest <termref
                        def="dt-import-precedence">import precedence</termref> are considered. Other
                     matching template rules with lower precedence are eliminated from
                     consideration.</p>
               </item>
               <item>
                  <p>Next, of the remaining matching rules, only those with the highest priority are
                     considered. Other matching template rules with lower priority are eliminated
                     from consideration.</p>
                  <p><termdef term="priority" id="dt-priority">The <term>priority</term> of a
                        template rule is specified by the <code>priority</code> attribute on the
                           <elcode>xsl:template</elcode> declaration. If no priority is specified
                        explicitly for a template rule, its <termref def="dt-default-priority"
                           >default priority</termref> is used, as defined in <specref
                           ref="default-priority"/>.</termdef></p>
                  <p>
                     <error spec="XT" type="static" class="SE" code="0530"><p>The value of the
                              <code>priority</code> attribute <error.extra> of the
                                 <elcode>xsl:template</elcode> element</error.extra>
                           <rfc2119>must</rfc2119> conform to the rules for the
                              <code>xs:decimal</code> type defined in <bibref ref="xmlschema-2"/>.
                           Negative values are permitted.</p></error>
                  </p>
               </item>
               <item diff="add" at="C">
                  <p>If this leaves more than one matching template rule, then:</p>
                  <olist>
                     <item>
                        <p>If the <termref def="dt-mode">mode</termref>
                           <var>M</var> has an <elcode>xsl:mode</elcode> declaration, and the
                           attribute value <code>on-multiple-match="fail"</code> is specified in the
                           mode declaration, a dynamic error is signaled. The error is treated as
                           occurring in the <elcode>xsl:apply-templates</elcode> instruction, and
                           can be recovered by wrapping that instruction in an
                              <elcode>xsl:try</elcode> instruction.</p>
                        <p diff="chg" at="C">
                           <error spec="XT" type="dynamic" class="DE" code="0540"><p>It is a
                                    <termref def="dt-dynamic-error"><phrase diff="del" at="M"
                                       >non-recoverable</phrase> dynamic error</termref> if the
                                 conflict resolution algorithm for template rules leaves more than
                                 one matching template rule <phrase diff="add" at="G"> when the
                                    declaration of the relevant <termref def="dt-mode"
                                       >mode</termref> has an <code>on-multiple-match</code>
                                    attribute with the value
                           <code>fail</code></phrase>.</p></error></p>
                     </item>
                     <item>
                        <p>Otherwise, of the matching template rules that remain, the one that
                           occurs last in <termref def="dt-declaration-order">declaration
                              order</termref> is used.</p>
                     </item>
                  </olist>
                  <note diff="add" at="C">
                     <p>This was a recoverable error in XSLT 2.0, meaning that it was
                        implementation-defined whether the error was signaled, or whether the
                        ambiguity was resolved by taking the last matching rule in declaration
                        order. <phrase diff="del" at="M">The choice of error code reflects this
                           legacy.</phrase> In XSLT 3.0 this situation is not an error unless the
                        attribute value <code>on-multiple-match="fail"</code> is specified in the
                        mode declaration. It is also possible to request warnings when this
                        condition arises, by means of the attribute <phrase diff="chg" at="F"
                              ><code>warning-on-multiple-match="yes"</code></phrase>. </p>
                  </note>
               </item>
            </olist>
         </div2>
         <div2 id="default-priority">
            <head>Default Priority for Template Rules</head>
            <p><termdef id="dt-default-priority" term="default priority">If no <code>priority</code>
                  attribute is specified on an <elcode>xsl:template</elcode> element, a
                     <term>default priority</term> is computed, based on the syntax of the <termref
                     def="dt-pattern">pattern</termref> supplied in the <code>match</code>
                  attribute.</termdef> The rules are as follows. </p>
            <olist>
               <item diff="add" at="P-bug22767">
                  <p>If the top-level pattern is a <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                        def="doc-xslt30-patterns-ParenthesizedExprP" xlink:type="simple"
                        >ParenthesizedExprP</nt> then the outer parentheses are effectively
                     stripped; these rules are applied recursively to the <nt
                        xmlns:xlink="http://www.w3.org/1999/xlink"
                        def="doc-xslt30-patterns-UnionExprP" xlink:type="simple">UnionExprP</nt>
                     contained in the <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                        def="doc-xslt30-patterns-ParenthesizedExprP" xlink:type="simple"
                        >ParenthesizedExprP</nt>.</p>
               </item>
               <item diff="add" at="C">
                  <p>If the top-level pattern is a <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                        def="doc-xslt30-patterns-UnionExprP" xlink:type="simple">UnionExprP</nt>
                     consisting of multiple alternatives separated by <code>|</code> or
                        <code>union</code>, then the template rule is treated equivalently to a set
                     of template rules, one for each alternative. <phrase diff="del" at="P">However,
                        it is not an error if an <phrase diff="chg" at="C">item</phrase> matches
                        more than one of the alternatives.</phrase>
                     <phrase diff="add" at="P-bug23329">These template rules are adjacent to each
                        other in declaration order, and the declaration order within this set of
                        template rules (which affects the result of <elcode>xsl:next-match</elcode>
                        if the alternatives have the same default priority) is the order of
                        alternatives in the <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                           def="doc-xslt30-patterns-UnionExprP" xlink:type="simple"
                        >UnionExprP</nt>.</phrase></p>
                  <note diff="add" at="P-bug23329">
                     <p>The splitting of a template rule into multiple rules occurs only if there is
                        no explicit <code>priority</code> attribute.</p>
                  </note>
               </item>
               <item diff="add" at="C">
                  <p>If the top-level pattern is an <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                        def="doc-xslt30-patterns-IntersectExceptExprP" xlink:type="simple"
                        >IntersectExceptExprP</nt> containing two or more <nt
                        xmlns:xlink="http://www.w3.org/1999/xlink"
                        def="doc-xslt30-patterns-PathExprP" xlink:type="simple">PathExprP</nt>
                     operands separated by <code>intersect</code> or <code>except</code> operators,
                     then the priority of the pattern is that of the first <nt
                        xmlns:xlink="http://www.w3.org/1999/xlink"
                        def="doc-xslt30-patterns-PathExprP" xlink:type="simple">PathExprP</nt>. </p>
               </item>
               <item>
                  <p diff="chg" at="O">If the pattern is a <nt
                        xmlns:xlink="http://www.w3.org/1999/xlink"
                        def="doc-xslt30-patterns-PredicatePattern" xlink:type="simple"
                        >PredicatePattern</nt> then its priority is 1 (one), unless the <xnt
                        xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                        ref="prod-xpath30-PredicateList" xlink:type="simple">PredicateList</xnt> is
                     empty, in which case the priority is −1 (minus one).</p>
                  <p diff="del" at="N">If the pattern (in its entirety) is a TypePattern with an
                     empty <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                        ref="prod-xpath30-PredicateList" xlink:type="simple">PredicateList</xnt>,
                     then:</p>
                  <olist diff="del" at="N">
                     <item>
                        <p>If the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                              ref="prod-xpath30-ItemType" xlink:type="simple">ItemType</xnt> is
                              <code>item()</code>, the priority is −2 (minus two).</p>
                     </item>
                     <item>
                        <p>If the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                              ref="prod-xpath30-ItemType" xlink:type="simple">ItemType</xnt> is
                              <code>node()</code>, <code>function(*)</code>, or
                              <code>xs:anyAtomicType</code>, the priority is −1 (minus one).</p>
                     </item>
                     <item>
                        <p>If the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                              ref="prod-xpath30-ItemType" xlink:type="simple">ItemType</xnt> is any
                           other atomic type, the priority is the priority associated with its base
                           type plus 1. This means for example that the priority of
                              <code>~xs:decimal</code> is 0 (zero), and the priority of
                              <code>~xs:integer</code> is +1 (plus one).</p>
                     </item>
                     <item>
                        <p diff="add" at="K">If the <xnt xmlns:xlink="http://www.w3.org/1999/xlink"
                              spec="XP30" ref="prod-xpath30-ItemType" xlink:type="simple"
                              >ItemType</xnt> is a union type, the priority is the minimum priority
                           of the atomic types in the transitive membership of the union, minus 0.5.
                           This means for example that the priority of a type formed as the union of
                              <code>xs:date</code> and <code>xs:dateTime</code> has a lower priority
                           than <code>xs:dateTime</code> but a higher priority than
                              <code>xs:anyAtomicType</code>, while a type formed as the union of
                              <code>xs:ID</code> and <code>xs:IDREF</code> has a lower priority than
                              <code>xs:IDREF</code> but a higher priority than
                              <code>xs:NCName</code>.</p>
                     </item>
                     <item>
                        <p>If the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                              ref="prod-xpath30-ItemType" xlink:type="simple">ItemType</xnt> is any
                           other <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                              ref="prod-xpath30-NodeTest" xlink:type="simple">NodeTest</xnt>, the
                           priority is the same as when that NodeTest appears as a pattern in its
                           own right (see below). For example, the priority of
                              <code>~element()</code> is −0.5 (minus 0.5), while that of
                              <code>~element(E)</code> is 0 (zero).</p>
                     </item>
                     <item>
                        <p diff="chg" at="K">If the <xnt xmlns:xlink="http://www.w3.org/1999/xlink"
                              spec="XP30" ref="prod-xpath30-ItemType" xlink:type="simple"
                              >ItemType</xnt> is an <xnt xmlns:xlink="http://www.w3.org/1999/xlink"
                              spec="XP30" ref="prod-xpath30-AnyFunctionTest" xlink:type="simple"
                              >AnyFunctionTest</xnt> the priority is -1, while for any other <xnt
                              xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                              ref="prod-xpath30-TypedFunctionTest" xlink:type="simple"
                              >TypedFunctionTest</xnt>, the priority is 0 (zero).</p>
                     </item>
                     <item>
                        <p diff="add" at="K">If the <xnt xmlns:xlink="http://www.w3.org/1999/xlink"
                              spec="XP30" ref="prod-xpath30-ItemType" xlink:type="simple"
                              >ItemType</xnt> is a <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                              def="doc-xslt30-patterns-NT-MapType" xlink:type="simple">MapType</nt>
                           of the form <code>map(*)</code>, then the priority is +0.5, while for a
                              <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                              def="doc-xslt30-patterns-NT-MapType" xlink:type="simple">MapType</nt>
                           of the form <code>map(K, V)</code> the priority is the same as that of
                           the pattern <code>~K</code>.</p>
                     </item>
                  </olist>
               </item>
               <item diff="del" at="N">
                  <p>If the pattern (in its entirety) is a TypePattern with a non-empty <xnt
                        xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                        ref="prod-xpath30-PredicateList" xlink:type="simple">PredicateList</xnt>,
                     then the priority is that of the <xnt
                        xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                        ref="prod-xpath30-ItemType" xlink:type="simple">ItemType</xnt> in the
                     absence of the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                        ref="prod-xpath30-PredicateList" xlink:type="simple">PredicateList</xnt>, as
                     given above, plus 0.5. So, for example, the priority of the pattern
                        <code>~xs:integer[. gt 0]</code> is +1.5.</p>
               </item>
               <item>
                  <p>If the pattern is a <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                        def="doc-xslt30-patterns-PathExprP" xlink:type="simple">PathExprP</nt>
                     taking the form <code>/</code>, then the priority is −0.5 (minus 0.5).</p>
               </item>
               <item>
                  <p>If the pattern is a <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                        def="doc-xslt30-patterns-PathExprP" xlink:type="simple">PathExprP</nt>
                     taking the form of an <termref def="dt-eqname">EQName</termref> optionally
                     preceded by a <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                        def="doc-xslt30-patterns-ForwardAxisP" xlink:type="simple">ForwardAxisP</nt>
                     or has the form <code>processing-instruction(</code>
                     <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                        ref="prod-xpath30-StringLiteral" xlink:type="simple">StringLiteral</xnt>
                     <code>)</code> or <code>processing-instruction(</code>
                     <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names" ref="NT-NCName"
                        xlink:type="simple">NCName</xnt>
                     <code>)</code> optionally preceded by a <nt
                        xmlns:xlink="http://www.w3.org/1999/xlink"
                        def="doc-xslt30-patterns-ForwardAxisP" xlink:type="simple"
                     >ForwardAxisP</nt>, then the priority is 0 (zero).</p>
               </item>
               <item>
                  <p>If the pattern is a <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                        def="doc-xslt30-patterns-PathExprP" xlink:type="simple">PathExprP</nt>
                     taking the form of an <xnt xmlns:xlink="http://www.w3.org/1999/xlink"
                        spec="XP30" ref="prod-xpath30-ElementTest" xlink:type="simple"
                        >ElementTest</xnt> or <xnt xmlns:xlink="http://www.w3.org/1999/xlink"
                        spec="XP30" ref="prod-xpath30-AttributeTest" xlink:type="simple"
                        >AttributeTest</xnt>, optionally preceded by a <nt
                        xmlns:xlink="http://www.w3.org/1999/xlink"
                        def="doc-xslt30-patterns-ForwardAxisP" xlink:type="simple"
                     >ForwardAxisP</nt>, then the priority is as shown in the table below. In this
                     table, the symbols <var>E</var>, <var>A</var>, and <var>T</var> represent an
                     arbitrary element name, attribute name, and type name respectively, while the
                     symbol <code>*</code> represents itself. The presence or absence of the symbol
                        <code>?</code> following a type name does not affect the priority.</p>
                  <table class="data">
                     <caption>Default Priority of Patterns</caption>
                     <thead>
                        <tr>
                           <th rowspan="1" colspan="1">Format</th>
                           <th rowspan="1" colspan="1">Priority</th>
                           <th rowspan="1" colspan="1">Notes</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>element()</code>
                           </td>
                           <td rowspan="1" colspan="1">−0.5</td>
                           <td rowspan="1" colspan="1">(equivalent to <code>*</code>)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>element(*)</code>
                           </td>
                           <td rowspan="1" colspan="1">−0.5</td>
                           <td rowspan="1" colspan="1">(equivalent to <code>*</code>)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>attribute()</code>
                           </td>
                           <td rowspan="1" colspan="1">−0.5</td>
                           <td rowspan="1" colspan="1">(equivalent to <code>@*</code>)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>attribute(*)</code>
                           </td>
                           <td rowspan="1" colspan="1">−0.5</td>
                           <td rowspan="1" colspan="1">(equivalent to <code>@*</code>)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>element(<var>E</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0</td>
                           <td rowspan="1" colspan="1">(equivalent to E)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>element(*,<var>T</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0</td>
                           <td rowspan="1" colspan="1">(matches by type only)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>attribute(<var>A</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0</td>
                           <td rowspan="1" colspan="1">(equivalent to <code>@A</code>)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>attribute(*,<var>T</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0</td>
                           <td rowspan="1" colspan="1">(matches by type only)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>element(<var>E</var>,<var>T</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0.25</td>
                           <td rowspan="1" colspan="1">(matches by name and type)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>schema-element(<var>E</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0.25</td>
                           <td rowspan="1" colspan="1">(matches by substitution group and type)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>attribute(<var>A</var>,<var>T</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0.25</td>
                           <td rowspan="1" colspan="1">(matches by name and type)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>schema-attribute(<var>A</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0.25</td>
                           <td rowspan="1" colspan="1">(matches by name and type)</td>
                        </tr>
                     </tbody>
                  </table>
               </item>
               <item>
                  <p>If the pattern is a <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                        def="doc-xslt30-patterns-PathExprP" xlink:type="simple">PathExprP</nt>
                     taking the form of a <xnt xmlns:xlink="http://www.w3.org/1999/xlink"
                        spec="XP30" ref="prod-xpath30-DocumentTest" xlink:type="simple"
                        >DocumentTest</xnt>, then if it includes no <xnt
                        xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                        ref="prod-xpath30-ElementTest" xlink:type="simple">ElementTest</xnt> or <xnt
                        xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                        ref="prod-xpath30-SchemaElementTest" xlink:type="simple"
                        >SchemaElementTest</xnt> the priority is −0.5. If it does include an <xnt
                        xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                        ref="prod-xpath30-ElementTest" xlink:type="simple">ElementTest</xnt> or <xnt
                        xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                        ref="prod-xpath30-SchemaElementTest" xlink:type="simple"
                        >SchemaElementTest</xnt>, then the priority is the same as the priority of
                     that <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                        ref="prod-xpath30-ElementTest" xlink:type="simple">ElementTest</xnt> or <xnt
                        xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                        ref="prod-xpath30-SchemaElementTest" xlink:type="simple"
                        >SchemaElementTest</xnt>, computed according to the table above.</p>
               </item>
               <item>
                  <p>If the pattern is a <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                        def="doc-xslt30-patterns-PathExprP" xlink:type="simple">PathExprP</nt>
                     taking the form of an <xnt xmlns:xlink="http://www.w3.org/1999/xlink"
                        spec="Names" ref="NT-NCName" xlink:type="simple">NCName</xnt><code>:*</code>
                     or <code>*:</code><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names"
                        ref="NT-NCName" xlink:type="simple">NCName</xnt>, optionally preceded by a
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                        def="doc-xslt30-patterns-ForwardAxisP" xlink:type="simple"
                     >ForwardAxisP</nt>, then the priority is −0.25.</p>
               </item>
               <item>
                  <p>If the pattern is a <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                        def="doc-xslt30-patterns-PathExprP" xlink:type="simple">PathExprP</nt>
                     taking the form of any other <xnt xmlns:xlink="http://www.w3.org/1999/xlink"
                        spec="XP30" ref="prod-xpath30-NodeTest" xlink:type="simple">NodeTest</xnt>,
                     optionally preceded by a <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                        def="doc-xslt30-patterns-ForwardAxisP" xlink:type="simple"
                     >ForwardAxisP</nt>, then the priority is −0.5.</p>
               </item>
               <item>
                  <p>In all other cases, the priority is +0.5.</p>
               </item>
            </olist>
            <note>
               <p>In many cases this means that highly selective patterns have higher priority than
                  less selective patterns. The most common kind of pattern (a pattern that tests for
                  a node of a particular kind, with a particular <termref def="dt-expanded-qname"
                     >expanded QName</termref> or a particular type) has priority 0. The next less
                  specific kind of pattern (a pattern that tests for a node of a particular kind and
                  an <termref def="dt-expanded-qname">expanded QName</termref> with a particular
                  namespace URI) has priority −0.25. Patterns less specific than this (patterns that
                  just test for nodes of a given kind) have priority −0.5. Patterns that specify
                  both the name and the required type have a priority of +0.25, putting them above
                  patterns that only specify the name <emph>or</emph> the type. Patterns more
                  specific than this, for example patterns that include predicates or that specify
                  the ancestry of the required node, have priority 0.5.</p>
               <p diff="del" at="N">In the case of a TypePattern, the default priority reflects the
                  position of the type in the type hierarchy.</p>
               <p>However, it is not invariably true that a more selective pattern has higher
                  priority than a less selective pattern. For example, the priority of the pattern
                     <code>node()[self::*]</code> is higher than that of the pattern
                     <code>salary</code>. Similarly, the patterns <code>attribute(*,
                     xs:decimal)</code> and <code>attribute(*, xs:short)</code> have the same
                  priority, despite the fact that the latter pattern matches a subset of the nodes
                  matched by the former. Therefore, to achieve clarity in a <termref
                     def="dt-stylesheet">stylesheet</termref> it is good practice to allocate
                  explicit priorities.</p>
               <p diff="del" at="P">The rules are based on the raw syntax of the pattern as written.
                  So, for example, enclosing a pattern in parentheses changes its priority; and the
                  rule that a template rule with <code>match="a|b"</code> is treated as two separate
                  template rules does not apply if the pattern is written as
                     <code>match="(a|b)"</code>.</p>
            </note>
         </div2>
         <div2 id="modes">
            <head>Modes</head>
            <p diff="chg" at="S-bug27676">
               <termdef id="dt-mode" term="mode"> A <term>mode</term> is a set of template rules;
                  when the <elcode>xsl:apply-templates</elcode> instruction selects a set of items
                  for processing, it identifies the rules to be used for processing those items by
                  nominating a mode, explicitly or implicitly.</termdef> Modes allow a node in a
                  <termref def="dt-source-tree">source tree</termref> (for example) to be processed
               multiple times, each time producing a different result. They also allow different
               sets of <termref def="dt-template-rule">template rules</termref> to be active when
               processing different trees, for example when processing documents loaded using the
                  <function>document</function> function (see <specref ref="func-document"/>). </p>
            <p diff="add" at="A">Modes are identified by an <termref def="dt-expanded-qname"
                  >expanded QName</termref>; in addition to any named modes, there is always one
               unnamed mode available. Whether a mode is named or unnamed, its properties
                  <rfc2119>may</rfc2119> be defined in an <elcode>xsl:mode</elcode> declaration. If
               a mode name is used (for example in an <elcode>xsl:template</elcode> declaration or
               an <elcode>xsl:apply-templates</elcode> instruction) and no declaration of that mode
               appears in the stylesheet, the mode is implicitly declared with default
               properties.</p>
            <div3 diff="add" at="A" id="declaring-modes">
               <head>Declaring Modes</head>
               <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
                  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="mode">
                  <e:in-category name="declaration"/>
                  <e:attribute name="name">
                     <e:data-type name="eqname"/>
                  </e:attribute>
                  <e:attribute name="streamable">
                     <e:data-type name="boolean"/>
                  </e:attribute>
                  <e:attribute name="use-accumulators">
                     <e:data-type name="tokens"/>
                  </e:attribute>
                  <e:attribute name="on-no-match">
                     <e:constant value="deep-copy"/>
                     <e:constant value="shallow-copy"/>
                     <e:constant value="deep-skip"/>
                     <e:constant value="shallow-skip"/>
                     <e:constant value="text-only-copy"/>
                     <e:constant value="fail"/>
                  </e:attribute>
                  <e:attribute name="on-multiple-match">
                     <e:constant value="use-last"/>
                     <e:constant value="fail"/>
                  </e:attribute>
                  <e:attribute name="warning-on-no-match">
                     <e:data-type name="boolean"/>
                  </e:attribute>
                  <e:attribute name="warning-on-multiple-match">
                     <e:data-type name="boolean"/>
                  </e:attribute>
                  <e:attribute name="typed">
                     <e:data-type name="boolean"/>
                     <e:constant value="strict"/>
                     <e:constant value="lax"/>
                     <e:constant value="unspecified"/>
                  </e:attribute>
                  <e:attribute name="visibility">
                     <e:constant value="public"/>
                     <e:constant value="private"/>
                     <e:constant value="final"/>
                  </e:attribute>
                  <e:empty/>
                  <e:allowed-parents>
                     <e:parent name="package"/>
                     <e:parent name="stylesheet"/>
                     <e:parent name="transform"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p>
                  <termdef id="dt-unnamed-mode" term="unnamed mode"><phrase diff="del"
                        at="R-bug26438">There is always an <term>unnamed mode</term> available.
                     </phrase>The <term>unnamed mode</term> is the default mode used when no
                        <code>mode</code> attribute is specified on an
                        <elcode>xsl:apply-templates</elcode> instruction or
                        <elcode>xsl:template</elcode> declaration, unless a different default mode
                     has been specified using the <phrase diff="chg" at="P"
                           ><code>[xsl:]default-mode</code> attribute of a containing
                        element</phrase>.</termdef>
               </p>
               <p>Every <termref def="dt-mode">mode</termref> other than the <termref
                     def="dt-unnamed-mode">unnamed mode</termref> is identified by an <termref
                     def="dt-expanded-qname">expanded QName</termref>.</p>
               <p>A <termref def="dt-stylesheet">stylesheet</termref> may contain multiple
                     <elcode>xsl:mode</elcode> declarations and may include or import <termref
                     def="dt-stylesheet-module">stylesheet modules</termref> that also contain
                     <elcode>xsl:mode</elcode> declarations. The name of an
                     <elcode>xsl:mode</elcode> declaration is the value of its <code>name</code>
                  attribute, if any.</p>
               <p>
                  <termdef id="dt-mode-definition" term="mode definition">All the
                        <elcode>xsl:mode</elcode> declarations in a <phrase diff="chg"
                        at="R-bug24307"><termref def="dt-package"/></phrase> that share the same
                     name are grouped into a named <term>mode definition</term>; those that have no
                     name are grouped into a single unnamed mode definition.</termdef>
               </p>
               <p><phrase diff="add" at="R-bug26438">The <code>declared-modes</code> attribute of
                     the <elcode>xsl:package</elcode> element determines whether implicit mode
                     declarations are allowed, as described in <specref
                        ref="requiring-explicit-modes"/>. If the package allows implicit mode
                     declarations, then </phrase> if a <termref def="dt-stylesheet"
                     >stylesheet</termref> does not contain a declaration of the unnamed mode, a
                  declaration is implied equivalent to an <elcode>xsl:mode</elcode> element with
                     <phrase diff="chg" at="R-bug24545">no attributes</phrase>. Similarly, if there
                  is a mode that is named in an <elcode>xsl:template</elcode> or
                     <elcode>xsl:apply-templates</elcode> element, or in the <phrase diff="chg"
                     at="P"><code>[xsl:]default-mode</code> attribute of a containing
                     element</phrase>, and the <termref def="dt-stylesheet">stylesheet</termref>
                  does not contain a declaration of that mode, then a declaration is implied
                  comprising an <elcode>xsl:mode</elcode> element with a <code>name</code> attribute
                     <phrase diff="chg" at="R-bug26740">equal to that mode name, plus the attribute
                        <code>visibility="private"</code></phrase>. </p>
               <p diff="del" at="R-bug24764">The contained <elcode>xsl:context-item</elcode>
                  element, if present, is used to declare requirements for the <termref
                     def="dt-global-context-item"/> when this mode is used as the <termref
                     def="dt-initial-mode"/>. Therefore, there must be no
                     <elcode>xsl:context-item</elcode> child if <code>initial="no"</code> is
                  specified.</p>
               <p diff="del" at="R-bug24764">
                  <error spec="XT" type="static" class="SE" code="0542"><p>It is a <termref
                           def="dt-static-error">static error</termref> if an
                           <elcode>xsl:mode</elcode> declaration <phrase diff="chg" at="R-bug24545"
                           >having a <code>name</code> attribute</phrase> and specifying <code
                           diff="chg" at="R-bug24545">visibility="private"</code> contains an
                           <elcode>xsl:context-item</elcode> element.</p></error>
               </p>
               <p>The attributes of the <elcode>xsl:mode</elcode> declaration establish values for a
                  number of properties of a mode. The allowed values and meanings of the attributes
                  are given in the following table.</p>
               <table class="data">
                  <caption>Attributes of the <code>xsl:mode</code> Element</caption>
                  <thead>
                     <tr>
                        <th rowspan="1" colspan="1">Attribute</th>
                        <th rowspan="1" colspan="1">Values</th>
                        <th rowspan="1" colspan="1">Meaning</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">name</td>
                        <td valign="top" rowspan="1" colspan="1">An <termref def="dt-eqname"
                              >EQName</termref></td>
                        <td valign="top" rowspan="1" colspan="1">Specifies the name of the mode. If
                           omitted, this <elcode>xsl:mode</elcode> declaration provides properties
                           of the <termref def="dt-unnamed-mode">unnamed mode</termref></td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">streamable</td>
                        <td valign="top" rowspan="1" colspan="1"><code>yes</code> or <code>no</code>
                           (default <code>no</code>)</td>
                        <td valign="top" rowspan="1" colspan="1">Determines whether template rules
                           in this mode are to be capable of being processed using <termref
                              def="dt-streaming"/>. If the value <code>yes</code> is specified, then
                           the body of any <termref def="dt-template-rule">template rule</termref>
                           that uses this mode <rfc2119>must</rfc2119> conform to the rules for
                           streamable templates given in <specref ref="streamable-templates"/>.</td>
                     </tr>
                     <tr diff="add" at="T-bug29803">
                        <td valign="top" rowspan="1" colspan="1">use-accumulators</td>
                        <td valign="top" rowspan="1" colspan="1">List of accumulator names, or
                              <code>#all</code> (default is an empty list)</td>
                        <td valign="top" rowspan="1" colspan="1">Relevant only when this mode is the
                              <termref def="dt-initial-mode"/> of the transformation, determines
                           which accumulators are applicable to documents containing nodes in the
                              <termref def="dt-initial-match-selection"/>. For further details see
                              <specref ref="applicability-of-accumulators"/>.</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">on-no-match</td>
                        <td valign="top" rowspan="1" colspan="1"><phrase diff="chg" at="I">One of
                                 <code>deep-copy</code>, <code>shallow-copy</code>,
                                 <code>deep-skip</code>, <code>shallow-skip</code>,
                                 <code>text-only-copy</code> or <code>fail</code> (default
                                 <code>text-only-copy</code>)</phrase></td>
                        <td valign="top" rowspan="1" colspan="1">Determines selection of the
                           built-in <termref def="dt-template-rule">template rules</termref> that
                           are used to process <phrase diff="chg" at="S-bug27682">an item</phrase>
                           when an <elcode>xsl:apply-templates</elcode> instruction selects <phrase
                              diff="chg" at="S-bug27682">an item</phrase> that does not match any
                           user-written <termref def="dt-template-rule">template rule</termref> in
                           the <termref def="dt-stylesheet">stylesheet</termref>. For details, see
                              <specref ref="built-in-rule"/>.</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">on-multiple-match</td>
                        <td valign="top" rowspan="1" colspan="1">One of <code>fail</code> or
                              <code>use-last</code> (default <code>use-last</code>)</td>
                        <td valign="top" rowspan="1" colspan="1">Defines the action to be taken when
                              <elcode>xsl:apply-templates</elcode> is used in this mode and more
                           than one user-written <termref def="dt-template-rule">template
                              rule</termref> is available to process <phrase diff="chg"
                              at="S-bug27682">an item</phrase>, each having the same <termref
                              def="dt-import-precedence">import precedence</termref> and <termref
                              def="dt-priority">priority</termref>. The value <code>fail</code>
                           indicates that it is a <termref def="dt-dynamic-error"><phrase diff="del"
                                 at="M">non-recoverable</phrase> dynamic error</termref> if more
                           than one template rule matches <phrase diff="chg" at="S-bug27682">an
                              item</phrase>. The value <code>use-last</code> indicates that the
                           situation is not to be treated as an error (the last template in <termref
                              def="dt-declaration-order">declaration order</termref> is the one that
                           is used). </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">warning-on-no-match</td>
                        <td valign="top" rowspan="1" colspan="1">One of <code>yes</code> or
                              <code>no</code>. The default is <termref
                              def="dt-implementation-defined"/>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">Requests the <termref
                              def="dt-processor">processor</termref> to output (or not to output) a
                           warning message in the case where an <elcode>xsl:apply-templates</elcode>
                           instruction selects <phrase diff="chg" at="S-bug27682">an item</phrase>
                           that matches no user-written template rule. The form and destination of
                           such warnings is <termref def="dt-implementation-defined"
                              >implementation-defined</termref>. The processor
                              <rfc2119>may</rfc2119> ignore this attribute, for example if the
                           environment provides no suitable means of communicating with the user.
                        </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">warning-on-multiple-match</td>
                        <td valign="top" rowspan="1" colspan="1">One of <code>yes</code> or
                              <code>no</code>. The default is <termref
                              def="dt-implementation-defined"/>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">Requests the <termref
                              def="dt-processor">processor</termref> to output a warning message in
                           the case where an <elcode>xsl:apply-templates</elcode> instruction
                           selects <phrase diff="chg" at="S-bug27682">an item</phrase> that matches
                           multiple template rules having the same <termref
                              def="dt-import-precedence">import precedence</termref> and <termref
                              def="dt-priority">priority</termref>. The form and destination of such
                           warnings is <termref def="dt-implementation-defined"
                              >implementation-defined</termref>. The processor
                              <rfc2119>may</rfc2119> ignore this attribute, for example if the
                           environment provides no suitable means of communicating with the
                           user.</td>
                     </tr>
                     <tr diff="add" at="G">
                        <td valign="top" rowspan="1" colspan="1">typed</td>
                        <td valign="top" rowspan="1" colspan="1">One of <code>yes</code>,
                              <code>no</code>, <code>strict</code>, <code>lax</code>, or
                              <code>unspecified</code>. The default is
                           <code>unspecified</code>.</td>
                        <td valign="top" rowspan="1" colspan="1"><phrase diff="chg" at="25517">See
                                 <specref ref="xsl-mode-typed"/>.</phrase></td>
                     </tr>
                     <tr diff="add" at="P">
                        <td valign="top" rowspan="1" colspan="1">visibility</td>
                        <td valign="top" rowspan="1" colspan="1">One of <code>public</code>,
                              <code>private</code>, or <code>final</code>. The default is
                              <code>private</code>.</td>
                        <td valign="top" rowspan="1" colspan="1">See <specref ref="visibility"/>.
                              <phrase diff="add" at="R-bug24307">If the mode is unnamed, that is, if
                              the <code>name</code> attribute is absent, then the
                                 <code>visibility</code> attribute if present
                                 <rfc2119>must</rfc2119> have the value
                              <code>private</code></phrase>. <phrase diff="add" at="P-bug23325">A
                                 <phrase diff="add" at="P-bug24545">named</phrase> mode is not
                              eligible to be used as the <termref def="dt-initial-mode"/> if its
                              visibility is <code>private</code>.</phrase></td>
                     </tr>
                  </tbody>
               </table>
               <imp-def-feature id="idf-err-warningonmatch">The default values for the
                     <code>warning-on-no-match</code> and <code>warning-on-multiple-match</code>
                  attributes of <elcode>xsl:mode</elcode> are <termref
                     def="dt-implementation-defined"/>.</imp-def-feature>
               <imp-def-feature id="idf-err-matchmessages">The form of any warnings output when
                  there is no matching template rule, or when there are multiple matching template
                  rules, is <termref def="dt-implementation-defined"/>.</imp-def-feature>
               <p>
                  <termdef id="dt-streamable-mode" term="streamable mode">A <term>streamable
                        mode</term> is a <termref def="dt-mode">mode</termref> that is declared in
                     an <elcode>xsl:mode</elcode> declaration with the attribute
                        <code>streamable="yes"</code>.</termdef>
               </p>
               <p>For any named <termref def="dt-mode">mode</termref>, the effective value of each
                  attribute is taken from an <elcode>xsl:mode</elcode> declaration that has a
                  matching name in its <code>name</code> attribute, and that specifies an explicit
                  value for the required attribute. <phrase diff="add" at="R-bug24234">If there is
                     no such declaration, the default value of the attribute is used.</phrase> If
                  there is more than one such declaration, the one with highest <termref
                     def="dt-import-precedence">import precedence</termref> is used.</p>
               <p>For the <termref def="dt-unnamed-mode">unnamed mode</termref>, the effective value
                  of each attribute is taken from an <elcode>xsl:mode</elcode> declaration that has
                  no <code>name</code> attribute, and that specifies an explicit value for the
                  required attribute. If there is no such declaration, the default value of the
                  attribute is used. If there is more than one such declaration, the one with
                  highest <termref def="dt-import-precedence">import precedence</termref> is
                  used.</p>
               <p diff="del" at="S-bug27707">The above rules apply both to the attributes (other
                  than <code>name</code>) of the <elcode>xsl:mode</elcode> element itself, and to
                  the attributes of the contained <elcode>xsl:context-item</elcode> element if
                  present.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0545"><p>It is a <termref
                           def="dt-static-error">static error</termref> if for any named or unnamed
                           <termref def="dt-mode">mode</termref>, <phrase diff="add" at="R-bug24234"
                           >a package explicitly specifies</phrase> two conflicting values for the
                        same attribute in different <elcode>xsl:mode</elcode> declarations having
                        the same <termref def="dt-import-precedence">import precedence</termref>,
                        unless there is another definition of the same attribute with higher import
                        precedence. The attributes in question are the attributes other than
                           <code>name</code> on the <elcode>xsl:mode</elcode> element<phrase
                           diff="del" at="R-bug24764">, and the <code>as</code> attribute on the
                           contained <elcode>xsl:context-item</elcode> element if
                        present</phrase>.</p></error>
               </p>
               <p diff="del" at="R-bug24764">If the <termref def="dt-global-context-item"/> supplied
                  to a stylesheet is a <termref def="dt-streamed-document"/> node, then it is not
                  permitted for the values of global variables to be dependent on the context item
                  in a way that requires reading of the input stream. This constraint is enforced by
                  the following static rule:</p>
               <p diff="del" at="R-bug24764"><error spec="XT" type="static" class="DE" code="0548"
                        ><p>It is a <termref def="dt-dynamic-error">dynamic error</termref> if the
                        stylesheet is evaluated with an <termref def="dt-initial-mode"/> that has
                        the effective attribute value <code>streamable="yes"</code>, if there is a
                           <termref def="dt-global-variable"/> in the stylesheet whose initializing
                        expression is not <termref def="dt-motionless"/> with respect to its context
                        item, as defined in <specref ref="streamability"/>.</p></error></p>
            </div3>
            <div3 id="using-modes">
               <head>Using Modes</head>
               <p><termdef id="dt-applicable" term="applicable">A <termref def="dt-template-rule"
                        >template rule</termref> is <term>applicable</term> to one or more modes.
                     The modes to which it is applicable are defined by the <code>mode</code>
                     attribute of the <elcode>xsl:template</elcode> element. If the attribute is
                     omitted, then the template rule is applicable to the <phrase diff="chg" at="A"
                        >default mode specified in the <phrase diff="chg" at="P"
                              ><code>[xsl:]default-mode</code> attribute of the innermost containing
                           element that has such an attribute</phrase>, which in turn defaults to
                        the <termref def="dt-unnamed-mode">unnamed mode</termref>.</phrase> If the
                        <code>mode</code> attribute is present, then its value
                        <rfc2119>must</rfc2119> be a non-empty whitespace-separated list of tokens,
                     each of which defines a mode to which the template rule is
                     applicable.</termdef></p>
               <p>Each token in the <code>mode</code> attribute <rfc2119>must</rfc2119> be one of
                  the following:</p>
               <ulist>
                  <item>
                     <p>an <phrase diff="chg" at="K"><termref def="dt-eqname"
                           >EQName</termref></phrase>, which is expanded as described in <specref
                           ref="qname"/> to define the name of the mode</p>
                  </item>
                  <item>
                     <p>the token <code>#default</code>, to indicate that the template rule is
                        applicable to the <phrase diff="chg" at="P">default mode that would apply if
                           the <code>mode</code> attribute were absent</phrase>
                     </p>
                  </item>
                  <item>
                     <p diff="add" at="A">the token <code>#unnamed</code>, to indicate that the
                        template rule is applicable to the <termref def="dt-unnamed-mode">unnamed
                           mode</termref>
                     </p>
                  </item>
                  <item>
                     <p>the token <code>#all</code>, to indicate that the template rule is
                        applicable to all modes (specifically, to the <phrase diff="chg" at="D"
                           >unnamed</phrase> mode and to every mode that is named <phrase diff="add"
                           at="D">explicitly or implicitly</phrase> in an
                           <elcode>xsl:apply-templates</elcode> instruction <phrase diff="del"
                           at="D">or <elcode>xsl:template</elcode> declaration</phrase> anywhere in
                        the stylesheet).</p>
                  </item>
               </ulist>
               <p diff="add" at="R-bug24308">When a template rule specifies <code diff="chg" at="M"
                     >mode="#all"</code> this is interpreted as meaning all modes declared
                  implicitly or explicitly within the <termref def="dt-declaring-package">declaring
                     package</termref> of the <elcode>xsl:template</elcode> element. This value
                  cannot be used in the case of a template rule declared within an
                     <elcode>xsl:override</elcode> element.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0550"><p>It is a <termref
                           def="dt-static-error">static error</termref> if the list of modes
                           <error.extra>in the <code>mode</code> attribute of
                              <elcode>xsl:template</elcode>
                        </error.extra> is empty, if the same token is included more than once in the
                        list, if the list contains an invalid token, or if the token
                           <code>#all</code> appears together with any other value.</p></error>
               </p>
               <p diff="add" at="R-bug24308">
                  <error spec="XT" type="static" class="SE" code="3440"><p>In the case of a <termref
                           def="dt-template-rule"/> (that is, an <elcode>xsl:template</elcode>
                        element having a <code>match</code> attribute) appearing as a child of
                           <elcode>xsl:override</elcode>, it is a <termref def="dt-static-error"
                           >static error</termref> if the list of modes in the <code>mode</code>
                        attribute contains <code>#all</code> or <code>#unnamed</code>, or if it
                        contains <code>#default</code> and the default mode is the <termref
                           def="dt-unnamed-mode"/>, or if the <code>mode</code> attribute is omitted
                        when the default mode is the <termref def="dt-unnamed-mode"/>.</p></error>
               </p>
               <p>The <elcode>xsl:apply-templates</elcode> element also has an optional
                     <code>mode</code> attribute. The value of this attribute
                     <rfc2119>must</rfc2119> be one of the following:</p>
               <ulist>
                  <item>
                     <p>an <phrase diff="chg" at="K"><termref def="dt-eqname"
                           >EQName</termref></phrase>, which is expanded as described in <specref
                           ref="qname"/> to define the name of a mode</p>
                  </item>
                  <item>
                     <p>the token <code>#default</code>, to indicate that the default mode <phrase
                           diff="add" at="A">for the <termref def="dt-stylesheet-module">stylesheet
                              module</termref>
                        </phrase> is to be used</p>
                  </item>
                  <item>
                     <p diff="add" at="A">the token <code>#unnamed</code>, to indicate that the
                           <termref def="dt-unnamed-mode">unnamed mode</termref> is to be used</p>
                  </item>
                  <item>
                     <p>the token <code>#current</code>, to indicate that the <termref
                           def="dt-current-mode">current mode</termref> is to be used</p>
                  </item>
               </ulist>
               <p>If the attribute is omitted, the default mode <phrase diff="add" at="A">for the
                        <termref def="dt-stylesheet-module">stylesheet module</termref>
                  </phrase> is used.</p>
               <p>When searching for a template rule to process each <phrase diff="chg" at="C"
                     >item</phrase> selected by the <elcode>xsl:apply-templates</elcode>
                  instruction, only those template rules that are applicable to the selected mode
                  are considered.</p>
               <p>
                  <termdef id="dt-current-mode" term="current mode">At any point in the processing
                     of a stylesheet, there is a <term>current mode</term>. When the transformation
                     is initiated, the current mode is the <phrase diff="chg" at="E"><termref
                           def="dt-initial-mode"/></phrase>, as described in <specref
                        ref="initiating"/>. Whenever an <elcode>xsl:apply-templates</elcode>
                     instruction is evaluated, the current mode becomes the mode selected by this
                     instruction.</termdef> When a <phrase diff="chg" at="M"><termref
                        def="dt-non-contextual-function-call"/> is made</phrase>, the current mode
                  is set to the <termref def="dt-unnamed-mode">unnamed mode</termref>. While
                  evaluating global variables and parameters, and the sequence constructor contained
                  in <elcode>xsl:key</elcode> or <elcode>xsl:sort</elcode>, the current mode is set
                  to the unnamed mode. No other instruction changes the current mode. The current
                  mode while evaluating an <termref def="dt-attribute-set">attribute set</termref>
                  is the same as the current mode of the caller. On completion of the
                     <elcode>xsl:apply-templates</elcode> instruction, or on return from a
                  stylesheet function call, the current mode reverts to its previous value. The
                  current mode is used when an <elcode>xsl:apply-templates</elcode> instruction uses
                  the syntax <code>mode="#current"</code>; it is also used by the
                     <elcode>xsl:apply-imports</elcode> and <elcode>xsl:next-match</elcode>
                  instructions (see <specref ref="apply-imports"/>).</p>
            </div3>
            <div3 id="xsl-mode-typed" diff="chg" at="R-bug25517">
               <head>Declaring the Type of Nodes Processed by a Mode</head>
               <p>Typically the template rules in a particular <termref def="dt-mode"/> will be
                  designed to process a specific kind of input document. The <code>typed</code>
                  attribute of <elcode>xsl:mode</elcode> gives the stylesheet author the opportunity
                  to provide information about this document to the processor. This information may
                  enable the processor to improve diagnostics or to optimize performance.</p>
               <p>The <code>typed</code> attribute of <elcode>xsl:mode</elcode> informs the
                  processor whether the nodes to be processed by template rules in this mode are to
                  be typed or untyped. </p>
               <ulist>
                  <item>
                     <p>If the value <code>yes</code> is specified (synonyms <code>true</code> or
                           <code>1</code>), then all nodes processed in this mode must be typed. A
                        dynamic error occurs if <elcode>xsl:apply-templates</elcode> in this mode
                        selects an element or attribute node whose <termref def="dt-type-annotation"
                        /> is <code>xs:untyped</code> or <code>xs:untypedAtomic</code>. </p>
                  </item>
                  <item>
                     <p>If the value <code>no</code> is specified (synonyms <code>false</code> or
                           <code>0</code>), then all nodes processed in this mode must be untyped. A
                        dynamic error occurs if <elcode>xsl:apply-templates</elcode> in this mode
                        selects an element or attribute whose <termref def="dt-type-annotation"/> is
                        anything other than <code>xs:untyped</code> or
                        <code>xs:untypedAtomic</code>. </p>
                  </item>
                  <item>
                     <p>The value <code>strict</code> is equivalent to <code>yes</code>, with the
                        additional provision that in the match pattern of any template rule that is
                           <termref def="dt-applicable"/> to this mode, any <code>NameTest</code>
                        used in the <code>ForwardStepP</code> of the first <code>StepExprP</code> of
                        a <code>RelativePathExprP</code> is interpreted as follows:</p>
                     <ulist>
                        <item>
                           <p>If the <code>NameTest</code> is an <code>EQName</code>
                              <var>E</var>, and the principal node kind of the axis of this step is
                                 <code>Element</code>, then:</p>
                           <ulist>
                              <item>
                                 <p>It is a static error if the in-scope schema declarations do not
                                    include a global element declaration for element name
                                       <var>E</var>
                                 </p>
                              </item>
                              <item>
                                 <p>When matching templates in this mode, the element name
                                       <var>E</var> appearing in this step is interpreted as
                                       <code>schema-element(E)</code>. (Informally, this means that
                                    it will only match an element if it has been validated against
                                    this element declaration). </p>
                              </item>
                           </ulist>
                        </item>
                        <item>
                           <p>Otherwise (the <code>NameTest</code> is a wildcard or the principal
                              node kind is <code>Attribute</code> or <code>Namespace</code>), the
                              template matching proceeds as if the <code>typed</code> attribute were
                              absent. </p>
                        </item>
                     </ulist>
                  </item>
                  <item>
                     <p>The value <code>lax</code> is equivalent to <code>yes</code>, with the
                        additional provision that in the match pattern of any template rule that is
                           <termref def="dt-applicable"/> to this mode, any <code>NameTest</code>
                        used in the <code>ForwardStepP</code> of the first <code>StepExprP</code> of
                        a <code>RelativePathExprP</code> is interpreted as follows:</p>
                     <ulist>
                        <item>
                           <p>If the <code>NameTest</code> is an <code>EQName</code>
                              <var>E</var>, and the principal node kind of the axis of this step is
                                 <code>Element</code>, and the in-scope schema declarations include
                              a global element declaration for element name <var>E</var>, then:</p>
                           <ulist>
                              <item>
                                 <p>When matching templates in this mode, the element name
                                       <var>E</var> appearing in this step is interpreted as
                                       <code>schema-element(E)</code>. (Informally, this means that
                                    it will only match an element if it has been validated against
                                    this element declaration). </p>
                              </item>
                           </ulist>
                        </item>
                        <item>
                           <p>Otherwise (the <code>NameTest</code> is a wildcard, or the principal
                              node kind is <code>Attribute</code> or <code>Namespace</code>, or
                              there is no element declaration for <var>E</var>), the template
                              matching proceeds as if the <code>typed</code> attribute were absent.
                           </p>
                        </item>
                     </ulist>
                  </item>
               </ulist>
               <p>
                  <error spec="XT" type="type" class="TE" code="3100"><p>It is a <termref
                           def="dt-type-error">type error</termref> if an
                           <elcode>xsl:apply-templates</elcode> instruction in a particular
                           <code>mode</code> selects an element or attribute whose type is
                           <code>xs:untyped</code> or <code>xs:untypedAtomic</code> when the
                           <code>typed</code> attribute of that mode specifies the value
                           <code>yes</code>, <code>strict</code>, or <code>lax</code>.</p></error>
               </p>
               <p>
                  <error spec="XT" type="static" class="SE" code="3105"><p>It is a <termref
                           def="dt-static-error">static error</termref> if a template rule
                        applicable to a mode that is defined with <code>typed="strict"</code> uses a
                        match pattern that contains a <code>RelativePathExprP</code> whose first
                           <code>StepExprP</code> is an <code>AxisStepP</code> whose
                           <code>ForwardStepP</code> uses an axis whose principal node kind is
                           <code>Element</code> and whose <code>NodeTest</code> is an
                           <code>EQName</code> that does not correspond to the name of any global
                        element declaration in the <termref def="dt-in-scope-schema-component"
                           >in-scope schema components</termref>.</p></error>
               </p>
               <p>
                  <error spec="XT" type="type" class="TE" code="3110"><p>It is a <termref
                           def="dt-type-error">type error</termref> if an
                           <elcode>xsl:apply-templates</elcode> instruction in a particular
                           <code>mode</code> selects an element or attribute whose type is anything
                        other than <code>xs:untyped</code> or <code>xs:untypedAtomic</code> when the
                           <code>typed</code> attribute of that mode specifies the value
                           <code>no</code>.</p></error>
               </p>
            </div3>
            <div3 id="streamable-templates">
               <head>Streamable Templates</head>
               <p>A <phrase diff="chg" at="R-bug24649">template rule that is <termref
                        def="dt-applicable"/> to a mode <var>M</var></phrase> is <termref
                     def="dt-guaranteed-streamable"/> if and only if all the following conditions
                  are satisfied:</p>
               <olist>
                  <item diff="add" at="R-bug24649">
                     <p>Mode <var>M</var> is declared in an <elcode>xsl:mode</elcode> declaration
                        that specifies <code>streamable="yes"</code>.</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-pattern">pattern</termref> defined in the
                           <code>match</code> attribute of the <elcode>xsl:template</elcode> element
                           <phrase diff="chg" at="P">is</phrase> a <termref def="dt-motionless"/>
                        pattern as defined in <specref ref="classifying-patterns"/>.</p>
                  </item>
                  <item diff="add" at="S-bug28154">
                     <p>The <termref def="dt-sweep"/> of the <termref def="dt-sequence-constructor"
                        /> forming the body of the <elcode>xsl:template</elcode> element is either
                           <termref def="dt-motionless"/> or <termref def="dt-consuming"/>.</p>
                  </item>
                  <item diff="add" at="S-bug28154">
                     <p>The <termref def="dt-type-adjusted-posture-and-sweep">type-adjusted
                           posture</termref> of the <termref def="dt-sequence-constructor"/> forming
                        the body of the <elcode>xsl:template</elcode> element, with respect to the
                           <termref def="dt-utype"/> that corresponds to the declared return type of
                        the template (defaulting to <code>item()*</code>), is <termref
                           def="dt-grounded"/>.</p>
                     <note>
                        <p>This means that either (a) the sequence constructor is grounded as
                           written (that is, it does not return streamed nodes), or (b) it
                           effectively becomes grounded because the declared result type of the
                           template is atomic, leading to implicit atomization of the result.</p>
                     </note>
                  </item>
                  <item>
                     <p>Every <termref def="dt-expression">expression</termref> and contained
                           <termref def="dt-sequence-constructor"/> in a contained
                           <elcode>xsl:param</elcode> element (the construct that provides the
                        default value of the parameter) <phrase diff="chg" at="P">is</phrase>
                        <termref def="dt-motionless"/>.</p>
                  </item>
               </olist>
               <p diff="add" at="P">Specifying <code>streamable="yes"</code> on an
                     <elcode>xsl:mode</elcode> declaration declares an intent that every template
                  rule that includes that mode (explicitly or implicitly, including by specifying
                     <code>#all</code>), should be <phrase diff="chg" at="S-bug27273">streamable,
                     either because it is <termref def="dt-guaranteed-streamable"/>, or because it
                     takes advantage of streamability extensions offered by a particular
                     processor</phrase>. The consequences of declaring the mode to be streamable
                  when there is such a template rule that is not guaranteed streamable depend on the
                  conformance level of the processor, and are explained in <specref
                     ref="streamability-guarantees"/>.</p>
               <p diff="add" at="Q">Processing of a document using streamable templates may be
                  initiated using code such as the following, where <code>S</code> is a mode
                  declared with <code>streamable="yes"</code>:</p>
               <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:source-document streamable="yes" href="bigdoc.xml"&gt;
  &lt;xsl:apply-templates mode="S"/&gt;
&lt;/xsl:source-document&gt;</eg>
               <p diff="add" at="Q">Alternatively, streamed processing may be initiated by invoking
                  the transformation with an <termref def="dt-initial-mode"/> declared as
                  streamable, while supplying the <phrase diff="chg" at="R-bug24764"><termref
                        def="dt-initial-match-selection"/></phrase> (in an <termref
                     def="dt-implementation-defined"/> way) as a streamed document.</p>
               <imp-def-feature id="idf-api-streaming">Streamed processing may be initiated by
                  invoking the transformation with an <termref def="dt-initial-mode"/> declared as
                  streamable, while supplying the <phrase diff="chg" at="R-bug24764"><termref
                        def="dt-initial-match-selection"/></phrase> (in an <termref
                     def="dt-implementation-defined"/> way) as a streamed
                  document.</imp-def-feature>
               <note diff="add" at="Q">
                  <p>Invoking a streamable template using the construct
                        <code>&lt;xsl:apply-templates select="doc('bigdoc.xml')"/&gt;</code> does
                     not ensure streamed processing. As always, processors may use streamed
                     processing if they are able to do so, but when the <xfunction>doc</xfunction>
                     or <function>document</function> functions are used, processors are obliged to
                     ensure that the results are deterministic, which may be difficult to reconcile
                     with streaming (if the same document is read twice, the results must be
                     identical). The use of <elcode>xsl:source-document</elcode>
                     <phrase diff="add" at="T-bug29747">with <code>streamable="yes"</code></phrase>
                     does not offer the same guarantees of determinism.</p>
               </note>
               <p>For an example of processing a collection of documents by use of the function
                     <xfunction>uri-collection</xfunction> in conjunction with
                     <elcode>xsl:source-document</elcode>, see <specref ref="stream-examples"/>.</p>
            </div3>
         </div2>
         <div2 id="built-in-rule">
            <head>Built-in Template Rules</head>
            <p diff="chg" at="C">When an <phrase diff="chg" at="P-bug22379">item</phrase> is
               selected by <elcode>xsl:apply-templates</elcode> and there is no user-specified
                  <termref def="dt-template-rule">template rule</termref> in the <termref
                  def="dt-stylesheet">stylesheet</termref> that can be used to process that <phrase
                  diff="chg" at="P-bug22379">item</phrase>, then a built-in template rule is
               evaluated instead. </p>
            <p>The built-in <termref def="dt-template-rule">template rules</termref> have lower
                  <termref def="dt-import-precedence">import precedence</termref> than all other
               template rules. Thus, the stylesheet author can override a built-in template rule by
               including an explicit template rule.</p>
            <p diff="chg" at="I">There are six sets of built-in template rules available. The set
               that is chosen is a property of the <termref def="dt-mode">mode</termref> selected by
               the <elcode>xsl:apply-templates</elcode> instruction. This property is set using the
                  <code>on-no-match</code> attribute of the <elcode>xsl:mode</elcode> declaration,
               which takes one of the six values <code>deep-copy</code>, <code>shallow-copy</code>,
                  <code>deep-skip</code>, <code>shallow-skip</code>, <code>text-only-copy</code>, or
                  <code>fail</code>, the default being <code>text-only-copy</code>. The effect of
               these six sets of built-in template rules is explained in the following
               subsections.</p>
            <div3 id="built-in-templates-text-only-copy">
               <head>Built-in Templates: Text-only Copy</head>
               <p diff="chg" at="I">The effect of <phrase diff="chg" at="P-bug22379">processing a
                     tree using a <termref def="dt-mode">mode</termref> that specifies
                        <code>on-no-match="text-only-copy"</code></phrase> is that the textual
                  content of the source document is retained while losing the markup, except where
                  explicit template rules dictate otherwise. When an element is encountered for
                  which there is no explicit <termref def="dt-template-rule">template
                  rule</termref>, the processing continues with the children of that element. Text
                  nodes are copied to the output.</p>
               <p>The built-in rule for document nodes and element nodes is equivalent to calling
                     <elcode>xsl:apply-templates</elcode> with no <code>select</code> attribute, and
                  with the <code>mode</code> attribute set to <code>#current</code>. If the built-in
                  rule was invoked with parameters, those parameters are passed on in the implicit
                     <elcode>xsl:apply-templates</elcode> instruction.</p>
               <p diff="add" at="R-bug24554">This is equivalent to the following in the case where
                  there are no parameters:</p>
               <eg diff="add" at="R-bug24554" role="xslt-declaration" xml:space="preserve">&lt;xsl:template match="document-node()|element()" mode="M"&gt;
  &lt;xsl:apply-templates mode="#current"/&gt;
&lt;/xsl:template&gt;</eg>
               <p diff="chg" at="R-bug26751">The built-in <termref def="dt-template-rule">template
                     rule</termref> for text and attribute nodes returns a text node containing the
                     <termref def="dt-string-value">string value</termref> of the context node. It
                  is effectively:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="text()|@*" mode="M"&gt;
  &lt;xsl:value-of select="string(.)"/&gt;
&lt;/xsl:template&gt;</eg>
               <note>
                  <p>This text node may have a string value that is zero-length.</p>
               </note>
               <p diff="chg" at="R-bug26751">The built-in <termref def="dt-template-rule">template
                     rule</termref> for <phrase diff="add" at="C">atomic values</phrase> returns a
                  text node containing the value. It is effectively:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match=".[. instance of xs:anyAtomicType]" mode="M"&gt;
  &lt;xsl:value-of select="string(.)"/&gt;
&lt;/xsl:template&gt;</eg>
               <note>
                  <p>This text node may have a string value that is zero-length.</p>
               </note>
               <p diff="chg" at="C">The built-in <termref def="dt-template-rule">template
                     rule</termref> for processing instructions, comments, and namespace nodes does
                  nothing (it returns the empty sequence).</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template 
   match="processing-instruction()|comment()|namespace-node()" 
   mode="M"/&gt;</eg>
               <p diff="chg" at="C">The built-in <termref def="dt-template-rule">template
                     rule</termref> for functions <phrase diff="add" at="R-bug24553">(including
                     maps)</phrase> does nothing (it returns the empty sequence).</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template 
   match=".[. instance of function(*)]" 
   mode="M"/&gt;</eg>
               <p diff="del" at="C">The built-in <termref def="dt-template-rule">template
                     rule</termref> for namespace nodes is also to do nothing. There is no pattern
                  that can match a namespace node, so the built-in template rule is always used when
                     <elcode>xsl:apply-templates</elcode> selects a namespace node.</p>
               <p diff="add" at="S-bug29079">The built-in <termref def="dt-template-rule"/> for
                  arrays (see <specref ref="arrays"/>) is to apply templates to the members of the
                  array. It is equivalent to invoking <elcode>xsl:apply-templates</elcode> with the
                     <code>select</code> attribute set to <code>?*</code> (which selects the members
                  of the array), and with the <code>mode</code> attribute set to
                     <code>#current</code>. If the built-in rule was invoked with parameters, those
                  parameters are passed on in the implicit <elcode>xsl:apply-templates</elcode>
                  instruction.</p>
               <p diff="add" at="R-bug29079">This is equivalent to the following in the case where
                  there are no parameters:</p>
               <eg diff="add" at="R-bug29079" role="xslt-declaration" xml:space="preserve">&lt;xsl:template match=".[. instance of array(*)]" mode="M"&gt;
  &lt;xsl:apply-templates mode="#current" select="?*"/&gt;
&lt;/xsl:template&gt;</eg>
               <p>The following example illustrates the use of built-in template rules when there
                  are parameters.</p>
               <example>
                  <head>Using a Built-In Template Rule</head>
                  <p>Suppose the stylesheet contains the following instruction:</p>
                  <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:apply-templates select="title" mode="M"&gt;
  &lt;xsl:with-param name="init" select="10"/&gt;
&lt;/xsl:apply-templates&gt;</eg>
                  <p>If there is no explicit template rule that matches the <code>title</code>
                     element, then the following implicit rule is used:</p>
                  <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="title" mode="M"&gt;
  &lt;xsl:param name="init"/&gt;
  &lt;xsl:apply-templates mode="#current"&gt;
    &lt;xsl:with-param name="init" select="$init"/&gt;
  &lt;/xsl:apply-templates&gt;
&lt;/xsl:template&gt;</eg>
               </example>
            </div3>
            <div3 id="built-in-templates-deep-copy" diff="add" at="I">
               <head>Built-in Templates: Deep Copy</head>
               <p>The effect of <phrase diff="chg" at="P-bug22379">processing a tree using a
                        <termref def="dt-mode">mode</termref> that specifies
                        <code>on-no-match="deep-copy"</code></phrase> is that an unmatched element
                  in the source tree is copied unchanged to the output, together with its entire
                  subtree. Other unmatched items are also copied unchanged. The subtree is copied
                  unconditionally, without attempting to match nodes in the subtree against template
                  rules.</p>
               <p>When this default action is selected for a mode <var>M</var>, all items <phrase
                     diff="add" at="P-bug22379">(nodes, atomic values, and functions,</phrase>
                  <phrase diff="add" at="R-bug24553">including maps</phrase>
                  <phrase diff="add" at="S-bug29079">and arrays</phrase>) are processed using a
                  template rule that is equivalent to the following:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="." mode="M"&gt;
  &lt;xsl:copy-of select="." validation="preserve"/&gt;
&lt;/xsl:template&gt;</eg>
            </div3>
            <div3 id="built-in-templates-shallow-copy" diff="chg" at="I">
               <head>Built-in Templates: Shallow Copy</head>
               <p>The effect of <phrase diff="chg" at="P-bug22379">processing a tree using a
                        <termref def="dt-mode">mode</termref> that specifies
                        <code>on-no-match="shallow-copy"</code></phrase> is that the source tree is
                  copied unchanged to the output, except for nodes where different processing is
                  specified using an explicit <termref def="dt-template-rule">template
                     rule</termref>.</p>
               <p>When this default action is selected for a mode <var>M</var>, all items <phrase
                     diff="add" at="P-bug22379">(nodes, atomic values, and functions, <phrase
                        diff="add" at="R-bug24553">including maps</phrase>
                     <phrase diff="add" at="S-bug29079">and arrays</phrase>)</phrase> are processed
                  using a template rule that is equivalent to the following, except that all
                  parameters supplied in <elcode>xsl:with-param</elcode> elements are passed on
                  implicitly to the called templates:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="." mode="M"&gt;
  &lt;xsl:copy validation="preserve"&gt;
    &lt;xsl:apply-templates select="@*" mode="M"/&gt;
    &lt;xsl:apply-templates select="node()" mode="M"/&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;</eg>
               <p>This rule is often referred to as the <emph>identity template</emph>, though it
                  should be noted that it does not preserve node identity.</p>
               <note>
                  <p>This rule differs from the traditional identity template rule by using two
                        <elcode>xsl:apply-templates</elcode> instructions, one to process the
                     attributes and one to process the children. The only observable difference from
                     the traditional <code>select="node() | @*"</code> is that with two separate
                     instructions, the value of <code>position()</code> in the called templates
                     forms one sequence starting at 1 for the attributes, and a new sequence
                     starting at 1 for the children.</p>
                  <p diff="del" at="S-bug29147">A further reason for choosing this form is for
                     streamability: this formulation is <termref def="dt-guaranteed-streamable"/>,
                     whereas the traditional form using <code>select="node() | @*"</code> is not
                     (see <specref ref="streamability-xsl-apply-templates"/>).</p>
               </note>
               <example>
                  <head>Modified Identity Transformation</head>
                  <p>The following stylesheet transforms an input document by deleting all elements
                     named <code>note</code>, together with their attributes and descendants:</p>
                  <eg xml:space="preserve" role="xslt-document">&lt;xsl:stylesheet version="3.0"
     xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
				  
&lt;xsl:mode on-no-match="shallow-copy" streamable="true"/&gt;

&lt;xsl:template match="note"&gt;
  &lt;!-- no action --&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg>
               </example>
            </div3>
            <div3 id="built-in-templates-deep-skip" diff="chg" at="O">
               <head>Built-in Templates: Deep Skip</head>
               <p diff="chg" at="P-bug22379">The effect of processing a tree using a <termref
                     def="dt-mode">mode</termref> that specifies
                     <code>on-no-match="deep-skip"</code> is that where no explicit template rule is
                  specified for an element, that element and all its descendants are ignored, and
                  are not copied to the result tree.</p>
               <p>The effect of choosing <code>on-no-match="deep-skip"</code> is as follows:</p>
               <ulist>
                  <item>
                     <p>The built-in rule for document nodes is equivalent to calling
                           <elcode>xsl:apply-templates</elcode> with no <code>select</code>
                        attribute, and with the <code>mode</code> attribute set to
                           <code>#current</code>. If the built-in rule was invoked with parameters,
                        those parameters are passed on in the implicit
                           <elcode>xsl:apply-templates</elcode> instruction.</p>
                     <p diff="add" at="R-bug24554">In the case where there are no parameters, this
                        is equivalent to the following rule:</p>
                     <eg diff="add" at="R-bug24554" xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="document-node()" mode="M"&gt;
  &lt;xsl:apply-templates mode="#current"/&gt;
&lt;/xsl:template&gt;</eg>
                  </item>
                  <item>
                     <p>The built-in rule for all items other than document nodes <phrase diff="add"
                           at="P-bug22379">(that is, for all other kinds of node, as well as atomic
                           values and functions, <phrase diff="add" at="R-bug24553">including
                              maps</phrase> and <phrase diff="add" at="S-bug29079"> and
                              arrays</phrase>)</phrase> is to do nothing, that is, to return an
                        empty sequence (without applying templates to any children or
                        ancestors).</p>
                     <p>This is equivalent to the following rule:</p>
                     <eg diff="add" at="R-bug24554" role="xslt-declaration" xml:space="preserve">&lt;xsl:template match="." mode="M"/&gt;</eg>
                  </item>
               </ulist>
            </div3>
            <div3 id="built-in-templates-shallow-skip" diff="chg" at="I">
               <head>Built-in Templates: Shallow Skip</head>
               <p>The effect of <phrase diff="chg" at="P-bug22379">processing a tree using a
                        <termref def="dt-mode">mode</termref> that specifies
                        <code>on-no-match="shallow-skip"</code></phrase> is to drop both the textual
                  content and the markup from the result document, except where there is an explicit
                  user-written <termref def="dt-template-rule">template rule</termref> that dictates
                  otherwise.</p>
               <p>The built-in rule for document nodes and element nodes <phrase diff="chg"
                     at="S-bug28774"> applies templates (in the current mode) first to the node’s
                     attributes and then to its children.</phrase> If the built-in rule was invoked
                  with parameters, those parameters are passed on in the implicit
                     <elcode>xsl:apply-templates</elcode>
                  <phrase diff="chg" at="S-bug28774">instructions</phrase>.</p>
               <p diff="add" at="R-bug24554">In the case where there are no parameters, this is
                  equivalent to the following rule:</p>
               <eg diff="add" at="S-bug28774" xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="document-node()|element()" mode="M"&gt;
  &lt;xsl:apply-templates select="@*" mode="#current"/&gt;
  &lt;xsl:apply-templates mode="#current"/&gt;
&lt;/xsl:template&gt;</eg>
               <p>The built-in template rule for all other kinds of node, and for atomic values and
                  functions <phrase diff="add" at="R-bug24553">(including maps</phrase>, <phrase
                     diff="add" at="S-bug29079">but not arrays</phrase>) is empty: that is, when the
                  item is matched, the built-in template rule returns an empty sequence.</p>
               <p diff="add" at="R-bug24554">This is equivalent to the following rule:</p>
               <eg diff="add" at="R-bug24554" xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="." mode="M"/&gt;</eg>
               <p diff="add" at="S-bug29079">The built-in <termref def="dt-template-rule"/> for
                  arrays (see <specref ref="arrays"/>) is to apply templates to the members of the
                  array. It is equivalent to invoking <elcode>xsl:apply-templates</elcode> with the
                     <code>select</code> attribute set to <code>?*</code> (which selects the members
                  of the array), and with the <code>mode</code> attribute set to
                     <code>#current</code>. If the built-in rule was invoked with parameters, those
                  parameters are passed on in the implicit <elcode>xsl:apply-templates</elcode>
                  instruction.</p>
               <p diff="add" at="R-bug29079">This is equivalent to the following in the case where
                  there are no parameters:</p>
               <eg diff="add" at="R-bug29079" role="xslt-declaration" xml:space="preserve">&lt;xsl:template match=".[. instance of array(*)]" mode="M"&gt;
  &lt;xsl:apply-templates mode="#current" select="?*"/&gt;
&lt;/xsl:template&gt;</eg>
            </div3>
            <div3 id="built-in-templates-fail" diff="add" at="E">
               <head>Built-in Templates: Fail</head>
               <p diff="add" at="E">The effect of choosing <code>on-no-match="fail"</code> for a
                     <termref def="dt-mode">mode</termref> is that every <phrase diff="chg" at="O"
                     >item</phrase> selected in an <elcode>xsl:apply-templates</elcode> instruction
                  must be matched by an explicit user-written <termref def="dt-template-rule"
                     >template rule</termref>.</p>
               <p>The built-in template rule is effectively: </p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="." mode="M"&gt;
  &lt;xsl:message terminate="yes" error-code="err:XTDE0555"/&gt;
&lt;/xsl:template&gt;</eg>
               <p>with an <termref def="dt-implementation-dependent"/> message body.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="0555"><p>It is a <termref
                           def="dt-dynamic-error"><phrase diff="del" at="M">non-recoverable</phrase>
                           dynamic error</termref> if <elcode>xsl:apply-templates</elcode>,
                           <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode> is
                        used to process a node using a mode whose declaration specifies
                           <code>on-no-match="fail"</code> when there is no <termref
                           def="dt-template-rule"/> in the <termref def="dt-stylesheet"/> whose
                        match pattern matches that node. </p></error>
               </p>
            </div3>
         </div2>
         <div2 id="apply-imports">
            <head>Overriding Template Rules</head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="apply-imports">
               <e:in-category name="instruction"/>
               <e:element name="with-param" repeat="zero-or-more"/>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="next-match">
               <e:in-category name="instruction"/>
               <e:choice repeat="zero-or-more">
                  <e:element name="with-param"/>
                  <e:element name="fallback"/>
               </e:choice>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>A <termref def="dt-template-rule">template rule</termref> that is being used to
               override another template rule (see <specref ref="conflict"/>) can use the
                  <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode> instruction
               to invoke the overridden template rule. The <elcode>xsl:apply-imports</elcode>
               instruction only considers template rules in imported stylesheet modules; the
                  <elcode>xsl:next-match</elcode> instruction considers all other template rules of
               lower <termref def="dt-import-precedence">import precedence</termref> and/or
               priority, <phrase diff="add" at="P-bug23329">and also declarations of the same
                  precedence and priority that appear earlier in <termref def="dt-declaration-order"
                  /></phrase>. Both instructions will invoke the built-in template rule for the
                  <phrase diff="chg" at="C">context item</phrase> (see <specref ref="built-in-rule"
               />) if no other template rule is found.</p>
            <p>
               <termdef id="dt-current-template-rule" term="current template rule">At any point in
                  the processing of a <termref def="dt-stylesheet">stylesheet</termref>, there may
                  be a <term>current template rule</term>. Whenever a <termref
                     def="dt-template-rule">template rule</termref> is chosen as a result of
                  evaluating <elcode>xsl:apply-templates</elcode>,
                     <elcode>xsl:apply-imports</elcode>, or <elcode>xsl:next-match</elcode>, the
                  template rule becomes the current template rule for the evaluation of the rule’s
                  sequence constructor.</termdef>
            </p>
            <p diff="chg" at="T-bug29716"> The <termref def="dt-current-template-rule"/> is cleared
               (becomes <termref def="dt-absent"/>) by any instruction that evaluates an operand
               with changed focus. It is therefore cleared when evaluating <termref
                  def="dt-instruction">instructions</termref> contained within: </p>
            <ulist>
               <item>
                  <p><elcode>xsl:for-each</elcode></p>
               </item>
               <item>
                  <p><elcode>xsl:for-each-group</elcode></p>
               </item>
               <item>
                  <p><elcode>xsl:analyze-string</elcode></p>
               </item>
               <item>
                  <p><elcode>xsl:iterate</elcode></p>
               </item>
               <item>
                  <p><elcode>xsl:source-document</elcode></p>
               </item>
               <item>
                  <p><elcode>xsl:merge</elcode></p>
               </item>
               <item>
                  <p><elcode>xsl:sort</elcode></p>
               </item>
               <item>
                  <p><elcode>xsl:key</elcode></p>
               </item>
               <item diff="chg" at="T-bug29716">
                  <p><elcode>xsl:copy</elcode> if and only if there is a <code>select</code>
                     attribute</p>
               </item>
               <item>
                  <p>A global <elcode>xsl:variable</elcode> or <elcode>xsl:param</elcode></p>
               </item>
               <item>
                  <p><elcode>xsl:function</elcode></p>
               </item>
               <item diff="chg" at="T-bug29716">
                  <p><elcode>xsl:template</elcode> if and only if the called template specifies
                        <code>&lt;xsl:context-item use="absent"/&gt;</code></p>
               </item>
            </ulist>
            <note>
               <p diff="chg" at="T-bug29716">The current template rule is not affected by invoking
                  named attribute sets (see <specref ref="attribute-sets"/>), or named templates
                  (see <specref ref="named-templates"/>) unless <code>&lt;xsl:context-item
                     use="absent"/&gt;</code> is specified. While evaluating a <termref
                     def="dt-global-variable">global variable</termref> or the default value of a
                     <termref def="dt-stylesheet-parameter">stylesheet parameter</termref> (see
                     <specref ref="global-variables"/>) the current template rule is <phrase
                     diff="chg" at="M"><termref def="dt-absent"/></phrase>.</p>
            </note>
            <p>These rules ensure that when <elcode>xsl:apply-imports</elcode> or
                  <elcode>xsl:next-match</elcode> is called, the <termref def="dt-context-item"
                  >context item</termref> is the same as when the current template rule was
                  invoked<phrase diff="del" at="C">, and is always a node</phrase>.</p>
            <p> Both <elcode>xsl:apply-imports</elcode> and <elcode>xsl:next-match</elcode> search
               for a <termref def="dt-template-rule">template rule</termref> that matches the
                  <phrase diff="chg" at="C"><termref def="dt-context-item">context
                  item</termref></phrase>, and that is applicable to the <termref
                  def="dt-current-mode">current mode</termref> (see <specref ref="modes"/>). In
               choosing a template rule, they use the usual criteria such as the priority and
                  <termref def="dt-import-precedence">import precedence</termref> of the template
               rules, but they consider as candidates only a subset of the template rules in the
                  <termref def="dt-stylesheet">stylesheet</termref>. This subset differs between the
               two instructions:</p>
            <ulist>
               <item>
                  <p>The <elcode>xsl:apply-imports</elcode> instruction considers as candidates only
                     those template rules contained in <termref def="dt-stylesheet-level">stylesheet
                        levels</termref> that are descendants in the <termref def="dt-import-tree"
                        >import tree</termref> of the <termref def="dt-stylesheet-level">stylesheet
                        level</termref> that contains the <termref def="dt-current-template-rule"
                        >current template rule</termref>.</p>
                  <note>
                     <p>This is <emph>not</emph> the same as saying that the search considers all
                        template rules whose import precedence is lower than that of the current
                        template rule.</p>
                  </note>
                  <p diff="add" at="R-bug24308"><error spec="XT" type="static" class="SE"
                        code="3460"><p>It is a <termref def="dt-static-error"/> if an
                              <elcode>xsl:apply-imports</elcode> element appears in a <termref
                              def="dt-template-rule"/> declared within an
                              <elcode>xsl:override</elcode> element. (To invoke the template rule
                           that is being overridden, <elcode>xsl:next-match</elcode> should
                           therefore be used.)</p></error></p>
               </item>
               <item>
                  <p>The <elcode>xsl:next-match</elcode> instruction considers as candidates all
                     those template rules that come after the <termref
                        def="dt-current-template-rule">current template rule</termref> in the
                     ordering of template rules implied by the conflict resolution rules given in
                        <specref ref="conflict"/>. That is, it considers all template rules with
                     lower <termref def="dt-import-precedence">import precedence</termref> than the
                        <termref def="dt-current-template-rule">current template rule</termref>,
                     plus the template rules that are at the same import precedence that have lower
                     priority than the current template rule, <phrase diff="chg" at="D">plus
                        the</phrase> template rules with the same import precedence and priority
                     that occur before the current template rule in <termref
                        def="dt-declaration-order">declaration order</termref>.</p>
                  <note>
                     <p>As explained in <specref ref="conflict"/>, a template rule <phrase
                           diff="add" at="P-bug23329">with no <code>priority</code>
                           attribute</phrase>, whose match pattern contains multiple alternatives
                        separated by <code>|</code>, is treated equivalently to a set of template
                        rules, one for each alternative. This means that where the same <phrase
                           diff="chg" at="C">item</phrase> matches more than one alternative<phrase
                           diff="del" at="P-bug23329">, and the alternatives have different
                           priority</phrase>, it is possible for an <elcode>xsl:next-match</elcode>
                        instruction to cause the current template rule to be invoked recursively.
                        This situation does not occur when the <phrase diff="chg" at="P-bug23329"
                           >template rule has an explicit</phrase> priority.</p>
                  </note>
                  <note diff="add" at="R-bug24308">
                     <p>Because a template rule declared as a child of <elcode>xsl:override</elcode>
                        has higher precedence than any template rule declared in the used package
                        (see <specref ref="modes-and-packages"/>), the effect of
                           <elcode>xsl:next-match</elcode> within such a template rule is to
                        consider as candidates first any other template rules <phrase diff="chg"
                           at="S-bug29210">for the same mode within the same
                              <elcode>xsl:use-package</elcode> element (taking into account explicit
                           and implicit priority, and document order, in the usual way), and then
                           all template rules in the used package.</phrase></p>
                  </note>
               </item>
            </ulist>
            <p diff="add" at="S-bug29210">If a matching template rule <var>R</var> is found, then
               the result of the <elcode>xsl:next-match</elcode> or
                  <elcode>xsl:apply-imports</elcode> instruction is the result of invoking
                  <var>R</var>, with the values of parameters being set using the child
                  <elcode>xsl:with-param</elcode> elements as described in <specref ref="with-param"
               />. The template rule <var>R</var> is evaluated with the same <termref def="dt-focus"
               /> as the <elcode>xsl:next-match</elcode> or <elcode>xsl:apply-imports</elcode>
               instruction. The <termref def="dt-current-template-rule"/> changes to be
               <var>R</var>. The <termref def="dt-current-mode"/> does not change. </p>
            <note>
               <p diff="add" at="S-bug29210">In the case where the current template rule
                     <var>T</var> is declared within an <elcode>xsl:override</elcode> element in a
                  using package <var>P</var>, while the selected rule <var>R</var> is declared
                  within a different package <var>Q</var>, and where the current mode is
                     <var>M/P</var> (mode <var>M</var> in package <var>P</var>), the effect is that
                  the current mode for evaluation of <var>R</var> remains <var>M/P</var> rather than
                  reverting to its corresponding mode <var>M/Q</var> (mode <var>M</var> in package
                     <var>Q</var>). If <var>R</var> contains an <elcode>xsl:apply-templates</elcode>
                  instruction that uses <code>mode="#current"</code>, then the set of template rules
                  considered by this instruction will therefore include any overriding template
                  rules declared in <var>P</var> as well as the original rules declared in
                     <var>Q</var>. </p>
            </note>
            <p>If no matching template rule is found that satisfies these criteria, the built-in
               template rule for the <phrase diff="chg" at="C">context item</phrase> is used (see
                  <specref ref="built-in-rule"/>).</p>
            <p>An <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode> instruction
               may use <elcode>xsl:with-param</elcode> child elements to pass parameters to the
               chosen <termref def="dt-template-rule">template rule</termref> (see <specref
                  ref="with-param"/>). It also passes on any <termref def="dt-tunnel-parameter"
                  >tunnel parameters</termref> as described in <specref ref="tunnel-params"/>.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0560"><p>It is a <termref
                        def="dt-dynamic-error"><phrase diff="del" at="M">non-recoverable</phrase>
                        dynamic error</termref> if <elcode>xsl:apply-imports</elcode> or
                        <elcode>xsl:next-match</elcode> is evaluated when the <termref
                        def="dt-current-template-rule">current template rule</termref> is <phrase
                        diff="chg" at="M"><termref def="dt-absent"/></phrase>.</p></error>
            </p>
            <example>
               <head>Using <elcode>xsl:apply-imports</elcode>
               </head>
               <p>For example, suppose the stylesheet <code>doc.xsl</code> contains a <termref
                     def="dt-template-rule">template rule</termref> for <code>example</code>
                  elements:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="example"&gt;
  &lt;pre&gt;&lt;xsl:apply-templates/&gt;&lt;/pre&gt;
&lt;/xsl:template&gt;</eg>
               <p>Another stylesheet could import <code>doc.xsl</code> and modify the treatment of
                     <code>example</code> elements as follows:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:import href="doc.xsl"/&gt;

&lt;xsl:template match="example"&gt;
  &lt;div style="border: solid red"&gt;
     &lt;xsl:apply-imports/&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;</eg>
               <p>The combined effect would be to transform an <code>example</code> into an element
                  of the form:</p>
               <eg xml:space="preserve" role="xml">&lt;div style="border: solid red"&gt;&lt;pre&gt;...&lt;/pre&gt;&lt;/div&gt;</eg>
            </example>
            <p>An <elcode>xsl:fallback</elcode> instruction appearing as a child of an
                  <elcode>xsl:next-match</elcode> instruction is ignored by an XSLT 2.0 <phrase
                  diff="chg" at="A">or 3.0</phrase> processor, but can be used to define fallback
               behavior when the stylesheet is processed by an XSLT 1.0 processor with forwards
               compatible behavior.</p>
         </div2>
         <div2 id="parameters-to-template-rules" diff="add" at="D">
            <head>Passing Parameters to Template Rules</head>
            <p>A template rule may have parameters. The parameters are declared in the body of the
               template using <elcode>xsl:param</elcode> elements, as described in <specref
                  ref="parameters"/>.</p>
            <p>Values for these parameters may be supplied in the calling
                  <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>, or
                  <elcode>xsl:next-match</elcode> instruction by means of
                  <elcode>xsl:with-param</elcode> elements appearing as children of the calling
               instruction. The <termref def="dt-expanded-qname">expanded QName</termref>
               represented by the <code>name</code> attribute of the <elcode>xsl:with-param</elcode>
               element must match the <termref def="dt-expanded-qname">expanded QName</termref>
               represented by the <code>name</code> attribute of the corresponding
                  <elcode>xsl:param</elcode> element. </p>
            <p>It is not an error for these instructions to supply a parameter that does not match
               any parameter declared in the template rule that is invoked; unneeded parameter
               values are simply ignored.</p>
            <p>A parameter may be declared as a <termref def="dt-tunnel-parameter">tunnel
                  parameter</termref> by specifying <code>tunnel="yes"</code> in the
                  <elcode>xsl:param</elcode> declaration; in this case the caller must supply the
               value as a tunnel parameter by specifying <code>tunnel="yes"</code> in the
               corresponding <elcode>xsl:with-param</elcode> element. Tunnel parameters differ from
               ordinary template parameters in that they are passed transparently through multiple
               template invocations. They are fully described in <specref ref="tunnel-params"/>.</p>
         </div2>
      </div1>
      <div1 id="repetition">
         <head>Repetition</head>
         <p diff="add" at="A">XSLT offers two constructs for processing each item of a sequence:
               <elcode>xsl:for-each</elcode> and <elcode>xsl:iterate</elcode>.</p>
         <p diff="add" at="A">The main difference between the two constructs is that with
               <elcode>xsl:for-each</elcode>, the processing applied to each item in the sequence is
            independent of the processing applied to any other item; this means that the items may
            be processed in any order or in parallel, though the order of the output sequence is
            well defined and corresponds to the order of the input (sorted if so requested). By
            contrast, with <elcode>xsl:iterate</elcode>, the processing is explicitly sequential:
            while one item is being processed, values may be computed which are then available for
            use while the next item is being processed. This makes <elcode>xsl:iterate</elcode>
            suitable for tasks such as creating a running total over a sequence of financial
            transactions.</p>
         <p diff="add" at="A">A further difference is that <elcode>xsl:for-each</elcode> permits
            sorting of the input sequence, while <elcode>xsl:iterate</elcode> does not.</p>
         <div2 id="for-each">
            <head>The <code>xsl:for-each</code> instruction</head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="for-each">
               <e:in-category name="instruction"/>
               <e:attribute name="select" required="yes">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:sequence>
                  <e:element repeat="zero-or-more" name="sort"/>
                  <e:model name="sequence-constructor"/>
               </e:sequence>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:for-each</elcode> instruction processes each item in a sequence of
               items, evaluating the <termref def="dt-sequence-constructor">sequence
                  constructor</termref> within the <elcode>xsl:for-each</elcode> instruction once
               for each item in that sequence.</p>
            <p> The <code>select</code> attribute is <rfc2119>required</rfc2119>; it contains an
                  <termref def="dt-expression">expression</termref> which is evaluated to produce a
               sequence, called the input sequence. If there is an <elcode>xsl:sort</elcode> element
               present (see <specref ref="sorting"/>) the input sequence is sorted to produce a
               sorted sequence. Otherwise, the sorted sequence is the same as the input
               sequence.</p>
            <p>The <elcode>xsl:for-each</elcode> instruction contains a <termref
                  def="dt-sequence-constructor">sequence constructor</termref>. The <termref
                  def="dt-sequence-constructor">sequence constructor</termref> is evaluated once for
               each item in the sorted sequence, with the <termref def="dt-focus">focus</termref>
               set as follows:</p>
            <ulist>
               <item>
                  <p>The <termref def="dt-context-item">context item</termref> is the item being
                     processed. <phrase diff="del" at="D">If this is a node, it will also be the
                           <termref def="dt-context-node">context node</termref>. If it is not a
                        node, there will be no context node: that is, any attempt to reference the
                        context node will result in a <termref def="dt-dynamic-error"><phrase
                              diff="del" at="M">non-recoverable</phrase> dynamic
                        error</termref>.</phrase>
                  </p>
               </item>
               <item>
                  <p>The <termref def="dt-context-position">context position</termref> is the
                     position of this item in the sorted sequence.</p>
               </item>
               <item>
                  <p>The <termref def="dt-context-size">context size</termref> is the size of the
                     sorted sequence (which is the same as the size of the input sequence).</p>
               </item>
            </ulist>
            <p> For each item in the input sequence, evaluating the <termref
                  def="dt-sequence-constructor">sequence constructor</termref> produces a sequence
               of items (see <specref ref="sequence-constructors"/>). These output sequences are
               concatenated; if item <var>Q</var> follows item <var>P</var> in the sorted sequence,
               then the result of evaluating the sequence constructor with <var>Q</var> as the
               context item is concatenated after the result of evaluating the sequence constructor
               with <var>P</var> as the context item. The result of the
                  <elcode>xsl:for-each</elcode> instruction is the concatenated sequence of
               items.</p>
            <example>
               <head>Using <elcode>xsl:for-each</elcode>
               </head>
               <p>For example, given an XML document with this structure</p>
               <eg xml:space="preserve" role="xml">&lt;customers&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
&lt;/customers&gt;</eg>
               <p>the following would create an HTML document containing a table with a row for each
                     <code>customer</code> element</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="/"&gt;
  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;Customers&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;table&gt;
	 &lt;tbody&gt;
	  &lt;xsl:for-each select="customers/customer"&gt;
	    &lt;tr&gt;
	      &lt;th&gt;
           &lt;xsl:apply-templates select="name"/&gt;
	      &lt;/th&gt;
	      &lt;xsl:for-each select="order"&gt;
           &lt;td&gt;
             &lt;xsl:apply-templates/&gt;
           &lt;/td&gt;
	      &lt;/xsl:for-each&gt;
	    &lt;/tr&gt;
	  &lt;/xsl:for-each&gt;
	&lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;</eg>
            </example>
         </div2>
         <div2 id="iterate" diff="add" at="A">
            <head>The <code>xsl:iterate</code> Instruction</head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="iterate">
               <e:in-category name="instruction"/>
               <e:attribute name="select" required="yes">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:sequence>
                  <e:element repeat="zero-or-more" name="param"/>
                  <e:element repeat="zero-or-one" name="on-completion"/>
                  <e:model name="sequence-constructor"/>
               </e:sequence>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="next-iteration">
               <e:in-category name="instruction"/>
               <e:sequence>
                  <e:element repeat="zero-or-more" name="with-param"/>
               </e:sequence>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="break">
               <e:in-category name="instruction"/>
               <e:attribute name="select" required="no">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="on-completion">
               <e:attribute name="select" required="no">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent name="iterate"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <code>select</code> attribute is <rfc2119>required</rfc2119>; it contains an
                  <termref def="dt-expression">expression</termref> which is evaluated to produce a
               sequence, called the input sequence.</p>
            <p>The <termref def="dt-sequence-constructor"/> contained in the
                  <elcode>xsl:iterate</elcode> instruction is evaluated once for each item in the
               input sequence, in order, or until the loop exits by evaluating an
                  <elcode>xsl:break</elcode> instruction, whichever is earlier. Within the <termref
                  def="dt-sequence-constructor">sequence constructor</termref> that forms the body
               of the <elcode>xsl:iterate</elcode> instruction, the <termref def="dt-context-item"
                  >context item</termref> is set to each item from the value of the
                  <code>select</code> expression in turn; the <termref def="dt-context-position"
                  >context position</termref> reflects the position of this item in the input
               sequence, and the <termref def="dt-context-size">context size</termref> is the number
               of items in the input sequence (which may be greater than the number of iterations,
               if the loop exits prematurely using <elcode>xsl:break</elcode>).</p>
            <note>
               <p>If <elcode>xsl:iterate</elcode> is used in conjunction with
                     <elcode>xsl:source-document</elcode> to achieve streaming, calls on the
                  function <xfunction>last</xfunction> will be disallowed. </p>
            </note>
            <p diff="add" at="G">The <elcode>xsl:break</elcode> and
                  <elcode>xsl:on-completion</elcode> elements may have either a <code>select</code>
               attribute or a non-empty contained <termref def="dt-sequence-constructor"/> but not
               both. The effect of the element in both cases is obtained by evaluating the
                  <code>select</code> expression if present or the contained sequence constructor
               otherwise; if neither is present, the value is an empty sequence.</p>
            <note diff="add" at="R-bug24179">
               <p>The <elcode>xsl:on-completion</elcode> element appears before other children of
                     <elcode>xsl:iterate</elcode> to ensure that variables declared in the sequence
                  constructor are not in scope within <elcode>xsl:on-completion</elcode>, since such
                  variables do not have a defined value within <elcode>xsl:on-completion</elcode>
                  especially in the case where the value of the <code>select</code> attribute is an
                  empty sequence.</p>
            </note>
            <p>The effect of <elcode>xsl:next-iteration</elcode> is to cause the iteration to
               continue by processing the next item in the input sequence, potentially with
               different values for the iteration parameters. The effect of
                  <elcode>xsl:break</elcode> is to cause the iteration to finish, whether or not all
               the items in the input sequence have been processed. In both cases the affected
               iteration is the one controlled by the innermost ancestor
                  <elcode>xsl:iterate</elcode> element.</p>
            <p>The instructions <elcode>xsl:next-iteration</elcode> and <elcode>xsl:break</elcode>
               are allowed only as descendants of an <elcode>xsl:iterate</elcode> instruction, and
               only in a <termref def="dt-tail-position">tail position</termref> within the <termref
                  def="dt-sequence-constructor">sequence constructor</termref> forming the body of
               the <elcode>xsl:iterate</elcode> instruction. </p>
            <p>
               <termdef id="dt-tail-position" term="tail position" open="true">An <termref
                     def="dt-instruction">instruction</termref>
                  <var>J</var> is in a <term>tail position</term> within a <termref
                     def="dt-sequence-constructor">sequence constructor</termref>
                  <var>SC</var> if it satisfies one of the following conditions:</termdef></p>
            <ulist>
               <item>
                  <p><var>J</var> is the last instruction in <var>SC</var>, ignoring any
                        <elcode>xsl:fallback</elcode> instructions.</p>
               </item>
               <item>
                  <p><var>J</var> is in a <termref def="dt-tail-position">tail position</termref>
                     within the sequence constructor that forms the body of an
                        <elcode>xsl:if</elcode> instruction that is itself in a <termref
                        def="dt-tail-position">tail position</termref> within <var>SC</var>.</p>
               </item>
               <item>
                  <p><var>J</var> is in a <termref def="dt-tail-position">tail position</termref>
                     within the sequence constructor that forms the body of an
                        <elcode>xsl:when</elcode> or <elcode>xsl:otherwise</elcode> branch of an
                        <elcode>xsl:choose</elcode> instruction that is itself in a <termref
                        def="dt-tail-position">tail position</termref> within <var>SC</var>.</p>
               </item>
               <item>
                  <p><var>J</var> is in a <termref def="dt-tail-position">tail position</termref>
                     within the sequence constructor that forms the body of an
                        <elcode>xsl:try</elcode> instruction that is itself in a <termref
                        def="dt-tail-position">tail position</termref> within <var>SC</var> (that
                     is, it is immediately followed by an <elcode>xsl:catch</elcode> element,
                     ignoring any <elcode>xsl:fallback</elcode> elements).</p>
               </item>
               <item>
                  <p><var>J</var> is in a <termref def="dt-tail-position">tail position</termref>
                     within the sequence constructor that forms the body of an
                        <elcode>xsl:catch</elcode> element within an <elcode>xsl:try</elcode>
                     instruction that is itself in a <termref def="dt-tail-position">tail
                        position</termref> within <var>SC</var>.</p>
               </item>
            </ulist>
            <p role="closetermdef"/>
            <p>
               <error spec="XT" type="static" class="SE" code="3120"><p>It is a <termref
                        def="dt-static-error">static error</termref> if an
                        <elcode>xsl:break</elcode> or <elcode>xsl:next-iteration</elcode> element
                     appears other than in a <termref def="dt-tail-position">tail position</termref>
                     within the <termref def="dt-sequence-constructor">sequence
                        constructor</termref> forming the body of an <elcode>xsl:iterate</elcode>
                     instruction.</p></error>
            </p>
            <p diff="add" at="P">
               <error spec="XT" type="static" class="SE" code="3125"><p>It is a <termref
                        def="dt-static-error">static error</termref> if the <code>select</code>
                     attribute of <elcode>xsl:break</elcode> or <elcode>xsl:on-completion</elcode>
                     is present and the instruction has children.</p></error>
            </p>
            <p>
               <error spec="XT" type="static" class="SE" code="3130"><p>It is a <termref
                        def="dt-static-error">static error</termref> if the <code>name</code>
                     attribute of an <elcode>xsl:with-param</elcode> child of an
                        <elcode>xsl:next-iteration</elcode> element does not match the
                        <code>name</code> attribute of an <elcode>xsl:param</elcode> child of the
                        <phrase diff="add" at="F">innermost</phrase> containing
                        <elcode>xsl:iterate</elcode> instruction.</p></error>
            </p>
            <p>Parameter names in <elcode>xsl:with-param</elcode> must be unique: <errorref
                  spec="XT" class="SE" code="0670"/>.</p>
            <p>The result of the <elcode>xsl:iterate</elcode> instruction is the concatenation of
               the sequences that result from the repeated evaluation of the contained <termref
                  def="dt-sequence-constructor">sequence constructor</termref>, followed by the
               sequence that results from evaluating the <elcode>xsl:break</elcode> or
                  <elcode>xsl:on-completion</elcode> element if any.</p>
            <p>Any <elcode>xsl:param</elcode> element that appears as a child of
                  <elcode>xsl:iterate</elcode> declares a parameter whose value may vary from one
               iteration to the next. The initial value of the parameter is the value obtained
               according to the rules given in <specref ref="variable-values"/>. The dynamic context
               for evaluating the initial value of an <elcode>xsl:param</elcode> element is the same
               as the dynamic context for evaluating the <code>select</code> expression of the
                  <elcode>xsl:iterate</elcode> instruction (the context item is thus
                  <emph>not</emph> the first item in the input sequence).</p>
            <p>On the first iteration a parameter always takes its initial value (which may depend
               on variables or other aspects of the dynamic context). Subsequently:</p>
            <ulist diff="chg" at="F">
               <item>
                  <p>If an <elcode>xsl:next-iteration</elcode> instruction is evaluated, then
                     parameter values for processing the next item in the input sequence can be set
                     in the <elcode>xsl:with-param</elcode> children of that instruction; in the
                     absence of an <elcode>xsl:with-param</elcode> element that names a particular
                     parameter, that parameter will retain its value from the previous
                     iteration.</p>
               </item>
               <item>
                  <p>If an <elcode>xsl:break</elcode> instruction is evaluated, no further items in
                     the input sequence are processed.</p>
               </item>
               <item>
                  <p>If neither an <elcode>xsl:next-iteration</elcode> nor an
                        <elcode>xsl:break</elcode> instruction is evaluated, then the next item in
                     the input sequence is processed using parameter values that are unchanged from
                     the previous iteration.</p>
               </item>
            </ulist>
            <p>The <elcode>xsl:next-iteration</elcode> instruction contributes nothing to the result
               sequence (technically, it returns an empty sequence). The instruction supplies
               parameter values for the next iteration, which are evaluated according to the rules
               given in <specref ref="with-param"/>; if there are no further items in the input
               sequence then it supplies parameter values for use while evaluating the body of the
                  <elcode>xsl:on-completion</elcode> element if any.</p>
            <p>The <elcode>xsl:break</elcode> instruction indicates that the iteration should
               terminate without processing any remaining items from the input sequence. The <phrase
                  diff="add" at="G"><code>select</code> expression or </phrase> contained sequence
               constructor is evaluated using the same context item, position, and size as the
                  <elcode>xsl:break</elcode> instruction itself, and the result is appended to the
               result of the <elcode>xsl:iterate</elcode> instruction as a whole.</p>
            <p>If neither an <elcode>xsl:next-iteration</elcode> nor an <elcode>xsl:break</elcode>
               instruction is evaluated, the next item in the input sequence is processed with
               parameter values unchanged from the previous iteration; if there are no further items
               in the input sequence, the iteration terminates.</p>
            <p>The optional <elcode>xsl:on-completion</elcode> element (which is not technically an
                  <termref def="dt-instruction">instruction</termref> and is not technically part of
               the <termref def="dt-sequence-constructor"/>) is evaluated when the input sequence is
               exhausted. It is not evaluated if the evaluation is terminated using
                  <elcode>xsl:break</elcode>. During evaluation of its <phrase diff="chg"
                  at="R-bug24179"><code>select</code> expression or</phrase> sequence constructor
               the context item, position, and size are <termref def="dt-absent">absent</termref>
               (that is, any reference to these values is an error). However, the values of the
               parameters to <elcode>xsl:iterate</elcode> are available, and take the values
               supplied by the <elcode>xsl:next-iteration</elcode> instruction evaluated while
               processing the last item in the sequence.</p>
            <p diff="add" at="D">If the input sequence is empty, then the result of the
                  <elcode>xsl:iterate</elcode> instruction is the result of evaluating the <phrase
                  diff="add" at="R-bug24179"><code>select</code> attribute or </phrase><termref
                  def="dt-sequence-constructor">sequence constructor</termref> forming the body of
               the <elcode>xsl:on-completion</elcode> element, using the initial values of the
                  <elcode>xsl:param</elcode> elements. If there is no
                  <elcode>xsl:on-completion</elcode> element, the result is an empty sequence.</p>
            <note>
               <p>Conceptually, <elcode>xsl:iterate</elcode> behaves like a tail-recursive function.
                  The <elcode>xsl:next-iteration</elcode> instruction then represents the recursive
                  call, supplying the tail of the input sequence as an implicit parameter. There are
                  two main reasons for providing the <elcode>xsl:iterate</elcode> instruction. One
                  is that many XSLT users find writing recursive functions to be a difficult skill,
                  and this construct promises to be easier to learn. The other is that recursive
                  function calls are difficult for an optimizer to analyze. Because
                     <elcode>xsl:iterate</elcode> is more constrained than a general-purpose
                  head-tail recursive function, it should be more amenable to optimization. In
                  particular, when the instruction is used in conjunction with
                     <elcode>xsl:source-document</elcode>, it is designed to make it easy for the
                  implementation to use streaming techniques, processing the nodes in an input
                  document sequentially as they are read, without building the entire document tree
                  in memory.</p>
            </note>
            <p>The examples below use <elcode>xsl:iterate</elcode> in conjunction with the
                  <elcode>xsl:source-document</elcode> instruction. This is not the only way of
               using <elcode>xsl:iterate</elcode>, but it illustrates the way in which the two
               features can be combined to achieve streaming of a large input document.</p>
            <example>
               <head>Using <elcode>xsl:iterate</elcode> to Compute Cumulative Totals</head>
               <p>Suppose that the input XML document has this structure</p>
               <eg xml:space="preserve" role="xml">&lt;transactions&gt;
  &lt;transaction date="2008-09-01" value="12.00"/&gt;
  &lt;transaction date="2008-09-01" value="8.00"/&gt;
  &lt;transaction date="2008-09-02" value="-2.00"/&gt;
  &lt;transaction date="2008-09-02" value="5.00"/&gt;
&lt;/transactions&gt;</eg>
               <p>and that the requirement is to transform this to:</p>
               <eg xml:space="preserve" role="xml">&lt;account&gt;
  &lt;balance date="2008-09-01" value="12.00"/&gt;
  &lt;balance date="2008-09-01" value="20.00"/&gt;
  &lt;balance date="2008-09-02" value="18.00"/&gt;
  &lt;balance date="2008-09-02" value="23.00"/&gt;
&lt;/account&gt;</eg>
               <p>This can be achieved using the following code, which is designed to process the
                  transaction file using streaming:</p>
               <eg xml:space="preserve" role="xslt-fragment">&lt;account&gt;
  &lt;xsl:source-document streamable="yes" href="transactions.xml"&gt;
    &lt;xsl:iterate select="transactions/transaction"&gt;
      &lt;xsl:param name="balance" select="0.00" as="xs:decimal"/&gt;
      &lt;xsl:variable name="newBalance" 
                    select="$balance + xs:decimal(@value)"/&gt;
      &lt;balance date="{@date}" value="{format-number($newBalance, '0.00')}"/&gt;
      &lt;xsl:next-iteration&gt;
        &lt;xsl:with-param name="balance" select="$newBalance"/&gt;
      &lt;/xsl:next-iteration&gt;
    &lt;/xsl:iterate&gt;
  &lt;/xsl:source-document&gt;
&lt;/account&gt;</eg>
               <p>The following example modifies this by only outputting the information for the
                  first day’s transactions:</p>
               <eg xml:space="preserve" role="xslt-fragment">&lt;account&gt;
  &lt;xsl:source-document streamable="yes" href="transactions.xml"&gt;
    &lt;xsl:iterate select="transactions/transaction"&gt;
      &lt;xsl:param name="balance" select="0.00" as="xs:decimal"/&gt;
      &lt;xsl:param name="prevDate" select="()" as="xs:date?"/&gt;
      &lt;xsl:variable name="newBalance" 
                    select="$balance + xs:decimal(@value)"/&gt;
      &lt;xsl:variable name="thisDate" 
                    select="xs:date(@date)"/&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="empty($prevDate) or $thisDate eq $prevDate"&gt;
          &lt;balance date="{$thisDate}" 
                   value="{format-number($newBalance, '0.00')}"/&gt;
          &lt;xsl:next-iteration&gt;
            &lt;xsl:with-param name="balance" select="$newBalance"/&gt;
            &lt;xsl:with-param name="prevDate" select="$thisDate"/&gt;
          &lt;/xsl:next-iteration&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:break/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/xsl:iterate&gt;
  &lt;/xsl:source-document&gt;
&lt;/account&gt;</eg>
               <p>The following code outputs the balance only at the end of each day, together with
                  the final balance:</p>
               <eg xml:space="preserve" role="xslt-fragment">&lt;account&gt;
  &lt;xsl:source-document streamable="yes" href="transactions.xml"&gt;
    &lt;xsl:iterate select="transactions/transaction"&gt;
      &lt;xsl:param name="balance" select="0.00" as="xs:decimal"/&gt;
      &lt;xsl:param name="prevDate" select="()" as="xs:date?"/&gt;
      &lt;xsl:on-completion&gt;
        &lt;balance date="{$prevDate}" 
                 value="{format-number($balance, '0.00')}"/&gt;
      &lt;/xsl:on-completion&gt;     
      &lt;xsl:variable name="newBalance" 
                    select="$balance + xs:decimal(@value)"/&gt;
      &lt;xsl:variable name="thisDate" select="xs:date(@date)"/&gt;
      &lt;xsl:if test="exists($prevDate) and $thisDate ne $prevDate"&gt;
        &lt;balance date="{$prevDate}" 
                 value="{format-number($balance, '0.00')}"/&gt;
      &lt;/xsl:if&gt;
      &lt;xsl:next-iteration&gt;
        &lt;xsl:with-param name="balance" select="$newBalance"/&gt;
        &lt;xsl:with-param name="prevDate" select="$thisDate"/&gt;
      &lt;/xsl:next-iteration&gt;     
    &lt;/xsl:iterate&gt;
  &lt;/xsl:source-document&gt;
&lt;/account&gt;</eg>
               <p>If the sequence of transactions is empty, this code outputs a single element:
                     <code>&lt;balance date="" value="0.00"/&gt;</code>.</p>
            </example>
            <example>
               <head>Collecting Multiple Values in a Single Pass</head>
               <p>Problem: Given a sequence of <code>employee</code> elements, find the employees
                  having the highest and lowest salary, while processing each employee only
                  once.</p>
               <p>Solution:</p>
               <eg xml:space="preserve" role="xslt-instruction" diff="chg" at="U-bug30060">&lt;xsl:source-document streamable="yes" href="si-iterate-035.xml"&gt;
            &lt;xsl:iterate select="employees/employee"&gt;
                &lt;xsl:param name="highest" as="element(employee)*"/&gt;
                &lt;xsl:param name="lowest" as="element(employee)*"/&gt;
                &lt;xsl:on-completion&gt;
                    &lt;highest-paid-employees&gt;
                        &lt;xsl:value-of select="$highest/name"/&gt;
                    &lt;/highest-paid-employees&gt;
                    &lt;lowest-paid-employees&gt;
                        &lt;xsl:value-of select="$lowest/name"/&gt;
                    &lt;/lowest-paid-employees&gt;  
                &lt;/xsl:on-completion&gt;
                &lt;xsl:variable name="this" select="copy-of()"/&gt;
                &lt;xsl:variable name="is-new-highest" as="xs:boolean"
                    select="empty($highest[@salary ge current()/@salary])"/&gt;
                &lt;xsl:variable name="is-equal-highest" as="xs:boolean" 
                    select="exists($highest[@salary eq current()/@salary])"/&gt; 
                &lt;xsl:variable name="is-new-lowest" as="xs:boolean" 
                    select="empty($lowest[@salary le current()/@salary])"/&gt;
                &lt;xsl:variable name="is-equal-lowest" as="xs:boolean" 
                    select="exists($lowest[@salary eq current()/@salary])"/&gt; 
                &lt;xsl:variable name="new-highest-set" as="element(employee)*"
                    select="if ($is-new-highest) then $this
                    else if ($is-equal-highest) then ($highest, $this)
                    else $highest"/&gt;
                &lt;xsl:variable name="new-lowest-set" as="element(employee)*"
                    select="if ($is-new-lowest) then $this
                    else if ($is-equal-lowest) then ($lowest, $this)
                    else $lowest"/&gt;
                &lt;xsl:next-iteration&gt;
                    &lt;xsl:with-param name="highest" select="$new-highest-set"/&gt;
                    &lt;xsl:with-param name="lowest" select="$new-lowest-set"/&gt;
                &lt;/xsl:next-iteration&gt;
            &lt;/xsl:iterate&gt;
        &lt;/xsl:source-document&gt;</eg>
               <p>If the input sequence is empty, this code outputs an empty
                     <code>highest-paid-employees</code> element and an empty
                     <code>lowest-paid-employees</code> element.</p>
            </example>
            <example diff="add" at="E">
               <head>Processing the Last Item in a Sequence Specially</head>
               <p>When streaming, it is not possible to determine whether the item being processed
                  is the last in a sequence without reading ahead. The <xfunction>last</xfunction>
                  function therefore cannot be used in <termref def="dt-guaranteed-streamable"/>
                  code. The <elcode>xsl:iterate</elcode> instruction provides a solution to this
                  problem.</p>
               <p>Problem: render the last paragraph in a section in some special way, for example
                  by using bold face. (The actual rendition is achieved by processing the paragraph
                  with mode <code>last-para</code>.)</p>
               <p>The solution uses <elcode>xsl:iterate</elcode>
                  <phrase diff="add" at="P">together with the <function>copy-of</function>
                     function</phrase> to maintain a one-element look-ahead by explicit coding:</p>
               <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:template match="section" mode="streaming"&gt;
   &lt;xsl:iterate select="para"&gt;
     &lt;xsl:param name="prev" select="()" as="element(para)?"/&gt;
     &lt;xsl:on-completion&gt;
       &lt;xsl:apply-templates select="$prev" mode="last-para"/&gt;      
     &lt;/xsl:on-completion&gt;
     &lt;xsl:if test="$prev"&gt;
       &lt;xsl:apply-templates select="$prev"/&gt;
     &lt;/xsl:if&gt;
     &lt;xsl:next-iteration&gt;
       &lt;xsl:with-param name="prev" select="copy-of(.)"/&gt;
     &lt;/xsl:next-iteration&gt;
   &lt;/xsl:iterate&gt;
 &lt;/xsl:template&gt;</eg>
            </example>
         </div2>
      </div1>
      <div1 id="conditionals">
         <head>Conditional Processing</head>
         <p>There are two instructions in XSLT that support conditional processing:
               <elcode>xsl:if</elcode> and <elcode>xsl:choose</elcode>. The <elcode>xsl:if</elcode>
            instruction provides simple if-then conditionality; the <elcode>xsl:choose</elcode>
            instruction supports selection of one choice when there are several possibilities.</p>
         <p diff="add" at="B">XSLT 3.0 also supports <elcode>xsl:try</elcode> and
               <elcode>xsl:catch</elcode> which define conditional processing to handle <termref
               def="dt-dynamic-error">dynamic errors</termref>.</p>
         <div2 id="xsl-if">
            <head>Conditional Processing with <elcode>xsl:if</elcode>
            </head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="if">
               <e:in-category name="instruction"/>
               <e:attribute name="test" required="yes">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:if</elcode> element has a mandatory <code>test</code> attribute,
               which specifies an <termref def="dt-expression">expression</termref>. The content is
               a <termref def="dt-sequence-constructor"/>.</p>
            <p>The result of the <elcode>xsl:if</elcode> instruction depends on the <xtermref
                  spec="XP30" ref="dt-ebv">effective boolean value</xtermref> of the expression in
               the <code>test</code> attribute. The rules for determining the effective boolean
               value of an expression are given in <bibref ref="xpath-30"/>: they are the same as
               the rules used for XPath conditional expressions.</p>
            <p>If the effective boolean value of the <termref def="dt-expression"
                  >expression</termref> is true, then the <termref def="dt-sequence-constructor"
                  >sequence constructor</termref> is evaluated (see <specref
                  ref="sequence-constructors"/>), and the resulting <phrase diff="del" at="K"
                  >node</phrase> sequence is returned as the result of the <elcode>xsl:if</elcode>
               instruction; otherwise, the sequence constructor is not evaluated, and the empty
               sequence is returned.</p>
            <example>
               <head>Using <elcode>xsl:if</elcode>
               </head>
               <p>In the following example, the names in a group of names are formatted as a comma
                  separated list:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="namelist/name"&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:if test="not(position()=last())"&gt;, &lt;/xsl:if&gt;
&lt;/xsl:template&gt;</eg>
               <p>The following colors every other table row yellow:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="item"&gt;
  &lt;tr&gt;
    &lt;xsl:if test="position() mod 2 = 0"&gt;
       &lt;xsl:attribute name="bgcolor"&gt;yellow&lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;</eg>
            </example>
         </div2>
         <div2 id="xsl-choose">
            <head>Conditional Processing with <elcode>xsl:choose</elcode>
            </head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="choose">
               <e:in-category name="instruction"/>
               <e:sequence>
                  <e:element repeat="one-or-more" name="when"/>
                  <e:element repeat="zero-or-one" name="otherwise"/>
               </e:sequence>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="when">
               <e:attribute name="test" required="yes">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent name="choose"/>
               </e:allowed-parents>
            </e:element-syntax>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="otherwise">
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent name="choose"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:choose</elcode> element selects one among a number of possible
               alternatives. It consists of a sequence of one or more <elcode>xsl:when</elcode>
               elements followed by an optional <elcode>xsl:otherwise</elcode> element. Each
                  <elcode>xsl:when</elcode> element has a single attribute, <code>test</code>, which
               specifies an <termref def="dt-expression">expression</termref>. The content of the
                  <elcode>xsl:when</elcode> and <elcode>xsl:otherwise</elcode> elements is a
                  <termref def="dt-sequence-constructor"/>.</p>
            <p>When an <elcode>xsl:choose</elcode> element is processed, each of the
                  <elcode>xsl:when</elcode> elements is tested in turn (that is, in the order that
               the elements appear in the stylesheet), until one of the <elcode>xsl:when</elcode>
               elements is satisfied. If none of the <elcode>xsl:when</elcode> elements is
               satisfied, then the <elcode>xsl:otherwise</elcode> element is considered, as
               described below.</p>
            <p>An <elcode>xsl:when</elcode> element is satisfied if the <xtermref spec="XP30"
                  ref="dt-ebv">effective boolean value</xtermref> of the <termref
                  def="dt-expression">expression</termref> in its <code>test</code> attribute is
                  <code>true</code>. The rules for determining the effective boolean value of an
               expression are given in <bibref ref="xpath-30"/>: they are the same as the rules used
               for XPath conditional expressions.</p>
            <p>The content of the first, and only the first, <elcode>xsl:when</elcode> element that
               is satisfied is evaluated, and the resulting sequence is returned as the result of
               the <elcode>xsl:choose</elcode> instruction. If no <elcode>xsl:when</elcode> element
               is satisfied, the content of the <elcode>xsl:otherwise</elcode> element is evaluated,
               and the resulting sequence is returned as the result of the
                  <elcode>xsl:choose</elcode> instruction. If no <elcode>xsl:when</elcode> element
               is satisfied, and no <elcode>xsl:otherwise</elcode> element is present, the result of
               the <elcode>xsl:choose</elcode> instruction is an empty sequence.</p>
            <p>Only the sequence constructor of the selected <elcode>xsl:when</elcode> or
                  <elcode>xsl:otherwise</elcode> instruction is evaluated. The <code>test</code>
               expressions for <elcode>xsl:when</elcode> instructions after the selected one are not
               evaluated.</p>
            <example>
               <head>Using <elcode>xsl:choose</elcode>
               </head>
               <p>The following example enumerates items in an ordered list using arabic numerals,
                  letters, or roman numerals depending on the depth to which the ordered lists are
                  nested.</p>
               <eg xml:space="preserve" role="xslt-declaration xmlns:fo='fo'">&lt;xsl:template match="orderedlist/listitem"&gt;
  &lt;fo:list-item indent-start='2pi'&gt;
    &lt;fo:list-item-label&gt;
      &lt;xsl:variable name="level"
                    select="count(ancestor::orderedlist) mod 3"/&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test='$level=1'&gt;
          &lt;xsl:number format="i"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:when test='$level=2'&gt;
          &lt;xsl:number format="a"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:number format="1"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
      &lt;xsl:text&gt;. &lt;/xsl:text&gt;
    &lt;/fo:list-item-label&gt;
    &lt;fo:list-item-body&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/fo:list-item-body&gt;
  &lt;/fo:list-item&gt;
&lt;/xsl:template&gt;</eg>
            </example>
         </div2>
         <div2 diff="add" at="B" id="try-catch">
            <head>Try/Catch</head>
            <p diff="add" at="C">The <elcode>xsl:try</elcode> instruction can be used to trap
               dynamic errors occurring within the expression it wraps; the recovery action if such
               errors occur is defined using a child <elcode>xsl:catch</elcode> element.</p>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="try">
               <e:in-category name="instruction"/>
               <e:attribute name="select" required="no">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="rollback-output">
                  <e:data-type name="boolean"/>
               </e:attribute>
               <e:sequence>
                  <e:model name="sequence-constructor"/>
                  <e:element name="catch"/>
                  <e:choice repeat="zero-or-more">
                     <e:element name="catch"/>
                     <e:element name="fallback"/>
                  </e:choice>
               </e:sequence>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <note>
               <p>Because a sequence constructor may contain an <elcode>xsl:fallback</elcode>
                  element, the effect of this content model is that an <elcode>xsl:fallback</elcode>
                  instruction may appear as a child of <elcode>xsl:try</elcode> in any position.</p>
            </note>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="catch">
               <e:attribute name="errors" required="no">
                  <e:data-type name="tokens"/>
               </e:attribute>
               <e:attribute name="select" required="no">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent name="try"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>An <elcode>xsl:try</elcode> instruction evaluates either the expression contained in
               its <code>select</code> attribute, or its contained <termref
                  def="dt-sequence-constructor">sequence constructor</termref>, and returns the
               result of that evaluation if it succeeds without error. If a <termref
                  def="dt-dynamic-error">dynamic error</termref> occurs during the evaluation, the
               processor evaluates the first <elcode>xsl:catch</elcode> child element applicable to
               the error, and returns that result instead.</p>
            <p>If the <elcode>xsl:try</elcode> element has a <code>select</code> attribute, then it
                  <rfc2119>must</rfc2119> have no children other than <elcode>xsl:catch</elcode> and
                  <elcode>xsl:fallback</elcode>. That is, the <code>select</code> attribute and the
               contained sequence constructor are mutually exclusive. If neither is present, the
               result of the <elcode>xsl:try</elcode> is an empty sequence (no dynamic error can
               occur in this case).</p>
            <p diff="add" at="R-bug25174">The <code>rollback-output</code> attribute is described in
                  <specref ref="recovery"/>. The default value is <code>yes</code>.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="3140"><p>It is a <termref
                        def="dt-static-error">static error</termref> if the <code>select</code>
                     attribute of the <elcode>xsl:try</elcode> element is present and the element
                     has children other than <elcode>xsl:catch</elcode> and
                        <elcode>xsl:fallback</elcode> elements.</p></error>
            </p>
            <p>Any <elcode>xsl:fallback</elcode> children of the <elcode>xsl:try</elcode> element
               are ignored by an XSLT 3.0 processor, but can be used to define the recovery action
               taken by an XSLT 1.0 or XSLT 2.0 processor operating with <termref
                  def="dt-forwards-compatible-behavior"/>.</p>
            <p>The <elcode>xsl:catch</elcode> element has an optional <code>errors</code> attribute,
               which lists the error conditions that the <elcode>xsl:catch</elcode> element is
               designed to intercept. The default value is <code>errors="*"</code>, which catches
               all errors. The value is a whitespace-separated list of <xnt
                  xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30" ref="prod-xpath30-NameTest"
                  xlink:type="simple">NameTests</xnt>; an <elcode>xsl:catch</elcode> element catches
               an error condition if this list includes a <code>NameTest</code> that matches the
               error code associated with that error condition.</p>
            <note>
               <p>Error codes are QNames. Those defined in this specification and in related
                  specifications are all in the <termref def="dt-standard-error-namespace">standard
                     error namespace</termref>, and may therefore be caught using an
                     <elcode>xsl:catch</elcode> element such as <code>&lt;xsl:catch
                     errors="err:FODC0001 err:FODC0005"&gt;</code> where the namespace prefix
                     <code>err</code> is bound to this namespace. Errors defined by implementers,
                  and errors raised by an explicit call of the <xfunction>error</xfunction> function
                  or by use of the <elcode>xsl:message</elcode>
                  <phrase diff="add" at="L">or <elcode>xsl:assert</elcode></phrase> instruction, may
                  use error codes in other namespaces.</p>
            </note>
            <p>If more than one <elcode>xsl:catch</elcode> element matches an error, the error is
               processed using the first one that matches, in document order. If no
                  <elcode>xsl:catch</elcode> matches the error, then the error is not caught (that
               is, evaluation of the <elcode>xsl:try</elcode> element fails with the dynamic
               error).</p>
            <p>An <elcode>xsl:catch</elcode> element may have either a <code>select</code>
               attribute, or a contained <termref def="dt-sequence-constructor">sequence
                  constructor</termref>.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="3150"><p>It is a <termref
                        def="dt-static-error">static error</termref> if the <code>select</code>
                     attribute of the <elcode>xsl:catch</elcode> element is present unless the
                     element has empty content.</p></error>
            </p>
            <p>The result of evaluating the <elcode>xsl:catch</elcode> element is the result of
               evaluating the XPath expression in its <code>select</code> attribute or the result of
               evaluating the contained sequence constructor; if neither is present, the result is
               an empty sequence. This result is delivered as the result of the
                  <elcode>xsl:try</elcode> instruction.</p>
            <p>If a dynamic error occurs during the evaluation of <elcode>xsl:catch</elcode>, it
               causes the containing <elcode>xsl:try</elcode> to fail with this error. The error is
               not caught by other sibling <elcode>xsl:catch</elcode> elements within the same
                  <elcode>xsl:try</elcode> instruction, but it may be caught by an
                  <elcode>xsl:try</elcode> instruction at an outer level, or by an
                  <elcode>xsl:try</elcode> instruction nested within the <elcode>xsl:catch</elcode>. </p>
            <p>Within the <code>select</code> expression, or within the sequence constructor
               contained by the <elcode>xsl:catch</elcode> element, a number of variables are
               implicitly declared, giving information about the error that occurred. These are
               lexically scoped to the <elcode>xsl:catch</elcode> element. These variables are all
               in the <termref def="dt-standard-error-namespace">standard error namespace</termref>,
               and they are initialized as described in the following table:</p>
            <table class="data">
               <caption>Variables Available within <code>xsl:catch</code></caption>
               <thead>
                  <tr>
                     <th rowspan="1" colspan="1">Variable</th>
                     <th rowspan="1" colspan="1">Type</th>
                     <th rowspan="1" colspan="1">Value</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td rowspan="1" colspan="1">err:code</td>
                     <td rowspan="1" colspan="1">xs:QName</td>
                     <td rowspan="1" colspan="1">The error code</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">err:description</td>
                     <td rowspan="1" colspan="1">xs:string<phrase diff="add" at="G">?</phrase></td>
                     <td rowspan="1" colspan="1">A description of the error condition; <phrase
                           diff="chg" at="G">an empty sequence if no description is available (for
                           example, if the <xfunction>error</xfunction> function was called with one
                           argument)</phrase>.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">err:value</td>
                     <td rowspan="1" colspan="1">item()*</td>
                     <td rowspan="1" colspan="1">Value associated with the error. For an error
                        raised by calling the <xfunction>error</xfunction> function, this is the
                        value of the third argument (if supplied). For an error raised by evaluating
                           <elcode>xsl:message</elcode> with <code>terminate="yes"</code>, <phrase
                           diff="add" at="L">or a failing <elcode>xsl:assert</elcode></phrase>, this
                        is the document node at the root of the tree containing the XML message
                        body.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">err:module</td>
                     <td rowspan="1" colspan="1">xs:string?</td>
                     <td rowspan="1" colspan="1">The URI (or system ID) of the stylesheet module
                        containing the instruction where the error occurred; an empty sequence if
                        the information is not available.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">err:line-number</td>
                     <td rowspan="1" colspan="1">xs:integer?</td>
                     <td rowspan="1" colspan="1">The line number within the stylesheet module of the
                        instruction where the error occurred; an empty sequence if the information
                        is not available. The value <rfc2119>may</rfc2119> be approximate.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">err:column-number</td>
                     <td rowspan="1" colspan="1">xs:integer?</td>
                     <td rowspan="1" colspan="1">The column number within the stylesheet module of
                        the instruction where the error occurred; an empty sequence if the
                        information is not available. The value <rfc2119>may</rfc2119> be
                        approximate.</td>
                  </tr>
               </tbody>
            </table>
            <p>Variables declared within the sequence constructor of the <elcode>xsl:try</elcode>
               element (and not within an <elcode>xsl:catch</elcode>) are not visible within the
                  <elcode>xsl:catch</elcode> element.</p>
            <note>
               <p>Within an <elcode>xsl:catch</elcode> it is possible to re-throw the error using
                  the function call <code>error($err:code, $err:description, $err:value)</code>.</p>
            </note>
            <p>The following additional rules apply to the catching of errors:</p>
            <olist>
               <item>
                  <p>All dynamic errors occurring during the evaluation of the
                        <elcode>xsl:try</elcode> sequence constructor or <code>select</code>
                     expression are caught (provided they match one of the
                        <elcode>xsl:catch</elcode> elements). </p>
                  <note>
                     <ulist>
                        <item>
                           <p>This includes errors occurring in functions or templates invoked in
                              the course of this evaluation, unless already caught by a nested
                                 <elcode>xsl:try</elcode>.</p>
                        </item>
                        <item>
                           <p>It also includes <phrase diff="add" at="S-bug28955">(for
                                 example)</phrase> errors caused by calling the
                                 <xfunction>error</xfunction> function, or the
                                 <elcode>xsl:message</elcode> instruction with
                                 <code>terminate="yes"</code>, or the <phrase diff="add" at="L">
                                 <elcode>xsl:assert</elcode> instruction</phrase>, <phrase
                                 diff="add" at="S-bug28955">or the <code>xs:error</code> constructor
                                 function</phrase>. </p>
                        </item>
                        <item>
                           <p>It does not include errors that occur while evaluating references to
                              variables whose declaration and initialization is outside the
                                 <elcode>xsl:try</elcode>.</p>
                        </item>
                     </ulist>
                  </note>
               </item>
               <item diff="del" at="Q">
                  <p>The existence of an <elcode>xsl:try</elcode> instruction does not affect the
                     right of the processor to recover, or not recover, from errors classified as
                     recoverable dynamic errors. An <elcode>xsl:catch</elcode> element will be
                     activated only if the processor chooses to signal the error rather than taking
                     the defined recovery action.</p>
               </item>
               <item>
                  <p>The existence of an <elcode>xsl:try</elcode> instruction does not affect the
                     obligation of the processor to signal certain errors as static errors, or its
                     right to choose whether to signal some errors (such as <termref
                        def="dt-type-error">type errors</termref>) statically or dynamically. Static
                     errors are never caught.</p>
               </item>
               <item>
                  <p>Some fatal errors arising in the processing environment, such as running out of
                     memory, may cause termination of the transformation despite the presence of an
                        <elcode>xsl:try</elcode> instruction. This is <termref
                        def="dt-implementation-dependent">implementation-dependent</termref>.</p>
               </item>
               <item>
                  <p>If the sequence constructor or <code>select</code> expression of the
                        <elcode>xsl:try</elcode> causes execution of
                        <elcode>xsl:result-document</elcode>, <elcode>xsl:message</elcode>, <phrase
                        diff="add" at="L">or <elcode>xsl:assert</elcode></phrase> instructions and
                     fails with a dynamic error that is caught, it is implementation-dependent
                     whether these instructions have any externally visible effect. The processor is
                        <rfc2119>not required</rfc2119> to roll back any changes made by these
                     instructions. The same applies to any side effects caused by extension
                     functions or extension instructions.</p>
               </item>
               <item>
                  <p diff="del" at="M">If the <elcode>xsl:try</elcode> element appears in a context
                     where it is required to deliver a value of a specified type (for example, if it
                     appears as the body of a stylesheet function), then any error that occurs
                     because it delivers a value of the wrong type, or an error that occurs during
                     conversion to the required type (for example, during atomization), is treated
                     as occurring within the scope of the <elcode>xsl:try</elcode> instruction.</p>
                  <p diff="add" at="M">A serialization error that occurs during the serialization of
                     a <termref diff="chg" at="S-bug27258" def="dt-secondary-result"/> produced
                     using <elcode>xsl:result-document</elcode> is treated as a dynamic error in the
                     evaluation of the <elcode>xsl:result-document</elcode> instruction, and may be
                     caught (for example by an <elcode>xsl:try</elcode> instruction that contains
                     the <elcode>xsl:result-document</elcode> instruction). A serialization error
                     that occurs while serializing the <phrase diff="add" at="S-bug27258"><termref
                           def="dt-principal-result"/></phrase>
                     <phrase diff="del" at="S-bug27258">implicit <termref def="dt-final-result-tree"
                        /> returned by the <termref def="dt-initial-named-template"/></phrase> is
                     treated as occurring after the transformation has finished, and cannot be
                     caught. </p>
               </item>
               <item>
                  <p diff="del" at="M">When an instruction <var>J</var> computes a value that will
                     inevitably cause some outer-level instruction <var>O</var> to fail with a
                     dynamic error, then the failure <rfc2119>may</rfc2119> be treated as occurring
                     in <var>J</var>, in which case it will be caught by an <elcode>xsl:try</elcode>
                     instruction whose scope includes <var>J</var> but does not include
                     <var>O</var>. For example, creating an element may fail because the element is
                     not allowed by the content model of a containing element; although the
                     specification describes this as a failure associated with the construction of
                     the containing element, a processor is allowed to detect the error as soon as
                     it becomes inevitable.</p>
                  <note diff="del" at="M">
                     <p>The effect of this rule is that when stylesheet output is streamed to a
                        schema validator or to a serializer, errors detected by the validation or
                        serialization process may be treated if they occurred in the instruction
                        that generated the offending output; however, stylesheet authors cannot rely
                        on this. In fact, where serialization is applied to a <termref
                           def="dt-final-result-tree"/>, there is no guarantee that it will be
                        possible to catch the error at all, since serialization is outside the scope
                        of the transformation process proper.</p>
                  </note>
                  <p diff="add" at="M">A validation error is treated as occurring in the instruction
                     that requested validation. For example, if the stylesheet is producing XHTML
                     output and requests validation of the entire result document by means of the
                     attribute <code>validation="strict"</code> on the instruction that creates the
                     outermost <code>html</code> element, then a validation failure can be caught
                     only at that level. Although the validation error might be detected, for
                     example, while writing a <code>p</code> element at a location where no
                        <code>p</code> element is allowed, it is not treated as an error in the
                     instruction that writes the <code>p</code> element and cannot be caught at that
                     level.</p>
               </item>
               <item diff="add" at="N">
                  <p>A type error may be caught if the processor raises it dynamically; this does
                     not affect the processor’s right to raise the error statically if it
                     chooses.</p>
                  <p>The following rules are provided to define which expression is considered to
                     fail when a type error occurs, and therefore where the error can be caught. The
                     general principle is that where the semantics of a construct <var>C</var> place
                     requirements on the type of some subexpression, a type error is an error in the
                     evaluation of <var>C</var>, not in the evaluation of the subexpression.</p>
                  <p>For example, consider the following construct:</p>
                  <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:variable name="v" as="xs:integer"&gt;
  &lt;xsl:sequence select="$foo"/&gt;
&lt;/xsl:variable&gt;</eg>
                  <p>The expected type of the result of the sequence constructor is
                        <code>xs:integer</code>; if the value of variable <code>$foo</code> turns
                     out to be a string, then a type error will occur. It is not possible to catch
                     this by writing:</p>
                  <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:variable name="v" as="xs:integer"&gt;
  &lt;xsl:try&gt;
    &lt;xsl:sequence select="$foo"/&gt;
    &lt;xsl:catch&gt;...&lt;/xsl:catch&gt;
  &lt;/xsl:try&gt;
&lt;/xsl:variable&gt;</eg>
                  <p>This fails to catch the error because the <elcode>xsl:sequence</elcode>
                     instruction is deemed to evaluate successfully; the failure only occurs when
                     the result of this instruction is bound to the variable.</p>
                  <p>A similar rule applies to functions: if the body of a function computes a
                     result which does not conform to the required type of the function result, it
                     is not possible to catch this error within the function body itself; it can
                     only be caught by the caller of the function. Similarly, if an expression used
                     to compute an argument to a function returns a value of the wrong type for the
                     function signature, this is not considered an error in this expression, but an
                     error in evaluating the function call as a whole.</p>
                  <p>A consequence of these rules is that when a type error occurs while
                     initializing a global variable (because the initializer returns a value of the
                     wrong type, given the declared type of the variable), then this error cannot be
                     caught.</p>
                  <note diff="add" at="O">
                     <p>Because processors are permitted to report type errors during static
                        analysis, it is unwise to attempt to recover from type errors dynamically.
                        The best strategy is generally to prevent their occurrence. For example,
                        rather than writing <code>$p + 1</code> where <code>$p</code> is a parameter
                        of unknown type, and then catching the type error that occurs if
                           <code>$p</code> is not numeric, it is better first to test whether
                           <code>$p</code> is numeric, perhaps by means of an expression such as
                           <code>$p instance of my:numeric</code>, where <code>my:numeric</code> is
                        a union type with <code>xs:double</code>, <code>xs:float</code>, and
                           <code>xs:decimal</code> as its member types.</p>
                  </note>
               </item>
               <item>
                  <p>The fact that the application tries to catch errors does not prevent the
                     processor from organizing the evaluation in such a way as to prevent errors
                     occurring. For example <code>exists(//a[10 div . gt 5])</code> may still do an
                     “early exit”, rather than examining every item in the sequence just to see if
                     it triggers a divide-by-zero error.</p>
               </item>
               <item>
                  <p>Except as specified above, the optimizer must not rearrange the evaluation (at
                     compile time or at run time) so that expressions written to be subject to the
                     try/catch are evaluated outside its scope, or expressions written to be
                     external to the try/catch are evaluated within its scope. This does not prevent
                     expressions being rearranged, but any expression that is so rearranged must
                     carry its try/catch context with it.</p>
               </item>
            </olist>
            <note diff="del" at="S-bug28221">
               <p>If an error occurs while evaluating an instruction within
                  <elcode>xsl:try</elcode>, then no instruction within the <elcode>xsl:try</elcode>
                  has any effect on the result returned by the <elcode>xsl:try</elcode> instruction.
                  This means that if a processor is streaming the output to a serializer, it needs
                  to adopt a strategy such as buffering the output in memory so that nothing is
                  written until successful completion of the <elcode>xsl:try</elcode> instruction,
                  or checkpointing the output so it can be rolled back when an error occurs.</p>
            </note>
            <note diff="del" at="R-bug25174">
               <p>Use of try/catch may affect the ability of a processor to perform streamed
                  evaluation of a stylesheet. If the sequence constructor contained within
                     <elcode>xsl:try</elcode> creates a sequence of ten elements, and these form
                  part of a final result tree, then if a failure occurs while writing the tenth
                  element, the work of creating the previous nine must be undone. In effect this
                  means that either the processor must delay sending the new elements to the
                  serializer until it is assured of success, or the serializer must provide a
                  mechanism to roll back elements already written.</p>
            </note>
            <div3 id="recovery" diff="add" at="R-bug25174">
               <head>Recovery of Result Trees</head>
               <p>The XSLT language is designed so that a processor that chooses to execute
                  instructions in document order will always append nodes to the result tree in
                  document order, and never needs to update a result tree in situ. As a result, it
                  is normal practice for XSLT processors to stream the result tree directly to its
                  final destination (for example, a serializer) without ever holding the tree in
                  memory. This applies whether or not the processor is streamable, and whether or
                  not source documents are streamed.</p>
               <p>The language specification states (see <specref ref="errors"/>) that when a
                  transformation terminates with a dynamic error, the state of persistent resources
                  affected by the transformation (for example, serialized result documents) is
                     <termref def="dt-implementation-defined"/>, so processors are not required to
                  take any special steps to recover such resources to their pre-transformation
                  state; at the same time, there is no guarantee that secondary result documents
                  produced before the failure occurs will be in a usable state.</p>
               <p>The situation becomes more complicated when dynamic errors occur while writing to
                  a result tree, and the dynamic error is caught by an
                     <elcode>xsl:try</elcode>/<elcode>xsl:catch</elcode> instruction. The semantics
                  of these instructions requires that when an error occurring during the evaluation
                  of <elcode>xsl:try</elcode> is caught, the result of the <elcode>xsl:try</elcode>
                  instruction is the result of the relevant <elcode>xsl:catch</elcode>. To achieve
                  this, any output written to the result tree during the execution of
                     <elcode>xsl:try</elcode> until the point where the error occurs must
                  effectively be undone. There are two basic strategies for achieving this: either
                  the updates are not committed to persistent storage until the
                     <elcode>xsl:try</elcode> instruction is completed, or the updates are written
                  in such a way that they can be rolled back in the event of a failure.</p>
               <p>Both these strategies are potentially expensive, and both have an adverse effect
                  on streaming, in that they affect the amount of memory needed to transform large
                  amounts of data. XSLT 3.0 therefore provides an option to relax the requirement to
                  recover result trees when failures occur in the course of evaluating an
                     <elcode>xsl:try</elcode> instruction. This option is invoked by specifying
                     <code>rollback-output="no"</code> on the <elcode>xsl:try</elcode>
                  instruction.</p>
               <p>The default value of the attribute is <code>rollback-output="yes"</code>.</p>
               <p>The effect of specifying <code>rollback-output="no"</code> on
                     <elcode>xsl:try</elcode> is as follows: if a dynamic error occurs in the course
                  of evaluating the <elcode>xsl:try</elcode> instruction, and if the failing
                  construct is evaluated in <termref def="dt-final-output-state"/> while writing to
                  some result document, then it is <termref def="dt-implementation-dependent"/>
                  whether an attempt to catch this error using <elcode>xsl:catch</elcode> will be
                  successful. If the attempt is successful, then the <elcode>xsl:try</elcode>
                  instruction succeeds, delivering the result of evaluating the
                     <elcode>xsl:catch</elcode> clause, and the transformation proceeds as normal.
                  If the attempt is unsuccessful (typically, because non-recoverable updates have
                  already been made to the result tree), then the <elcode>xsl:try</elcode>
                  instruction as a whole fails with a dynamic error. The state of this result
                  document will then be undefined, but the transformation can ignore the failure and
                  continue to produce other result documents, for example by wrapping the
                     <elcode>xsl:result-document</elcode> instruction in an <elcode>xsl:try</elcode>
                  instruction that catches the relevant error.</p>
               <p>
                  <error spec="XT" class="DE" code="3530" type="dynamic"><p>It is a <termref
                           def="dt-dynamic-error"/> if an <elcode>xsl:try</elcode> instruction is
                        unable to recover the state of a final result tree because recovery has been
                        disabled by use of the attribute
                     <code>rollback-output="no"</code>.</p></error>
               </p>
               <p>For example, consider the following:</p>
               <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:result-document href="out.xml"&gt;     
  &lt;xsl:try rollback-output="no"&gt;
    &lt;xsl:source-document streamable="yes" href="in.xml"&gt;
      &lt;xsl:copy-of select="."/&gt;
    &lt;/xsl:source-document&gt;
    &lt;xsl:catch errors="*"&gt;
       &lt;error code="{$err:code}" message="{$err:description}" file="in.xml"/&gt;
    &lt;/xsl:catch&gt;
  &lt;/xsl:try&gt;
&lt;/xsl:result-document&gt;</eg>
               <p>The most likely failure to occur here is a failure to read the streamed input file
                     <code>in.xml</code>. In the common case where this failure is detected
                  immediately, for example if the file does not exist or the network connection is
                  down, no output will have been written to the result document, and the attempt to
                  catch the error is likely to be successful. If however a failure is detected after
                  several megabytes of data have been copied to <code>out.xml</code>, for example an
                  XML well-formedness error in the input file, or a network failure that occurs
                  while reading the file, recovery of the output file may be impossible. In this
                  situation the <elcode>xsl:result-document</elcode> instruction will fail with a
                  dynamic error. It is possible to catch this error, but the state of the file
                     <code>out.xml</code> will be unpredictable.</p>
               <p>Note that adding an <elcode>xsl:try</elcode> instruction as a child of
                     <elcode>xsl:source-document</elcode> does not help. Any error reading the input
                  file (such as a well-formedness error) is an error in the
                     <elcode>xsl:source-document</elcode> instruction and can only be caught at that
                  level.</p>
               <p>When <code>rollback-output="no"</code> is specified, it is still possible to
                  ensure recovery of errors happens predictably by evaluating the
                  potentially-failing code in <termref def="dt-temporary-output-state"/>: typically,
                  within an <elcode>xsl:variable</elcode>. In effect the variable acts as an
                  explicit buffer for temporary results, which is only copied to the final output if
                  evaluation succeeds.</p>
               <note>
                  <p>An application might wish to ensure that when a fatal error occurs while
                     reading an input stream, data written to persistent storage up to the point of
                     failure is available after the transformation terminates. Setting
                        <code>rollback-output="no"</code> does not guarantee this, but a processor
                     might choose to interpret this as the intent.</p>
               </note>
               <p>Changing the attribute to <code>rollback-output="yes"</code> makes the stylesheet
                  more robust and able to handle error conditions predictably, but the cost may be
                  substantial; for example it may be necessary to buffer the whole of the result
                  document in memory.</p>
            </div3>
            <div3 id="try-catch-examples">
               <head>Try/Catch Examples</head>
               <example>
                  <head>Catching a Divide-by-Zero Error</head>
                  <p>The following example divides an employee’s salary by the number of years they
                     have served, catching the divide-by-zero error if the latter is zero.</p>
                  <eg role="xslt-instruction xmlns:err='http://www.w3.org/2005/xqt-errors'" xml:space="preserve">&lt;xsl:try select="salary div length-of-service"&gt;
  &lt;xsl:catch errors="err:FOAR0001" select="()"/&gt;
&lt;/xsl:try&gt;</eg>
               </example>
               <example>
                  <head>Catching an Error during Result-tree Validation</head>
                  <p>The following example generates a result tree and performs schema validation,
                     outputting a warning message and serializing the invalid tree if validation
                     fails.</p>
                  <eg role="xslt-instruction xmlns:err='http://www.w3.org/2005/xqt-errors'" xml:space="preserve">&lt;xsl:result-document href="out.xml"&gt;
  &lt;xsl:variable name="result"&gt;
    &lt;xsl:call-template name="construct-output"/&gt;
  &lt;/xsl:variable&gt;
  &lt;xsl:try&gt;
    &lt;xsl:copy-of select="$result" validation="strict"/&gt;
    &lt;xsl:catch&gt;
      &lt;xsl:message&gt;Warning: validation of result document failed:
          Error code: &lt;xsl:value-of select="$err:code"/&gt;
          Reason: &lt;xsl:value-of select="$err:description"/&gt;
      &lt;/xsl:message&gt;
      &lt;xsl:sequence select="$result"/&gt;
    &lt;/xsl:catch&gt;
  &lt;/xsl:try&gt;
&lt;/xsl:result-document&gt;
</eg>
                  <p>The reason that the result tree is constructed in a variable in this example is
                     so that the unvalidated tree is available to be used within the
                        <elcode>xsl:catch</elcode> element. An alternative approach would be to
                     repeat the logic for constructing the tree:</p>
                  <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:try&gt;
  &lt;xsl:result-document href="out.xml" validation="strict"&gt;  
    &lt;xsl:call-template name="construct-output"/&gt;
  &lt;/xsl:result-document&gt;
  &lt;xsl:catch&gt;
    &lt;xsl:message&gt;Warning: validation of result document failed:
          Error code: &lt;xsl:value-of select="$err:code"/&gt;
          Reason: &lt;xsl:value-of select="$err:description"/&gt;
    &lt;/xsl:message&gt;
    &lt;xsl:call-template name="construct-output"/&gt;
  &lt;/xsl:catch&gt;
&lt;/xsl:try&gt;</eg>
               </example>
            </div3>
         </div2>
         <div2 id="conditional-content-construction" diff="add" at="S-bug27189">
            <head>Conditional Content Construction</head>
            <p>The facilities described in this section are designed to make it easier to generate
               result trees conditionally depending on what is found in the input, without violating
               the rules for streamability. These facilities are available whether or not streaming
               is in use, but they are introduced to the language specifically to make streaming
               easier.</p>
            <p>The facilities are introduced first by example:</p>
            <example>
               <head>Generating a Wrapper Element for a non-Empty Sequence</head>
               <p>The following example generates an <code>events</code> element if and only if
                  there are one or more <code>event</code> elements. The code could be written like
                  this:</p>
               <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:if test="exists(event)"&gt;
  &lt;events&gt;
    &lt;xsl:copy-of select="event"/&gt;
  &lt;/events&gt;
&lt;/xsl:if&gt;</eg>
               <p>However, the above code would not be <termref def="dt-guaranteed-streamable"/>,
                  because it processes the child <code>event</code> elements more than once. To make
                  it streamable, it can be rewritten as:</p>
               <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:where-populated&gt;
  &lt;events&gt;
    &lt;xsl:copy-of select="event"/&gt;
  &lt;/events&gt;
&lt;/xsl:where-populated&gt;</eg>
               <p>The effect of the <elcode>xsl:where-populated</elcode> instruction, as explained
                  later, is to avoid outputting the <code>events</code> element if it would have no
                  children. A streaming implementation will typically hold the start tag of the
                     <code>events</code> element in a buffer, to be sent to the output destination
                  only if and when a child node is generated.</p>
            </example>
            <example>
               <head>Generating a Header and Footer only if there is Content</head>
               <p>The following example generates an <code>h3</code> element and a summary paragraph
                  only if a list of items is non-empty. The code could be written like this:</p>
               <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:if test="exists(item-for-sale)"&gt;
  &lt;h1&gt;Items for Sale&lt;/h1&gt;
&lt;/xsl:if&gt;  
&lt;xsl:apply-templates select="item-for-sale"/&gt;
&lt;xsl:if test="exists(item-for-sale)"&gt;
  &lt;p&gt;Total value: {accumulator-before('total-value')}&lt;/p&gt;
&lt;/xsl:if&gt;</eg>
               <p>However, the above code would not be <termref def="dt-guaranteed-streamable"/>,
                  because it processes the child <code>item-for-sale</code> elements more than once.
                  To make it streamable, it can be rewritten as:</p>
               <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:sequence&gt;
  &lt;xsl:on-non-empty&gt;
    &lt;h1&gt;Items for Sale&lt;/h1&gt;
  &lt;/xsl:on-non-empty&gt;  
  &lt;xsl:apply-templates select="item-for-sale"/&gt;
  &lt;xsl:on-non-empty&gt;
    &lt;p&gt;Total value: {accumulator-before('total-value')}&lt;/p&gt;
  &lt;/xsl:on-non-empty&gt;  
&lt;/xsl:sequence&gt;</eg>
               <p>The effect of the <elcode>xsl:on-non-empty</elcode> instruction, as explained
                  later, is to output the enclosed content only if the containing sequence
                  constructor also generates “ordinary” content, that is, if there is content
                  generated by instructions other than <elcode>xsl:on-empty</elcode> and
                     <elcode>xsl:on-non-empty</elcode> instructions.</p>
            </example>
            <example>
               <head>Generating Substitute Text when there is no Content</head>
               <p>The following example generates a summary paragraph only if a list of items is
                  empty. The code could be written like this:</p>
               <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:apply-templates select="item-for-sale"/&gt;
&lt;xsl:if test="empty(item-for-sale)"&gt;
  &lt;p&gt;There are no items for sale.&lt;/p&gt;
&lt;/xsl:if&gt;</eg>
               <p>However, the above code would not be <termref def="dt-guaranteed-streamable"/>,
                  because it processes the child <code>item-for-sale</code> elements more than once
                  (the fact that the list is empty is irrelevant, because streamability is
                  determined statically). To make the code streamable, it can be rewritten as:</p>
               <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:sequence&gt;
  &lt;xsl:apply-templates select="item-for-sale"/&gt;
  &lt;xsl:on-empty&gt;
    &lt;p&gt;There are no items for sale.&lt;/p&gt;
  &lt;/xsl:on-empty&gt;
&lt;/xsl:sequence&gt;</eg>
               <p>The effect of the <elcode>xsl:on-empty</elcode> instruction, as explained later,
                  is to output the enclosed content only if the containing sequence constructor
                  generates no “ordinary” content, that is, if there is no content generated by
                  instructions other than <elcode>xsl:on-empty</elcode> and
                     <elcode>xsl:on-non-empty</elcode> instructions.</p>
            </example>
            <note>
               <p>In some cases, similar effects can be achieved by using the
                     <xfunction>has-children</xfunction> function, which tests whether an element
                  has child nodes without consuming the children. However, use of
                     <xfunction>has-children</xfunction> has the drawback that the function is
                  unselective: it cannot be used to test whether there are any children of relevance
                  to the application. In particular, it returns true if an element contains comments
                  or whitespace text nodes that the application might consider to be
                  insignificant.</p>
            </note>
            <note>
               <p>There are no special streamability rules for the three instructions
                     <elcode>xsl:where-populated</elcode>, <elcode>xsl:on-empty</elcode>, or
                     <elcode>xsl:on-non-empty</elcode>. The <termref
                     def="dt-general-streamability-rules"/> apply. In many cases the
                     <elcode>xsl:on-empty</elcode> and <elcode>xsl:on-non-empty</elcode>
                  instructions will generate content that does not depend on the source document,
                  and they will therefore be <termref def="dt-motionless"/>, but this is not
                  required.</p>
            </note>
            <div3 id="where-populated">
               <head>The <code>xsl:where-populated</code> instruction</head>
               <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
                  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="where-populated">
                  <e:in-category name="instruction"/>
                  <e:model name="sequence-constructor"/>
                  <e:allowed-parents>
                     <e:parent-category name="sequence-constructor"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p>The <elcode>xsl:where-populated</elcode> instruction encloses a <termref
                     def="dt-sequence-constructor"/>. The result of the instruction is established
                  as follows:</p>
               <olist>
                  <item>
                     <p>The sequence constructor is evaluated in the usual way (taking into account
                        any <elcode>xsl:on-empty</elcode> and <elcode>xsl:on-non-empty</elcode>
                        instructions) to produce a result <var>$R</var>.</p>
                  </item>
                  <item>
                     <p>The result of the instruction is the value of the expression
                           <code>$R[not(deemed-empty(.))]</code> where the function
                           <code>deemed-empty($item as item())</code> returns true if and only if
                           <code>$item</code> is one of the following:</p>
                     <ulist>
                        <item>
                           <p>A document or element node that has no children.</p>
                           <note>
                              <p>If an element has attributes or namespaces, these do not prevent
                                 the element being deemed empty.</p>
                              <p>If a document or element node has children, the node is not deemed
                                 empty, even if the children are empty. For example, a document node
                                 created using an <elcode>xsl:variable</elcode> instruction in the
                                 form <code>&lt;xsl:variable
                                    name="temp"&gt;&lt;a/&gt;&lt;/xsl:variable&gt;</code> is not
                                 deemed empty, even though the contained &lt;a/&gt; element is
                                 empty.</p>
                           </note>
                        </item>
                        <item>
                           <p>A node, other than a document or element node, whose string value is
                              zero-length.</p>
                           <note>
                              <p>A whitespace-only text node is not deemed empty.</p>
                           </note>
                        </item>
                        <item>
                           <p>An atomic value such that the result of casting the atomic value to a
                              string is zero-length.</p>
                           <note>
                              <p>This can happen only when the atomic value is of type
                                    <code>xs:string</code>, <code>xs:anyURI</code>,
                                    <code>xs:untypedAtomic</code>, <code>xs:hexBinary</code>, or
                                    <code>xs:base64Binary</code>.</p>
                           </note>
                        </item>
                        <item>
                           <p diff="add" at="S-bug28989">A map whose size (number of key/value
                              pairs) is zero.</p>
                        </item>
                        <item>
                           <p diff="chg" at="T-bug29455">An array (see <specref ref="arrays"/>)
                              where the result of flattening the array using the <xfunction
                                 spec="FO31">array:flatten</xfunction> function is either an empty
                              sequence, or a sequence in which every item is deemed empty (applying
                              these rules recursively).</p>
                        </item>
                     </ulist>
                  </item>
               </olist>
               <example>
                  <head>Generating an HTML list</head>
                  <p>The following example generates an HTML unnumbered list, if and only if the
                     list is non-empty. Note that the presence of the <code>class</code> attribute
                     does not make the list non-empty. The code is written to be streamable.</p>
                  <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:where-populated&gt;
  &lt;ul class="my-list"&gt;
    &lt;xsl:for-each select="source-item"&gt;
       &lt;li&gt;&lt;xsl:value-of select="."/&gt;&lt;/li&gt;
    &lt;/xsl:for-each&gt;
  &lt;/ul&gt;
&lt;/xsl:where-populated&gt;</eg>
               </example>
            </div3>
            <div3 id="on-empty">
               <head>The <code>xsl:on-empty</code> instruction</head>
               <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
                  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="on-empty">
                  <e:in-category name="instruction"/>
                  <e:attribute name="select" required="no">
                     <e:data-type name="expression"/>
                  </e:attribute>
                  <e:model name="sequence-constructor"/>
                  <e:allowed-parents>
                     <e:parent-category name="sequence-constructor"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p>The <elcode>xsl:on-empty</elcode> instruction has the same content model as
                     <elcode>xsl:sequence</elcode>, and when it is evaluated, the same rules apply.
                  In particular, the <code>select</code> attribute and the contained sequence
                  constructor are mutually exclusive <errorref spec="XT" class="SE" code="3185"
                  />.</p>
               <p diff="add" at="S-bug28888">When an <elcode>xsl:on-empty</elcode> instruction
                  appears in a sequence constructor, then:</p>
               <olist diff="add" at="S-bug28888">
                  <item>
                     <p>It must be the only <elcode>xsl:on-empty</elcode> instruction in the
                        sequence constructor, and</p>
                  </item>
                  <item>
                     <p>It must not be followed in the sequence constructor by any other <termref
                           def="dt-instruction"/>, other than <elcode>xsl:fallback</elcode>, or by a
                        significant text node (that is, a text node that has not been discarded
                        under the provisions of <specref ref="stylesheet-stripping"/>), or by a
                           <termref def="dt-literal-result-element"/>. It may, however, be followed
                        by non-instructions such as <elcode>xsl:catch</elcode> where
                        appropriate.</p>
                  </item>
               </olist>
               <p diff="chg" at="T-bug29455"><termdef id="dt-vacuous" term="vacuous">An item is
                        <term>vacuous</term> if it is one of the following: a zero-length text node;
                     a document node with no children; an atomic value which, on casting to
                        <code>xs:string</code>, produces a zero-length string; or (when XPath 3.1 is
                     supported) an array which on flattening using the <xfunction spec="FO31"
                        >array:flatten</xfunction> function produces either an empty sequence or a
                     sequence consisting entirely of <termref def="dt-vacuous"/>
                  items.</termdef></p>
               <p diff="chg" at="T-bug29455">An <elcode>xsl:on-empty</elcode> instruction is
                  triggered only if every preceding sibling instruction, text node, and literal
                  result element in the same <termref def="dt-sequence-constructor"/> returns either
                  an empty sequence, or a sequence consisting entirely of <termref def="dt-vacuous"
                  /> items. </p>
               <p diff="chg" at="T-bug29455">If an <elcode>xsl:on-empty</elcode> instruction is
                  triggered, then the result of the containing <termref
                     def="dt-sequence-constructor"/> is the result of the
                     <elcode>xsl:on-empty</elcode> instruction. </p>
               <note diff="chg" at="T-bug29455">
                  <p>This means that the (vacuous) results produced by other instructions in the
                     sequence constructor are discarded. This is relevant mainly when the result of
                     the sequence constructor is used for something other than constructing a node:
                     for example if it forms the result of a function, or the value of a variable,
                     and the function or variable specifies a required type.</p>
                  <p>When streaming, it may be necessary to buffer vacuous items in the result
                     sequence until it is known whether the result will contain items that are
                     non-vacuous. In many common situations, however — in particular, when the
                     sequence constructor is being used to create the content of a node — vacuous
                     items can be discarded immediately because they do not affect the content of
                     the node being constructed. </p>
               </note>
               <note diff="chg" at="T-bug29455">
                  <p>In nearly all cases, the rules for <elcode>xsl:on-empty</elcode> are aligned
                     with the rules for constructing complex content. If the sequence constructor
                     within a literal result element or an <elcode>xsl:element</elcode> instruction
                     includes an <elcode>xsl:on-empty</elcode> instruction, then the content of the
                     element will be the value delivered by the <elcode>xsl:on-empty</elcode>
                     instruction if and only if the content would otherwise be empty.</p>
                  <p>There is one minor exception to this rule: if the sequence constructor delivers
                     multiple zero-length strings, then in the absence of the
                        <elcode>xsl:on-empty</elcode> instruction the new element would contain
                     whitespace, made up of the separators between these zero-length strings; but
                        <elcode>xsl:on-empty</elcode> takes no account of these separators.</p>
               </note>
               <note diff="chg" at="T-bug29455">
                  <p>Attribute and namespace nodes created by the sequence constructor are
                     significant; the <elcode>xsl:on-empty</elcode> instruction will not be
                     triggered if such nodes are present. If this is not the desired effect, it is
                     possible to partition the sequence constructor to change the scope of
                        <elcode>xsl:on-empty</elcode>, for example:</p>
                  <eg role="xslt-instruction" xml:space="preserve">&lt;ol&gt;
  &lt;xsl:attribute name="class" select="numbered-list"/&gt;
  &lt;xsl:sequence&gt;
    &lt;xsl:value-of select="xyz"/&gt;
    &lt;xsl:on-empty select="'The list is empty'"/&gt;
  &lt;/xsl:sequence&gt;
&lt;/ol&gt;</eg>
               </note>
               <note diff="chg" at="T-bug29455">
                  <p>Where the sequence constructor is a child of an instruction with an
                        <code>[xsl:]use-attribute-sets</code> attribute, any attribute nodes created
                     by expanding the referenced attribute set(s) are not part of the result of the
                     sequence constructor and therefore play no role in determining whether an
                        <elcode>xsl:on-empty</elcode> or <elcode>xsl:on-non-empty</elcode>
                     instruction is triggered. Equally, when the sequence constructor is a child of
                     a <termref def="dt-literal-result-element"/>, attribute nodes generated by
                     expanding the attributes of the literal result element are not taken into
                     account.</p>
               </note>
               <note diff="add" at="S-bug28888">
                  <p>If <elcode>xsl:on-empty</elcode> is the only instruction in a sequence
                     constructor then it is always evaluated.</p>
                  <p>If <elcode>xsl:on-empty</elcode> and <elcode>xsl:on-non-empty</elcode> appear
                     in the same sequence constructor, then the rules ensure that only one of them
                     will be evaluated.</p>
               </note>
            </div3>
            <div3 id="on-non-empty">
               <head>The <elcode>xsl:on-non-empty</elcode> instruction</head>
               <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
                  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="on-non-empty">
                  <e:in-category name="instruction"/>
                  <e:attribute name="select" required="no">
                     <e:data-type name="expression"/>
                  </e:attribute>
                  <e:model name="sequence-constructor"/>
                  <e:allowed-parents>
                     <e:parent-category name="sequence-constructor"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p>The <elcode>xsl:on-non-empty</elcode> instruction has the same content model as
                     <elcode>xsl:sequence</elcode>, and when it is evaluated, the same rules apply.
                  In particular, the <code>select</code> attribute and the contained sequence
                  constructor are mutually exclusive <errorref spec="XT" class="SE" code="3185"
                  />.</p>
               <p diff="chg" at="T-bug29455">An <elcode>xsl:on-non-empty</elcode> instruction is
                  evaluated only if there is at least one sibling node in the same <termref
                     def="dt-sequence-constructor"/>, excluding <elcode>xsl:on-empty</elcode> and
                     <elcode>xsl:on-non-empty</elcode> instructions, whose evaluation yields a
                  sequence containing an item that is not <termref def="dt-vacuous"/>. If this
                  condition applies, then all <elcode>xsl:on-non-empty</elcode> instructions in the
                  containing sequence constructor are evaluated, and their results are included in
                  the result of the containing sequence constructor in their proper positions. </p>
               <note diff="chg" at="T-bug29455">
                  <p>The <elcode>xsl:on-non-empty</elcode> instruction is typically used to generate
                     headers or footers appearing before or after a list of items, where the header
                     or footer is to be omitted if there are no items in the list. </p>
               </note>
               <note>
                  <p>Unlike <elcode>xsl:on-empty</elcode>, the <elcode>xsl:on-non-empty</elcode>
                     instruction can appear anywhere in a sequence constructor, and can appear more
                     than once.</p>
               </note>
            </div3>
            <div3 id="evaluating-on-empty">
               <head>Evaluating <elcode>xsl:on-empty</elcode> and <elcode>xsl:on-non-empty</elcode>
                  Instructions</head>
               <p>The following non-normative algorithm explains one possible strategy for streamed
                  evaluation of a <termref def="dt-sequence-constructor"/> containing
                     <elcode>xsl:on-empty</elcode> and/or <elcode>xsl:on-non-empty</elcode>
                  instructions.</p>
               <p>The algorithm makes use of the following mutable variables:</p>
               <ulist>
                  <item>
                     <p><var>L</var> : a list of instructions awaiting evaluation. Initially
                        empty.</p>
                  </item>
                  <item>
                     <p><var>R</var> : a list of items to act as the result of the evaluation.
                        Initially empty.</p>
                  </item>
                  <item>
                     <p><var>F</var> : a boolean flag, initially false, to indicate whether any
                           <termref def="dt-vacuous">non-vacuous</termref> items have been written
                        to <var>R</var> by <term>ordinary instructions</term>. The term
                           <term>ordinary instruction</term> means any node in the sequence
                        constructor other than an <elcode>xsl:on-empty</elcode> or
                           <elcode>xsl:on-non-empty</elcode> instruction.</p>
                  </item>
               </ulist>
               <p>The algorithm is as follows:</p>
               <olist diff="chg" at="S-bug28888">
                  <item>
                     <p>The nodes in the sequence constructor are evaluated in document order.</p>
                  </item>
                  <item>
                     <p>When an <elcode>xsl:on-non-empty</elcode> instruction is encountered,
                        then:</p>
                     <olist>
                        <item>
                           <p>If <var>F</var> is true, the instruction is evaluated and the result
                              is appended to <var>R</var>.</p>
                        </item>
                        <item>
                           <p>Otherwise, the instruction is appended to <var>L</var>.</p>
                        </item>
                     </olist>
                  </item>
                  <item>
                     <p>When an <term>ordinary instruction</term> is evaluated:</p>
                     <olist>
                        <item>
                           <p>The results of the evaluation are appended to <var>R</var>, in
                              order.</p>
                        </item>
                        <item>
                           <p>When a <termref def="dt-vacuous">non-vacuous</termref> item is about
                              to be appended to <var>R</var>, and <var>F</var> is false, then before
                              appending the item to <var>R</var>, the following actions are
                              taken:</p>
                           <olist>
                              <item>
                                 <p>Any <elcode>xsl:on-non-empty</elcode> instructions in
                                       <var>L</var> are evaluated, in order, and their results are
                                    appended to <var>R</var>.</p>
                              </item>
                              <item>
                                 <p><var>F</var> is set to true.</p>
                              </item>
                           </olist>
                        </item>
                     </olist>
                  </item>
                  <item>
                     <p>When an <elcode>xsl:on-empty</elcode> instruction is encountered, then:</p>
                     <olist>
                        <item>
                           <p>If <var>F</var> is true, the instruction is ignored.</p>
                        </item>
                        <item>
                           <p diff="chg" at="T-bug29455">Otherwise, the existing contents of
                                 <var>R</var> are discarded, the instruction is evaluated, and its
                              results are appended to <var>R</var>.</p>
                           <note diff="add" at="T-bug29455">
                              <p>The need to discard items from <var>R</var> arises only when all
                                 the items in <var>R</var> are <termref def="dt-vacuous"/>.
                                 Streaming implementations may therefore need a limited amount of
                                 buffering to retain insignificant items until it is known whether
                                 they will be needed. However, in many common cases an optimized
                                 implementation will be able to discard <termref def="dt-vacuous"/>
                                 items such as empty text nodes immediately, because when a node is
                                 being constructed using the rules in <specref
                                    ref="constructing-complex-content"/> or <specref
                                    ref="constructing-simple-content"/>, such items have no effect
                                 on the final outcome.</p>
                           </note>
                           <p>Otherwise, the instruction is evaluated and its results are appended
                              to <var>R</var>.</p>
                        </item>
                     </olist>
                  </item>
                  <item>
                     <p>The result of the sequence constructor is the list of items in
                        <var>R</var>.</p>
                  </item>
               </olist>
            </div3>
            <div3 id="where-populated-example">
               <head>A More Complex Example</head>
               <p>This example shows how the three instructions
                  <elcode>xsl:where-populated</elcode>, <elcode>xsl:on-empty</elcode>, and
                     <elcode>xsl:on-non-empty</elcode> may be combined.</p>
               <example>
                  <head>Generating a Table only if there is Content</head>
                  <p>The following example generates a table containing the names and ages of a set
                     of students; if there are no students, it substitutes a paragraph explaining
                     this.</p>
                  <eg role="xslt-fragment" xml:space="preserve">&lt;div id="students"&gt;
&lt;xsl:where-populated&gt;
   &lt;table&gt;
      &lt;xsl:on-non-empty&gt;
         &lt;thead&gt;
            &lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Age&lt;/th&gt;&lt;/tr&gt;
         &lt;/thead&gt;
      &lt;/xsl:on-non-empty&gt;
      &lt;xsl:where-populated&gt;
         &lt;tbody&gt;
            &lt;xsl:for-each select="student/copy-of()"&gt;
               &lt;tr&gt;
                  &lt;td&gt;&lt;xsl:value-of select="name"/&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;xsl:value-of select="age"/&gt;&lt;/td&gt;
               &lt;/tr&gt;
            &lt;/xsl:for-each&gt;
         &lt;/tbody&gt;
      &lt;/xsl:where-populated&gt;
   &lt;/table&gt;
&lt;/xsl:where-populated&gt;
&lt;xsl:on-empty&gt;
   &lt;p&gt;There are no students&lt;/p&gt;
&lt;/xsl:on-empty&gt;
&lt;/div&gt;</eg>
                  <p>Explanation:</p>
                  <ulist>
                     <item>
                        <p>The <elcode>xsl:where-populated</elcode> around the <code>table</code>
                           element ensures that if there is no <code>thead</code> and no
                              <code>tbody</code>, then there will be no <code>table</code>. </p>
                     </item>
                     <item>
                        <p>The <elcode>xsl:on-non-empty</elcode> surrounding the <code>thead</code>
                           element ensures that the <code>thead</code> element is not output unless
                           the <code>tbody</code> element is output. </p>
                     </item>
                     <item>
                        <p>The <elcode>xsl:where-populated</elcode> around the <code>tbody</code>
                           element ensures that the <code>tbody</code> element is not output unless
                           there is at least one table row (<code>tr</code>). </p>
                     </item>
                     <item>
                        <p>The <elcode>xsl:on-empty</elcode> around the <code>p</code> element
                           ensures that if no <code>table</code> is output, then the paragraph
                              <code>There are no students</code> is output instead. </p>
                     </item>
                  </ulist>
               </example>
            </div3>
         </div2>
      </div1>
      <div1 id="variables-and-parameters">
         <head>Variables and Parameters</head>
         <p>
            <termdef id="dt-variable-binding-element" term="variable-binding element">The two
               elements <elcode>xsl:variable</elcode> and <elcode>xsl:param</elcode> are referred to
               as <term>variable-binding elements</term>.</termdef></p>
         <p>
            <termdef id="dt-variable" term="variable">The <elcode>xsl:variable</elcode> element
               declares a <term>variable</term>, which may be a <termref def="dt-global-variable"
                  >global variable</termref> or a <termref def="dt-local-variable">local
                  variable</termref>.</termdef>
         </p>
         <p>
            <termdef id="dt-parameter" term="parameter">The <elcode>xsl:param</elcode> element
               declares a <term>parameter</term>, which may be a <termref
                  def="dt-stylesheet-parameter">stylesheet parameter</termref>, a <termref
                  def="dt-template-parameter">template parameter</termref>, a <termref
                  def="dt-function-parameter">function parameter</termref><phrase diff="add" at="D"
                  >, or an <elcode>xsl:iterate</elcode> parameter</phrase>. A parameter is a
                  <termref def="dt-variable">variable</termref> with the additional property that
               its value can be set by the caller.</termdef>
         </p>
         <p>
            <termdef id="dt-value" term="value">A variable is a binding between a name and a value.
               The <term>value</term> of a variable is any sequence (of nodes, atomic values,
                  <phrase diff="add" at="C">and/or function items</phrase>), as defined in <bibref
                  ref="xpath-datamodel-30"/>.</termdef>
         </p>
         <div2 id="variables">
            <head>Variables</head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="variable">
               <e:in-category name="declaration"/>
               <e:in-category name="instruction"/>
               <e:attribute name="name" required="yes">
                  <e:data-type name="eqname"/>
               </e:attribute>
               <e:attribute name="select">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="as">
                  <e:data-type name="sequence-type"/>
               </e:attribute>
               <e:attribute name="static">
                  <e:data-type name="boolean"/>
               </e:attribute>
               <e:attribute name="visibility">
                  <e:constant value="public"/>
                  <e:constant value="private"/>
                  <e:constant value="final"/>
                  <e:constant value="abstract"/>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent name="package"/>
                  <e:parent name="stylesheet"/>
                  <e:parent name="transform"/>
                  <e:parent name="override"/>
                  <e:parent name="function"/>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:variable</elcode> element has a <rfc2119>required</rfc2119>
               <code>name</code> attribute, which specifies the name of the variable. The value of
               the <code>name</code> attribute is an <phrase diff="chg" at="K"><termref
                     def="dt-eqname">EQName</termref></phrase>, which is expanded as described in
                  <specref ref="qname"/>.</p>
            <p>The <elcode>xsl:variable</elcode> element has an optional <code>as</code> attribute,
               which specifies the <termref def="dt-required-type">required type</termref> of the
               variable. The value of the <code>as</code> attribute is a <phrase diff="chg"
                  at="S-bug29079"><termref def="dt-sequence-type"/></phrase>.</p>
            <p>
               <termdef id="dt-supplied-value" term="supplied value">The value of the variable is
                  computed using the <termref def="dt-expression">expression</termref> given in the
                     <code>select</code> attribute or the contained <termref
                     def="dt-sequence-constructor">sequence constructor</termref>, as described in
                     <specref ref="variable-values"/>. This value is referred to as the
                     <term>supplied value</term> of the variable.</termdef> If the
                  <elcode>xsl:variable</elcode> element has a <code>select</code> attribute, then
               the sequence constructor <rfc2119>must</rfc2119> be empty.</p>
            <p>If the <code>as</code> attribute is specified, then the <termref
                  def="dt-supplied-value">supplied value</termref> of the variable is converted to
               the required type, using the <termref def="dt-function-conversion-rules">function
                  conversion rules</termref>.</p>
            <p>
               <error spec="XT" type="type" class="TE" code="0570"><p>It is a <termref
                        def="dt-type-error">type error</termref> if the <termref
                        def="dt-supplied-value">supplied value</termref> of a variable cannot be
                     converted to the required type.</p></error>
            </p>
            <p>If the <code>as</code> attribute is omitted, the <termref def="dt-supplied-value"
                  >supplied value</termref> of the variable is used directly, and no conversion
               takes place.</p>
            <p diff="add" at="M">For the effect of the <code>static</code> attribute, see <specref
                  ref="static-params"/>.</p>
            <p diff="add" at="I">The <code>visibility</code> attribute <rfc2119>must not</rfc2119>
               be specified for a <termref def="dt-local-variable"/>: that is, it is allowed only
               when the parent element is <elcode>xsl:stylesheet</elcode>,
                  <elcode>xsl:transform</elcode>, <phrase diff="add" at="V-bug30094"
                     ><elcode>xsl:package</elcode></phrase> or <elcode>xsl:override</elcode>.</p>
            <p diff="add" at="I">If the <code>visibility</code> attribute is present with the value
                  <code>abstract</code> then the <code>select</code> attribute
                  <rfc2119>must</rfc2119> be absent and the contained <termref
                  def="dt-sequence-constructor"/>
               <rfc2119>must</rfc2119> be empty. In this situation there is no <termref
                  def="dt-supplied-value">supplied value</termref>, and therefore the constraint
               that the supplied value is consistent with the required type does not apply.</p>
         </div2>
         <div2 id="parameters" diff="chg" at="R-bug25158">
            <head>Parameters</head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="param">
               <e:in-category name="declaration"/>
               <e:attribute name="name" required="yes">
                  <e:data-type name="eqname"/>
               </e:attribute>
               <e:attribute name="select">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="as">
                  <e:data-type name="sequence-type"/>
               </e:attribute>
               <e:attribute name="required">
                  <e:data-type name="boolean"/>
               </e:attribute>
               <e:attribute name="tunnel">
                  <e:data-type name="boolean"/>
               </e:attribute>
               <e:attribute name="static">
                  <e:data-type name="boolean"/>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent name="package"/>
                  <e:parent name="stylesheet"/>
                  <e:parent name="transform"/>
                  <e:parent name="override"/>
                  <e:parent name="function"/>
                  <e:parent name="template"/>
                  <e:parent name="iterate"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:param</elcode> element may be used:</p>
            <ulist>
               <item>
                  <p>As a child of <elcode>xsl:stylesheet</elcode>
                     <phrase diff="add" at="S-bug28525">or <elcode>xsl:package</elcode></phrase>, to
                     define a parameter to the transformation. <termref
                        def="dt-stylesheet-parameter">Stylesheet parameters</termref> are set by the
                     calling application: see <specref ref="priming-stylesheet"/>. </p>
               </item>
               <item>
                  <p>As a child of <elcode>xsl:template</elcode> to define a parameter to a
                     template, which may be supplied when the template is invoked using
                        <elcode>xsl:call-template</elcode>, <elcode>xsl:apply-templates</elcode>,
                        <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode>.
                        <termref def="dt-template-parameter">Template parameters</termref> are set
                     by means of an <elcode>xsl:with-param</elcode> child element of the invoking
                     instruction, as described in <specref ref="with-param"/>.</p>
               </item>
               <item>
                  <p>As a child of <elcode>xsl:function</elcode> to define a parameter to a
                     stylesheet function, which may be supplied when the function is called from an
                     XPath <termref def="dt-expression">expression</termref>. <termref
                        def="dt-function-parameter">Function parameters</termref> are set
                     positionally by means of the argument list in an XPath function call. </p>
               </item>
               <item diff="add" at="A">
                  <p>As a child of <elcode>xsl:iterate</elcode> to define a parameter that can vary
                     from one iteration to the next. Iteration parameters always take their default
                     values for the first iteration, and in subsequent iterations are set using an
                        <elcode>xsl:with-param</elcode> child of the
                        <elcode>xsl:next-iteration</elcode> instruction.</p>
               </item>
            </ulist>
            <p diff="add" at="S-bug28565">The attributes applicable to <elcode>xsl:param</elcode>
               depend on its parent element in the stylesheet, as defined by the following
               table:</p>
            <table class="data">
               <caption>Attributes of the <code>xsl:param</code> Element</caption>
               <thead>
                  <tr>
                     <th rowspan="1" colspan="1">Parent Element</th>
                     <th rowspan="1" colspan="1">name</th>
                     <th rowspan="1" colspan="1">select</th>
                     <th rowspan="1" colspan="1">as</th>
                     <th rowspan="1" colspan="1">required</th>
                     <th rowspan="1" colspan="1">tunnel</th>
                     <th rowspan="1" colspan="1">static</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <th rowspan="1" colspan="1"><elcode>xsl:package</elcode></th>
                     <td rowspan="1" colspan="1">mandatory</td>
                     <td rowspan="1" colspan="1">optional</td>
                     <td rowspan="1" colspan="1">optional</td>
                     <td rowspan="1" colspan="1">yes|<term>no</term></td>
                     <td rowspan="1" colspan="1"><term>no</term></td>
                     <td rowspan="1" colspan="1">yes|<term>no</term></td>
                  </tr>
                  <tr>
                     <th rowspan="1" colspan="1"><elcode>xsl:stylesheet</elcode></th>
                     <td rowspan="1" colspan="1">mandatory</td>
                     <td rowspan="1" colspan="1">optional</td>
                     <td rowspan="1" colspan="1">optional</td>
                     <td rowspan="1" colspan="1">yes|<term>no</term></td>
                     <td rowspan="1" colspan="1"><term>no</term></td>
                     <td rowspan="1" colspan="1">yes|<term>no</term></td>
                  </tr>
                  <tr>
                     <th rowspan="1" colspan="1"><elcode>xsl:template</elcode></th>
                     <td rowspan="1" colspan="1">mandatory</td>
                     <td rowspan="1" colspan="1">optional</td>
                     <td rowspan="1" colspan="1">optional</td>
                     <td rowspan="1" colspan="1">yes|<term>no</term></td>
                     <td rowspan="1" colspan="1">yes|<term>no</term></td>
                     <td rowspan="1" colspan="1"><term>no</term></td>
                  </tr>
                  <tr>
                     <th rowspan="1" colspan="1"><elcode>xsl:function</elcode></th>
                     <td rowspan="1" colspan="1">mandatory</td>
                     <td rowspan="1" colspan="1">disallowed</td>
                     <td rowspan="1" colspan="1">optional</td>
                     <td rowspan="1" colspan="1"><term>yes</term></td>
                     <td rowspan="1" colspan="1"><term>no</term></td>
                     <td rowspan="1" colspan="1"><term>no</term></td>
                  </tr>
                  <tr>
                     <th rowspan="1" colspan="1"><elcode>xsl:iterate</elcode></th>
                     <td rowspan="1" colspan="1">mandatory</td>
                     <td rowspan="1" colspan="1">mandatory</td>
                     <td rowspan="1" colspan="1">optional</td>
                     <td rowspan="1" colspan="1"><term>no</term></td>
                     <td rowspan="1" colspan="1"><term>no</term></td>
                     <td rowspan="1" colspan="1"><term>no</term></td>
                  </tr>
               </tbody>
            </table>
            <p diff="add" at="S-bug28525">In the table, the entries for the <code>name</code>,
                  <code>select</code>, and <code>as</code> attributes indicate whether the attribute
               must appear, is optional, or must be absent; the entries for the
                  <code>required</code>, <code>tunnel</code>, and <code>static</code> attributes
               indicate the values that are permitted if the attribute is present, with the default
               value shown in bold. (The value <code>yes</code> can also be written
                  <code>true</code> or <code>1</code>, while <code>no</code> can also be written
                  <code>false</code> or <code>0</code>.)</p>
            <p>The <code>name</code> attribute is mandatory: it specifies the name of the parameter.
               The value of the <code>name</code> attribute is an <phrase diff="chg" at="K"><termref
                     def="dt-eqname">EQName</termref></phrase>, which is expanded as described in
                  <specref ref="qname"/>.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0580"><p>It is a <termref
                        def="dt-static-error">static error</termref> if the values of the
                        <code>name</code> attribute of two <phrase diff="chg" at="A">sibling
                           <elcode>xsl:param</elcode> elements represent the same <termref
                           def="dt-expanded-qname">expanded QName</termref></phrase>.</p></error>
            </p>
            <p>If the <elcode>xsl:param</elcode> element has a <code>select</code> attribute, then
               the sequence constructor <rfc2119>must</rfc2119> be empty.</p>
            <p diff="chg" at="R-bug26740">The <code>static</code> attribute <phrase diff="add"
                  at="S-bug28525">can take the value <code>yes</code></phrase> only on <termref
                  def="dt-stylesheet-parameter">stylesheet parameters</termref>, and is explained in
                  <specref ref="global-variables"/>.</p>
            <note>
               <p>Local variables may <termref def="dt-shadows">shadow</termref> template parameters
                  and function parameters: see <specref ref="scope-of-variables"/>.</p>
            </note>
            <p>The optional <code>tunnel</code> attribute may be used to indicate that a parameter
               is a <termref def="dt-tunnel-parameter">tunnel parameter</termref>. The default is
                  <code>no</code>; the value <code>yes</code> may be specified only for <termref
                  def="dt-template-parameter">template parameters</termref>. Tunnel parameters are
               described in <specref ref="tunnel-params"/>
            </p>
            <div3 id="parameter-type">
               <head>The Required Type of a Parameter</head>
               <p>The <elcode>xsl:param</elcode> element has an optional <code>as</code> attribute,
                  which specifies the <termref def="dt-required-type"/> of the parameter. The value
                  of the <code>as</code> attribute is a <phrase diff="chg" at="S-bug29079"><termref
                        def="dt-sequence-type"/></phrase>. If the <code>as</code> attribute is
                  omitted, then the required type is <code>item()*</code>.</p>
               <p>The <termref def="dt-supplied-value">supplied value</termref> of the parameter is
                  the value supplied by the caller. If no value was supplied by the caller, and if
                  the parameter is not mandatory, then the default value is used as the supplied
                  value as described in <specref ref="default-values-of-parameters"/>.</p>
               <p>The <termref def="dt-supplied-value">supplied value</termref> of the parameter is
                  converted to the <termref def="dt-required-type"/> using the <termref
                     def="dt-function-conversion-rules"/>.</p>
               <p>
                  <error spec="XT" type="type" class="TE" code="0590"><p>It is a <termref
                           def="dt-type-error">type error</termref> if the conversion of the
                           <termref def="dt-supplied-value">supplied value</termref> of a parameter
                        to its <termref def="dt-required-type"/> fails.</p></error>
               </p>
            </div3>
            <div3 id="default-values-of-parameters">
               <head>Default Values of Parameters</head>
               <p diff="chg" at="S-bug28525">The optional <code>required</code> attribute of
                     <elcode>xsl:param</elcode> may be used to indicate that a <termref
                     def="dt-stylesheet-parameter"/> or <termref def="dt-template-parameter"/> is
                  mandatory. The only value permitted for a <termref def="dt-function-parameter"/>
                  is <code>yes</code> (these are always mandatory), and the only value permitted for
                  a parameter to <elcode>xsl:iterate</elcode> is <code>no</code> (these are always
                  initialized to a default value).</p>
               <p><termdef id="dt-explicitly-mandatory" term="explicitly mandatory">A parameter is
                        <term>explicitly mandatory</term> if it is a <termref
                        def="dt-function-parameter">function parameter</termref>, or if the
                        <code>required</code> attribute is present and has the value
                        <code>yes</code>.</termdef> If a parameter is explicitly mandatory, then the
                     <elcode>xsl:param</elcode> element <rfc2119>must</rfc2119> be empty and
                     <rfc2119>must not</rfc2119> have a <code>select</code> attribute.</p>
               <p>If a parameter is not <termref def="dt-explicitly-mandatory"/>, then it may have a
                  default value. The default value is obtained by evaluating the <termref
                     def="dt-expression">expression</termref> given in the <code>select</code>
                  attribute or the contained <termref def="dt-sequence-constructor">sequence
                     constructor</termref>, as described in <specref ref="variable-values"/>.</p>
               <note>
                  <p>This specification does not dictate whether and when the default value of a
                     parameter is evaluated. For example, if the default is specified as
                        <code>&lt;xsl:param name="p"&gt;&lt;foo/&gt;&lt;/xsl:param&gt;</code>, then
                     it is not specified whether a distinct <code>foo</code> element node will be
                     created on each invocation of the template, or whether the same
                        <code>foo</code> element node will be used for each invocation. However, it
                     is permissible for the default value to depend on the values of other
                     parameters, or on the evaluation context, in which case the default must
                     effectively be evaluated on each invocation.</p>
               </note>
               <p><termdef id="dt-explicit-default" term="explicit default">An <term>explicit
                        default</term> for a parameter is indicated by the presence of either a
                        <code>select</code> attribute or a non-empty sequence
                  constructor.</termdef></p>
               <p><termdef id="dt-implicit-default" term="implicit default">If a parameter that is
                     not <termref def="dt-explicitly-mandatory"/> has no <termref
                        def="dt-explicit-default"/> value, then it has an <term>implicit
                        default</term> value, which is the empty sequence if there is an
                        <code>as</code> attribute, or a zero-length string if not.</termdef></p>
               <p><termdef id="dt-implicitly-mandatory" term="implicitly mandatory">If a parameter
                     has an <termref def="dt-implicit-default"/> value which cannot be converted to
                     the <termref def="dt-required-type"/> (that is, if it has an <code>as</code>
                     attribute which does not permit the empty sequence), then the parameter is
                        <term>implicitly mandatory</term>.</termdef></p>
               <note>
                  <p>The effect of these rules is that specifying <code>&lt;xsl:param name="p"
                        as="xs:date" select="2"/&gt;</code> is an error, but if the default value of
                     the parameter is never used, then the processor has discretion whether or not
                     to report the error. By contrast, <code>&lt;xsl:param name="p"
                        as="xs:date"/&gt;</code> is treated as if <code>required="yes"</code> had
                     been specified: the empty sequence is not a valid instance of
                        <code>xs:date</code>, so in effect there is no default value and the
                     parameter is therefore treated as being mandatory.</p>
               </note>
               <p>Various errors can arise with regard to mandatory parameters when no value is
                  supplied. In the rules below, <term>non-tunnel</term> means: not having a
                     <code>tunnel</code> attribute with the value <code>yes</code>.</p>
               <ulist>
                  <item>
                     <p>
                        <error spec="XT" type="static" class="SE" code="3520"><p>It is a static
                              error if a parameter to <elcode>xsl:iterate</elcode> is <termref
                                 def="dt-implicitly-mandatory"/>.</p></error>
                     </p>
                  </item>
                  <item>
                     <p>
                        <error spec="XT" type="static" class="SE" code="0690"><p>It is a <termref
                                 def="dt-static-error">static error</termref> if a <termref
                                 def="dt-package">package</termref> contains both (a) a named
                              template named <var>T</var> that is not overridden by another named
                              template of higher import precedence and that has an <termref
                                 def="dt-explicitly-mandatory"/> non-tunnel parameter named
                                 <var>P</var>, and (b) an <elcode>xsl:call-template</elcode>
                              instruction whose <code>name</code> attribute equals <var>T</var> and
                              that has no non-tunnel <elcode>xsl:with-param</elcode> child element
                              whose <code>name</code> attribute equals <var>P</var>. (All names are
                              compared as QNames.)</p></error>
                     </p>
                  </item>
                  <item>
                     <p>
                        <error spec="XT" type="dynamic" class="DE" code="0700"><p>It is a <termref
                                 def="dt-dynamic-error"><phrase diff="del" at="M"
                                    >non-recoverable</phrase> dynamic error</termref> if a template
                              that has an <termref def="dt-explicitly-mandatory"/> or <termref
                                 def="dt-implicitly-mandatory"/> parameter is invoked without
                              supplying a value for that parameter.</p></error>
                     </p>
                     <p>This includes the following cases:</p>
                     <ulist>
                        <item>
                           <p>The template is invoked using <elcode>xsl:apply-templates</elcode>,
                                 <elcode>xsl:apply-imports</elcode>, or
                                 <elcode>xsl:next-match</elcode> and there is no
                                 <elcode>xsl:with-param</elcode> child whose <code>name</code> and
                                 <code>tunnel</code> attributes match the corresponding attributes
                              of the mandatory parameter.</p>
                        </item>
                        <item>
                           <p>The mandatory parameter is a tunnel parameter, and the template is
                              invoked using <elcode>xsl:call-template</elcode>, and there is no
                                 <elcode>xsl:with-param</elcode> child whose <code>name</code> and
                                 <code>tunnel</code> attributes match the corresponding attributes
                              of the mandatory parameter.</p>
                        </item>
                        <item>
                           <p>The template is invoked as the entry point to the transformation,
                              either by invoking an initial mode (<specref
                                 ref="invoking-initial-mode"/>) or by invoking an initial template
                                 (<specref ref="invoking-initial-template"/>) and no value is
                              supplied for the mandatory parameter by the calling application.</p>
                        </item>
                     </ulist>
                  </item>
               </ulist>
            </div3>
         </div2>
         <div2 id="variable-values">
            <head>Values of Variables and Parameters</head>
            <p>A <termref def="dt-variable-binding-element">variable-binding element</termref> may
               specify the <termref def="dt-supplied-value">supplied value</termref> of a <termref
                  def="dt-variable">variable</termref>
               <phrase diff="add" at="D">or the default value of a</phrase>
               <termref def="dt-parameter">parameter</termref> in four different ways.</p>
            <ulist>
               <item>
                  <p>If the <termref def="dt-variable-binding-element">variable-binding
                        element</termref> has a <code>select</code> attribute, then the value of the
                     attribute <rfc2119>must</rfc2119> be an <termref def="dt-expression"
                        >expression</termref> and the <termref def="dt-supplied-value">supplied
                        value</termref> of the variable is the value that results from evaluating
                     the expression. In this case, the content of the variable-binding element
                        <rfc2119>must</rfc2119> be empty.</p>
               </item>
               <item>
                  <p>If the <termref def="dt-variable-binding-element">variable-binding
                        element</termref> has empty content and has neither a <code>select</code>
                     attribute nor an <code>as</code> attribute, then the <termref
                        def="dt-supplied-value">supplied value</termref> of the variable is a
                     zero-length string. Thus</p>
                  <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:variable name="x"/&gt;</eg>
                  <p>is equivalent to</p>
                  <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:variable name="x" select="''"/&gt;</eg>
               </item>
               <item>
                  <p>If a <termref def="dt-variable-binding-element">variable-binding
                        element</termref> has no <code>select</code> attribute and has non-empty
                     content (that is, the variable-binding element has one or more child nodes),
                     and has no <code>as</code> attribute, then the content of the variable-binding
                     element specifies the <termref def="dt-supplied-value">supplied
                     value</termref>. The content of the variable-binding element is a <termref
                        def="dt-sequence-constructor">sequence constructor</termref>; a new document
                     is constructed with a document node having as its children the sequence of
                     nodes that results from evaluating the sequence constructor and then applying
                     the rules given in <specref ref="constructing-complex-content"/>. The value of
                     the variable is then a singleton sequence containing this document node. For
                     further information, see <specref ref="temporary-trees"/>. </p>
               </item>
               <item>
                  <p>If a <termref def="dt-variable-binding-element">variable-binding
                        element</termref> has an <code>as</code> attribute but no
                        <code>select</code> attribute, then the <termref def="dt-supplied-value"
                        >supplied value</termref> is the sequence that results from evaluating the
                     (possibly empty) <termref def="dt-sequence-constructor">sequence
                        constructor</termref> contained within the variable-binding element (see
                        <specref ref="sequence-constructors"/>). </p>
               </item>
            </ulist>
            <p>These combinations are summarized in the table below.</p>
            <table class="data">
               <caption>Effect of Different Attribute Combinations on
                  <code>xsl:variable</code></caption>
               <col width="12%" span="1"/>
               <col width="12%" span="1"/>
               <col width="12%" span="1"/>
               <col span="1"/>
               <thead>
                  <tr>
                     <th align="left" rowspan="1" colspan="1">select attribute</th>
                     <th align="left" rowspan="1" colspan="1">as attribute</th>
                     <th align="left" rowspan="1" colspan="1">content</th>
                     <th align="left" rowspan="1" colspan="1">Effect</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td rowspan="1" colspan="1">present</td>
                     <td rowspan="1" colspan="1">absent</td>
                     <td rowspan="1" colspan="1">empty</td>
                     <td rowspan="1" colspan="1">Value is obtained by evaluating the
                           <code>select</code> attribute</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">present</td>
                     <td rowspan="1" colspan="1">present</td>
                     <td rowspan="1" colspan="1">empty</td>
                     <td rowspan="1" colspan="1">Value is obtained by evaluating the
                           <code>select</code> attribute, adjusted to the type required by the
                           <code>as</code> attribute</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">present</td>
                     <td rowspan="1" colspan="1">absent</td>
                     <td rowspan="1" colspan="1">present</td>
                     <td rowspan="1" colspan="1">Static error</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">present</td>
                     <td rowspan="1" colspan="1">present</td>
                     <td rowspan="1" colspan="1">present</td>
                     <td rowspan="1" colspan="1">Static error</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">absent</td>
                     <td rowspan="1" colspan="1">absent</td>
                     <td rowspan="1" colspan="1">empty</td>
                     <td rowspan="1" colspan="1">Value is a zero-length string</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">absent</td>
                     <td rowspan="1" colspan="1">present</td>
                     <td rowspan="1" colspan="1">empty</td>
                     <td rowspan="1" colspan="1">Value is an empty sequence, provided the
                           <code>as</code> attribute permits an empty sequence</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">absent</td>
                     <td rowspan="1" colspan="1">absent</td>
                     <td rowspan="1" colspan="1">present</td>
                     <td rowspan="1" colspan="1">Value is a document node whose content is obtained
                        by evaluating the sequence constructor</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">absent</td>
                     <td rowspan="1" colspan="1">present</td>
                     <td rowspan="1" colspan="1">present</td>
                     <td rowspan="1" colspan="1">Value is obtained by evaluating the sequence
                        constructor, adjusted to the type required by the <code>as</code>
                        attribute</td>
                  </tr>
               </tbody>
            </table>
            <p>
               <error spec="XT" type="static" class="SE" code="0620"><p>It is a <termref
                        def="dt-static-error">static error</termref> if a <termref
                        def="dt-variable-binding-element">variable-binding element</termref> has a
                        <code>select</code> attribute and has non-empty content.</p></error>
            </p>
            <example>
               <head>Values of Variables</head>
               <p>The value of the following variable is the sequence of integers (1, 2, 3):</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:variable name="i" as="xs:integer*" select="1 to 3"/&gt;</eg>
               <p>The value of the following variable is an integer, assuming that the attribute
                     <code>@size</code> exists, and is annotated either as an integer, or as
                     <code>xs:untypedAtomic</code>:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:variable name="i" as="xs:integer" select="@size"/&gt;</eg>
               <p>The value of the following variable is a zero-length string:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:variable name="z"/&gt;</eg>
               <p>The value of the following variable is a document node containing an empty element
                  as a child:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:variable name="doc"&gt;&lt;c/&gt;&lt;/xsl:variable&gt;</eg>
               <p>The value of the following variable is a sequence of integers (2, 4, 6):</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:variable name="seq" as="xs:integer*"&gt;
  &lt;xsl:for-each select="1 to 3"&gt;
    &lt;xsl:sequence select=".*2"/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:variable&gt;</eg>
               <p>The value of the following variable is a sequence of parentless attribute
                  nodes:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:variable name="attset" as="attribute()+"&gt;
  &lt;xsl:attribute name="x"&gt;2&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="y"&gt;3&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="z"&gt;4&lt;/xsl:attribute&gt;    
&lt;/xsl:variable&gt;</eg>
               <p>The value of the following variable is an empty sequence:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:variable name="empty" as="empty-sequence()"/&gt;</eg>
            </example>
            <p>The actual value of the variable depends on the <termref def="dt-supplied-value"
                  >supplied value</termref>, as described above, and the required type, which is
               determined by the value of the <code>as</code> attribute.</p>
            <example>
               <head>Pitfalls with Numeric Predicates</head>
               <p>When a variable is used to select nodes by position, be careful not to do:</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:variable name="n"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;</eg>
               <p>This will output the values of all the <code>td</code> elements, space-separated
                  (or <phrase diff="chg" at="D">with <termref def="dt-xslt-10-behavior">XSLT 1.0
                        behavior</termref></phrase>, the value of the first <code>td</code>
                  element), because the variable <code>n</code> will be bound to a node, not a
                  number. Instead, do one of the following:</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:variable name="n" select="2"/&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;</eg>
               <p>or</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:variable name="n"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[position()=$n]"/&gt;</eg>
               <p>or</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:variable name="n" as="xs:integer"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;</eg>
            </example>
         </div2>
         <div2 id="temporary-trees">
            <head>Creating Implicit Document Nodes</head>
            <p>A document node is created implicitly when evaluating an
                  <elcode>xsl:variable</elcode>, <elcode>xsl:param</elcode>, or
                  <elcode>xsl:with-param</elcode> element that has non-empty content and that has no
                  <code>as</code> attribute. The value of the <termref def="dt-variable"
                  >variable</termref> is <phrase diff="add" at="S-bug27258">this newly constructed
                  document node.</phrase>
               <phrase diff="del" at="S-bug27258">a single node, the document node of a <termref
                     def="dt-temporary-tree">temporary tree</termref>.</phrase> The content of the
               document node is formed from the result of evaluating the <termref
                  def="dt-sequence-constructor">sequence constructor</termref> contained within the
               variable-binding element, as described in <specref ref="constructing-complex-content"
               />. </p>
            <note>
               <p>The construct:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:variable name="tree"&gt;
  &lt;a/&gt;
&lt;/xsl:variable&gt;</eg>
               <p>can be regarded as a shorthand for:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:variable name="tree" as="document-node()"&gt;
  &lt;xsl:document validation="preserve"&gt;
    &lt;a/&gt;
  &lt;/xsl:document&gt;  
&lt;/xsl:variable&gt;</eg>
            </note>
            <p>The base URI of the document node is taken from the base URI of the variable binding
               element in the stylesheet. (See <xspecref spec="DM30" ref="dm-base-uri"/> in <bibref
                  ref="xpath-datamodel-30"/>)</p>
            <p>No document-level validation takes place (which means, for example, that there is no
               checking that ID values are unique). However, <termref def="dt-type-annotation">type
                  annotations</termref> on nodes within the new tree are copied unchanged.</p>
            <note>
               <p>The base URI of other nodes in the tree is determined by the rules for
                  constructing complex content (see <specref ref="constructing-complex-content"/>).
                  The effect of these rules is that the base URI of a node in the temporary tree is
                  determined as if all the nodes in the temporary tree came from a single entity
                  whose URI was the base URI of the <termref def="dt-variable-binding-element"
                     >variable-binding element</termref>. Thus, the base URI of the document node
                  will be equal to the base URI of the variable-binding element, while an
                     <code>xml:base</code> attribute within the temporary tree will change the base
                  URI for its parent element and that element’s descendants, just as it would within
                  a document constructed by parsing.</p>
            </note>
            <p>The <code>document-uri</code> and <code>unparsed-entities</code> properties of the
               new document node are set to empty.</p>
            <p>A <termref def="dt-temporary-tree">temporary tree</termref> is available for
               processing in exactly the same way as any source document. For example, its nodes are
               accessible using path expressions, and they can be processed using instructions such
               as <elcode>xsl:apply-templates</elcode> and <elcode>xsl:for-each</elcode>. Also, the
                  <function>key</function> and <xfunction>id</xfunction> functions can be used to
               find nodes within a temporary tree, <phrase diff="chg" at="D"> by supplying the
                  document node at the root of the tree as an argument to the function or by making
                  it the context node</phrase>.</p>
            <example>
               <head>Two-Phase Transformation</head>
               <p>The following stylesheet uses a temporary tree as the intermediate result of a
                  two-phase transformation, using different <termref def="dt-mode">modes</termref>
                  for the two phases (see <specref ref="modes"/>). Typically, the template rules in
                  module <code>phase1.xsl</code> will be declared with <code>mode="phase1"</code>,
                  while those in module <code>phase2.xsl</code> will be declared with
                     <code>mode="phase2"</code>: </p>
               <eg xml:space="preserve" role="xslt-document">&lt;xsl:stylesheet
  version="3.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:import href="phase1.xsl"/&gt;
&lt;xsl:import href="phase2.xsl"/&gt;

&lt;xsl:variable name="intermediate"&gt;
  &lt;xsl:apply-templates select="/" mode="phase1"/&gt;
&lt;/xsl:variable&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:apply-templates select="$intermediate" mode="phase2"/&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg>
            </example>
            <note>
               <p>The algorithm for matching nodes against template rules is exactly the same
                  regardless which tree the nodes come from. If different template rules are to be
                  used when processing different trees, then unless nodes from different trees can
                  be distinguished by means of <termref def="dt-pattern">patterns</termref>, it is a
                  good idea to use <termref def="dt-mode">modes</termref> to ensure that each tree
                  is processed using the appropriate set of template rules.</p>
            </note>
         </div2>
         <div2 id="global-variables">
            <head>Global Variables and Parameters</head>
            <p>Both <elcode>xsl:variable</elcode> and <elcode>xsl:param</elcode> are allowed as
                  <termref def="dt-declaration">declaration</termref> elements: that is, they may
               appear as children of the <phrase diff="add" at="R-editorial"
                     ><elcode>xsl:package</elcode> or</phrase>
               <elcode>xsl:stylesheet</elcode> element.</p>
            <p>
               <termdef id="dt-global-variable" term="global variable">A <termref def="dt-top-level"/>
                  <termref def="dt-variable-binding-element">variable-binding element</termref>
                  declares a <term>global variable</term> that is visible everywhere (except <phrase
                     diff="add" at="N">within its own declaration, and</phrase> where it is <termref
                     def="dt-shadows">shadowed</termref> by another binding).</termdef>
            </p>
            <p>
               <termdef id="dt-stylesheet-parameter" term="stylesheet parameter">A <termref
                     def="dt-top-level"/>
                  <elcode>xsl:param</elcode> element declares a <term>stylesheet parameter</term>. A
                  stylesheet parameter is a global variable with the additional property that its
                  value can be supplied by the caller when a transformation is initiated.</termdef>
               As described in <specref ref="parameters"/>, a stylesheet parameter may be declared
               as being mandatory, or may have a default value specified for use when no value is
               supplied by the caller. The mechanism by which the caller supplies a value for a
               stylesheet parameter is <termref def="dt-implementation-defined"
                  >implementation-defined</termref>. An XSLT <termref def="dt-processor"
                  >processor</termref>
               <rfc2119>must</rfc2119> provide such a mechanism.</p>
            <imp-def-feature id="idf-api-params">The mechanism by which the caller supplies a value
               for a <termref def="dt-stylesheet-parameter"/> is <termref
                  def="dt-implementation-defined"
               >implementation-defined</termref>.</imp-def-feature>
            <p>It is an error if no value is supplied for a mandatory stylesheet parameter <errorref
                  spec="XT" class="DE" code="0050"/>.</p>
            <p>If a <termref def="dt-stylesheet">stylesheet</termref> contains more than one binding
               for a global variable of a particular name, then the binding with the highest
                  <termref def="dt-import-precedence">import precedence</termref> is used.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0630"><p>It is a <termref
                        def="dt-static-error">static error</termref> if a <termref def="dt-package"
                        diff="chg" at="R-bug24763">package</termref> contains more than one <phrase
                        diff="add" at="N">non-hidden</phrase> binding of a global variable with the
                     same name and same <termref def="dt-import-precedence">import
                        precedence</termref>, unless it also contains another binding with the same
                     name and higher import precedence.</p></error>
            </p>
            <p>For a global variable or the default value of a stylesheet parameter, the <termref
                  def="dt-expression">expression</termref> or <termref def="dt-sequence-constructor"
                  >sequence constructor</termref> specifying the variable value is evaluated with a
                  <termref def="dt-singleton-focus">singleton focus</termref> as follows:</p>
            <ulist>
               <item>
                  <p>If the declaration appears within the <termref def="dt-top-level-package"/>
                     (including within an <elcode>xsl:override</elcode> element in the top-level
                     package), then the focus is based on the <phrase diff="chg" at="E"><termref
                           def="dt-global-context-item"/></phrase> if supplied, or <termref
                        def="dt-absent"/> otherwise.</p>
               </item>
               <item>
                  <p diff="add" at="R-bug25611">If the declaration appears within a <termref
                        def="dt-library-package"/>, then the focus is <termref def="dt-absent"
                     />.</p>
               </item>
            </ulist>
            <p>An XPath error will be reported if the evaluation of a global variable or parameter
               references the context item, context position, or context size when the <termref
                  def="dt-focus"/> is <termref def="dt-absent"/>. The values of other components of
               the dynamic context are the initial values as defined in <specref
                  ref="xpath-dynamic-context"/> and <specref ref="additional-dynamic-context"/>.</p>
            <p diff="chg" at="R-bug26740">The <termref def="dt-visibility"/> of a <termref
                  def="dt-stylesheet-parameter"/> is always (implicitly) <code>private</code> if the
               parameter is <code>static</code>, or <code>public</code> if the parameter is
               non-static.</p>
            <note diff="add" at="N">
               <p>This rule has the effect that after combining all the packages making up a
                  stylesheet, the non-static stylesheet parameters whose values are required
                  necessarily have distinct names, which simplifies the design of APIs.</p>
            </note>
            <p diff="add" at="M">For the effect of the <code>static</code> attribute, see <specref
                  ref="static-params"/>.</p>
            <p diff="chg" at="R-bug26740">The <code>visibility</code> attribute <rfc2119>must
                  not</rfc2119> be specified for a local variable: that is, it is allowed only when
               the parent element is <elcode>xsl:package</elcode>, <elcode>xsl:stylesheet</elcode>,
                  <elcode>xsl:transform</elcode>, or <elcode>xsl:override</elcode>.</p>
            <p diff="add" at="I">If the <code>visibility</code> attribute is present with the value
                  <code>abstract</code> then the <code>select</code> attribute
                  <rfc2119>must</rfc2119> be absent and the contained <termref
                  def="dt-sequence-constructor"/>
               <rfc2119>must</rfc2119> be empty. In this situation there is no <termref
                  def="dt-supplied-value">supplied value</termref>, and therefore the constraint
               that the supplied value is consistent with the required type does not apply.</p>
            <example>
               <head>A Stylesheet Parameter</head>
               <p>The following example declares a global parameter <code>para-font-size</code>,
                  which is referenced in an <termref def="dt-attribute-value-template">attribute
                     value template</termref>.</p>
               <eg xml:space="preserve" role="xslt-declaration xmlns:fo='fo'">&lt;xsl:param name="para-font-size" as="xs:string"&gt;12pt&lt;/xsl:param&gt;

&lt;xsl:template match="para"&gt;
 &lt;fo:block font-size="{$para-font-size}"&gt;
   &lt;xsl:apply-templates/&gt;
 &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</eg>
               <p>The implementation must provide a mechanism allowing the user to supply a value
                  for the parameter <code>para-font-size</code> when invoking the stylesheet; the
                  value <code>12pt</code> acts as a default.</p>
            </example>
         </div2>
         <div2 id="static-params" diff="add" at="M">
            <head>Static Variables and Parameters</head>
            <p>Static variables and parameters are global variables and can be used in the same way
               as other global variables. In addition, they can be used in
                  <code>[xsl:]use-when</code> expressions and in shadow attributes.</p>
            <p>
               <termdef id="dt-static-variable" term="static variable">A <termref def="dt-top-level"/>
                  <termref def="dt-variable-binding-element">variable-binding element</termref>
                  having the attribute <code>static="yes"</code> declares a <term>static
                     variable</term>: that is, a <termref def="dt-global-variable"/> whose value is
                  known during static analysis of the stylesheet.</termdef>
            </p>
            <p>
               <termdef id="dt-static-parameter" term="static parameter">A <termref
                     def="dt-static-variable"/> declared using an <elcode>xsl:param</elcode> element
                  is referred to as a <term>static parameter</term>.</termdef>
            </p>
            <p>The <code>static</code> attribute <rfc2119>must not</rfc2119>
               <phrase diff="chg" at="28525">take the value <code>yes</code></phrase> on an
                  <elcode>xsl:variable</elcode> or <elcode>xsl:param</elcode> element unless it is a
                  <termref def="dt-top-level"/> element.</p>
            <p diff="add" at="O">When the <code>static</code> attribute is present with the value
                  <code>yes</code>, the <code>visibility</code> attribute <rfc2119>must
                  not</rfc2119> have a value other than <code>private</code><phrase diff="del"
                  at="R-bug26740"> or <code>final</code></phrase>.</p>
            <note diff="add" at="O">
               <p>This rule prevents static variables being overridden in another package. Since the
                  values of such variables may be used at compile time (for example, during
                  processing of <code>[xsl:]use-when</code> expressions), the rule is necessary to
                  ensure that packages can be independently compiled.</p>
               <p diff="del" at="R-bug26740">Declaring a static variable or parameter with
                     <code>visibility="final"</code> allows its value to be used in ordinary
                  (non-static) expressions in a using package, but use in static expressions is
                  possible only within the same package.</p>
               <p diff="add" at="R-bug26740">It is possible to make the value of a static variable
                  or parameter available in a using package by binding a non-static public variable
                  to its value, for example:</p>
               <eg role="xslt-declaration" xml:space="preserve">
     &lt;xsl:param name="DEBUG" static="yes" select="true()"/&gt;
     &lt;xsl:variable name="tracing" static="no" visibility="public" select="$DEBUG"/&gt;</eg>
            </note>
            <p>When the attribute <code>static="yes"</code> is specified, the
                  <elcode>xsl:variable</elcode> or <elcode>xsl:param</elcode> element
                  <rfc2119>must</rfc2119> have empty content. In the case of
                  <elcode>xsl:variable</elcode> the <code>select</code> attribute must be present to
               define the value of the variable <errorref spec="XT" class="SE" code="0010"/>.</p>
            <p>If the <code>select</code> attribute is present, then it is evaluated using the rules
               for <termref def="dt-static-expression">static expressions</termref>.</p>
            <p diff="add" at="R-bug24478">The rules for the scope of static variables, and the
               handling of duplicate declarations, are similar to the rules for non-static
               variables, but with additional constraints designed to disallow forwards references.
               The reason for disallowing forwards references is to ensure that
                  <code>use-when</code> attributes can always be evaluated as early as possible, and
               in particular to ensure that the value of a <code>use-when</code> attribute never has
               circular dependencies. The additional constraints are as follows:</p>
            <olist diff="add" at="R-bug24478">
               <item>
                  <p>The static context for evaluation of a <termref def="dt-static-expression"/>
                     only contains those <termref def="dt-static-variable">static
                        variables</termref> visible within the containing package whose declarations
                     occur prior to the element containing the static expression in stylesheet tree
                     order. Stylesheet tree order is the order that results when all
                        <elcode>xsl:import</elcode> and <elcode>xsl:include</elcode> declarations
                     are replaced by the declarations in the imported or included stylesheet module.
                     A static variable is not in scope within its own declaration.</p>
               </item>
               <item>
                  <p>If two static variables declared within the same package have the same name,
                     the one that has higher <termref def="dt-import-precedence"/> is used (it is a
                     consequence of rules defined elsewhere that there cannot be more than one
                     declaration with highest import precedence). However, if the declaration with
                     higher import precedence occurs after the one with lower import precedence in
                     stylesheet tree order, then the two declarations must be consistent. For this
                     purpose two declarations are consistent if (a) they are either both
                        <elcode>xsl:variable</elcode> elements, or both <elcode>xsl:param</elcode>
                     elements, and (b) if the variables are initialized (that is, if the elements
                     are <elcode>xsl:variable</elcode> elements, or if they are
                        <elcode>xsl:param</elcode> elements and no value for the parameter is
                     externally supplied) then the values of both variables must be <xtermref
                        spec="FO30" ref="dt-identical">identical</xtermref>, and must not contain
                     function items.</p>
                  <note>
                     <p>This rule ensures that when a static variable reference is encountered, the
                        value of the most recently declared static variable with that name can be
                        used, knowing that this value cannot be overridden by a subsequent
                        declaration having higher import precedence.</p>
                  </note>
                  <p><error spec="XT" type="static" class="SE" code="3450"><p>It is a <termref
                              def="dt-static-error">static error</termref> if a variable declared
                           with <code>static="yes"</code> is inconsistent with another static
                           variable of the same name that is declared earlier in stylesheet tree
                           order and that has lower <termref def="dt-import-precedence"
                        />.</p></error></p>
               </item>
            </olist>
         </div2>
         <div2 id="static-expression" diff="add" at="M">
            <head>Static Expressions</head>
            <p><termdef id="dt-static-expression" term="static expression">A <term>static
                     expression</term> is an XPath <termref def="dt-expression"/> whose value must
                  be computed during static analysis of the stylesheet.</termdef></p>
            <p>Static expressions appear in a number of contexts, in particular:</p>
            <ulist>
               <item>
                  <p>In <code>[xsl:]use-when</code> attributes (see <specref
                        ref="conditional-inclusion"/>);</p>
               </item>
               <item>
                  <p>In the <code>select</code> attribute of <termref def="dt-static-variable"/>
                     declarations (<elcode>xsl:variable</elcode> or <elcode>xsl:param</elcode> with
                        <code>static="yes"</code>);</p>
               </item>
               <item diff="add" at="S-bug28352">
                  <p>In shadow attributes (see <specref ref="shadow-attributes"/>).</p>
               </item>
            </ulist>
            <p>There are no syntactic constraints on the XPath expression that can be used as a
                  <termref def="dt-static-expression"/>. However, there are severe constraints on
               the information provided in its evaluation context. These constraints are designed to
               ensure that the expression can be evaluated at the earliest possible stage of
               stylesheet processing, without any dependency on information contained in the
               stylesheet itself or in any source document.</p>
            <p>Specifically, the components of the static and dynamic context are defined by the
               following two tables:</p>
            <table class="def">
               <caption>Static Context Components for Static Expressions</caption>
               <col align="left" width="30%" span="1"/>
               <col align="left" span="1"/>
               <thead>
                  <tr>
                     <th rowspan="1" colspan="1">Component</th>
                     <th rowspan="1" colspan="1">Value</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td rowspan="1" colspan="1">XPath 1.0 compatibility mode</td>
                     <td rowspan="1" colspan="1">false</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Statically known namespaces</td>
                     <td rowspan="1" colspan="1">determined by the in-scope namespaces for the
                        containing element in the stylesheet</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Default element/type namespace</td>
                     <td rowspan="1" colspan="1">determined by the
                           <code>xpath-default-namespace</code> attribute if present (see <specref
                           ref="unprefixed-qnames"/>); otherwise the null namespace</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Default function namespace</td>
                     <td rowspan="1" colspan="1">The <termref def="dt-standard-function-namespace"
                           >standard function namespace</termref>
                     </td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">In-scope schema types</td>
                     <td rowspan="1" colspan="1">The type definitions that would be available in the
                        absence of any <elcode>xsl:import-schema</elcode> declaration</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">In-scope element declarations</td>
                     <td rowspan="1" colspan="1">None</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">In-scope attribute declarations</td>
                     <td rowspan="1" colspan="1">None</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">In-scope variables</td>
                     <td diff="chg" at="R-bug24478" rowspan="1" colspan="1">The <termref
                           def="dt-static-variable">static variables</termref> visible within the
                        containing package whose declarations occur prior to the element containing
                        the static expression in stylesheet tree order. Stylesheet tree order is the
                        order that results when all <elcode>xsl:import</elcode> and
                           <elcode>xsl:include</elcode> declarations are replaced by the
                        declarations in the imported or included stylesheet module. A static
                        variable is not in scope within its own declaration, <phrase diff="add"
                           at="O">and it is in scope only within its declaring package, not in any
                           using packages.</phrase> If two static variables satisfying this rule
                        have the same name and are both in scope, the one that appears most recently
                        in stylesheet tree order is used; as a consequence of rules defined
                        elsewhere this will always be consistent with the declaration having highest
                        import precedence.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Context item static type</td>
                     <td rowspan="1" colspan="1"><termref def="dt-absent">Absent</termref></td>
                  </tr>
                  <tr>
                     <td diff="chg" at="R-bug26751" rowspan="1" colspan="1">Statically known
                        function signatures</td>
                     <td rowspan="1" colspan="1">The functions defined in <bibref
                           ref="xpath-functions-30"/> in the <code>fn</code> and <code>math</code>
                        namespaces, together with: <olist>
                           <item>
                              <p>the functions <function>element-available</function>,
                                    <function>function-available</function>,
                                    <function>type-available</function>, <phrase diff="add"
                                    at="S-bug29109"
                                    ><function>available-system-properties</function>,</phrase> and
                                    <function>system-property</function> defined in this
                                 specification;</p>
                           </item>
                           <item>
                              <p>functions that appear in both this specification and in <bibref
                                    ref="xpath-functions-31"/> (for example, the functions in the
                                    <code>map</code> namespaces, and a few others such as
                                    <code>collation-key</code> and <code>json-to-xml</code>);</p>
                           </item>
                           <item>
                              <p>if XPath 3.1 is supported, functions defined in <bibref
                                    ref="xpath-functions-31"/> in the <code>fn</code>,
                                    <code>math</code>, <code>map</code>, and <code>array</code>
                                 namespaces;</p>
                           </item>
                           <item>
                              <p>constructor functions for built-in types;</p>
                           </item>
                           <item>
                              <p>the set of extension functions that are present in the static
                                 context of every XPath expression (other than a static expression)
                                 within the content of the element that contains the static
                                 expression. </p>
                           </item>
                        </olist> Note that <termref def="dt-stylesheet-function">stylesheet
                           functions</termref> are <emph>not</emph> included in the context, which
                        means that the function <function>function-available</function> will return
                           <code>false</code> in respect of such functions, and
                           <xfunction>function-lookup</xfunction> will fail to find them. The effect
                        of this rule is to ensure that <function>function-available</function>
                        returns true in respect of functions that can be called within the static
                        expression. It also has the effect that these extension functions will be
                        recognized within the static expression itself; however, the fact that a
                        function is available in this sense gives no guarantee that a call on the
                        function will succeed.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Statically known collations</td>
                     <td rowspan="1" colspan="1">Implementation-defined</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Default collation</td>
                     <td rowspan="1" colspan="1">The Unicode Codepoint Collation</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Static Base URI</td>
                     <td rowspan="1" colspan="1">The base URI of the containing element in the
                        stylesheet document <phrase diff="add" at="M">(see <xspecref spec="DM30"
                              ref="dm-base-uri"/>)</phrase></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Statically known documents</td>
                     <td rowspan="1" colspan="1">Implementation-defined</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Statically known collections</td>
                     <td rowspan="1" colspan="1">Implementation-defined</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Statically known default collection type</td>
                     <td rowspan="1" colspan="1">Implementation-defined</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Statically known decimal formats</td>
                     <td rowspan="1" colspan="1">A single unnamed <termref def="dt-decimal-format"
                           >decimal format</termref> equivalent to the decimal format that is
                        created by an <elcode>xsl:decimal-format</elcode> declaration with no
                        attributes.</td>
                  </tr>
               </tbody>
            </table>
            <p> </p>
            <table class="def">
               <caption>Dynamic Context Components for Static Expressions</caption>
               <col align="left" width="30%" span="1"/>
               <col align="left" span="1"/>
               <thead>
                  <tr>
                     <th rowspan="1" colspan="1">Component</th>
                     <th rowspan="1" colspan="1">Value</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td rowspan="1" colspan="1">Context item, position, and size</td>
                     <td rowspan="1" colspan="1"><termref def="dt-absent">Absent</termref></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Variable values</td>
                     <td rowspan="1" colspan="1">A value for every variable present in the in-scope
                        variables. For <termref def="dt-static-parameter">static
                           parameters</termref> where an external value is supplied: the
                        externally-supplied value of the parameter. In all other cases: the value of
                        the variable as defined in <specref ref="variable-values"/>.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Named functions</td>
                     <td rowspan="1" colspan="1">The function implementation corresponding to each
                        function signature in the statically known function signatures</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Current dateTime</td>
                     <td rowspan="1" colspan="1">Implementation-defined</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Implicit timezone</td>
                     <td rowspan="1" colspan="1">Implementation-defined</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Default language</td>
                     <td rowspan="1" colspan="1">Implementation-defined</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Default calendar</td>
                     <td rowspan="1" colspan="1">Implementation-defined</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Default place</td>
                     <td rowspan="1" colspan="1">Implementation-defined</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Available documents</td>
                     <td rowspan="1" colspan="1">Implementation-defined</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Available collections</td>
                     <td rowspan="1" colspan="1">Implementation-defined</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Default collection</td>
                     <td rowspan="1" colspan="1">Implementation-defined</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Environment variables</td>
                     <td rowspan="1" colspan="1">Implementation-defined</td>
                  </tr>
               </tbody>
            </table>
            <p>Within a <termref def="dt-stylesheet-module">stylesheet module</termref>, all static
               expressions are evaluated in a single <xtermref spec="FO30" ref="execution-scope"
                  >execution scope</xtermref>. This need not be the same execution scope as that
               used for static expressions in other stylesheet modules, or as that used when
               evaluating XPath expressions appearing elsewhere in the stylesheet module. This means
               that a function such as <xfunction>current-date</xfunction> will return the same
               result when called in different <code>[xsl:]use-when</code> expressions within the
               same stylesheet module, but will not necessarily return the same result as the same
               call in an <code>[xsl:]use-when</code> expression within a different stylesheet
               module, or as a call on the same function executed during the transformation
               proper.</p>
            <p diff="add" at="S-bug28205">If a <termref def="dt-static-error"/> is present in a
                  <termref def="dt-static-expression"/>, it is treated in the same way as any other
               static error in the stylesheet module. If a <termref def="dt-dynamic-error"/> occurs
               during evaluation of a static expression, it is treated as a static error in the
               analysis of the stylesheet, while retaining its original error code.</p>
         </div2>
         <div2 id="local-variables">
            <head>Local Variables and Parameters</head>
            <p>
               <termdef id="dt-local-variable" term="local variable">As well as being allowed as a
                     <termref def="dt-declaration">declaration</termref>, the
                     <elcode>xsl:variable</elcode> element is also allowed in <termref
                     def="dt-sequence-constructor">sequence constructors</termref>. Such a variable
                  is known as a <term>local variable</term>.</termdef>
            </p>
            <p>An <elcode>xsl:param</elcode> element may also be used to create a variable binding
               with local scope:</p>
            <ulist>
               <item>
                  <p>
                     <termdef id="dt-template-parameter" term="template parameter"> An
                           <elcode>xsl:param</elcode> element may appear as a child of an
                           <elcode>xsl:template</elcode> element, before any
                           non-<elcode>xsl:param</elcode> children of that element. Such a parameter
                        is known as a <term>template parameter</term>. A template parameter is a
                           <termref def="dt-local-variable">local variable</termref> with the
                        additional property that its value can be set when the template is called,
                        using any of the instructions <elcode>xsl:call-template</elcode>,
                           <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>,
                        or <elcode>xsl:next-match</elcode>.</termdef>
                  </p>
               </item>
               <item>
                  <p>
                     <termdef id="dt-function-parameter" term="function parameter"> An
                           <elcode>xsl:param</elcode> element may appear as a child of an
                           <elcode>xsl:function</elcode> element, before any
                           non-<elcode>xsl:param</elcode> children of that element. Such a parameter
                        is known as a <term>function parameter</term>. A function parameter is a
                           <termref def="dt-local-variable">local variable</termref> with the
                        additional property that its value can be set when the function is called,
                        using a function call in an XPath <termref def="dt-expression"
                           >expression</termref>.</termdef>
                  </p>
               </item>
               <item>
                  <p diff="add" at="D">An <elcode>xsl:param</elcode> element may appear as a child
                     of an <elcode>xsl:iterate</elcode> instruction, before any
                        non-<elcode>xsl:param</elcode> children of that element. This defines a
                     parameter whose value may be initialized on entry to the iteration, and which
                     may be varied each time round the iteration by use of an
                        <elcode>xsl:with-param</elcode> element in the
                        <elcode>xsl:next-iteration</elcode> instruction. </p>
               </item>
            </ulist>
            <p>The result of evaluating a local <elcode>xsl:variable</elcode> or
                  <elcode>xsl:param</elcode> element (that is, the contribution it makes to the
               result of the <termref def="dt-sequence-constructor"/> it is part of) is an empty
               sequence.</p>
         </div2>
         <div2 id="scope-of-variables">
            <head>Scope of Variables</head>
            <p>For any <termref def="dt-variable-binding-element">variable-binding
               element</termref>, there is a region (more specifically, a set of <phrase diff="del"
                  at="M">element</phrase> nodes) of the <termref def="dt-stylesheet"
                  >stylesheet</termref> within which the binding is visible. The set of variable
               bindings in scope for an XPath <termref def="dt-expression">expression</termref>
               consists of those bindings that are visible at the point in the stylesheet where the
               expression occurs.</p>
            <p>A global <termref def="dt-variable-binding-element">variable binding
                  element</termref> is visible everywhere in the <phrase diff="chg" at="V-bug30095"
                  >containing <termref def="dt-package"/></phrase> (including other <termref
                  def="dt-stylesheet-module">stylesheet modules</termref>) except within the
                  <elcode>xsl:variable</elcode> or <elcode>xsl:param</elcode> element itself and any
               region where it is <termref def="dt-shadows">shadowed</termref> by another variable
               binding. <phrase diff="add" at="V-bug30095">(For rules regarding the visibility of
                  the variable in other packages, see <specref ref="visibility"/>.)</phrase>
            </p>
            <p>A local <termref def="dt-variable-binding-element">variable binding element</termref>
               is visible for all following siblings and their descendants, with <phrase diff="chg"
                  at="B">the following</phrase> exceptions:</p>
            <olist>
               <item>
                  <p>It is not visible in any region where it is <termref def="dt-shadows"
                        >shadowed</termref> by another variable binding.</p>
               </item>
               <item>
                  <p>It is not visible within the subtree rooted at an <elcode>xsl:fallback</elcode>
                     instruction that is a sibling of the variable binding element.</p>
               </item>
               <item>
                  <p diff="add" at="B">It is not visible within the subtree rooted at an
                        <elcode>xsl:catch</elcode> instruction that is a sibling of the variable
                     binding element.</p>
               </item>
            </olist>
            <p>The binding is not visible for the <elcode>xsl:variable</elcode> or
                  <elcode>xsl:param</elcode> element itself.</p>
            <p diff="add" at="M">If a binding is visible for an element then it is visible for every
               attribute of that element and for every text node child of that element.</p>
            <p>
               <termdef id="dt-shadows" term="shadows">A binding <term>shadows</term> another
                  binding if the binding occurs at a point where the other binding is visible, and
                  the bindings have the same name.</termdef> It is not an error if a binding
               established by a local <elcode>xsl:variable</elcode> or <elcode>xsl:param</elcode>
               <termref def="dt-shadows">shadows</termref> a global binding. In this case, the
               global binding will not be visible in the region of the <termref def="dt-stylesheet"
                  >stylesheet</termref> where it is shadowed by the other binding.</p>
            <example>
               <head>Local Variable Shadowing a Global Variable</head>
               <p>The following is allowed:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:param name="x" select="1"/&gt;
&lt;xsl:template name="foo"&gt;
  &lt;xsl:variable name="x" select="2"/&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <p>It is also not an error if a binding established by a local
                  <elcode>xsl:variable</elcode> element <termref def="dt-shadows">shadows</termref>
               a binding established by another local <elcode>xsl:variable</elcode> or
                  <elcode>xsl:param</elcode>.</p>
            <example>
               <head>Misuse of Variable Shadowing</head>
               <p>The following is not an error, but the effect is probably not what was intended.
                  The template outputs <code>&lt;x value="1"/&gt;</code>, because the declaration of
                  the inner variable named <code>$x</code> has no effect on the value of the outer
                  variable named <code>$x</code>.</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:variable name="x" select="1"/&gt;
&lt;xsl:template name="foo"&gt;
  &lt;xsl:for-each select="1 to 5"&gt;
    &lt;xsl:variable name="x" select="$x+1"/&gt;
  &lt;/xsl:for-each&gt;
  &lt;x value="{$x}"/&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <note>
               <p>Once a variable has been given a value, the value cannot subsequently be changed.
                  XSLT does not provide an equivalent to the assignment operator available in many
                  procedural programming languages. </p>
               <p>This is because an assignment operator would make it harder to create an
                  implementation that processes a document other than in a batch-like way, starting
                  at the beginning and continuing through to the end.</p>
            </note>
            <p>As well as global variables and local variables, an XPath <termref
                  def="dt-expression">expression</termref> may also declare range variables for use
               locally within an expression. For details, see <bibref ref="xpath-30"/>.</p>
            <p>Where a reference to a variable occurs in an XPath expression, it is resolved first
               by reference to range variables that are in scope, then by reference to local
               variables and parameters, and finally by reference to global variables and
               parameters. A range variable may shadow a local variable or a global variable. XPath
               also allows a range variable to shadow another range variable.</p>
         </div2>
         <div2 id="with-param">
            <head>Setting Parameter Values</head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="with-param">
               <e:attribute name="name" required="yes">
                  <e:data-type name="eqname"/>
               </e:attribute>
               <e:attribute name="select">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="as">
                  <e:data-type name="sequence-type"/>
               </e:attribute>
               <e:attribute name="tunnel">
                  <e:data-type name="boolean"/>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent name="apply-templates"/>
                  <e:parent name="apply-imports"/>
                  <e:parent name="call-template"/>
                  <e:parent name="evaluate"/>
                  <e:parent name="next-match"/>
                  <e:parent name="next-iteration"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>Parameters are passed to templates using the <elcode>xsl:with-param</elcode> element.
               The <rfc2119>required</rfc2119>
               <code>name</code> attribute specifies the name of the <termref
                  def="dt-template-parameter">template parameter</termref> (the variable the value
               of whose binding is to be replaced). The value of the <code>name</code> attribute is
               an <phrase diff="chg" at="K"><termref def="dt-eqname">EQName</termref></phrase>,
               which is expanded as described in <specref ref="qname"/>.</p>
            <p><phrase diff="add" at="D">The <elcode>xsl:with-param</elcode> element is also used
                  when passing parameters to an iteration of the <elcode>xsl:iterate</elcode>
                  instruction, or to a dynamic invocation of an XPath expression using
                     <elcode>xsl:evaluate</elcode>. In consequence, </phrase>
               <elcode>xsl:with-param</elcode> may appear within
                  <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>,
                  <elcode>xsl:call-template</elcode>, <phrase diff="add" at="B"
                     ><elcode>xsl:evaluate</elcode>, <elcode>xsl:next-iteration</elcode>, </phrase>
               and <elcode>xsl:next-match</elcode>. (Arguments to <termref
                  def="dt-stylesheet-function">stylesheet functions</termref>, however, are supplied
               as part of an XPath function call: see <specref ref="stylesheet-functions"/>.) </p>
            <p>
               <error spec="XT" type="static" class="SE" code="0670"><p diff="chg" at="B">It is a
                        <termref def="dt-static-error">static error</termref> if two or more sibling
                        <elcode>xsl:with-param</elcode> elements have <code>name</code> attributes
                     that represent the same <termref def="dt-expanded-qname">expanded
                        QName</termref>.</p></error>
            </p>
            <p>The value of the parameter is specified in the same way as for
                  <elcode>xsl:variable</elcode> and <elcode>xsl:param</elcode> (see <specref
                  ref="variable-values"/>), taking account of the values of the <code>select</code>
               and <code>as</code> attributes and the content of the <elcode>xsl:with-param</elcode>
               element, if any.</p>
            <note>
               <p>It is possible to have an <code>as</code> attribute on the
                     <elcode>xsl:with-param</elcode> element that differs from the <code>as</code>
                  attribute on the corresponding <elcode>xsl:param</elcode> element<phrase
                     diff="del" at="D"> describing the formal parameters of the called
                     template</phrase>.</p>
               <p>In this situation, the supplied value of the parameter will first be processed
                  according to the rules of the <code>as</code> attribute on the
                     <elcode>xsl:with-param</elcode> element, and the resulting value will then be
                  further processed according to the rules of the <code>as</code> attribute on the
                     <elcode>xsl:param</elcode> element.</p>
               <p>For example, suppose the supplied value is a node with <termref
                     def="dt-type-annotation"/>
                  <code>xs:untypedAtomic</code>, and the <elcode>xsl:with-param</elcode> element
                  specifies <code>as="xs:integer"</code>, while the <elcode>xsl:param</elcode>
                  element specifies <code>as="xs:double"</code>. Then the node will first be
                  atomized and the resulting untyped atomic value will be cast to
                     <code>xs:integer</code>. If this succeeds, the <code>xs:integer</code> will
                  then be promoted to an <code>xs:double</code>.</p>
            </note>
            <p>The <termref def="dt-focus">focus</termref> used for computing the value specified by
               the <elcode>xsl:with-param</elcode> element is the same as that used for <phrase
                  diff="chg" at="B">its parent <termref def="dt-instruction"
                  >instruction</termref></phrase>.</p>
            <p>The optional <code>tunnel</code> attribute may be used to indicate that a parameter
               is a <termref def="dt-tunnel-parameter">tunnel parameter</termref>. The default is
                  <code>no</code>. Tunnel parameters are described in <specref ref="tunnel-params"
               />. They are used only when passing parameters to templates: for an
                  <elcode>xsl:with-param</elcode> element that is a child of
                  <elcode>xsl:evaluate</elcode> or <elcode>xsl:next-iteration</elcode> the
                  <code>tunnel</code> attribute <rfc2119>must</rfc2119> either be omitted or take
               the value <code>no</code>. </p>
            <p> In other cases it is a <termref def="dt-dynamic-error"><phrase diff="del" at="M"
                     >non-recoverable</phrase> dynamic error</termref> if the template that is
               invoked declares a <termref def="dt-template-parameter">template parameter</termref>
               with <code>required="yes"</code> and no value for this parameter is supplied by the
               calling instruction. <errorref spec="XT" class="DE" code="0700"/>
            </p>
         </div2>
         <div2 id="circularity">
            <head>Circular Definitions</head>
            <p>
               <termdef id="dt-circularity" term="circularity">A <term>circularity</term> is said to
                  exist if a construct such as a <termref def="dt-global-variable">global
                     variable</termref>, an <termref def="dt-attribute-set">attribute set</termref>,
                  or a <termref def="dt-key">key</termref>, is defined in terms of itself. For
                  example, if the <termref def="dt-expression">expression</termref> or <termref
                     def="dt-sequence-constructor">sequence constructor</termref> specifying the
                  value of a <termref def="dt-global-variable">global variable</termref>
                  <var>X</var> references a global variable <var>Y</var>, then the value for
                     <var>Y</var>
                  <rfc2119>must</rfc2119> be computed before the value of <var>X</var>. A
                  circularity exists if it is impossible to do this for all global variable
                  definitions.</termdef>
            </p>
            <example>
               <head>Circular Variable Definitions</head>
               <p>The following two declarations create a circularity:</p>
               <eg role="error" xml:space="preserve">&lt;xsl:variable name="x" select="$y+1"/&gt;
&lt;xsl:variable name="y" select="$x+1"/&gt;</eg>
            </example>
            <example>
               <head>Circularity involving Variables and Functions</head>
               <p>The definition of a global variable can be circular even if no other variable is
                  involved. For example the following two declarations (see <specref
                     ref="stylesheet-functions"/> for an explanation of the
                     <elcode>xsl:function</elcode> element) also create a circularity:</p>
               <eg role="error" xml:space="preserve">&lt;xsl:variable name="x" select="my:f()"/&gt;

&lt;xsl:function name="my:f"&gt;
  &lt;xsl:sequence select="$x"/&gt;
&lt;/xsl:function&gt;
</eg>
            </example>
            <example>
               <head>Circularity involving Variables and Templates</head>
               <p>The definition of a variable is also circular if the evaluation of the variable
                  invokes an <elcode>xsl:apply-templates</elcode> instruction and the variable is
                  referenced in the pattern used in the <code>match</code> attribute of any template
                  rule in the <termref def="dt-stylesheet">stylesheet</termref>. For example the
                  following definition is circular:</p>
               <eg role="error" xml:space="preserve">&lt;xsl:variable name="x"&gt;
  &lt;xsl:apply-templates select="//param[1]"/&gt;
&lt;/xsl:variable&gt;

&lt;xsl:template match="param[$x]"&gt;1&lt;/xsl:template&gt;
</eg>
            </example>
            <example>
               <head>Circularity involving Variables and Keys</head>
               <p>Similarly, a variable definition is circular if it causes a call on the
                     <function>key</function> function, and the definition of that <termref
                     def="dt-key">key</termref> refers to that variable in its <code>match</code> or
                     <code>use</code> attributes. So the following definition is circular:</p>
               <eg role="error" xml:space="preserve" diff="chg" at="R-bug7358">&lt;xsl:variable name="x" select="my:f(10, /)"/&gt;

&lt;xsl:function name="my:f"&gt;
  &lt;xsl:param name="arg1"/&gt;
  &lt;xsl:param name="top"/&gt;
  &lt;xsl:sequence select="key('k', $arg1, $top)"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:key name="k" match="item[@code=$x]" use="@desc"/&gt;
</eg>
            </example>
            <example diff="add" at="S-bug28114">
               <head>Circularity involving Attribute Sets</head>
               <p>An attribute set is circular if its <code>use-attribute-sets</code> attribute
                  references itself, directly or indirectly. So the following definitions establish
                  a circularity:</p>
               <eg role="error" xml:space="preserve">&lt;xsl:attribute-set name="a" use-attribute-sets="b"/&gt;
&lt;xsl:attribute-set name="b" use-attribute-sets="a"/&gt;                  
</eg>
               <p>Because attribute sets can invoke functions, global variables, or templates, and
                  can also include instructions such as literal result elements that themselves
                  invoke attribute sets, examples of circularity involving attribute sets can be
                  more complex than this simple example illustrates. It is also possible to
                  construct examples in which self-reference among attribute sets could be regarded
                  as (terminating or non-terminating) recursion. However, because such
                  self-references have no practical utility, any requirement to evaluate an
                  attribute set in the course of its own evaluation is considered an error.</p>
               <note>
                  <p>In previous versions of this specification, self-reference among attribute sets
                     was defined as a static error. In XSLT 3.0 it is not always detectable
                     statically, because attribute sets can bind to each other across package
                     boundaries. Nevertheless, in cases where a processor can detect a static
                     circularity, it can report this error during the analysis phase, under the
                     general provision for reporting dynamic errors during stylesheet analysis if
                     execution can never succeed.</p>
               </note>
            </example>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0640"><p>In general, a <termref
                        def="dt-circularity">circularity</termref> in a <termref def="dt-stylesheet"
                        >stylesheet</termref> is a <termref def="dt-dynamic-error"><phrase
                           diff="del" at="M">non-recoverable</phrase> dynamic
                  error</termref>.</p></error> However, as with all other dynamic errors, an
               implementation will signal the error only if it actually executes the instructions
               and expressions that participate in the circularity. Because different
               implementations may optimize the execution of a stylesheet in different ways, it is
                  <termref def="dt-implementation-dependent">implementation-dependent</termref>
               whether a particular circularity will actually be signaled.</p>
            <p>For example, in the following declarations, the function declares a local variable
                  <code>$b</code>, but it returns a result that does not require the variable to be
               evaluated. It is <termref def="dt-implementation-dependent"
                  >implementation-dependent</termref> whether the value is actually evaluated, and
               it is therefore implementation-dependent whether the circularity is signaled as an
               error:</p>
            <eg role="error" xml:space="preserve">&lt;xsl:variable name="x" select="my:f(1)"/&gt;

&lt;xsl:function name="my:f"&gt;
  &lt;xsl:param name="a"/&gt;
  &lt;xsl:variable name="b" select="$x"/&gt;  
  &lt;xsl:sequence select="$a + 2"/&gt;
&lt;/xsl:function&gt;
</eg>
            <p diff="add" at="S-bug28368">Although a circularity is detected as a dynamic error,
               there is no unique instruction whose evaluation triggers the error condition, and the
               result of any attempt to catch the error using an <elcode>xsl:try</elcode>
               instruction is therefore <termref def="dt-implementation-dependent"/>.</p>
            <p>Circularities usually involve global variables or parameters, but they can also exist
               between <termref def="dt-key">key</termref> definitions (see <specref ref="key"/>),
               between named <termref def="dt-attribute-set">attribute sets</termref> (see <specref
                  ref="attribute-sets"/>), or between any combination of these constructs. For
               example, a circularity exists if a key definition invokes a function that references
               an attribute set that calls the <function>key</function> function, supplying the name
               of the original key definition as an argument.</p>
            <p>Circularity is not the same as recursion. Stylesheet functions (see <specref
                  ref="stylesheet-functions"/>) and named templates (see <specref
                  ref="named-templates"/>) may call other functions and named templates without
               restriction. With careless coding, recursion may be non-terminating. Implementations
               are <rfc2119>required</rfc2119> to signal circularity as a <termref
                  def="dt-dynamic-error">dynamic error</termref>, but they are not
                  <rfc2119>required</rfc2119> to detect non-terminating recursion.</p>
            <p diff="add" at="R-bug26543">The requirement to report a circularity as a dynamic error
               overrides the rule that dynamic errors in evaluating <termref def="dt-pattern"
                  >patterns</termref> are normally masked (by treating the pattern as not
               matching).</p>
         </div2>
      </div1>
      <div1 id="callable-components">
         <head>Callable Components</head>
         <p>This section describes three constructs that can be used to provide subroutine-like
            functionality that can be invoked from anywhere in the stylesheet: named templates (see
               <specref ref="named-templates"/>), named attribute sets (see <specref
               ref="attribute-sets"/>), and <termref def="dt-stylesheet-function">stylesheet
               functions</termref> (see <specref ref="stylesheet-functions"/>).</p>
         <p diff="add" at="R-bug24510"><termdef id="dt-invocation-construct"
               term="invocation construct">The following <termref def="dt-construct"
                  >constructs</termref> are classified as <term>invocation constructs</term>: the
               instructions <elcode>xsl:call-template</elcode>,
               <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>, and
                  <elcode>xsl:next-match</elcode>; XPath function calls that bind to <termref
                  def="dt-stylesheet-function">stylesheet functions</termref>; XPath dynamic
               function calls; the functions <function>accumulator-before</function> and
                  <function>accumulator-after</function>; the <code>[xsl:]use-attribute-sets</code>
               attribute. These all have the characteristic that they can cause evaluation of
               constructs that are not lexically contained within the calling
            construct.</termdef></p>
         <div2 id="named-templates">
            <head>Named Templates</head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="call-template">
               <e:in-category name="instruction"/>
               <e:attribute name="name" required="yes">
                  <e:data-type name="eqname"/>
               </e:attribute>
               <e:element repeat="zero-or-more" name="with-param"/>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>
               <termdef id="dt-named-template" term="named template">Templates can be invoked by
                  name. An <elcode>xsl:template</elcode> element with a <code>name</code> attribute
                  defines a <term>named template</term>.</termdef> The value of the
                  <code>name</code> attribute is an <phrase diff="chg" at="K"><termref
                     def="dt-eqname">EQName</termref></phrase>, which is expanded as described in
                  <specref ref="qname"/>. If an <elcode>xsl:template</elcode> element has a
                  <code>name</code> attribute, it may, but need not, also have a <code>match</code>
               attribute. An <elcode>xsl:call-template</elcode> instruction invokes a template by
               name; it has a <rfc2119>required</rfc2119>
               <code>name</code> attribute that identifies the template to be invoked. Unlike
                  <elcode>xsl:apply-templates</elcode>, the <elcode>xsl:call-template</elcode>
               instruction does not change the <termref def="dt-focus">focus</termref>.</p>
            <p>The <code>match</code>, <code>mode</code> and <code>priority</code> attributes on an
                  <elcode>xsl:template</elcode> element have no effect when the <termref
                  def="dt-template">template</termref> is invoked by an
                  <elcode>xsl:call-template</elcode> instruction. Similarly, the <code>name</code>
               <phrase diff="add" at="I"> and <code>visibility</code></phrase> attributes on an
                  <elcode>xsl:template</elcode> element have no effect when the template is invoked
               by an <elcode>xsl:apply-templates</elcode> instruction.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0650"><p>It is a <termref
                        def="dt-static-error">static error</termref> if a <termref def="dt-package"
                        diff="chg" at="R-bug24763">package</termref> contains an
                        <elcode>xsl:call-template</elcode> instruction whose <code>name</code>
                     attribute does not match the <code>name</code> attribute of any <phrase
                        diff="chg" at="I"><termref def="dt-named-template">named template</termref>
                        visible in the containing <termref def="dt-package">package</termref> (this
                        includes any template defined in this package, as well as templates accepted
                        from used packages whose visibility in this package is not
                           <code>hidden</code>). For more details of the process of binding the
                        called template, see <specref ref="component-references"
                  />.</phrase></p></error>
            </p>
            <p>
               <error spec="XT" type="static" class="SE" code="0660"><p>It is a <termref
                        def="dt-static-error">static error</termref> if a <phrase diff="chg" at="I">
                        <termref def="dt-package">package</termref></phrase> contains more than one
                        <phrase diff="add" at="N">non-hidden</phrase>
                     <termref def="dt-template">template</termref> with the same name and the same
                        <termref def="dt-import-precedence">import precedence</termref>, unless it
                     also contains a <termref def="dt-template">template</termref> with the same
                     name and higher <termref def="dt-import-precedence">import
                     precedence</termref>.</p></error>
            </p>
            <p><phrase diff="chg" at="I">The target <termref def="dt-template">template</termref>
                  for an <elcode>xsl:call-template</elcode> instruction is established using the
                  binding rules described in <specref ref="component-references"/>. This will always
                  be a template whose <code>name</code> attribute matches the <code>name</code>
                  attribute of the <elcode>xsl:call-template</elcode> instruction. It may be a
                  template defined in the same package that has higher <termref
                     def="dt-import-precedence">import precedence</termref> than any other template
                  with this name, or it may be a template accepted from a used package, or (if the
                  template is not defined as <code>private</code> or <code>final</code>) it may be
                  an overriding template in a package that uses the containing package. </phrase>
               The result of evaluating an <elcode>xsl:call-template</elcode> instruction is the
               sequence produced by evaluating the <termref def="dt-sequence-constructor">sequence
                  constructor</termref> contained in its target <termref def="dt-template"
                  >template</termref> (see <specref ref="sequence-constructors"/>).</p>
            <p diff="add" at="L">The template name <code>xsl:initial-template</code> is specially
               recognized in that it provides a default entry point for stylesheet execution (see
                  <specref ref="initiating"/>.) <phrase diff="del" at="R-bug24764">A template with
                  this name <rfc2119>must not</rfc2119> have any <elcode>xsl:param</elcode> children
                  that specify <code>required="yes"</code>. In all other respects a template with
                  this name behaves exactly like a template with any other name.</phrase></p>
            <p diff="del" at="R-bug24539">
               <error spec="XT" type="static" class="SE" code="3340"><p diff="add" at="N">It is a
                        <termref def="dt-static-error">static error</termref> if an
                        <elcode>xsl:template</elcode> declaration has the name
                        <code>xsl:initial-template</code> and contains an <elcode>xsl:param</elcode>
                     that specifies <code>required="yes"</code>.</p><note>
                     <p diff="add" at="N">This is because the name <code>xsl:initial-template</code>
                        indicates the default <termref def="dt-initial-named-template"/> for
                        stylesheet execution, and it is not possible to supply template parameters
                        to the initial template.</p>
                  </note></error>
            </p>
            <div3 id="declaring-context-item" diff="chg" at="R-bug24764">
               <head diff="chg" at="P">Declaring the Context Item for a Template</head>
               <p>The <elcode>xsl:context-item</elcode> element is used as a child of
                     <elcode>xsl:template</elcode>, to declare the required type of the context
                  item. It is intended particularly for use when the containing template is called
                  using an <elcode>xsl:call-template</elcode> instruction, but it also constrains
                  the context item if the same template is invoked using
                     <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>, or
                     <elcode>xsl:next-match</elcode>. </p>
               <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
                  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="context-item">
                  <e:attribute name="as">
                     <e:data-type name="item-type"/>
                  </e:attribute>
                  <e:attribute name="use">
                     <e:constant value="required"/>
                     <e:constant value="optional"/>
                     <e:constant value="absent"/>
                  </e:attribute>
                  <e:empty/>
                  <e:allowed-parents>
                     <e:parent name="template"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p>If the <code>as</code> attribute is present then its value must be an <xnt
                     xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                     ref="prod-xpath30-ItemType" xlink:type="simple">ItemType</xnt>. If the
                  attribute is omitted this is equivalent to specifying
                  <code>as="item()"</code>.</p>
               <p diff="add" at="S-bug27014"><error spec="XT" type="static" class="SE" code="3088"
                        ><p>It is a <termref def="dt-static-error"/> if the <code>as</code>
                        attribute is present <error.extra>on the <elcode>xsl:context-item</elcode>
                           element</error.extra> when <code>use="absent"</code> is
                     specified.</p></error></p>
               <p diff="add" at="D">A <termref def="dt-type-error"/> is signaled if the supplied
                  context item does not match its required type. No attempt is made to convert the
                  context item to the required type (using the function conversion rules or
                  otherwise). The error code is the same as for <elcode>xsl:param</elcode>:
                     <errorref spec="XT" class="TE" code="0590"/>.</p>
               <p diff="add" at="G">If an <elcode>xsl:context-item</elcode> element is present as
                  the first child element of <elcode>xsl:template</elcode>, it defines whether the
                  template requires a context item to be supplied, and if so, what the type of the
                  context item must be. If this template is the <termref
                     def="dt-initial-named-template"/>, then this has the effect of placing
                  constraints on the <termref def="dt-global-context-item">global context
                     item</termref> for the transformation as a whole.</p>
               <p diff="add" at="G">The <code>use</code> attribute of
                     <elcode>xsl:context-item</elcode> takes the value <code>required</code>,
                     <code>optional</code>, or <code diff="chg" at="S-bug27015">absent</code>.
                     <phrase diff="add" at="R-bug24529">The default is
                     <code>optional</code></phrase>.</p>
               <p>If the containing <elcode>xsl:template</elcode> element has no <code>name</code>
                  attribute then the only permitted value is <code>required</code>.</p>
               <ulist>
                  <item>
                     <p>If the value <code>required</code> is specified, then there must be a
                        context item. (This will automatically be the case if the template is
                        invoked using <elcode>xsl:apply-templates</elcode>,
                           <elcode>xsl:apply-imports</elcode>, or <elcode>xsl:next-match</elcode>,
                        but not if it is invoked using <elcode>xsl:call-template</elcode>.) </p>
                  </item>
                  <item>
                     <p>If the value <code>optional</code> is specified, or if the attribute is
                        omitted, or if the <elcode>xsl:context-item</elcode> element is omitted,
                        then there may or may not be a context item when the template is
                        invoked.</p>
                  </item>
                  <item diff="chg" at="S-bug27015">
                     <p>If the value <code>absent</code> is specified, then the contained sequence
                        constructor, and any <elcode>xsl:param</elcode> elements, are evaluated with
                        an absent focus.</p>
                     <note>
                        <p>It is not an error to call such a template with a non-absent focus; the
                           context item is simply treated as absent. This option is useful when
                           streaming, since an <elcode>xsl:call-template</elcode> instruction may
                           become streamable if the referenced template is declared to make no use
                           of the context item.</p>
                     </note>
                  </item>
               </ulist>
               <p diff="add" at="G"><phrase diff="del" at="S-bug27012">The <code>as</code> attribute
                     of the <elcode>xsl:context-item</elcode> defines the required type of the
                     context item supplied to the template if one is supplied. The default value is
                        <code>as="item()"</code>. If a context item is supplied (which will
                     automatically be the case if the template is invoked using
                        <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>, or
                        <elcode>xsl:next-match</elcode>) then it will be converted to the required
                     type by applying the <termref def="dt-function-conversion-rules">function
                        conversion rules</termref>; a <termref def="dt-type-error">type
                        error</termref>
                     <errorref spec="XT" class="TE" code="0590"/> occurs if conversion to the
                     required type is not possible.</phrase> The processor <rfc2119>may</rfc2119>
                  signal a <termref def="dt-type-error">type error</termref> statically if the
                  required context item type is incompatible with the <code>match</code> pattern,
                  that is, if no item that satisfies the match pattern can also satisfy the required
                  context item type.</p>
               <p diff="add" at="G">The <elcode>xsl:context-item</elcode> element plays no part in
                  deciding whether and when the template rule is invoked in response to an
                     <elcode>xsl:apply-templates</elcode> instruction. </p>
               <p>
                  <error spec="XT" type="type" class="TE" code="3090"><p>It is a <termref
                           def="dt-type-error">type error</termref> if the
                           <elcode>xsl:context-item</elcode> child of <elcode>xsl:template</elcode>
                        specifies that a context item is required and none is supplied by the
                        caller, that is, if the context item is absent at the point where
                           <elcode>xsl:call-template</elcode> is evaluated.</p></error>
               </p>
            </div3>
            <div3 id="call-template-params">
               <head>Passing Parameters to Named Templates</head>
               <p>Parameters are passed to named templates using the <elcode>xsl:with-param</elcode>
                  element as a child of the <elcode>xsl:call-template</elcode> instruction.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0680"><p>In the case of
                           <elcode>xsl:call-template</elcode>, it is a <termref
                           def="dt-static-error">static error</termref> to pass a non-tunnel
                        parameter named <var>x</var> to a template that does not have a <phrase
                           diff="add" at="I">non-tunnel</phrase>
                        <termref def="dt-template-parameter">template parameter</termref> named
                           <var>x</var>, unless <phrase diff="chg" at="D">the
                              <elcode>xsl:call-template</elcode> instruction is processed with
                              <termref def="dt-xslt-10-behavior">XSLT 1.0
                           behavior</termref></phrase>.</p></error> This is not an error in the case
                  of <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>, and
                     <elcode>xsl:next-match</elcode>; in these cases the parameter is simply
                  ignored.</p>
               <p>The optional <code>tunnel</code> attribute may be used to indicate that a
                  parameter is a <termref def="dt-tunnel-parameter">tunnel parameter</termref>. The
                  default is <code>no</code>. Tunnel parameters are described in <specref
                     ref="tunnel-params"/>. </p>
               <example>
                  <head>Calling a Named Template with a Parameter</head>
                  <p>This example defines a named template for a <code>numbered-block</code> with a
                     parameter to control the format of the number.</p>
                  <eg xml:space="preserve" role="xslt-declaration xmlns:fo='fo'">&lt;xsl:template name="numbered-block"&gt;
  &lt;xsl:param name="format"&gt;1. &lt;/xsl:param&gt;
  &lt;fo:block&gt;
    &lt;xsl:number format="{$format}"/&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="ol//ol/li"&gt;
  &lt;xsl:call-template name="numbered-block"&gt;
    &lt;xsl:with-param name="format"&gt;a. &lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;</eg>
               </example>
            </div3>
            <div3 id="tunnel-params">
               <head>Tunnel Parameters</head>
               <p>
                  <termdef id="dt-tunnel-parameter" term="tunnel parameter">A parameter passed to a
                     template may be defined as a <term>tunnel parameter</term>. Tunnel parameters
                     have the property that they are automatically passed on by the called template
                     to any further templates that it calls, and so on recursively.</termdef> Tunnel
                  parameters thus allow values to be set that are accessible during an entire phase
                  of stylesheet processing, without the need for each template that is used during
                  that phase to be aware of the parameter.</p>
               <note diff="chg" at="T-bug29982">
                  <p>Tunnel parameters are conceptually similar to the dynamically scoped variables
                     found in some functional programming languages (for example, early versions of
                     LISP), where evaluating a variable reference involves searching down the
                     dynamic call stack for a matching variable name. There are two main use cases
                     for the feature:</p>
                  <olist>
                     <item>
                        <p>They provide a way to supply context information that might be needed by
                           many templates (for example, the fact that the output is to be localized
                           for a particular language), but which cannot be placed in a global
                           variable because it might vary from one phase of processing to another.
                           Passing such information using conventional parameters is error-prone,
                           because a single <elcode>xsl:apply-templates</elcode> or
                              <elcode>xsl:call-template</elcode> instruction that neglects to pass
                           the information on will lead to failures that are difficult to
                           diagnose.</p>
                     </item>
                     <item>
                        <p>They are particularly useful when writing a customization layer for an
                           existing stylesheet. For example, if you want to override a template rule
                           that displays chemical formulae, you might want the new rule to be
                           parameterized so you can apply the house-style of a particular scientific
                           journal. Tunnel parameters allow you to pass this information to the
                           overriding template rule without requiring modifications to all the
                           intermediate template rules. Again, a global variable could be used, but
                           only if the same house-style is to be used for all chemical formulae
                           processed during a single transformation.</p>
                     </item>
                  </olist>
               </note>
               <p>A <termref def="dt-tunnel-parameter">tunnel parameter</termref> is created by
                  using an <elcode>xsl:with-param</elcode> element that specifies
                     <code>tunnel="yes"</code>. A template that requires access to the value of a
                  tunnel parameter must declare it using an <elcode>xsl:param</elcode> element that
                  also specifies <code>tunnel="yes"</code>.</p>
               <p>On any template call using an <elcode>xsl:apply-templates</elcode>,
                     <elcode>xsl:call-template</elcode>, <elcode>xsl:apply-imports</elcode> or
                     <elcode>xsl:next-match</elcode> instruction, a set of <termref
                     def="dt-tunnel-parameter">tunnel parameters</termref> is passed from the
                  calling template to the called template. This set consists of any parameters
                  explicitly created using <code>&lt;xsl:with-param tunnel="yes"&gt;</code>,
                  overlaid on a base set of tunnel parameters. If the
                     <elcode>xsl:apply-templates</elcode>, <elcode>xsl:call-template</elcode>,
                     <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode>
                  instruction has an <elcode>xsl:template</elcode> declaration as an ancestor
                  element in the stylesheet, then the base set consists of the tunnel parameters
                  that were passed to that template; otherwise (for example, if the instruction is
                  within a global variable declaration, an <termref def="dt-attribute-set">attribute
                     set</termref> declaration, or a <termref def="dt-stylesheet-function"
                     >stylesheet function</termref>), the base set is empty. If a parameter created
                  using <code>&lt;xsl:with-param tunnel="yes"&gt;</code> has the same <termref
                     def="dt-expanded-qname">expanded QName</termref> as a parameter in the base
                  set, then the parameter created using <elcode>xsl:with-param</elcode> overrides
                  the parameter in the base set; otherwise, the parameter created using
                     <elcode>xsl:with-param</elcode> is added to the base set.</p>
               <p>When a template accesses the value of a <termref def="dt-tunnel-parameter">tunnel
                     parameter</termref> by declaring it with <code>&lt;xsl:param
                     tunnel="yes"&gt;</code>, this does not remove the parameter from the base set
                  of tunnel parameters that is passed on to any templates called by this
                  template.</p>
               <p>Two sibling <elcode>xsl:with-param</elcode> elements <rfc2119>must</rfc2119> have
                  distinct parameter names, even if one is a <termref def="dt-tunnel-parameter"
                     >tunnel parameter</termref> and the other is not. Equally, two sibling
                     <elcode>xsl:param</elcode> elements representing <termref
                     def="dt-template-parameter">template parameters</termref>
                  <rfc2119>must</rfc2119> have distinct parameter names, even if one is a <termref
                     def="dt-tunnel-parameter">tunnel parameter</termref> and the other is not.
                  However, the tunnel parameters that are implicitly passed in a template call
                     <rfc2119>may</rfc2119> have names that duplicate the names of non-tunnel
                  parameters that are explicitly passed on the same call.</p>
               <p>
                  <termref def="dt-tunnel-parameter">Tunnel parameters</termref> are not passed in
                  calls to <termref def="dt-stylesheet-function">stylesheet functions</termref>.</p>
               <p>All other options of <elcode>xsl:with-param</elcode> and
                     <elcode>xsl:param</elcode> are available with <termref
                     def="dt-tunnel-parameter">tunnel parameters</termref> just as with non-tunnel
                  parameters. For example, parameters may be declared as mandatory or optional, a
                  default value may be specified, and a required type may be specified. If any
                  conversion is required from the supplied value of a tunnel parameter to the
                  required type specified in <elcode>xsl:param</elcode>, then the converted value is
                  used within the receiving template, but the value that is passed on in any further
                  template calls is the original supplied value before conversion. Equally, any
                  default value is local to the template: specifying a default value for a tunnel
                  parameter does not change the set of tunnel parameters that is passed on in
                  further template calls.</p>
               <p diff="del" at="R">The set of <termref def="dt-tunnel-parameter">tunnel
                     parameters</termref> that is passed to the <termref
                     def="dt-initial-named-template"/> is empty.</p>
               <p>
                  <termref def="dt-tunnel-parameter">Tunnel parameters</termref> are passed
                  unchanged through a built-in template rule (see <specref ref="built-in-rule"
                  />).</p>
               <p diff="add" at="D">If a tunnel parameter is declared in an
                     <elcode>xsl:param</elcode> element with the attribute
                  <code>tunnel="yes"</code>, <phrase diff="add" at="T-bug29981">and if the parameter
                     is <termref def="dt-explicitly-mandatory">explicitly</termref> or <termref
                        def="dt-implicitly-mandatory">implicitly</termref> mandatory,</phrase> then
                  a <phrase diff="del" at="M">non-recoverable</phrase> dynamic error occurs
                     <errorref spec="XT" class="DE" code="0700"/> if the set of tunnel parameters
                  passed to the template does not include a parameter with a matching <termref
                     def="dt-expanded-qname">expanded QName</termref>.</p>
               <example>
                  <head>Using Tunnel Parameters</head>
                  <p>Suppose that the equations in a scientific paper are to be sequentially
                     numbered, but that the format of the number depends on the context in which the
                     equations appear. It is possible to reflect this using a rule of the form:</p>
                  <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="equation"&gt;
  &lt;xsl:param name="equation-format" select="'(1)'" tunnel="yes"/&gt;
  &lt;xsl:number level="any" format="{$equation-format}"/&gt;
&lt;/xsl:template&gt;</eg>
                  <p>At any level of processing above this level, it is possible to determine how
                     the equations will be numbered, for example:</p>
                  <eg xml:space="preserve" role="non-xml">&lt;xsl:template match="appendix"&gt;
  ...
  &lt;xsl:apply-templates&gt;
    &lt;xsl:with-param name="equation-format" select="'[i]'" tunnel="yes"/&gt;
  &lt;/xsl:apply-templates&gt;
  ...
&lt;/xsl:template&gt;</eg>
                  <p>The parameter value is passed transparently through all the intermediate layers
                     of template rules until it reaches the rule with <code>match="equation"</code>.
                     The effect is similar to using a global variable, except that the parameter can
                     take different values during different phases of the transformation.</p>
               </example>
            </div3>
         </div2>
         <div2 id="attribute-sets">
            <head>Named Attribute Sets</head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="attribute-set">
               <e:in-category name="declaration"/>
               <e:attribute name="name" required="yes">
                  <e:data-type name="eqname"/>
               </e:attribute>
               <e:attribute name="use-attribute-sets">
                  <e:data-type name="eqnames"/>
               </e:attribute>
               <e:attribute name="visibility">
                  <e:constant value="public"/>
                  <e:constant value="private"/>
                  <e:constant value="final"/>
                  <e:constant value="abstract"/>
               </e:attribute>
               <e:attribute name="streamable">
                  <e:data-type name="boolean"/>
               </e:attribute>
               <e:element repeat="zero-or-more" name="attribute"/>
               <e:allowed-parents>
                  <e:parent name="package"/>
                  <e:parent name="stylesheet"/>
                  <e:parent name="transform"/>
                  <e:parent name="override"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p diff="chg" at="P-bug22747">Attribute sets <phrase diff="chg" at="Q-bug23932"
                  >generate</phrase> named collections of attributes that can be used repeatedly on
               different constructed elements. The <elcode>xsl:attribute-set</elcode> declaration is
               used to declare attribute sets. The <rfc2119>required</rfc2119>
               <code>name</code> attribute specifies the name of the attribute set. The value of the
                  <code>name</code> attribute is an <code>EQName</code>, which is expanded as
               described in <specref ref="qname"/>.</p>
            <p diff="chg" at="P-bug22747">
               <termdef id="dt-attribute-set" term="attribute set">An <term>attribute set</term> is
                  defined as a set of <elcode>xsl:attribute-set</elcode> declarations in the same
                     <termref def="dt-package"/> that share the same <termref
                     def="dt-expanded-qname"/>.</termdef>
            </p>
            <p>The content of the <elcode>xsl:attribute-set</elcode> element consists of zero or
               more <elcode>xsl:attribute</elcode> instructions that are evaluated to produce the
               attributes in the set.</p>
            <div3 id="using-attribute-sets">
               <head>Using Attribute Sets</head>
               <p>
                  <termref def="dt-attribute-set">Attribute sets</termref> are used by specifying a
                     <code>use-attribute-sets</code> attribute on the <elcode>xsl:element</elcode>
                  or <elcode>xsl:copy</elcode> instruction, or by specifying an
                     <code>xsl:use-attribute-sets</code> attribute on a literal result element. An
                  attribute set may be defined in terms of other attribute sets by using the
                     <code>use-attribute-sets</code> attribute on the
                     <elcode>xsl:attribute-set</elcode> element itself. The value of the
                     <code>[xsl:]use-attribute-sets</code> attribute is in each case a
                  whitespace-separated list of names of attribute sets. Each name is specified as an
                     <phrase diff="chg" at="K"><termref def="dt-eqname">EQName</termref></phrase>,
                  which is expanded as described in <specref ref="qname"/>.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0710"><p>It is a <termref
                           def="dt-static-error">static error</termref> if the value of the
                           <code>use-attribute-sets</code> attribute of an
                        <elcode>xsl:copy</elcode>, <elcode>xsl:element</elcode>, or
                           <elcode>xsl:attribute-set</elcode> element, or the
                           <code>xsl:use-attribute-sets</code> attribute of a <termref
                           def="dt-literal-result-element">literal result element</termref>, is not
                        a whitespace-separated sequence of <phrase diff="chg" at="K"><termref
                              def="dt-eqname">EQNames</termref></phrase>, or if it contains an
                        EQName that does not match the <code>name</code> attribute of any
                           <elcode>xsl:attribute-set</elcode> declaration in the <phrase diff="chg"
                           at="R-bug24763">containing <termref def="dt-package"
                           >package</termref></phrase>.</p></error>
               </p>
               <p diff="add" at="S-bug27624">An <termref def="dt-attribute-set"/> may be considered
                  as comprising a sequence of instructions, each of which is either an
                     <elcode>xsl:attribute</elcode> instruction or an <termref
                     def="dt-attribute-set-invocation"/>. Starting with the declarations making up
                  an attribute set, this sequence of instructions can be generated by the following
                  rules: </p>
               <olist diff="add" at="S-bug27624">
                  <item>
                     <p>The relevant attribute set <termref def="dt-declaration"
                           >declarations</termref> (that is, all declarations of attribute sets
                        within a package sharing the same <termref def="dt-expanded-qname"/>) are
                        considered in order: first in increasing order of <termref
                           def="dt-import-precedence"/>, and within each precedence, in <termref
                           def="dt-declaration-order"/>. </p>
                  </item>
                  <item>
                     <p>Each declaration is expanded to a sequence of instructions as follows.
                        First, one <termref def="dt-attribute-set-invocation"/> is generated for
                        each EQName present in the <code>use-attribute-sets</code> attribute, if
                        present, retaining the order in which the EQNames appear. This is followed
                        by the sequence of contained <elcode>xsl:attribute</elcode> instructions, in
                        order. </p>
                     <p><termdef id="dt-attribute-set-invocation" term="attribute set invocation">An
                              <term>attribute set invocation</term> is a pseudo-instruction
                           corresponding to a single EQName appearing within an
                              <code>[xsl:]use-attribute-sets</code> attribute; the effect of the
                           pseudo-instruction is to cause the referenced <termref
                              def="dt-attribute-set"/> to be evaluated.</termdef></p>
                  </item>
               </olist>
               <p diff="add" at="S-bug27624">Similarly, an <code>[xsl:]use-attribute-sets</code>
                  attribute of an <elcode>xsl:copy</elcode>, <elcode>xsl:element</elcode>, or
                     <elcode>xsl:attribute-set</elcode> element, or of a literal result element, is
                  expanded to a sequence of <termref def="dt-attribute-set-invocation">attribute set
                     invocations</termref>, one for each EQName in order. </p>
               <p diff="add" at="S-bug27624">An <termref def="dt-attribute-set"/> is a named
                     <termref def="dt-component"/>, and the binding of QNames appearing in an
                     <termref def="dt-attribute-set-invocation"/> to attribute set components
                  follows the rules in <specref ref="component-references"/>. </p>
               <p diff="add" at="S-bug27624">The following two (mutually recursive) rules define how
                  an <code>[xsl:]use-attribute-set</code> attribute is expanded:</p>
               <olist diff="add" at="S-bug27624">
                  <item>
                     <p>An <termref def="dt-attribute-set"/> is evaluated by evaluating each of the
                        contained <termref def="dt-attribute-set-invocation">attribute set
                           invocations</termref> and <elcode>xsl:attribute</elcode> instructions in
                        order, to deliver a sequence of attribute nodes. </p>
                  </item>
                  <item>
                     <p>An <termref def="dt-attribute-set-invocation"/> is evaluated by evaluating
                        the <termref def="dt-attribute-set"/> to which it is bound, as determined by
                        the rules in <specref ref="component-references"/>. </p>
                  </item>
               </olist>
               <p diff="add" at="S-bug28114">For rules regarding cycles in attribute set
                  declarations, see <specref ref="circularity"/>.</p>
               <note diff="add" at="S-bug27624">
                  <p>The effect of an <termref def="dt-attribute-set-invocation"/> on the dynamic
                     context is the same as the effect of an <elcode>xsl:call-template</elcode>
                     instruction. In particular, it does not change the <termref def="dt-focus"/>.
                     Although attribute sets are often defined with fixed values, or with values
                     that depend only on global variables, it is possible to define an attribute set
                     in such a way that the values of the constructed attributes are dependent on
                     the context item.</p>
               </note>
               <note diff="add" at="S-bug27624">
                  <p>In all cases the result of evaluating an <termref def="dt-attribute-set"/> is
                     subsequently used to create the attributes of an element node, using the rules
                     in <specref ref="constructing-complex-content"/>. The effect of those rules is
                     that when the result of evaluating the attribute set contains attributes with
                     duplicate names, the last duplicate wins. The optimization rules allow a
                     processor to avoid evaluating or validating an attribute if it is able to
                     determine that the attribute will subsequently be discarded as a duplicate.
                  </p>
               </note>
            </div3>
            <div3 id="visibility-of-attribute-sets">
               <head>Visibility of Attribute Sets</head>
               <p diff="chg" at="P-bug22747">The <code>visibility</code> attribute determines the
                  potential visibility of the attribute set in packages other than the containing
                  package. If the <code>visibility</code> attribute is present on any of the
                     <elcode>xsl:attribute-set</elcode> declarations making up the definition of an
                     <termref def="dt-attribute-set"/> (that is, all declarations within the same
                  package sharing the same name), then it <rfc2119>must</rfc2119> be present, with
                  the same value, on every <elcode>xsl:attribute-set</elcode> declaration making up
                  the definition of that <termref def="dt-attribute-set"/>.</p>
               <p diff="add" at="I">If the <code>visibility</code> attribute is present with the
                  value <code>abstract</code> then there must be no <elcode>xsl:attribute</elcode>
                  children <phrase diff="add" at="O">and no <code>use-attribute-sets</code>
                     attribute</phrase>.</p>
            </div3>
            <div3 id="streamability-of-attribute-sets" diff="add" at="P-bug22721">
               <head>Streamability of Attribute Sets</head>
               <p>An <termref def="dt-attribute-set">attribute set</termref> may be designated as
                  streamable by including the attribute <code>streamable="yes"</code> on each
                     <elcode>xsl:attribute-set</elcode> declaration making up the attribute set. If
                  any <elcode>xsl:attribute-set</elcode> declaration for an attribute set has the
                  attribute <code>streamable="yes"</code>, then every
                     <elcode>xsl:attribute-set</elcode> declaration for that attribute set
                     <rfc2119>must</rfc2119> have the attribute <code>streamable="yes"</code>.</p>
               <p diff="chg" at="Q">An <termref def="dt-attribute-set">attribute set</termref> is
                     <termref def="dt-guaranteed-streamable"/> if all the following conditions are
                  satisfied:</p>
               <olist>
                  <item>
                     <p diff="add" at="R-bug24649">Every <elcode>xsl:attribute-set</elcode>
                        declaration for the attribute set has the attribute
                           <code>streamable="yes"</code>.</p>
                  </item>
                  <item>
                     <p>Every <elcode>xsl:attribute-set</elcode> declaration for the attribute set
                           <phrase diff="chg" at="T-bug29492"> is <termref def="dt-grounded"/>
                           and</phrase>
                        <termref def="dt-motionless"/> according to the analysis in <specref
                           ref="classifying-attribute-sets"/>.</p>
                  </item>
               </olist>
               <p diff="add" at="Q">Specifying <code>streamable="yes"</code> on an
                     <elcode>xsl:attribute-set</elcode> element declares an intent that the
                  attribute set should be <phrase diff="chg" at="S-bug27273">streamable, either
                     because it is <termref def="dt-guaranteed-streamable"/>, or because it takes
                     advantage of streamability extensions offered by a particular
                     processor</phrase>. The consequences of declaring the attribute set to be
                  streamable when it is not in fact guaranteed streamable depend on the conformance
                  level of the processor, and are explained in <specref
                     ref="streamability-guarantees"/>.</p>
               <p diff="add" at="R-bug24144"><error spec="XT" type="static" class="SE" code="0730"
                        ><p>If an <elcode>xsl:attribute</elcode> set element specifies
                           <code>streamable="yes"</code> then every attribute set referenced in its
                           <code>use-attribute-sets</code> attribute (if present) must also specify
                           <code>streamable="yes"</code>.</p></error></p>
               <note diff="chg" at="Q">
                  <p>It is common for attribute sets to create attributes with constant values, and
                     such attribute sets will always be grounded and motionless and therefore
                     streamable. Although such cases are fairly simple for a processor to detect,
                     references to attribute sets are not guaranteed streamable unless the attribute
                     set is declared with the attribute <code>streamable="yes"</code>, which should
                     therefore be used if interoperable streaming is required.</p>
               </note>
            </div3>
            <div3 id="evaluating-attribute-sets">
               <head>Evaluating Attribute Sets</head>
               <p>Attribute sets are evaluated as follows:</p>
               <ulist>
                  <item>
                     <p>The <elcode>xsl:copy</elcode> and <elcode>xsl:element</elcode> instructions
                        have a <code>use-attribute-sets</code> attribute. The sequence of attribute
                        nodes produced by evaluating this attribute is prepended to the sequence
                        produced by evaluating the <termref def="dt-sequence-constructor">sequence
                           constructor</termref> contained within the instruction.</p>
                  </item>
                  <item>
                     <p>
                        <termref def="dt-literal-result-element">Literal result elements</termref>
                        allow an <code>xsl:use-attribute-sets</code> attribute, which is evaluated
                        in the same way as the <code>use-attribute-sets</code> attribute of
                           <elcode>xsl:element</elcode> and <elcode>xsl:copy</elcode>. The sequence
                        of attribute nodes produced by evaluating this attribute is prepended to the
                        sequence of attribute nodes produced by evaluating the attributes of the
                        literal result element, which in turn is prepended to the sequence produced
                        by evaluating the <termref def="dt-sequence-constructor">sequence
                           constructor</termref> contained with the literal result element.</p>
                  </item>
               </ulist>
               <p>The <elcode>xsl:attribute</elcode> instructions are evaluated using the same
                     <termref def="dt-focus">focus</termref> as is used for evaluating the <phrase
                     diff="add" at="T-bug29480"><termref def="dt-sequence-constructor"/> contained
                     by the</phrase> element that is the parent of the
                     <code>[xsl:]use-attribute-sets</code> attribute forming the initial input to
                  the algorithm. However, the static context for the evaluation depends on the
                  position of the <elcode>xsl:attribute</elcode> instruction in the stylesheet:
                  thus, only local variables declared within an <elcode>xsl:attribute</elcode>
                  instruction, and global variables, are visible.</p>
               <note diff="add" at="T-bug29480">
                  <p>The above rule means that for an <elcode>xsl:copy</elcode> element with a
                        <code>select</code> attribute, the focus for evaluating any referenced
                     attribute sets is the node selected by the <code>select</code> attribute,
                     rather than the context item of the <elcode>xsl:copy</elcode> instruction.</p>
               </note>
               <p>The set of attribute nodes produced by expanding
                     <code>xsl:use-attribute-sets</code> may include several attributes with the
                  same name. When the attributes are added to an element node, only the last of the
                  duplicates will take effect.</p>
               <p>The way in which each instruction uses the results of expanding the
                     <code>[xsl:]use-attribute-sets</code> attribute is described in the
                  specification for the relevant instruction: see <specref
                     ref="literal-result-element"/>, <specref ref="xsl-element"/>, and <specref
                     ref="copying"/>.</p>
               <p>The result of evaluating an attribute set is a sequence of attribute nodes.
                  Evaluating the same attribute set more than once can produce different results,
                  because although an attribute set does not have parameters, it may contain
                  expressions or instructions whose value depends on the evaluation context.</p>
               <p>Each attribute node produced by expanding an attribute set has a <termref
                     def="dt-type-annotation"/> determined by the rules for the
                     <elcode>xsl:attribute</elcode> instruction that created the attribute node: see
                     <specref ref="annotation-for-constructed-attribute"/>. These type annotations
                  may be preserved, stripped, or replaced as determined by the rules for the
                  instruction that creates the element in which the attributes are used.</p>
            </div3>
            <div3 id="attribute-sets-examples">
               <head>Attribute Sets: Examples</head>
               <example>
                  <head>A Simple Attribute Set</head>
                  <p>The following example creates a named <termref def="dt-attribute-set">attribute
                        set</termref>
                     <code>title-style</code> and uses it in a <termref def="dt-template-rule"
                        >template rule</termref>.</p>
                  <eg xml:space="preserve" role="xslt-declaration xmlns:fo='fo'">&lt;xsl:template match="chapter/heading"&gt;
  &lt;fo:block font-stretch="condensed" xsl:use-attribute-sets="title-style"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:attribute-set name="title-style"&gt;
  &lt;xsl:attribute name="font-size"&gt;12pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-weight"&gt;bold&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;</eg>
               </example>
               <example>
                  <head>Overriding Attributes in an Attribute Set</head>
                  <p>The following example creates a named attribute set <code>base-style</code> and
                     uses it in a template rule with multiple specifications of the attributes:</p>
                  <glist>
                     <gitem>
                        <label>font-family</label>
                        <def>
                           <p>is specified only in the attribute set</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label>font-size</label>
                        <def>
                           <p>is specified in the attribute set, is specified on the literal result
                              element, and in an <elcode>xsl:attribute</elcode> instruction</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label>font-style</label>
                        <def>
                           <p>is specified in the attribute set, and on the literal result
                              element</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label>font-weight</label>
                        <def>
                           <p>is specified in the attribute set, and in an
                                 <elcode>xsl:attribute</elcode> instruction</p>
                        </def>
                     </gitem>
                  </glist>
                  <p>Stylesheet fragment:</p>
                  <eg xml:space="preserve" role="xslt-declaration xmlns:fo='fo'">&lt;xsl:attribute-set name="base-style"&gt;
  &lt;xsl:attribute name="font-family"&gt;Univers&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-size"&gt;10pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-style"&gt;normal&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-weight"&gt;normal&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;

&lt;xsl:template match="o"&gt;
  &lt;fo:block xsl:use-attribute-sets="base-style"
            font-size="12pt"
            font-style="italic"&gt;
    &lt;xsl:attribute name="font-size"&gt;14pt&lt;/xsl:attribute&gt;
    &lt;xsl:attribute name="font-weight"&gt;bold&lt;/xsl:attribute&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</eg>
                  <p>Result:</p>
                  <eg xml:space="preserve" role="non-xml">&lt;fo:block font-family="Univers"
          font-size="14pt"
          font-style="italic"
          font-weight="bold"&gt;
...
&lt;/fo:block&gt;
</eg>
               </example>
            </div3>
            <div3 id="attribute-set-cycles" diff="del" at="S-bug28114">
               <head>Cycles in Attribute Sets</head>
               <p>Cycles in <termref def="dt-attribute-set">attribute sets</termref> (that is, where
                  an attribute set directly or indirectly invokes itself) are not permitted, and are
                  detected statically. </p>
               <p>An <termref def="dt-attribute-set"/>
                  <var>A</var> is dependent on an <termref def="dt-attribute-set"/>
                  <var>B</var> if <var>A</var> contains an <termref
                     def="dt-attribute-set-invocation"/> that is bound to <var>B</var>, or if
                     <var>A</var> contains an <termref def="dt-attribute-set-invocation"/> that is
                  bound to an <termref def="dt-attribute-set"/>
                  <var>C</var> that is dependent on <var>B</var>. A cycle exists if any <termref
                     def="dt-attribute-set"/> is dependent on itself. </p>
               <p>Such a cycle is an error even if the attribute set is never invoked, and even if
                  the cycle is subsequently broken by overriding one or more of the attribute sets
                  participating in the cycle. As a consequence, it is possible to detect a cycle
                  during the static analysis of a <termref def="dt-package"/>, before it is known
                  how the package will be used. </p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0720"><p>It is a <termref
                           def="dt-static-error">static error</termref> if an attribute set is
                        dependent on itself.</p></error>
               </p>
            </div3>
         </div2>
         <div2 id="stylesheet-functions">
            <head>Stylesheet Functions</head>
            <p>
               <termdef id="dt-stylesheet-function" term="stylesheet function">An
                     <elcode>xsl:function</elcode> declaration declares the name, parameters, and
                  implementation of a <term>stylesheet function</term> that can be called from any
                  XPath <termref def="dt-expression">expression</termref> within the <termref
                     def="dt-stylesheet">stylesheet</termref>
                  <phrase diff="add" at="R-bug24763">(subject to visibility
                  rules)</phrase>.</termdef>
            </p>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="function">
               <e:in-category name="declaration"/>
               <e:attribute name="name" required="yes">
                  <e:data-type name="eqname"/>
               </e:attribute>
               <e:attribute name="as" required="no">
                  <e:data-type name="sequence-type"/>
               </e:attribute>
               <e:attribute name="visibility" required="no">
                  <e:constant value="public"/>
                  <e:constant value="private"/>
                  <e:constant value="final"/>
                  <e:constant value="abstract"/>
               </e:attribute>
               <e:attribute name="streamability" required="no">
                  <e:constant value="unclassified"/>
                  <e:constant value="absorbing"/>
                  <e:constant value="inspection"/>
                  <e:constant value="filter"/>
                  <e:constant value="shallow-descent"/>
                  <e:constant value="deep-descent"/>
                  <e:constant value="ascent"/>
                  <e:data-type name="eqname"/>
               </e:attribute>
               <e:attribute name="override-extension-function" required="no">
                  <e:data-type name="boolean"/>
               </e:attribute>
               <e:attribute name="override" required="no" deprecated="yes">
                  <e:data-type name="boolean"/>
               </e:attribute>
               <e:attribute name="new-each-time" required="no">
                  <e:constant value="yes"/>
                  <e:constant value="true"/>
                  <e:constant value="1"/>
                  <e:constant value="no"/>
                  <e:constant value="false"/>
                  <e:constant value="0"/>
                  <e:constant value="maybe"/>
               </e:attribute>
               <e:attribute name="cache" required="no">
                  <e:data-type name="boolean"/>
               </e:attribute>
               <e:sequence>
                  <e:element repeat="zero-or-more" name="param"/>
                  <e:model name="sequence-constructor"/>
               </e:sequence>
               <e:allowed-parents>
                  <e:parent name="package"/>
                  <e:parent name="stylesheet"/>
                  <e:parent name="transform"/>
                  <e:parent name="override"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:function</elcode> declaration defines a <termref
                  def="dt-stylesheet-function">stylesheet function</termref> that can be called from
               any XPath <termref def="dt-expression">expression</termref> used in the <termref
                  def="dt-stylesheet">stylesheet</termref> (including an XPath expression used
               within a predicate in a <termref def="dt-pattern">pattern</termref>). The
                  <code>name</code> attribute specifies the name of the function. The value of the
                  <code>name</code> attribute is an <phrase diff="chg" at="K"><termref
                     def="dt-eqname">EQName</termref></phrase>, which is expanded as described in
                  <specref ref="qname"/>.</p>
            <p>An <elcode>xsl:function</elcode> declaration can only appear as a <termref
                  def="dt-top-level"/> element in a stylesheet module.</p>
            <p>The content of the <elcode>xsl:function</elcode> element consists of zero or more
                  <elcode>xsl:param</elcode> elements that specify the formal arguments of the
               function, followed by a <termref def="dt-sequence-constructor">sequence
                  constructor</termref> that defines the value to be returned by the function.</p>
            <div3 id="xsl-function-name">
               <head>Function Name and Arity</head>
               <p diff="add" at="M">The name of the function is given by the <code>name</code>
                  attribute; the arguments are defined by child <elcode>xsl:param</elcode> elements;
                  and the return type is defined by the <code>as</code> attribute. Together these
                  definitions constitute the <emph>function signature</emph>.</p>
               <p diff="add" at="L">
                  <error spec="XT" type="static" class="SE" code="0740"><p>It is a <termref
                           def="dt-static-error">static error</termref> if a <termref
                           def="dt-stylesheet-function">stylesheet function</termref> has a name
                        that is in no namespace.</p></error></p>
               <note>
                  <p>To prevent the namespace declaration used for the function name appearing in
                     the result document, use the <code>exclude-result-prefixes</code> attribute on
                     the <elcode>xsl:stylesheet</elcode> element: see <specref ref="lre-namespaces"
                     />.</p>
                  <p>The name of the function must not be in a <termref def="dt-reserved-namespace"
                        >reserved namespace</termref>: <errorref spec="XT" class="SE" code="0080"/>
                  </p>
               </note>
               <p>
                  <termdef id="dt-arity" term="arity">The <term>arity</term> of a stylesheet
                     function is the number of <elcode>xsl:param</elcode> elements in the function
                     definition.</termdef> Optional arguments are not allowed.</p>
               <note>
                  <p>Functions are not polymorphic. Although the XPath function call mechanism
                     allows two functions to have the same name and different <termref
                        def="dt-arity">arity</termref>, it does not allow them to be distinguished
                     by the types of their arguments.</p>
               </note>
            </div3>
            <div3 id="function-arguments">
               <head>Arguments</head>
               <p>The <elcode>xsl:param</elcode> elements define the formal parameters to the
                  function. These are interpreted positionally. When the function is called using a
                  function call in an XPath <termref def="dt-expression">expression</termref>, the
                  first argument supplied is assigned to the first <elcode>xsl:param</elcode>
                  element, the second argument supplied is assigned to the second
                     <elcode>xsl:param</elcode> element, and so on.</p>
               <p diff="chg" at="T-bug29980">Because arguments to a stylesheet function call
                     <rfc2119>must</rfc2119> all be specified, the <elcode>xsl:param</elcode>
                  elements within an <elcode>xsl:function</elcode> element <rfc2119>must
                     not</rfc2119> specify a default value: this means they <rfc2119>must</rfc2119>
                  be empty, and <rfc2119>must not</rfc2119> have a <code>select</code>
                  attribute.</p>
               <p diff="chg" at="T-bug29980">
                  <error spec="XT" type="static" class="SE" code="0760"><p>It is a static error if
                        an <elcode>xsl:param</elcode> child of an <elcode>xsl:function</elcode>
                        element has either a <code>select</code> attribute or non-empty
                     content.</p></error>
               </p>
               <p>The <code>as</code> attribute of the <elcode>xsl:param</elcode> element defines
                  the required type of the parameter. The rules for converting the values of the
                  actual arguments supplied in the function call to the types required by each
                     <elcode>xsl:param</elcode> element, <phrase diff="add" at="S-bug28371">and the
                     errors that can occur,</phrase> are defined in <bibref ref="xpath-30"/>. The
                  rules that apply are those for the case where <termref def="dt-xpath-compat-mode"
                     >XPath 1.0 compatibility mode</termref> is set to <code>false</code>.</p>
               <p diff="del" at="S-bug28371">
                  <error spec="XT" type="type" class="TE" code="0790"><p>If the value of an argument
                        to a <termref def="dt-stylesheet-function">stylesheet function</termref>
                        cannot be converted to the required type, a <termref def="dt-type-error"
                           >type error</termref> is signaled.</p></error>
               </p>
               <p>If the <code>as</code> attribute is omitted, no conversion takes place and any
                  value is accepted.</p>
            </div3>
            <div3 id="function-result">
               <head>Function Result</head>
               <p>The result of the function is the result of evaluating the contained <termref
                     def="dt-sequence-constructor"/>.</p>
               <p>Within the sequence constructor, the <termref def="dt-focus">focus</termref> is
                  initially <termref def="dt-absent">absent</termref>; this means that any attempt
                  to reference the context item, context position, or context size is a <termref
                     def="dt-dynamic-error"><phrase diff="del" at="M">non-recoverable</phrase>
                     dynamic error</termref>. (See <xerrorref spec="XP30" class="DY" code="0002"
                  />.)</p>
               <p>It is not possible within the body of the <termref def="dt-stylesheet-function"
                     >stylesheet function</termref> to access the values of local variables that
                  were in scope in the place where the function call was written. Global variables,
                  however, remain available.</p>
               <p>The optional <code>as</code> attribute indicates the <termref
                     def="dt-required-type">required type</termref> of the result of the function.
                  The value of the <code>as</code> attribute is a <phrase diff="chg" at="S-bug29079"
                        ><termref def="dt-sequence-type"/></phrase>.</p>
               <p>
                  <error spec="XT" type="type" class="TE" code="0780"><p>If the <code>as</code>
                        attribute <error.extra>of <elcode>xsl:function</elcode>
                        </error.extra> is specified, then the result evaluated by the <termref
                           def="dt-sequence-constructor">sequence constructor</termref> (see
                           <specref ref="sequence-constructors"/>) is converted to the required
                        type, using the <termref def="dt-function-conversion-rules">function
                           conversion rules</termref>. It is a <termref def="dt-type-error">type
                           error</termref> if this conversion fails.</p></error> If the
                     <code>as</code> attribute is omitted, the calculated result is used as
                  supplied, and no conversion takes place.</p>
            </div3>
            <div3 id="function-visibility-and-overriding">
               <head>Visibility and Overriding of Functions</head>
               <p diff="add" at="I">If the <code>visibility</code> attribute is present with the
                  value <code>abstract</code> then the <termref def="dt-sequence-constructor"/>
                  defining the function body <rfc2119>must</rfc2119> be empty.</p>
               <p>The XPath specification states that the function that is executed as the result of
                  a function call is identified by looking in the in-scope functions of the static
                  context for a function whose name and <termref def="dt-arity">arity</termref>
                  matches the name and number of arguments in the function call. <phrase diff="add"
                     at="S+">In XSLT 3.0, final determination of the function to be called cannot be
                     made until all packages have been assembled: see <specref
                        ref="component-references"/>.</phrase></p>
               <p>An <elcode>xsl:function</elcode> declaration defines a <termref
                     def="dt-stylesheet-function">stylesheet function</termref> which forms a
                     <termref def="dt-component"/> in its containing <termref def="dt-package"/>,
                  unless </p>
               <ulist>
                  <item>
                     <p>there is another <termref def="dt-stylesheet-function">stylesheet
                           function</termref> with the same name and <termref def="dt-arity"
                           >arity</termref>, and higher <termref def="dt-import-precedence">import
                           precedence</termref>, or</p>
                  </item>
                  <item>
                     <p>the <code>override-extension-function</code> or <code>override</code>
                        attribute has the value <code>no</code> and there is already a function with
                        the same name and <termref def="dt-arity">arity</termref> in the in-scope
                        functions.</p>
                  </item>
               </ulist>
               <p diff="add" at="I">The <termref def="dt-visibility">visibility</termref> of the
                  function in other packages depends on the value of the <code>visibility</code>
                  attribute and other factors, as described in <specref ref="packages"/>.</p>
               <p>The optional <phrase diff="chg" at="M"
                     ><code>override-extension-function</code></phrase> attribute defines what
                  happens if this function has the same name and <termref def="dt-arity"
                     >arity</termref> as a function provided by the implementer or made available in
                  the static context using an implementation-defined mechanism. If the <phrase
                     diff="chg" at="M"><code>override-extension-function</code></phrase> attribute
                  has the value <code>yes</code>, then this function is used in preference; if it
                  has the value <code>no</code>, then the other function is used in preference. The
                  default value is <code>yes</code>.</p>
               <note>
                  <p>Specifying <phrase diff="chg" at="M"
                           ><code>override-extension-function="yes"</code></phrase> ensures
                     interoperable behavior: the same code will execute with all processors.
                     Specifying <phrase diff="chg" at="M"
                           ><code>override-extension-function="no"</code></phrase> is useful when
                     writing a fallback implementation of a function that is available with some
                     processors but not others: it allows the vendor’s implementation of the
                     function (or a user’s implementation written as an extension function) to be
                     used in preference to the stylesheet implementation, which is useful when the
                     extension function is more efficient.</p>
                  <p>The <code>override-extension-function</code> attribute does <emph>not</emph>
                     affect the rules for deciding which of several <termref
                        def="dt-stylesheet-function">stylesheet functions</termref> with the same
                     name and <termref def="dt-arity">arity</termref> takes precedence.</p>
               </note>
               <p diff="add" at="M">The <code>override</code> attribute is a <termref
                     def="dt-deprecated"/> synonym of <code>override-extension-function</code>,
                  retained for compatibility with XSLT 2.0. If both attributes are present then they
                     <rfc2119>must</rfc2119> have the same value.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0770"><p>It is a <termref
                           def="dt-static-error">static error</termref> for a <phrase diff="chg"
                           at="N"><termref def="dt-package">package</termref></phrase> to contain
                        two or more <phrase diff="chg" at="S+"><elcode>xsl:function</elcode>
                           declarations</phrase> with the same <termref def="dt-expanded-qname"
                           >expanded QName</termref>, the same <termref def="dt-arity"
                           >arity</termref>, and the same <termref def="dt-import-precedence">import
                           precedence</termref>, unless there is another <phrase diff="chg" at="S+"
                              ><elcode>xsl:function</elcode> declaration</phrase> with the same
                           <termref def="dt-expanded-qname">expanded QName</termref> and arity, and
                        a higher import precedence.</p></error>
               </p>
               <p diff="add" at="I">When the <elcode>xsl:function</elcode> declaration appears as a
                  child of <elcode>xsl:override</elcode>, there <rfc2119>must</rfc2119> be a
                  stylesheet function with the same <termref def="dt-expanded-qname">expanded
                     QName</termref> and <termref def="dt-arity">arity</termref> in the <termref
                     def="dt-package">package</termref> referenced by the containing
                     <elcode>xsl:use-package</elcode> element; the <termref def="dt-visibility"
                     >visibility</termref> of that function must be <code>public</code> or
                     <code>abstract</code>, and the overriding and overridden functions
                     <rfc2119>must</rfc2119> have the same argument types and result type.</p>
            </div3>
            <div3 id="streamability-of-stylesheet-functions" diff="chg" at="S-bug27571">
               <head>Streamability of Stylesheet Functions</head>
               <p>The <code>streamability</code> attribute of <elcode>xsl:function</elcode> is used
                  to assign the function to one of a number of <termref
                     def="dt-streamability-category">streamability categories</termref>. The various
                  categories, and their effect on the streamability of function calls, are described
                  in <specref ref="streamable-stylesheet-functions"/>.</p>
               <p>The streamability category of a function characterizes the way in which the
                  function processes any streamed nodes supplied in the first argument to the
                  function. (In general, streamed nodes cannot be supplied in other arguments,
                  unless they are atomized by the <termref def="dt-function-conversion-rules"/>.)
                  The <code>streamability</code> attribute is therefore not applicable unless the
                  function takes at least one argument.</p>
               <p><error spec="XT" type="dynamic" class="SE" code="3155"><p>It is a static error if
                        an <elcode>xsl:function</elcode> element with no <elcode>xsl:param</elcode>
                        children has a <code>streamability</code> attribute with any value other
                        than <code>unclassified</code>.</p></error></p>
            </div3>
            <div3 id="function-lookup">
               <head>Dynamic Access to Functions</head>
               <p diff="add" at="M">If a <termref def="dt-stylesheet-function">stylesheet
                     function</termref> with a particular <termref def="dt-expanded-qname">expanded
                     QName</termref> and <termref def="dt-arity">arity</termref> exists in the
                  stylesheet, then a call to the <xfunction>function-lookup</xfunction> function
                  supplying that name and arity will return the function as a value. This applies
                  only if the static context for the call on <xfunction>function-lookup</xfunction>
                  includes the stylesheet function, which implies that the function is visible in
                  the containing package.</p>
               <p diff="chg" at="M">The <function>function-available</function> function, when
                  called with a particular <termref def="dt-expanded-qname">expanded QName</termref>
                  and <termref def="dt-arity">arity</termref>, returns true if and only if a call on
                     <xfunction>function-lookup</xfunction> with the same arguments, in the same
                  static context, would return a function item.</p>
               <note>
                  <p diff="chg" at="M">For legacy reasons there is also a single-argument version of
                        <function>function-available</function>, which returns true if there is a
                     function with the given name regardless of arity.</p>
               </note>
               <p diff="add" at="P-bug22936">The standard rules for
                     <xfunction>function-lookup</xfunction> require that if the supplied name and
                  arity identify a context-dependent function such as <xfunction>name#0</xfunction>
                  or <xfunction>lang#1</xfunction> (call it <var>F</var>), then the returned
                  function value includes in its closure a copy of the static and dynamic context of
                  the call to <xfunction>function-lookup</xfunction>, and the context item for a
                  subsequent dynamic call of <var>F</var> is taken from this saved context. In the
                  case where the context item is a node in a streamed input document, saving the
                  node is not possible. In this case, therefore, the context is saved with an absent
                  focus, so the call on <var>F</var> will fail with a dynamic error saying that
                  there is no context item available.</p>
            </div3>
            <div3 id="function-determinism" diff="chg" at="S-bug29060">
               <head>Determinism of Functions</head>
               <p>Stylesheet functions have been designed to be largely deterministic: unless a
                  stylesheet function calls some <termref def="dt-extension-function">extension
                     function</termref> which is itself nondeterministic, the function will return
                  results that depend only on the supplied arguments. This property (coupled with
                  the fact that the effect of calling extension functions is entirely <termref
                     def="dt-implementation-dependent"/>) enables a processor to implement various
                  optimizations, such as removing invariant function calls from the body of a loop,
                  or combining common subexpressions.</p>
               <p>One exception to the intrinsic determinism of stylesheet functions arises because
                  constructed nodes have distinct identity. This means that when a function that
                  creates a new node is called, two calls on the function will return nodes that can
                  be distinguished: for example, with such a function, <code>f:make-node() is
                     f:make-node()</code> will return false.</p>
               <p>Three classes of functions can be identified:</p>
               <olist>
                  <item>
                     <p><xtermref spec="FO31" ref="dt-deterministic">Deterministic</xtermref>
                        functions: as the term is defined in <bibref ref="xpath-functions-31"/>,
                        these offer a guarantee that when a function is called repeatedly with the
                        same arguments, it returns the same results. A classic example is the
                           <xfunction>doc</xfunction> function, which offers the guarantee that
                           <code>doc($X) is doc($X)</code>: that is, two calls supplying the same
                        URI return the same node.</p>
                  </item>
                  <item>
                     <p>Proactive functions: these offer the guarantee that each invocation of the
                        function causes a single execution of the function body, or behaves exactly
                        as if it did so. In particular this means that when the function creates new
                        nodes, it creates new nodes on each invocation. By default, <termref
                           def="dt-stylesheet-function">stylesheet functions</termref> are
                        proactive.</p>
                  </item>
                  <item>
                     <p>Elidable functions: these offer no guarantee of determinism, and no
                        guarantee of proactive evaluation. If the function creates new nodes, then
                        two calls on the function with the same arguments may or may not return the
                        same nodes, at the implementation’s discretion. Examples of elidable
                        functions include the <bibref ref="xpath-functions-31"/> functions
                           <xfunction>analyze-string</xfunction> and
                           <function>json-to-xml</function>.</p>
                  </item>
               </olist>
               <p>The <code>new-each-time</code> attribute of <elcode>xsl:function</elcode> allows a
                  stylesheet function to be assigned to one of these three categories. The value
                     <code>new-each-time="no"</code> means the function is deterministic; the value
                     <code>new-each-time="yes"</code> means it is proactive; and the value
                     <code>new-each-time="maybe"</code> means it is elidable.</p>
               <p>The definition of <xtermref spec="FO31" ref="dt-deterministic"
                     >determinism</xtermref> requires a definition of what it means for a function
                  to be called twice with “the same” arguments and to return “the same” result. This
                  is defined in <bibref ref="xpath-functions-31"/>, specifically by the definition
                  of the term <xtermref spec="FO31" ref="dt-identical">identical</xtermref>.</p>
               <p>Processors have considerable freedom to optimize execution of stylesheets, and of
                  function calls in particular, but the strategies that are adopted must respect the
                  specification as to whether functions are deterministic, proactive, or elidable.
                  For example, consider a function call that appears within an
                     <elcode>xsl:for-each</elcode> instruction, where the supplied arguments to the
                  function do not depend on the context item or on any variables declared within the
                     <elcode>xsl:for-each</elcode> instruction. A possible optimization is to
                  execute the function call only once, rather than executing it repeatedly each time
                  round the loop (this is sometimes called loop-lifting). This optimization is safe
                  when the function is deterministic or elidable, but it requires great care if the
                  function is proactive; it is permitted only if the processor is able to determine
                  that the results of stylesheet execution are equivalent to the results that would
                  be obtained if the optimization had not been performed. Declaring a function call
                  to be elidable (by writing <code>new-each-time="maybe"</code>) makes it more
                  likely that an implementation will be able to apply this optimization, as well as
                  other optimizations such as caching or memoization.</p>
            </div3>
            <div3 id="memoization" diff="chg" at="S-bug29060">
               <head>Memoization</head>
               <p>The <code>cache</code> attribute is an optimization hint which the processor can
                  use or ignore at its discretion; however it <rfc2119>should</rfc2119> be taken
                  seriously, because it may make a difference to whether execution of a stylesheet
                  is practically feasible or not.</p>
               <p>The default value is <code>cache="no".</code></p>
               <p>The value <code>cache="yes"</code> encourages the processor to retain memory of
                     <phrase diff="del" at="S-bug29060">all </phrase>previous calls of this function
                  during the same transformation and to reuse results from this memory whenever
                  possible. <phrase diff="del" at="S-bug29060">The value
                        <code>cache="partial"</code> encourages the processor to retain such memory
                     but to discard results if necessary to keep the amount of memory used within
                     bounds. </phrase>The default value <code>cache="no"</code> encourages the
                  processor not to retain memory of previous calls.</p>
               <p>In all cases the results must respect the semantics. If a function is proactive
                     (<code>new-each-time="yes"</code>) then caching of results may be infeasible,
                  especially if the function result can include nodes; but it is not an error to
                  request it, since some implementations may be able to provide caching, or
                  analogous optimizations, even for proactive functions. (One possible strategy is
                  to return a copy of the cached result, thus creating the illusion that the
                  function has been evaluated anew.)</p>
               <note>
                  <p>Memoization is essentially a trade-off between time and space; a memoized
                     function can be expected to use more memory to deliver faster execution.
                     Achieving an optimum balance may require configuring the size of the cache that
                     is used; implementations <rfc2119>may</rfc2119> use additional <termref
                        def="dt-extension-attribute">extension attributes</termref> or other
                     mechanisms to provide finer control of this kind.</p>
               </note>
               <note>
                  <p>Memoization of a function generally involves creating an associative table (for
                     example, a hash map) that maps argument values to function results. To get this
                     right, it is vital that the key for this table should correctly reflect what it
                     means for two function calls to have “the same arguments”. Does it matter, for
                     example, that one call passes the <code>xs:string</code> value "Paris", while
                     another passes the <code>xs:untypedAtomic</code> value "Paris"? If the function
                     is declared with <code>new-each-time="maybe"</code>, then the rules say that
                     these cannot be treated as “the same arguments”: the definition of <xtermref
                        spec="FO31" ref="dt-identical"/> requires them to have exactly the same type
                     as well as being equal. However, an implementation that is able to determine
                     that all references to the argument within the function body only make use of
                     its string value might be able to take advantage of this fact, and thus perform
                     more efficient caching.</p>
               </note>
            </div3>
            <div3 id="function-examples">
               <head>Examples of Stylesheet Functions</head>
               <example>
                  <head>A Stylesheet Function</head>
                  <p>The following example creates a recursive <termref def="dt-stylesheet-function"
                        >stylesheet function</termref> named <code>str:reverse</code> that reverses
                     the words in a supplied sentence, and then invokes this function from within a
                        <termref def="dt-template-rule">template rule</termref>. </p>
                  <eg xml:space="preserve" role="xslt-document">&lt;xsl:transform 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:str="http://example.com/namespace"
  version="3.0"
  exclude-result-prefixes="str"&gt;

&lt;xsl:function name="str:reverse" as="xs:string"&gt;
  &lt;xsl:param name="sentence" as="xs:string"/&gt;
  &lt;xsl:sequence  
     select="if (contains($sentence, ' '))
             then concat(str:reverse(substring-after($sentence, ' ')),
                         ' ',
                         substring-before($sentence, ' '))
             else $sentence"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:template match="/"&gt;
  &lt;output&gt;
    &lt;xsl:value-of select="str:reverse('DOG BITES MAN')"/&gt;
  &lt;/output&gt;
&lt;/xsl:template&gt;

&lt;/xsl:transform&gt;</eg>
                  <p>An alternative way of writing the same function is to implement the conditional
                     logic at the XSLT level, thus:</p>
                  <eg xml:space="preserve" role="xslt-declaration xmlns:str='str'">&lt;xsl:function name="str:reverse" as="xs:string"&gt;
  &lt;xsl:param name="sentence" as="xs:string"/&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="contains($sentence, ' ')"&gt;  
      &lt;xsl:sequence 
           select="concat(str:reverse(substring-after($sentence, ' ')),
                                ' ',
                                substring-before($sentence, ' '))"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:sequence select="$sentence"/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:function&gt;</eg>
               </example>
               <example>
                  <head>Declaring the Return Type of a Function</head>
                  <p>The following example illustrates the use of the <code>as</code> attribute in a
                     function definition. It returns a string containing the representation of its
                     integer argument, expressed as a roman numeral. For example, the function call
                        <code>num:roman(7)</code> will return the string <code>"vii"</code>. This
                     example uses the <elcode>xsl:number</elcode> instruction, described in <specref
                        ref="number"/>. The <elcode>xsl:number</elcode> instruction returns a text
                     node, and the <termref def="dt-function-conversion-rules">function conversion
                        rules</termref> are invoked to convert this text node to the type declared
                     in the <elcode>xsl:function</elcode> element, namely <code>xs:string</code>. So
                     the text node is <termref def="dt-atomization">atomized</termref> to a
                     string.</p>
                  <eg xml:space="preserve" role="xslt-declaration xmlns:num='num'">&lt;xsl:function name="num:roman" as="xs:string"&gt;
  &lt;xsl:param name="value" as="xs:integer"/&gt;
  &lt;xsl:number value="$value" format="i"/&gt;
&lt;/xsl:function&gt;</eg>
               </example>
               <example diff="add" at="D">
                  <head>A Higher-Order Function</head>
                  <p>XPath 3.0 introduces the ability to pass function items as arguments to a
                     function. A function that takes function items as arguments is known as a
                     higher-order function.</p>
                  <p>The following example is a higher-order function that operates on any
                     tree-structured data, for example an organization chart. Given as input a
                     function that finds the direct subordinates of a node in this tree structure
                     (for example, the direct reports of a manager, or the geographical subdivisions
                     of an administrative area), it determines whether one object is present in the
                     subtree rooted at another object (for example, whether one person is among the
                     staff managed directly or indirectly by a manager, or whether one parcel of
                     land is contained directly or indirectly within another parcel). The function
                     does not check for cycles in the data.</p>
                  <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">&lt;xsl:function name="f:is-subordinate" as="xs:boolean"&gt;
    &lt;xsl:param name="superior" 
               as="node()"/&gt;
    &lt;xsl:param name="subordinate" 
               as="node()"/&gt;
    &lt;xsl:param name="get-direct-children" 
               as="function(node()) as node()*"/&gt;
    &lt;xsl:sequence select="
               some $sub in $get-direct-children($superior) satisfies
                 ($sub is $subordinate or
                  f:is-subordinate($sub, $subordinate, 
                                      $get-direct-children))"/&gt;
&lt;/xsl:function&gt;</eg>
                  <p>Given source data representing an organization chart in the form of elements
                     such as:</p>
                  <eg role="xml" xml:space="preserve">&lt;employee id="P57832" manager="P68951"/&gt;</eg>
                  <p>the following function can be defined to get the direct reports of a
                     manager:</p>
                  <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">&lt;xsl:function name="f:direct-reports" 
               as="element(employee)*"&gt;
    &lt;xsl:param name="manager" as="element(employee)"/&gt;
    &lt;xsl:sequence select="$manager/../employee
                               [@manager = $manager/@id]"/&gt;
&lt;/xsl:function&gt;</eg>
                  <p>It is then possible to test whether one employee <code>$E</code> reports
                     directly or indirectly to another employee <code>$M</code> by means of the
                     function call:</p>
                  <eg role="non-xml" xml:space="preserve">f:is-subordinate($M, $E, f:direct-reports#1)</eg>
               </example>
            </div3>
         </div2>
         <div2 id="dynamic-xpath" diff="add" at="B">
            <head>Dynamic XPath Evaluation</head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="evaluate">
               <e:in-category name="instruction"/>
               <e:attribute name="xpath" required="yes">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="as" required="no">
                  <e:data-type name="sequence-type"/>
               </e:attribute>
               <e:attribute name="base-uri" required="no">
                  <e:attribute-value-template>
                     <e:data-type name="uri"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="with-params" required="no">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="context-item" required="no">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="namespace-context" required="no">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="schema-aware" required="no">
                  <e:attribute-value-template>
                     <e:data-type name="boolean"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:choice repeat="zero-or-more">
                  <e:element name="with-param"/>
                  <e:element name="fallback"/>
               </e:choice>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:evaluate</elcode> instruction constructs an XPath expression in the
               form of a string, evaluates the expression in a specified context, and returns the
               result of the evaluation.</p>
            <p>The expression given as the value of the <code>xpath</code> attribute is evaluated
               and the result is converted to a string using the <termref
                  def="dt-function-conversion-rules">function conversion rules</termref>.</p>
            <p><termdef id="dt-target-expression" term="target expression">The string that results
                  from evaluating the expression in the <code>xpath</code> attribute is referred to
                  as the <term>target expression</term>.</termdef></p>
            <p><error spec="XT" type="dynamic" class="DE" code="3160"><p>It is a <termref
                        def="dt-dynamic-error"><phrase diff="del" at="M">non-recoverable</phrase>
                        dynamic error</termref> if the <termref def="dt-target-expression">target
                        expression</termref>
                     <error.extra>of an <elcode>xsl:evaluate</elcode> instruction</error.extra> is
                     not a valid <phrase diff="chg" at="S-bug24266"><termref def="dt-expression"
                        /></phrase> (that is, if a static error occurs when analyzing the string
                     according to the rules of the XPath specification).</p></error></p>
            <p>The <code>as</code> attribute, if present, indicates the required type of the result.
               If the attribute is absent, the required type is <code>item()*</code>, which allows
               any result. The result of evaluating the <termref def="dt-target-expression">target
                  expression</termref> is converted to the required type using the <termref
                  def="dt-function-conversion-rules">function conversion rules</termref>. This may
               cause a <termref def="dt-type-error">type error</termref> if conversion is not
               possible. The result after conversion is returned as the result of the
                  <elcode>xsl:evaluate</elcode> instruction.</p>
            <p diff="add" at="M">The target expression may contain variable references; the values
               of such variables may be supplied using an <elcode>xsl:with-param</elcode> child
               instruction if the names of the variables are known statically, or using a map
               supplied as the value of the expression in the <code>with-params</code> attribute if
               the names are only known dynamically. If the <code>with-params</code> attribute is
               present then it must contain an expression whose value, when evaluated, is of type
                  <code>map(xs:QName, item()*)</code> (see <specref ref="map"/> for details of
               maps).</p>
            <p diff="add" at="T-bug29351">
               <error spec="XT" type="type" class="TE" code="3165"><p>It is a <termref
                        def="dt-type-error">type error</termref> if the result of evaluating the
                     expression in the <code>with-params</code> attribute of the
                        <elcode>xsl:evaluate</elcode> instruction is anything other than a single
                     map of type <code>map(xs:QName, item()*)</code>.</p></error>
            </p>
            <div3 id="evaluate-static-context">
               <head>Static context for the target expression</head>
               <p>The <xtermref spec="XP30" ref="dt-static-context">static context</xtermref> for
                  the <termref def="dt-target-expression">target expression</termref> is as
                  follows:</p>
               <ulist>
                  <item>
                     <p>XPath 1.0 compatibility mode is <code>false</code>.</p>
                  </item>
                  <item>
                     <p>Statically known namespaces and default element/type namespace:</p>
                     <ulist>
                        <item>
                           <p>if the <code>namespace-context</code> attribute is present, then its
                              value is an <termref def="dt-expression">expression</termref> whose
                              required type is a single node. The expression is evaluated, and the
                              in-scope namespaces of the resulting node are used as the statically
                              known namespaces for the target expression. The binding for the
                              default namespace in the in-scope namespaces is used as the default
                              namespace for elements and types in the target expression.</p>
                           <p>
                              <error spec="XT" type="type" class="TE" code="3170"><p>It is a
                                       <termref def="dt-type-error">type error</termref> if the
                                    result of evaluating the <code>namespace-context</code>
                                    attribute of the <elcode>xsl:evaluate</elcode> instruction is
                                    anything other than a single node.</p></error>
                           </p>
                        </item>
                        <item>
                           <p>if the <code>namespace-context</code> attribute is absent, then the
                              in-scope namespaces of the <elcode>xsl:evaluate</elcode> instruction
                              (with the exception of any binding for the default namespace) are used
                              as the statically known namespaces for the target expression, and the
                              value of the innermost <code>[xsl:]xpath-default-namespace</code>
                              attribute, if any, is used as the default namespace for elements and
                              types in the target expression.</p>
                        </item>
                     </ulist>
                     <note>
                        <p>XPath 3.0 allows expanded names to be written in a context-independent
                           way using the syntax <code>Q{namespace-uri}local-name</code></p>
                     </note>
                  </item>
                  <item>
                     <p>Default function namespace: the <termref
                           def="dt-standard-function-namespace">standard function
                           namespace</termref>.</p>
                  </item>
                  <item>
                     <p>In-scope schema definitions: if the <code>schema-aware</code> attribute is
                        present and has the <termref def="dt-effective-value">effective
                           value</termref>
                        <code>yes</code>, then the in-scope schema definitions from the stylesheet
                        context (that is, the schema definitions imported using
                           <elcode>xsl:import-schema</elcode>). Otherwise, the built-in types (see
                           <specref ref="built-in-types"/>).</p>
                  </item>
                  <item>
                     <p diff="chg" at="M">In-scope variables: the names of the in-scope variables
                        are the union of the names appearing in the <code>name</code> attribute of
                        the contained <elcode>xsl:with-param</elcode> elements, and the names
                        present as keys in the map obtained by evaluating the
                           <code>with-params</code> attribute, if present. The corresponding type is
                           <code>item()*</code> in the case of a name found as a key in the
                           <code>with-params</code> map, or the type named in the <code>as</code>
                        attribute of <elcode>xsl:with-param</elcode> child (defaulting to
                           <code>item()*</code>) otherwise.</p>
                     <p diff="chg" at="M">If a variable name is present both the static
                           <elcode>xsl:with-param</elcode> children and also in the dynamic
                           <code>with-params</code> map, the value from the latter takes
                        precedence.</p>
                     <note>
                        <p>Variables declared in the stylesheet in <elcode>xsl:variable</elcode> or
                              <elcode>xsl:param</elcode> elements are <emph>not</emph> in-scope
                           within the target expression.</p>
                     </note>
                  </item>
                  <item>
                     <p>Function signatures:</p>
                     <ulist>
                        <item>
                           <p>All functions defined in <bibref ref="xpath-functions-30"/> in the
                                 <code>fn</code> and <code>math</code> namespaces;</p>
                        </item>
                        <item>
                           <p>All functions in the <code>fn</code> and <code>map</code> namespaces
                              whose definitions appear both in this specification and also in
                                 <bibref ref="xpath-functions-31"/>;</p>
                        </item>
                        <item>
                           <p>If the processor supports XPath 3.1, all functions defined in <bibref
                                 ref="xpath-functions-31"/> in the <code>fn</code>,
                                 <code>math</code>, <code>map</code>, and <code>array</code>
                              namespaces;</p>
                        </item>
                        <item>
                           <p>Constructor functions for <phrase diff="chg" at="O">named
                                 simple</phrase> types included in the in-scope schema
                              definitions;</p>
                        </item>
                        <item>
                           <p>All user-defined functions present in the containing package provided
                              their visibility is not <code>hidden</code> or
                              <code>private</code>;</p>
                        </item>
                        <item>
                           <p>An <termref def="dt-implementation-defined"
                                 >implementation-defined</termref> set of <termref
                                 def="dt-extension-function">extension functions</termref>.</p>
                        </item>
                     </ulist>
                     <p>Note that this set deliberately excludes XSLT-defined functions in the
                           <termref def="dt-standard-function-namespace">standard function
                           namespace</termref> including for example, <function>key</function>,
                           <function>current-group</function>, and
                           <function>system-property</function>. A list of these functions is in
                           <specref ref="XSLT-defined-functions"/>.</p>
                     <imp-def-feature id="idf-ext-evaluatefunctions">The set of extension functions
                        available in the static context for the target expression of
                           <elcode>xsl:evaluate</elcode> is <termref def="dt-implementation-defined"
                        />.</imp-def-feature>
                  </item>
                  <item>
                     <p>Statically known collations: the same as the collations available at this
                        point in the stylesheet.</p>
                  </item>
                  <item>
                     <p>Default collation: the same as the default collation defined at this point
                        in the stylesheet (for example, by use of the
                           <code>[xsl:]default-collation</code> attribute)</p>
                  </item>
                  <item>
                     <p>Base URI: if the <code>base-uri</code> attribute is present, then its
                           <termref def="dt-effective-value">effective value</termref>; otherwise,
                        the base URI of the <elcode>xsl:evaluate</elcode> instruction.</p>
                  </item>
                  <item>
                     <p>Statically known documents: the empty set</p>
                  </item>
                  <item>
                     <p>Statically known collections: the empty set</p>
                  </item>
                  <item>
                     <p>Statically known default collection type: <code>node()*</code></p>
                  </item>
               </ulist>
            </div3>
            <div3 id="evaluate-dynamic-context">
               <head>Dynamic context for the target expression</head>
               <p diff="chg" at="K">The dynamic context for evaluation of the target expression is
                  as follows:</p>
               <ulist>
                  <item>
                     <p>The context item, position, and size depend on the result of evaluating the
                        expression in the <code>context-item</code> attribute. If this attribute is
                        absent, or if the result is an empty sequence, then the context item,
                        position, and size for evaluation of the target expression are all <termref
                           def="dt-absent"/>. If the result of evaluating the
                           <code>context-item</code> expression is a single item, then the target
                        expression is evaluated with a <termref def="dt-singleton-focus"/> based on
                        this item.</p>
                     <p><error spec="XT" type="type" class="TE" code="3210"><p>If the result of
                              evaluating the <code>context-item</code> expression <error.extra>of an
                                    <elcode>xsl:evaluate</elcode> instruction</error.extra> is a
                              sequence containing more than one item, then a <termref
                                 def="dt-type-error"/> is signaled.</p></error></p>
                  </item>
                  <item>
                     <p diff="chg" at="M">The <term>variable values</term> consists of the values
                        bound to parameters defined either in the contained
                           <elcode>xsl:with-param</elcode> elements, which are evaluated as
                        described in <specref ref="variable-values"/>, or in the map that results
                        from evaluation of the expression in the <code>with-params</code> attribute;
                        if the same QName is bound in both, the value in the
                           <code>with-params</code> map takes precedence.</p>
                  </item>
                  <item>
                     <p>The XSLT-specific aspects of the dynamic context described in <specref
                           ref="additional-dynamic-context"/> are all <termref def="dt-absent"
                        />.</p>
                  </item>
                  <item>
                     <p diff="add" at="T-bug30049">The <xtermref spec="XP30"
                           ref="dt-named-functions">named functions</xtermref> (representing the
                        functions accessible using <function>function-available</function> or
                           <xfunction>function-lookup</xfunction>) include all the functions
                        available in the static context, and may also include an additional <termref
                           def="dt-implementation-defined"/> set of functions that are available
                        dynamically but not statically. </p>
                  </item>
                  <item>
                     <p>All other aspects of the dynamic context are the same as the dynamic context
                        for the <elcode>xsl:evaluate</elcode> instruction itself, <phrase diff="add"
                           at="R-bug24521">except that an implementation <code>may</code> restrict
                           the availability of external resources (for example, available documents)
                           or provide options to restrict their availability, for security
                           reasons</phrase>.</p>
                     <note diff="add" at="R-bug24521">
                        <p>For example, a processor may disallow access using the
                              <xfunction>doc</xfunction> or <xfunction>collection</xfunction>
                           functions to documents in local filestore.</p>
                     </note>
                  </item>
               </ulist>
            </div3>
            <div3 id="evaluate-effect">
               <head>The effect of the <code>xsl:evaluate</code> instruction</head>
               <p>The XPath expression is evaluated in the same <xtermref ref="execution-scope"
                     spec="FO30">execution scope</xtermref> as the calling XSLT transformation; this
                  means that the results of <xtermref spec="FO30" ref="dt-deterministic"
                     >deterministic</xtermref> functions such as <xfunction>doc</xfunction> or
                     <xfunction>current-dateTime</xfunction> will be consistent between the calling
                  stylesheet and the called XPath expression.</p>
               <p diff="add" at="E">It is a <termref def="dt-dynamic-error"/> if evaluation of the
                  XPath expression fails with a dynamic error. The XPath-defined error code is used
                  unchanged.</p>
               <note>
                  <p>Implementations wanting to avoid the cost of repeated compilation of the same
                     XPath expression should cache the compiled form internally.</p>
               </note>
               <p diff="add" at="L">Stylesheet authors need to be aware of the security risks
                  associated with the use of <elcode>xsl:evaluate</elcode>. The instruction should
                  not be used to execute code from an untrusted source. To avoid the risk of code
                  injection, user-supplied data should never be inserted into the expression using
                  string concatenation, but should always be referenced by use of parameters.</p>
            </div3>
            <div3 id="evaluation-as-optional-feature">
               <head><elcode>xsl:evaluate</elcode> as an optional feature</head>
               <p>The <elcode>xsl:evaluate</elcode> instruction is newly introduced in XSLT 3.0. It
                  is part of the dynamic evaluation feature, which is an optional feature of the
                  specification (see <specref ref="dynamic-evaluation-feature"/>). An XSLT 3.0
                  processor <rfc2119>may</rfc2119> disable the feature, or allow users to disable
                  the feature. The processor <rfc2119>may</rfc2119> be able to determine during
                  static analysis whether or not the feature is available, or it
                     <rfc2119>may</rfc2119> only be able to determine this during dynamic
                  evaluation. In the first case we refer to the feature being <term>statically
                     disabled</term>, in the second case to it being <term>dynamically
                     disabled</term>.</p>
               <p>If the feature is statically disabled, then:</p>
               <ulist>
                  <item>
                     <p>A call to <code>element-available('xsl:evaluate')</code> returns false,
                        wherever it appears;</p>
                  </item>
                  <item>
                     <p>A call to <code>system-property('xsl:supports-dynamic-evaluation')</code>
                        returns the string <code>"no"</code>, wherever it appears;</p>
                  </item>
                  <item>
                     <p>If an <elcode>xsl:evaluate</elcode> instruction has an
                           <elcode>xsl:fallback</elcode> child, fallback processing takes place;</p>
                  </item>
                  <item>
                     <p>No static error is raised if an <elcode>xsl:evaluate</elcode> instruction is
                        present in the stylesheet (an error occurs only if it is actually
                        evaluated).</p>
                  </item>
               </ulist>
               <p>If the feature is dynamically disabled, then:</p>
               <ulist>
                  <item>
                     <p>A call to <code>element-available('xsl:evaluate')</code> appearing in a
                           <termref def="dt-static-expression">static expression</termref> (for
                        example, in an <code>[xsl:]use-when</code> attribute) returns true;</p>
                  </item>
                  <item>
                     <p>A call to <code>element-available('xsl:evaluate')</code> appearing anywhere
                        else returns false;</p>
                  </item>
                  <item>
                     <p>A call to <code>system-property('xsl:supports-dynamic-evaluation')</code>
                        appearing in a <termref def="dt-static-expression">static
                           expression</termref> (for example, in an <code>[xsl:]use-when</code>
                        attribute) returns the string <code>"yes"</code>;</p>
                  </item>
                  <item>
                     <p>A call to <code>system-property('xsl:supports-dynamic-evaluation')</code>
                        appearing anywhere else returns the string <code>"no"</code>;</p>
                  </item>
                  <item>
                     <p>If an <elcode>xsl:evaluate</elcode> instruction has an
                           <elcode>xsl:fallback</elcode> child, fallback processing takes place;</p>
                  </item>
                  <item>
                     <p>In the absence of an <elcode>xsl:fallback</elcode> child, a dynamic error is
                        raised if an <elcode>xsl:evaluate</elcode> instruction is evaluated. The
                        dynamic error may be caught using <elcode>xsl:try</elcode> and
                           <elcode>xsl:catch</elcode>.</p>
                  </item>
               </ulist>
               <p diff="add" at="T-bug29927">If a processor supports the dynamic evaluation feature,
                  it is <termref def="dt-implementation-defined"/> how the processor allows users to
                  disable dynamic evaluation and it is implementation-defined whether the mechanism
                  is static or dynamic.</p>
               <p><error spec="XT" type="dynamic" class="DE" code="3175"><p>It is a <termref
                           def="dt-dynamic-error"/> if an <elcode>xsl:evaluate</elcode> instruction
                        is evaluated when use of <elcode>xsl:evaluate</elcode> has been statically
                        or dynamically disabled. </p></error></p>
               <p>In consequence of these rules, the recommended approach for stylesheet authors to
                  write code that works whether or not <elcode>xsl:evaluate</elcode> is enabled is
                  to use an <elcode>xsl:fallback</elcode> child instruction. For example:</p>
               <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:variable name="isValid" as="xs:boolean"&gt;
  &lt;xsl:evaluate xpath="$validityCondition"&gt;
     &lt;xsl:fallback&gt;&lt;xsl:sequence select="true()"/&gt;&lt;/xsl:fallback&gt;
  &lt;/xsl:evaluate&gt;
&lt;/xsl:variable&gt;</eg>
               <note>
                  <p>There may be circumstances where it is inappropriate to allow use of
                        <elcode>xsl:evaluate</elcode>. For example:</p>
                  <ulist>
                     <item>
                        <p>There may be security risks associated with the ability to execute code
                           from an untrusted source, which cannot be inspected during static
                           analysis.</p>
                     </item>
                     <item>
                        <p>There may be environments where the available computing resources are
                           sufficient to enable pre-compiled stylesheets to be executed, but not to
                           enable XPath expressions to be compiled into executable code.</p>
                     </item>
                  </ulist>
                  <p> Processors that implement <elcode>xsl:evaluate</elcode> should provide
                     mechanisms allowing calls on <elcode>xsl:evaluate</elcode> to be disabled.
                     Implementations may disable the feature by default, and they may disable it
                     unconditionally. </p>
               </note>
            </div3>
            <div3 id="evaluate-examples">
               <head>Examples of <elcode>xsl:evaluate</elcode></head>
               <example>
                  <head>Using a Dynamic Sort Key</head>
                  <p>A common requirement is to sort a table on the value of an expression which is
                     selected at run-time, perhaps by supplying the expression as a string-valued
                     parameter to the stylesheet. Suppose that such an expression is supplied to the
                     parameter:</p>
                  <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:param name="sortkey" as="xs:string" select="'@name'"/&gt;</eg>
                  <p>Then the data may be sorted as follows:</p>
                  <eg role="non-xml" xml:space="preserve">&lt;xsl:sort&gt;
   &lt;xsl:evaluate xpath="$sortkey" as="xs:string" context-item="."/&gt;
&lt;/xsl:sort&gt;</eg>
                  <p>Note the importance in this use case of caching the compiled expression, since
                     it is evaluated repeatedly, once for each item in the list being sorted.</p>
               </example>
               <example diff="add" at="K">
                  <head>Getting a Function if it Exists</head>
                  <p diff="chg" at="T-bug30049">If the <xfunction>function-lookup</xfunction>
                     function were not available in the standard library, then a very similar
                     function could be implemented like this:</p>
                  <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">&lt;xsl:function name="f:function-lookup"&gt;
  &lt;xsl:param name="name" as="xs:QName"/&gt;
  &lt;xsl:param name="arity" as="xs:integer"/&gt;
  &lt;xsl:try&gt;
    &lt;xsl:evaluate xpath="'Q{' || namespace-uri-from-QName($name) || '}' 
                || local-name-from-QName($name) || '#' || $arity"&gt;
      &lt;xsl:with-param name="name" as="xs:QName" select="$name"/&gt;
      &lt;xsl:with-param name="arity" as="xs:integer" select="$arity"/&gt;
    &lt;/xsl:evaluate&gt;
    &lt;xsl:catch errors="err:XTDE3160" select="()"/&gt;
  &lt;/xsl:try&gt;  
&lt;/xsl:function&gt;  
     </eg>
                  <note diff="add" at="T-bug30049">
                     <p>The main difference between this function and the standard
                           <xfunction>function-lookup</xfunction> function is that there are
                        differences in the functions that are visible: for example
                           <xfunction>function-lookup</xfunction> gives access to user-defined
                        functions with private visibility, whereas <elcode>xsl:evaluate</elcode>
                        does not.</p>
                  </note>
                  <p>The <elcode>xsl:evaluate</elcode> instruction uses the supplied QName and arity
                     to construct an expression of the form
                     <code>Q{namespace-uri}local#arity</code>, which is then evaluated to return a
                     function item representing the requested function.</p>
               </example>
            </div3>
         </div2>
      </div1>
      <div1 id="creating-new-nodes">
         <head>Creating Nodes and Sequences</head>
         <p>This section describes instructions that directly create new nodes, or sequences of
            nodes, atomic values, <phrase diff="add" at="C">and/or function items</phrase>.</p>
         <div2 id="literal-result-element">
            <head>Literal Result Elements</head>
            <p>
               <termdef id="dt-literal-result-element" term="literal result element">In a <termref
                     def="dt-sequence-constructor">sequence constructor</termref>, an element in the
                     <termref def="dt-stylesheet">stylesheet</termref> that does not belong to the
                     <termref def="dt-xslt-namespace">XSLT namespace</termref> and that is not an
                     <termref def="dt-extension-instruction">extension instruction</termref> (see
                     <specref ref="extension-instruction"/>) is classified as a <term>literal result
                     element</term>.</termdef> A literal result element is evaluated to construct a
               new element node with the same <termref def="dt-expanded-qname">expanded
                  QName</termref> (that is, the same namespace URI, local name, and namespace
               prefix). The result of evaluating a literal result element is a node sequence
               containing one element, the newly constructed element node.</p>
            <p>The content of the element is a <termref def="dt-sequence-constructor">sequence
                  constructor</termref> (see <specref ref="sequence-constructors"/>). The sequence
               obtained by evaluating this sequence constructor, after prepending any attribute
               nodes produced as described in <specref ref="attributes-for-lres"/> and namespace
               nodes produced as described in <specref ref="lre-namespaces"/>, is used to construct
               the content of the element, following the rules in <specref
                  ref="constructing-complex-content"/>
            </p>
            <p>The base URI of the new element is copied from the base URI of the literal result
               element in the stylesheet, unless the content of the new element includes an
                  <code>xml:base</code> attribute, in which case the base URI of the new element is
               the value of that attribute, resolved (if it is a relative URI <phrase diff="add"
                  at="F">reference</phrase>) against the base URI of the literal result element in
               the stylesheet. (Note, however, that this is only relevant when creating a parentless
               element. When the literal result element is copied to form a child of an element or
               document node, the base URI of the new copy is taken from that of its new
               parent.)</p>
            <div3 id="setting-annotation-for-lre">
               <head>Setting the Type Annotation for Literal Result Elements</head>
               <p>The attributes <code>xsl:type</code> and <code>xsl:validation</code> may be used
                  on a literal result element to invoke validation of the contents of the element
                  against a type definition or element declaration in a schema, and to determine the
                     <termref def="dt-type-annotation"/> that the new element node will carry. These
                  attributes also affect the type annotation carried by any elements and attributes
                  that have the new element node as an ancestor. These two attributes are both
                  optional, and if one is specified then the other <rfc2119>must</rfc2119> be
                  omitted.</p>
               <p>The value of the <code>xsl:validation</code> attribute, if present, must be one of
                  the values <code>strict</code>, <code>lax</code>, <code>preserve</code>, or
                     <code>strip</code>. The value of the <code>xsl:type</code> attribute, if
                  present, must be an <phrase diff="chg" at="K"><termref def="dt-eqname"
                        >EQName</termref></phrase> identifying a type definition that is present in
                  the <termref def="dt-in-scope-schema-component">in-scope schema
                     components</termref> for the stylesheet. Neither attribute may be specified as
                  an <termref def="dt-attribute-value-template">attribute value template.</termref>
                  The effect of these attributes is described in <specref ref="validation"/>.</p>
            </div3>
            <div3 id="attributes-for-lres">
               <head>Attribute Nodes for Literal Result Elements</head>
               <p>Attribute nodes for a literal result element may be created by including
                     <elcode>xsl:attribute</elcode> instructions within the <termref
                     def="dt-sequence-constructor">sequence constructor</termref>. Additionally,
                  attribute nodes are created corresponding to the attributes of the literal result
                  element in the stylesheet, and as a result of expanding the
                     <code>xsl:use-attribute-sets</code> attribute of the literal result element, if
                  present.</p>
               <p>The sequence that is used to construct the content of the literal result element
                  (as described in <specref ref="constructing-complex-content"/>) is the
                  concatenation of the following four sequences, in order:</p>
               <olist>
                  <item>
                     <p>The sequence of namespace nodes produced as described in <specref
                           ref="lre-namespaces"/>.</p>
                  </item>
                  <item>
                     <p>The sequence of attribute nodes produced by expanding the
                           <code>xsl:use-attribute-sets</code> attribute (if present) following the
                        rules given in <specref ref="attribute-sets"/>
                     </p>
                  </item>
                  <item>
                     <p>The attributes produced by processing the attributes of the literal result
                        element itself, other than attributes in the <termref
                           def="dt-xslt-namespace">XSLT namespace</termref>. The way these are
                        processed is described below.</p>
                  </item>
                  <item>
                     <p>The sequence produced by evaluating the contained <termref
                           def="dt-sequence-constructor">sequence constructor</termref>, if the
                        element is not empty.</p>
                  </item>
               </olist>
               <note>
                  <p>The significance of this order is that an attribute produced by an
                        <elcode>xsl:attribute</elcode>, <elcode>xsl:copy</elcode>, or
                        <elcode>xsl:copy-of</elcode> instruction in the content of the literal
                     result element takes precedence over an attribute produced by expanding an
                     attribute of the literal result element itself, which in turn takes precedence
                     over an attribute produced by expanding the <code>xsl:use-attribute-sets</code>
                     attribute. This is because of the rules in <specref
                        ref="constructing-complex-content"/>, which specify that when two or more
                     attributes in the sequence have the same name, all but the last of the
                     duplicates are discarded.</p>
                  <p>Although the above rules place namespace nodes before attributes, this is not
                     strictly necessary, because the rules in <specref
                        ref="constructing-complex-content"/> allow the namespaces and attributes to
                     appear in any order so long as both come before other kinds of node. The order
                     of namespace nodes and attribute nodes in the sequence has no effect on the
                     relative position of the nodes in document order once they are added to a
                     tree.</p>
               </note>
               <p>Each attribute of the literal result element, other than an attribute in the
                     <termref def="dt-xslt-namespace">XSLT namespace</termref>, is processed to
                  produce an attribute for the element in the <termref def="dt-result-tree">result
                     tree</termref>.</p>
               <p>The value of such an attribute is interpreted as an <termref
                     def="dt-attribute-value-template">attribute value template</termref>: it can
                  therefore contain <termref def="dt-expression">expressions</termref> contained in
                  curly brackets (<code>{}</code>). The new attribute node will have the same
                     <termref def="dt-expanded-qname">expanded QName</termref> (that is, the same
                  namespace URI, local name, and namespace prefix) as the attribute in the
                  stylesheet tree, and its <termref def="dt-string-value">string value</termref>
                  will be the same as the <termref def="dt-effective-value">effective
                     value</termref> of the attribute in the stylesheet tree. The <termref
                     def="dt-type-annotation">type annotation</termref> on the attribute will
                  initially be <code>xs:untypedAtomic</code>, and the <termref def="dt-typed-value"
                     >typed value</termref> of the attribute node will be the same as its <termref
                     def="dt-string-value">string value</termref>.</p>
               <note>
                  <p>The eventual <termref def="dt-type-annotation"/> of the attribute in the
                        <termref def="dt-result-tree">result tree</termref> depends on the
                        <code>xsl:validation</code> and <code>xsl:type</code> attributes of the
                     parent literal result element, and on the instructions used to create its
                     ancestor elements. If the <code>xsl:validation</code> attribute is set to
                        <code>preserve</code> or <code>strip</code>, the type annotation will be
                        <code>xs:untypedAtomic</code>, and the <termref def="dt-typed-value">typed
                        value</termref> of the attribute node will be the same as its <termref
                        def="dt-string-value">string value</termref>. If the
                        <code>xsl:validation</code> attribute is set to <code>strict</code> or
                        <code>lax</code>, or if the <code>xsl:type</code> attribute is used, the
                     type annotation on the attribute will be set as a result of the schema
                     validation process applied to the parent element. If neither attribute is
                     present, the type annotation on the attribute will be
                        <code>xs:untypedAtomic</code>.</p>
               </note>
               <p>If the name of a constructed attribute is <code>xml:id</code>, the processor must
                  perform attribute value normalization by effectively applying the
                     <xfunction>normalize-space</xfunction> function to the value of the attribute,
                  and the resulting attribute node must be given the <code>is-id</code>
                  property.</p>
               <note diff="add" at="M">
                  <p> If the attribute name is <code>xml:space</code>, it is <emph>not</emph> an
                     error when the value is something other than <code>default</code> or
                        <code>preserve</code>. Although the XML specification states that other
                     values are erroneous, a document containing such values is well-formed; if
                     erroneous values are to be rejected, schema validation should be used. </p>
               </note>
               <p diff="del" at="M">
                  <error spec="XT" type="dynamic" class="RE" code="0795"><p>It is a recoverable
                        dynamic error if the name of a constructed attribute is
                           <code>xml:space</code> and the value is not either <code>default</code>
                        or <code>preserve</code>. <error.action>The optional recovery action is to
                           construct the attribute with the value as requested.</error.action>
                     </p></error>
                  <phrase diff="chg" at="L">This applies however the attribute is constructed (for
                     example, by using a literal result element, by using the
                        <elcode>xsl:attribute</elcode> instruction, or by implicit or explicit
                     copying from a source document).</phrase></p>
               <note>
                  <p>The <code>xml:base</code>, <code>xml:lang</code>, <code>xml:space</code>, and
                        <code>xml:id</code> attributes have two effects in XSLT. They behave as
                     standard XSLT attributes, which means for example that if they appear on a
                     literal result element, they will be copied to the <termref
                        def="dt-result-tree">result tree</termref> in the same way as any other
                     attribute. In addition, they have their standard meaning as defined in the core
                     XML specifications. Thus, an <code>xml:base</code> attribute in the stylesheet
                     affects the base URI of the element on which it appears, and an
                        <code>xml:space</code> attribute affects the interpretation of <termref
                        def="dt-whitespace-text-node">whitespace text nodes</termref> within that
                     element. One consequence of this is that it is inadvisable to write these
                     attributes as attribute value templates: although an XSLT processor will
                     understand this notation, the XML parser will not. See also <specref
                        ref="namespace-aliasing"/> which describes how to use
                        <elcode>xsl:namespace-alias</elcode> with these attributes.</p>
                  <p>The same is true of the schema-defined attributes <code>xsi:type</code>,
                        <code>xsi:nil</code>, <code>xsi:noNamespaceSchemaLocation</code>, and
                        <code>xsi:schemaLocation</code>. If the stylesheet is processed by a schema
                     processor, these attributes will be recognized and interpreted by the schema
                     processor, but in addition the XSLT processor treats them like any other
                     attribute on a literal result element: that is, their <termref
                        def="dt-effective-value">effective value</termref> (after expanding <termref
                        def="dt-attribute-value-template">attribute value templates</termref>) is
                     copied to the result tree in the same way as any other attribute. If the
                        <termref def="dt-result-tree">result tree</termref> is validated, the copied
                     attributes will again be recognized and interpreted by the schema
                     processor.</p>
                  <p>None of these attributes will be generated in the <termref def="dt-result-tree"
                        >result tree</termref> unless the stylesheet writes them to the result tree
                     explicitly, in the same way as any other attribute.</p>
               </note>
               <p>
                  <error spec="XT" type="static" class="SE" code="0805"><p>It is a <termref
                           def="dt-static-error">static error</termref> if an attribute on a literal
                        result element is in the <termref def="dt-xslt-namespace">XSLT
                           namespace</termref>, unless it is one of the attributes explicitly
                        defined in this specification.</p></error>
               </p>
               <note>
                  <p>If there is a need to create attributes in the XSLT namespace, this can be
                     achieved using <elcode>xsl:attribute</elcode>, or by means of the
                        <elcode>xsl:namespace-alias</elcode> declaration.</p>
               </note>
            </div3>
            <div3 id="lre-namespaces">
               <head>Namespace Nodes for Literal Result Elements</head>
               <p>The created element node will have a copy of the namespace nodes that were present
                  on the element node in the stylesheet tree with the exception of any namespace
                  node whose <termref def="dt-string-value">string value</termref> is designated as
                  an <term>excluded namespace</term>. Special considerations apply to aliased
                  namespaces: see <specref ref="namespace-aliasing"/>. </p>
               <p>The following namespaces are designated as excluded namespaces:</p>
               <ulist>
                  <item>
                     <p>The <termref def="dt-xslt-namespace">XSLT namespace</termref> URI
                           (<code>http://www.w3.org/1999/XSL/Transform</code>)</p>
                  </item>
                  <item>
                     <p>A namespace URI declared as an extension namespace (see <specref
                           ref="extension-instruction"/>)</p>
                  </item>
                  <item>
                     <p>A namespace URI designated by using an
                           <code>[xsl:]exclude-result-prefixes</code> attribute either on the
                        literal result element itself or on an ancestor element. The attribute
                           <rfc2119>must</rfc2119> be in the XSLT namespace only if its parent
                        element is <emph>not</emph> in the XSLT namespace.</p>
                     <p>The value of the attribute is either <code>#all</code>, or a
                        whitespace-separated list of tokens, each of which is either a namespace
                        prefix or <code>#default</code>. The namespace bound to each of the prefixes
                        is designated as an excluded namespace.</p>
                     <p>
                        <error class="SE" type="static" spec="XT" code="0808"><p>It is a <termref
                                 def="dt-static-error">static error</termref> if a namespace prefix
                              is used within the <code>[xsl:]exclude-result-prefixes</code>
                              attribute and there is no namespace binding in scope for that
                              prefix.</p></error>
                     </p>
                     <p>The default namespace of the parent element of the
                           <code>[xsl:]exclude-result-prefixes</code> attribute (see <xspecref
                           spec="DM30" ref="ElementNode"/>) may be designated as an excluded
                        namespace by including <code>#default</code> in the list of namespace
                        prefixes.</p>
                     <p>
                        <error class="SE" type="static" spec="XT" code="0809"><p>It is a <termref
                                 def="dt-static-error">static error</termref> if the value
                                 <code>#default</code> is used within the
                                 <code>[xsl:]exclude-result-prefixes</code> attribute and the parent
                              element of the <code>[xsl:]exclude-result-prefixes</code> attribute
                              has no default namespace.</p></error>
                     </p>
                     <p>The value <code>#all</code> indicates that all namespaces that are in scope
                        for the stylesheet element that is the parent of the
                           <code>[xsl:]exclude-result-prefixes</code> attribute are designated as
                        excluded namespaces.</p>
                     <p>The designation of a namespace as an excluded namespace is effective within
                        the subtree of the stylesheet module rooted at the element bearing the
                           <code>[xsl:]exclude-result-prefixes</code> attribute; a subtree rooted at
                        an <elcode>xsl:stylesheet</elcode> element does not include any stylesheet
                        modules imported or included by children of that
                           <elcode>xsl:stylesheet</elcode> element.</p>
                  </item>
               </ulist>
               <p>The excluded namespaces, as described above, <emph>only</emph> affect namespace
                  nodes copied from the stylesheet when processing a literal result element. There
                  is no guarantee that an excluded namespace will not appear on the <termref
                     def="dt-result-tree">result tree</termref> for some other reason. Namespace
                  nodes are also written to the result tree as part of the process of namespace
                  fixup (see <specref ref="namespace-fixup"/>), or as the result of instructions
                  such as <elcode>xsl:copy</elcode> and <elcode>xsl:element</elcode>.</p>
               <note>
                  <p>When a stylesheet uses a namespace declaration only for the purposes of
                     addressing a <termref def="dt-source-tree">source tree</termref>, specifying
                     the prefix in the <code>[xsl:]exclude-result-prefixes</code> attribute will
                     avoid superfluous namespace declarations in the serialized <termref
                        def="dt-result-tree">result tree</termref>. The attribute is also useful to
                     prevent namespaces used solely for the naming of stylesheet functions or
                     extension functions from appearing in the serialized result tree.</p>
               </note>
               <example>
                  <head>Excluding Namespaces from the Result Tree</head>
                  <p>Consider the following stylesheet:</p>
                  <eg xml:space="preserve" role="xslt-document">&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:a="a.uri"
  xmlns:b="b.uri"
  exclude-result-prefixes="#all"&gt;
  
&lt;xsl:template match="/"&gt;
  &lt;foo xmlns:c="c.uri" xmlns:d="d.uri" xmlns:a2="a.uri" 
       xsl:exclude-result-prefixes="c"/&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg>
                  <p>The result of this stylesheet will be:</p>
                  <eg xml:space="preserve" role="xml">&lt;foo xmlns:d="d.uri"/&gt;</eg>
                  <p>The namespaces <code>a.uri</code> and <code>b.uri</code> are excluded by virtue
                     of the <code>exclude-result-prefixes</code> attribute on the
                        <elcode>xsl:stylesheet</elcode> element, and the namespace
                        <code>c.uri</code> is excluded by virtue of the
                        <code>xsl:exclude-result-prefixes</code> attribute on the <code>foo</code>
                     element. The setting <code>#all</code> does not affect the namespace
                        <code>d.uri</code> because <code>d.uri</code> is not an in-scope namespace
                     for the <elcode>xsl:stylesheet</elcode> element. The element in the <termref
                        def="dt-result-tree">result tree</termref> does not have a namespace node
                     corresponding to <code>xmlns:a2="a.uri"</code> because the effect of
                        <code>exclude-result-prefixes</code> is to designate the namespace URI
                        <code>a.uri</code> as an excluded namespace, irrespective of how many
                     prefixes are bound to this namespace URI.</p>
                  <p>If the stylesheet is changed so that the literal result element has an
                     attribute <code>b:bar="3"</code>, then the element in the <termref
                        def="dt-result-tree">result tree</termref> will typically have a namespace
                     declaration <code>xmlns:b="b.uri"</code> (the processor may choose a different
                     namespace prefix if this is necessary to avoid conflicts). The
                        <code>exclude-result-prefixes</code> attribute makes <code>b.uri</code> an
                     excluded namespace, so the namespace node is not automatically copied from the
                     stylesheet, but the presence of an attribute whose name is in the namespace
                        <code>b.uri</code> forces the namespace fixup process (see <specref
                        ref="namespace-fixup"/>) to introduce a namespace node for this
                     namespace.</p>
               </example>
               <p>A literal result element may have an optional <code>xsl:inherit-namespaces</code>
                  attribute, with the value <code>yes</code> or <code>no</code>. The default value
                  is <code>yes</code>. If the value is set to <code>yes</code>, or is omitted, then
                  the namespace nodes created for the newly constructed element are copied to the
                  children and descendants of the newly constructed element, as described in
                     <specref ref="constructing-complex-content"/>. If the value is set to
                     <code>no</code>, then these namespace nodes are not automatically copied to the
                  children. This may result in namespace undeclarations (such as
                     <code>xmlns=""</code> or, in the case of XML 1.1, <code>xmlns:p=""</code>)
                  appearing on the child elements when <phrase diff="del" at="S-bug27258">a <termref
                        def="dt-final-result-tree">final result tree</termref> is</phrase><phrase
                     diff="add" at="S-bug27258">they are</phrase> serialized.</p>
            </div3>
            <div3 id="namespace-aliasing">
               <head>Namespace Aliasing</head>
               <p>When a stylesheet is used to define a transformation whose output is itself a
                  stylesheet module, or in certain other cases where the result document uses
                  namespaces that it would be inconvenient to use in the stylesheet, namespace
                  aliasing can be used to declare a mapping between a namespace URI used in the
                  stylesheet and the corresponding namespace URI to be used in the result
                  document.</p>
               <p>
                  <termdef id="dt-literal-namespace-uri" term="literal namespace URI">A namespace
                     URI in the stylesheet tree that is being used to specify a namespace URI in the
                        <termref def="dt-result-tree">result tree</termref> is called a
                        <term>literal namespace URI</term>.</termdef>
               </p>
               <p>
                  <termdef id="dt-target-namespace-uri" term="target namespace URI">The namespace
                     URI that is to be used in the <termref def="dt-result-tree">result
                        tree</termref> as a substitute for a <termref def="dt-literal-namespace-uri"
                        >literal namespace URI</termref> is called the <term>target namespace
                        URI</term>.</termdef>
               </p>
               <p>Either of the <termref def="dt-literal-namespace-uri">literal namespace
                     URI</termref> or the <termref def="dt-target-namespace-uri">target namespace
                     URI</termref> can be <emph>null</emph>: this is treated as a reference to the
                  set of names that are in no namespace.</p>
               <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
                  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="namespace-alias">
                  <e:in-category name="declaration"/>
                  <e:attribute name="stylesheet-prefix" required="yes">
                     <e:data-type name="prefix"/>
                     <e:constant value="#default"/>
                  </e:attribute>
                  <e:attribute name="result-prefix" required="yes">
                     <e:data-type name="prefix"/>
                     <e:constant value="#default"/>
                  </e:attribute>
                  <e:empty/>
                  <e:allowed-parents>
                     <e:parent name="package"/>
                     <e:parent name="stylesheet"/>
                     <e:parent name="transform"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p>
                  <termdef id="dt-alias" term="alias">A stylesheet can use the
                        <elcode>xsl:namespace-alias</elcode> element to declare that a <termref
                        def="dt-literal-namespace-uri">literal namespace URI</termref> is being used
                     as an <term>alias</term> for a <termref def="dt-target-namespace-uri">target
                        namespace URI</termref>.</termdef>
               </p>
               <p>The effect is that when names in the namespace identified by the <termref
                     def="dt-literal-namespace-uri">literal namespace URI</termref> are copied to
                  the <termref def="dt-result-tree">result tree</termref>, the namespace URI in the
                  result tree will be the <termref def="dt-target-namespace-uri">target namespace
                     URI</termref>, instead of the literal namespace URI. This applies to:</p>
               <ulist>
                  <item>
                     <p>the namespace URI in the <termref def="dt-expanded-qname">expanded
                           QName</termref> of a literal result element in the stylesheet</p>
                  </item>
                  <item>
                     <p>the namespace URI in the <termref def="dt-expanded-qname">expanded
                           QName</termref> of an attribute specified on a literal result element in
                        the stylesheet</p>
                  </item>
               </ulist>
               <p diff="add" at="I">The effect of an <elcode>xsl:namespace-alias</elcode>
                  declaration is local to the <termref def="dt-package">package</termref> in which
                  it appears: that is, it only affects the result of <termref
                     def="dt-literal-result-element">literal result elements</termref> within the
                  same package.</p>
               <p>Where namespace aliasing changes the namespace URI part of the <termref
                     def="dt-expanded-qname">expanded QName</termref> containing the name of an
                  element or attribute node, the namespace prefix in that expanded QName is replaced
                  by the prefix indicated by the <code>result-prefix</code> attribute of the
                     <elcode>xsl:namespace-alias</elcode> declaration.</p>
               <p>The <elcode>xsl:namespace-alias</elcode> element declares that the namespace URI
                  bound to the prefix specified by the <code>stylesheet-prefix</code> is the
                     <termref def="dt-literal-namespace-uri">literal namespace URI</termref>, and
                  the namespace URI bound to the prefix specified by the <code>result-prefix</code>
                  attribute is the <termref def="dt-target-namespace-uri">target namespace
                     URI</termref>. Thus, the <code>stylesheet-prefix</code> attribute specifies the
                  namespace URI that will appear in the stylesheet, and the
                     <code>result-prefix</code> attribute specifies the corresponding namespace URI
                  that will appear in the <termref def="dt-result-tree">result tree</termref>. </p>
               <p>The default namespace (as declared by <code>xmlns</code>) may be specified by
                  using <code>#default</code> instead of a prefix. If no default namespace is in
                  force, specifying <code>#default</code> denotes the null namespace URI. This
                  allows elements that are in no namespace in the stylesheet to acquire a namespace
                  in the result document, or vice versa.</p>
               <p>If a <termref def="dt-literal-namespace-uri">literal namespace URI</termref> is
                  declared to be an alias for multiple different <termref
                     def="dt-literal-namespace-uri">target namespace URIs</termref>, then the
                  declaration with the highest <termref def="dt-import-precedence">import
                     precedence</termref> is used.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0810"><p>It is a <termref
                           def="dt-static-error">static error</termref> if <phrase diff="add" at="I"
                           >within a <termref def="dt-package">package</termref></phrase> there is
                        more than one such declaration <error.extra>more than one
                              <elcode>xsl:namespace-alias</elcode> declaration</error.extra> with
                        the same <termref def="dt-literal-namespace-uri">literal namespace
                           URI</termref> and the same <termref def="dt-import-precedence">import
                           precedence</termref> and different values for the <termref
                           def="dt-target-namespace-uri">target namespace URI</termref>, unless
                        there is also an <elcode>xsl:namespace-alias</elcode> declaration with the
                        same <termref def="dt-literal-namespace-uri">literal namespace URI</termref>
                        and a higher import precedence. </p></error>
               </p>
               <p diff="add" at="R-bug7130">No error occurs if there is more than one such
                     <elcode>xsl:namespace-alias</elcode> declaration having the same <termref
                     def="dt-literal-namespace-uri">literal namespace URI</termref> and the same
                     <termref def="dt-target-namespace-uri">target namespace URI</termref>, even if
                  the <code>result-prefix</code> differs; in this case the
                     <code>result-prefix</code> used is the one that appears last in <termref
                     def="dt-declaration-order">declaration order</termref>. </p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0812"><p>It is a <termref
                           def="dt-static-error">static error</termref> if a value other than
                           <code>#default</code> is specified for either the
                           <code>stylesheet-prefix</code> or the <code>result-prefix</code>
                        attributes of the <elcode>xsl:namespace-alias</elcode> element when there is
                        no in-scope binding for that namespace prefix.</p></error>
               </p>
               <p>When a literal result element is processed, its namespace nodes are handled as
                  follows:</p>
               <ulist>
                  <item>
                     <p>A namespace node whose string value is a <termref
                           def="dt-literal-namespace-uri">literal namespace URI</termref> is not
                        copied to the <termref def="dt-result-tree">result tree</termref>.</p>
                  </item>
                  <item>
                     <p>A namespace node whose string value is a <termref
                           def="dt-target-namespace-uri">target namespace URI</termref> is copied to
                        the <termref def="dt-result-tree">result tree</termref>, whether or not the
                        URI identifies an excluded namespace.</p>
                  </item>
               </ulist>
               <p>In the event that the same URI is used as a <termref
                     def="dt-literal-namespace-uri">literal namespace URI</termref> and a <termref
                     def="dt-target-namespace-uri">target namespace URI</termref>, the second of
                  these rules takes precedence.</p>
               <note>
                  <p>These rules achieve the effect that the element generated from the literal
                     result element will have an in-scope namespace node that binds the
                        <code>result-prefix</code> to the <termref def="dt-target-namespace-uri"
                        >target namespace URI</termref>, provided that the namespace declaration
                     associating this prefix with this URI is in scope for both the
                        <elcode>xsl:namespace-alias</elcode> instruction and for the literal result
                     element. Conversely, the <code>stylesheet-prefix</code> and the <termref
                        def="dt-literal-namespace-uri">literal namespace URI</termref> will not
                     normally appear in the <termref def="dt-result-tree">result tree</termref>.</p>
               </note>
               <example>
                  <head>Using <elcode>xsl:namespace-alias</elcode> to Generate a Stylesheet</head>
                  <p>When literal result elements are being used to create element, attribute, or
                     namespace nodes that use the <termref def="dt-xslt-namespace">XSLT
                        namespace</termref> URI, the stylesheet may use an alias. </p>
                  <p>For example, the stylesheet</p>
                  <eg xml:space="preserve" role="xslt-document">&lt;xsl:stylesheet
  version="3.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:fo="http://www.w3.org/1999/XSL/Format"
  xmlns:axsl="file://namespace.alias"&gt;

&lt;xsl:namespace-alias stylesheet-prefix="axsl" result-prefix="xsl"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;axsl:stylesheet version="3.0"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/axsl:stylesheet&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="elements"&gt;
  &lt;axsl:template match="/"&gt;
     &lt;axsl:comment select="system-property('xsl:version')"/&gt;
     &lt;axsl:apply-templates/&gt;
  &lt;/axsl:template&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="block"&gt;
  &lt;axsl:template match="{.}"&gt;
     &lt;fo:block&gt;&lt;axsl:apply-templates/&gt;&lt;/fo:block&gt;
  &lt;/axsl:template&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg>
                  <p>will generate an XSLT stylesheet from a document of the form:</p>
                  <eg xml:space="preserve" role="xml">&lt;elements&gt;
&lt;block&gt;p&lt;/block&gt;
&lt;block&gt;h1&lt;/block&gt;
&lt;block&gt;h2&lt;/block&gt;
&lt;block&gt;h3&lt;/block&gt;
&lt;block&gt;h4&lt;/block&gt;
&lt;/elements&gt;</eg>
                  <p>The output of the transformation will be a stylesheet such as the following.
                     Whitespace has been added for clarity. Note that an implementation may output
                     different namespace prefixes from those appearing in this example; however, the
                     rules guarantee that there will be a namespace node that binds the prefix
                        <code>xsl</code> to the URI
                        <code>http://www.w3.org/1999/XSL/Transform</code>, which makes it safe to
                     use the QName <code>xsl:version</code> in the content of the generated
                     stylesheet.</p>
                  <eg xml:space="preserve" role="xslt-document">&lt;xsl:stylesheet
  version="3.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:comment select="system-property('xsl:version')"/&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;
  
&lt;xsl:template match="p"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h1"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h2"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h3"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h4"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg>
               </example>
               <note>
                  <p>It may be necessary also to use aliases for namespaces other than the XSLT
                     namespace URI. For example, it can be useful to define an alias for the
                     namespace <code>http://www.w3.org/2001/XMLSchema-instance</code>, so that the
                     stylesheet can use the attributes <code>xsi:type</code>, <code>xsi:nil</code>,
                     and <code>xsi:schemaLocation</code> on a literal result element, without
                     running the risk that a schema processor will interpret these as applying to
                     the stylesheet itself. Equally, literal result elements belonging to a
                     namespace dealing with digital signatures might cause XSLT stylesheets to be
                     mishandled by general-purpose security software; using an alias for the
                     namespace would avoid the possibility of such mishandling.</p>
               </note>
               <example>
                  <head>Aliasing the XML Namespace</head>
                  <p>It is possible to define an alias for the XML namespace.</p>
                  <eg xml:space="preserve" role="xslt-document">
&lt;xsl:stylesheet xmlns:axml="http://www.example.com/alias-xml"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="3.0"&gt;

&lt;xsl:namespace-alias stylesheet-prefix="axml" result-prefix="xml"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;name axml:space="preserve"&gt;
    &lt;first&gt;James&lt;/first&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;last&gt;Clark&lt;/last&gt;
  &lt;/name&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg>
                  <p>produces the output:</p>
                  <eg xml:space="preserve" role="xml">&lt;name xml:space="preserve"&gt;&lt;first&gt;James&lt;/first&gt; &lt;last&gt;Clark&lt;/last&gt;&lt;/name&gt;</eg>
                  <p>This allows an <code>xml:space</code> attribute to be generated in the output
                     without affecting the way the stylesheet is parsed. The same technique can be
                     used for other attributes such as <code>xml:lang</code>, <code>xml:base</code>,
                     and <code>xml:id</code>.</p>
               </example>
               <note>
                  <p>Namespace aliasing is only necessary when literal result elements are used. The
                     problem of reserved namespaces does not arise when using
                        <elcode>xsl:element</elcode> and <elcode>xsl:attribute</elcode> to construct
                     the <termref def="dt-result-tree">result tree</termref>. Therefore, as an
                     alternative to using <elcode>xsl:namespace-alias</elcode>, it is always
                     possible to achieve the desired effect by replacing literal result elements
                     with <elcode>xsl:element</elcode> and <elcode>xsl:attribute</elcode>
                     instructions.</p>
               </note>
            </div3>
            <div3 id="conditional-literal-result-elements" diff="del" at="S-bug27189">
               <head>Conditional Creation of Literal Result Elements</head>
               <p>If a literal result element has an <code>xsl:on-empty</code> attribute, then the
                  value of the attribute <rfc2119>must</rfc2119> be an XPath expression. If the
                  attribute is present and the constructed element has <phrase diff="chg" at="O">no
                     attributes and no children</phrase>, then instead of returning the constructed
                  element, the instruction returns the result of evaluating the expression in the
                     <code>xsl:on-empty</code> attribute<phrase diff="add" at="O">; if this
                     expression returns a node, the instruction returns a copy of this
                     node.</phrase></p>
               <p diff="add" at="O"> It is a <termref def="dt-type-error"/> if the result of
                  evaluating the <code>xsl:on-empty</code> attribute <error.extra>on a literal
                     result element</error.extra> does not satisfy the required type
                     <code>element()?</code>. That is, the expression must deliver either a single
                  element node, or an empty sequence.</p>
               <p diff="chg" at="O">If the <code>xsl:on-empty</code> expression is evaluated and
                  returns an empty sequence, then the <code>xsl:validation</code> and
                     <code>xsl:type</code> attributes are ignored. However, if the result of the
                     <code>xsl:on-empty</code> expression is an element, then it is subjected to
                  validation as determined by these attributes, along with
                     <code>[xsl:]default-validation</code> where relevant.</p>
               <p>Note that when a literal result element has one or more attributes (other than
                  attributes in the XSLT namespace), or when it references a non-empty attribute
                  set, the <code>on-empty</code> attribute has no effect because these conditions
                  will not be satisfied.</p>
            </div3>
         </div2>
         <div2 id="xsl-element">
            <head>Creating Element Nodes Using <code>xsl:element</code>
            </head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="element">
               <e:in-category name="instruction"/>
               <e:attribute name="name" required="yes">
                  <e:attribute-value-template>
                     <e:data-type name="qname"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="namespace">
                  <e:attribute-value-template>
                     <e:data-type name="uri"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="inherit-namespaces">
                  <e:data-type name="boolean"/>
               </e:attribute>
               <e:attribute name="use-attribute-sets">
                  <e:data-type name="eqnames"/>
               </e:attribute>
               <e:attribute name="type">
                  <e:data-type name="eqname"/>
               </e:attribute>
               <e:attribute name="validation">
                  <e:constant value="strict"/>
                  <e:constant value="lax"/>
                  <e:constant value="preserve"/>
                  <e:constant value="strip"/>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:element</elcode> instruction allows an element to be created with a
               computed name. The <termref def="dt-expanded-qname">expanded QName</termref> of the
               element to be created is specified by a <rfc2119>required</rfc2119>
               <code>name</code> attribute and an optional <code>namespace</code> attribute.</p>
            <p>The result of evaluating the <elcode>xsl:element</elcode> instruction, <phrase
                  diff="chg" at="L">in usual circumstances</phrase>, is the newly constructed
               element node.</p>
            <div3 id="xsl-element-content">
               <head>The Content of the Constructed Element Node</head>
               <p>The content of the <elcode>xsl:element</elcode> instruction is a <termref
                     def="dt-sequence-constructor">sequence constructor</termref> for the children,
                  attributes, and namespaces of the created element. The sequence obtained by
                  evaluating this sequence constructor (see <specref ref="sequence-constructors"/>)
                  is used to construct the content of the element, as described in <specref
                     ref="constructing-complex-content"/>.</p>
               <p>The <elcode>xsl:element</elcode> element may have a
                     <code>use-attribute-sets</code> attribute, whose value is a
                  whitespace-separated list of QNames that identify
                     <elcode>xsl:attribute-set</elcode> declarations. If this attribute is present,
                  it is expanded as described in <specref ref="attribute-sets"/> to produce a
                  sequence of attribute nodes. This sequence is prepended to the sequence produced
                  as a result of evaluating the <termref def="dt-sequence-constructor"/>, as
                  described in <specref ref="constructing-complex-content"/>.</p>
            </div3>
            <div3 id="xsl-element-name">
               <head>The Name of the Constructed Element Node</head>
               <p>The <code>name</code> attribute is interpreted as an <termref
                     def="dt-attribute-value-template">attribute value template</termref>, whose
                     <termref def="dt-effective-value">effective value</termref>
                  <rfc2119>must</rfc2119> be a <termref def="dt-lexical-qname">lexical
                     QName</termref>.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="0820"><p>It is a <termref
                           def="dt-dynamic-error"><phrase diff="del" at="M">non-recoverable</phrase>
                           dynamic error</termref> if the <termref def="dt-effective-value"
                           >effective value</termref> of the <code>name</code> attribute
                           <error.extra>of the <elcode>xsl:element</elcode>
                           instruction</error.extra> is not a <termref def="dt-lexical-qname"
                           >lexical QName</termref>. </p></error>
               </p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="0830"><p>In the case of an
                           <elcode>xsl:element</elcode> instruction with no <code>namespace</code>
                        attribute, it is a <termref def="dt-dynamic-error"><phrase diff="del" at="M"
                              >non-recoverable</phrase> dynamic error</termref> if the <termref
                           def="dt-effective-value">effective value</termref> of the
                           <code>name</code> attribute is a <termref def="dt-lexical-qname">lexical
                           QName</termref> whose prefix is not declared in an in-scope namespace
                        declaration for the <elcode>xsl:element</elcode> instruction.</p></error>
               </p>
               <p>If the <code>namespace</code> attribute is not present then the <termref
                     def="dt-lexical-qname">lexical QName</termref> is expanded into an <termref
                     def="dt-expanded-qname">expanded QName</termref> using the namespace
                  declarations in effect for the <elcode>xsl:element</elcode> element, including any
                  default namespace declaration.</p>
               <p>If the <code>namespace</code> attribute is present, then it too is interpreted as
                  an <termref def="dt-attribute-value-template">attribute value template</termref>.
                  The <termref def="dt-effective-value">effective value</termref>
                  <rfc2119>must</rfc2119> be in the lexical space of the <code>xs:anyURI</code>
                  type. If the string is zero-length, then the <termref def="dt-expanded-qname"
                     >expanded QName</termref> of the element has a null namespace URI. Otherwise,
                  the string is used as the namespace URI of the <termref def="dt-expanded-qname"
                     >expanded QName</termref> of the element to be created. The local part of the
                     <termref def="dt-lexical-qname">lexical QName</termref> specified by the
                     <code>name</code> attribute is used as the local part of the <termref
                     def="dt-expanded-qname">expanded QName</termref> of the element to be
                  created.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="0835"><p> It is a <termref
                           def="dt-dynamic-error"><phrase diff="del" at="M">non-recoverable</phrase>
                           dynamic error</termref> if the <termref def="dt-effective-value"
                           >effective value</termref> of the <code>namespace</code> attribute
                           <error.extra>of the <elcode>xsl:element</elcode>
                           instruction</error.extra> is not in the lexical space of the
                           <code>xs:anyURI</code> datatype or if it is the string
                           <code>http://www.w3.org/2000/xmlns/</code>.</p></error>
               </p>
               <note>
                  <p>The XDM data model requires the name of a node to be an instance of
                        <code>xs:QName</code>, and XML Schema defines the namespace part of an
                        <code>xs:QName</code> to be an instance of <code>xs:anyURI</code>. However,
                     the schema specification, and the specifications that it refers to, give
                     implementations some flexibility in how strictly they enforce these
                     constraints.</p>
               </note>
               <p>The prefix of the <termref def="dt-lexical-qname">lexical QName</termref>
                  specified in the <code>name</code> attribute (or the absence of a prefix) is
                  copied to the prefix part of the <termref def="dt-expanded-qname">expanded
                     QName</termref> representing the name of the new element node. In the event of
                  a conflict a prefix may subsequently be added, changed, or removed during the
                  namespace fixup process (see <specref ref="namespace-fixup"/>). The term
                     <emph>conflict</emph> here means any violation of the constraints defined in
                     <bibref ref="xpath-datamodel-30"/>, for example the use of the same prefix to
                  refer to two different namespaces in the element and in one of its attributes, the
                  use of the prefix <code>xml</code> to refer to a namespace other than the XML
                  namespace, or any use of the prefix <code>xmlns</code>.</p>
            </div3>
            <div3 id="xsl-element-properties">
               <head>Other Properties of the Constructed Element Node</head>
               <p>The <elcode>xsl:element</elcode> instruction has an optional
                     <code>inherit-namespaces</code> attribute, with the value <code>yes</code> or
                     <code>no</code>. The default value is <code>yes</code>. If the value is set to
                     <code>yes</code>, or is omitted, then the namespace nodes created for the newly
                  constructed element (whether these were copied from those of the source node, or
                  generated as a result of namespace fixup) are copied to the children and
                  descendants of the newly constructed element, as described in <specref
                     ref="constructing-complex-content"/>. If the value is set to <code>no</code>,
                  then these namespace nodes are not automatically copied to the children. This may
                  result in namespace undeclarations (such as <code>xmlns=""</code> or, in the case
                  of XML Namespaces 1.1, <code>xmlns:p=""</code>) appearing on the child elements
                  when <phrase diff="del" at="S-bug27258">a <termref def="dt-final-result-tree"
                        >final result tree</termref></phrase>
                  <phrase diff="add" at="S-bug27258">the element</phrase> is serialized.</p>
               <p>The base URI of the new element is copied from the base URI of the
                     <elcode>xsl:element</elcode> instruction in the stylesheet, unless the content
                  of the new element includes an <code>xml:base</code> attribute, in which case the
                  base URI of the new element is the value of that attribute, resolved (if it is a
                  relative URI) against the base URI of the <elcode>xsl:element</elcode> instruction
                  in the stylesheet. (Note, however, that this is only relevant when creating
                  parentless elements. When the new element is copied to form a child of an element
                  or document node, the base URI of the new copy is taken from that of its new
                  parent.)</p>
               <p diff="add" at="S-bug28565">The values of the <code>nilled</code>,
                     <code>is-id</code>, and <code>is-idrefs</code> properties of the new element
                  depend on the <code>type</code> and <code>validation</code> attributes of the
                     <elcode>xsl:element</elcode> instruction, as explained in <specref
                     ref="validation"/>.</p>
            </div3>
            <div3 id="annotation-for-constructed-element">
               <head>The Type Annotation of the Constructed Element Node</head>
               <p>The optional attributes <code>type</code> and <code>validation</code> may be used
                  on the <elcode>xsl:element</elcode> instruction to invoke validation of the
                  contents of the element against a type definition or element declaration in a
                  schema, and to determine the <termref def="dt-type-annotation">type
                     annotation</termref> that the new element node will carry. These attributes
                  also affect the type annotation carried by any elements and attributes that have
                  the new element node as an ancestor. These two attributes are both optional, and
                  if one is specified then the other <rfc2119>must</rfc2119> be omitted. The
                  permitted values of these attributes and their semantics are described in <specref
                     ref="validation"/>.</p>
               <note>
                  <p>The final type annotation of the element in the <termref def="dt-result-tree"
                        >result tree</termref> also depends on the <code>type</code> and
                        <code>validation</code> attributes of the instructions used to create the
                     ancestors of the element.</p>
               </note>
            </div3>
            <div3 id="xsl-element-on-empty" diff="del" at="S-bug27189">
               <head>Conditional Construction of Element Nodes</head>
               <p>If the <code>on-empty</code> attribute is present and the content of the
                  constructed element as determined by the rules in <specref
                     ref="xsl-element-content"/> (that is, the result of evaluating the sequence
                  constructor and prepending any attributes generated by the
                     <code>use-attribute-sets</code> attribute) is a sequence containing nothing
                  other than namespace nodes and zero-length text nodes, then instead of returning
                  the newly constructed element node, the instruction returns the result of
                  evaluating the expression in the <code>on-empty</code> attribute<phrase diff="add"
                     at="O">; if this expression returns a node, the instruction returns a copy of
                     this node</phrase>.</p>
               <p>It is a <termref def="dt-type-error"/> if the result of evaluating the
                     <code>on-empty</code> attribute <error.extra>on the
                        <elcode>xsl:element</elcode> instruction</error.extra> does not satisfy the
                  required type <code>element()?</code>. That is, the expression must deliver either
                  a single element node, or an empty sequence.</p>
               <p diff="add" at="O">If the <code>on-empty</code> expression is evaluated and returns
                  an empty sequence, then the <code>validation</code> and <code>type</code>
                  attributes are ignored. However, if the result of the <code>on-empty</code>
                  expression is an element, then it is subjected to validation as determined by
                  these attributes, along with <code>[xsl:]default-validation</code> where
                  relevant.</p>
            </div3>
         </div2>
         <div2 id="creating-attributes">
            <head>Creating Attribute Nodes Using <code>xsl:attribute</code>
            </head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="attribute">
               <e:in-category name="instruction"/>
               <e:attribute name="name" required="yes">
                  <e:attribute-value-template>
                     <e:data-type name="qname"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="namespace">
                  <e:attribute-value-template>
                     <e:data-type name="uri"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="select">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="separator">
                  <e:attribute-value-template>
                     <e:data-type name="string"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="type">
                  <e:data-type name="eqname"/>
               </e:attribute>
               <e:attribute name="validation">
                  <e:constant value="strict"/>
                  <e:constant value="lax"/>
                  <e:constant value="preserve"/>
                  <e:constant value="strip"/>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent name="attribute-set"/>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:attribute</elcode> element can be used to add attributes to result
               elements whether created by literal result elements in the stylesheet or by
               instructions such as <elcode>xsl:element</elcode> or <elcode>xsl:copy</elcode>. The
                  <termref def="dt-expanded-qname">expanded QName</termref> of the attribute to be
               created is specified by a <rfc2119>required</rfc2119>
               <code>name</code> attribute and an optional <code>namespace</code> attribute. Except
               in error cases, the result of evaluating an <elcode>xsl:attribute</elcode>
               instruction is the newly constructed attribute node.</p>
            <p>The string value of the new attribute node may be defined either by using the
                  <code>select</code> attribute, or by the <termref def="dt-sequence-constructor"
                  >sequence constructor</termref> that forms the content of the
                  <elcode>xsl:attribute</elcode> element. <phrase diff="chg" at="K">These are
                  mutually exclusive: if the <code>select</code> attribute is present then the
                  sequence constructor must be empty, and if the sequence constructor is non-empty
                  then the <code>select</code> attribute must be absent. If the <code>select</code>
                  attribute is absent and the sequence constructor is empty</phrase>, then the
               string value of the new attribute node will be a zero-length string. The way in which
               the value is constructed is specified in <specref ref="constructing-simple-content"
               />.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0840"><p>It is a <termref
                        def="dt-static-error">static error</termref> if the <code>select</code>
                     attribute of the <elcode>xsl:attribute</elcode> element is present unless the
                     element has empty content.</p></error>
            </p>
            <p>If the <code>separator</code> attribute is present, then the <termref
                  def="dt-effective-value">effective value</termref> of this attribute is used to
               separate adjacent items in the result sequence, as described in <specref
                  ref="constructing-simple-content"/>. In the absence of this attribute, the default
               separator is a single space (#x20) when the content is specified using the
                  <code>select</code> attribute, or a zero-length string when the content is
               specified using a <termref def="dt-sequence-constructor">sequence
                  constructor</termref>.</p>
            <p>The <code>name</code> attribute is interpreted as an <termref
                  def="dt-attribute-value-template">attribute value template</termref>, whose
                  <termref def="dt-effective-value">effective value</termref>
               <rfc2119>must</rfc2119> be a <termref def="dt-lexical-qname">lexical
               QName</termref>.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0850"><p>It is a <termref
                        def="dt-dynamic-error"><phrase diff="del" at="M">non-recoverable</phrase>
                        dynamic error</termref> if the <termref def="dt-effective-value">effective
                        value</termref> of the <code>name</code> attribute <error.extra>of an
                           <elcode>xsl:attribute</elcode> instruction</error.extra> is not a
                        <termref def="dt-lexical-qname">lexical QName</termref>.</p></error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0855"><p>In the case of an
                        <elcode>xsl:attribute</elcode> instruction with no <code>namespace</code>
                     attribute, it is a <termref def="dt-dynamic-error"><phrase diff="del" at="M"
                           >non-recoverable</phrase> dynamic error</termref> if the <termref
                        def="dt-effective-value">effective value</termref> of the <code>name</code>
                     attribute is the string <code>xmlns</code>.</p></error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0860"><p>In the case of an
                        <elcode>xsl:attribute</elcode> instruction with no <code>namespace</code>
                     attribute, it is a <termref def="dt-dynamic-error"><phrase diff="del" at="M"
                           >non-recoverable</phrase> dynamic error</termref> if the <termref
                        def="dt-effective-value">effective value</termref> of the <code>name</code>
                     attribute is a <termref def="dt-lexical-qname">lexical QName</termref> whose
                     prefix is not declared in an in-scope namespace declaration for the
                        <elcode>xsl:attribute</elcode> instruction.</p></error>
            </p>
            <p>If the <code>namespace</code> attribute is not present, then the <termref
                  def="dt-lexical-qname">lexical QName</termref> is expanded into an <termref
                  def="dt-expanded-qname">expanded QName</termref> using the namespace declarations
               in effect for the <elcode>xsl:attribute</elcode> element, <emph>not</emph> including
               any default namespace declaration.</p>
            <p>If the <code>namespace</code> attribute is present, then it too is interpreted as an
                  <termref def="dt-attribute-value-template">attribute value template</termref>. The
                  <termref def="dt-effective-value">effective value</termref>
               <rfc2119>must</rfc2119> be in the lexical space of the <code>xs:anyURI</code> type.
               If the string is zero-length, then the <termref def="dt-expanded-qname">expanded
                  QName</termref> of the attribute has a null namespace URI. Otherwise, the string
               is used as the namespace URI of the <termref def="dt-expanded-qname">expanded
                  QName</termref> of the attribute to be created. The local part of the <termref
                  def="dt-lexical-qname">lexical QName</termref> specified by the <code>name</code>
               attribute is used as the local part of the <termref def="dt-expanded-qname">expanded
                  QName</termref> of the attribute to be created.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0865"><p> It is a <termref
                        def="dt-dynamic-error"><phrase diff="del" at="M">non-recoverable</phrase>
                        dynamic error</termref> if the <termref def="dt-effective-value">effective
                        value</termref> of the <code>namespace</code> attribute <error.extra>of the
                           <elcode>xsl:attribute</elcode> instruction</error.extra> is not in the
                     lexical space of the <code>xs:anyURI</code> datatype or if it is the string
                        <code>http://www.w3.org/2000/xmlns/</code>.</p></error>
            </p>
            <note>
               <p>The same considerations apply as for elements: <errorref spec="XT" class="DE"
                     code="0835"/> in <specref ref="xsl-element"/>.</p>
            </note>
            <p>The prefix of the <termref def="dt-lexical-qname">lexical QName</termref> specified
               in the <code>name</code> attribute (or the absence of a prefix) is copied to the
               prefix part of the <termref def="dt-expanded-qname">expanded QName</termref>
               representing the name of the new attribute node. In the event of a conflict this
               prefix may subsequently be added, changed, or removed during the namespace fixup
               process (see <specref ref="namespace-fixup"/>). If the attribute is in a non-null
               namespace and no prefix is specified, then the namespace fixup process will invent a
               prefix. The term <emph>conflict</emph> here means any violation of the constraints
               defined in <bibref ref="xpath-datamodel-30"/>, for example the use of the same prefix
               to refer to two different namespaces in the element and in one of its attributes, the
               use of the prefix <code>xml</code> to refer to a namespace other than the XML
               namespace, or any use of the prefix <code>xmlns</code>.</p>
            <p>If the name of a constructed attribute is <code>xml:id</code>, the processor must
               perform attribute value normalization by effectively applying the
                  <xfunction>normalize-space</xfunction> function to the value of the attribute, and
               the resulting attribute node must be given the <code>is-id</code> property. This
               applies whether the attribute is constructed using the <elcode>xsl:attribute</elcode>
               instruction or whether it is constructed using an attribute of a literal result
               element. This does not imply any constraints on the value of the attribute, or on its
               uniqueness, and it does not affect the <termref def="dt-type-annotation">type
                  annotation</termref> of the attribute, unless the containing document is
               validated.</p>
            <note>
               <p>The effect of setting the <code>is-id</code> property is that the parent element
                  can be located within the containing document by use of the
                     <xfunction>id</xfunction> function. In effect, XSLT when constructing a
                  document performs some of the functions of an <code>xml:id</code> processor, as
                  defined in <bibref ref="xml-id"/>; the other aspects of <code>xml:id</code>
                  processing are performed during validation.</p>
            </note>
            <example>
               <head>Creating a List-Valued Attribute</head>
               <p>The following instruction creates the attribute <code>colors="red green
                     blue"</code>:</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:attribute name="colors" select="'red', 'green', 'blue'"/&gt;</eg>
            </example>
            <example>
               <head>Namespaces are not Attributes</head>
               <p>It is not an error to write:</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:attribute name="xmlns:xsl" 
   namespace="file://some.namespace"
   select="'http://www.w3.org/1999/XSL/Transform'"/&gt;</eg>
               <p>However, this will not result in the namespace declaration
                     <code>xmlns:xsl="http://www.w3.org/1999/XSL/Transform"</code> being output.
                  Instead, it will produce an attribute node with local name <code>xsl</code>, and
                  with a system-allocated namespace prefix mapped to the namespace URI
                     <code>file://some.namespace</code>. This is because the namespace fixup process
                  is not allowed to use <code>xmlns</code> as the name of a namespace node.</p>
            </example>
            <p>As described in <specref ref="constructing-complex-content"/>, in a sequence that is
               used to construct the content of an element, any attribute nodes
                  <rfc2119>must</rfc2119> appear in the sequence before any element, text, comment,
               or processing instruction nodes. Where the sequence contains two or more attribute
               nodes with the same <termref def="dt-expanded-qname">expanded QName</termref>, the
               one that comes last is the only one that takes effect.</p>
            <note>
               <p>If a collection of attributes is generated repeatedly, this can be done
                  conveniently by using named attribute sets: see <specref ref="attribute-sets"/>
               </p>
            </note>
            <div3 id="annotation-for-constructed-attribute">
               <head>Setting the Type Annotation for a Constructed Attribute Node</head>
               <p>The optional attributes <code>type</code> and <code>validation</code> may be used
                  on the <elcode>xsl:attribute</elcode> instruction to invoke validation of the
                  contents of the attribute against a type definition or attribute declaration in a
                  schema, and to determine the <termref def="dt-type-annotation">type
                     annotation</termref> that the new attribute node will carry. These two
                  attributes are both optional, and if one is specified then the other
                     <rfc2119>must</rfc2119> be omitted. The permitted values of these attributes
                  and their semantics are described in <specref ref="validation"/>.</p>
               <p diff="add" at="S-bug28565">The process of validation also determines the values of
                  the <code>is-id</code> and <code>is-idrefs</code> properties on the new attribute
                  node.</p>
               <note>
                  <p>The final <termref def="dt-type-annotation"/> of the attribute in the <termref
                        def="dt-result-tree">result tree</termref> also depends on the
                        <code>type</code> and <code>validation</code> attributes of the instructions
                     used to create the ancestors of the attribute.</p>
               </note>
            </div3>
            <div3 id="xsl-attribute-on-empty" diff="del" at="R-bug24378">
               <head>Conditional Creation of Attribute Nodes</head>
               <p>If the <code>on-empty</code> attribute is present and the string value of the
                  constructed attribute is a zero-length string, then instead of returning the
                  constructed attribute, the instruction returns the result of evaluating the
                  expression in the <code>on-empty</code> attribute;<phrase diff="add" at="O"> if
                     this expression returns a node, the instruction returns a copy of the
                     node</phrase>. </p>
               <p>It is a <termref def="dt-type-error"/> if the result of evaluating the
                     <code>on-empty</code> attribute <error.extra>on the
                        <elcode>xsl:attribute</elcode> instruction</error.extra> does not satisfy
                  the required type <code>attribute()?</code>. That is, the expression must deliver
                  either a single attribute node, or an empty sequence.</p>
               <p diff="chg" at="O">If the <code>on-empty</code> expression is evaluated and returns
                  an empty sequence, then the <code>validation</code> and <code>type</code>
                  attributes are ignored. However, if the result of the <code>on-empty</code>
                  expression is an attribute node, then it is subjected to validation as determined
                  by these attributes, along with <code>[xsl:]default-validation</code> where
                  relevant.</p>
            </div3>
         </div2>
         <div2 id="creating-text-nodes">
            <head>Creating Text Nodes</head>
            <p>This section describes three different ways of creating text nodes: by means of
               literal text nodes in the stylesheet, or by using the <elcode>xsl:text</elcode> and
                  <elcode>xsl:value-of</elcode> instructions. It is also possible to create text
               nodes using the <elcode>xsl:number</elcode> instruction described in <specref
                  ref="number"/>.</p>
            <p>If and when the sequence that results from evaluating a <termref
                  def="dt-sequence-constructor">sequence constructor</termref> is used to form the
               content of a node, as described in <specref ref="constructing-simple-content"/> and
                  <specref ref="constructing-complex-content"/>, adjacent text nodes in the sequence
               are merged. Within the sequence itself, however, they exist as distinct nodes.</p>
            <example>
               <head>A Sequence of Text Nodes</head>
               <p>The following function returns a sequence of three text nodes:</p>
               <eg xml:space="preserve" role="xslt-declaration xmlns:f='f'">&lt;xsl:function name="f:wrap"&gt;
  &lt;xsl:param name="s"/&gt;
  &lt;xsl:text&gt;(&lt;/xsl:text&gt;
  &lt;xsl:value-of select="$s"/&gt;
  &lt;xsl:text&gt;)&lt;/xsl:text&gt;
&lt;/xsl:function&gt;</eg>
               <p>When this function is called as follows:</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:value-of select="f:wrap('---')"/&gt;</eg>
               <p>the result is:</p>
               <eg xml:space="preserve" role="non-xml">(---)</eg>
               <p>No additional spaces are inserted, because the calling
                     <elcode>xsl:value-of</elcode> instruction merges adjacent text nodes before
                  atomizing the sequence. However, the result of the instruction:</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:value-of select="data(f:wrap('---'))"/&gt;</eg>
               <p>is:</p>
               <eg xml:space="preserve" role="non-xml">( --- )</eg>
               <p>because in this case the three text nodes are atomized to form three strings, and
                  spaces are inserted between adjacent strings.</p>
            </example>
            <p>It is possible to construct text nodes whose string value is zero-length. A
               zero-length text node, when atomized, produces a zero-length string. However,
               zero-length text nodes are ignored when they appear in a sequence that is used to
               form the content of a node, as described in <specref
                  ref="constructing-complex-content"/> and <specref
                  ref="constructing-simple-content"/>.</p>
            <div3 id="literal-text-nodes">
               <head>Literal Text Nodes</head>
               <p>A <termref def="dt-sequence-constructor"/> can contain text nodes. Each text node
                  in a sequence constructor remaining after <termref def="dt-whitespace-text-node"
                     >whitespace text nodes</termref> have been stripped as specified in <specref
                     ref="stylesheet-stripping"/> will construct a new text node with the same
                     <termref def="dt-string-value">string value</termref>. The resulting text node
                  is added to the result of the containing sequence constructor.</p>
               <p>Text is processed at the tree level. Thus, markup of <code>&amp;lt;</code> in a
                  template will be represented in the stylesheet tree by a text node that includes
                  the character <code>&lt;</code>. This will create a text node in the <termref
                     def="dt-result-tree">result tree</termref> that contains a <code>&lt;</code>
                  character, which will be represented by the markup <code>&amp;lt;</code> (or an
                  equivalent character reference) when the result tree is serialized as an XML
                  document, unless otherwise specified using <termref def="dt-character-map"
                     >character maps</termref> (see <specref ref="character-maps"/>) or
                     <code>disable-output-escaping</code> (see <specref
                     ref="disable-output-escaping"/>).</p>
            </div3>
            <div3 id="xsl-text">
               <head>Creating Text Nodes Using <code>xsl:text</code>
               </head>
               <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
                  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="text">
                  <e:in-category name="instruction"/>
                  <e:attribute name="disable-output-escaping" deprecated="yes">
                     <e:data-type name="boolean"/>
                  </e:attribute>
                  <e:text/>
                  <e:allowed-parents>
                     <e:parent-category name="sequence-constructor"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p>The <elcode>xsl:text</elcode> element is evaluated to construct a new text
                  node.</p>
               <p diff="add" at="R-bug26525">If the element or one of its ancestors has an
                     <code>[xsl:]expand-text</code> attribute, and the nearest ancestor with such an
                  attribute has the value <code>yes</code>, then any unescaped curly brackets in the
                  value of the element indicate the presence of <termref
                     def="dt-text-value-template">text value templates</termref>, which are expanded
                  as described in <specref ref="text-value-templates"/>.</p>
               <p><phrase diff="add" at="R-bug26525">In the absence of such an attribute, or if the
                     effective value is <code>no</code>,</phrase> the content of the
                     <elcode>xsl:text</elcode> element is a single text node whose value forms the
                     <termref def="dt-string-value">string value</termref> of the new text node. An
                     <elcode>xsl:text</elcode> element may be empty, in which case the result of
                  evaluating the instruction is a text node whose string value is the zero-length
                  string.</p>
               <p>The result of evaluating an <elcode>xsl:text</elcode> instruction is the newly
                  constructed text node.</p>
               <p>A text node that is an immediate child of an <elcode>xsl:text</elcode> instruction
                  will not be stripped from the stylesheet tree, even if it consists entirely of
                  whitespace (see <specref ref="strip"/>).</p>
               <p>For the effect of the <termref def="dt-deprecated">deprecated</termref>
                  <code>disable-output-escaping</code> attribute, see <specref
                     ref="disable-output-escaping"/>
               </p>
               <note>
                  <p>It is not always necessary to use the <elcode>xsl:text</elcode> instruction to
                     write text nodes to the <termref def="dt-result-tree">result tree</termref>.
                     Literal text can be written to the result tree by including it anywhere in a
                        <termref def="dt-sequence-constructor"/>, while computed text can be output
                     using the <elcode>xsl:value-of</elcode> instruction. The principal reason for
                     using <elcode>xsl:text</elcode> is that it offers improved control over
                     whitespace handling.</p>
               </note>
            </div3>
            <div3 id="value-of">
               <head>Generating Text with <elcode>xsl:value-of</elcode>
               </head>
               <p>Within a <termref def="dt-sequence-constructor"/>, the
                     <elcode>xsl:value-of</elcode> instruction can be used to generate computed text
                  nodes. The <elcode>xsl:value-of</elcode> instruction computes the text using an
                     <termref def="dt-expression">expression</termref> that is specified as the
                  value of the <code>select</code> attribute, or by means of contained instructions.
                  This might, for example, extract text from a <termref def="dt-source-tree">source
                     tree</termref> or insert the value of a variable. </p>
               <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
                  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="value-of">
                  <e:in-category name="instruction"/>
                  <e:attribute name="select">
                     <e:data-type name="expression"/>
                  </e:attribute>
                  <e:attribute name="separator">
                     <e:attribute-value-template>
                        <e:data-type name="string"/>
                     </e:attribute-value-template>
                  </e:attribute>
                  <e:attribute name="disable-output-escaping" deprecated="yes">
                     <e:data-type name="boolean"/>
                  </e:attribute>
                  <e:model name="sequence-constructor"/>
                  <e:allowed-parents>
                     <e:parent-category name="sequence-constructor"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p>The <elcode>xsl:value-of</elcode> instruction is evaluated to construct a new text
                  node; the result of the instruction is the newly constructed text node.</p>
               <p>The string value of the new text node may be defined either by using the
                     <code>select</code> attribute, or by the <termref def="dt-sequence-constructor"
                     >sequence constructor</termref> (see <specref ref="sequence-constructors"/>)
                  that forms the content of the <elcode>xsl:value-of</elcode> element. <phrase
                     diff="chg" at="K">These are mutually exclusive: if the <code>select</code>
                     attribute is present then the sequence constructor must be empty, and if the
                     sequence constructor is non-empty then the <code>select</code> attribute must
                     be absent. If the <code>select</code> attribute is absent and the sequence
                     constructor is empty, then the result of the instruction is a text node whose
                     string value is zero-length.</phrase> The way in which the value is constructed
                  is specified in <specref ref="constructing-simple-content"/>.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0870"><p>It is a <termref
                           def="dt-static-error">static error</termref> if the <code>select</code>
                        attribute of the <elcode>xsl:value-of</elcode> element is present when the
                        content of the element is non-empty.<phrase diff="del" at="L">, or if the
                              <code>select</code> attribute is absent when the content is
                           empty.</phrase></p></error>
               </p>
               <p>If the <code>separator</code> attribute is present, then the <termref
                     def="dt-effective-value">effective value</termref> of this attribute is used to
                  separate adjacent items in the result sequence, as described in <specref
                     ref="constructing-simple-content"/>. In the absence of this attribute, the
                  default separator is a single space (#x20) when the content is specified using the
                     <code>select</code> attribute, or a zero-length string when the content is
                  specified using a <termref def="dt-sequence-constructor">sequence
                     constructor</termref>.</p>
               <p><phrase diff="chg" at="D">Special rules apply when the instruction is processed
                     with <termref def="dt-xslt-10-behavior">XSLT 1.0 behavior</termref>.</phrase>
                  If no <code>separator</code> attribute is present, and if the <code>select</code>
                  attribute is present, then all items in the <termref def="dt-atomization"
                     >atomized</termref> result sequence other than the first are ignored.</p>
               <example>
                  <head>Generating a List with Separators</head>
                  <p>The instruction:</p>
                  <eg xml:space="preserve" role="xslt-fragment">&lt;x&gt;&lt;xsl:value-of select="1 to 4" separator="|"/&gt;&lt;/x&gt;</eg>
                  <p>produces the output:</p>
                  <eg xml:space="preserve" role="xml">&lt;x&gt;1|2|3|4&lt;/x&gt;</eg>
               </example>
               <note>
                  <p>The <elcode>xsl:copy-of</elcode> element can be used to copy a sequence of
                     nodes to the <termref def="dt-result-tree">result tree</termref> without
                        <termref def="dt-atomization">atomization</termref>. See <specref
                        ref="copy-of"/>.</p>
               </note>
               <p>For the effect of the <termref def="dt-deprecated">deprecated</termref>
                  <code>disable-output-escaping</code> attribute, see <specref
                     ref="disable-output-escaping"/>
               </p>
            </div3>
         </div2>
         <div2 id="creating-document-nodes">
            <head>Creating Document Nodes</head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="document">
               <e:in-category name="instruction"/>
               <e:attribute name="validation">
                  <e:constant value="strict"/>
                  <e:constant value="lax"/>
                  <e:constant value="preserve"/>
                  <e:constant value="strip"/>
               </e:attribute>
               <e:attribute name="type">
                  <e:data-type name="eqname"/>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:document</elcode> instruction is used to create a new document node.
               The content of the <elcode>xsl:document</elcode> element is a <termref
                  def="dt-sequence-constructor">sequence constructor</termref> for the children of
               the new document node. A document node is created, and the sequence obtained by
               evaluating the sequence constructor is used to construct the content of the document,
               as described in <specref ref="constructing-complex-content"/>. <phrase diff="del"
                  at="S-bug27258">The temporary tree rooted at this document node forms the result
                  tree.</phrase></p>
            <p>Except in error situations, the result of evaluating the
                  <elcode>xsl:document</elcode> instruction is a single node, the newly constructed
               document node.</p>
            <note>
               <p>The new document is not serialized. To construct a document that is to form a
                  final result rather than an intermediate result, use the
                     <elcode>xsl:result-document</elcode> instruction described in <specref
                     ref="creating-result-trees"/>.</p>
            </note>
            <p>The optional attributes <code>type</code> and <code>validation</code> may be used on
               the <elcode>xsl:document</elcode> instruction to validate the contents of the new
               document, and to determine the <termref def="dt-type-annotation"/> that elements and
               attributes within the <termref def="dt-result-tree">result tree</termref> will carry.
               The permitted values and their semantics are described in <specref
                  ref="validating-document-nodes"/>.</p>
            <p>The base URI of the new document node is taken from the base URI of the
                  <elcode>xsl:document</elcode> instruction.</p>
            <p>The <code>document-uri</code> and <code>unparsed-entities</code> properties of the
               new document node are set to empty.</p>
            <example>
               <head>Checking Uniqueness Constraints in a Temporary Tree</head>
               <p>The following example creates a temporary tree held in a variable. The use of an
                  enclosed <elcode>xsl:document</elcode> instruction ensures that uniqueness
                  constraints defined in the schema for the relevant elements are checked.</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:variable name="tree" as="document-node()"&gt;
  &lt;xsl:document validation="strict"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:document&gt;
&lt;/xsl:variable&gt;</eg>
            </example>
         </div2>
         <div2 id="creating-processing-instructions">
            <head>Creating Processing Instructions</head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="processing-instruction">
               <e:in-category name="instruction"/>
               <e:attribute name="name" required="yes">
                  <e:attribute-value-template>
                     <e:data-type name="ncname"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="select">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:processing-instruction</elcode> element is evaluated to create a
               processing instruction node.</p>
            <p>The <elcode>xsl:processing-instruction</elcode> element has a
                  <rfc2119>required</rfc2119>
               <code>name</code> attribute that specifies the name of the processing instruction
               node. The value of the <code>name</code> attribute is interpreted as an <termref
                  def="dt-attribute-value-template">attribute value template</termref>.</p>
            <p>The string value of the new processing-instruction node may be defined either by
               using the <code>select</code> attribute, or by the <termref
                  def="dt-sequence-constructor">sequence constructor</termref> that forms the
               content of the <elcode>xsl:processing-instruction</elcode> element. <phrase
                  diff="chg" at="K">These are mutually exclusive: if the <code>select</code>
                  attribute is present then the sequence constructor must be empty, and if the
                  sequence constructor is non-empty then the <code>select</code> attribute must be
                  absent. If the <code>select</code> attribute is absent and the sequence
                  constructor is empty</phrase>, then the string value of the new
               processing-instruction node will be a zero-length string. The way in which the value
               is constructed is specified in <specref ref="constructing-simple-content"/>.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0880"><p>It is a <termref
                        def="dt-static-error">static error</termref> if the <code>select</code>
                     attribute of the <elcode>xsl:processing-instruction</elcode> element is present
                     unless the element has empty content.</p></error>
            </p>
            <p>Except in error situations, the result of evaluating the
                  <elcode>xsl:processing-instruction</elcode> instruction is a single node, the
               newly constructed processing instruction node.</p>
            <example>
               <head>Creating a Processing Instruction</head>
               <p>This instruction:</p>
               <eg xml:space="preserve" diff="chg" at="P-erratumE35" role="xslt-instruction">&lt;xsl:processing-instruction name="xml-stylesheet"
  select="('href=&amp;quot;book.css&amp;quot;', 'type=&amp;quot;text/css&amp;quot;')"/&gt;</eg>
               <p>creates the processing instruction</p>
               <eg xml:space="preserve" role="non-xml">&lt;?xml-stylesheet href="book.css" type="text/css"?&gt;</eg>
               <p>Note that the <code>xml-stylesheet</code> processing instruction contains
                     <emph>pseudo-attributes</emph> in the form <code>name="value"</code>. Although
                  these have the same textual form as attributes in an element start tag, they are
                  not represented as XDM attribute nodes, and cannot therefore be constructed using
                     <elcode>xsl:attribute</elcode> instructions.</p>
            </example>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0890"><p>It is a <termref
                        def="dt-dynamic-error"><phrase diff="del" at="M">non-recoverable</phrase>
                        dynamic error</termref> if the <termref def="dt-effective-value">effective
                        value</termref> of the <code>name</code> attribute <error.extra>of the
                           <elcode>xsl:processing-instruction</elcode> instruction</error.extra> is
                     not both an <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names"
                        ref="NT-NCName" xlink:type="simple">NCName</xnt> and a <xnt
                        xmlns:xlink="http://www.w3.org/1999/xlink" spec="XML" ref="PITarget"
                        xlink:type="simple">PITarget</xnt>.</p></error>
            </p>
            <note>
               <p>Because these rules disallow the name <code>xml</code>, the
                     <elcode>xsl:processing-instruction</elcode> cannot be used to output an XML
                  declaration. The <elcode>xsl:output</elcode> declaration should be used to control
                  this instead (see <specref ref="serialization"/>).</p>
            </note>
            <p>If the result of evaluating the content of the
                  <elcode>xsl:processing-instruction</elcode> contains the string
               <code>?&gt;</code>, this string is modified by inserting a space between the
                  <code>?</code> and <code>&gt;</code> characters.</p>
            <p>The base URI of the new processing-instruction is copied from the base URI of the
                  <elcode>xsl:processing-instruction</elcode> element in the stylesheet. (Note,
               however, that this is only relevant when creating a parentless processing
               instruction. When the new processing instruction is copied to form a child of an
               element or document node, the base URI of the new copy is taken from that of its new
               parent.)</p>
         </div2>
         <div2 id="creating-namespace-nodes">
            <head>Creating Namespace Nodes</head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="namespace">
               <e:in-category name="instruction"/>
               <e:attribute name="name" required="yes">
                  <e:attribute-value-template>
                     <e:data-type name="ncname"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="select">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:namespace</elcode> element is evaluated to create a namespace node.
               Except in error situations, the result of evaluating the
                  <elcode>xsl:namespace</elcode> instruction is a single node, the newly constructed
               namespace node.</p>
            <p>The <elcode>xsl:namespace</elcode> element has a <rfc2119>required</rfc2119>
               <code>name</code> attribute that specifies the name of the namespace node (that is,
               the namespace prefix). The value of the <code>name</code> attribute is interpreted as
               an <termref def="dt-attribute-value-template">attribute value template</termref>. If
               the <termref def="dt-effective-value">effective value</termref> of the
                  <code>name</code> attribute is a zero-length string, a namespace node is added for
               the default namespace.</p>
            <p>The string value of the new namespace node (that is, the namespace URI) may be
               defined either by using the <code>select</code> attribute, or by the <termref
                  def="dt-sequence-constructor">sequence constructor</termref> that forms the
               content of the <elcode>xsl:namespace</elcode> element. <phrase diff="chg" at="K"
                  >These are mutually exclusive: if the <code>select</code> attribute is present
                  then the sequence constructor must be empty, and if the sequence constructor is
                  non-empty then the <code>select</code> attribute must be absent.</phrase> Since
               the string value of a namespace node cannot be a zero-length string, <phrase
                  diff="chg" at="K">either a <code>select</code> attribute or a non-empty sequence
                  constructor <rfc2119>must</rfc2119> be present</phrase>. The way in which the
               value is constructed is specified in <specref ref="constructing-simple-content"
               />.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0905"><p>It is a <termref
                        def="dt-dynamic-error"><phrase diff="del" at="M">non-recoverable</phrase>
                        dynamic error</termref> if the string value of the new namespace node is not
                     valid in the lexical space of the datatype <code>xs:anyURI</code>, or if it is
                     the string <code>http://www.w3.org/2000/xmlns/</code>.</p></error>
            </p>
            <p>
               <error spec="XT" type="static" class="SE" code="0910"><p>It is a <termref
                        def="dt-static-error">static error</termref> if the <code>select</code>
                     attribute of the <elcode>xsl:namespace</elcode> element is present when the
                     element has content other than one or more <elcode>xsl:fallback</elcode>
                     instructions, or if the <code>select</code> attribute is absent when the
                     element has empty content.</p></error>
            </p>
            <p>Note the restrictions described in <specref ref="constructing-complex-content"/> for
               the position of a namespace node relative to other nodes in the node sequence
               returned by a sequence constructor.</p>
            <example>
               <head>Constructing a QName-Valued Attribute</head>
               <p>This literal result element:</p>
               <eg xml:space="preserve" role="non-xml">&lt;data xsi:type="xs:integer" 
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
  &lt;xsl:namespace name="xs" 
                 select="'http://www.w3.org/2001/XMLSchema'"/&gt;
  &lt;xsl:text&gt;42&lt;/xsl:text&gt;
&lt;/data&gt;</eg>
               <p>would typically cause the output document to contain the element:</p>
               <eg xml:space="preserve" role="non-xml">&lt;data xsi:type="xs:integer"
     xmlns:xs="http://www.w3.org/2001/XMLSchema"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;42&lt;/data&gt;</eg>
               <p>In this case, the element is constructed using a literal result element, and the
                  namespace <code>xmlns:xs="http://www.w3.org/2001/XMLSchema"</code> could therefore
                  have been added to the <termref def="dt-result-tree">result tree</termref> simply
                  by declaring it as one of the in-scope namespaces in the stylesheet. In practice,
                  the <elcode>xsl:namespace</elcode> instruction is more likely to be useful in
                  situations where the element is constructed using an <elcode>xsl:element</elcode>
                  instruction, which does not copy all the in-scope namespaces from the
                  stylesheet.</p>
            </example>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0920"><p>It is a <termref
                        def="dt-dynamic-error"><phrase diff="del" at="M">non-recoverable</phrase>
                        dynamic error</termref> if the <termref def="dt-effective-value">effective
                        value</termref> of the <code>name</code> attribute <error.extra>of the
                           <elcode>xsl:namespace</elcode> instruction</error.extra> is neither a
                     zero-length string nor an <xnt xmlns:xlink="http://www.w3.org/1999/xlink"
                        spec="Names" ref="NT-NCName" xlink:type="simple">NCName</xnt>, or if it is
                        <code>xmlns</code>. </p></error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0925"><p>It is a <termref
                        def="dt-dynamic-error"><phrase diff="del" at="M">non-recoverable</phrase>
                        dynamic error</termref> if the <elcode>xsl:namespace</elcode> instruction
                     generates a namespace node whose name is <code>xml</code> and whose string
                     value is not <code>http://www.w3.org/XML/1998/namespace</code>, or a namespace
                     node whose string value is <code>http://www.w3.org/XML/1998/namespace</code>
                     and whose name is not <code>xml</code>.</p></error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0930"><p>It is a <termref
                        def="dt-dynamic-error"><phrase diff="del" at="M">non-recoverable</phrase>
                        dynamic error</termref> if evaluating the <code>select</code> attribute or
                     the contained <termref def="dt-sequence-constructor"/> of an
                        <elcode>xsl:namespace</elcode> instruction results in a zero-length string.
                  </p></error>
            </p>
            <p>For details of other error conditions that may arise, see <specref
                  ref="sequence-constructors"/>.</p>
            <note>
               <p>It is rarely necessary to use <elcode>xsl:namespace</elcode> to create a namespace
                  node in the <termref def="dt-result-tree">result tree</termref>; in most
                  circumstances, the required namespace nodes will be created automatically, as a
                  side-effect of writing elements or attributes that use the namespace. An example
                  where <elcode>xsl:namespace</elcode> is needed is a situation where the required
                  namespace is used only within attribute values in the result document, not in
                  element or attribute names; especially where the required namespace prefix or
                  namespace URI is computed at run-time and is not present in either the source
                  document or the stylesheet.</p>
               <p>Adding a namespace node to the <termref def="dt-result-tree">result tree</termref>
                  will never change the <termref def="dt-expanded-qname">expanded QName</termref> of
                  any element or attribute node in the result tree: that is, it will never change
                  the namespace URI of an element or attribute. It might, however, constrain the
                  choice of prefixes when namespace fixup is performed.</p>
               <p>Namespace prefixes for element and attribute names are initially established by
                  the rules of the instruction that creates the element or attribute node, and in
                  the event of conflicts, they may be changed by the namespace fixup process
                  described in <specref ref="namespace-fixup"/>. The fixup process ensures that an
                  element has in-scope namespace nodes for the namespace URIs used in the element
                  name and in its attribute names, and the serializer will typically use these
                  namespace nodes to determine the prefix to use in the serialized output. The fixup
                  process cannot generate namespace nodes that are inconsistent with those already
                  present in the tree. This means that it is not possible for the processor to
                  decide the prefix to use for an element or for any of its attributes until all the
                  namespace nodes for the element have been added.</p>
               <p>If a namespace prefix is mapped to a particular namespace URI using the
                     <elcode>xsl:namespace</elcode> instruction, or by using
                     <elcode>xsl:copy</elcode> or <elcode>xsl:copy-of</elcode> to copy a namespace
                  node, this prevents the namespace fixup process (and hence the serializer) from
                  using the same prefix for a different namespace URI on the same element.</p>
            </note>
            <example>
               <head>Conflicting Namespace Prefixes</head>
               <p>Given the instruction:</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:element name="p:item" 
                 xmlns:p="http://www.example.com/p"&gt;
  &lt;xsl:namespace name="p"&gt;http://www.example.com/q&lt;/xsl:namespace&gt;
&lt;/xsl:element&gt;</eg>
               <p>a possible serialization of the <termref def="dt-result-tree">result
                     tree</termref> is:</p>
               <eg xml:space="preserve" role="xml">&lt;ns0:item 
    xmlns:ns0="http://www.example.com/p" 
    xmlns:p="http://www.example.com/q"/&gt;</eg>
               <p>The processor must invent a namespace prefix for the URI <code>p.uri</code>; it
                  cannot use the prefix <code>p</code> because that prefix has been explicitly
                  associated with a different URI.</p>
            </example>
            <note>
               <p>The <elcode>xsl:namespace</elcode> instruction cannot be used to generate a
                     <term>namespace undeclaration</term> of the form <code>xmlns=""</code> (nor the
                  new forms of namespace undeclaration permitted in <bibref ref="xml-names11"/>).
                  Namespace undeclarations are generated automatically by the serializer if
                     <code>undeclare-prefixes="yes"</code> is specified on
                     <elcode>xsl:output</elcode>, whenever a parent element has a namespace node for
                  the default namespace prefix, and a child element has no namespace node for that
                  prefix.</p>
            </note>
         </div2>
         <div2 id="creating-comments">
            <head>Creating Comments</head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="comment">
               <e:in-category name="instruction"/>
               <e:attribute name="select">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:comment</elcode> element is evaluated to construct a new comment
               node. Except in error cases, the result of evaluating the
                  <elcode>xsl:comment</elcode> instruction is a single node, the newly constructed
               comment node.</p>
            <p>The string value of the new comment node may be defined either by using the
                  <code>select</code> attribute, or by the <termref def="dt-sequence-constructor"
                  >sequence constructor</termref> that forms the content of the
                  <elcode>xsl:comment</elcode> element. <phrase diff="chg" at="K">These are mutually
                  exclusive: if the <code>select</code> attribute is present then the sequence
                  constructor must be empty, and if the sequence constructor is non-empty then the
                     <code>select</code> attribute must be absent. If the <code>select</code>
                  attribute is absent and the sequence constructor is empty</phrase>, then the
               string value of the new comment node will be a zero-length string. The way in which
               the value is constructed is specified in <specref ref="constructing-simple-content"
               />.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0940"><p>It is a <termref
                        def="dt-static-error">static error</termref> if the <code>select</code>
                     attribute of the <elcode>xsl:comment</elcode> element is present unless the
                     element has empty content.</p></error>
            </p>
            <example>
               <head>Generating a Comment Node</head>
               <p>For example, this</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:comment&gt;This file is automatically generated. Do not edit!&lt;/xsl:comment&gt;</eg>
               <p>would create the comment</p>
               <eg xml:space="preserve" role="non-xml">&lt;!--This file is automatically generated. Do not edit!--&gt;</eg>
            </example>
            <p>In the generated comment node, the processor <rfc2119>must</rfc2119> insert a space
               after any occurrence of <code>x2D</code> (hyphen) that is followed by another
               occurrence of <code>x2D</code> (hyphen) or that ends the comment.</p>
         </div2>
         <div2 id="copying">
            <head>Copying Nodes</head>
            <div3 id="shallow-copy">
               <head>Shallow Copy</head>
               <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
                  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="copy">
                  <e:in-category name="instruction"/>
                  <e:attribute name="select">
                     <e:data-type name="expression"/>
                  </e:attribute>
                  <e:attribute name="copy-namespaces">
                     <e:data-type name="boolean"/>
                  </e:attribute>
                  <e:attribute name="inherit-namespaces">
                     <e:data-type name="boolean"/>
                  </e:attribute>
                  <e:attribute name="use-attribute-sets">
                     <e:data-type name="eqnames"/>
                  </e:attribute>
                  <e:attribute name="type">
                     <e:data-type name="eqname"/>
                  </e:attribute>
                  <e:attribute name="validation">
                     <e:constant value="strict"/>
                     <e:constant value="lax"/>
                     <e:constant value="preserve"/>
                     <e:constant value="strip"/>
                  </e:attribute>
                  <e:model name="sequence-constructor"/>
                  <e:allowed-parents>
                     <e:parent-category name="sequence-constructor"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p>The <elcode>xsl:copy</elcode> instruction provides a way of copying <phrase
                     diff="chg" at="C">a selected item. The selected item is the item selected by
                     evaluating the expression in the <code>select</code> attribute if present, or
                     the <termref def="dt-context-item">context item</termref> otherwise</phrase>.
                  If the selected item is a node, evaluating the <elcode>xsl:copy</elcode>
                  instruction constructs a copy of the selected node, and the result of the
                     <elcode>xsl:copy</elcode> instruction is this newly constructed node. By
                  default, the namespace nodes of the context node are automatically copied as well,
                  but the attributes and children of the node are not automatically copied.</p>
               <p diff="add" at="R-bug7624">
                  <error spec="XT" type="type" class="TE" code="0945"><p>It is a <termref
                           def="dt-type-error">type error</termref> to use the
                           <elcode>xsl:copy</elcode> instruction with no <code>select</code>
                        attribute when the context item is absent. </p></error>
               </p>
               <p diff="add" at="C">If the <code>select</code> expression returns an empty sequence,
                  the <elcode>xsl:copy</elcode> instruction returns an empty sequence, and the
                  contained <termref def="dt-sequence-constructor"/> is not evaluated.</p>
               <p diff="add" at="C"><error spec="XT" type="type" class="TE" code="3180"><p>It is a
                           <termref def="dt-type-error">type error</termref> if the result of
                        evaluating the <code>select</code> expression <error.extra>of the
                              <elcode>xsl:copy</elcode> element</error.extra> is a sequence of more
                        than one item.</p></error></p>
               <p>When the <phrase diff="chg" at="C">selected item</phrase> is an atomic value
                     <phrase diff="add" at="C">or function item</phrase>, the
                     <elcode>xsl:copy</elcode> instruction returns this value. The <termref
                     def="dt-sequence-constructor">sequence constructor</termref> is not evaluated.
                     <phrase diff="del" at="R-bug24140">and <rfc2119>must not</rfc2119> generate any
                        <termref def="dt-type-error">type errors</termref></phrase></p>
               <p>When the <phrase diff="chg" at="C">selected item</phrase> is an attribute node,
                  text node, comment node, processing instruction node, or namespace node, the
                     <elcode>xsl:copy</elcode> instruction returns a new node that is a copy of the
                  context node. The new node will have the same node kind, name, and string value as
                  the context node. In the case of an attribute node, it will also have the same
                  values for the <code>is-id</code> and <code>is-idrefs</code> properties. The
                     <termref def="dt-sequence-constructor"/> is not evaluated. <phrase diff="del"
                     at="R-bug24140">and <rfc2119>must not</rfc2119> generate any <termref
                        def="dt-type-error">type errors</termref></phrase></p>
               <p>When the <phrase diff="chg" at="C">selected item</phrase> is a document node or
                  element node, the <elcode>xsl:copy</elcode> instruction returns a new node that
                  has the same node kind and name as the <phrase diff="chg" at="C">selected</phrase>
                  node. The content of the new node is formed by evaluating the <termref
                     def="dt-sequence-constructor">sequence constructor</termref> contained in the
                     <elcode>xsl:copy</elcode> instruction. <phrase diff="add" at="I">If the
                        <code>select</code> attribute is present then the sequence constructor is
                     evaluated with the selected item as the <termref def="dt-singleton-focus"
                        >singleton focus</termref>; otherwise it is evaluated using the context of
                     the <elcode>xsl:copy</elcode> instruction unchanged.</phrase> The sequence
                  obtained by evaluating this sequence constructor is used (after prepending any
                  attribute nodes or namespace nodes as described in the following paragraphs) to
                  construct the content of the document or element node, as described in <specref
                     ref="constructing-complex-content"/>.</p>
               <p diff="add" at="S-bug28565">When the selected item is a document node, the
                     <code>unparsed-entities</code> property of the existing document node is copied
                  to the new document node.</p>
               <p diff="chg" at="S-bug28565">When the selected item is an element or attribute node,
                  the values of the <code>is-id</code>, <code>is-idrefs</code>, and
                     <code>nilled</code> properties of the new element or attribute depend on the
                  values of the <code>validation</code> and <code>type</code> attributes, as defined
                  in <specref ref="validation"/>.</p>
               <note diff="del" at="C">
                  <p>The <elcode>xsl:copy</elcode> instruction is most useful when copying element
                     nodes. In other cases, the <elcode>xsl:copy-of</elcode> instruction is more
                     flexible, because it has a <code>select</code> attribute allowing selection of
                     the nodes or values to be copied.</p>
               </note>
               <p>The <elcode>xsl:copy</elcode> instruction has an optional
                     <code>use-attribute-sets</code> attribute, whose value is a
                  whitespace-separated list of QNames that identify
                     <elcode>xsl:attribute-set</elcode> declarations. This attribute is used only
                  when copying element nodes. This list is expanded as described in <specref
                     ref="attribute-sets"/> to produce a sequence of attribute nodes. This sequence
                  is prepended to the sequence produced as a result of evaluating the <termref
                     def="dt-sequence-constructor">sequence constructor</termref>.</p>
               <p>The <elcode>xsl:copy</elcode> instruction has an optional
                     <code>copy-namespaces</code> attribute, with the value <code>yes</code> or
                     <code>no</code>. The default value is <code>yes</code>. The attribute is used
                  only when copying element nodes. If the value is set to <code>yes</code>, or is
                  omitted, then all the namespace nodes of the source element are copied as
                  namespace nodes for the result element. These copied namespace nodes are prepended
                  to the sequence produced as a result of evaluating the <termref
                     def="dt-sequence-constructor">sequence constructor</termref> (it is immaterial
                  whether they come before or after any attribute nodes produced by expanding the
                     <code>use-attribute-sets</code> attribute). If the value is set to
                     <code>no</code>, then the namespace nodes are not copied. However, namespace
                  nodes will still be added to the result element as <rfc2119>required</rfc2119> by
                  the namespace fixup process: see <specref ref="namespace-fixup"/>.</p>
               <p>The <elcode>xsl:copy</elcode> instruction has an optional
                     <code>inherit-namespaces</code> attribute, with the value <code>yes</code> or
                     <code>no</code>. The default value is <code>yes</code>. The attribute is used
                  only when copying element nodes. If the value is set to <code>yes</code>, or is
                  omitted, then the namespace nodes created for the newly constructed element
                  (whether these were copied from those of the source node, or generated as a result
                  of namespace fixup) are copied to the children and descendants of the newly
                  constructed element, as described in <specref ref="constructing-complex-content"
                  />. If the value is set to <code>no</code>, then these namespace nodes are not
                  automatically copied to the children. This may result in namespace undeclarations
                  (such as <code>xmlns=""</code> or, in the case of XML Namespaces 1.1,
                     <code>xmlns:p=""</code>) appearing on the child elements when a <termref
                     def="dt-final-result-tree">final result tree</termref> is serialized.</p>
               <p>
                  <error spec="XT" type="type" class="TE" code="0950"><p>It is a <termref
                           def="dt-type-error">type error</termref> to use the
                           <elcode>xsl:copy</elcode> or <elcode>xsl:copy-of</elcode> instruction to
                        copy a node that has namespace-sensitive content if the
                           <code>copy-namespaces</code> attribute has the value <code>no</code> and
                        its explicit or implicit <code>validation</code> attribute has the value
                           <code>preserve</code>. It is also a type error if either of these
                        instructions (with <code>validation="preserve"</code>) is used to copy an
                        attribute having namespace-sensitive content, unless the parent element is
                        also copied. A node has namespace-sensitive content if its typed value
                        contains an item of type <code>xs:QName</code> or <code>xs:NOTATION</code>
                        or a type derived therefrom. The reason this is an error is because the
                        validity of the content depends on the namespace context being
                        preserved.</p></error>
               </p>
               <note>
                  <p>When attribute nodes are copied, whether with <elcode>xsl:copy</elcode> or with
                        <elcode>xsl:copy-of</elcode>, the processor does not automatically copy any
                     associated namespace information. The namespace used in the attribute name
                     itself will be declared by virtue of the namespace fixup process (see <specref
                        ref="namespace-fixup"/>) when the attribute is added to an element in the
                        <termref def="dt-result-tree">result tree</termref>, but if namespace
                     prefixes are used in the content of the attribute (for example, if the value of
                     the attribute is an XPath expression) then it is the responsibility of the
                     stylesheet author to ensure that suitable namespace nodes are added to the
                        <termref def="dt-result-tree">result tree</termref>. This can be achieved by
                     copying the namespace nodes using <elcode>xsl:copy</elcode>, or by generating
                     them using <elcode>xsl:namespace</elcode>.</p>
               </note>
               <p>The optional attributes <code>type</code> and <code>validation</code> may be used
                  on the <elcode>xsl:copy</elcode> instruction to validate the contents of an
                  element, attribute or document node against a type definition, element
                  declaration, or attribute declaration in a schema, and thus to determine the
                     <termref def="dt-type-annotation"/> that the new copy of an element or
                  attribute node will carry. These attributes are ignored when copying an item that
                  is not an element, attribute or document node. When the node being copied is an
                  element or document node, these attributes also affect the type annotation carried
                  by any elements and attributes that have the copied element or document node as an
                  ancestor. These two attributes are both optional, and if one is specified then the
                  other <rfc2119>must</rfc2119> be omitted. The permitted values of these attributes
                  and their semantics are described in <specref ref="validation"/>.</p>
               <note>
                  <p>The final <termref def="dt-type-annotation"/> of the node in the <termref
                        def="dt-result-tree">result tree</termref> also depends on the
                        <code>type</code> and <code>validation</code> attributes of the instructions
                     used to create the ancestors of the node.</p>
               </note>
               <p diff="del" at="R-bug8219">The base URI of a node is copied, except in the case of
                  an element node having an <code>xml:base</code> attribute, in which case the base
                  URI of the new node is taken as the value of the <code>xml:base</code> attribute,
                  resolved if it is relative against the base URI of the <elcode>xsl:copy</elcode>
                  instruction. If the copied node is subsequently attached as a child to a new
                  element or document node, the final copy of the node inherits its base URI from
                  its parent node, unless this is overridden using an <code>xml:base</code>
                  attribute.</p>
               <p diff="add" at="R-bug8219">When a node is copied, its base URI is copied, except
                  when the result of the <elcode>xsl:copy</elcode> instruction is an element node
                  having an <code>xml:base</code> attribute, in which case the base URI of the new
                  node is taken as the value of its <code>xml:base</code> attribute, resolved if it
                  is relative against the base URI of the <elcode>xsl:copy</elcode> instruction. </p>
               <p>When an <code>xml:id</code> attribute is copied, using either the
                     <elcode>xsl:copy</elcode> or <elcode>xsl:copy-of</elcode> instruction, it is
                     <termref def="dt-implementation-defined"/> whether the value of the attribute
                  is subjected to attribute value normalization (that is, effectively applying the
                     <xfunction>normalize-space</xfunction> function).</p>
               <note>
                  <p>In most cases the value will already have been subjected to attribute value
                     normalization on the source tree, but if this processing has not been performed
                     on the source tree, it is not an error for it to be performed on the result
                     tree.</p>
               </note>
               <imp-def-feature id="idf-feature-xmlid">If an <code>xml:id</code> attribute that has
                  not been subjected to attribute value normalization is copied from a source tree
                  to a result tree, it is implementation-defined whether attribute value
                  normalization will be applied during the copy process.</imp-def-feature>
               <div4 id="conditional-copy" diff="del" at="S-bug27189">
                  <head diff="chg" at="N">Conditional Copying of Nodes</head>
                  <p diff="add" at="N">The effect of specifying an <code>on-empty</code> attribute
                     is as follows.</p>
                  <p diff="add" at="R-bug24378">If the <term>selected item</term> is not an element
                     node, the attribute has no effect, except that static errors
                        <rfc2119>must</rfc2119> be reported and type errors <rfc2119>may</rfc2119>
                     be reported.</p>
                  <p diff="chg" at="O">If the result of the instruction in the absence of the
                        <code>on-empty</code> attribute would be an element or document node having
                     no attributes and no children then instead of returning this result, the
                     instruction returns the result of evaluating the expression in the
                        <code>on-empty</code> attribute; if the result of this expression is a node,
                     the instruction returns a copy of this node. <phrase diff="chg" at="R-bug24142"
                        >The <code>on-empty</code> attribute is evaluated with the same <termref
                           def="dt-focus"/> as the <elcode>xsl:copy</elcode> instruction
                        itself.</phrase></p>
                  <p diff="add" at="O"><error spec="XT" type="type" class="TE" code="3330"><p>It is
                           a <termref def="dt-type-error"/> if the result of evaluating the
                              <code>on-empty</code> attribute <error.extra>on the
                                 <elcode>xsl:copy</elcode> instruction</error.extra> does not
                           satisfy the required type <code>element()?</code>. That is, the
                           expression must deliver either a single element node, or an empty
                           sequence.</p></error></p>
                  <p diff="chg" at="R-bug24142">If the <code>on-empty</code> expression is evaluated
                     and returns an empty sequence then the <code>validation</code> and
                        <code>type</code> attributes are ignored. However, if the result of the
                        <code>on-empty</code> expression is an element node, then it is subjected to
                     validation as determined by these attributes, along with
                        <code>[xsl:]default-validation</code> where relevant.</p>
               </div4>
            </div3>
            <div3 id="copy-of">
               <head>Deep Copy</head>
               <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
                  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="copy-of">
                  <e:in-category name="instruction"/>
                  <e:attribute name="select" required="yes">
                     <e:data-type name="expression"/>
                  </e:attribute>
                  <e:attribute name="copy-accumulators">
                     <e:data-type name="boolean"/>
                  </e:attribute>
                  <e:attribute name="copy-namespaces">
                     <e:data-type name="boolean"/>
                  </e:attribute>
                  <e:attribute name="type">
                     <e:data-type name="eqname"/>
                  </e:attribute>
                  <e:attribute name="validation">
                     <e:constant value="strict"/>
                     <e:constant value="lax"/>
                     <e:constant value="preserve"/>
                     <e:constant value="strip"/>
                  </e:attribute>
                  <e:empty/>
                  <e:allowed-parents>
                     <e:parent-category name="sequence-constructor"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p>The <elcode>xsl:copy-of</elcode> instruction can be used to construct a copy of a
                  sequence of nodes, atomic values, <phrase diff="add" at="C">and/or function
                     items</phrase> with each new node containing copies of all the children,
                  attributes, and (by default) namespaces of the original node, recursively. The
                  result of evaluating the instruction is a sequence of items corresponding
                  one-to-one with the supplied sequence, and retaining its order.</p>
               <p>The <rfc2119>required</rfc2119>
                  <code>select</code> attribute contains an <termref def="dt-expression"
                     >expression</termref>, whose value may be any sequence of nodes, atomic values,
                     <phrase diff="add" at="C">and/or function items</phrase>. The items in this
                  sequence are processed as follows:</p>
               <ulist>
                  <item>
                     <p>If the item is an element node, a new element is constructed and appended to
                        the result sequence. The new element will have the same <termref
                           def="dt-expanded-qname">expanded QName</termref> as the original, and it
                        will have deep copies of the attribute nodes and children of the element
                        node.</p>
                     <p>The new element will also have namespace nodes copied from the original
                        element node, unless they are excluded by specifying
                           <code>copy-namespaces="no"</code>. If this attribute is omitted, or takes
                        the value <code>yes</code>, then all the namespace nodes of the original
                        element are copied to the new element. If it takes the value
                        <code>no</code>, then none of the namespace nodes are copied: however,
                        namespace nodes will still be created in the <termref def="dt-result-tree"
                           >result tree</termref> as <rfc2119>required</rfc2119> by the namespace
                        fixup process: see <specref ref="namespace-fixup"/>. This attribute affects
                        all elements copied by this instruction: both elements selected directly by
                        the <code>select</code>
                        <termref def="dt-expression">expression</termref>, and elements that are
                        descendants of nodes selected by the <code>select</code> expression. </p>
                     <p diff="chg" at="S-bug28565">The values of the <code>is-id</code>,
                           <code>is-idrefs</code>, and <code>nilled</code> properties of the new
                        element depend on the values of the <code>validation</code> and
                           <code>type</code> attributes, as defined in <specref ref="validation"
                        />.</p>
                  </item>
                  <item>
                     <p>If the item is a document node, the instruction adds a new document node to
                        the result sequence; the children of this document node will be one-to-one
                        copies of the children of the original document node (each copied according
                        to the rules for its own node kind). <phrase diff="add" at="S-bug28565">The
                              <code>unparsed-entities</code> property of the original document node
                           is copied to the new document node.</phrase></p>
                  </item>
                  <item>
                     <p>If the item is an attribute or namespace node, or a text node, a comment, or
                        a processing instruction, the same rules apply as with
                           <elcode>xsl:copy</elcode> (see <specref ref="shallow-copy"/>).</p>
                  </item>
                  <item>
                     <p>If the item is an atomic value <phrase diff="add" at="C">or a function
                           item</phrase>, the value is appended to the result sequence, as with
                           <elcode>xsl:sequence</elcode>.</p>
                  </item>
               </ulist>
               <p>The optional attributes <code>type</code> and <code>validation</code> may be used
                  on the <elcode>xsl:copy-of</elcode> instruction to validate the contents of an
                  element, attribute or document node against a type definition, element
                  declaration, or attribute declaration in a schema and thus to determine the
                     <termref def="dt-type-annotation"/> that the new copy of an element or
                  attribute node will carry. These attributes are applied individually to each
                  element, attribute, and document node that is selected by the expression in the
                     <code>select</code> attribute. These attributes are ignored when copying an
                  item that is not an element, attribute or document node.</p>
               <p>The specified <code>type</code> and <code>validation</code> apply directly only to
                  elements, attributes and document nodes created as copies of nodes actually
                  selected by the <code>select</code> expression, they do not apply to nodes that
                  are implicitly copied because they have selected nodes as an ancestor. However,
                  these attributes do indirectly affect the <termref def="dt-type-annotation">type
                     annotation</termref> carried by such implicitly copied nodes, as a consequence
                  of the validation process.</p>
               <p>These two attributes are both optional, and if one is specified then the other
                     <rfc2119>must</rfc2119> be omitted. The permitted values of these attributes
                  and their semantics are described in <specref ref="validation"/>.</p>
               <p>Errors may occur when copying namespace-sensitive elements or attributes using
                     <code>validation="preserve"</code>. <errorref class="TE" code="0950"/>.</p>
               <p diff="add" at="R-bug24136">If removal of namespaces is requested using
                     <code>copy-namespaces="no"</code>, then any validation that is requested is
                  applied to the tree that remains after the relevant namespaces have been removed.
                  This will cause validation to fail if there is namespace-sensitive content that
                  depends on the presence of the removed namespaces.</p>
               <p>The base URI of a node is copied, except in the case of an element node having an
                     <code>xml:base</code> attribute, in which case the base URI of the new node is
                  taken as the value of the <code>xml:base</code> attribute, resolved if it is
                  relative against the base URI of the <elcode>xsl:copy-of</elcode> instruction. If
                  the copied node is subsequently attached as a child to a new element or document
                  node, the final copy of the node inherits its base URI from its parent node,
                  unless this is overridden using an <code>xml:base</code> attribute.</p>
               <p>The effect of the <code>copy-accumulators</code> attribute is described in
                     <specref ref="applicability-of-accumulators"/>.</p>
            </div3>
         </div2>
         <div2 id="constructing-sequences">
            <head>Constructing Sequences</head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="sequence">
               <e:in-category name="instruction"/>
               <e:attribute name="select" required="no">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:sequence</elcode> instruction may be used within a <termref
                  def="dt-sequence-constructor">sequence constructor</termref> to construct a
               sequence of nodes, atomic values, <phrase diff="add" at="C">and/or function
                  items</phrase>. This sequence is returned as the result of the instruction. Unlike
               most other instructions, <elcode>xsl:sequence</elcode> can return a sequence
               containing existing nodes, rather than constructing new nodes. When
                  <elcode>xsl:sequence</elcode> is used to select atomic values <phrase diff="add"
                  at="C">or function items</phrase>, the effect is very similar to the
                  <elcode>xsl:copy-of</elcode> instruction.</p>
            <p diff="chg" at="E">The items comprising the result sequence are evaluated either using
               the <code>select</code> attribute, or using the contained <termref
                  def="dt-sequence-constructor"/>. These are mutually exclusive; if the instruction
               has a <code>select</code> attribute, then it <rfc2119>must</rfc2119> have no children
               other than <elcode>xsl:fallback</elcode> instructions. If there is no
                  <code>select</code> attribute and no contained <termref
                  def="dt-sequence-constructor"/>, the result is an empty sequence.</p>
            <p diff="add" at="M">
               <error spec="XT" type="static" class="SE" code="3185"><p>It is a <termref
                        def="dt-static-error">static error</termref> if the <code>select</code>
                     attribute of <elcode>xsl:sequence</elcode> is present and the instruction has
                     children other than <elcode>xsl:fallback</elcode>.</p></error>
            </p>
            <p>Any contained <elcode>xsl:fallback</elcode> instructions are ignored by an XSLT 2.0
                  <phrase diff="add" at="A">or 3.0</phrase> processor, but can be used to define
               fallback behavior for an XSLT 1.0 processor running in forwards compatibility
               mode.</p>
            <example>
               <head>Constructing a Sequence of Integers</head>
               <p>The following code:</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:variable name="values" as="xs:integer*"&gt;
    &lt;xsl:sequence select="(1,2,3,4)"/&gt;
    &lt;xsl:sequence select="(8,9,10)"/&gt;
&lt;/xsl:variable&gt;
&lt;xsl:value-of select="sum($values)"/&gt;</eg>
               <p>produces the output: <code>37</code>
               </p>
            </example>
            <example>
               <head>Using <code>xsl:for-each</code> to Construct a Sequence</head>
               <p>The following code constructs a sequence containing the value of the
                     <code>@price</code> attribute for selected elements (which we assume to be
                  typed as <code>xs:decimal</code>), or a computed price for those elements that
                  have no <code>@price</code> attribute. It then returns the average price:</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:variable name="prices" as="xs:decimal*"&gt;
  &lt;xsl:for-each select="//product"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="@price"&gt;
        &lt;xsl:sequence select="@price"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:sequence select="@cost * 1.5"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:variable&gt;
&lt;xsl:value-of select="avg($prices)"/&gt;</eg>
               <p>Note that the existing <code>@price</code> attributes could equally have been
                  added to the <code>$prices</code> sequence using <elcode>xsl:copy-of</elcode> or
                     <elcode>xsl:value-of</elcode>. However, <elcode>xsl:copy-of</elcode> would
                  create a copy of the attribute node, which is not needed in this situation, while
                     <elcode>xsl:value-of</elcode> would create a new text node, which then has to
                  be converted to an <code>xs:decimal</code>. Using <elcode>xsl:sequence</elcode>,
                  which in this case atomizes the existing attribute node and adds an
                     <code>xs:decimal</code> atomic value to the result sequence, is a more direct
                  way of achieving the same result.</p>
               <p>This example could alternatively be solved at the XPath level:</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:value-of select="avg(//product/(+@price, @cost*1.5)[1])"/&gt;</eg>
               <p>The apparently redundant <code>+</code> operator is there to atomize the attribute
                  value: the expression on the right hand side of the <code>/</code> operator must
                  not return a <phrase diff="chg" at="C"> sequence containing both nodes and
                     non-nodes (atomic values or function items).</phrase></p>
            </example>
            <note diff="add" at="E">
               <p>The main use case for allowing <elcode>xsl:sequence</elcode> to contain a sequence
                  constructor is to allow the instructions within an <elcode>xsl:fork</elcode>
                  element to be divided into groups.</p>
               <p>It can also be used to limit the scope of local variables or of standard
                  attributes such as <code>[xsl:]default-collation</code>.</p>
            </note>
         </div2>
      </div1>
      <div1 id="number">
         <head>Numbering</head>
         <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="number">
            <e:in-category name="instruction"/>
            <e:attribute name="value">
               <e:data-type name="expression"/>
            </e:attribute>
            <e:attribute name="select">
               <e:data-type name="expression"/>
            </e:attribute>
            <e:attribute name="level">
               <e:constant value="single"/>
               <e:constant value="multiple"/>
               <e:constant value="any"/>
            </e:attribute>
            <e:attribute name="count">
               <e:data-type name="pattern"/>
            </e:attribute>
            <e:attribute name="from">
               <e:data-type name="pattern"/>
            </e:attribute>
            <e:attribute name="format">
               <e:attribute-value-template>
                  <e:data-type name="string"/>
               </e:attribute-value-template>
            </e:attribute>
            <e:attribute name="lang">
               <e:attribute-value-template>
                  <e:data-type name="language"/>
               </e:attribute-value-template>
            </e:attribute>
            <e:attribute name="letter-value">
               <e:attribute-value-template>
                  <e:constant value="alphabetic"/>
                  <e:constant value="traditional"/>
               </e:attribute-value-template>
            </e:attribute>
            <e:attribute name="ordinal">
               <e:attribute-value-template>
                  <e:data-type name="string"/>
               </e:attribute-value-template>
            </e:attribute>
            <e:attribute name="start-at">
               <e:attribute-value-template>
                  <e:data-type name="string"/>
               </e:attribute-value-template>
            </e:attribute>
            <e:attribute name="grouping-separator">
               <e:attribute-value-template>
                  <e:data-type name="char"/>
               </e:attribute-value-template>
            </e:attribute>
            <e:attribute name="grouping-size">
               <e:attribute-value-template>
                  <e:data-type name="integer"/>
               </e:attribute-value-template>
            </e:attribute>
            <e:empty/>
            <e:allowed-parents>
               <e:parent-category name="sequence-constructor"/>
            </e:allowed-parents>
         </e:element-syntax>
         <p>The <elcode>xsl:number</elcode> instruction is used to create a formatted number. The
            result of the instruction is a newly constructed text node containing the formatted
            number as its <termref def="dt-string-value">string value</termref>.</p>
         <p>
            <termdef id="dt-place-marker" term="place marker">The <elcode>xsl:number</elcode>
               instruction performs two tasks: firstly, determining a <term>place marker</term>
               (this is a sequence of integers, to allow for hierarchic numbering schemes such as
                  <code>1.12.2</code> or <code>3(c)ii</code>), and secondly, formatting the place
               marker for output as a text node in the result sequence.</termdef> The place marker
            to be formatted can either be supplied directly, in the <code>value</code> attribute, or
            it can be computed based on the position of a selected node within the tree that
            contains it.</p>
         <p>
            <error spec="XT" type="static" class="SE" code="0975"><p>It is a <termref
                     def="dt-static-error">static error</termref> if the <code>value</code>
                  attribute of <elcode>xsl:number</elcode> is present unless the
                  <code>select</code>, <code>level</code>, <code>count</code>, and <code>from</code>
                  attributes are all absent.</p></error>
         </p>
         <note>
            <p>The facilities described in this section are specifically designed to enable the
               calculation and formatting of section numbers, paragraph numbers, and the like. For
               formatting of other numeric quantities, the <xfunction>format-number</xfunction>
               function may be more suitable.</p>
            <p>Furthermore, formatting of integers where there is no requirement to calculate the
               position of a node in the document can now be accomplished using the
                  <xfunction>format-integer</xfunction> function, which borrows many concepts from
               the <elcode>xsl:number</elcode> specification.</p>
         </note>
         <div2 id="start-at">
            <head>The <code>start-at</code> Attribute</head>
            <p diff="add" at="S-bug27060">The <termref def="dt-effective-value"/> of the
                  <code>start-at</code> attribute <rfc2119>must</rfc2119> be a string representing a
               whitespace-separated sequence of one or more integers, each one optionally preceded
               by a minus sign, separated by whitespace. More specifically, the value must be a
               string matching the regular expression <code>-?[0-9]+(\s+-?[0-9]+)*</code>. This
               sequence of integers is used to <term>re-base</term> the sequence of integers being
               formatted. Specifically if <var>$S</var> is the sequence of integers represented by
               the <code>start-at</code> attribute, and <var>$V</var> is the sequence of integers to
               be formatted, then the following transformation is applied to <var>$V</var>:</p>
            <eg diff="add" at="S-bug27060" role="non-xml" xml:space="preserve">
for $i in 1 to count($V) return
  if ($i le count($S))
  then $V[$i] + $S[$i] - 1
  else $V[$i] + $S[last()] - 1
</eg>
            <note diff="add" at="S-bug27060">
               <p>This means that if there are <var>N</var> integers in the <code>start-at</code>
                  attribute, then these are used to re-base the first <var>N</var> numbers, while
                  numbers after the <var>Nth</var> are re-based using the last (<var>Nth</var>)
                  integer in the <code>start-at</code> attribute. If the <code>start-at</code>
                  attribute contains more integers than are required, the surplus is ignored.</p>
            </note>
            <p diff="add" at="S-bug27060">For example, if the attribute is given as
                  <code>start-at="3 0 0"</code>, and the number sequence to be formatted is
                  <code>(1, 1, 1, 1)</code>, then the re-based sequence is <code>3, 0, 0,
               0</code>.</p>
         </div2>
         <div2 id="formatting-supplied-number">
            <head>Formatting a Supplied Number</head>
            <p>The <termref def="dt-place-marker">place marker</termref> to be formatted may be
               specified by an expression. The <code>value</code> attribute contains the <termref
                  def="dt-expression">expression</termref>. The value of this expression is <termref
                  def="dt-atomization">atomized</termref> using the procedure defined in <bibref
                  ref="xpath-30"/>, and each value <var>$V</var> in the atomized sequence is then
               converted to the integer value returned by the XPath expression
                  <code>xs:integer(round(number($V)))</code>. <phrase diff="chg" at="S-bug27060">If
                  the <code>start-at</code> attribute is present, this sequence is then re-based as
                  described in <specref ref="start-at"/>.</phrase> The resulting sequence of
               integers is used as the place marker to be formatted.</p>
            <p diff="chg" at="D">If the instruction is processed with <termref
                  def="dt-xslt-10-behavior">XSLT 1.0 behavior</termref>, then:</p>
            <ulist>
               <item>
                  <p>All items in the <termref def="dt-atomization">atomized</termref> sequence
                     after the first are discarded;</p>
               </item>
               <item>
                  <p>If the atomized sequence is empty, it is replaced by a sequence containing the
                        <code>xs:double</code> value <code>NaN</code> as its only item;</p>
               </item>
               <item>
                  <p>If any value in the sequence cannot be converted to an integer (this includes
                     the case where the sequence contains a <code>NaN</code> value) then the string
                        <code>NaN</code> is inserted into the formatted result string in its proper
                     position. The error described in the following paragraph does not apply in this
                     case.</p>
               </item>
            </ulist>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0980"><p>It is a <termref
                        def="dt-dynamic-error"><phrase diff="del" at="M">non-recoverable</phrase>
                        dynamic error</termref> if any undiscarded item in the atomized sequence
                     supplied as the value of the <code>value</code> attribute of
                        <elcode>xsl:number</elcode> cannot be converted to an integer, or if the
                     resulting integer is less than 0 (zero). </p></error>
            </p>
            <note>
               <p>The value zero does not arise when numbering nodes in a source document, but it
                  can arise in other numbering sequences. It is permitted specifically because the
                  rules of the <elcode>xsl:number</elcode> instruction are also invoked by functions
                  such as <xfunction>format-time</xfunction>: the minutes and seconds component of a
                  time value can legitimately be zero.</p>
            </note>
            <p>The resulting sequence is formatted as a string using the <termref
                  def="dt-effective-value">effective values</termref> of the attributes specified in
                  <specref ref="convert"/>; each of these attributes is interpreted as an <termref
                  def="dt-attribute-value-template">attribute value template</termref>. After
               conversion, the <elcode>xsl:number</elcode> element constructs a new text node
               containing the resulting string, and returns this node.</p>
            <example>
               <head>Numbering a Sorted List</head>
               <p>The following example numbers a sorted list:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="items"&gt;
  &lt;xsl:for-each select="item"&gt;
    &lt;xsl:sort select="."/&gt;
    &lt;p&gt;
      &lt;xsl:number value="position()" format="1. "/&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/p&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;</eg>
            </example>
         </div2>
         <div2 id="numbering-based-on-position">
            <head>Numbering based on Position in a Document </head>
            <p>If no <code>value</code> attribute is specified, then the <elcode>xsl:number</elcode>
               instruction returns a new text node containing a formatted <termref
                  def="dt-place-marker">place marker</termref> that is based on the position of a
               selected node within its containing document. If the <code>select</code> attribute is
               present, then the expression contained in the <code>select</code> attribute is
               evaluated to determine the selected node. If the <code>select</code> attribute is
               omitted, then the selected node is the <termref def="dt-context-node">context
                  node</termref>.</p>
            <p>
               <error spec="XT" type="type" class="TE" code="0990"><p>It is a <termref
                        def="dt-type-error">type error</termref> if the <elcode>xsl:number</elcode>
                     instruction is evaluated, with no <code>value</code> or <code>select</code>
                     attribute, when the <termref def="dt-context-item">context item</termref> is
                     not a node. </p></error>
            </p>
            <p>
               <error spec="XT" type="type" class="TE" code="1000"><p>It is a <termref
                        def="dt-type-error">type error</termref> if the result of evaluating the
                        <code>select</code> attribute of the <elcode>xsl:number</elcode> instruction
                     is anything other than a single node.</p></error>
            </p>
            <p diff="del" at="S-bug27060">
               <error spec="XT" type="dynamic" class="DE" code="1001"><p>It is a <termref
                        def="dt-dynamic-error">dynamic error</termref> if the <termref
                        def="dt-effective-value">effective value</termref> of the
                        <code>start-at</code> attribute of the <elcode>xsl:number</elcode>
                     instruction is not in the lexical space of <code>xs:integer</code>. The error
                     may be signaled statically if it can be detected statically.</p></error>
            </p>
            <p> The following attributes control how the selected node is to be numbered:</p>
            <ulist>
               <item>
                  <p>The <code>level</code> attribute specifies rules for selecting the nodes that
                     are taken into account in allocating a number; it has the values
                        <code>single</code>, <code>multiple</code> or <code>any</code>. The default
                     is <code>single</code>.</p>
               </item>
               <item>
                  <p>The <code>count</code> attribute is a <termref def="dt-pattern"
                        >pattern</termref> that specifies which nodes are to be counted at those
                     levels. If <code>count</code> attribute is not specified, then it defaults to
                     the pattern that matches any node with the same node kind as the selected node
                     and, if the selected node has an <termref def="dt-expanded-qname">expanded
                        QName</termref>, with the same <termref def="dt-expanded-qname">expanded
                        QName</termref> as the selected node.</p>
               </item>
               <item>
                  <p>The <code>from</code> attribute is a <termref def="dt-pattern"
                        >pattern</termref> that specifies where counting starts.</p>
               </item>
            </ulist>
            <p>In addition, the attributes specified in <specref ref="convert"/> are used for number
               to string conversion, as in the case when the <code>value</code> attribute is
               specified.</p>
            <p>The <elcode>xsl:number</elcode> element first constructs a sequence of positive
               integers using the <code>level</code>, <code>count</code> and <code>from</code>
               attributes. Where <code>level</code> is <code>single</code> or <code>any</code>, this
               sequence will either be empty or contain a single number; where <code>level</code> is
                  <code>multiple</code>, the sequence may be of any length. The sequence is
               constructed as follows:</p>
            <p>Let <code>matches-count($node)</code> be a function that returns true if and only if
               the given node <code>$node</code> matches the pattern given in the <code>count</code>
               attribute, or the implied pattern (according to the rules given above) if the
                  <code>count</code> attribute is omitted.</p>
            <p>Let <code>matches-from($node)</code> be a function that returns true if and only if
               the given node <code>$node</code> matches the pattern given in the <code>from</code>
               attribute, or if <code>$node</code> is the root node of a tree. If the
                  <code>from</code> attribute is omitted, then the function returns true if and only
               if <code>$node</code> is the root node of a tree.</p>
            <p>Let <code>$S</code> be the selected node.</p>
            <p>When <code>level="single"</code>: </p>
            <ulist>
               <item>
                  <p>Let <code>$A</code> be the node sequence selected by the following
                     expression:</p>
                  <p>
                     <code>   $S/ancestor-or-self::node()[matches-count(.)][1]</code>
                  </p>
                  <p>(this selects the innermost ancestor-or-self node that matches the
                        <code>count</code> pattern)</p>
               </item>
               <item>
                  <p>Let <code>$F</code> be the node sequence selected by the expression:</p>
                  <p>
                     <code>   $S/ancestor-or-self::node()[matches-from(.)][1]</code>
                  </p>
                  <p>(this selects the innermost ancestor-or-self node that matches the
                        <code>from</code> pattern)</p>
               </item>
               <item>
                  <p>Let <code>$AF</code> be the value of:</p>
                  <p>
                     <code>   $A[ancestor-or-self::node()[. is $F]]</code>
                  </p>
                  <p>(this selects $A if it is in the subtree rooted at $F, or the empty sequence
                     otherwise)</p>
               </item>
               <item>
                  <p>If <code>$AF</code> is empty, return the empty sequence, <code>()</code>
                  </p>
               </item>
               <item>
                  <p>Otherwise return the value of:</p>
                  <p>
                     <code>   1 + count($AF/preceding-sibling::node()[matches-count(.)])</code>
                  </p>
                  <p>(the number of preceding siblings of the counted node that match the
                        <code>count</code> pattern, plus one).</p>
               </item>
            </ulist>
            <p>When <code>level="multiple"</code>: </p>
            <ulist>
               <item>
                  <p>Let <code>$A</code> be the node sequence selected by the expression:</p>
                  <p>
                     <code>   $S/ancestor-or-self::node()[matches-count(.)]</code>
                  </p>
                  <p>(the set of ancestor-or-self nodes that match the <code>count</code>
                     pattern)</p>
               </item>
               <item>
                  <p>Let <code>$F</code> be the node sequence selected by the expression:</p>
                  <p>
                     <code>   $S/ancestor-or-self::node()[matches-from(.)][1]</code>
                  </p>
                  <p>(the innermost ancestor-or-self node that matches the <code>from</code>
                     pattern)</p>
               </item>
               <item>
                  <p>Let <code>$AF</code> be the value of:</p>
                  <p>
                     <code>   $A[ancestor-or-self::node()[. is $F]]</code>
                  </p>
                  <p>(the nodes selected in the first step that are in the subtree rooted at the
                     node selected in the second step)</p>
               </item>
               <item>
                  <p>Return the result of the expression:</p>
                  <p>
                     <code>   for $af in $AF return
                        1+count($af/preceding-sibling::node()[matches-count(.)])</code>
                  </p>
                  <p>(a sequence of integers containing, for each of these nodes, one plus the
                     number of preceding siblings that match the <code>count</code> pattern)</p>
               </item>
            </ulist>
            <p>When <code>level="any"</code>: </p>
            <ulist>
               <item>
                  <p>Let <code>$A</code> be the node sequence selected by the expression:</p>
                  <p>
                     <code>   $S/(preceding::node()|ancestor-or-self::node())[matches-count(.)]</code>
                  </p>
                  <p>(the set of nodes consisting of the selected node together with all nodes,
                     other than attributes and namespaces, that precede the selected node in
                     document order, provided that they match the <code>count</code> pattern)</p>
               </item>
               <item>
                  <p>Let <code>$F</code> be the node sequence selected by the expression:</p>
                  <p diff="chg" at="P-erratumE30">
                     <code>   $S/(preceding::node()|ancestor-or-self::node())[matches-from(.)][last()]</code>
                  </p>
                  <p>(the last node in document order that matches the <code>from</code> pattern and
                     that precedes the selected node, using the same definition)</p>
               </item>
               <item>
                  <p>Let <code>$AF</code> be the node sequence <code>$A[. is $F or . &gt;&gt;
                        $F]</code></p>
                  <p>(the nodes selected in the first step, excluding those that precede the node
                     selected in the second step)</p>
               </item>
               <item>
                  <p>If <code>$AF</code> is empty, return the empty sequence, <code>()</code>
                  </p>
               </item>
               <item>
                  <p>Otherwise return the value of the expression <code>count($AF)</code>
                  </p>
               </item>
            </ulist>
            <p>The resulting sequence of numbers is referred to as the <termref
                  def="dt-place-marker">place marker</termref>.</p>
            <p diff="add" at="G">If the <code>start-at</code> attribute is present, then the
                  <termref def="dt-place-marker">place marker</termref> is <phrase diff="chg"
                  at="S-bug27060">re-based as described in <specref ref="start-at"/>.</phrase></p>
            <p>The sequence of numbers is then converted into a string using the <termref
                  def="dt-effective-value">effective values</termref> of the attributes specified in
                  <specref ref="convert"/>; each of these attributes is interpreted as an <termref
                  def="dt-attribute-value-template">attribute value template</termref>. After
               conversion, the resulting string is used to create a text node, which forms the
               result of the <elcode>xsl:number</elcode> instruction.</p>
            <example>
               <head>Numbering the Items in an Ordered List</head>
               <p>The following will number the items in an ordered list:</p>
               <eg xml:space="preserve" role="xslt-declaration xmlns:fo='fo'">&lt;xsl:template match="ol/item"&gt;
  &lt;fo:block&gt;
    &lt;xsl:number/&gt;
    &lt;xsl:text&gt;. &lt;/xsl:text&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <example>
               <head>Multi-Level Numbering</head>
               <p>The following two rules will number <code>title</code> elements. This is intended
                  for a document that contains a sequence of chapters followed by a sequence of
                  appendices, where both chapters and appendices contain sections, which in turn
                  contain subsections. Chapters are numbered 1, 2, 3; appendices are numbered A, B,
                  C; sections in chapters are numbered 1.1, 1.2, 1.3; sections in appendices are
                  numbered A.1, A.2, A.3. Subsections within a chapter are numbered 1.1.1, 1.1.2,
                  1.1.3; subsections within an appendix are numbered A.1.1, A.1.2, A.1.3.</p>
               <eg xml:space="preserve" role="xslt-declaration xmlns:fo='fo'">&lt;xsl:template match="title"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="multiple"
                 count="chapter|section|subsection"
                 format="1.1 "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="appendix//title" priority="1"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="multiple"
                 count="appendix|section|subsection"
                 format="A.1 "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <example>
               <head>Numbering Notes within a Chapter</head>
               <p>This example numbers notes sequentially within a chapter, <phrase diff="add"
                     at="G">starting from the number 100:</phrase> :</p>
               <eg xml:space="preserve" role="xslt-declaration xmlns:fo='fo'">&lt;xsl:template match="note"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="any" from="chapter" format="(1) " start-at="100"/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</eg>
            </example>
         </div2>
         <div2 id="convert">
            <head>Number to String Conversion Attributes</head>
            <note>
               <p diff="add" at="M">This specification is aligned with that of the
                     <xfunction>format-integer</xfunction> function, but there are differences; for
                  example grouping separators are part of the primary format token in
                     <xfunction>format-integer</xfunction>, but are indicated by separate attributes
                  in <elcode>xsl:number</elcode>.</p>
            </note>
            <p>The following attributes are used to control conversion of a sequence of numbers into
               a string. The numbers are integers greater than or equal to 0 (zero). The attributes
               are all optional.</p>
            <p>The main attribute is <code>format</code>. The default value for the
                  <code>format</code> attribute is <code>1</code>. The <code>format</code> attribute
               is split into a sequence of tokens where each token is a maximal sequence of
               alphanumeric characters or a maximal sequence of non-alphanumeric characters.
                  <emph>Alphanumeric</emph> means any character that has a Unicode category of Nd,
               Nl, No, Lu, Ll, Lt, Lm or Lo <phrase diff="add" at="P-erratumE34">(see <bibref
                     ref="UNICODE"/>)</phrase>. The alphanumeric tokens (<emph>format tokens</emph>)
               indicate the format to be used for each number in the sequence; in most cases the
               format token is the same as the required representation of the number 1 (one).</p>
            <p>Each non-alphanumeric token is either a prefix, a separator, or a suffix. If there is
               a non-alphanumeric token but no format token, then the single non-alphanumeric token
               is used as both the prefix and the suffix. The prefix, if it exists, is the
               non-alphanumeric token that precedes the first format token: the prefix always
               appears exactly once in the constructed string, at the start. The suffix, if it
               exists, is the non-alphanumeric token that follows the last format token: the suffix
               always appears exactly once in the constructed string, at the end. All other
               non-alphanumeric tokens (those that occur between two format tokens) are
                  <emph>separator tokens</emph> and are used to separate numbers in the
               sequence.</p>
            <p>The <var>n</var>th format token is used to format the <var>n</var>th number in the
               sequence. If there are more numbers than format tokens, then the last format token is
               used to format remaining numbers. If there are no format tokens, then a format token
               of <code>1</code> is used to format all numbers. Each number after the first is
               separated from the preceding number by the separator token preceding the format token
               used to format that number, or, if that is the first format token, then by
                  <code>.</code> (dot).</p>
            <example>
               <head>Formatting a List of Numbers</head>
               <p>Given the sequence of numbers <code>5, 13, 7</code> and the format token
                     <code>A-001(i)</code>, the output will be the string <code>E-013(vii)</code>
               </p>
            </example>
            <p>Format tokens are interpreted as follows:</p>
            <ulist>
               <item>
                  <p>Any token where the last character has a decimal digit value of 1 (as specified
                     in the Unicode character property database, <phrase diff="add"
                        at="P-erratumE34">see <bibref ref="UNICODE"/>)</phrase>, and the Unicode
                     value of preceding characters is one less than the Unicode value of the last
                     character generates a decimal representation of the number where each number is
                     at least as long as the format token. The digits used in the decimal
                     representation are the set of digits containing the digit character used in the
                     format token. Thus, a format token <code>1</code> generates the sequence
                        <code>0 1 2 ... 10 11 12 ...</code>, and a format token <code>01</code>
                     generates the sequence <code>00 01 02 ... 09 10 11 12 ... 99 100 101</code>. A
                     format token of <code>&amp;#x661;</code> (Arabic-Indic digit one) generates the
                     sequence <code>١</code> then <code>٢</code> then <code>٣</code> ...</p>
               </item>
               <item>
                  <p>A format token <code>A</code> generates the sequence <code>A B C ... Z AA AB
                        AC...</code>.</p>
               </item>
               <item>
                  <p>A format token <code>a</code> generates the sequence <code>a b c ... z aa ab
                        ac...</code>.</p>
               </item>
               <item>
                  <p>A format token <code>i</code> generates the sequence <code>i ii iii iv v vi vii
                        viii ix x ...</code>.</p>
               </item>
               <item>
                  <p>A format token <code>I</code> generates the sequence <code>I II III IV V VI VII
                        VIII IX X ...</code>.</p>
               </item>
               <item>
                  <p>A format token <code>w</code> generates numbers written as lower-case words,
                     for example in English, <code>one two three four ...</code>. </p>
               </item>
               <item>
                  <p>A format token <code>W</code> generates numbers written as upper-case words,
                     for example in English, <code>ONE TWO THREE FOUR ...</code>. </p>
               </item>
               <item>
                  <p>A format token <code>Ww</code> generates numbers written as title-case words,
                     for example in English, <code>One Two Three Four ...</code>. </p>
               </item>
               <item>
                  <p>Any other format token indicates a numbering sequence in which that token
                     represents the number 1 (one) (but see the note below). It is <termref
                        def="dt-implementation-defined"/> which numbering sequences, additional to
                     those listed above, are supported. If an implementation does not support a
                     numbering sequence represented by the given token, it <rfc2119>must</rfc2119>
                     use a format token of <code>1</code>.</p>
                  <note>
                     <p>In some traditional numbering sequences additional signs are added to denote
                        that the letters should be interpreted as numbers; these are not included in
                        the format token. An example, see also the example below, is classical Greek
                        where a <emph>dexia keraia</emph> and sometimes an <emph>aristeri
                           keraia</emph> is added.</p>
                  </note>
               </item>
            </ulist>
            <imp-def-feature id="idf-local-numbering">The combinations of languages and numbering
               sequences recognized by the <elcode>xsl:number</elcode> instruction, beyond those
               defined as mandatory in this specification, are <termref
                  def="dt-implementation-defined"/>. There <rfc2119>may</rfc2119> be
               implementation-defined upper bounds on the numbers that can be formatted using any
               particular numbering sequence. There <rfc2119>may</rfc2119> be constraints on the
               values of the <code>ordinal</code> attribute recognized for any given
               language.</imp-def-feature>
            <p>For all format tokens other than the first kind above (one that consists of decimal
               digits), there <rfc2119>may</rfc2119> be <termref def="dt-implementation-defined"
                  >implementation-defined</termref> lower and upper bounds on the range of numbers
               that can be formatted using this format token; indeed, for some numbering sequences
               there may be intrinsic limits. <phrase diff="chg" at="S+">For example, the format
                  token <code>&amp;#x2460;</code> (circled digit one, ①) has a range imposed by the
                  Unicode character repertoire (zero to 20 in Unicode versions prior to 3.2, or zero
                  to 50 in subsequent versions).</phrase> For the numbering sequences described
               above any upper bound imposed by the implementation <rfc2119>must not</rfc2119> be
               less than 1000 (one thousand) and any lower bound must not be greater than 1. Numbers
               that fall outside this range <rfc2119>must</rfc2119> be formatted using the format
               token <code>1</code>. The numbering sequence associated with the format token
                  <code>1</code> has a lower bound of 0 (zero).</p>
            <p>The above expansions of numbering sequences for format tokens such as <code>a</code>
               and <code>i</code> are indicative but not prescriptive. There are various conventions
               in use for how alphabetic sequences continue when the alphabet is exhausted, and
               differing conventions for how roman numerals are written (for example,
                  <code>IV</code> versus <code>IIII</code> as the representation of the number 4).
               Sometimes alphabetic sequences are used that omit letters such as <code>i</code> and
                  <code>o</code>. This specification does not prescribe the detail of any sequence
               other than those sequences consisting entirely of decimal digits.</p>
            <p>Many numbering sequences are language-sensitive. This applies especially to the
               sequence selected by the tokens <code>w</code>, <code>W</code> and <code>Ww</code>.
               It also applies to other sequences, for example different languages using the
               Cyrillic alphabet use different sequences of characters, each starting with the
               letter #x410 (Cyrillic capital letter A). In such cases, the <code>lang</code>
               attribute specifies which language’s conventions are to be used; <phrase diff="chg"
                  at="R-bug8477">its <termref def="dt-effective-value">effective value</termref>
                  <rfc2119>must</rfc2119> either be a string in the value space of
                     <code>xs:language</code>, or a zero-length string.</phrase> If no
                  <code>lang</code> value is specified, <phrase diff="add" at="R-bug8477">or if the
                  value is a zero-length string</phrase>, the language that is used is <termref
                  def="dt-implementation-defined">implementation-defined</termref>. The set of
               languages for which numbering is supported is <termref
                  def="dt-implementation-defined">implementation-defined</termref>. If a language is
               requested that is not supported, the processor <phrase diff="chg" at="R-bug8477"
                     ><rfc2119>may</rfc2119> use a fallback language identified by removing
                  successive hyphen-separated suffixes from the supplied value until a supported
                  language code is obtained; failing this, the processor </phrase> uses the language
               that it would use if the <code>lang</code> attribute were omitted.</p>
            <p diff="chg" at="S-bug27614">The optional <code>ordinal</code> attribute is used to
               indicate whether cardinal or ordinal numbers are required, and to select other
               options relating to the grammatical context of the number to be formatted. The
               allowed set of values is <termref def="dt-implementation-defined"/>. If the attribute
               is absent, or if its value is zero-length, or if its value is <code>no</code> or
                  <code>0</code> or <code>false</code>, then cardinal numbers appropriate to the
               selected language are output. If the value is <code>yes</code> or <code>1</code> or
                  <code>true</code>, then ordinal numbers appropriate to the target language are
               output. Other values are <termref def="dt-implementation-defined"/>.</p>
            <p>For example, in English, the value <code>ordinal="yes"</code> when used with the
               format token <code>1</code> outputs the sequence <code>1st 2nd 3rd 4th ...</code>,
               and when used with the format token <code>w</code> outputs the sequence <code>first
                  second third fourth ...</code>.</p>
            <note diff="chg" at="S-bug27614">
               <p>In some languages, the form of numbers (especially ordinal numbers) varies
                  depending on the grammatical context: they may have different genders and may
                  decline with the noun that they qualify. In such cases the value of the
                     <code>ordinal</code> attribute may be used to indicate the variation of the
                  cardinal or ordinal number required, in an <termref
                     def="dt-implementation-defined"/> way. </p>
               <p>The way in which the variation is indicated will depend on the conventions of the
                  language.</p>
               <p>For inflected languages that vary the ending of the word, the approach recommended
                  in the previous version of this specification was to indicate the required ending,
                  preceded by a hyphen: for example in German, appropriate values might be
                     <code>ordinal="-e"</code>, <code>ordinal="-er"</code>,
                     <code>ordinal="-es"</code>, <code>ordinal="-en"</code>. </p>
               <p>Another approach, which might usefully be adopted by an implementation based on
                  the open-source ICU localization library <bibref ref="ICU"/>, or any other library
                  making use of the Unicode Common Locale Data Repository <bibref ref="CLDR"/>, is
                  to allow the value of the attribute to be the name of a registered numbering rule
                  set for the language in question, conventionally prefixed with a percent sign: for
                  example, <code>ordinal="%spellout-ordinal-masculine"</code>, or
                     <code>ordinal="%spellout-cardinal-year"</code>. (The attribute name
                     <code>ordinal</code> in this case is a misnomer, but serves the purpose.) </p>
            </note>
            <example>
               <head>Ordinal Numbering in Italian</head>
               <p>The specification <code>format="1" ordinal="-º" lang="it"</code>, if supported,
                  should produce the sequence:</p>
               <eg xml:space="preserve" role="non-xml">1º 2º 3º 4º ...</eg>
               <p>The specification <code>format="Ww" ordinal="-o" lang="it"</code>, if supported,
                  should produce the sequence:</p>
               <eg xml:space="preserve" role="non-xml">Primo Secondo Terzo Quarto Quinto ...</eg>
            </example>
            <p>The <code>letter-value</code> attribute disambiguates between numbering sequences
               that use letters. In many languages there are two commonly used numbering sequences
               that use letters. One numbering sequence assigns numeric values to letters in
               alphabetic sequence, and the other assigns numeric values to each letter in some
               other manner traditional in that language. In English, these would correspond to the
               numbering sequences specified by the format tokens <code>a</code> and <code>i</code>.
               In some languages, the first member of each sequence is the same, and so the format
               token alone would be ambiguous. A value of <code>alphabetic</code> specifies the
               alphabetic sequence; a value of <code>traditional</code> specifies the other
               sequence. If the <code>letter-value</code> attribute is not specified, then it is
                  <termref def="dt-implementation-dependent">implementation-dependent</termref> how
               any ambiguity is resolved.</p>
            <note>
               <p>Implementations may use <termref def="dt-extension-attribute">extension
                     attributes</termref> on <elcode>xsl:number</elcode> to provide additional
                  control over the way in which numbers are formatted.</p>
            </note>
            <p>The <code>grouping-separator</code> attribute gives the separator used as a grouping
               (for example, thousands) separator in decimal numbering sequences, and the optional
                  <code>grouping-size</code> specifies the size (normally 3) of the grouping. For
               example, <code>grouping-separator=","</code> and <code>grouping-size="3"</code> would
               produce numbers of the form <code>1,000,000</code> while
                  <code>grouping-separator="."</code> and <code>grouping-size="2"</code> would
               produce numbers of the form <code>1.00.00.00</code>. If only one of the
                  <code>grouping-separator</code> and <code>grouping-size</code> attributes is
               specified, then it is ignored.</p>
            <p diff="add" at="R-bug9927">The <termref def="dt-effective-value">effective
                  value</termref> of the <code>grouping-separator</code> attribute
                  <rfc2119>may</rfc2119> be any string, including a zero-length string. </p>
            <p diff="add" at="R-bug9927">The <termref def="dt-effective-value">effective
                  value</termref> of the <code>grouping-size</code> attribute
                  <rfc2119>must</rfc2119> be a string in the lexical space of
                  <code>xs:integer</code>. If the resulting integer is positive then it defines the
               number of digits between adjacent grouping separators; it if is zero or negative,
               then no grouping separators are inserted. </p>
            <example>
               <head>Format Tokens and the Resulting Sequences</head>
               <p>These examples use non-Latin characters which might not display correctly in all
                  browsers, depending on the system configuration.</p>
               <table class="data">
                  <caption>Format tokens for use with xsl:number</caption>
                  <thead>
                     <tr>
                        <th align="left" rowspan="1" colspan="1">Description</th>
                        <th align="left" rowspan="1" colspan="1">Format Token</th>
                        <th align="left" rowspan="1" colspan="1">Sequence</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td rowspan="1" colspan="1">French cardinal words</td>
                        <td rowspan="1" colspan="1">
                           <code>format="Ww" lang="fr"</code>
                        </td>
                        <td rowspan="1" colspan="1">Un, Deux, Trois, Quatre</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">German ordinal words</td>
                        <td rowspan="1" colspan="1">
                           <code>format="w" ordinal="-e" lang="de"</code>
                        </td>
                        <td rowspan="1" colspan="1">erste, zweite, dritte, vierte</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">Katakana numbering</td>
                        <td rowspan="1" colspan="1">
                           <code>format="&amp;#x30A2;"</code>
                        </td>
                        <td rowspan="1" colspan="1">ア, イ, ウ, エ, オ, カ, キ, ク, ケ, コ, サ, シ, ス, セ, ソ, タ,
                           チ, ツ, テ, ト, ナ, ニ, ヌ, ネ, ノ, ハ, ヒ, フ, ヘ, ホ, マ, ミ, ム, メ, モ, ヤ, ユ, ヨ, ラ, リ,
                           ル, レ, ロ, ワ, ヰ, ヱ, ヲ, ン</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">Katakana numbering in iroha order</td>
                        <td rowspan="1" colspan="1">
                           <code>format="&amp;#x30A4;"</code>
                        </td>
                        <td rowspan="1" colspan="1">イ, ロ, ハ, ニ, ホ, ヘ, ト, チ, リ, ヌ, ル, ヲ, ワ, カ, ヨ, タ,
                           レ, ソ, ツ, ネ, ナ, ラ, ム, ウ, ヰ, ノ, オ, ク, ヤ, マ, ケ, フ, コ, エ, テ, ア, サ, キ, ユ, メ,
                           ミ, シ, ヱ, ヒ, モ, セ, ス</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">Thai numbering</td>
                        <td rowspan="1" colspan="1">
                           <code>format="&amp;#x0E51;"</code>
                        </td>
                        <td rowspan="1" colspan="1">๑, ๒, ๓, ๔, ๕, ๖, ๗, ๘, ๙, ๑๐, ๑๑, ๑๒, ๑๓, ๑๔,
                           ๑๕, ๑๖, ๑๗, ๑๘, ๑๙, ๒๐</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">Traditional Hebrew numbering</td>
                        <td rowspan="1" colspan="1">
                           <code>format="&amp;#x05D0;" letter-value="traditional"</code>
                        </td>
                        <td rowspan="1" colspan="1">א, ב, ג, ד, ה, ו, ז, ח, ט, י, יא, יב, יג, יד,
                           טו, טז, יז, יח, יט, כ</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">Traditional Georgian numbering</td>
                        <td rowspan="1" colspan="1">
                           <code>format="&amp;#x10D0;" letter-value="traditional"</code>
                        </td>
                        <td rowspan="1" colspan="1">ა, ბ, გ, დ, ე, ვ, ზ, ჱ, თ, ი, ია, იბ, იგ, იდ,
                           იე, ივ, იზ, იჱ, ით, კ </td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">Classical Greek numbering (see note)</td>
                        <td rowspan="1" colspan="1">
                           <code>format="&amp;#x03B1;" letter-value="traditional"</code>
                        </td>
                        <td rowspan="1" colspan="1"><phrase role="normalize-nfc"> αʹ, βʹ, γʹ, δʹ,
                              εʹ, ϛʹ, ζʹ, ηʹ, θʹ, ιʹ, ιαʹ, ιβʹ, ιγʹ, ιδʹ, ιεʹ, ιϛʹ, ιζʹ, ιηʹ, ιθʹ,
                              κʹ</phrase></td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">Old Slavic numbering</td>
                        <td rowspan="1" colspan="1">
                           <code>format="&amp;#x0430;" letter-value="traditional"</code>
                        </td>
                        <td rowspan="1" colspan="1">А, В, Г, Д, Е, Ѕ, З, И, Ѳ, Ӏ, АӀ, ВӀ, ГӀ, ДӀ,
                           ЕӀ, ЅӀ, ЗӀ, ИӀ, ѲӀ, К</td>
                     </tr>
                  </tbody>
               </table>
               <p>Note that Classical Greek is an example where the format token is not the same as
                  the representation of the number 1.</p>
            </example>
         </div2>
      </div1>
      <div1 id="sorting">
         <head>Sorting</head>
         <p>
            <termdef id="dt-sort-key-specification" term="sort key specification">A <term>sort key
                  specification</term> is a sequence of one or more adjacent
                  <elcode>xsl:sort</elcode> elements which together define rules for sorting the
               items in an input sequence to form a sorted sequence.</termdef>
         </p>
         <p>
            <termdef id="dt-sort-key-component" term="sort key component">Within a <termref
                  def="dt-sort-key-specification">sort key specification</termref>, each
                  <elcode>xsl:sort</elcode> element defines one <term>sort key
               component</term>.</termdef> The first <elcode>xsl:sort</elcode> element specifies the
            primary component of the sort key specification, the second <elcode>xsl:sort</elcode>
            element specifies the secondary component of the sort key specification, and so on.</p>
         <p>A sort key specification may occur immediately within an
               <elcode>xsl:apply-templates</elcode>, <elcode>xsl:for-each</elcode>,
               <elcode>xsl:perform-sort</elcode>, or <elcode>xsl:for-each-group</elcode>
            element.</p>
         <note>
            <p>When used within <elcode>xsl:for-each</elcode>, <elcode>xsl:for-each-group</elcode>,
               or <elcode>xsl:perform-sort</elcode>, <elcode>xsl:sort</elcode> elements must occur
               before any other children.</p>
         </note>
         <div2 id="xsl-sort">
            <head>The <elcode>xsl:sort</elcode> Element</head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="sort">
               <e:attribute name="select">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="lang">
                  <e:attribute-value-template>
                     <e:data-type name="language"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="order">
                  <e:attribute-value-template>
                     <e:constant value="ascending"/>
                     <e:constant value="descending"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="collation">
                  <e:attribute-value-template>
                     <e:data-type name="uri"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="stable">
                  <e:attribute-value-template>
                     <e:data-type name="boolean"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="case-order">
                  <e:attribute-value-template>
                     <e:constant value="upper-first"/>
                     <e:constant value="lower-first"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="data-type">
                  <e:attribute-value-template>
                     <e:constant value="text"/>
                     <e:constant value="number"/>
                     <e:data-type name="eqname"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent name="apply-templates"/>
                  <e:parent name="for-each"/>
                  <e:parent name="for-each-group"/>
                  <e:parent name="perform-sort"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:sort</elcode> element defines a <termref def="dt-sort-key-component"
                  >sort key component</termref>. A sort key component specifies how a <termref
                  def="dt-sort-key-value">sort key value</termref> is to be computed for each item
               in the sequence being sorted, and also how two sort key values are to be
               compared.</p>
            <p>The value of a <termref def="dt-sort-key-component">sort key component</termref> is
               determined either by its <code>select</code> attribute or by the contained <termref
                  def="dt-sequence-constructor">sequence constructor</termref>. If neither is
               present, the default is <code>select="."</code>, which has the effect of sorting on
               the actual value of the item if it is an atomic value, or on the typed-value of the
               item if it is a node. If a <code>select</code> attribute is present, its value
                  <rfc2119>must</rfc2119> be an XPath <termref def="dt-expression"
                  >expression</termref>.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="1015"><p>It is a <termref
                        def="dt-static-error">static error</termref> if an <elcode>xsl:sort</elcode>
                     element with a <code>select</code> attribute has non-empty content.</p></error>
            </p>
            <p>Those attributes of the <elcode>xsl:sort</elcode> elements whose values are <termref
                  def="dt-attribute-value-template">attribute value templates</termref> are
               evaluated using the same <termref def="dt-focus">focus</termref> as is used to
               evaluate the <code>select</code> attribute of the containing instruction
               (specifically, <elcode>xsl:apply-templates</elcode>, <elcode>xsl:for-each</elcode>,
                  <elcode>xsl:for-each-group</elcode>, or <elcode>xsl:perform-sort</elcode>).</p>
            <p>The <code>stable</code> attribute is permitted only on the first
                  <elcode>xsl:sort</elcode> element within a <termref
                  def="dt-sort-key-specification">sort key specification</termref>. </p>
            <p>
               <error spec="XT" type="static" class="SE" code="1017"><p>It is a <termref
                        def="dt-static-error">static error</termref> if an <elcode>xsl:sort</elcode>
                     element other than the first in a sequence of sibling <elcode>xsl:sort</elcode>
                     elements has a <code>stable</code> attribute.</p></error>
            </p>
            <p>
               <termdef id="dt-stable" term="stable">A <termref def="dt-sort-key-specification">sort
                     key specification</termref> is said to be <term>stable</term> if its first
                     <elcode>xsl:sort</elcode> element has no <code>stable</code> attribute, or has
                  a <code>stable</code> attribute whose <termref def="dt-effective-value">effective
                     value</termref> is <code>yes</code>.</termdef>
            </p>
            <div3 id="sorting-process">
               <head>The Sorting Process</head>
               <p>
                  <termdef id="dt-initial-sequence" term="initial sequence">The sequence to be
                     sorted is referred to as the <term>initial sequence</term>.</termdef>
               </p>
               <p>
                  <termdef id="dt-sorted-sequence" term="sorted sequence">The sequence after sorting
                     as defined by the <elcode>xsl:sort</elcode> elements is referred to as the
                        <term>sorted sequence</term>.</termdef>
               </p>
               <p>
                  <termdef id="dt-sort-key-value" term="sort key value"> For each item in the
                        <termref def="dt-initial-sequence">initial sequence</termref>, a value is
                     computed for each <termref def="dt-sort-key-component">sort key
                        component</termref> within the <termref def="dt-sort-key-specification">sort
                        key specification</termref>. The value computed for an item by using the
                        <var>N</var>th sort key component is referred to as the <var>N</var>th
                        <term>sort key value</term> of that item.</termdef>
               </p>
               <p>The items in the <termref def="dt-initial-sequence">initial sequence</termref> are
                  ordered into a <termref def="dt-sorted-sequence">sorted sequence</termref> by
                  comparing their <termref def="dt-sort-key-value">sort key values</termref>. The
                  relative position of two items <var>A</var> and <var>B</var> in the sorted
                  sequence is determined as follows. The first sort key value of <var>A</var> is
                  compared with the first sort key value of <var>B</var>, according to the rules of
                  the first <termref def="dt-sort-key-component">sort key component</termref>. If,
                  under these rules, <var>A</var> is less than <var>B</var>, then <var>A</var> will
                  precede <var>B</var> in the sorted sequence, unless the <code>order</code>
                  attribute of this <termref def="dt-sort-key-component">sort key
                     component</termref> specifies <code>descending</code>, in which case
                     <var>B</var> will precede <var>A</var> in the sorted sequence. If, however, the
                  relevant sort key values compare equal, then the second sort key value of
                     <var>A</var> is compared with the second sort key value of <var>B</var>,
                  according to the rules of the second <termref def="dt-sort-key-component">sort key
                     component</termref>. This continues until two sort key values are found that
                  compare unequal. If all the sort key values compare equal, and the <termref
                     def="dt-sort-key-specification">sort key specification</termref> is <termref
                     def="dt-stable">stable</termref>, then <var>A</var> will precede <var>B</var>
                  in the <termref def="dt-sorted-sequence">sorted sequence</termref> if and only if
                     <var>A</var> preceded <var>B</var> in the <termref def="dt-initial-sequence"
                     >initial sequence</termref>. If all the sort key values compare equal, and the
                     <termref def="dt-sort-key-specification">sort key specification</termref> is
                  not <termref def="dt-stable">stable</termref>, then the relative order of
                     <var>A</var> and <var>B</var> in the <termref def="dt-sorted-sequence">sorted
                     sequence</termref> is <termref def="dt-implementation-dependent"
                     >implementation-dependent</termref>.</p>
               <note>
                  <p>If two items have equal <termref def="dt-sort-key-value">sort key
                        values</termref>, and the sort is <termref def="dt-stable">stable</termref>,
                     then their order in the <termref def="dt-sorted-sequence">sorted
                        sequence</termref> will be the same as their order in the <termref
                        def="dt-initial-sequence">initial sequence</termref>, regardless of whether
                        <code>order="descending"</code> was specified on any or all of the <termref
                        def="dt-sort-key-component">sort key components</termref>.</p>
               </note>
               <p>The <var>N</var>th sort key value is computed by evaluating either the
                     <code>select</code> attribute or the contained <termref
                     def="dt-sequence-constructor">sequence constructor</termref> of the
                     <var>N</var>th <elcode>xsl:sort</elcode> element, or the expression
                     <code>.</code> (dot) if neither is present. This evaluation is done with the
                     <termref def="dt-focus">focus</termref> set as follows:</p>
               <ulist>
                  <item>
                     <p>The <termref def="dt-context-item">context item</termref> is the item in the
                           <termref def="dt-initial-sequence">initial sequence</termref> whose
                           <termref def="dt-sort-key-value">sort key value</termref> is being
                        computed.</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-context-position">context position</termref> is the
                        position of that item in the initial sequence.</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-context-size">context size</termref> is the size of the
                        initial sequence.</p>
                  </item>
               </ulist>
               <note>
                  <p>As in any other XPath expression, the <function>current</function> function may
                     be used within the <code>select</code> expression of <elcode>xsl:sort</elcode>
                     to refer to the item that is the context item for the expression as a whole;
                     that is, the item whose <termref def="dt-sort-key-value">sort key
                        value</termref> is being computed.</p>
               </note>
               <p>The <termref def="dt-sort-key-value">sort key values</termref> are <termref
                     def="dt-atomization">atomized</termref>, and are then compared. The way they
                  are compared depends on their datatype, as described in the next section.</p>
            </div3>
            <div3 id="comparing-sort-keys">
               <head>Comparing Sort Key Values</head>
               <p>It is possible to force the system to compare <termref def="dt-sort-key-value"
                     >sort key values</termref> using the rules for a particular datatype by
                  including a cast as part of the <termref def="dt-sort-key-component">sort key
                     component</termref>. For example, <code>&lt;xsl:sort
                     select="xs:date(@dob)"/&gt;</code> will force the attributes to be compared as
                  dates. In the absence of such a cast, the sort key values are compared using the
                  rules appropriate to their datatype. Any values of type
                     <code>xs:untypedAtomic</code> are cast to <code>xs:string</code>.</p>
               <p>For backwards compatibility with XSLT 1.0, the <code>data-type</code> attribute
                  remains available. If this has the <termref def="dt-effective-value">effective
                     value</termref>
                  <code>text</code>, the atomized <termref def="dt-sort-key-value">sort key
                     values</termref> are converted to strings before being compared. If it has the
                  effective value <code>number</code>, the atomized sort key values are converted to
                  doubles before being compared. The conversion is done by using the
                     <xfunction>string</xfunction> or <xfunction>number</xfunction> function as
                  appropriate. <phrase diff="chg" at="K">If the <code>data-type</code> attribute has
                     any other <termref def="dt-effective-value">effective value</termref>, then
                     this value <rfc2119>must</rfc2119> be an <termref def="dt-eqname"
                        >EQName</termref> denoting an <termref def="dt-expanded-qname">expanded
                        QName</termref> with a non-absent namespace</phrase>, and the effect of the
                  attribute is <termref def="dt-implementation-defined"/>.</p>
               <imp-def-feature id="idf-ext-sortdatatype">If the <code>data-type</code> attribute of
                  the <elcode>xsl:sort</elcode> element has a value other than <code>text</code> or
                     <code>number</code>, the effect is implementation-defined.</imp-def-feature>
               <p>
                  <error spec="XT" type="type" class="TE" code="1020"><p>If any <termref
                           def="dt-sort-key-value">sort key value</termref>, after <termref
                           def="dt-atomization">atomization</termref> and any type conversion
                           <rfc2119>required</rfc2119> by the <code>data-type</code> attribute, is a
                        sequence containing more than one item, then the effect depends on whether
                        the <elcode>xsl:sort</elcode> element <phrase diff="chg" at="D">is processed
                           with <termref def="dt-xslt-10-behavior">XSLT 1.0 behavior</termref>. With
                           XSLT 1.0 behavior,</phrase> the effective sort key value is the first
                        item in the sequence. In other cases, this is a <termref def="dt-type-error"
                           >type error</termref>.</p></error>
               </p>
               <p>The set of <termref def="dt-sort-key-value">sort key values</termref> (after any
                  conversion) is first divided into two categories: empty values, and ordinary
                  values. The empty sort key values represent those items where the sort key value
                  is an empty sequence. These values are considered for sorting purposes to be equal
                  to each other, but less than any other value. The remaining values are classified
                  as ordinary values.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1030"><p>It is a <termref
                           def="dt-dynamic-error"><phrase diff="del" at="M">non-recoverable</phrase>
                           dynamic error</termref> if, for any <termref def="dt-sort-key-component"
                           >sort key component</termref>, the set of <termref
                           def="dt-sort-key-value">sort key values</termref> evaluated for all the
                        items in the <termref def="dt-initial-sequence">initial sequence</termref>,
                        after any type conversion requested, contains a pair of ordinary values for
                        which the result of the XPath <code>lt</code> operator is an error. <phrase
                           diff="add" at="R-bug6857">If the processor is able to detect the error
                           statically, it <rfc2119>may</rfc2119> optionally signal it as a <termref
                              def="dt-static-error">static error</termref>.</phrase></p></error>
               </p>
               <note>
                  <p>The above error condition may occur if the values to be sorted are of a type
                     that does not support ordering (for example, <code>xs:QName</code>) or if the
                     sequence is heterogeneous (for example, if it contains both strings and
                     numbers). The error can generally be prevented by invoking a cast or
                     constructor function within the sort key component.</p>
                  <p>The error condition is subject to the usual caveat that a processor is not
                     required to evaluate any expression solely in order to determine whether it
                     raises an error. For example, if there are several sort key components, then a
                     processor is not required to evaluate or compare minor sort key values unless
                     the corresponding major sort key values are equal.</p>
               </note>
               <p>In general, comparison of two ordinary values is performed according to the rules
                  of the XPath <code>lt</code> operator. To ensure a total ordering, the same
                  implementation of the <code>lt</code> operator <rfc2119>must</rfc2119> be used for
                  all the comparisons: the one that is chosen is the one appropriate to the most
                  specific type to which all the values can be converted by subtype substitution
                  and/or type promotion. For example, if the sequence contains both
                     <code>xs:decimal</code> and <code>xs:double</code> values, then the values are
                  compared using <code>xs:double</code> comparison, even when comparing two
                     <code>xs:decimal</code> values. NaN values, for sorting purposes, are
                  considered to be equal to each other, and less than any other numeric value.
                  Special rules also apply to the <code>xs:string</code> and <code>xs:anyURI</code>
                  types, and types derived by restriction therefrom, as described in the next
                  section.</p>
            </div3>
            <div3 id="collating-sequences">
               <head>Sorting Using Collations</head>
               <p>The rules given in this section apply when comparing values whose type is
                     <code>xs:string</code> or a type derived by restriction from
                     <code>xs:string</code>, or whose type is <code>xs:anyURI</code> or a type
                  derived by restriction from <code>xs:anyURI</code>.</p>
               <p>
                  <termdef id="dt-collation" term="collation">Facilities in XSLT <phrase diff="chg"
                        at="A">3.0</phrase> and XPath <phrase diff="chg" at="C">3.0</phrase> that
                     require strings to be ordered rely on the concept of a named
                        <term>collation</term>. A collation is a set of rules that determine whether
                     two strings are equal, and if not, which of them is to be sorted before the
                     other.</termdef> A collation is identified by a URI, but the manner in which
                  this URI is associated with an actual rule or algorithm is largely <termref
                     def="dt-implementation-defined">implementation-defined</termref>.</p>
               <p>For more information about collations, see <xspecref spec="FO30"
                     ref="string-compare"/> in <bibref ref="xpath-functions-30"/>. Some
                  specifications, for example <bibref ref="UNICODE-TR10"/>, use the term “collation”
                  to describe rules that can be tailored or parameterized for various purposes. In
                  this specification, a collation URI refers to a collation in which all such
                  parameters have already been fixed. Therefore, if a collation URI is specified,
                  other attributes such as <code>case-order</code> and <code>lang</code> are
                  ignored. </p>
               <imp-def-feature id="idf-local-collations">The facilities for defining collations and
                  allocating URIs to identify them are largely
                  implementation-defined.</imp-def-feature>
               <p>Every implementation <phrase diff="chg" at="S-bug27627"><rfc2119>must</rfc2119>
                     recognize the collation URI </phrase>
                  <code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>, which
                  provides the ability to compare strings based on the Unicode codepoint values of
                  the characters in the string.</p>
               <p diff="add" at="N">Furthermore, every implementation must recognize collation URIs
                  representing tailorings of the Unicode Collation Algorithm (UCA), as described in
                     <specref ref="uca-collations"/>. Although this form of collation URI must be
                  recognized, implementations are not required to support every possible
                  tailoring.</p>
               <p>If the <elcode>xsl:sort</elcode> element has a <code>collation</code> attribute,
                  then the strings are compared according to the rules for the named <termref
                     def="dt-collation">collation</termref>: that is, they are compared using the
                  XPath function call <code>compare($a, $b, $collation)</code>.</p>
               <p>If the <termref def="dt-effective-value">effective value</termref> of the
                     <code>collation</code> attribute of <elcode>xsl:sort</elcode> is a relative
                  URI, then it is resolved against the base URI of the <elcode>xsl:sort</elcode>
                  element.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1035"><p>It is a <termref
                           def="dt-dynamic-error"><phrase diff="del" at="M">non-recoverable</phrase>
                           dynamic error</termref> if the <code>collation</code> attribute of
                           <elcode>xsl:sort</elcode> (after resolving against the base URI) is not a
                        URI that is recognized by the implementation as referring to a
                        collation.</p></error>
               </p>
               <note>
                  <p>It is entirely for the implementation to determine whether it recognizes a
                     particular collation URI. For example, if the implementation allows collation
                     URIs to contain parameters in the query part of the URI, it is the
                     implementation that determines whether a URI containing an unknown or invalid
                     parameter is or is not a recognized collation URI. The fact that this situation
                     is described as an error thus does not prevent an implementation applying a
                     fallback collation if it chooses to do so.</p>
               </note>
               <p>The <code>lang</code> and <code>case-order</code> attributes are ignored if a
                     <code>collation</code> attribute is present. But in the absence of a
                     <code>collation</code> attribute, these attributes provide input to an <termref
                     def="dt-implementation-defined">implementation-defined</termref> algorithm to
                  locate a suitable collation:</p>
               <imp-def-feature id="idf-local-implicitcollations">The algorithm used by
                     <elcode>xsl:sort</elcode> to locate a collation, given the values of the
                     <code>lang</code> and <code>case-order</code> attributes, is
                  implementation-defined.</imp-def-feature>
               <ulist>
                  <item>
                     <p>The <code>lang</code> attribute indicates that a collation suitable for a
                        particular natural language <rfc2119>should</rfc2119> be used. The <termref
                           def="dt-effective-value">effective value</termref> of the attribute
                           <rfc2119>must</rfc2119>
                        <phrase diff="chg" at="R-bug8477"> either be a string in the value space of
                              <code>xs:language</code>, or a zero-length string. Supplying the
                           zero-length string has the same effect as omitting the attribute. If a
                           language is requested that is not supported, the processor
                              <rfc2119>may</rfc2119> use a fallback language identified by removing
                           successive hyphen-separated suffixes from the supplied value until a
                           supported language code is obtained; failing this, the processor behaves
                           as if the <code>lang</code> attribute were omitted. </phrase></p>
                     <note diff="add" at="S-bug29252">
                        <p>The fallback algorithm described above is identical to the rules in
                           RFC4647 Basic Filtering used in BCP 47, and is specified in <bibref
                              ref="RFC4647"/> in greater detail.</p>
                     </note>
                  </item>
                  <item>
                     <p>The <code>case-order</code> attribute indicates whether the desired
                        collation <rfc2119>should</rfc2119> sort upper-case letters before
                        lower-case or vice versa. The <termref def="dt-effective-value">effective
                           value</termref> of the attribute <rfc2119>must</rfc2119> be either
                           <code>lower-first</code> (indicating that lower-case letters precede
                        upper-case letters in the collating sequence) or <code>upper-first</code>
                        (indicating that upper-case letters precede lower-case).</p>
                     <p>When <code>lower-first</code> is requested, the returned collation
                           <rfc2119>should</rfc2119> have the property that when two strings differ
                        only in the case of one or more characters, then a string in which the first
                        differing character is lower-case should precede a string in which the
                        corresponding character is title-case, which should in turn precede a string
                        in which the corresponding character is upper-case. When upper-first is
                        requested, the returned collation <rfc2119>should</rfc2119> have the
                        property that when two strings differ only in the case of one or more
                        characters, then a string in which the first differing character is
                        upper-case should precede a string in which the corresponding character is
                        title-case, which should in turn precede a string in which the corresponding
                        character is lower-case.</p>
                     <p>So, for example, if <code>lang="en"</code>, then <code>A a B b</code> are
                        sorted with <code>case-order="upper-first"</code> and <code>a A b B</code>
                        are sorted with <code>case-order="lower-first"</code>.</p>
                     <p>As a further example, if <code>lower-first</code> is requested, then a
                        sorted sequence might be “MacAndrew, macintosh, macIntosh, Macintosh,
                        MacIntosh, macintoshes, Macintoshes, McIntosh”. If <code>upper-first</code>
                        is requested, the same sequence would sort as “MacAndrew, MacIntosh,
                        Macintosh, macIntosh, macintosh, MacIntoshes, macintoshes, McIntosh”.</p>
                  </item>
               </ulist>
               <p>If none of the <code>collation</code>, <code>lang</code>, or
                     <code>case-order</code> attributes is present, the collation is chosen in an
                     <termref def="dt-implementation-defined"/> way. It is not
                     <rfc2119>required</rfc2119> that the default collation for sorting should be
                  the same as the <termref def="dt-default-collation">default collation</termref>
                  used when evaluating XPath expressions, as described in <specref
                     ref="static-context"/> and <specref ref="default-collation-attribute"/>.</p>
               <imp-def-feature id="idf-local-defaultsortcollation">If none of the
                     <code>collation</code>, <code>lang</code>, or <code>case-order</code>
                  attributes is present (on <elcode>xsl:sort</elcode>), the collation is chosen in
                  an <termref def="dt-implementation-defined"/> way.</imp-def-feature>
               <note>
                  <p>It is usually appropriate, when sorting, to use a strong collation, that is,
                     one that takes account of secondary differences (accents) and tertiary
                     differences (case) between strings that are otherwise equal. A weak collation,
                     which ignores such differences, may be more suitable when comparing strings for
                     equality.</p>
                  <p>Useful background information on international sorting is provided in <bibref
                        ref="UNICODE-TR10"/>. The <code>case-order</code> attribute may be
                     interpreted as described in section 6.6 of <bibref ref="UNICODE-TR10"/>.</p>
               </note>
            </div3>
         </div2>
         <div2 id="creating-sorted-sequence">
            <head>Creating a Sorted Sequence</head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="perform-sort">
               <e:in-category name="instruction"/>
               <e:attribute name="select" required="no">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:sequence>
                  <e:element repeat="one-or-more" name="sort"/>
                  <e:model name="sequence-constructor"/>
               </e:sequence>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:perform-sort</elcode> instruction is used to return a <termref
                  def="dt-sorted-sequence">sorted sequence</termref>.</p>
            <p>The <termref def="dt-initial-sequence">initial sequence</termref> is obtained either
               by evaluating the <code>select</code> attribute or by evaluating the contained
               sequence constructor (but not both). If there is no <code>select</code> attribute and
               no sequence constructor then the <termref def="dt-initial-sequence">initial
                  sequence</termref> (and therefore, the <termref def="dt-sorted-sequence">sorted
                  sequence</termref>) is an empty sequence.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="1040"><p>It is a <termref
                        def="dt-static-error">static error</termref> if an
                        <elcode>xsl:perform-sort</elcode> instruction with a <code>select</code>
                     attribute has any content other than <elcode>xsl:sort</elcode> and
                        <elcode>xsl:fallback</elcode> instructions.</p></error>
            </p>
            <p>The result of the <elcode>xsl:perform-sort</elcode> instruction is the result of
               sorting its <termref def="dt-initial-sequence">initial sequence</termref> using its
               contained <termref def="dt-sort-key-specification">sort key
               specification</termref>.</p>
            <example>
               <head>Sorting a Sequence of Atomic Values</head>
               <p>The following stylesheet function sorts a sequence of atomic values using the
                  value itself as the sort key.</p>
               <eg xml:space="preserve" role="xslt-declaration xmlns:local='local'">&lt;xsl:function name="local:sort" 
          as="xs:anyAtomicType*"&gt;
  &lt;xsl:param name="in" as="xs:anyAtomicType*"/&gt;
  &lt;xsl:perform-sort select="$in"&gt;
    &lt;xsl:sort select="."/&gt;
  &lt;/xsl:perform-sort&gt;
&lt;/xsl:function&gt;</eg>
            </example>
            <example>
               <head>Writing a Function to Perform a Sort</head>
               <p>The following example defines a function that sorts books by price, and uses this
                  function to output the five books that have the lowest prices:</p>
               <eg xml:space="preserve" role="non-xml">&lt;xsl:function name="bib:books-by-price" 
          as="schema-element(bib:book)*"&gt;
  &lt;xsl:param name="in" as="schema-element(bib:book)*"/&gt;
  &lt;xsl:perform-sort select="$in"&gt;
    &lt;xsl:sort select="xs:decimal(bib:price)"/&gt;
  &lt;/xsl:perform-sort&gt;
&lt;/xsl:function&gt;
   ...
   &lt;xsl:copy-of select="bib:books-by-price(//bib:book)
                             [position() = 1 to 5]"/&gt;

 </eg>
            </example>
         </div2>
         <div2 id="sorted-iteration">
            <head>Processing a Sequence in Sorted Order</head>
            <p>When used within <elcode>xsl:for-each</elcode> or
                  <elcode>xsl:apply-templates</elcode>, a <termref def="dt-sort-key-specification"
                  >sort key specification</termref> indicates that the sequence of items selected by
               that instruction is to be processed in sorted order, not in the order of the supplied
               sequence.</p>
            <example>
               <head>Processing Elements in Sorted Order</head>
               <p>For example, suppose an employee database has the form</p>
               <eg xml:space="preserve" role="xml">&lt;employees&gt;
  &lt;employee&gt;
    &lt;name&gt;
      &lt;given&gt;James&lt;/given&gt;
      &lt;family&gt;Clark&lt;/family&gt;
    &lt;/name&gt;
    ...
  &lt;/employee&gt;
&lt;/employees&gt;
</eg>
               <p>Then a list of employees sorted by name could be generated using:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="employees"&gt;
  &lt;ul&gt;
    &lt;xsl:apply-templates select="employee"&gt;
      &lt;xsl:sort select="name/family"/&gt;
      &lt;xsl:sort select="name/given"/&gt;
    &lt;/xsl:apply-templates&gt;
  &lt;/ul&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="employee"&gt;
  &lt;li&gt;
    &lt;xsl:value-of select="name/given"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:value-of select="name/family"/&gt;
  &lt;/li&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <p>When used within <elcode>xsl:for-each-group</elcode>, a <termref
                  def="dt-sort-key-specification">sort key specification</termref> indicates the
               order in which the groups are to be processed. For the effect of
                  <elcode>xsl:for-each-group</elcode>, see <specref ref="grouping"/>. </p>
         </div2>
         <div2 id="uca-collations" diff="add" at="N">
            <head>The Unicode Collation Algorithm</head>
            <p><emph>The description of the Unicode Collation Algorithm in this section is
                  technically identical to the description found in <bibref ref="xpath-31"/>. The
                  description here is to be used by a processor that does not implement the <termref
                     def="dt-xpath31-feature"/>; if the processor does implement the <termref
                     def="dt-xpath31-feature"/>, the description in <bibref ref="xpath-31"/>
                  applies.</emph></p>
            <p>XSLT 3.0 defines a family of collation URIs representing tailorings of the Unicode
               Collation Algorithm (UCA) as defined in <bibref ref="UNICODE-TR10"/>. The parameters
               used for tailoring the UCA are based on the parameters defined in the Locale Data
               Markup Language (LDML), defined in <bibref ref="UNICODE-TR35"/>.</p>
            <p>This family of URIs use the scheme and path
                  <code>http://www.w3.org/2013/collation/UCA</code> followed by an optional query
               part. The query part, if present, consists of a question mark followed by a sequence
               of zero or more semicolon-separated parameters. Each parameter is a keyword-value
               pair, the keyword and value being separated by an equals sign.</p>
            <p>All implementations must recognize URIs in this family. This applies to all places
               where collations are used, including (for example) the <elcode>xsl:sort</elcode>,
                  <elcode>xsl:key</elcode>, <elcode>xsl:for-each-group</elcode>, and
                  <elcode>xsl:merge-key</elcode> elements, the <code>[xsl:]default-collation</code>
               attribute, and the <code>collation</code> argument of functions such as
                  <xfunction>contains</xfunction>, <xfunction>max</xfunction>, <phrase diff="add"
                  at="R-bug24970"> and <function>collation-key</function></phrase>. If the
                  <code>fallback</code> parameter is present with the value <code>no</code>, then
               the implementation <rfc2119>must</rfc2119> either use a collation that conforms with
               the rules in the Unicode specifications for the requested tailoring, or fail with a
               static or dynamic error indicating that it does not provide the collation (the error
               code should be the same as if the collation URI were not recognized). If the
                  <code>fallback</code> parameter is omitted or takes the value <code>yes</code>,
               and if the collation URI is well-formed according to the rules in this section, then
               the implementation <rfc2119>must</rfc2119> accept the collation URI, and
                  <rfc2119>should</rfc2119> use the available collation that most closely reflects
               the user’s intentions. For example, if the collation URI requested is
                  <code>http://www.w3.org/2013/collation/UCA?lang=se;fallback=yes</code> and the
               implementation does not include a fully conformant version of the UCA tailored for
               Swedish, then it <rfc2119>may</rfc2119> choose to use a Swedish collation that is
               known to differ from the UCA definition, or one whose conformance has not been
               established. It might even, as a last resort, fall back to using codepoint
               collation.</p>
            <p>If two query parameters use the same keyword then the last one wins. If a query
               parameter uses a keyword or value which is not defined in this specification then the
               meaning is <termref def="dt-implementation-defined"/>. If the implementation
               recognizes the meaning of the keyword and value then it <rfc2119>should</rfc2119>
               interpret it accordingly; if it does not recognize the keyword or value then if the
                  <code>fallback</code> parameter is present with the value <code>no</code> it
               should reject the collation as unsupported, otherwise it should ignore the
               unrecognized parameter.</p>
            <p>The following query parameters are defined. If any parameter is absent, the default
               is <termref def="dt-implementation-defined"/> except where otherwise stated. The
               meaning given for each parameter is non-normative; the normative specification is
               found in <bibref ref="UNICODE-TR35"/>.</p>
            <imp-def-feature id="idf-local-ucaextensions">When using the family of URIs that invoke
               the Unicode Collation Algorithm, the effect of supplying a query keyword or value not
               defined in this specification is <termref def="dt-implementation-defined"/>. The
               defaults for query keywords are also implementation-defined unless otherwise
               stated.</imp-def-feature>
            <table class="data">
               <caption>Options for the Unicode Collation Algorithm</caption>
               <thead>
                  <tr>
                     <th rowspan="1" colspan="1">Keyword</th>
                     <th rowspan="1" colspan="1">Values</th>
                     <th rowspan="1" colspan="1">Meaning</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td rowspan="1" colspan="1">fallback</td>
                     <td rowspan="1" colspan="1">yes | no (default yes)</td>
                     <td rowspan="1" colspan="1">Determines whether the processor uses a fallback
                        collation if a conformant collation is not available.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">lang</td>
                     <td rowspan="1" colspan="1">language code, as defined for the <code>lang</code>
                        attribute of <elcode>xsl:sort</elcode></td>
                     <td rowspan="1" colspan="1">The language whose collation conventions are to be
                        used.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">version</td>
                     <td rowspan="1" colspan="1">string</td>
                     <td rowspan="1" colspan="1">The version number of the UCA to be used.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">strength</td>
                     <td rowspan="1" colspan="1">primary | secondary | tertiary | quaternary |
                        identical, or 1|2|3|4|5 as synonyms</td>
                     <td rowspan="1" colspan="1">The collation strength as defined in UCA. Primary
                        strength takes only the base form of the character into account (so
                        A=a=Â=â); secondary strength ignores case but considers accents and
                        diacritics as significant (so A=a and Â=â but â!=a); tertiary considers case
                        as significant (A!=a!=Â!=â); quaternary considers spaces and punctuation
                        that would otherwise be ignored (for example
                           <code>data-base</code>=<code>database</code>).</td>
                  </tr>
                  <tr diff="add" at="T-bug29865">
                     <td valign="top" rowspan="1" colspan="1">maxVariable</td>
                     <td valign="top" rowspan="1" colspan="1">space | punct | symbol | currency
                        (default punct)</td>
                     <td valign="top" rowspan="1" colspan="1"> Indicates that all characters in the
                        specified group and earlier groups are treated as "noise" characters to be
                        handled as defined by the <code>alternate</code> parameter. For example,
                           <code>maxVariable=punct</code> indicates that characters classified as
                        whitespace or punctuation get this treatment.</td>
                  </tr>
                  <tr diff="chg" at="E">
                     <td valign="top" rowspan="1" colspan="1">alternate</td>
                     <td valign="top" rowspan="1" colspan="1">non-ignorable | shifted | blanked
                        (default non-ignorable)</td>
                     <td valign="top" rowspan="1" colspan="1">Controls the handling of characters
                        such as spaces and hyphens; specifically, the “noise” characters in the
                        groups selected by the <code>maxVariable</code> parameter. The value
                           <code>non-ignorable</code> indicates that such characters are treated as
                        distinct at the primary level (so <code>data base</code> sorts before
                           <code>datatype</code>); <code>shifted</code> indicates that they are are
                        used to differentiate two strings only at the <code>quaternary</code> level,
                        and <code>blanked</code> indicates that they are taken into account only at
                        the <code>identical</code> level. </td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">backwards</td>
                     <td rowspan="1" colspan="1">yes | no (default no)</td>
                     <td rowspan="1" colspan="1">The value <code>backwards=yes</code> indicates that
                        the last accent in the search term is the most significant.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">normalization</td>
                     <td rowspan="1" colspan="1">yes | no (default no)</td>
                     <td rowspan="1" colspan="1">Indicates whether search terms are converted to
                        normalization form D.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">caseLevel</td>
                     <td rowspan="1" colspan="1">yes | no (default no)</td>
                     <td rowspan="1" colspan="1">When used with primary strength, setting
                           <code>caseLevel=yes</code> has the effect of ignoring accents while
                        taking account of case.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">caseFirst</td>
                     <td rowspan="1" colspan="1">upper | lower</td>
                     <td rowspan="1" colspan="1">Indicates whether upper-case precedes lower-case or
                        vice versa.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">numeric</td>
                     <td rowspan="1" colspan="1">yes | no (default no)</td>
                     <td rowspan="1" colspan="1">When <code>numeric=yes</code> is specified, a
                        sequence of consecutive digits is interpreted as a number, for example
                           <code>chap2</code> sorts before <code>chap12</code>.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">reorder</td>
                     <td rowspan="1" colspan="1">a comma-separated sequence of reorder codes, where
                        a reorder code is one of <code>space</code>, <code>punct</code>,
                           <code>symbol</code>, <code>currency</code>, <code>digit</code>, or a
                        four-letter script code defined in <bibref ref="ISO15924_register"/>, the
                        register of scripts maintained by the Unicode Consortium in its capacity as
                        registration authority for <bibref ref="ISO15924"/>.</td>
                     <td rowspan="1" colspan="1">Determines the relative ordering of text in
                        different scripts; for example the value <code>digit,Grek,Latn</code>
                        indicates that digits precede Greek letters, which precede Latin
                        letters.</td>
                  </tr>
               </tbody>
            </table>
            <note>
               <p>This list excludes parameters that are inconvenient to express in a URI, or that
                  are applicable only to substring matching.</p>
            </note>
         </div2>
      </div1>
      <div1 id="grouping">
         <head>Grouping</head>
         <p>The facilities described in this section are designed to allow items in a sequence to be
            grouped based on common values; for example it allows grouping of elements having the
            same value for a particular attribute, or elements with the same name, or elements with
            common values for any other <termref def="dt-expression">expression</termref>. Since
            grouping identifies items with duplicate values, the same facilities also allow
            selection of the distinct values in a sequence of items, that is, the elimination of
            duplicates.</p>
         <note>
            <p>Simple elimination of duplicates can also be achieved using the function
                  <xfunction>distinct-values</xfunction>: see <bibref ref="xpath-functions-30"
               />.</p>
         </note>
         <p>In addition these facilities allow grouping based on sequential position, for example
            selecting groups of adjacent <code>para</code> elements. The facilities also provide an
            easy way to do fixed-size grouping, for example identifying groups of three adjacent
            nodes, which is useful when arranging data in multiple columns.</p>
         <p>For each group of items identified, it is possible to evaluate a <termref
               def="dt-sequence-constructor">sequence constructor</termref> for the group. Grouping
            is nestable to multiple levels so that groups of distinct items can be identified, then
            from among the distinct groups selected, further sub-grouping of distinct items in the
            current group can be done. </p>
         <p>It is also possible for one item to participate in more than one group.</p>
         <div2 id="xsl-for-each-group">
            <head>The <code>xsl:for-each-group</code> Element</head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="for-each-group">
               <e:in-category name="instruction"/>
               <e:attribute name="select" required="yes">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="group-by" required="no">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="group-adjacent" required="no">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="group-starting-with" required="no">
                  <e:data-type name="pattern"/>
               </e:attribute>
               <e:attribute name="group-ending-with" required="no">
                  <e:data-type name="pattern"/>
               </e:attribute>
               <e:attribute name="composite">
                  <e:data-type name="boolean"/>
               </e:attribute>
               <e:attribute name="collation">
                  <e:attribute-value-template>
                     <e:data-type name="uri"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:sequence>
                  <e:element repeat="zero-or-more" name="sort"/>
                  <e:model name="sequence-constructor"/>
               </e:sequence>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>This element is an <termref def="dt-instruction">instruction</termref> that may be
               used anywhere within a <termref def="dt-sequence-constructor">sequence
                  constructor</termref>.</p>
            <p>
               <termdef id="dt-group" term="group">The <elcode>xsl:for-each-group</elcode>
                  instruction allocates the items in an input sequence into <term>groups</term> of
                  items (that is, it establishes a collection of sequences) based either on common
                  values of a grouping key, or on a <termref def="dt-pattern">pattern</termref> that
                  the initial or final <phrase diff="chg" at="C">item</phrase> in a group must
                  match.</termdef> The <termref def="dt-sequence-constructor">sequence
                  constructor</termref> that forms the content of the
                  <elcode>xsl:for-each-group</elcode> instruction is evaluated once for each of
               these groups.</p>
            <p>
               <termdef id="dt-population" term="population">The sequence of items to be grouped,
                  which is referred to as the <term>population</term>, is determined by evaluating
                  the XPath <termref def="dt-expression">expression</termref> contained in the
                     <code>select</code> attribute.</termdef>
            </p>
            <p>
               <termdef id="dt-population-order" term="population order">The population is treated
                  as a sequence; the order of items in this sequence is referred to as
                     <term>population order</term>.</termdef></p>
            <p>A group is never empty. If the population is empty, the number of groups will be
               zero.</p>
            <p>The assignment of items to groups depends on the <code>group-by</code>,
                  <code>group-adjacent</code>, <code>group-starting-with</code>, and
                  <code>group-ending-with</code> attributes. </p>
            <p>
               <error spec="XT" type="static" class="SE" code="1080"><p>These four attributes
                        <error.extra>the <code>group-by</code>, <code>group-adjacent</code>,
                           <code>group-starting-with</code>, and <code>group-ending-with</code>
                        attributes of <elcode>xsl:for-each-group</elcode>
                     </error.extra> are mutually exclusive: it is a <termref def="dt-static-error"
                        >static error</termref> if none of these four attributes is present or if
                     more than one of them is present.</p></error>
            </p>
            <p>
               <error spec="XT" type="static" class="SE" code="1090"><p>It is a <termref
                        def="dt-static-error">static error</termref> to specify the
                        <code>collation</code> attribute <phrase diff="add" at="G">or the
                           <code>composite</code> attribute</phrase> if neither the
                        <code>group-by</code> attribute nor <code>group-adjacent</code> attribute is
                     specified.</p></error>
            </p>
            <p diff="chg" at="F">
               <termdef id="dt-grouping-key" term="grouping key">If either of the
                     <code>group-by</code> or <code>group-adjacent</code> attributes is present,
                  then for each item in the <termref def="dt-population">population</termref> a set
                  of <term>grouping keys</term> is calculated, as follows: the expression contained
                  in the <code>group-by</code> or <code>group-adjacent</code> attribute is
                  evaluated; the result is atomized; and any <code>xs:untypedAtomic</code> values
                  are cast to <code>xs:string</code>. <phrase diff="chg" at="G">If
                        <code>composite="yes"</code> is specified, there is a single grouping key
                     whose value is the resulting sequence; otherwise, there is a set of grouping
                     keys, consisting of the distinct atomic values present in the result
                     sequence.</phrase></termdef>
            </p>
            <p>When calculating grouping keys for an item in the population, the <termref
                  def="dt-expression">expression</termref> contained in the <code>group-by</code> or
                  <code>group-adjacent</code> attribute is evaluated with that item as the <termref
                  def="dt-context-item">context item</termref>, with its position in <termref
                  def="dt-population-order">population order</termref> as the <termref
                  def="dt-context-position">context position</termref>, and with the size of the
               population as the <termref def="dt-context-size">context size</termref>.<phrase
                  diff="del" at="F"> The resulting sequence is <termref def="dt-atomization"
                     >atomized</termref>, and each atomic value in the atomized sequence acts as a
                     <termref def="dt-grouping-key">grouping key</termref> for that item in the
                  population.</phrase></p>
            <p>If the <code>group-by</code> attribute is present, <phrase diff="add" at="G">and if
                  the <code>composite</code> attribute is omitted or takes the value
                  <code>no</code>,</phrase> then an item in the population <rfc2119>may</rfc2119>
               have multiple grouping keys: that is, the <code>group-by</code> expression evaluates
               to a sequence<phrase diff="add" at="G">, and each item in the sequence is treated as
                  a separate grouping key. </phrase> The item is included in as many groups as there
               are distinct grouping keys (which may be zero).</p>
            <p>If the <code>group-adjacent</code> attribute is used, <phrase diff="add" at="G">and
                  if the <code>composite</code> attribute is omitted or takes the value
                     <code>no</code>,</phrase> then each item in the population
                  <rfc2119>must</rfc2119> have exactly one grouping key value.</p>
            <p>
               <error spec="XT" type="type" class="TE" code="1100" diff="chg" at="F"><p>It is a
                        <termref def="dt-type-error">type error</termref> if the result of
                     evaluating the <code>group-adjacent</code> expression is an empty sequence or a
                     sequence containing more than one item, <phrase diff="add" at="G">unless
                           <code>composite="yes"</code> is specified.</phrase></p></error>
            </p>
            <p>
               <termref def="dt-grouping-key">Grouping keys</termref> are compared using the rules
               for the <phrase diff="chg" at="G"><xfunction>deep-equal</xfunction> function. This
                  means that values of type <code>xs:untypedAtomic</code> will be cast to
                     <code>xs:string</code> before the comparison, and that items that are not
                  comparable using the <code>eq</code> operator are considered to be not equal, that
                  is, they are allocated to different groups. It also means that the value
                     <code>NaN</code> is considered equal to itself.</phrase> If the values are
               strings, or untyped atomic values, then if there is a <code>collation</code>
               attribute the values are compared using the collation specified as the <termref
                  def="dt-effective-value">effective value</termref> of the <code>collation</code>
               attribute, resolved if relative against the base URI of the
                  <elcode>xsl:for-each-group</elcode> element. If there is no <code>collation</code>
               attribute then the <termref def="dt-default-collation">default collation</termref> is
               used.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="1110"><p>It is a <termref
                        def="dt-dynamic-error"><phrase diff="del" at="M">non-recoverable</phrase>
                        dynamic error</termref> if the collation URI specified to
                        <elcode>xsl:for-each-group</elcode> (after resolving against the base URI)
                     is a collation that is not recognized by the implementation. (For notes,
                        <errorref class="DE" code="1035"/>.)</p></error>
            </p>
            <p>For more information on collations, see <specref ref="collating-sequences"/>.</p>
            <p diff="del" at="C">
               <error spec="XT" type="type" class="TE" code="1120"><p>When the
                        <code>group-starting-with</code> or <code>group-ending-with</code> attribute
                        <error.extra>of the <elcode>xsl:for-each-group</elcode>
                        instruction</error.extra> is used, it is a <termref def="dt-type-error">type
                        error</termref> if the result of evaluating the <code>select</code>
                     expression contains an item that is not a node.</p></error>
            </p>
            <p diff="add" at="F">The way in which an <elcode>xsl:for-each-group</elcode> element is
               evaluated depends on which of the four group-defining attributes is present:</p>
            <ulist>
               <item>
                  <p>If the <code>group-by</code> attribute is present, the items in the <termref
                        def="dt-population">population</termref> are examined, in population order.
                     For each item <var>J</var>, the expression in the <code>group-by</code>
                     attribute is evaluated to produce a sequence of zero or more <termref
                        def="dt-grouping-key">grouping key</termref> values. <phrase diff="add"
                        at="G">If <code>composite="yes"</code> is specified, there will be a single
                        grouping key, which will in general be a sequence of zero or more atomic
                        values; otherwise, there will be zero or more grouping keys, each of which
                        will be a single atomic value.</phrase> For each one of these <termref
                        def="dt-grouping-key">grouping keys</termref>, if there is already a group
                     created to hold items having that grouping key value, <var>J</var> is <phrase
                        diff="chg" at="D">appended</phrase> to that group; otherwise a new group is
                     created for items with that grouping key value, and <var>J</var> becomes its
                     first member.</p>
                  <p>An item in the population may thus be <phrase diff="chg" at="D"
                        >appended</phrase> to zero, one, or many groups. An item will never be
                        <phrase diff="chg" at="D">appended</phrase> more than once to the same
                     group; if two or more grouping keys for the same item are equal, then the
                     duplicates are ignored. An <emph>item</emph> here means the item at a
                     particular position within the population—if the population contains the same
                     node at several different positions in the sequence then a group may indeed
                     contain duplicate nodes.</p>
                  <p>The number of groups will be the same as the number of distinct grouping key
                     values present in the <termref def="dt-population">population</termref>. </p>
                  <p>If the population contains values of different numeric types that differ from
                     each other by small amounts, then the <code>eq</code> operator is not
                     transitive, because of rounding effects occurring during type promotion. The
                     effect of this is described in <specref ref="non-transitivity"/>.</p>
               </item>
               <item>
                  <p>If the <code>group-adjacent</code> attribute is present, the items in the
                        <termref def="dt-population">population</termref> are examined, in
                     population order. If an item has the same value for the <termref
                        def="dt-grouping-key">grouping key</termref> as its preceding item within
                     the <termref def="dt-population">population</termref> (in <termref
                        def="dt-population-order">population order</termref>), then it is <phrase
                        diff="chg" at="D">appended</phrase> to the same group as its preceding item;
                     otherwise a new group is created and the item becomes its first member.</p>
               </item>
               <item>
                  <p>If the <code>group-starting-with</code> attribute is present, then its value
                        <rfc2119>must</rfc2119> be a <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                        def="doc-xslt30-patterns-Pattern30" xlink:type="simple">pattern</nt>.
                        <phrase diff="del" at="C">In this case, the items in the population
                           <rfc2119>must</rfc2119> all be nodes.</phrase></p>
                  <p>The <phrase diff="chg" at="C">items</phrase> in the <termref
                        def="dt-population">population</termref> are examined in <termref
                        def="dt-population-order">population order</termref>. If an <phrase
                        diff="chg" at="C">item</phrase> matches the pattern, or is the first <phrase
                        diff="chg" at="C">item</phrase> in the population, then a new group is
                     created and the <phrase diff="chg" at="C">item</phrase> becomes its first
                     member. Otherwise, the <phrase diff="chg" at="C">item</phrase> is <phrase
                        diff="chg" at="D">appended</phrase> to the same group as its preceding
                        <phrase diff="chg" at="C">item</phrase> within the population.</p>
               </item>
               <item>
                  <p>If the <code>group-ending-with</code> attribute is present, then its value
                        <rfc2119>must</rfc2119> be a <nt xmlns:xlink="http://www.w3.org/1999/xlink"
                        def="doc-xslt30-patterns-Pattern30" xlink:type="simple">pattern</nt>.
                        <phrase diff="del" at="C">In this case, the items in the population
                           <rfc2119>must</rfc2119> all be nodes.</phrase></p>
                  <p>The <phrase diff="chg" at="C">items</phrase> in the <termref
                        def="dt-population">population</termref> are examined in <termref
                        def="dt-population-order">population order</termref>. If an <phrase
                        diff="chg" at="C">item</phrase> is the first <phrase diff="chg" at="C"
                        >item</phrase> in the population, or if the previous <phrase diff="chg"
                        at="C">item</phrase> in the population matches the pattern, then a new group
                     is created and the <phrase diff="chg" at="C">item</phrase> becomes its first
                     member. Otherwise, the <phrase diff="chg" at="C">item</phrase> is <phrase
                        diff="chg" at="D">appended</phrase> to the same group as its preceding
                        <phrase diff="chg" at="C">item</phrase> within the population.</p>
               </item>
            </ulist>
            <p diff="add" at="D">In all cases the order of items within each group is predictable,
               and reflects the original <termref def="dt-population-order">population
                  order</termref>, in that the items are processed in population order and each item
               is appended at the end of zero or more groups.</p>
            <note diff="add" at="D">
               <p>As always, a different algorithm may be used if it achieves the same effect.</p>
            </note>
            <p>
               <termdef id="dt-initial-item" term="initial item">For each <termref def="dt-group"
                     >group</termref>, the item within the group that is first in <termref
                     def="dt-population-order">population order</termref> is known as the
                     <term>initial item</term> of the group.</termdef>
            </p>
            <p>The <termref def="dt-sequence-constructor"/> contained in the
                  <elcode>xsl:for-each-group</elcode> element is evaluated once for each of the
                  <termref def="dt-group">groups</termref>, in <termref def="dt-processing-order"
                  >processing order</termref>. The sequences that result are concatenated, in
                  <termref def="dt-processing-order">processing order</termref>, to form the result
               of the <elcode>xsl:for-each-group</elcode> element. Within the <termref
                  def="dt-sequence-constructor">sequence constructor</termref>, the <termref
                  def="dt-context-item">context item</termref> is the <termref def="dt-initial-item"
                  >initial item</termref> of the relevant group, the <termref
                  def="dt-context-position">context position</termref> is the position of this
                  <phrase diff="chg" at="F">group in the <termref def="dt-processing-order"
                     >processing order</termref> of the groups</phrase>, and the <termref
                  def="dt-context-size">context size</termref> is the number of groups<phrase
                  diff="del" at="K">, the <termref def="dt-current-group">current group</termref> is
                  the <termref def="dt-group">group</termref> being processed, and the <termref
                     def="dt-current-grouping-key">current grouping key</termref> is the grouping
                  key for that group. If the <elcode>xsl:for-each-group</elcode> instruction uses
                  the <code>group-starting-with</code> or <code>group-ending-with</code> attributes,
                  then the current grouping key is the empty sequence.</phrase> This has the effect
               that within the <termref def="dt-sequence-constructor"/>, a call on
                  <code>position()</code> takes successive values <code>1, 2, ... last()</code>.</p>
         </div2>
         <div2 id="information-about-group" diff="add" at="K">
            <head>Accessing Information about the Current Group Value</head>
            <p>Two pieces of information are available during the processing of each group (that is,
               while evaluating the sequence constructor contained in the
                  <elcode>xsl:for-each-group</elcode> instruction, and also while evaluating the
               sort key of a group as expressed by the <code>select</code> attribute or sequence
               constructor of an <elcode>xsl:sort</elcode> child of the
                  <elcode>xsl:for-each-group</elcode> element):</p>
            <ulist diff="chg" at="R-bug24510">
               <item>
                  <p><termdef id="dt-current-group" term="current group">The <term>current
                           group</term> is the <termref def="dt-group">group</termref> itself, as a
                        sequence of items</termdef>.</p>
               </item>
               <item>
                  <p><termdef id="dt-current-grouping-key" term="current grouping key">The
                           <term>current grouping key</term> is a single atomic value, or in the
                        case of a composite key, a sequence of atomic values, containing the
                           <termref def="dt-grouping-key"/> of the items in the <termref
                           def="dt-current-group"/>.</termdef></p>
               </item>
            </ulist>
            <p diff="del" at="R-bug24510">There are two ways of getting this information. The
               preferred way in XSLT 3.0 is to bind variables using the <code>bind-group</code> and
                  <code>bind-grouping-key</code> attributes of the
                  <elcode>xsl:for-each-group</elcode> instruction.</p>
            <p diff="del" at="R-bug24510">If the <code>bind-group</code> attribute is present, then
               its value must be an <termref def="dt-eqname">EQName</termref>, and this causes a
               local variable binding for this name to be visible within the sequence constructor
               forming the body of the <elcode>xsl:for-each-group</elcode> instruction, and also
               within any <elcode>xsl:sort</elcode> element child of the
                  <elcode>xsl:for-each-group</elcode> element. The type of the variable is
                  <code>item()*</code> (any sequence of items), and its value is the content of the
                  <termref def="dt-current-group"/>.</p>
            <p diff="del" at="R-bug24510">If the <code>bind-grouping-key</code> attribute is
               present, then its value must be a <termref def="dt-eqname">EQName</termref>, and this
               causes a local variable binding for this name to be present within the sequence
               constructor forming the body of the <elcode>xsl:for-each-group</elcode> instruction
               and also within any <elcode>xsl:sort</elcode> element child of the
                  <elcode>xsl:for-each-group</elcode> element. The type of the variable is
                  <code>anyAtomicType*</code> (any sequence of atomic values), and its value is the
                  <termref def="dt-current-grouping-key"/>, that is the <termref
                  def="dt-grouping-key"/> of the <termref def="dt-group">group</termref> being
               processed.</p>
            <p diff="del" at="R-bug24510">If the variable names bound in the <code>bind-group</code>
               or <code>bind-grouping-key</code> attributes are used in the <code>select</code>
               attribute or the sequence constructor within an <elcode>xsl:sort</elcode> child of
               the <elcode>xsl:for-each-group</elcode> instruction, then they act as references to
               the group whose sort key is being computed, or the grouping key of that group,
               respectively.</p>
            <p diff="del" at="R-bug24510">Except as noted below, the variable bindings established
               by the <code>bind-group</code> and <code>bind-grouping-key</code> attributes, when
               present, are visible within all descendant elements of the
                  <elcode>xsl:for-each-group</elcode> instruction on which they are declared, other
               than elements where the variable binding is <termref def="dt-shadows"
                  >shadowed</termref> by another variable binding. For more information see <specref
                  ref="scope-of-variables"/>.</p>
            <p diff="del" at="R-bug24510"> [XTSE3220] It is a <termref def="dt-static-error">static
                  error</termref> if a variable bound in the <code>bind-group</code> or
                  <code>bind-grouping-key</code> attribute of an <elcode>xsl:for-each-group</elcode>
               instruction is referenced within an expression in the <code>lang</code>,
                  <code>order</code>, <code>collation</code>, <code>stable</code>,
                  <code>case-order</code>, or <code>data-type</code> attributes of an
                  <elcode>xsl:sort</elcode> child of that <elcode>xsl:for-each-group</elcode>
               instruction. </p>
            <p diff="del" at="R-bug24510">[XTSE3230] It is a <termref def="dt-static-error"/> if the
                  <code>bind-grouping-key</code> attribute is present on an
                  <elcode>xsl:for-each-group</elcode> instruction unless either the
                  <code>group-by</code> or <code>group-adjacent</code> attribute is present.</p>
            <p diff="del" at="R-bug24510">For backwards compatibility, XSLT 3.0 also allows
               information about the <termref def="dt-current-group"/> and the <termref
                  def="dt-current-grouping-key"/> to be held in the dynamic context, and obtained
               therefrom using the <function>current-group</function> and
                  <function>current-grouping-key</function> functions respectively. The difference
               between using bound variables and using these functions is that the variables have
               static scope (they can only be used lexically within the
                  <elcode>xsl:for-each-group</elcode> element), whereas the functions have dynamic
               scope (they are available in called templates — though not in called functions — as
               well as within the lexical body of <elcode>xsl:for-each-group</elcode>). The fact
               that the functions have dynamic scope makes certain optimizations difficult, and in
               particular it makes it impossible to satisfy the rules for streamability. When
               streamed processing is required, therefore, it is necessary to bind variables to the
               group and grouping key rather than using the <function>current-group</function> and
                  <function>current-grouping-key</function> functions.</p>
            <p diff="add" at="R-bug24510">Information about the <termref def="dt-current-group"/>
               and the <termref def="dt-current-grouping-key"/> is held in the dynamic context, and
               is available using the <function>current-group</function> and
                  <function>current-grouping-key</function> functions respectively.</p>
            <p diff="add" at="R-bug24510">In XSLT 2.0, the <termref def="dt-current-group"/> and the
                  <termref def="dt-current-grouping-key"/> were passed unchanged through calls of
                  <elcode>xsl:apply-templates</elcode> and <elcode>xsl:call-template</elcode>, and
               also <elcode>xsl:apply-imports</elcode> and <elcode>xsl:next-match</elcode>. This
               behavior is retained in XSLT 3.0 except in the case where streaming is in use:
               specifically, if the <elcode>xsl:apply-templates</elcode>,
                  <elcode>xsl:call-template</elcode>, <elcode>xsl:apply-imports</elcode>, or
                  <elcode>xsl:next-match</elcode> instruction occurs within a <termref
                  def="dt-declared-streamable"/> construct (typically, within an
                  <elcode>xsl:source-document</elcode> instruction, or within a streamable <termref
                  def="dt-template-rule"/>), then the current group and current grouping key are set
               to <termref def="dt-absent"/> in the called template. The reason for this is to allow
               the streamability of an <elcode>xsl:for-each-group</elcode> instruction to be
               assessed statically, as described in <specref ref="streamability-xsl-for-each-group"
               />.</p>
            <note diff="del" at="R-bug24510">
               <p>The terms current group value and current grouping key value refer to the group
                  and grouping key being processed, regardless whether these are bound to variables
                  or held in the dynamic context. The terms <termref def="dt-current-group"/> and
                     <termref def="dt-current-grouping-key"/> refer to the values held in the
                  dynamic context, which are set to hold the current group value and current
                  grouping key value only when these values have not been bound to variables.</p>
            </note>
            <p diff="del" at="R-bug24510">An added benefit of using the <code>bind-group</code> and
                  <code>bind-grouping-key</code> variables is apparent when
                  <elcode>xsl:for-each-group</elcode> elements are nested: the grouping variables
               for the outer instruction remain in scope when processing the inner instruction.</p>
            <p diff="del" at="R-bug24510">If the <code>bind-group</code> attribute is present on the
                  <elcode>xsl:for-each-group</elcode> instruction, then the <termref
                  def="dt-current-group">current group</termref> (the value accessed by the
                  <function>current-group</function> function) is set to <termref def="dt-absent"
                  >absent</termref> during the processing of the instruction, which has the effect
               that any call on <function>current-group</function> results in a dynamic error.</p>
            <p diff="del" at="R-bug24510">If the <code>bind-grouping-key</code> attribute is present
               on the <elcode>xsl:for-each-group</elcode> instruction, or if neither the
                  <code>group-by</code> nor <code>group-adjacent</code> attribute is present, then
               the <termref def="dt-current-grouping-key">current grouping key</termref> (the value
               accessed by the <function>current-grouping-key</function> function) is set to
                  <termref def="dt-absent">absent</termref> during the processing of the
               instruction, which has the effect that any call on
                  <function>current-grouping-key</function> results in a dynamic error.</p>
            <div3 id="func-current-group">
               <head>fn:current-group</head>
               <glist>
                  <gitem>
                     <label>Summary</label>
                     <def>
                        <p>Returns the group currently being processed by an
                              <elcode>xsl:for-each-group</elcode>
                           <phrase diff="del" at="K">or <elcode>xsl:merge</elcode></phrase>
                           instruction.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Signature</label>
                     <def>
                        <example role="signature">
                           <proto name="current-group" return-type="item()*" isOp="no" prefix="fn"
                              returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no"
                              isDatatype="no" isSpecial="no"/>
                        </example>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Properties</label>
                     <def>
                        <p>This function is <xtermref spec="FO30" ref="dt-deterministic"
                              >deterministic</xtermref>, <xtermref spec="FO30"
                              ref="dt-context-dependent">context-dependent</xtermref>, and <xtermref
                              spec="FO30" ref="dt-focus-independent">focus-independent</xtermref>.
                        </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Rules</label>
                     <def>
                        <p> The evaluation context for XPath <termref def="dt-expression"
                              >expressions</termref> includes a component called the <termref
                              def="dt-current-group">current group</termref>, which is a sequence. </p>
                        <p diff="add" at="C">The function <function>current-group</function> returns
                           the sequence of items making up the current group.</p>
                        <p diff="add" at="C">The current group is bound during evaluation of the
                              <elcode>xsl:for-each-group</elcode> instruction. If no
                              <elcode>xsl:for-each-group</elcode> instruction is being evaluated,
                           the current group will be <termref def="dt-absent"/>: that is, any
                           reference to it will cause a dynamic error.</p>
                        <p diff="add" at="R-bug24150">The effect of <termref
                              def="dt-invocation-construct">invocation constructs</termref> on the
                              <termref def="dt-current-group"/> is as follows:</p>
                        <ulist diff="add" at="R-bug24150">
                           <item>
                              <p>If the <termref def="dt-invocation-construct"/> is contained within
                                 a <termref def="dt-declared-streamable"/>
                                 <termref def="dt-construct"/> (for example, if it is within an
                                    <elcode>xsl:source-document</elcode> instruction with the
                                 attribute <code>streamable="yes"</code>, or within a streamable
                                 template), then the invocation construct sets the current group to
                                    <termref def="dt-absent"/>. In this situation the scope of the
                                 current group is effectively static; it can only be referenced
                                 within the body of the <elcode>xsl:for-each-group</elcode>
                                 instruction to which it applies.</p>
                           </item>
                           <item>
                              <p>If the <termref def="dt-invocation-construct"/> is a (static or
                                 dynamic) function call, then the invocation construct sets the
                                 current group to <termref def="dt-absent"/>.</p>
                           </item>
                           <item>
                              <p>Otherwise the <termref def="dt-invocation-construct"/> leaves the
                                 current group unchanged. In this situation the scope of the current
                                 group is effectively dynamic: it can be referenced within called
                                 templates and attribute sets.</p>
                           </item>
                        </ulist>
                        <p diff="chg" at="R-bug24150">The current group is initially <termref
                              def="dt-absent"/> during the evaluation of global variables and
                           stylesheet parameters, during the evaluation of the <code>use</code>
                           attribute or contained sequence constructor of <elcode>xsl:key</elcode>,
                           and during the evaluation of the <code>initial-value</code> attribute of
                              <elcode>xsl:accumulator</elcode> and the <code>select</code> attribute
                           of contained sequence constructor of
                              <elcode>xsl:accumulator-rule</elcode>.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Error Conditions</label>
                     <def>
                        <p>
                           <error spec="XT" type="static" class="SE" code="1060"><p>It is a <termref
                                    def="dt-static-error">static error</termref> if the
                                    <function>current-group</function> function is used within a
                                    <termref def="dt-pattern">pattern</termref>.</p></error>
                        </p>
                        <p diff="add" at="K">
                           <error spec="XT" type="dynamic" class="DE" code="1061"><p>It is a
                                    <termref def="dt-dynamic-error">dynamic error</termref> if the
                                    <function>current-group</function> function is used when the
                                 current group is <termref def="dt-absent">absent</termref>
                                 <phrase diff="add" at="N">, or when it is invoked in the course of
                                    evaluating a pattern</phrase>. The error <rfc2119>may</rfc2119>
                                 be reported statically if it can be detected
                              statically.</p></error>
                        </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Notes</label>
                     <def>
                        <p role="note">Like other XSLT extensions to the dynamic evaluation context,
                           the <termref def="dt-current-group"/> is not retained as part of the
                           closure of a function value. This means that the expression
                              <code>current-group#0</code> is valid and returns a function value,
                           but any invocation of this function will fail with a dynamic error
                              <errorref spec="XT" class="DE" code="1061"/>. </p>
                     </def>
                  </gitem>
               </glist>
            </div3>
            <div3 id="func-current-grouping-key">
               <head>fn:current-grouping-key</head>
               <glist>
                  <gitem>
                     <label>Summary</label>
                     <def>
                        <p>Returns the grouping key of the group currently being processed using the
                              <elcode>xsl:for-each-group</elcode>
                           <phrase diff="del" at="K">or <elcode>xsl:merge</elcode></phrase>
                           instruction.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Signature</label>
                     <def>
                        <example role="signature">
                           <proto name="current-grouping-key" return-type="xs:anyAtomicType*"
                              isOp="no" prefix="fn" returnEmptyOk="no" returnSeq="no"
                              returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no"/>
                        </example>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Properties</label>
                     <def>
                        <p>This function is <xtermref spec="FO30" ref="dt-deterministic"
                              >deterministic</xtermref>, <xtermref spec="FO30"
                              ref="dt-context-dependent">context-dependent</xtermref>, and <xtermref
                              spec="FO30" ref="dt-focus-independent">focus-independent</xtermref>.
                        </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Rules</label>
                     <def>
                        <p> The evaluation context for XPath <termref def="dt-expression"
                              >expressions</termref> includes a component called the <termref
                              def="dt-current-grouping-key">current grouping key</termref>, which is
                              <phrase diff="chg" at="C">a sequence of atomic values</phrase>. The
                           current grouping key is the <termref def="dt-grouping-key">grouping
                              key</termref> shared in common by all the items within the <termref
                              def="dt-current-group">current group</termref>. </p>
                        <p>The function <function>current-grouping-key</function> returns the
                              <termref def="dt-current-grouping-key">current grouping
                           key</termref>.</p>
                        <p diff="add" at="C">The current grouping key is bound during evaluation of
                           an <elcode>xsl:for-each-group</elcode> instruction that has a
                              <code>group-by</code> or <code>group-adjacent</code> attribute<phrase
                              diff="del" at="K"> and during evaluation of the
                                 <elcode>xsl:merge</elcode> instruction</phrase>. If <phrase>no
                                 <elcode>xsl:for-each-group</elcode> instruction is being evaluated,
                              the current grouping key will be <termref def="dt-absent"/>, which
                              means that any reference to it causes a dynamic error. The current
                              grouping key is also set to <termref def="dt-absent"/> during the
                              evaluation of an <elcode>xsl:for-each-group</elcode> instruction with
                              a <code>group-starting-with</code> or <code>group-ending-with</code>
                              attribute</phrase>.</p>
                        <p diff="add" at="R-bug24150">The effect of <termref
                              def="dt-invocation-construct">invocation constructs</termref> on the
                              <termref def="dt-current-grouping-key"/> is as follows:</p>
                        <ulist diff="add" at="R-bug24150">
                           <item>
                              <p>If the <termref def="dt-invocation-construct"/> is contained within
                                 a <termref def="dt-declared-streamable"/>
                                 <termref def="dt-construct"/> (for example, if it is within an
                                    <elcode>xsl:source-document</elcode> instruction with the
                                 attribute <code>streamable="yes"</code>, or within a streamable
                                 template), then the invocation construct sets the current grouping
                                 key to <termref def="dt-absent"/>. In this situation the scope of
                                 the current group is effectively static; it can only be referenced
                                 within the body of the <elcode>xsl:for-each-group</elcode>
                                 instruction to which it applies.</p>
                           </item>
                           <item>
                              <p>If the <termref def="dt-invocation-construct"/> is a (static or
                                 dynamic) function call, then the invocation construct sets the
                                 current grouping key to <termref def="dt-absent"/>.</p>
                           </item>
                           <item>
                              <p>Otherwise the <termref def="dt-invocation-construct"/> leaves the
                                 current grouping key unchanged. In this situation the scope of the
                                 current group is effectively dynamic: it can be referenced within
                                 called templates and attribute sets.</p>
                           </item>
                        </ulist>
                        <p diff="chg" at="R-bug24150">The current grouping key is initially <termref
                              def="dt-absent"/> during the evaluation of global variables and
                           stylesheet parameters, during the evaluation of the <code>use</code>
                           attribute or contained sequence constructor of <elcode>xsl:key</elcode>,
                           and during the evaluation of the <code>initial-value</code> attribute of
                              <elcode>xsl:accumulator</elcode> and the <code>select</code> attribute
                           of contained sequence constructor of
                              <elcode>xsl:accumulator-rule</elcode>.</p>
                        <p>While an <elcode>xsl:for-each-group</elcode> instruction with a
                              <code>group-by</code> or <code>group-adjacent</code> attribute is
                           being evaluated, the <termref def="dt-current-grouping-key">current
                              grouping key</termref> will be a single atomic value <phrase
                              diff="add" at="G">if <code>composite="no"</code> is specified
                              (explicitly or implicitly), or a sequence of atomic values if
                                 <code>composite="yes"</code> is specified.</phrase>
                        </p>
                        <p diff="del" at="K">While the <elcode>xsl:merge-action</elcode> part of an
                              <elcode>xsl:merge</elcode> instruction is being evaluated, the current
                           grouping key will be a sequence of atomic values, one for each component
                           of the grouping key, as defined by the <elcode>xsl:merge-key</elcode>
                           elements.</p>
                        <p>At other times, the current grouping key will be <termref def="dt-absent"
                              >absent</termref>.</p>
                        <p><phrase diff="chg" at="D">The <termref def="dt-grouping-key">grouping
                                 keys</termref> of all items in a group are not necessarily
                              identical. For example, one might be an <code>xs:float</code> while
                              another is a numerically equal <code>xs:decimal</code></phrase>. The
                              <function>current-grouping-key</function> function <phrase diff="chg"
                              at="F">returns</phrase> the grouping key of the <termref
                              def="dt-initial-item">initial item</termref> in the group, after
                           atomization and casting of <code>xs:untypedAtomic</code> values to
                              <code>xs:string</code>.</p>
                        <p>The function takes no arguments.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Error Conditions</label>
                     <def>
                        <p>
                           <error spec="XT" type="static" class="SE" code="1070"><p>It is a <termref
                                    def="dt-static-error">static error</termref> if the
                                    <function>current-grouping-key</function> function is used
                                 within a <termref def="dt-pattern">pattern</termref>.</p></error>
                        </p>
                        <p diff="add" at="K">
                           <error spec="XT" type="dynamic" class="DE" code="1071"><p>It is a
                                    <termref def="dt-dynamic-error">dynamic error</termref> if the
                                    <function>current-grouping-key</function> function is used when
                                 the current grouping key is <termref def="dt-absent"
                                    >absent</termref>, <phrase diff="add" at="N">or when it is
                                    invoked in the course of evaluating a pattern.</phrase> The
                                 error <rfc2119>may</rfc2119> be reported statically if it can be
                                 detected statically.</p></error>
                        </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Notes</label>
                     <def>
                        <p role="note">Like other XSLT extensions to the dynamic evaluation context,
                           the <termref def="dt-current-grouping-key"/> is not retained as part of
                           the closure of a function value. This means that the expression
                              <code>current-grouping-key#0</code> is valid and returns a function
                           value, but any invocation of this function will fail with a dynamic error
                              <errorref spec="XT" class="DE" code="1071"/>. </p>
                     </def>
                  </gitem>
               </glist>
            </div3>
         </div2>
         <div2 id="order-of-groups">
            <head>Ordering among Groups</head>
            <p>
               <termdef id="dt-first-appearance" term="order of first appearance">There is a <phrase
                     diff="add" at="F">total</phrase> ordering among <termref def="dt-group"
                     >groups</termref> referred to as the <term>order of first appearance</term>. A
                  group <var>G</var> is defined to precede a group <var>H</var> in order of first
                  appearance if the <termref def="dt-initial-item">initial item</termref> of
                     <var>G</var> precedes the initial item of <var>H</var> in population order. If
                  two groups <var>G</var> and <var>H</var> have the same initial item (because the
                  item is in both groups) then <var>G</var> precedes <var>H</var> if the <termref
                     def="dt-grouping-key">grouping key</termref> of <var>G</var> precedes the
                  grouping key of <var>H</var> in the sequence that results from evaluating the
                     <code>group-by</code> expression of this initial item.</termdef>
            </p>
            <p>
               <termdef id="dt-processing-order" term="processing order">There is another <phrase
                     diff="add" at="F">total</phrase> ordering among groups referred to as
                     <term>processing order</term>. If group <var>R</var> precedes group
                     <var>S</var> in processing order, then in the result sequence returned by the
                     <elcode>xsl:for-each-group</elcode> instruction the items generated by
                  processing group <var>R</var> will precede the items generated by processing group
                     <var>S</var>.</termdef>
            </p>
            <p>If there are no <elcode>xsl:sort</elcode> elements immediately within the
                  <elcode>xsl:for-each-group</elcode> element, the <termref
                  def="dt-processing-order">processing order</termref> of the <termref
                  def="dt-group">groups</termref> is the <termref def="dt-first-appearance">order of
                  first appearance</termref>.</p>
            <p>Otherwise, the <elcode>xsl:sort</elcode> elements immediately within the
                  <elcode>xsl:for-each-group</elcode> element define the processing order of the
                  <termref def="dt-group">groups</termref> (see <specref ref="sorting"/>). They do
               not affect the order of items within each group. Multiple <termref
                  def="dt-sort-key-component">sort key components</termref> are allowed, and are
               evaluated in major-to-minor order. If two groups have the same values for all their
               sort key components, they are processed in <termref def="dt-first-appearance"/> if
               the <termref def="dt-sort-key-specification">sort key specification</termref> is
                  <termref def="dt-stable">stable</termref>, otherwise in an <termref
                  def="dt-implementation-dependent">implementation-dependent</termref> order.</p>
            <p>The <code>select</code>
               <termref def="dt-expression">expression</termref> of an <elcode>xsl:sort</elcode>
               element is evaluated once for each <termref def="dt-group">group</termref>. During
               this evaluation, the <termref def="dt-context-item">context item</termref> is the
                  <termref def="dt-initial-item">initial item</termref> of the group, the <termref
                  def="dt-context-position">context position</termref> is the position of this item
               within the set of initial items (that is, one item for each group in the <termref
                  def="dt-population">population</termref>) in <termref def="dt-population-order"
                  >population order</termref>, the <termref def="dt-context-size">context
                  size</termref> is the number of groups, the <termref def="dt-current-group"/> is
               the group whose <termref def="dt-sort-key-value">sort key value</termref> is being
               determined, and the <termref def="dt-current-grouping-key"/> is the grouping key for
               that group. If the <elcode>xsl:for-each-group</elcode> instruction uses the
                  <code>group-starting-with</code> or <code>group-ending-with</code> attributes,
               then the <termref def="dt-current-grouping-key"/> is <phrase diff="chg"
                  at="R-bug24510"><termref def="dt-absent"/></phrase>.</p>
            <example>
               <head>Sorting Groups</head>
               <p>For example, this means that if the <termref def="dt-grouping-key">grouping
                     key</termref> is <code>@category</code>, you can sort the groups in order of
                  their grouping key by writing <code>&lt;xsl:sort
                     select="current-grouping-key()"/&gt;</code>; or you can sort the groups in
                  order of size by writing <code>&lt;xsl:sort
                     select="count(current-group())"/&gt;</code>
               </p>
            </example>
         </div2>
         <div2 id="grouping-examples">
            <head>Examples of Grouping</head>
            <p diff="del" at="R-bug24510">These examples all use the <code>bind-group</code> and
                  <code>bind-grouping-key</code> attributes introduced in XSLT 3.0. For equivalent
               examples using the <function>current-group</function> and
                  <function>current-grouping-key</function> functions, see the XSLT 2.0
               specification.</p>
            <example>
               <head>Grouping Nodes based on Common Values</head>
               <p>The following example groups a list of nodes based on common values. The resulting
                  groups are numbered <phrase diff="chg" at="R-bug8398">and sorted</phrase>, and a
                  total is calculated for each group. </p>
               <p>Source XML document:</p>
               <eg xml:space="preserve" role="xml">&lt;cities&gt;
  &lt;city name="Milano"  country="Italia"      pop="5"/&gt;
  &lt;city name="Paris"   country="France"      pop="7"/&gt;
  &lt;city name="München" country="Deutschland" pop="4"/&gt;
  &lt;city name="Lyon"    country="France"      pop="2"/&gt;
  &lt;city name="Venezia" country="Italia"      pop="1"/&gt;
&lt;/cities&gt;</eg>
               <p>More specifically, the aim is to produce a four-column table, containing one row
                  for each distinct country. The four columns are to contain first, a sequence
                  number giving the number of the row; second, the name of the country, third, a
                  comma-separated alphabetical list of the city names within that country, and
                  fourth, the sum of the <code>pop</code> attribute for the cities in that
                  country.</p>
               <p>Desired output:</p>
               <eg xml:space="preserve" role="xml">&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Position&lt;/th&gt;
    &lt;th&gt;Country&lt;/th&gt;
    &lt;th&gt;List of Cities&lt;/th&gt;
    &lt;th&gt;Population&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;1&lt;/td&gt;
    &lt;td&gt;Italia&lt;/td&gt;
    &lt;td&gt;Milano, Venezia&lt;/td&gt;
    &lt;td&gt;6&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;2&lt;/td&gt;
    &lt;td&gt;France&lt;/td&gt;
    &lt;td&gt;Lyon, Paris&lt;/td&gt;
    &lt;td&gt;9&lt;/td&gt;
  &lt;/tr&gt;  
  &lt;tr&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;Deutschland&lt;/td&gt;
    &lt;td&gt;München&lt;/td&gt;
    &lt;td&gt;4&lt;/td&gt;
  &lt;/tr&gt;  
&lt;/table&gt;</eg>
               <p>Solution:</p>
               <eg xml:space="preserve" diff="chg" at="R-bug8398" role="xml">&lt;table xsl:version="3.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;tr&gt;
    &lt;th&gt;Position&lt;/th&gt;
    &lt;th&gt;Country&lt;/th&gt;
    &lt;th&gt;City List&lt;/th&gt;
    &lt;th&gt;Population&lt;/th&gt;
  &lt;/tr&gt;
  &lt;xsl:for-each-group select="cities/city" group-by="@country"&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;xsl:value-of select="position()"/&gt;&lt;/td&gt;
      &lt;td&gt;&lt;xsl:value-of select="current-grouping-key()"/&gt;&lt;/td&gt;
      &lt;td&gt;
        &lt;xsl:for-each select="current-group()/@name"&gt;
          &lt;xsl:sort select="."/&gt;
          &lt;xsl:if test="position() ne 1"&gt;, &lt;/xsl:if&gt;
          &lt;xsl:value-of select="."/&gt;
        &lt;/xsl:for-each&gt;  
      &lt;/td&gt;
      &lt;td&gt;&lt;xsl:value-of select="sum(current-group()/@pop)"/&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/table&gt;</eg>
            </example>
            <example diff="chg" at="K">
               <head>A Composite Grouping Key</head>
               <p>Sometimes it is necessary to use a composite grouping key: for example, suppose
                  the source document is similar to the one used in the previous examples, but
                  allows multiple entries for the same country and city, such as:</p>
               <eg xml:space="preserve" role="xml">&lt;cities&gt;
  &lt;city name="Milano"  country="Italia"  year="1950"   pop="5.23"/&gt;
  &lt;city name="Milano"  country="Italia"  year="1960"   pop="5.29"/&gt;  
  &lt;city name="Padova"  country="Italia"  year="1950"   pop="0.69"/&gt;
  &lt;city name="Padova"  country="Italia"  year="1960"   pop="0.93"/&gt;    
  &lt;city name="Paris"   country="France"  year="1951"   pop="7.2"/&gt;
  &lt;city name="Paris"   country="France"  year="1961"   pop="7.6"/&gt;
&lt;/cities&gt;</eg>
               <p>Now suppose we want to list the average value of <code>@pop</code> for each
                  (country, name) combination. One way to handle this is to concatenate the parts of
                  the key, for example <code>&lt;xsl:for-each-group select="concat(@country, '/',
                     @name)"&gt;</code>. A second solution is to nest one
                     <elcode>xsl:for-each-group</elcode> element directly inside another. XSLT 3.0
                  introduces a third option, which is to define the grouping key as composite:</p>
               <eg xml:space="preserve" diff="chg" at="R-bug24510" role="xslt-instruction">
&lt;xsl:for-each-group select="cities/city" 
                    group-by="@name, @country" 
                    composite="yes"&gt;
  &lt;p&gt;
    &lt;xsl:value-of select="current-grouping-key()[1] || ', ' ||
                          current-grouping-key()[2] || ': ' || 
                          avg(current-group()/@pop)"/&gt;
  &lt;/p&gt;
&lt;/xsl:for-each-group&gt;</eg>
               <note>
                  <p>The string concatenation operator <code>||</code> is new in XPath 3.0.</p>
               </note>
            </example>
            <example>
               <head>Identifying a Group by its Initial Element</head>
               <p>The next example identifies a group not by the presence of a common value, but
                  rather by adjacency in document order. A group consists of an <code>h2</code>
                  element, followed by all the <code>p</code> elements up to the next
                     <code>h2</code> element.</p>
               <p>Source XML document:</p>
               <eg xml:space="preserve" role="xml">&lt;body&gt;
  &lt;h2&gt;Introduction&lt;/h2&gt;
  &lt;p&gt;XSLT is used to write stylesheets.&lt;/p&gt;
  &lt;p&gt;XQuery is used to query XML databases.&lt;/p&gt;
  &lt;h2&gt;What is a stylesheet?&lt;/h2&gt;
  &lt;p&gt;A stylesheet is an XML document used to define a transformation.&lt;/p&gt;
  &lt;p&gt;Stylesheets may be written in XSLT.&lt;/p&gt;
  &lt;p&gt;XSLT 2.0 introduces new grouping constructs.&lt;/p&gt;
&lt;/body&gt;</eg>
               <p>Desired output:</p>
               <eg xml:space="preserve" role="xml">&lt;chapter&gt;
  &lt;section title="Introduction"&gt;
    &lt;para&gt;XSLT is used to write stylesheets.&lt;/para&gt;
    &lt;para&gt;XQuery is used to query XML databases.&lt;/para&gt;
  &lt;/section&gt; 
  &lt;section title="What is a stylesheet?"&gt;
    &lt;para&gt;A stylesheet is used to define a transformation.&lt;/para&gt;
    &lt;para&gt;Stylesheets may be written in XSLT.&lt;/para&gt;
    &lt;para&gt;XSLT 2.0 introduces new grouping constructs.&lt;/para&gt;
  &lt;/section&gt;
&lt;/chapter&gt;</eg>
               <p>Solution:</p>
               <eg xml:space="preserve" diff="chg" at="R-bug24510" role="xslt-declaration">&lt;xsl:template match="body"&gt;
  &lt;chapter&gt;
    &lt;xsl:for-each-group select="*" group-starting-with="h2"&gt;
      &lt;section title="{self::h2}"&gt;
        &lt;xsl:for-each select="current-group()[self::p]"&gt;
          &lt;para&gt;&lt;xsl:value-of select="."/&gt;&lt;/para&gt;
        &lt;/xsl:for-each&gt; 
      &lt;/section&gt;
    &lt;/xsl:for-each-group&gt;
  &lt;/chapter&gt;
&lt;/xsl:template&gt;</eg>
               <p>The use of <code>title="{self::h2}"</code> rather than <code>title="{.}"</code> is
                  to handle the case where the first element is not an <code>h2</code> element.</p>
            </example>
            <example>
               <head>Identifying a Group by its Final Element</head>
               <p>The next example illustrates how a group of related elements can be identified by
                  the last element in the group, rather than the first. Here the absence of the
                  attribute <code>continued="yes"</code> indicates the end of the group.</p>
               <p>Source XML document:</p>
               <eg xml:space="preserve" role="xml">&lt;doc&gt;
  &lt;page continued="yes"&gt;Some text&lt;/page&gt;
  &lt;page continued="yes"&gt;More text&lt;/page&gt;    
  &lt;page&gt;Yet more text&lt;/page&gt;
  &lt;page continued="yes"&gt;Some words&lt;/page&gt;
  &lt;page continued="yes"&gt;More words&lt;/page&gt;    
  &lt;page&gt;Yet more words&lt;/page&gt;        
&lt;/doc&gt;</eg>
               <p>Desired output:</p>
               <eg xml:space="preserve" role="xml">&lt;doc&gt;
  &lt;pageset&gt;
    &lt;page&gt;Some text&lt;/page&gt;
    &lt;page&gt;More text&lt;/page&gt;    
    &lt;page&gt;Yet more text&lt;/page&gt;
  &lt;/pageset&gt;
  &lt;pageset&gt;
    &lt;page&gt;Some words&lt;/page&gt;
    &lt;page&gt;More words&lt;/page&gt;    
    &lt;page&gt;Yet more words&lt;/page&gt;
  &lt;/pageset&gt;
&lt;/doc&gt;</eg>
               <p>Solution:</p>
               <eg xml:space="preserve" diff="chg" at="R-bug24510" role="xslt-declaration">&lt;xsl:template match="doc"&gt;
&lt;doc&gt;
  &lt;xsl:for-each-group select="*" 
                      group-ending-with="page[not(@continued='yes')]"&gt;
    &lt;pageset&gt;
      &lt;xsl:for-each select="current-group()"&gt;
        &lt;page&gt;&lt;xsl:value-of select="."/&gt;&lt;/page&gt;
      &lt;/xsl:for-each&gt; 
    &lt;/pageset&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/doc&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <example>
               <head>Adding an Element to Several Groups</head>
               <p>The next example shows how an item can be added to multiple groups. Book titles
                  will be added to one group for each indexing term marked up within the title.</p>
               <p>Source XML document:</p>
               <eg xml:space="preserve" role="xml">&lt;titles&gt;
    &lt;title&gt;A Beginner's Guide to &lt;ix&gt;Java&lt;/ix&gt;&lt;/title&gt;
    &lt;title&gt;Learning &lt;ix&gt;XML&lt;/ix&gt;&lt;/title&gt;
    &lt;title&gt;Using &lt;ix&gt;XML&lt;/ix&gt; with &lt;ix&gt;Java&lt;/ix&gt;&lt;/title&gt;
&lt;/titles&gt;</eg>
               <p>Desired output:</p>
               <eg xml:space="preserve" role="xml">&lt;h2&gt;Java&lt;/h2&gt;
    &lt;p&gt;A Beginner's Guide to Java&lt;/p&gt;
    &lt;p&gt;Using XML with Java&lt;/p&gt;
&lt;h2&gt;XML&lt;/h2&gt;
    &lt;p&gt;Learning XML&lt;/p&gt;
    &lt;p&gt;Using XML with Java&lt;/p&gt;</eg>
               <p>Solution:</p>
               <eg xml:space="preserve" diff="chg" at="R-bug24510" role="xslt-declaration">&lt;xsl:template match="titles"&gt;
    &lt;xsl:for-each-group select="title" group-by="ix"&gt;
      &lt;h2&gt;&lt;xsl:value-of select="current-grouping-key()"/&gt;&lt;/h2&gt;
      &lt;xsl:for-each select="current-group()"&gt;
        &lt;p&gt;&lt;xsl:value-of select="."/&gt;&lt;/p&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <example>
               <head>Grouping Alternating Sequences of Elements</head>
               <p>In this example, the membership of a node within a group is based both on
                  adjacency of the nodes in document order, and on common values. In this case, the
                  grouping key is a boolean condition, true or false, so the effect is that a
                  grouping establishes a maximal sequence of nodes for which the condition is true,
                  followed by a maximal sequence for which it is false, and so on.</p>
               <p>Source XML document:</p>
               <eg xml:space="preserve" role="xml">&lt;p&gt;Do &lt;em&gt;not&lt;/em&gt;:
    &lt;ul&gt;
    &lt;li&gt;talk,&lt;/li&gt;
    &lt;li&gt;eat, or&lt;/li&gt;
    &lt;li&gt;use your mobile telephone&lt;/li&gt;
    &lt;/ul&gt;
    while you are in the cinema.&lt;/p&gt;</eg>
               <p>Desired output:</p>
               <eg xml:space="preserve" role="xml">&lt;p&gt;Do &lt;em&gt;not&lt;/em&gt;:&lt;/p&gt;
    &lt;ul&gt;
    &lt;li&gt;talk,&lt;/li&gt;
    &lt;li&gt;eat, or&lt;/li&gt;
    &lt;li&gt;use your mobile telephone&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;while you are in the cinema.&lt;/p&gt;</eg>
               <p>Solution:</p>
               <p>This requires creating a <code>p</code> element around the maximal sequence of
                  sibling nodes that does not include a <code>ul</code> or <code>ol</code>
                  element.</p>
               <p>This can be done by using <code>group-adjacent</code>, with a grouping key that is
                  true if the element is a <code>ul</code> or <code>ol</code> element, and false
                  otherwise:</p>
               <eg xml:space="preserve" diff="chg" at="R-bug24510" role="xslt-declaration">&lt;xsl:template match="p"&gt;
    &lt;xsl:for-each-group select="node()" 
            group-adjacent="self::ul or self::ol"&gt;
        &lt;xsl:choose&gt;
            &lt;xsl:when test="current-grouping-key()"&gt;
                &lt;xsl:copy-of select="current-group()"/&gt;  
            &lt;/xsl:when&gt;
            &lt;xsl:otherwise&gt;
                &lt;p&gt;
                    &lt;xsl:copy-of select="current-group()"/&gt;
                &lt;/p&gt;
            &lt;/xsl:otherwise&gt;  
        &lt;/xsl:choose&gt;
    &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;</eg>
            </example>
         </div2>
         <div2 id="non-transitivity">
            <head>Non-Transitivity</head>
            <p>If the population contains values of different numeric types that differ from each
               other by small amounts, then the <code>eq</code> operator is not transitive, because
               of rounding effects occurring during type promotion. It is thus possible to have
               three values <var>A</var>, <var>B</var>, and <var>C</var> among the grouping keys of
               the population such that <code>A eq B</code>, <code>B eq C</code>, but <code>A ne
                  C</code>.</p>
            <p>For example, this arises when computing</p>
            <eg xml:space="preserve" role="xslt-instruction">
      &lt;xsl:for-each-group group-by="." select="
             xs:float('1.0'),
             xs:decimal('1.0000000000100000000001'),
             xs:double('1.00000000001')"/&gt;</eg>
            <p>because the values of type <code>xs:float</code> and <code>xs:double</code> both
               compare equal to the value of type <code>xs:decimal</code> but not equal to each
               other.</p>
            <p>In this situation the results <rfc2119>must</rfc2119> be equivalent to the results
               obtained by the following algorithm:</p>
            <ulist>
               <item>
                  <p>For each item <var>J</var> in the <termref def="dt-population"
                        >population</termref> in <termref def="dt-population-order">population
                        order</termref>, for each of the <termref def="dt-grouping-key">grouping
                        keys</termref>
                     <var>K</var> for that item in sequence, the processor identifies those existing
                     groups <var>G</var> such that the grouping key of the <termref
                        def="dt-initial-item">initial item</termref> of <var>G</var> is equal to
                        <var>K</var>.</p>
               </item>
               <item>
                  <p>If there is exactly one group <var>G</var>, then <var>J</var> is added to this
                     group, unless <var>J</var> is already a member of this group.</p>
               </item>
               <item>
                  <p>If there is no group <var>G</var>, then a new group is created with
                        <var>J</var> as its first item.</p>
               </item>
               <item>
                  <p>If there is more than one group <var>G</var> (which can only happen in
                     exceptional circumstances involving non-transitivity), then one of these groups
                     is selected in an implementation-dependent way, and <var>J</var> is added to
                     this group, unless <var>J</var> is already a member of this group.</p>
               </item>
            </ulist>
            <p>The effect of these rules is that (a) every item in a non-singleton group has a
               grouping key that is equal to that of at least one other item in that group, (b) for
               any two distinct groups, there is at least one pair of items (one from each group)
               whose grouping keys are not equal to each other.</p>
         </div2>
      </div1>
      <div1 id="merging" diff="chg" at="C">
         <head>Merging</head>
         <p>The <elcode>xsl:merge</elcode> instruction allows a sorted sequence of items to be
            constructed by merging several input sequences. Each input sequence <rfc2119 diff="chg"
               at="F">must</rfc2119> have a merge key (one or more atomic values that can be
            computed as a function of the items in the sequence); <phrase diff="chg" at="S">the
               input sequence <rfc2119 diff="chg" at="F">must</rfc2119> either already be sorted on
               the value of its merge keys, or pre-sorting on these values must be
               requested.</phrase> The merge keys for the different input sequences <rfc2119
               diff="chg" at="F">must</rfc2119> be compatible in the sense that <phrase diff="chg"
               at="F">key values from an item in one sequence are always comparable with key values
               from an item in a different sequence</phrase>.</p>
         <p>For example, if two log files contain details of events sorted by date and time, then
            the <elcode>xsl:merge</elcode> instruction can be used to combine these into a single
            sequence that is also sorted by date and time.</p>
         <p>The data written to the output sequence can be computed in an arbitrary way from the
            data in the input sequences, provided it follows the ordering of the input
            sequences.</p>
         <p>The <elcode>xsl:merge</elcode> instruction can be used to merge several sequences of
            items that all have the same structure (more precisely, sequences whose merge keys are
            computed in the same way): for example, log files created by the same application
            running on different machines in a server farm. Alternatively,
               <elcode>xsl:merge</elcode> can be used to merge sequences that have different
            structure (sequences whose merge keys are computed in different ways), provided that the
            computed merge keys are compatible: an example might be two log files created by
            different applications, using different XML vocabularies, that both contain timestamped
            events but represent the timestamp in different ways. The
               <elcode>xsl:merge-source</elcode> element represents a <phrase diff="chg" at="F">set
               of input sequences that follow common rules</phrase>, including the rules for
            computing the merge key. The <elcode>xsl:merge</elcode> operation may take any number of
               <elcode>xsl:merge-source</elcode> elements representing different <phrase diff="chg"
               at="F">rules for</phrase> input sequences, and each <elcode>xsl:merge-source</elcode>
            element may describe any number (zero or more) of input sequences. The number of input
            sequences to the merging operation is thus <phrase diff="chg" at="F">fixed only at the
               time the <elcode>xsl:merge</elcode> instruction is evaluated, and
                  <rfc2119>may</rfc2119> vary from one evaluation to another</phrase>.</p>
         <p>The following examples illustrate some of the possibilities. The detailed explanation of
            the constructs used follows later in this section.</p>
         <example>
            <head>Merging All the Files in a Collection</head>
            <p>This example takes as input a homogeneous collection of XML log files each of which
               contains a sorted sequence of <code>event</code> elements with a
                  <code>timestamp</code> attribute validated as an instance of
                  <code>xs:dateTime</code>. It merges the events from the input files into a single
               sorted output file.</p>
            <eg diff="chg" at="R-bug24510" role="xslt-instruction" xml:space="preserve">
&lt;xsl:result-document href="merged-events.xml"&gt;
  &lt;events&gt;
    &lt;xsl:merge&gt;
      &lt;xsl:merge-source for-each-source="uri-collection('log-files')"
                        select="events/event"&gt;
        &lt;xsl:merge-key select="@timestamp"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-action&gt;
        &lt;xsl:copy-of select="current-merge-group()"/&gt;
      &lt;/xsl:merge-action&gt;
    &lt;/xsl:merge&gt;
  &lt;/events&gt;
&lt;/xsl:result-document&gt;
</eg>
            <p>The example assumes that there are <phrase diff="chg" at="F">several input files each
                  of which has</phrase> a structure similar to the following, in which the
                  <code>timestamp</code> attribute has a typed value that is an instance of
                  <code>xs:dateTime</code>:</p>
            <eg role="xml" xml:space="preserve">
&lt;events&gt;
   &lt;event timestamp="2009-08-20T12:01:01Z"&gt;Transaction T1234 started&lt;/event&gt;
   &lt;event timestamp="2009-08-20T12:01:08Z"&gt;Transaction T1235 started&lt;/event&gt;
   &lt;event timestamp="2009-08-20T12:01:12Z"&gt;Transaction T1235 ended&lt;/event&gt;
   &lt;event timestamp="2009-08-20T12:01:15Z"&gt;Transaction T1234 ended&lt;/event&gt;
&lt;/events&gt;</eg>
            <p>The output file will have the same structure, and will contain copies of all the
                  <code>event</code> elements from all of the input files, in sorted order. <phrase
                  diff="chg" at="F">Note that multiple events with the same timestamp can occur
                  either within a single file or across multiple files: the order of appearance of
                  these events in the output file corresponds to the order of the log files within
                  the collection (which might or might not be predictable, depending on the
                  implementation).</phrase></p>
         </example>
         <example>
            <head>Merging Two Heterogeneous Files</head>
            <p>This example takes as input two log files with different structure, producing a
               single merged output in which the entries have a common structure:</p>
            <eg diff="chg" at="R-bug24510" role="xslt-instruction" xml:space="preserve">
&lt;xsl:result-document href="merged-events.xml"&gt;
  &lt;events&gt;
    &lt;xsl:merge&gt;
      &lt;xsl:merge-source select="doc('log-file-1.xml')/events/event"&gt;
        &lt;xsl:merge-key select="@timestamp"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-source select="doc('log-files-2.xml')/log/day/record"&gt;
        &lt;xsl:merge-key select="dateTime(../@date, time)"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-action&gt;
        &lt;xsl:apply-templates select="current-merge-group()" 
                             mode="standardize-log-entry"/&gt;
      &lt;/xsl:merge-action&gt;
    &lt;/xsl:merge&gt;
  &lt;/events&gt;
&lt;/xsl:result-document&gt;
</eg>
            <p>Here the first input file has a structure similar to that shown in the previous
               example, while the second input has a different structure, of the form:</p>
            <eg role="xml" xml:space="preserve">
&lt;log&gt;
  &lt;day date="2009-08-20"&gt;
    &lt;record&gt;
      &lt;time&gt;12:01:09-05:00&lt;/time&gt;
      &lt;message&gt;Temperature 15.4C&lt;/message&gt;
    &lt;/record&gt;
    &lt;record&gt;
      &lt;time&gt;12:03:00-05:00&lt;/time&gt;
      &lt;message&gt;Temperature 18.2C&lt;/message&gt;
    &lt;/record&gt;
  &lt;/day&gt;
&lt;/log&gt;</eg>
            <p>The templates in mode <code>standardize-log-entry</code> convert the log entries to a
               common output format, for example:</p>
            <eg role="xslt-declaration" xml:space="preserve">
&lt;xsl:template match="event" mode="standardize-log-entry" 
                            as="schema-element(event)"&gt;
  &lt;xsl:copy-of select="." validation="preserve"/&gt;
&lt;/xsl:template&gt;
  
&lt;xsl:template match="record" mode="standardize-log-entry" 
                             as="schema-element(event)"&gt;
  &lt;event timestamp="{dateTime(../@date, time)}" xsl:validation="strict"&gt;
    &lt;xsl:value-of select="message"/&gt;
  &lt;/event&gt;
&lt;/xsl:template&gt;</eg>
         </example>
         <note>
            <p>The <elcode>xsl:merge</elcode> instruction is designed to enable streaming of data,
               so that there is no need to allocate memory to hold the input sequences. <phrase
                  diff="chg" at="R-bug24343">However, it can also be used in cases where streamed
                  processing is not possible, for example when the input needs to be
               sorted</phrase>.</p>
         </note>
         <div2 id="merge-terminology">
            <head>Terminology for Merging</head>
            <p><termdef id="dt-merge-source-definition" term="merge source definition">A <term>merge
                     source definition</term> is the definition of one kind of input to the merge
                  operation. It selects zero or more <termref def="dt-merge-input-sequence">merge
                     input sequences</termref>, and it includes a <termref
                     def="dt-merge-key-specification">merge key specification</termref> to define
                  how the <phrase diff="chg" at="F"><termref def="dt-merge-key-value">merge key
                        values</termref></phrase> are computed for each such merge input
                  sequence.</termdef> A merge source definition corresponds to an
                  <elcode>xsl:merge-source</elcode> element in the stylesheet.</p>
            <p><termdef id="dt-merge-input-sequence" term="merge input sequence">A <term>merge input
                     sequence</term> is an arbitrary <xtermref spec="DM30" ref="dt-sequence"
                     >sequence</xtermref> of items which is already sorted according to the <termref
                     def="dt-merge-key-specification">merge key specification</termref> for the
                  corresponding <termref def="dt-merge-source-definition">merge source
                     definition</termref>.</termdef></p>
            <p><termdef id="dt-merge-key-specification" term="merge key specification">A <term>merge
                     key specification</term> consists of one or more adjacent
                     <elcode>xsl:merge-key</elcode> elements which together define how the <termref
                     def="dt-merge-input-sequence">merge input sequences</termref> selected by a
                     <termref def="dt-merge-source-definition">merge source definition</termref> are
                  sorted. Each <elcode>xsl:merge-key</elcode> element defines one <termref
                     def="dt-merge-key-component">merge key component</termref>.</termdef> For
               example, a merge key specification for a log file might specify two merge key
               components, <code>date</code> and <code>time</code>.</p>
            <p><termdef id="dt-merge-key-component" term="merge key component">A <term>merge key
                     component</term> specifies one component of a <termref
                     def="dt-merge-key-specification">merge key specification</termref>; it
                  corresponds to a single <elcode>xsl:merge-key</elcode> element in the
                  stylesheet.</termdef></p>
            <p><termdef id="dt-merge-key-value" term="merge key value"> For each item in a <termref
                     def="dt-merge-input-sequence">merge input sequence</termref>, a value is
                  computed for each <termref def="dt-merge-key-component">merge key
                     component</termref> within the <termref def="dt-merge-key-specification">merge
                     key specification</termref>. The value computed for an item by using the
                     <var>N</var>th <termref def="dt-merge-key-component"/> is referred to as the
                     <var>N</var>th <term>merge key value</term> of that item.</termdef></p>
            <p><termdef id="dt-composite-merge-key-value" term="composite merge key value"> The
                  ordered collection of <termref def="dt-merge-key-value">merge key values</termref>
                  computed for one item in a <termref def="dt-merge-input-sequence">merge input
                     sequence</termref> (one for each <termref def="dt-merge-key-component">merge
                     key component</termref> within the <termref def="dt-merge-key-specification"
                     >merge key specification</termref>) is referred to as a <term>composite merge
                     key value</term>.</termdef></p>
            <p><termdef id="dt-merge-activation" term="merge activation">A <term>merge
                     activation</term> is a single evaluation of the sequence constructor contained
                  within the <elcode>xsl:merge-action</elcode> element, which occurs once for each
                  distinct <termref def="dt-composite-merge-key-value">composite merge key
                     value</termref>.</termdef></p>
         </div2>
         <div2 id="merge-instruction">
            <head>The <elcode>xsl:merge</elcode> Instruction</head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="merge">
               <e:in-category name="instruction"/>
               <e:sequence>
                  <e:element repeat="one-or-more" name="merge-source"/>
                  <e:element name="merge-action"/>
                  <e:element repeat="zero-or-more" name="fallback"/>
               </e:sequence>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The effect of the <elcode>xsl:merge</elcode> instruction is to produce a sorted
               result sequence from a number of input sequences.</p>
            <p>The input sequences to the merge operation are defined by the
                  <elcode>xsl:merge-source</elcode> child elements, as described in the next
               section.</p>
            <p diff="chg" at="C">The sequence constructor contained in the
                  <elcode>xsl:merge-action</elcode> element is evaluated once for each distinct
                  <termref def="dt-composite-merge-key-value"/> to form a partial result sequence.
               The result of the <elcode>xsl:merge</elcode> instruction is the concatenation of
               these partial result sequences. For example, the action might be to copy the items
               from all the input sequences to the result sequence without change; or it might be to
               select the items from one input sequence in preference to the others. In the general
               case, the items in the partial result sequence are produced by an arbitrary
               computation that has access to the items (from the various input sequences) that
               share the same value for the composite merge key.</p>
            <p diff="chg" at="C">The <elcode>xsl:merge-source</elcode> and
                  <elcode>xsl:merge-action</elcode> elements are described in the following
               sections.</p>
            <p diff="del" at="R-bug24510">The <code>bind-group</code> attribute establishes the name
               of a variable which is available for reference within the
                  <elcode>xsl:merge-action</elcode> element, and whose value is a sequence of items,
               from all input sources, that share a common <termref
                  def="dt-composite-merge-key-value"/>.</p>
            <p diff="del" at="R-bug24510">The <code>bind-key</code> attribute establishes the name
               of a variable which is available for reference within the
                  <elcode>xsl:merge-action</elcode> element, and whose value is the <termref
                  def="dt-composite-merge-key-value"/> of these items.</p>
            <p>Any <elcode>xsl:fallback</elcode> children of the <elcode>xsl:merge</elcode>
               instruction are ignored by an XSLT 3.0 processor, but are used by an XSLT 1.0 or XSLT
               2.0 processor to <phrase diff="chg" at="F">perform fallback processing</phrase>.</p>
            <note>
               <p>An <elcode>xsl:merge</elcode> instruction that has no input sequences returns an
                  empty sequence. An <elcode>xsl:merge</elcode> instruction with a single input
                  sequence performs processing that is very similar in concept to
                     <elcode>xsl:for-each-group</elcode> with the <code>group-adjacent</code>
                  attribute, except that it requires the input to be sorted on the grouping key.</p>
            </note>
         </div2>
         <div2 id="merge-input-sequences">
            <head>Selecting the Sequences to be Merged</head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="merge-source">
               <e:attribute name="name" required="no">
                  <e:data-type name="ncname"/>
               </e:attribute>
               <e:attribute name="for-each-item" required="no">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="for-each-source" required="no">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="select" required="yes">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="streamable" required="no">
                  <e:data-type name="boolean"/>
               </e:attribute>
               <e:attribute name="use-accumulators">
                  <e:data-type name="tokens"/>
               </e:attribute>
               <e:attribute name="sort-before-merge" required="no">
                  <e:data-type name="boolean"/>
               </e:attribute>
               <e:attribute name="validation">
                  <e:constant value="strict"/>
                  <e:constant value="lax"/>
                  <e:constant value="preserve"/>
                  <e:constant value="strip"/>
               </e:attribute>
               <e:attribute name="type">
                  <e:data-type name="eqname"/>
               </e:attribute>
               <e:element repeat="one-or-more" name="merge-key"/>
               <e:allowed-parents>
                  <e:parent name="merge"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>Each <elcode>xsl:merge-source</elcode> element defines one or more <termref
                  def="dt-merge-input-sequence">merge input sequences</termref>.</p>
            <p diff="add" at="R-bug24510">The <code>name</code> attribute provides a means of
               distinguishing items from different merge sources within the
                  <elcode>xsl:merge-action</elcode> instructions. If the <code>name</code> attribute
               is present on an <elcode>xsl:merge-source</elcode> element, then it must not be equal
               to the <code>name</code> attribute of any sibling <elcode>xsl:merge-source</elcode>
               element. If the <code>name</code> attribute is absent, then an <termref
                  def="dt-implementation-dependent"/> name, different from all explicitly specified
               names, is allocated to the merge source.</p>
            <p diff="chg" at="R-bug26766"><error spec="XT" class="SE" type="static" code="3195"
                     ><p>If the <code>for-each-item</code> is present then the <phrase diff="chg"
                        at="T-bug29804"><code>for-each-source</code>, <code>use-accumulators</code>,
                        and <code>streamable</code></phrase> attributes must both be absent. If the
                        <code>use-accumulators</code> attribute is present then the
                        <code>for-each-source</code> attribute must be present. If the
                        <code>for-each-source</code> attribute is present then the
                        <code>for-each-item</code> attribute must be absent. </p></error></p>
            <p diff="add" at="S-bug27660">The <code>use-accumulators</code> attribute defines the
               set of accumulators that are applicable to the streamed document, as explained in
                  <specref ref="applicability-of-accumulators"/>.</p>
            <p diff="chg" at="K"><phrase diff="chg" at="R-bug24343">If neither of
                     <code>for-each-item</code> and <code>for-each-source</code> is
               present</phrase>, the <elcode>xsl:merge-source</elcode> element defines a single
               merge input sequence. This sequence is the result of evaluating the expression in the
                  <code>select</code> attribute. This is evaluated using the dynamic context of the
               containing <elcode>xsl:merge</elcode> instruction. This sequence will be merged with
               the sequences defined by other <elcode>xsl:merge-source</elcode> elements, if
               present.</p>
            <p diff="chg" at="K">When the <code diff="chg" at="R-bug24343">for-each-item</code>
               attribute is present, the <elcode>xsl:merge-source</elcode> element defines a
               collection of merge input sequences. The selection of items in these input sequences
               is a two-stage process: the <code>for-each-item</code> attribute of the
                  <elcode>xsl:merge-source</elcode> element is an expression that selects a sequence
               of <emph>anchor items</emph>, and for each anchor item, the <code>select</code>
               attribute is evaluated to select the items that make up one merge input sequence. The
                  <code diff="chg" at="R-bug24343">for-each-item</code> expression is evaluated with
               the dynamic context of the containing <elcode>xsl:merge</elcode> instruction, while
               the <code>select</code> attribute is evaluated with the <termref def="dt-focus"
                  >focus</termref> for the evaluation as follows:</p>
            <ulist>
               <item>
                  <p>The <termref def="dt-context-item">context item</termref> is the anchor
                     item</p>
               </item>
               <item>
                  <p>The <termref def="dt-context-position">context position</termref> is the
                     position of the anchor item within the sequence of anchor items</p>
               </item>
               <item>
                  <p>The <termref def="dt-context-size">context size</termref> is the number of
                     anchor items.</p>
               </item>
            </ulist>
            <p diff="add" at="R-bug24343">When the <code>for-each-source</code> attribute is
               present, its value must be an expression that returns a sequence of URIs. <phrase
                  diff="add" at="T-bug29697">The expression is evaluated with the same dynamic
                  context as the containing <elcode>xsl:merge</elcode> instruction.</phrase> The
               expected type of the expression is <code>xs:string*</code>, and the actual result of
               the expression is converted to this type using the <termref
                  def="dt-function-conversion-rules"/>. Each of these URIs is used to obtain a
               document node. Each <rfc2119>must</rfc2119> be a valid URI reference. If it is an
               absolute URI reference, it is used as is; if it is a relative URI reference, it is
               made absolute by resolving it against the base URI of the
                  <elcode>xsl:merge-source</elcode> element. The process of obtaining a document
               node given a URI is the same as for the <xfunction>doc</xfunction> function, <phrase
                  diff="add" at="R-bug26766">and may trigger the same error conditions</phrase>.
               However, unlike the <xfunction>doc</xfunction> function, the
                  <elcode>xsl:merge</elcode> instruction offers no guarantee that the resulting
               document will be stable (that is, that multiple calls specifying the same URI will
               return the same document). The resulting document nodes act as the <term>anchor
                  items</term>. These anchor items are then used in the same way as a sequence of
               anchor items selected directly using the <code>for-each-item</code> attribute:
                  <phrase diff="add" at="T-bug29697">in particular, the <termref def="dt-focus"/> is
                  determined in the same way.</phrase></p>
            <note diff="add" at="R-bug24343">
               <p>Examples of expressions that return a sequence of URIs are:</p>
               <ulist>
                  <item>
                     <p><code>for-each-source="'inputA.xml', 'inputB.xml'"</code></p>
                  </item>
                  <item>
                     <p><code>for-each-source="(1 to $N) ! ('input' || $N || '.xml')"</code></p>
                  </item>
                  <item>
                     <p><code>for-each-source="uri-collection('input/dir/')</code></p>
                  </item>
               </ulist>
               <p>Relative URIs are resolved relative to the base URI of the
                     <elcode>xsl:merge-source</elcode> element.</p>
            </note>
            <p diff="add" at="R-bug24343">The attributes <code>validation</code> and
                  <code>type</code> are used to control schema validation of documents read by
               virtue of their appearance in the result of the <code>for-each-source</code>
               expression. These attributes are mutually exclusive <errorref spec="XT" class="SE"
                  code="1505"/>. The rules are the same as for an
                  <elcode>xsl:source-document</elcode> instruction <phrase diff="add"
                  at="T-bug29747">specifying <code>streamable="yes"</code></phrase>. If the
                  <code>for-each-source</code> attribute is absent, then the <code>validation</code>
               and <code>type</code> attributes <rfc2119>must</rfc2119> both be absent.</p>
            <p diff="del" at="R-bug24510">The <code>bind-source</code> attribute establishes the
               name of a variable which is available for reference within the
                  <elcode>xsl:merge-action</elcode> element, and whose value is a sequence of items,
               from this source only, that share the <termref def="dt-composite-merge-key-value"/>
               for this activation of the <elcode>xsl:merge-action</elcode>.</p>
            <p diff="add" at="K">If the <code>sort-before-merge</code> attribute is absent or has
               the value <code>no</code>, then each input sequence <rfc2119>must</rfc2119> already
               be in the correct order for merging (a dynamic error occurs if it is not). If the
               attribute is present with the value <code>yes</code>, then each input sequence will
               first be sorted to ensure that it is in the correct order.</p>
            <example>
               <head>Merging Several Documents with the Same Structure</head>
               <p>The following <elcode>xsl:merge-source</elcode> element selects two anchor items
                  (the root nodes of two documents), and for each of these it selects an input
                  sequence consisting of selected <code>event</code> elements within the relevant
                  document.</p>
               <eg role="xslt-fragment" xml:space="preserve">
&lt;xsl:merge-source for-each-source="'log-A.xml', 'log-B.xml'"
                  streamable="yes"
                  select="events/event"&gt;
   &lt;xsl:merge-key select="@timestamp" order="ascending"/&gt;
&lt;/xsl:merge-source&gt;</eg>
               <p>This example can be extended to merge any number of input documents with the same
                  structure:</p>
               <eg role="xslt-fragment" xml:space="preserve">
&lt;xsl:merge-source for-each-source="uri-collection('log-collection')"
                  streamable="yes"
                  select="events/event"&gt;
   &lt;xsl:merge-key select="@time" order="ascending"/&gt;
&lt;/xsl:merge-source&gt;</eg>
               <p>In both the above examples the anchor items are document nodes, and the items in
                  the input sequence are elements within the document that is rooted at this node.
                  This is a common usage pattern, but by no means the only way in which the
                  construct can be used.</p>
            </example>
            <p>The number of anchor items selected by an <elcode>xsl:merge-source</elcode> element,
               and therefore the number of input sequences, is variable, but the input sequences
               selected by one <elcode>xsl:merge-source</elcode> element must all use the same
               expressions to select the items in the input sequence and to compute their merge
               keys. If different expressions are needed for different input sequences, then
               multiple <elcode>xsl:merge-source</elcode> elements can be used.</p>
            <example>
               <head>Merging Two Documents with Different Structure</head>
               <p>The following code merges two log files having different internal structure:</p>
               <eg diff="chg" at="R-bug24343" role="xslt-fragment" xml:space="preserve">
&lt;xsl:merge-source for-each-source="'event-log.xml'" 
                  streamable="yes" select="/*/event"&gt;
  &lt;xsl:merge-key select="@timestamp"/&gt;
&lt;/xsl:merge-source&gt;
&lt;xsl:merge-source for-each-source="'error-log.xml'" 
                  streamable="yes" select="/*/error"&gt;
  &lt;xsl:merge-key select="dateTime(@date, @time)"/&gt;
&lt;/xsl:merge-source&gt;</eg>
               <p>Although the merge keys are computed in different ways for the two input
                  sequences, the keys must be compatible across the two sequences: in this case they
                  are both atomic values of type <code>xs:dateTime</code>.</p>
            </example>
            <p>In the common case where there is only one input sequence of a particular kind, the
                  <code diff="chg" at="R-bug24343">for-each-item</code> attribute of
                  <elcode>xsl:merge-source</elcode> may be omitted; the <code>select</code>
               expression is then evaluated relative to the <termref def="dt-focus">focus</termref>
               of the <elcode>xsl:merge</elcode> instruction itself.</p>
            <example>
               <head>Sorting before Merging</head>
               <p>Where one or more of the inputs to the merging process is not pre-sorted, a sort
                  can be requested using the <code>sort-before-merge</code> attribute. For
                  example:</p>
               <eg role="xslt-fragment" xml:space="preserve">
&lt;xsl:merge-source select="doc('event-log.xml')/*/event"&gt;
  &lt;xsl:merge-key select="@timestamp"/&gt;
&lt;/xsl:merge-source&gt;
&lt;xsl:merge-source select="doc('error-log.xml')//error" 
                  sort-before-merge="yes"&gt;
  &lt;xsl:merge-key select="dateTime(current-date(), @time)"/&gt;
&lt;/xsl:merge-source&gt;
</eg>
            </example>
            <p>
               <error spec="XT" type="static" class="SE" code="3190"><p>It is a <termref
                        def="dt-static-error">static error</termref> if two sibling
                        <elcode>xsl:merge-source</elcode> elements have the same name.</p></error>
            </p>
         </div2>
         <div2 id="streamable-merging" diff="add" at="L">
            <head>Streamable Merging</head>
            <p diff="chg" at="R-bug24343">Any input to a merging operation, provided it is selected
               by means of the <elcode>xsl:merge-source</elcode> element with a
                  <code>for-each-source</code> attribute, may be designated as streamable by
               including the attribute <code>streamable="yes"</code> on the
                  <elcode>xsl:merge-source</elcode> element. <phrase diff="del" at="T-bug29804">This
                  is also the default value when the <code>for-each-source</code> attribute is
                  present.</phrase></p>
            <p diff="add" at="R-bug25335">When <code>streamable="yes"</code> is specified on an
                  <elcode>xsl:merge-source</elcode> element, then (whether or not streamed
               processing is actually used, and whether or not the processor supports streaming) the
               expression appearing in the <code>select</code> attribute is implicitly used as the
               argument of a call on the <function>snapshot</function> function, which means that
               merge keys for each selected node are computed with reference to this snapshot, and
               the <function>current-merge-group</function> function, when used within the
                  <elcode>xsl:merge-action</elcode> sequence constructor, delivers snapshots of the
               selected nodes.</p>
            <note>
               <p diff="add" at="R-bug25335">There are therefore no constraints on the navigation
                  that may be performed in computing the merge key, or in the course of evaluating
                  the <elcode>xsl:merge-action</elcode> body. An attempt to navigate outside the
                  portion of the source document delivered by the <function>snapshot</function>
                  function will typically not cause an error, but will return empty results.</p>
               <p diff="chg" at="S-bug29141">There is no rule to prevent the <code>select</code>
                  expression returning atomic values, or grounded nodes from a different source
                  document, or newly constructed nodes, but they are still processed using the
                     <function>snapshot</function> function.</p>
               <p diff="add" at="S-bug28130">Because the <function>snapshot</function> copies
                  accumulator values as described in <specref ref="copying-accumulators"/>, the
                  functions <function>accumulator-before</function> and
                     <function>accumulator-after</function> may be used to gain access to
                  information that is not directly available in the nodes that are present within
                  each snapshot (for example, information in a header section of the merge input
                  document).</p>
            </note>
            <p diff="chg" at="Q">An <phrase diff="chg" at="R-bug24649"
                     ><elcode>xsl:merge-source</elcode> element</phrase> is <termref
                  def="dt-guaranteed-streamable"/> if it satisfies all the following conditions:</p>
            <olist>
               <item diff="add" at="R-bug24649">
                  <p>The <elcode>xsl:merge-source</elcode> element has the <phrase diff="del"
                        at="T-bug29804">actual or defaulted</phrase> attribute value
                        <code>streamable="yes"</code>;</p>
               </item>
               <item>
                  <p>The <code diff="chg" at="R-bug24343">for-each-source</code> attribute is
                     present on that <elcode>xsl:merge-source</elcode> element<phrase diff="del"
                        at="R-bug24343">, and its value is a function call that calls the
                           <function>document</function>, <xfunction>doc</xfunction>, or
                           <xfunction>collection</xfunction> function</phrase>;</p>
               </item>
               <item diff="chg" at="S-bug29142">
                  <p>The expression in the <code>select</code> attribute of that
                        <elcode>xsl:merge-source</elcode> element, assessed with a <termref
                        def="dt-context-posture"/> of <termref def="dt-striding"/> and a <termref
                        def="dt-context-item-type"/> of <var>U{document-node()}</var>, has <termref
                        def="dt-striding"/> or <termref def="dt-grounded"/>
                     <termref def="dt-posture"/> and <termref def="dt-motionless"/> or <termref
                        def="dt-consuming"/>
                     <termref def="dt-sweep"/>; </p>
               </item>
               <item>
                  <p>The <code>sort-before-merge</code> attribute of that
                        <elcode>xsl:merge-source</elcode> element is either absent or takes its
                     default value of <code>no</code>.</p>
               </item>
               <item diff="del" at="R-bug25335">
                  <p>The <code>select</code> expression of each merge key in that
                        <elcode>xsl:merge-source</elcode> element is a <termref def="dt-motionless"
                     /> expression;</p>
               </item>
               <item diff="del" at="R-bug25335">
                  <p>The <termref def="dt-sequence-constructor"/> in the
                        <elcode>xsl:merge-action</elcode> element has <phrase diff="add" at="Q"
                           ><termref def="dt-grounded"/>
                        <termref def="dt-posture"/> and </phrase> and either <termref
                        def="dt-motionless"/> or <phrase diff="del" at="Q"
                        >group-consuming</phrase><phrase diff="add" at="Q"><termref
                           def="dt-consuming"/>
                        <termref def="dt-sweep"/></phrase>.</p>
               </item>
            </olist>
            <p diff="add" at="Q">Specifying <code>streamable="yes"</code> on an <phrase diff="chg"
                  at="T-bug29698"><elcode>xsl:merge-source</elcode></phrase> element declares an
               intent that the <elcode>xsl:merge</elcode> instruction should be <phrase diff="chg"
                  at="S-bug27273">streamable <phrase diff="add" at="T-bug29698">with respect to that
                     particular source</phrase>, either because it is <termref
                     def="dt-guaranteed-streamable"/>, or because it takes advantage of
                  streamability extensions offered by a particular processor</phrase>. The
               consequences of declaring the instruction to be streamable when it is not in fact
               guaranteed streamable depend on the conformance level of the processor, and are
               explained in <specref ref="streamability-guarantees"/>.</p>
            <example>
               <head>Streamed Merging</head>
               <p>The following example merges two log files, processing each of them using
                  streaming.</p>
               <eg diff="chg" at="R-bug24343" role="xslt-fragment" xml:space="preserve">
&lt;events&gt;
   &lt;xsl:merge&gt;
      &lt;xsl:merge-source for-each-source="'log-file-1.xml'" 
                        select="/events/event" 
                        streamable="yes"&gt;
         &lt;xsl:merge-key select="@timestamp"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-source for-each-source="'log-files-2.xml'" 
                        select="/log/day/record" 
                        streamable="yes"&gt;
         &lt;xsl:merge-key select="dateTime(../@date, time)"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-action&gt;
         &lt;events time="{current-merge-key()}"&gt;
            &lt;xsl:copy-of select="current-merge-group()"/&gt;
         &lt;/events&gt;   
      &lt;/xsl:merge-action&gt;
   &lt;/xsl:merge&gt;
&lt;/events&gt;</eg>
            </example>
            <p>Note that the merge key for the second merge source includes data from a child
               element of the selected element and also from an attribute of the parent element.
               This works because of the merge key is evaluated on the result of implicitly applying
               the <function>snapshot</function> function.</p>
            <example diff="add" at="S-bug29141">
               <head>Merging XML and non-XML Data</head>
               <p>The following example merges two log files, one in text format and one in XML
                  format.</p>
               <eg role="xslt-instruction" xml:space="preserve">
&lt;events&gt;
   &lt;xsl:merge&gt;
      &lt;xsl:merge-source name="fax" 
                        select="unparsed-text-lines('fax-log.txt')"&gt;
         &lt;xsl:merge-key select="xs:dateTime(substring-before(., ' '))"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-source name="mail"
                        for-each-source="'mail-log.xml'" 
                        select="/log/day/message" 
                        streamable="yes"&gt;
         &lt;xsl:merge-key select="dateTime(../@date, @time)"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-action&gt;
         &lt;messages at="{current-merge-key()}"&gt;
            &lt;xsl:where-populated&gt;
               &lt;fax&gt;
                  &lt;xsl:for-each select="current-merge-group('fax')"&gt;
                     &lt;message xsl:expand-text="true"&gt;{
                        substring-after(., ' ')
                     }&lt;/message&gt;
                  &lt;/xsl:for-each&gt;   
               &lt;/fax&gt;
               &lt;mail&gt;
                  &lt;xsl:sequence select="current-merge-group('mail')/*"/&gt;
               &lt;/mail&gt;
            &lt;/xsl:where-populated&gt;   
         &lt;/messages&gt;   
      &lt;/xsl:merge-action&gt;
   &lt;/xsl:merge&gt;
&lt;/events&gt;</eg>
            </example>
         </div2>
         <div2 id="merge-keys">
            <head>Defining the Merge Keys</head>
            <p>The keys on which the input sequences are sorted are referred to as merge keys. If
               the attribute <code>sort-before-merge</code> has the value <code>yes</code>, the
               input sequences will be sorted into the correct sequence before the merge operation
               takes place (alternatively, the processor <rfc2119>may</rfc2119> use an algorithm
               that has the same effect as sorting followed by merging). If the attribute is absent
               or has the value <code>no</code>, then the input sequences <rfc2119>must</rfc2119>
               already be in the correct order.</p>
            <p>The merge key for each type of input sequence (that is, for each
                  <elcode>xsl:merge-source</elcode> element) is defined by a sequence of
                  <elcode>xsl:merge-key</elcode> element children of the
                  <elcode>xsl:merge-source</elcode> element. Each <elcode>xsl:merge-key</elcode>
               element defines one merge key component. The syntax and semantics of an
                  <elcode>xsl:merge-key</elcode> element are closely based on the rules for the
                  <elcode>xsl:sort</elcode> element (the only exception being the absence of the
                  <code>stable</code> attribute); the difference is that
                  <elcode>xsl:merge-key</elcode> elements do not cause a sort to take place, they
               merely declare the existing sort order of the input sequence.</p>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="merge-key">
               <e:attribute name="select">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="lang">
                  <e:attribute-value-template>
                     <e:data-type name="language"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="order">
                  <e:attribute-value-template>
                     <e:constant value="ascending"/>
                     <e:constant value="descending"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="collation">
                  <e:attribute-value-template>
                     <e:data-type name="uri"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="case-order">
                  <e:attribute-value-template>
                     <e:constant value="upper-first"/>
                     <e:constant value="lower-first"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="data-type">
                  <e:attribute-value-template>
                     <e:constant value="text"/>
                     <e:constant value="number"/>
                     <e:data-type name="eqname"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent name="merge-source"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <code>select</code> attribute and the contained <termref
                  def="dt-sequence-constructor">sequence constructor</termref> are mutually
               exclusive:</p>
            <p>
               <error spec="XT" type="static" class="SE" code="3200"><p>It is a <termref
                        def="dt-static-error">static error</termref> if an
                        <elcode>xsl:merge-key</elcode> element with a <code>select</code> attribute
                     has non-empty content.</p></error>
            </p>
            <p diff="add" at="S-bug28762">The value of <var>N</var>th merge key value of an item
                  <var>J</var> in a <termref def="dt-merge-input-sequence">merge input
                  sequence</termref>
               <var>S</var> is the result of the expression in the <code>select</code> attribute of
               the <var>N</var>th <elcode>xsl:merge-key</elcode> child of the corresponding
                  <elcode>xsl:merge-source</elcode> element, or in the absence of the
                  <code>select</code> attribute, the result of the contained <termref
                  def="dt-sequence-constructor"/>. This is evaluated with a <termref
                  def="dt-singleton-focus"/> based on <var>J</var>, or, if
                  <code>streamable=yes</code> is specified on the <elcode>xsl:merge-source</elcode>,
               a <termref def="dt-singleton-focus"/> based on a <function>snapshot</function> of
                  <var>J</var> (see <specref ref="streamable-merging"/>).</p>
            <note>
               <p>This means that <code>position()</code> and <code>last()</code> return 1 (one).
                  This differs from the way <elcode>xsl:sort</elcode> keys are evaluated, where
                     <code>position()</code> is the position in the unsorted sequence, and
                     <code>last()</code> is the size of the unsorted sequence.</p>
            </note>
            <p>The effect of the <elcode>xsl:merge-key</elcode> elements is defined in terms of the
               rules for an equivalent sequence of <elcode>xsl:sort</elcode> elements: if the rules
               for sorting (see <specref ref="sorting-process"/>) with <code>stable="yes"</code>
               would place an item <var>A</var> before an item <var>B</var> in the <termref
                  def="dt-sorted-sequence">sorted sequence</termref> produced by the sorting
               process, then <var>A</var> must precede <var>B</var> in the input sequence to the
               merging process.</p>
            <p>The merge keys of the various input sequences to a merge operation must be compatible
               with each other, since the merge operation will decide the ordering of the result
               sequence by comparing merge key values across input sequences. This means that across
               all the <elcode>xsl:merge-source</elcode> children of an <elcode>xsl:merge</elcode>
               instruction:</p>
            <ulist>
               <item>
                  <p>Each <elcode>xsl:merge-source</elcode> element <rfc2119>must</rfc2119> have the
                     same number of <elcode>xsl:merge-key</elcode> child elements; let this number
                     be <var>N</var>.</p>
               </item>
               <item>
                  <p>For each integer <var>J</var> in 1..<var>N</var>, consider the set of
                        <elcode>xsl:merge-key</elcode> elements that are in position <var>J</var>
                     among the <elcode>xsl:merge-key</elcode> children of their parent
                        <elcode>xsl:merge-source</elcode> element. All the
                        <elcode>xsl:merge-key</elcode> elements in this set <rfc2119>must</rfc2119>
                     have the same <termref def="dt-effective-value">effective value</termref> for
                     their <code>lang</code>, <code>order</code>, <code>collation</code>,
                        <code>case-order</code>, and <code>data-type</code> attributes, where having
                     the same effective value in this case means that either both attributes must be
                     absent, or both must be present and evaluate to the same value; and in addition
                     in the case of <code>collation</code> the absolute URI must be the same after
                     resolving against the base URI. </p>
               </item>
            </ulist>
            <p>If any of the attributes <code>lang</code>, <code>order</code>,
                  <code>collation</code>, <code>case-order</code>, or <code>data-type</code> are
                  <termref def="dt-attribute-value-template">attribute value templates</termref>,
               then their <termref def="dt-effective-value">effective values</termref> are evaluated
               using the <termref def="dt-focus">focus</termref> of the containing
                  <elcode>xsl:merge</elcode> instruction.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="2200"><p>It is a <termref
                        def="dt-static-error">static error</termref> if the number of
                        <elcode>xsl:merge-key</elcode> children of a
                        <elcode>xsl:merge-source</elcode> element is not equal to the number of
                        <elcode>xsl:merge-key</elcode> children of another
                        <elcode>xsl:merge-source</elcode> child of the same
                        <elcode>xsl:merge</elcode> instruction.</p></error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="2210"><p diff="chg" at="I">It is a
                        <termref def="dt-dynamic-error">dynamic error</termref> if there are two
                        <elcode>xsl:merge-key</elcode> elements that occupy corresponding positions
                     among the <elcode>xsl:merge-key</elcode> children of two different
                        <elcode>xsl:merge-source</elcode> elements and that have differing <termref
                        def="dt-effective-value">effective values</termref> for any of the
                     attributes <code>lang</code>, <code>order</code>, <code>collation</code>,
                        <code>case-order</code>, or <code>data-type</code>. Values are considered to
                     differ if the attribute is present on one element and not on the other, or if
                     it is present on both elements with <termref def="dt-effective-value">effective
                        values</termref> that are not equal to each other. In the case of the
                        <code>collation</code> attribute, the values are compared as absolute URIs
                     after resolving against the base URI. The error <rfc2119>may</rfc2119> be
                     reported statically if it is detected statically.</p></error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="2220"><p>It is a <termref
                        def="dt-dynamic-error">dynamic error</termref> if any input sequence to an
                        <elcode>xsl:merge</elcode> instruction contains two items that are not
                     correctly sorted according to the merge key values defined on the
                        <elcode>xsl:merge-key</elcode> children of the corresponding
                        <elcode>xsl:merge-source</elcode> element, when compared using the collation
                     rules defined by the attributes of the corresponding
                        <elcode>xsl:merge-key</elcode> children of the <elcode>xsl:merge</elcode>
                     instruction, unless the attribute <code>sort-before-merge</code> is present
                     with the value <code>yes</code>.</p></error>
            </p>
            <p>
               <error spec="XT" type="type" class="TE" code="2230"><p>It is a <termref
                        def="dt-type-error">type error</termref> if some item selected by a
                     particular merge key in one input sequence is not comparable using the XPath
                        <code>le</code> operator with some item selected by the corresponding sort
                     key in another input sequence.</p></error>
            </p>
         </div2>
         <div2 id="current-merge-group-and-key" diff="add" at="R-bug24510">
            <head>The Current Merge Group and Key</head>
            <p>During processing of an <elcode>xsl:merge</elcode> instruction, two additional values
               are available within the dynamic context:</p>
            <ulist>
               <item>
                  <p><termdef id="dt-current-merge-group" term="current merge group">The
                           <term>current merge group</term> is a <termref def="dt-map"/>. During
                        evaluation of an <elcode>xsl:merge</elcode> instruction, as each group of
                        items with equal <termref def="dt-composite-merge-key-value">composite merge
                           key values</termref> is processed, the current merge group is set to a
                        map whose keys are the names of the various merge sources, and whose
                        associated values are the items from each merge source having the relevant
                        composite merge key value.</termdef></p>
               </item>
               <item>
                  <p><termdef id="dt-current-merge-key" term="current merge key">The <term>current
                           merge key</term> is a sequence of atomic values. During evaluation of an
                           <elcode>xsl:merge</elcode> instruction, as each group of items with equal
                           <termref def="dt-composite-merge-key-value">composite merge key
                           values</termref> is processed, the current merge key is set to the
                        composite merge key value that these items have in common.</termdef></p>
               </item>
            </ulist>
            <p>These values are made available through the functions
                  <function>current-merge-group</function> and
                  <function>current-merge-key</function>.</p>
            <p diff="add" at="T-bug29697">The <termref def="dt-current-merge-group"/> and <termref
                  def="dt-current-merge-key"/> are available within the sequence constructor
               contained by an <elcode>xsl:merge-action</elcode> element. The values are initially
                  <termref def="dt-absent"/> during the evaluation of global variables and
               stylesheet parameters, during the evaluation of the <code>use</code> attribute or
               contained sequence constructor of <elcode>xsl:key</elcode>, and during the evaluation
               of the <code>initial-value</code> attribute of <elcode>xsl:accumulator</elcode> and
               the <code>select</code> attribute of contained sequence constructor of
                  <elcode>xsl:accumulator-rule</elcode>. All <termref def="dt-invocation-construct"
                  >invocation constructs</termref> set the <termref def="dt-current-merge-group"/>
               and <termref def="dt-current-merge-key"/> to <termref def="dt-absent"/>. </p>
            <note diff="add" at="T-bug29697">
               <p>Taken together, these rules mean that any invocation of
                     <function>current-merge-group</function> or
                     <function>current-merge-key</function> that is not lexically scoped by an
                     <elcode>xsl:merge-action</elcode> element will raise a dynamic error.</p>
            </note>
            <p diff="add" at="T-bug29697">When an inner <elcode>xsl:merge</elcode> instruction is
               lexically nested within the <elcode>xsl:merge-action</elcode> element of an outer
                  <elcode>xsl:merge</elcode> instruction, any use of
                  <function>current-merge-group</function> or <function>current-merge-key</function>
               that appears within the <elcode>xsl:merge-action</elcode> of the inner
                  <elcode>xsl:merge</elcode> instruction is a reference to the <termref
                  def="dt-current-merge-group"/> or <termref def="dt-current-merge-key"/> of the
               inner <elcode>xsl:merge</elcode> instruction, while any such reference that appears
               within the outer <elcode>xsl:merge-action</elcode> element, but not within the inner
                  <elcode>xsl:merge-action</elcode>, is a reference to the <termref
                  def="dt-current-merge-group"/> or <termref def="dt-current-merge-key"/> of the
               outer <elcode>xsl:merge</elcode> instruction. This means, for example, that a
               reference to the current merge group of the outer <elcode>xsl:merge</elcode> can
               appear in the <code>select</code> attribute of an <elcode>xsl:merge-source</elcode>
               child of the inner <elcode>xsl:merge</elcode>.</p>
            <p diff="add" at="T-bug29697">On completion of the evaluation of the
                  <elcode>xsl:merge-action</elcode> sequence constructor, the current merge group
               and current merge key revert to their previous values.</p>
            <div3 id="func-current-merge-group">
               <head>fn:current-merge-group</head>
               <glist>
                  <gitem>
                     <label>Summary</label>
                     <def>
                        <p>Returns the group of items currently being processed by an
                              <elcode>xsl:merge</elcode> instruction.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Signatures</label>
                     <def>
                        <example role="signature">
                           <proto name="current-merge-group" return-type="item()*" isOp="no"
                              prefix="fn" returnEmptyOk="no" returnSeq="no" returnVaries="no"
                              isSchema="no" isDatatype="no" isSpecial="no"/>
                        </example>
                        <example role="signature">
                           <proto name="current-merge-group" return-type="item()*" isOp="no"
                              prefix="fn" returnEmptyOk="no" returnSeq="no" returnVaries="no"
                              isSchema="no" isDatatype="no" isSpecial="no">
                              <arg name="source" type="xs:string"/>
                           </proto>
                        </example>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Properties</label>
                     <def>
                        <p>This function is <xtermref spec="FO30" ref="dt-deterministic"
                              >deterministic</xtermref>, <xtermref spec="FO30"
                              ref="dt-context-dependent">context-dependent</xtermref>, and <xtermref
                              spec="FO30" ref="dt-focus-independent">focus-independent</xtermref>.
                        </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Rules</label>
                     <def>
                        <p diff="chg" at="T-bug29697">The <termref def="dt-current-merge-group"/> is
                           bound during evaluation of the <elcode>xsl:merge-action</elcode> child of
                           an <elcode>xsl:merge</elcode> instruction. If no
                              <elcode>xsl:merge-action</elcode> is being evaluated, then the current
                           merge group is <termref def="dt-absent"/>, in which case the function
                           raises a dynamic error (see below).</p>
                        <p>The <termref def="dt-current-merge-group"/> (if not absent) is a <termref
                              def="dt-map"/>. It contains the set of items, from all merge inputs,
                           that share a common value for the merge key. This is structured as a map
                           so that the items from each merge source can be identified. The key in
                           the map is the value of the <code>name</code> attribute of the
                           corresponding <elcode>xsl:merge-source</elcode> element (or an invented
                           name, in its absence), and the associated value is the set of items
                           contributed by that merge group.</p>
                        <p>The map itself is not made visible, but this function returns values
                           derived from the map. Specifically, if the map is denoted by
                              <var>$G</var>:</p>
                        <ulist>
                           <item>
                              <p>The single-argument form of this function returns the value of the
                                 expression <code>if (map:contains($source)) then $G($source) else
                                    error()</code>. Informally, if there is an
                                    <elcode>xsl:merge-source</elcode> element whose
                                    <code>name</code> attribute matches <code>$source</code>, the
                                 function returns the items in the current merge group that are
                                 contributed by this merge source; otherwise it raises a dynamic
                                 error (see below).</p>
                           </item>
                           <item>
                              <p>The zero-argument form of the function returns the value of the
                                 expression <code>sort(map:keys($G))!$G(.)</code>, where the
                                    <code>sort()</code> function sorts the names of
                                    <elcode>xsl:merge-source</elcode> elements into the document
                                 order of the <elcode>xsl:merge-source</elcode> elements in the
                                 stylesheet. Informally, it returns all the items in the current
                                 merge group regardless of which merge source they derive from.</p>
                           </item>
                        </ulist>
                        <p>Within the <termref def="dt-current-merge-group"/>, the ordering of items
                           from the input sequences is as follows, in major-to-minor order:</p>
                        <ulist>
                           <item>
                              <p>Items are first ordered by the <elcode>xsl:merge-source</elcode>
                                 element that defined the input sequence from which the item was
                                 taken; items from <elcode>xsl:merge-source</elcode>
                                 <var>A</var> precede items from <elcode>xsl:merge-source</elcode>
                                 <var>B</var> if <var>A</var> precedes <var>B</var> in document
                                 order within the stylesheet.</p>
                           </item>
                           <item>
                              <p>Items from different input sequences selected by the same
                                    <elcode>xsl:merge-source</elcode> element are then ordered based
                                 on the order of the anchor items in the sequence selected by
                                 evaluating the <code>select</code> attribute of the
                                    <elcode>xsl:merge-source</elcode> element.</p>
                           </item>
                           <item>
                              <p>Finally, duplicate items from the same input sequence retain their
                                 order from the input sequence.</p>
                           </item>
                        </ulist>
                        <p diff="add" at="L">Duplicates are not eliminated: for example, if the same
                           node is selected in more than one input sequence, it may appear twice in
                           the current <phrase diff="chg" at="R-bug26680">merge</phrase> group.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Error Conditions</label>
                     <def>
                        <p>
                           <error spec="XT" type="static" class="SE" code="3470"><p>It is a <termref
                                    def="dt-static-error">static error</termref> if the
                                    <function>current-merge-group</function> function is used within
                                 a <termref def="dt-pattern">pattern</termref>.</p></error>
                        </p>
                        <p>
                           <error spec="XT" type="dynamic" class="DE" code="3480"><p>It is a
                                    <termref def="dt-dynamic-error">dynamic error</termref> if the
                                    <function>current-merge-group</function> function is used when
                                 the current merge group is <termref def="dt-absent"
                                    >absent</termref>. The error <rfc2119>may</rfc2119> be reported
                                 statically if it can be detected statically.</p></error>
                        </p>
                        <p>
                           <error spec="XT" type="dynamic" class="DE" code="3490"><p>It is a
                                    <termref def="dt-dynamic-error">dynamic error</termref> if the
                                    <code>$source</code> argument of the
                                    <function>current-merge-group</function> function does not match
                                 the <code>name</code> attribute of any
                                    <elcode>xsl:merge-source</elcode> element for the current merge
                                 operation. The error <rfc2119>may</rfc2119> be reported statically
                                 if it can be detected statically.</p></error>
                        </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Notes</label>
                     <def>
                        <p role="note">Because the <termref def="dt-current-merge-group"/> is
                           cleared by function calls and template calls, the
                              <function>current-merge-group</function> function only has useful
                           effect when the call appears as a descendant of an
                              <elcode>xsl:merge-action</elcode> element.</p>
                        <p role="note">If an <elcode>xsl:merge-source</elcode> element has no
                              <code>name</code> attribute, then it is not possible to discover the
                           items in the current merge group that derive specifically from that
                           source, but these items will still be present in the current merge group,
                           and will be included in the result when the function is called with no
                           arguments.</p>
                        <p role="note">Like other XSLT extensions to the dynamic evaluation context,
                           the <termref def="dt-current-merge-group"/> is not retained as part of
                           the closure of a function value. This means that the expression
                              <code>current-merge-group#0</code> is valid and returns a function
                           value, but any invocation of this function will fail with a dynamic error
                              <errorref spec="XT" class="DE" code="3480"/>. </p>
                     </def>
                  </gitem>
               </glist>
            </div3>
            <div3 id="func-current-merge-key">
               <head>fn:current-merge-key</head>
               <glist>
                  <gitem>
                     <label>Summary</label>
                     <def>
                        <p>Returns the <phrase diff="chg" at="R-bug26680">merge</phrase> key of the
                              <phrase diff="add" at="R-bug26680">merge</phrase> group currently
                           being processed using the <elcode>xsl:merge</elcode> instruction.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Signature</label>
                     <def>
                        <example role="signature">
                           <proto name="current-merge-key" return-type="xs:anyAtomicType*" isOp="no"
                              prefix="fn" returnEmptyOk="no" returnSeq="no" returnVaries="no"
                              isSchema="no" isDatatype="no" isSpecial="no"/>
                        </example>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Properties</label>
                     <def>
                        <p>This function is <xtermref spec="FO30" ref="dt-deterministic"
                              >deterministic</xtermref>, <xtermref spec="FO30"
                              ref="dt-context-dependent">context-dependent</xtermref>, and <xtermref
                              spec="FO30" ref="dt-focus-independent">focus-independent</xtermref>.
                        </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Rules</label>
                     <def>
                        <p>The evaluation context for XPath <termref def="dt-expression"
                              >expressions</termref> includes a component called the <termref
                              def="dt-current-merge-key"/>, which is a sequence of atomic values.
                           The current merge key is the <termref def="dt-composite-merge-key-value"
                              >composite merge key value</termref> shared in common by all the items
                           within the <termref def="dt-current-merge-group">current merge
                              group</termref>. </p>
                        <p>The function <function>current-merge-key</function> returns the <termref
                              def="dt-current-merge-key">current merge key</termref>.</p>
                        <p diff="chg" at="T-bug29697">While the <elcode>xsl:merge-action</elcode>
                           child of an <elcode>xsl:merge</elcode> instruction is being evaluated,
                           the <phrase diff="chg" at="R-bug26680"><termref
                                 def="dt-current-merge-key"/></phrase> will be a single atomic value
                           if there is a single merge key, or a sequence of atomic values if there
                           are multiple merge keys.</p>
                        <p>At other times, the current merge key will be <termref def="dt-absent"
                              >absent</termref>.</p>
                        <p><phrase diff="chg" at="D">The <phrase diff="chg" at="R-bug26680"><termref
                                    def="dt-composite-merge-key-value">merge keys</termref></phrase>
                              of all items in a group are not necessarily identical. For example,
                              one might be an <code>xs:float</code> while another is a numerically
                              equal <code>xs:decimal</code></phrase>. The <phrase diff="chg"
                              at="R-bug26680"><function>current-merge-key</function></phrase>
                           function <phrase diff="chg" at="F">returns</phrase> the <phrase
                              diff="chg" at="R-bug26680">merge</phrase> key of the first item in the
                           group, after atomization and casting of <code>xs:untypedAtomic</code>
                           values to <code>xs:string</code>.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Error Conditions</label>
                     <def>
                        <p>
                           <error spec="XT" type="static" class="SE" code="3500"><p>It is a <termref
                                    def="dt-static-error">static error</termref> if the
                                    <function>current-merge-key</function> function is used within a
                                    <termref def="dt-pattern">pattern</termref>.</p></error>
                        </p>
                        <p diff="add" at="K">
                           <error spec="XT" type="dynamic" class="DE" code="3510"><p>It is a
                                    <termref def="dt-dynamic-error">dynamic error</termref> if the
                                    <function>current-merge-key</function> function is used when the
                                 current <phrase diff="chg" at="R-bug26680">merge</phrase> key is
                                    <termref def="dt-absent">absent</termref>, or when it is invoked
                                 in the course of evaluating a pattern. The error
                                    <rfc2119>may</rfc2119> be reported statically if it can be
                                 detected statically.</p></error>
                        </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Notes</label>
                     <def>
                        <p role="note">Like other XSLT extensions to the dynamic evaluation context,
                           the <termref def="dt-current-merge-key"/> is not retained as part of the
                           closure of a function value. This means that the expression <phrase
                              diff="chg" at="R-bug26680"><code>current-merge-key#0</code></phrase>
                           is valid and returns a function value, but any invocation of this
                           function will fail with a dynamic error <errorref spec="XT" class="DE"
                              code="3510"/>. </p>
                     </def>
                  </gitem>
               </glist>
            </div3>
         </div2>
         <div2 id="merge-action">
            <head>The <elcode>xsl:merge-action</elcode> Element</head>
            <p>The <elcode>xsl:merge-action</elcode> child of an <elcode>xsl:merge</elcode>
               instruction defines the processing to be applied for each distinct <termref
                  def="dt-composite-merge-key-value"/> found in the input sequences to the
                  <elcode>xsl:merge</elcode> instruction.</p>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="merge-action">
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent name="merge"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The merge key values for each item in an input sequence are calculated based on the
               corresponding <elcode>xsl:merge-key</elcode> elements, in the same way as <termref
                  def="dt-sort-key-value">sort key values</termref> are calculated using a sequence
               of <elcode>xsl:sort</elcode> elements (see <specref ref="sorting-process"/>). If
               several items from the same or from different input sequences have the same values
               for all their merge keys (comparing pairwise), then they are considered to form a
               group. The sequence constructor contained in the <elcode>xsl:merge-action</elcode>
               element is evaluated once for each such group of items, and the result of the
                  <elcode>xsl:merge</elcode> instruction is the concatenation of the results
               obtained by processing each group in turn.</p>
            <p><phrase diff="chg" at="F">The groups are processed one by one, based on the values of
                  the merge keys for the group.</phrase> If group <var>G</var> has a set of merge
               key values <var>M</var>, while group <var>H</var> has a set of merge key values
                  <var>N</var>, then in the result of the <elcode>xsl:merge</elcode> instruction,
               the result of processing group <var>G</var> will precede the result of processing
                  <var>H</var> if and only if <var>M</var> precedes <var>N</var> in the sort order
               defined by the <code>lang</code>, <code>order</code>, <code>collation</code>,
                  <code>case-order</code>, and <code>data-type</code> attributes of the merge key
               definitions.</p>
            <p>Generally, two sets of merge key values are distinct if any corresponding items in
               the two sets of values do not compare equal under the rules for the XPath
                  <code>eq</code> operator, under the collating rules for the corresponding merge
               key definition. In rare cases, when considering more than two sets of merge key
               values, ambiguities may arise because of the non-transitivity of the <code>eq</code>
               operator when applied across different numeric types. In this situation, the
               partitioning of items into sets having distinct key values is handled in the same way
               as for <elcode>xsl:for-each-group</elcode> (see <specref ref="non-transitivity"/>),
               and is to some extent <termref def="dt-implementation-dependent"
                  >implementation-dependent</termref>. </p>
            <p diff="del" at="R-bug24510">The static context for the sequence constructor contained
               within the <elcode>xsl:merge-action</elcode> element includes the variables declared
               using the <code>bind-group</code> and <code>bind-key</code> attributes of the
               containing <elcode>xsl:merge</elcode> instruction and the <code>bind-source</code>
               attributes of the <elcode>xsl:merge-source</elcode> children of this
                  <elcode>xsl:merge</elcode> instruction.</p>
            <p diff="del" at="R-bug24510">[XTSE3270] It is a <termref def="dt-static-error">static
                  error</termref> if the set of variable names declared using the
                  <code>bind-group</code> and <code>bind-key</code> attributes of an
                  <elcode>xsl:merge</elcode> instruction and the <code>bind-source</code> attributes
               of its <elcode>xsl:merge-source</elcode> children contains any duplicates.</p>
            <p diff="del" at="R-bug24510">The variable defined in the <code>bind-key</code>
               attribute, if any, is bound to the value of the <termref
                  def="dt-composite-merge-key-value"/>. There may be several input items having
               merge keys that are equal but distinguishable (for example the number 1.0 as a float
               and as a double, or the strings <code>"A"</code> and <code>"a"</code> under a
               case-blind collation); in this case the value of the variable is the value of the
               merge key computed for the first item in the current group, after atomization and
               casting of <code>xs:untypedAtomic</code> to <code>xs:string</code>.</p>
            <p diff="del" at="R-bug24510">The variable defined in the <code>bind-group</code>
               attribute, if any, is bound to the set of items (zero or more from each input
               sequence) that have this set of values as their merge key value. The value of this
               variable is referred to as the <term>current group</term>.</p>
            <p diff="del" at="R-bug24510">The variable defined in the <code>bind-source</code>
               attribute of an <elcode>xsl:merge-source</elcode> element, if any, is bound to the
               current group, filtered to include only those items that originate from the merge
               source in question.</p>
            <p>The <termref def="dt-focus">focus</termref> for evaluation of the sequence
               constructor contained in the <elcode>xsl:merge-action</elcode> element is as
               follows:</p>
            <ulist>
               <item>
                  <p>The <termref def="dt-context-item">context item</termref> is the first item in
                     the <phrase diff="chg" at="S-bug28191">group being processed, that is
                           <code>current-merge-group()[1]</code></phrase></p>
               </item>
               <item>
                  <p>The <termref def="dt-context-position">context position</termref> is the
                     position of the current group within the sequence of groups (so the first
                     evaluation of <elcode>xsl:merge-action</elcode> has <code>position()=1</code>,
                     the second has <code>position()=2</code>, and so on).</p>
               </item>
               <item>
                  <p>The <termref def="dt-context-size">context size</termref> is as follows:</p>
                  <ulist>
                     <item>
                        <p diff="chg" at="S-bug29120">If any of the
                              <elcode>xsl:merge-source</elcode> elements within the
                              <elcode>xsl:merge</elcode> instruction specifies
                              <code>streamable="yes"</code> (explicitly or implicitly), then
                           absent.</p>
                        <note>
                           <p>This means that within the <elcode>xsl:merge-action</elcode> of a
                              streamable <elcode>xsl:merge</elcode>, calling <code>last()</code>
                              throws error <xerrorref spec="XP30" class="DY" code="0002"/>.</p>
                        </note>
                     </item>
                     <item>
                        <p>Otherwise, the number of groups, that is, the number of distinct sets of
                           merge key values. </p>
                     </item>
                  </ulist>
               </item>
            </ulist>
            <example>
               <head>Selective Processing of Merge Inputs</head>
               <p>Consider a situation where there are two merge sources, named
                     <code>"master"</code> and <code>"update"</code>; the master source identifies a
                  single merge input file (the master file), while the update source identifies a
                  set of <var>N</var> update files, perhaps one for each day of the week. The
                  required logic is that if a merge key is present only in the master file, then the
                  corresponding item should be copied to the output; if it is present in a single
                  update file then that item replaces the corresponding item from the master file;
                  if it is present in several update files, then an error is raised. This can be
                  achieved as follows:</p>
               <eg diff="chg" at="R-bug24343" role="xslt-instruction" xml:space="preserve">&lt;xsl:merge&gt;
  &lt;xsl:merge-source name="master" 
                    for-each-source="'master.xml'"
                    streamable="yes"
                    select="/events/event"&gt;
      &lt;xsl:merge-key select="@key"/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-source name="updates" 
                    for-each-source="uri-collection('updates')"
                    streamable="yes"
                    select="/events/event-change"&gt;
      &lt;xsl:merge-key select="@affected-key"/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="empty(current-merge-group('master'))"&gt;
        &lt;xsl:message&gt;
           Error: update is present with no matching master record!
        &lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="empty(current-merge-group('updates'))"&gt;
        &lt;xsl:copy-of select="current-merge-group('master')"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="count(current-merge-group('updates')) = 1"&gt;
        &lt;xsl:copy-of select="current-merge-group('updates')"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:message&gt;
           Conflict: multiple updates for the same master record!
        &lt;/xsl:message&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:merge-action&gt;
&lt;/xsl:merge&gt;
            </eg>
               <p>Some words of explanation:</p>
               <ulist>
                  <item>
                     <p diff="chg" at="H">Error messages are produced if there is an update element
                        whose key does not correspond to any element in the master source, or if
                        there is more than one update element corresponding to the same master
                        element.</p>
                  </item>
                  <item>
                     <p diff="chg" at="H">In the absence of errors, if there is a single update
                        element then it is copied to the output; if there is none, then the master
                        element is copied.</p>
                  </item>
               </ulist>
            </example>
         </div2>
         <div2 id="merge-examples">
            <head>Examples of xsl:merge</head>
            <p>Previous sections introduced examples designed to illustrate some specific features
               of the <elcode>xsl:merge</elcode> instruction. This section provides some further
               examples to illustrate different ways in which the instruction can be used.</p>
            <example>
               <head>Applying Transactions to a Master File</head>
               <p>This example applies transactions from a transaction file to a master file.
                  Records in the master file for which there is no corresponding transaction are
                  copied unchanged. The transaction file contains instructions to delete, replace,
                  or insert records identified by an ID value. The master file is known to be sorted
                  on the ID value; the transaction file is unsorted.</p>
               <p>Master file document structure:</p>
               <eg xml:space="preserve" role="xml">&lt;data&gt;
  &lt;record ID="A0001"&gt;...&lt;/record&gt;
  &lt;record ID="A0002"&gt;...&lt;/record&gt;
  &lt;record ID="A0003"&gt;...&lt;/record&gt;
&lt;/data&gt;</eg>
               <p>Transaction file document structure:</p>
               <eg xml:space="preserve" role="xml">&lt;transactions&gt;
  &lt;update record="A0004" action="insert"&gt;...&lt;/update&gt;
  &lt;update record="A0002" action="delete"/&gt;
  &lt;update record="A0003" action="replace"&gt;...&lt;/update&gt;
&lt;/transactions&gt;</eg>
               <p>Solution:</p>
               <eg xml:space="preserve" role="xslt-instruction">
 &lt;xsl:merge&gt;
  &lt;xsl:merge-source name="master" 
                    select="doc('master.xml')/data/record"&gt;
      &lt;xsl:merge-key select="@ID"/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-source name="updates"
                    sort-before-merge="yes"
                    select="doc('transactions.xml')/transactions/update"&gt;     
      &lt;xsl:merge-key select="@record"/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="empty(current-merge-group('updates'))"&gt;
        &lt;xsl:copy-of select="current-merge-group('master')"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="current-merge-group('updates')/@action=('insert', 'replace')"&gt;
        &lt;record ID="{current-merge-key()}"&gt;
          &lt;xsl:copy-of select="current-merge-group('updates')/*"/&gt;
        &lt;/record&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="current-merge-group('updates')/@action='delete'"/&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:merge-action&gt;
  &lt;/xsl:merge&gt;</eg>
            </example>
            <example>
               <head>Merging Two Sequences of Numbers</head>
               <p>The <elcode>xsl:merge</elcode> instruction can be used to determine the union,
                  intersection, or difference of two sequences of numbers (or other atomic values).
                  This code gives the union:</p>
               <eg diff="chg" at="R-bug24510" role="xslt-instruction" xml:space="preserve">&lt;xsl:merge&gt;
  &lt;xsl:merge-source select="1 to 30"&gt;
      &lt;xsl:merge-key select="."/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-source select="20 to 40"&gt;
      &lt;xsl:merge-key select="."/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:sequence select="current-merge-key()"/&gt;
  &lt;/xsl:merge-action&gt;
&lt;/xsl:merge&gt;
               </eg>
               <p>While this gives the intersection:</p>
               <eg diff="chg" at="R-bug24510" role="xslt-instruction" xml:space="preserve">&lt;xsl:merge&gt;
  &lt;xsl:merge-source select="1 to 30"&gt;
      &lt;xsl:merge-key select="."/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-source select="20 to 40"&gt;
      &lt;xsl:merge-key select="."/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:if test="count(current-merge-group()) eq 2"&gt;
      &lt;xsl:sequence select="current-merge-key()"/&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:merge-action&gt;
&lt;/xsl:merge&gt;
               </eg>
            </example>
         </div2>
      </div1>
      <div1 id="splitting" diff="add" at="B">
         <head>Splitting</head>
         <p>Sometimes it is convenient to be able to compute multiple results during a single scan
            of the input data. For example, a transformation may wish to rename selected elements,
            and also to output a count of how many elements have been renamed. Traditionally in a
            functional language this means computing two separate functions of the input sequence,
            which (in the absence of sophisticated optimization) will result in the input being
            scanned twice. This is inconsistent with streaming, where the input is only available to
            be scanned once, and it can also lead to poor performance in non-streaming
            applications.</p>
         <p>To meet this requirement, XSLT 3.0 introduces the instruction <elcode>xsl:fork</elcode>.
            The content of this instruction is a <phrase diff="add" at="L">restricted form
               of</phrase>
            <termref def="dt-sequence-constructor">sequence constructor</termref>, and in a formal
            sense the effect of the instruction is simply to return the result of evaluating the
            sequence constructor. However, the presence of the instruction affects the analysis of
            streamability (see <specref ref="streamability"/>). In particular, when
               <elcode>xsl:fork</elcode> is used in a context where streaming is required, each
            independent instruction within the sequence constructor must be streamable, but the
            analysis assumes that these instructions can all be evaluated during a single pass of
            the streamed input document.</p>
         <note>
            <p>The semantics of the instruction require a number of result sequences to be computed
               during a single pass of the input. A processor may interpret this as a request to use
               multiple threads. However, implementations using a single thread are feasible, and
               this instruction is not intended primarily as a means for stylesheet authors to
               express their intentions with regard to multi-threaded execution.</p>
         </note>
         <note>
            <p>Because multiple results are computed during a single pass of the input, and then
               concatenated into a single sequence, this instruction will generally involve some
               buffering of results. The amount of memory used should not exceed that needed to hold
               the results of the instruction. However, within this principle, implementations may
               adopt a variety of strategies for evaluation; for example, there may be cases where
               buffering of the input is more efficient than buffering of output.</p>
            <p>Generally, stylesheet authors indicate that buffering of input is the preferred
               strategy by using the <function>copy-of</function> or <function>snapshot</function>
               functions, and indicate that buffering of output is preferred by using
                  <elcode>xsl:fork</elcode>. However, conformant processors are not constrained in
               their choice of evaluation strategies.</p>
         </note>
         <p diff="del" at="L">The <elcode>xsl:sequence</elcode> instruction may be used as a child
            of <elcode>xsl:fork</elcode> to break the instructions within <elcode>xsl:fork</elcode>
            into a number of separate groups, each of which is considered as (and indeed is) a
            separate instruction operating in a single pass over the data.</p>
         <p diff="add" at="R-bug24317">The content model of the <elcode>xsl:fork</elcode>
            instruction (given that an XSLT 3.0 processor ignores <elcode>xsl:fallback</elcode>)
            takes two possible forms:</p>
         <olist diff="add" at="R-bug24317">
            <item>
               <p>A sequence of <elcode>xsl:sequence</elcode> instructions</p>
            </item>
            <item>
               <p>A single <elcode>xsl:for-each-group</elcode> instruction. This will normally use
                  the <code>group-by</code> attribute, because in all other cases the containing
                     <elcode>xsl:fork</elcode> instruction has no useful effect.</p>
            </item>
         </olist>
         <p diff="add" at="R-bug24317">The first form is appropriate when splitting a single input
            stream into a fixed number of output streams, known statically: for example, one output
            stream for credit transactions, a second for debit transactions. The second form is
            appropriate when the number of output streams depends on the data: for example, one
            output stream for each distinct city name found in the input data.</p>
         <p>The following section describes the <elcode>xsl:fork</elcode> instruction more
            formally.</p>
         <div2 id="fork-instruction" diff="chg" at="K">
            <head>The <code>xsl:fork</code> Instruction</head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="fork">
               <e:in-category name="instruction"/>
               <e:sequence>
                  <e:element name="fallback" repeat="zero-or-more"/>
                  <e:choice>
                     <e:sequence repeat="zero-or-more">
                        <e:element name="sequence"/>
                        <e:element name="fallback" repeat="zero-or-more"/>
                     </e:sequence>
                     <e:sequence>
                        <e:element name="for-each-group"/>
                        <e:element name="fallback" repeat="zero-or-more"/>
                     </e:sequence>
                  </e:choice>
               </e:sequence>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <note diff="add" at="R-bug24317">
               <p>The content model can be described as follows: there is either a single
                     <elcode>xsl:for-each-group</elcode> instruction, or a sequence of zero or more
                     <elcode>xsl:sequence</elcode> instructions; in addition,
                     <elcode>xsl:fallback</elcode> instructions may be added anywhere.</p>
            </note>
            <p>The result of the <elcode>xsl:fork</elcode> instruction is the sequence formed by
               concatenating the results of evaluating each of its contained <phrase diff="del"
                  at="R-bug24317"><elcode>xsl:sequence</elcode></phrase> instructions, in order.
               That is, the result can be determined by treating the content as a <termref
                  def="dt-sequence-constructor">sequence constructor</termref> and evaluating it as
               such.</p>
            <note>
               <p>Any <elcode>xsl:fallback</elcode> children will be ignored by an XSLT 3.0
                  processor.</p>
            </note>
            <p diff="chg" at="R-bug24317">By using the <elcode>xsl:fork</elcode> instruction, the
               stylesheet author is suggesting to the <termref def="dt-processor"
                  >processor</termref> that buffering of output is acceptable even though this might
               use unbounded memory and thus violate the normal expectations of streamable
               processing</p>
            <p>The presence of an <elcode>xsl:fork</elcode> instruction affects the analysis of
               streamability, as described in <specref ref="streamability"/>.</p>
         </div2>
         <div2 id="splitting-examples">
            <head>Examples of Splitting with Streamed Data</head>
            <p>This section gives examples of how splitting using <elcode>xsl:fork</elcode> can be
               used to enable streaming of input documents in cases where several results need to be
               computed during a single pass over the input data.</p>
            <example>
               <head>Splitting a Transaction File into Credits and Debits</head>
               <p>Consider a transaction file that contains a sequence of debits and credits:</p>
               <eg role="xml" xml:space="preserve">&lt;transactions&gt;
  &lt;transaction value="5.60"/&gt;
  &lt;transaction value="11.20"/&gt;
  &lt;transaction value="-3.40"/&gt;
  &lt;transaction value="8.90"/&gt;
  &lt;transaction value="-1.99"/&gt;
&lt;/transactions&gt;</eg>
               <p>where the requirement is to split this into two separate files containing credits
                  and debits respectively.</p>
               <p>This can be achieved in <termref def="dt-guaranteed-streamable"/> code as
                  follows:</p>
               <eg diff="chg" at="S-bug27011" role="xslt-instruction" xml:space="preserve">
&lt;xsl:source-document streamable="yes" href="transactions.xml"&gt;
  &lt;xsl:fork&gt;
    &lt;xsl:sequence&gt;
      &lt;xsl:result-document href="credits.xml"&gt;
        &lt;credits&gt;
          &lt;xsl:for-each select="transactions/transaction[@value &amp;gt;= 0]"&gt;
            &lt;xsl:copy-of select="."/&gt;
          &lt;/xsl:for-each&gt;
        &lt;/credits&gt;
      &lt;/xsl:result-document&gt;
    &lt;/xsl:sequence&gt;
    &lt;xsl:sequence&gt;
      &lt;xsl:result-document href="debits.xml"&gt;
        &lt;debits&gt;
          &lt;xsl:for-each select="transactions/transaction[@value &amp;lt; 0]"&gt;
            &lt;xsl:copy-of select="."/&gt;
          &lt;/xsl:for-each&gt;
        &lt;/debits&gt;
      &lt;/xsl:result-document&gt;
    &lt;/xsl:sequence&gt;  
  &lt;/xsl:fork&gt;
&lt;/xsl:source-document&gt;
               </eg>
               <p>In the absence of the <elcode>xsl:fork</elcode> instruction, this would not be
                  streamable, because the sequence constructor includes two <termref
                     def="dt-consuming"/> instructions. With the addition of the
                     <elcode>xsl:fork</elcode> instruction, however, each
                     <elcode>xsl:result-document</elcode> instruction is allowed to make a downwards
                  selection. </p>
               <p>One possible implementation model for this is as follows: a single thread reads
                  the source document, and sends parsing events such as start-element and
                  end-element to two other threads, each of which is writing one of the two result
                  documents. Each of these implements the downwards-selecting path expression using
                  a process that waits until the next <code>transaction</code> start-element event
                  is received; when this event is received, the process examines the
                     <code>@value</code> attribute to determine whether or not this transaction is
                  to be copied; if it is, then all events until the matching
                     <code>transaction</code> end-element event are copied to the serializer for the
                  result document; otherwise, these events are discarded.</p>
            </example>
            <example diff="add" at="R-bug24317">
               <head>Splitting a Transaction File by Customer Account</head>
               <p>Consider a transaction file that contains a sequence of debits and credits:</p>
               <eg role="xml" xml:space="preserve">&lt;transactions&gt;
  &lt;transaction value="5.60" account="01826370"/&gt;
  &lt;transaction value="11.20" account="92741838"/&gt;
  &lt;transaction value="-3.40" account="01826370"/&gt;
  &lt;transaction value="8.90" account="92741838"/&gt;
  &lt;transaction value="-1.99" account="43861562"/&gt;
&lt;/transactions&gt;</eg>
               <p>where the requirement is to split this into a number of separate files, one for
                  each account number found in the input.</p>
               <p>This can be achieved in <termref def="dt-guaranteed-streamable"/> code as
                  follows:</p>
               <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:source-document streamable="yes" href="transactions.xml"&gt;
  &lt;xsl:fork&gt;
    &lt;xsl:for-each-group select="transactions/transaction" group-by="@account"&gt;
      &lt;xsl:result-document href="account{current-grouping-key()}.xml"&gt;
        &lt;transactions account="{current-grouping-key()}"&gt;
          &lt;xsl:copy-of select="current-group()"/&gt;
        &lt;/transactions&gt;
      &lt;/xsl:result-document&gt;
    &lt;/xsl:for-each-group&gt;
  &lt;/xsl:fork&gt;
&lt;/xsl:source-document&gt;
               </eg>
               <p>In the absence of the <elcode>xsl:fork</elcode> instruction, this would not be
                  streamable, because in the general case the output of
                     <elcode>xsl:for-each-group</elcode> with a <code>group-by</code> attribute
                  needs to be buffered. (The streamability rules do not recognize an
                     <elcode>xsl:for-each-group</elcode> whose body comprises an
                     <elcode>xsl:result-document</elcode> instruction as a special case.) With the
                  addition of the <elcode>xsl:fork</elcode> instruction, however, the code becomes
                  guaranteed streamable. </p>
               <p>One possible implementation model for this is as follows: the processor opens a
                  new serializer each time a new account number is encountered in the input, and
                  writes the <code>&lt;transactions&gt;</code> start tag to the serializer. When a
                     <code>transaction</code> element is encountered in the input, it is copied to
                  the relevant serializer, according to the value of the <code>account</code>
                  attribute. At the end of the input, a <code>&lt;transactions&gt;</code> end tag is
                  written to each of the serializers, and each output file is closed.</p>
               <p>In the more general case, where the body of the
                     <elcode>xsl:for-each-group</elcode> instruction contributes output to the
                  principal result document, the output generated by processing each group needs to
                  be buffered in memory. The requirement to use <elcode>xsl:fork</elcode> exists so
                  that this use of (potentially unbounded) memory has to be a conscious decision by
                  the stylesheet author.</p>
            </example>
            <example diff="add" at="L">
               <head>Arithmetic using Multiple Child Elements as Operands</head>
               <p>The rules for streamability do not allow two instructions in a sequence
                  constructor to both read child or descendant elements of the context node, which
                  makes it tricky to perform a calculation in which multiple child elements act as
                  operands. This restriction can be avoided by using <elcode>xsl:fork</elcode>, as
                  shown below, where each of the two branches of the <elcode>xsl:fork</elcode>
                  instruction selects children of the context node.</p>
               <eg role="xslt-declaration" xml:space="preserve">
&lt;xsl:template match="order" mode="a-streamable-mode"&gt;                  
  &lt;xsl:variable name="price-and-discount" as="xs:decimal+"&gt;
    &lt;xsl:fork&gt;
      &lt;xsl:sequence select="xs:decimal(price)"/&gt;
      &lt;xsl:sequence select="xs:decimal(discount)"/&gt;
    &lt;/xsl:fork&gt;
  &lt;/xsl:variable&gt;
  &lt;xsl:value-of select="$price-and-discount[1] - $price-and-discount[2]"/&gt;
  &lt;/xsl:template&gt;</eg>
               <p>A possible implementation strategy here is for events from the XML parser to be
                  sent to two separate agents (perhaps but not necessarily running in different
                  threads), one of which computes <code>xs:decimal(price)</code> and the other
                     <code>xs:decimal(discount)</code>; on completion the results computed by the
                  two agents are appended to the sequence that forms the value of the variable.</p>
               <p>With this strategy, the processor would require sufficient memory to hold the
                  results of evaluating each branch of the fork. If these results (unlike this
                  example) are large, this could defeat the purpose of streaming by requiring large
                  amounts of memory; nevertheless, this code is treated as streamable.</p>
               <note>
                  <p>An alternative solution to this requirement is to use map constructors: see
                        <specref ref="map-constructors"/>.</p>
               </note>
            </example>
            <example>
               <head>Deleting Elements, and Counting Deletions</head>
               <p>In this example the input is a narrative document containing <code>note</code>
                  elements at any level of nesting. The requirement is to output a copy of the input
                  document in which (a) the <code>note</code> elements have been removed, and (b) a
                     <code>footnote</code> is added at the end indicating how many <code>note</code>
                  elements have been deleted.</p>
               <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:mode on-no-match="shallow-copy" streamable="yes"/&gt;

&lt;xsl:template match="note"/&gt;

&lt;xsl:template match="/*"&gt;
  &lt;xsl:fork&gt;
    &lt;xsl:sequence&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xsl:sequence&gt;
    &lt;xsl:sequence&gt;
      &lt;footnote&gt;
        &lt;p&gt;Removed &lt;xsl:value-of select="count(.//note)"/&gt; 
                 note elements.&lt;/p&gt;
      &lt;/footnote&gt;
    &lt;/xsl:sequence&gt;  
  &lt;/xsl:fork&gt;
&lt;/xsl:template&gt;
               </eg>
               <p>The <elcode>xsl:fork</elcode> instruction contains two independent branches. These
                  can therefore be evaluated in the same pass over the input data. The first branch
                  (the <elcode>xsl:apply-templates</elcode> instruction) causes everything except
                  the <code>note</code> elements to be copied to the result; the second instruction
                  (the literal result element <code>footnote</code>) outputs a count of the number
                  of descendant <code>note</code> elements.</p>
               <p>Note that although the processing makes a single pass over the input stream, there
                  is some buffering of results required, because the results of the instructions
                  within the <elcode>xsl:fork</elcode> instruction need to be concatenated. In this
                  case an intelligent implementation might be able to restrict the buffered data to
                  a single integer.</p>
               <p>In a formal sense, however, the result is exactly the same as if the
                     <elcode>xsl:fork</elcode> element were not there.</p>
               <p diff="add" at="K">An alternative way of solving this example problem would be to
                  count the number of <code>note</code> elements using an accumulator: see <specref
                     ref="accumulators"/>.</p>
            </example>
         </div2>
      </div1>
      <div1 id="regular-expressions">
         <head>Regular Expressions</head>
         <p>The function library for XPath 3.0 defines <phrase diff="chg" at="R-bug24618"
               >several</phrase> functions that make use of regular expressions:</p>
         <ulist>
            <item>
               <p>
                  <xfunction>matches</xfunction> returns a boolean result that indicates whether or
                  not a string matches a given regular expression.</p>
            </item>
            <item>
               <p>
                  <xfunction>replace</xfunction> takes a string as input and returns a string
                  obtained by replacing all substrings that match a given regular expression with a
                  replacement string.</p>
            </item>
            <item>
               <p>
                  <xfunction>tokenize</xfunction> returns a sequence of strings formed by breaking a
                  supplied input string at any separator that matches a given regular
                  expression.</p>
            </item>
            <item diff="add" at="R-bug24618">
               <p>
                  <xfunction>analyze-string</xfunction> returns a tree of nodes that effectively add
                  markup to a string indicating the parts of the string that matched the regular
                  expression, as well as its captured groups.</p>
            </item>
         </ulist>
         <p>These functions are described in <bibref ref="xpath-functions-30"/>.</p>
         <p><phrase diff="chg" at="R-bug24618">Supplementing</phrase> these functions, XSLT provides
            an instruction <elcode>xsl:analyze-string</elcode>, which is defined in this
            section.</p>
         <note diff="add" at="R-bug24618">
            <p>The <elcode>xsl:analyze-string</elcode> instruction predates the
                  <xfunction>analyze-string</xfunction> function, and provides very similar
               functionality, though in a different way. The two constructs are not precisely
               equivalent; for example, <elcode>xsl:analyze-string</elcode> allows a regular
               expression that matches a zero-length string while the
                  <xfunction>analyze-string</xfunction> function does not. The
                  <elcode>xsl:analyze-string</elcode> instruction (via the use of
                  <function>regex-group</function>) provides information about the value of captured
               substrings; the <xfunction>analyze-string</xfunction> function additionally provides
               information about the position of the captured substrings within the original
               string.</p>
         </note>
         <p>The regular expressions used by this instruction, and the flags that control the
            interpretation of these regular expressions, <rfc2119>must</rfc2119> conform to the
            syntax defined in <bibref ref="xpath-functions-30"/> (see <xspecref spec="FO30"
               ref="regex-syntax"/>), which is itself based on the syntax defined in <bibref
               ref="xmlschema-2"/>.</p>
         <div2 id="analyze-string">
            <head>The <code>xsl:analyze-string</code> Instruction</head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="analyze-string">
               <e:in-category name="instruction"/>
               <e:attribute name="select" required="yes">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="regex" required="yes">
                  <e:attribute-value-template>
                     <e:data-type name="string"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="flags" required="no">
                  <e:attribute-value-template>
                     <e:data-type name="string"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:sequence>
                  <e:element repeat="zero-or-one" name="matching-substring"/>
                  <e:element repeat="zero-or-one" name="non-matching-substring"/>
                  <e:element repeat="zero-or-more" name="fallback"/>
               </e:sequence>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="matching-substring">
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent name="analyze-string"/>
               </e:allowed-parents>
            </e:element-syntax>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="non-matching-substring">
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent name="analyze-string"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:analyze-string</elcode> instruction takes as input a string (the
               result of evaluating the expression in the <code>select</code> attribute) and a
               regular expression (the effective value of the <code>regex</code> attribute).</p>
            <p>If the result of evaluating the <code>select</code> expression <phrase diff="add"
                  at="G">is an empty sequence, it is treated as a zero-length string. If the value
               </phrase>is not a string, it is converted to a string by applying the <termref
                  def="dt-function-conversion-rules">function conversion rules</termref>.</p>
            <p>The <code>flags</code> attribute may be used to control the interpretation of the
               regular expression. If the attribute is omitted, the effect is the same as supplying
               a zero-length string. This is interpreted in the same way as the <code>$flags</code>
               attribute of the functions <xfunction>matches</xfunction>,
                  <xfunction>replace</xfunction>, and <xfunction>tokenize</xfunction>. Specifically,
               if it contains the letter <code>m</code>, the match operates in multiline mode. If it
               contains the letter <code>s</code>, it operates in dot-all mode. If it contains the
               letter <code>i</code>, it operates in case-insensitive mode. If it contains the
               letter <code>x</code>, then whitespace within the regular expression is ignored. For
               more detailed specifications of these modes, see <bibref ref="xpath-functions-30"/>
                  (<xspecref ref="flags" spec="FO30"/>).</p>
            <note>
               <p>Because the <code>regex</code> attribute is an attribute value template, curly
                  brackets within the regular expression must be doubled. For example, to match a
                  sequence of one to five characters, write <code>regex=".{{1,5}}"</code>. For
                  regular expressions containing many curly brackets it may be more convenient to
                  use a notation such as <code>regex="{'[0-9]{1,5}[a-z]{3}[0-9]{1,2}'}"</code>, or
                  to use a variable.</p>
            </note>
            <p>The <elcode>xsl:analyze-string</elcode> instruction may have two child elements:
                  <elcode>xsl:matching-substring</elcode> and
                  <elcode>xsl:non-matching-substring</elcode>. Both elements are optional, and
               neither may appear more than once. At least one of them must be present. If both are
               present, the <elcode>xsl:matching-substring</elcode> element must come first.</p>
            <p>The content of the <elcode>xsl:analyze-string</elcode> instruction must take one of
               the following forms:</p>
            <olist>
               <item>
                  <p>A single <elcode>xsl:matching-substring</elcode> instruction, followed by zero
                     or more <elcode>xsl:fallback</elcode> instructions</p>
               </item>
               <item>
                  <p>A single <elcode>xsl:non-matching-substring</elcode> instruction, followed by
                     zero or more <elcode>xsl:fallback</elcode> instructions</p>
               </item>
               <item>
                  <p>A single <elcode>xsl:matching-substring</elcode> instruction, followed by a
                     single <elcode>xsl:non-matching-substring</elcode> instruction, followed by
                     zero or more <elcode>xsl:fallback</elcode> instructions</p>
               </item>
            </olist>
            <p>
               <error spec="XT" type="static" class="SE" code="1130"><p>It is a <termref
                        def="dt-static-error">static error</termref> if the
                        <elcode>xsl:analyze-string</elcode> instruction contains neither an
                        <elcode>xsl:matching-substring</elcode> nor an
                        <elcode>xsl:non-matching-substring</elcode> element.</p></error>
            </p>
            <p>Any <elcode>xsl:fallback</elcode> elements among the children of the
                  <elcode>xsl:analyze-string</elcode> instruction are ignored by an XSLT 2.0 <phrase
                  diff="add" at="A">or 3.0</phrase> processor, but allow fallback behavior to be
               defined when the stylesheet is used with an XSLT 1.0 processor operating with
               forwards-compatible behavior.</p>
            <p>This instruction is designed to process all the non-overlapping substrings of the
               input string that match the regular expression supplied.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="1140"><p>It is a <termref
                        def="dt-dynamic-error"><phrase diff="del" at="M">non-recoverable</phrase>
                        dynamic error</termref> if the <termref def="dt-effective-value">effective
                        value</termref> of the <code>regex</code> attribute <error.extra>of the
                           <elcode>xsl:analyze-string</elcode> instruction</error.extra> does not
                     conform to the <rfc2119>required</rfc2119> syntax for regular expressions, as
                     specified in <bibref ref="xpath-functions-30"/>. If the regular expression is
                     known statically (for example, if the attribute does not contain any <termref
                        def="dt-expression">expressions</termref> enclosed in curly brackets) then
                     the processor <rfc2119>may</rfc2119> signal the error as a <termref
                        def="dt-static-error">static error</termref>. </p></error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="1145"><p>It is a <termref
                        def="dt-dynamic-error"><phrase diff="del" at="M">non-recoverable</phrase>
                        dynamic error</termref> if the <termref def="dt-effective-value">effective
                        value</termref> of the <code>flags</code> attribute <error.extra>of the
                           <elcode>xsl:analyze-string</elcode> instruction</error.extra> has a value
                     other than the values defined in <bibref ref="xpath-functions-30"/>. If the
                     value of the attribute is known statically (for example, if the attribute does
                     not contain any <termref def="dt-expression">expressions</termref> enclosed in
                     curly brackets) then the processor <rfc2119>may</rfc2119> signal the error as a
                        <termref def="dt-static-error">static error</termref>. </p></error>
            </p>
            <p diff="del" at="N">
               <error spec="XT" type="dynamic" class="DE" code="1150"><p>It is a <termref
                        def="dt-dynamic-error"><phrase diff="del" at="M">non-recoverable</phrase>
                        dynamic error</termref> if the <termref def="dt-effective-value">effective
                        value</termref> of the <code>regex</code> attribute <error.extra>of the
                           <elcode>xsl:analyze-string</elcode> instruction</error.extra> is a
                     regular expression that matches a zero-length string: or more specifically, if
                     the regular expression <code>$r</code> and flags <code>$f</code> are such that
                        <code>matches("", $r, $f)</code> returns true. If the regular expression is
                     known statically (for example, if the attribute does not contain any <termref
                        def="dt-expression">expressions</termref> enclosed in curly brackets) then
                     the processor <rfc2119>may</rfc2119> signal the error as a <termref
                        def="dt-static-error">static error</termref>. </p></error>
            </p>
            <p diff="chg" at="N">To explain the behavior of the instruction it is useful to consider
               an input string of length <var>N</var> characters as having <var>N+1</var>
               inter-character positions, including one just before the first character and one just
               after the last. Each of these positions is a possible position for testing whether
               the regular expression matches. These positions are numbered from zero to
                  <code>N</code>.</p>
            <note diff="add" at="N">
               <p>The term <term>character</term>, here as elsewhere in this specification, means a
                  Unicode codepoint. When strings are held in decomposed form, the multiple
                  codepoints representing a composite character are considered to be multiple
                  characters. A codepoint greater than 65535 is considered as one character, not as
                  a surrogate pair.</p>
            </note>
            <p diff="chg" at="N">The processor starts by setting the current position to position
               zero, and the current non-matching substring to a zero-length string. It then does
               the following repeatedly:</p>
            <olist diff="chg" at="N">
               <item>
                  <p>Test whether the regular expression matches at the current position.</p>
               </item>
               <item>
                  <p>If there is a match:</p>
                  <olist>
                     <item>
                        <p>If the current non-matching substring has length greater than zero,
                           evaluate the <elcode>xsl:non-matching-substring</elcode> sequence
                           constructor with the current non-matching substring as the context
                           item.</p>
                     </item>
                     <item>
                        <p>Reset the current non-matching substring to a zero-length string.</p>
                     </item>
                     <item>
                        <p>Evaluate the <elcode>xsl:matching-substring</elcode> sequence constructor
                           with the matching substring as the context item.</p>
                     </item>
                     <item>
                        <p>Do the appropriate one of the following:</p>
                        <olist>
                           <item>
                              <p>If the matching substring is non-zero length, set the current
                                 position to coincide with the end of the matching substring, exit,
                                 and repeat.</p>
                           </item>
                           <item>
                              <p>If the matching substring is zero length and the current position
                                 is at the end of the input string, exit.</p>
                           </item>
                           <item>
                              <p>If the matching substring is zero length and the current position
                                 is not at the end of the input string, add the character that
                                 immediately follows the current position to the current
                                 non-matching substring, set the current position to the position
                                 immediately after this character, exit, and repeat.</p>
                           </item>
                        </olist>
                     </item>
                  </olist>
               </item>
               <item>
                  <p>If there is no match:</p>
                  <olist>
                     <item>
                        <p>If the current position is the last position (that is, just after the
                           last character):</p>
                        <olist>
                           <item>
                              <p>If the current non-matching substring has length greater than zero,
                                 evaluate the <elcode>xsl:non-matching-substring</elcode> sequence
                                 constructor with the current non-matching substring as the context
                                 item.</p>
                           </item>
                           <item>
                              <p>Exit.</p>
                           </item>
                        </olist>
                     </item>
                     <item>
                        <p>Otherwise, add the character at the current position to the current
                           non-matching substring, increment the current position, and repeat.</p>
                     </item>
                  </olist>
               </item>
            </olist>
            <p><phrase diff="chg" at="N">When the matcher is looking for a match at a particular
                  starting position and there are </phrase> several alternatives within the regular
               expression that match at this position in the input string, then the match that is
               chosen is the first alternative that matches. For example, if the input string is
                  <code>The quick brown fox jumps</code> and the regular expression is
                  <code>jump|jumps</code>, then the match that is chosen is <code>jump</code>. </p>
            <p>The input string is thus partitioned into a sequence of substrings, some of which
               match the regular expression, others which do not match it. <phrase diff="chg" at="N"
                  >Each non-matching substring will contain at least one character, but a matching
                  substring may be zero-length. </phrase> This sequence of substrings is processed
               using the <phrase diff="chg" at="F">instructions within the contained
                     <elcode>xsl:matching-substring</elcode> and
                     <elcode>xsl:non-matching-substring</elcode> elements</phrase>. A matching
               substring is processed using the <elcode>xsl:matching-substring</elcode> element, a
               non-matching substring using the <elcode>xsl:non-matching-substring</elcode> element.
               Each of these elements takes a <termref def="dt-sequence-constructor"/> as its
               content. If the element is absent, the effect is the same as if it were present with
               empty content. In processing each substring, the contents of the substring will be
               the <termref def="dt-context-item">context item</termref> (as a value of type
                  <code>xs:string</code>); the position of the substring within the sequence of
               matching and non-matching substrings will be the <termref def="dt-context-position"
                  >context position</termref>; and the number of matching and non-matching
               substrings will be the <termref def="dt-context-size">context size</termref>.</p>
            <p diff="del" at="N">If the input is a zero-length string, the number of substrings will
               be zero, so neither the <elcode>xsl:matching-substring</elcode> nor
                  <elcode>xsl:non-matching-substring</elcode> elements will be evaluated.</p>
         </div2>
         <div2 id="func-regex-group">
            <head>fn:regex-group</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>Returns the string captured by a parenthesized subexpression of the regular
                        expression used during evaluation of the <elcode>xsl:analyze-string</elcode>
                        instruction.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signature</label>
                  <def>
                     <example role="signature">
                        <proto name="regex-group" return-type="xs:string" isOp="no" prefix="fn"
                           returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no"
                           isDatatype="no" isSpecial="no">
                           <arg name="group-number" type="xs:integer"/>
                        </proto>
                     </example>
                  </def>
               </gitem>
               <gitem>
                  <label>Properties</label>
                  <def>
                     <p>This function is <xtermref spec="FO30" ref="dt-deterministic"
                           >deterministic</xtermref>, <xtermref spec="FO30"
                           ref="dt-context-dependent">context-dependent</xtermref>, and <xtermref
                           spec="FO30" ref="dt-focus-independent">focus-independent</xtermref>. </p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>
                        <termdef id="dt-current-captured-substrings"
                           term="current captured substrings">While the
                              <elcode>xsl:matching-substring</elcode> instruction is active, a set
                           of <term>current captured substrings</term> is available, corresponding
                           to the parenthesized subexpressions of the regular expression.</termdef>
                        These captured substrings are accessible using the function
                           <function>regex-group</function>. This function takes an integer argument
                        to identify the group, and returns a string representing the captured
                        substring.</p>
                     <p>The <var>N</var>th captured substring (where <var>N</var> &gt; 0) is the
                        string matched by the subexpression contained by the <var>N</var>th left
                        parenthesis in the regex, <phrase diff="add" at="C">excluding any
                           non-capturing groups, which are written as <code>(?:xxx)</code></phrase>.
                        The zeroth captured substring is the string that matches the entire regex.
                        This means that the value of <code>regex-group(0)</code> is initially the
                        same as the value of <code>.</code> (dot).</p>
                     <p>The function returns the zero-length string if there is no captured
                        substring with the relevant number. This can occur for a number of
                        reasons:</p>
                     <olist>
                        <item>
                           <p>The number is negative.</p>
                        </item>
                        <item>
                           <p>The regular expression does not contain a parenthesized subexpression
                              with the given number.</p>
                        </item>
                        <item>
                           <p>The parenthesized subexpression exists, and did not match any part of
                              the input string.</p>
                        </item>
                        <item>
                           <p>The parenthesized subexpression exists, and matched a zero-length
                              substring of the input string.</p>
                        </item>
                     </olist>
                     <p>The set of captured substrings is a context variable with dynamic scope. It
                        is initially an empty sequence. During the evaluation of an
                           <elcode>xsl:matching-substring</elcode> instruction it is set to the
                        sequence of matched substrings for that regex match. During the evaluation
                        of an <elcode>xsl:non-matching-substring</elcode> instruction or a <termref
                           def="dt-pattern">pattern</termref> or a <termref
                           def="dt-stylesheet-function">stylesheet function</termref> it is set to
                        an empty sequence. On completion of an instruction that changes the value,
                        the variable reverts to its previous value.</p>
                     <p>The value of the <termref def="dt-current-captured-substrings">current
                           captured substrings</termref> is unaffected through calls of
                           <elcode>xsl:apply-templates</elcode>, <elcode>xsl:call-template</elcode>,
                           <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode>, or
                        by expansion of named <termref def="dt-attribute-set">attribute
                           sets</termref>.</p>
                  </def>
               </gitem>
            </glist>
         </div2>
         <div2 id="regex-examples">
            <head>Examples of Regular Expression Matching</head>
            <example>
               <head>Replacing Characters by Elements</head>
               <p>Problem: replace all newline characters in the <code>abstract</code> element by
                  empty <code>br</code> elements:</p>
               <p>Solution:</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:analyze-string select="abstract" regex="\n"&gt;
  &lt;xsl:matching-substring&gt;
    &lt;br/&gt;
  &lt;/xsl:matching-substring&gt;
  &lt;xsl:non-matching-substring&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:non-matching-substring&gt;
&lt;/xsl:analyze-string&gt;</eg>
            </example>
            <example>
               <head>Recognizing non-XML Markup Structure</head>
               <p>Problem: replace all occurrences of <code>[...]</code> in the <code>body</code> by
                     <code>cite</code> elements, retaining the content between the square brackets
                  as the content of the new element.</p>
               <p>Solution:</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:analyze-string select="body" regex="\[(.*?)\]"&gt;
  &lt;xsl:matching-substring&gt;
    &lt;cite&gt;&lt;xsl:value-of select="regex-group(1)"/&gt;&lt;/cite&gt;
  &lt;/xsl:matching-substring&gt;
  &lt;xsl:non-matching-substring&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:non-matching-substring&gt;
&lt;/xsl:analyze-string&gt;</eg>
               <p>Note that this simple approach fails if the <code>body</code> element contains
                  markup that needs to be retained. In this case it is necessary to apply the
                  regular expression processing to each text node individually. If the
                     <code>[...]</code> constructs span multiple text nodes (for example, because
                  there are elements within the square brackets) then it probably becomes necessary
                  to make two or more passes over the data.</p>
            </example>
            <example>
               <head>Parsing a Date</head>
               <p>Problem: the input string contains a date such as <code>23 March 2002</code>.
                  Convert it to the form <code>2002-03-23</code>.</p>
               <p>Solution (with no error handling if the input format is incorrect):</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:variable name="months" 
        select="'January', 'February', 'March', ..."/&gt;

&lt;xsl:analyze-string select="normalize-space($input)" 
    regex="([0-9]{{1,2}})\s([A-Z][a-z]+)\s([0-9]{{4}})"&gt;
    &lt;xsl:matching-substring&gt;
        &lt;xsl:number value="regex-group(3)" format="0001"/&gt;          
        &lt;xsl:text&gt;-&lt;/xsl:text&gt;
        &lt;xsl:number value="index-of($months, regex-group(2))" format="01"/&gt;
        &lt;xsl:text&gt;-&lt;/xsl:text&gt;
        &lt;xsl:number value="regex-group(1)" format="01"/&gt;
    &lt;/xsl:matching-substring&gt;
&lt;/xsl:analyze-string&gt;</eg>
               <p>Note the use of <code>normalize-space</code> to simplify the work done by the
                  regular expression, and the use of doubled curly brackets because the
                     <code>regex</code> attribute is an attribute value template.</p>
            </example>
            <example diff="add" at="N">
               <head>Matching Zero-Length Strings</head>
               <p>This example removes all empty and whitespace-only lines from a file.</p>
               <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:analyze-string select="unparsed-text('in.txt')"
                    regex="^[\t ]*$" flags="m" expand-text="yes"&gt;
  &lt;xsl:non-matching-substring&gt;{.}&lt;/xsl:non-matching-substring&gt;
&lt;/xsl:analyze-string&gt;</eg>
            </example>
            <example diff="add" at="N">
               <head>Parsing comma-separated values</head>
               <p>There are many variants of CSV formats. This example is designed to handle input
                  where:</p>
               <ulist>
                  <item>
                     <p>Each record occupies one line.</p>
                  </item>
                  <item>
                     <p>Fields are separated by commas.</p>
                  </item>
                  <item>
                     <p>Quotation marks around a field are optional, unless the field contains a
                        comma or quotation mark, in which case they are mandatory.</p>
                  </item>
                  <item>
                     <p>A quotation mark within the value of a field is represented by a pair of two
                        adjacent quotation marks.</p>
                  </item>
               </ulist>
               <p>For example, the input record:</p>
               <eg role="non-xml" xml:space="preserve">Ten Thousand,10000,,"10,000","It's ""10 Grand"", mister",10K</eg>
               <p>contains six fields, specifically:</p>
               <ulist>
                  <item>
                     <p>Ten Thousand</p>
                  </item>
                  <item>
                     <p>10000</p>
                  </item>
                  <item>
                     <p>&lt;zero-length-string&gt;</p>
                  </item>
                  <item>
                     <p>10,000</p>
                  </item>
                  <item>
                     <p>It's "10 Grand", mister</p>
                  </item>
                  <item>
                     <p>10K</p>
                  </item>
               </ulist>
               <p>The following code parses such CSV input into an XML structure containing
                     <code>row</code> and <code>col</code> elements:</p>
               <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:for-each select="unparsed-text-lines('in.csv')" expand-text="yes"&gt;
  &lt;row&gt;
    &lt;xsl:analyze-string select="." 
                        regex='(?:^|,)(?:"((?:[^"]|"")*)"|([^",]*))'&gt;
      &lt;xsl:matching-substring&gt;
        &lt;col&gt;{replace(regex-group(1), '""', '"')||regex-group(2)}&lt;/col&gt;
      &lt;/xsl:matching-substring&gt;
    &lt;/xsl:analyze-string&gt;
  &lt;/row&gt;
&lt;/xsl:for-each&gt;</eg>
               <p>Note that because this regular expression matches a zero-length string, it is not
                  permitted in XSLT 2.0.</p>
            </example>
         </div2>
      </div1>
      <div1 id="streaming">
         <head>Streaming</head>
         <p>XSLT 3.0 introduces a number of constructs that are specifically designed to enable
            streamed applications to be written, but which are also useful in their own right; it
            also includes some features that are very specialized to streaming.</p>
         <div2 id="source-document-instruction">
            <head>The <code>xsl:source-document</code> Instruction</head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="source-document">
               <e:in-category name="instruction"/>
               <e:attribute name="href" required="yes">
                  <e:attribute-value-template>
                     <e:data-type name="uri"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="streamable">
                  <e:data-type name="boolean"/>
               </e:attribute>
               <e:attribute name="use-accumulators">
                  <e:data-type name="tokens"/>
               </e:attribute>
               <e:attribute name="validation">
                  <e:constant value="strict"/>
                  <e:constant value="lax"/>
                  <e:constant value="preserve"/>
                  <e:constant value="strip"/>
               </e:attribute>
               <e:attribute name="type">
                  <e:data-type name="eqname"/>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:source-document</elcode> instruction reads a source document whose
               URI is supplied, and processes the content of the document <phrase diff="del"
                  at="T-bug29747">using streaming</phrase> by evaluating the contained <termref
                  def="dt-sequence-constructor"/>. <phrase diff="add" at="T-bug29747">The
                     <code>streamable</code> attribute (default <code>"no"</code>)</phrase> allows
               streamed processing to be requested.</p>
            <p>For example, if a document represents a book holding a sequence of chapters, then the
               following code can be used to split the book into multiple XML files, one per
               chapter, without allocating memory to hold the entire book in memory at one time:</p>
            <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:source-document streamable="yes" href="book.xml"&gt;
  &lt;xsl:for-each select="book"&gt;             
    &lt;xsl:for-each select="chapter"&gt;
      &lt;xsl:result-document href="chapter{position()}.xml"&gt;
        &lt;xsl:copy-of select="."/&gt;
      &lt;/xsl:result-document&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:for-each&gt;  
&lt;/xsl:source-document&gt;</eg>
            <note>
               <p diff="add" at="T-bug29747">In earlier drafts of this specification the
                     <elcode>xsl:source-document</elcode> element was named <code>xsl:stream</code>.
                  The instruction has been generalised to handle both streamed and unstreamed
                  input.</p>
            </note>
            <p>The document to be read is determined by the <termref def="dt-effective-value"
                  >effective value</termref> of the <code>href</code> attribute (which is defined as
               an <termref def="dt-attribute-value-template">attribute value template</termref>).
                  <phrase diff="chg" at="F">This <rfc2119>must</rfc2119> be a valid URI reference.
                  If it is an absolute URI reference, it is used as is; if it is a relative URI
                  reference, it is made absolute by resolving it against the base URI of the
                     <elcode>xsl:source-document</elcode> element</phrase>. The process of obtaining
               a document node given a URI is the same as for the <xfunction>doc</xfunction>
               function. However, unlike the <xfunction>doc</xfunction> function, the
                  <elcode>xsl:source-document</elcode> instruction offers no guarantee that the
               resulting document will be stable (that is, that multiple calls specifying the same
               URI will return the same document).</p>
            <p>Specifically, if an <elcode>xsl:source-document</elcode> instruction is evaluated
               several times (or if different <elcode>xsl:source-document</elcode> instructions are
               evaluated) with the same URI (<phrase diff="chg" at="F">after making it
                  absolute</phrase>) as the value of the <code>href</code> attribute, it is <termref
                  def="dt-implementation-dependent">implementation-dependent</termref> whether the
               same nodes or different nodes are returned on each occasion; it is also possible that
               the actual document content will be different. </p>
            <note>
               <p diff="add" at="T-bug29747">A different node will necessarily be returned if there
                  are differences in attributes such as <code>validation</code>, <code>type</code>,
                     <code>streamable</code>, or <code>use-accumulators</code>, or if the calls are
                  in different <termref def="dt-package">packages</termref> with variations in the
                  rules for whitespace stripping or stripping of type annotations.</p>
            </note>
            <p>The result of the <elcode>xsl:source-document</elcode> instruction is the same as the
               result of the following (non-streaming) process:</p>
            <olist>
               <item>
                  <p>The source document is read from the supplied URI and parsed to form an tree of
                     nodes in the XDM data model.</p>
               </item>
               <item>
                  <p>The contained sequence constructor is evaluated with the root node of this tree
                     as the context item, and with the context position and context size set to one;
                     and the resulting sequence is returned as the result of the
                        <elcode>xsl:source-document</elcode> instruction.</p>
               </item>
            </olist>
            <p diff="add" at="P">The <elcode>xsl:source-document</elcode> instruction is <termref
                  def="dt-guaranteed-streamable"/> if <phrase diff="add" at="T-bug29747">both the
                  following conditions are satisfied:</phrase></p>
            <olist>
               <item>
                  <p diff="add" at="T-bug29747">It is <termref def="dt-declared-streamable"/>, by
                     specifying <code>streamable="yes"</code>.</p>
               </item>
               <item>
                  <p>the contained <termref def="dt-sequence-constructor"/> is <termref
                        def="dt-grounded"/>, as assessed using the streamability analysis in
                        <specref ref="streamability"/>. The consequences of being or not being
                     guaranteed streamable depend on the processor conformance level, and are
                     explained in <specref ref="streamability-guarantees"/>.</p>
               </item>
            </olist>
            <p diff="add" at="S-bug27660">The <code>use-accumulators</code> attribute defines the
               set of accumulators that are applicable to the document, as explained in <specref
                  ref="applicability-of-accumulators"/>.</p>
            <note diff="del" at="T-bug29747">
               <p>The name of the instruction reflects its intended usage, to process an input
                  document using streaming. However, a processor that does not offer the <termref
                     def="dt-streaming-feature"/> must still implement the instruction (without
                  being required to use streamed evaluation or to check its streamability); and
                  processors that do offer the <termref def="dt-streaming-feature"/> are also
                  required to provide a mode of execution in which the construct is evaluated
                  without streaming if it fails the streamability criteria.</p>
            </note>
            <note>
               <p>The following notes apply specifically to streamed processing.</p>
               <p>The rules for <phrase diff="chg" at="S-bug27273"><termref
                        def="dt-guaranteed-streamable">guaranteed streamability</termref></phrase>
                  ensure that the sequence constructor (and therefore the
                     <elcode>xsl:source-document</elcode> instruction) cannot return any nodes from
                  the <termref def="dt-streamed-document">streamed document</termref>. For example,
                  it cannot contain the instruction <code>&lt;xsl:sequence
                     select="//chapter"/&gt;</code>. If nodes from this document are to be returned,
                  they must first be copied, for example by <phrase diff="add" at="F">using the
                        <elcode>xsl:copy-of</elcode> instruction or by </phrase>calling the
                     <function>copy-of</function> or <function>snapshot</function> functions.</p>
               <p>Because the <elcode>xsl:source-document</elcode> instruction cannot <phrase
                     diff="add" at="S-bug27273">(if it satisfies the rules for guaranteed
                     streamability)</phrase> return nodes from the streamed document, any nodes it
                  does return will be conventional (unstreamed) nodes that can be processed without
                  restriction. For example, if <elcode>xsl:source-document</elcode> is invoked
                  within a <termref def="dt-stylesheet-function">stylesheet function</termref>
                  <code>f:firstChapter</code>, and the sequence constructor consists of the
                  instruction <code>&lt;xsl:copy-of select="//chapter"/&gt;</code>, then the calling
                  code can manipulate the resulting <code>chapter</code> elements as ordinary trees
                  rooted at parentless element nodes.</p>
               <p diff="add" at="S-bug27273">If the sequence constructor in an
                     <elcode>xsl:source-document</elcode> instruction were to return nodes from the
                  document for which streaming has been requested, the instruction would not be
                  guaranteed streamable. Processors which support the streaming feature would then
                  not be required to process it in a streaming manner, and this specification
                  imposes no restrictions on the processing of the nodes returned. (The ability of a
                  streaming processor to handle such stylesheets in a streaming manner might, of
                  course, depend on how the nodes returned are processed, but those details are out
                  of scope for this specification.) </p>
            </note>
            <div3 id="source-document-validation" diff="add" at="Q">
               <head>Validation of Source Documents</head>
               <p>The <code>validation</code> and <code>type</code> attributes of
                     <elcode>xsl:source-document</elcode> may be used to control schema validation
                  of the <phrase diff="add" at="T-bug29747">input document</phrase>. They have the
                  same effect as the corresponding attributes of the <elcode>xsl:copy-of</elcode>
                  instruction when applied to a document node, except that <phrase diff="add"
                     at="T-bug29747">when <code>streamable="yes"</code> is specified,</phrase> the
                  copy that is produced is itself a streamed document. The process is described in
                  more detail in <specref ref="validating-document-nodes"/>.</p>
               <p>These two attributes are both optional, and if one is specified then the other
                     <rfc2119>must</rfc2119> be omitted (<errorref spec="XT" class="SE" code="1505"
                  />).</p>
               <p>The presence of a <code>validation</code> or <code>type</code> attribute on an
                     <elcode>xsl:source-document</elcode> instruction causes any
                     <code>input-type-annotations</code> attribute to have no effect on any document
                  read using that instruction.</p>
               <note>
                  <p>In effect, setting <code>validation</code> to <code>strict</code> or
                        <code>lax</code>, or supplying the <code>type</code> attribute, requests
                     document-level validation of the input as it is read. Setting
                        <code>validation="preserve"</code> indicates that if the incoming document
                     contains type annotations (for example, produced by validating the output of a
                     previous step in a streaming pipeline) then they should be retained, while the
                     value <code>strip</code> indicates that any such type annotations should be
                     dropped.</p>
                  <p>It is a consequence of the way validation is defined in XSD that the type
                     annotation of an element node can be determined during the processing of its
                     start tag, although the actual validity of the element is not known until the
                     end tag is encountered. When validation is requested, a streamed document
                     should not present data to the stylesheet except to the extent that such data
                     could form the leading part of a valid document. If the document proves to be
                     invalid, the processor should not pass invalid data to the stylesheet to be
                     processed, but should immediately signal the appropriate error. For the
                     purposes of <elcode>xsl:try</elcode> and <elcode>xsl:catch</elcode>, this error
                     can only be caught at the level of the <elcode>xsl:source-document</elcode>
                     instruction that initiated validation, not at a finer level. If validation
                     errors are caught in this way, any output that has been computed up to the
                     point of the error is not added to the final result tree; the mechanisms to
                     achieve this may use memory, which may reduce the efficacy of streaming.</p>
                  <p>The analysis of guaranteed streamability (see <specref ref="streamability"/>)
                     takes no account of information that might be obtained from a schema-aware
                     static analysis of the stylesheet. Implementations may, however, be able to use
                     streaming strategies for stylesheets that are not guaranteed-streamable, by
                     taking advantage of such information. For example, an implementation might be
                     able to treat the expression <code>.//title</code> as <termref
                        def="dt-striding"/> rather than <termref def="dt-crawling"/> if it can
                     establish from knowledge of the schema that two <code>title</code> elements
                     will never <phrase diff="chg" at="R-bug24290">be nested one inside the
                        other</phrase>.</p>
               </note>
            </div3>
            <div3 id="stream-examples">
               <head>Examples of <code>xsl:source-document</code></head>
               <p>The <elcode>xsl:source-document</elcode> instruction can be used to initiate
                  processing of a document using streaming with a variety of coding styles,
                  illustrated in the examples below.</p>
               <p diff="del" at="O">These examples no longer work; it is no longer possible to
                  compute an aggregate over descendant values using a path expression. Instead,
                  traversal using templates is required.</p>
               <example diff="chg" at="P-bug22017">
                  <head>Using <elcode>xsl:source-document</elcode> with Aggregate Functions</head>
                  <p>The following example computes the number of transactions in a transaction
                     file</p>
                  <p>Input:</p>
                  <eg role="xml" xml:space="preserve">
&lt;transactions&gt;
  &lt;transaction value="12.51"/&gt;
  &lt;transaction value="3.99"/&gt;
&lt;/transactions&gt;</eg>
                  <p>Stylesheet code:</p>
                  <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:source-document streamable="yes" href="transactions.xml"&gt;
  &lt;count&gt;
    &lt;xsl:value-of select="count(transactions/transaction)"/&gt;
  &lt;/count&gt;
&lt;/xsl:source-document&gt;</eg>
                  <p>Result:</p>
                  <eg role="xml" xml:space="preserve">&lt;count&gt;2&lt;/count&gt;</eg>
                  <p>Analysis:</p>
                  <olist>
                     <item>
                        <p>The literal result element <code>count</code> has the same sweep as the
                              <elcode>xsl:value-of</elcode> instruction.</p>
                     </item>
                     <item>
                        <p>The <elcode>xsl:value-of</elcode> instruction has the same sweep as its
                              <code>select</code> expression.</p>
                     </item>
                     <item>
                        <p>The call to <code>count</code> has the same sweep as its argument.</p>
                     </item>
                     <item>
                        <p>The argument to <code>count</code> is a <code>RelativePathExpr</code>.
                              <phrase diff="chg" at="S-bug29150">Under the rules in <specref
                                 ref="streamability-of-path-expressions"/>, this expression is
                                 <termref def="dt-striding"/> and <termref def="dt-consuming"/>. The
                              call on <code>count</code> is therefore <termref def="dt-grounded"/>
                              and <termref def="dt-consuming"/></phrase>. </p>
                     </item>
                     <item>
                        <p diff="chg" at="S-bug29150">The entire body of the
                              <elcode>xsl:source-document</elcode> instruction is therefore <termref
                              def="dt-grounded"/> and <termref def="dt-consuming"/>.</p>
                     </item>
                  </olist>
                  <p>The following example computes the highest-value transaction in the same input
                     file:</p>
                  <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:source-document streamable="yes" href="transactions.xml"&gt;
  &lt;maxValue&gt;
    &lt;xsl:value-of select="max(transactions/transaction/@value)"/&gt;
  &lt;/maxValue&gt;
&lt;/xsl:source-document&gt;</eg>
                  <p>Result:</p>
                  <eg role="xml" xml:space="preserve">&lt;maxValue&gt;12.51&lt;/maxValue&gt;</eg>
                  <p>Analysis:</p>
                  <olist>
                     <item>
                        <p>The literal result element <code>maxValue</code> has the same sweep as
                           the <elcode>xsl:value-of</elcode> instruction.</p>
                     </item>
                     <item>
                        <p>The <elcode>xsl:value-of</elcode> instruction has the same sweep as its
                              <code>select</code> expression.</p>
                     </item>
                     <item>
                        <p>The call to <code>max</code> has the same sweep as its argument.</p>
                     </item>
                     <item>
                        <p>The argument to <code>max</code> is a <code>RelativePathExpr</code> whose
                           two operands are the <code>RelativePathExpr</code>
                           <code>transactions/transaction</code> and the <code>AxisStep</code>
                           <code>@value</code>. The <phrase diff="chg" at="R-bug24536"
                              >left-hand</phrase> operand <code>transactions/transaction</code> has
                              <phrase diff="chg" at="P"><termref def="dt-striding"/>
                              <termref def="dt-posture"/></phrase>. The <phrase diff="chg"
                              at="R-bug24536">right-hand</phrase> operand <code>@value</code>, given
                           that it appears in a node value context, is <termref def="dt-motionless"
                           />. The <code>RelativePathExpr</code> argument to <code>max</code> is
                           therefore consuming.</p>
                     </item>
                     <item>
                        <p>The entire body of the <elcode>xsl:source-document</elcode> instruction
                           is therefore <termref def="dt-consuming"/>.</p>
                     </item>
                  </olist>
                  <p diff="chg" at="T-bug29604">To compute both the count and the maximum value in a
                     single pass over the input, several approaches are possible. The simplest is to
                     use maps (map constructors are exempt from the usual rule that multiple
                     downward selections are not allowed):</p>
                  <eg xml:space="preserve" role="xslt-instruction" diff="chg" at="T-bug29604">&lt;xsl:source-document streamable="yes" href="transactions.xml"&gt;
  &lt;xsl:variable name="tally" select="map{ 'count': count(transactions/transaction), 
                                          'max':   max(transactions/transaction/@value)}"/&gt;
  &lt;value count="{$tally('count')}" max="{$tally('max')}"/&gt;
&lt;/xsl:source-document&gt;</eg>
                  <p diff="chg" at="T-bug29604">Other options include the use of
                        <elcode>xsl:fork</elcode>, or multiple <elcode>xsl:accumulator</elcode>
                     declarations, one for each value to be computed.</p>
               </example>
               <example>
                  <head>Using <elcode>xsl:source-document</elcode> with
                        <elcode>xsl:for-each</elcode> to Process a Collection of Input Documents </head>
                  <p>This example displays a list of the chapter titles extracted from each book in
                     a collection of books.</p>
                  <p>Each input document is assumed to have a structure such as:</p>
                  <eg role="xml" xml:space="preserve">&lt;book&gt;
  &lt;chapter number-of-pages="18"&gt;
    &lt;title&gt;The first chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
  &lt;chapter number-of-pages="15"&gt;
    &lt;title&gt;The second chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
  &lt;chapter number-of-pages="12"&gt;
    &lt;title&gt;The third chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
&lt;/book&gt;</eg>
                  <p>Stylesheet code:</p>
                  <eg xml:space="preserve" role="xslt-fragment">&lt;chapter-titles&gt;
  &lt;xsl:for-each select="uri-collection('books')"&gt;
    &lt;xsl:source-document streamable="yes" href="{.}"&gt;
      &lt;xsl:for-each select="book"&gt;
        &lt;xsl:for-each select="chapter"&gt;
           &lt;title&gt;&lt;xsl:value-of select="title"/&gt;&lt;/title&gt;
        &lt;/xsl:for-each&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:source-document&gt;
  &lt;/xsl:for-each&gt;
&lt;/chapter-titles&gt;</eg>
                  <p>Output:</p>
                  <eg role="xml" xml:space="preserve">&lt;chapter-titles&gt;
  &lt;title&gt;The first chapter of book A&lt;/title&gt;
  &lt;title&gt;The second chapter of book A&lt;/title&gt;
  ...
  &lt;title&gt;The first chapter of book B&lt;/title&gt;
  ...
&lt;/chapter-titles&gt;</eg>
                  <note>
                     <p>This example uses the function <xfunction>uri-collection</xfunction> to
                        obtain the document URIs of all the documents in a collection, so that each
                        one can be processed in turn using <elcode>xsl:source-document</elcode>.</p>
                  </note>
               </example>
               <example>
                  <head>Using <elcode>xsl:source-document</elcode> with <elcode>xsl:iterate</elcode>
                  </head>
                  <p>This example assumes that the input is a book with multiple chapters, as shown
                     in the previous example, with the page count for each chapter given as an
                     attribute of the chapter. The transformation determines the starting page
                     number for each chapter by accumulating the page counts for previous chapters,
                     and rounding up to an odd number if necessary.</p>
                  <eg xml:space="preserve" role="xslt-fragment">&lt;chapter-start-page&gt;
   &lt;xsl:source-document streamable="yes" href="book.xml"&gt;
      &lt;xsl:iterate select="book/chapter"&gt;
         &lt;xsl:param name="start-page" select="1"/&gt;
         &lt;chapter title="{title}" start-page="{$start-page}"/&gt;
         &lt;xsl:next-iteration&gt;
            &lt;xsl:with-param name="start-page" 
                            select="$start-page + @number-of-pages + 
                                      (@number-of-pages mod 2)"/&gt;
         &lt;/xsl:next-iteration&gt;
      &lt;/xsl:iterate&gt;
   &lt;/xsl:source-document&gt;
&lt;/chapter-start-page&gt;
</eg>
                  <p>Output:</p>
                  <eg role="xml" xml:space="preserve">&lt;chapter-start-page&gt;
  &lt;chapter title="The first chapter of book A" start-page="1"/&gt;
  &lt;chapter title="The second chapter of book A" start-page="19"/&gt;
  &lt;chapter title="The third chapter of book A" start-page="35"/&gt;
  ...
&lt;/chapter-start-page&gt;
                     </eg>
               </example>
               <example>
                  <head>Using <elcode>xsl:source-document</elcode> with
                        <elcode>xsl:for-each-group</elcode>
                  </head>
                  <p>This example assumes that the input is a book with multiple chapters, and that
                     each chapter belongs to a part, which is present as an attribute of the chapter
                     (for example, chapters 1-4 might constitute Part 1, the next three chapters
                     forming Part 2, and so on):</p>
                  <eg role="xml" xml:space="preserve">&lt;book&gt;
  &lt;chapter part="1"&gt;
    &lt;title&gt;The first chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
  &lt;chapter part="1"&gt;
    &lt;title&gt;The second chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
  ...
  &lt;chapter part="2"&gt;
    &lt;title&gt;The fifth chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
&lt;/book&gt;</eg>
                  <p>The transformation copies the full text of the chapters, creating an extra
                     level of hierarchy for the parts.</p>
                  <eg xml:space="preserve" diff="chg" at="R-bug24510" role="xslt-fragment">&lt;book&gt;
   &lt;xsl:source-document streamable="yes" href="book.xml"&gt;
      &lt;xsl:for-each select="book"&gt;
         &lt;xsl:for-each-group select="chapter" group-adjacent="data(@part)"&gt;
            &lt;part number="{current-grouping-key()}"&gt;
               &lt;xsl:copy-of select="current-group()"/&gt;
            &lt;/part&gt;
         &lt;/xsl:for-each-group&gt;
      &lt;/xsl:for-each&gt;
   &lt;/xsl:source-document&gt;
&lt;/book&gt;
</eg>
                  <p>Output:</p>
                  <eg role="xml" diff="chg" at="T-bug30056" xml:space="preserve">&lt;book&gt;
  &lt;part number="1"&gt;
    &lt;chapter part="1"&gt;
      &lt;title&gt;The first chapter of book A&lt;/title&gt;
      ...
    &lt;/chapter&gt;
    &lt;chapter part="1"&gt;
      &lt;title&gt;The second chapter of book A&lt;/title&gt;
      ...
    &lt;/chapter&gt;
    ...
  &lt;/part&gt;
  &lt;part number="2"&gt;
    &lt;chapter part="2"&gt;
      &lt;title&gt;The fifth chapter of book A&lt;/title&gt;
    ...
    &lt;/chapter&gt;
    ...
  &lt;/part&gt;
&lt;/book&gt;
    </eg>
               </example>
               <example>
                  <head>Using <elcode>xsl:source-document</elcode> with
                        <elcode>xsl:apply-templates</elcode>
                  </head>
                  <p>This example copies an XML document while deleting all the <code>ednote</code>
                     elements at any level of the tree, together with their descendants. This
                     example is a complete stylesheet, which is intended to be evaluated by
                     nominating <code>main</code> as the <termref def="dt-initial-named-template"/>.
                     The use of <code diff="chg" at="F">on-no-match="deep-copy"</code> in the
                        <elcode>xsl:mode</elcode> declaration means that the built-in template rule
                     copies nodes unchanged, except where overridden by a user-defined template
                     rule.</p>
                  <eg xml:space="preserve" role="xslt-document">&lt;xsl:transform version="3.0" 
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:mode name="delete-ednotes" streamable="yes" 
                                on-no-match="shallow-copy"/&gt;

&lt;xsl:template name="main"&gt;
   &lt;xsl:source-document streamable="yes" href="book.xml"&gt;
      &lt;xsl:apply-templates mode="delete-ednotes"/&gt;
   &lt;/xsl:source-document&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="ednote" mode="delete-ednotes"/&gt;

&lt;/xsl:transform&gt;</eg>
                  <p>Additional template rules could be added to process other elements and
                     attributes in the same pass through the data: for example, to modify the value
                     of a <code>last-updated</code> attribute (wherever it appears) to the current
                     date and time, the following rule suffices:</p>
                  <eg xml:space="preserve" diff="chg" at="S-bug26999" role="xslt-declaration">
&lt;xsl:template match="@last-updated" mode="delete-ednotes"&gt;
  &lt;xsl:attribute name="last-updated" select="current-dateTime()"/&gt;
&lt;/xsl:template&gt;</eg>
               </example>
            </div3>
            <div3 id="func-stream-available" diff="add" at="R-bug25173">
               <head>fn:stream-available</head>
               <glist>
                  <gitem>
                     <label>Summary</label>
                     <def>
                        <p>Determines, as far as possible, whether a document is available for
                           streamed processing using <elcode>xsl:source-document</elcode>.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Signature</label>
                     <def>
                        <example role="signature">
                           <proto name="stream-available" return-type="xs:boolean" isOp="no"
                              prefix="fn" returnEmptyOk="no" returnSeq="no" returnVaries="no"
                              isSchema="no" isDatatype="no" isSpecial="no">
                              <arg name="uri" type="xs:string?"/>
                           </proto>
                        </example>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Properties</label>
                     <def>
                        <p>This function is <xtermref spec="FO30" ref="dt-nondeterministic"
                              >nondeterministic</xtermref>, <xtermref spec="FO30"
                              ref="dt-context-dependent">context-dependent</xtermref>, and <xtermref
                              spec="FO30" ref="dt-focus-independent">focus-independent</xtermref>.
                           It depends on available documents. </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Rules</label>
                     <def>
                        <p>The intent of the <function>stream-available</function> function is to
                           allow a stylesheet author to determine, before calling
                              <elcode>xsl:source-document</elcode> with
                              <code>streamable="yes"</code> and with a particular URI as the value
                           of its <code>href</code> attribute, whether a document is available at
                           that location for streamed processing.</p>
                        <p>If the <code>$uri</code> argument is an empty sequence then the function
                           returns <code>false</code>.</p>
                        <p>If the function returns <code>true</code> then the caller can conclude
                           that the following conditions are true:</p>
                        <olist>
                           <item>
                              <p>The supplied URI is valid;</p>
                           </item>
                           <item>
                              <p>A resource can be retrieved at that URI;</p>
                           </item>
                           <item>
                              <p>An XML representation of the resource can be delivered, which is
                                 well-formed at least to the extent that some initial sequence of
                                 octets can be decoded into characters and matched against the
                                 production:</p>
                              <p><code>prolog (EmptyElemTag | STag )</code></p>
                              <p>as defined in the XML 1.0 or XML 1.1 Recommendation.</p>
                              <note>That is, the XML is well-formed at least as far as the end of
                                 the first element start tag; to establish this, a parser will
                                 typically retrieve any external entities referenced in the Doctype
                                 declaration or DTD.</note>
                           </item>
                        </olist>
                        <p>If the function returns <code>false</code>, the caller can conclude that
                           either one of the above conditions is not satisfied, or the processor
                           detected some other condition that would prevent a call on
                              <elcode>xsl:source-document</elcode> with
                              <code>streamable="yes"</code> executing successfully.</p>
                        <p>Like <elcode>xsl:source-document</elcode> itself, the function is not
                           deterministic, which means that multiple calls during the execution of a
                           stylesheet will not necessarily return the same result. The caller cannot
                           make any inferences about the point in time at which the input conditions
                           for <function>stream-available</function> are present, and in particular
                           there is no guarantee that because <function>stream-available</function>
                           returns true, <elcode>xsl:source-document</elcode> will necessarily
                           succeed.</p>
                        <p>The value of the <code>$uri</code> argument <rfc2119>must</rfc2119> be a
                           URI in the form of a string. If it is a relative URI, it is resolved
                           relative to the static base URI of the <phrase diff="chg" at="T-bug29461"
                              >function call</phrase>.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Error Conditions</label>
                     <def>
                        <p>If the URI is invalid, such that a call on
                              <xfunction>doc-available</xfunction> would signal an error, then
                              <function>stream-available</function> signals the same error:
                              <xerrorref spec="FO30" class="DC" code="0005"/>.</p>
                     </def>
                  </gitem>
               </glist>
            </div3>
         </div2>
         <div2 id="accumulators" diff="add" at="K">
            <head>Accumulators</head>
            <p>Accumulators are introduced in XSLT 3.0 to enable data that is read during streamed
               processing of a document to be accumulated, processed or retained for later use.
               However, they may equally be used with non-streamed processing.</p>
            <p diff="chg" at="S-bug28130"><termdef id="dt-accumulator" term="accumulator">An
                     <term>accumulator</term> defines a <phrase diff="chg" at="S-bug27273">series of
                     values</phrase> associated with the nodes of the tree. If an accumulator is
                  applicable to a particular tree, then for each node in the tree, other than
                  attribute and namespace nodes, there will be two values available, called the
                  pre-descent and post-descent values. These two values are available via a pair of
                  functions, <function>accumulator-before</function> and
                     <function>accumulator-after</function>.</termdef></p>
            <p diff="chg" at="S-bug28130">There are two ways the values of an accumulator can be
               established for a given tree: they can be computed by evaluating the rules appearing
               in the <elcode>xsl:accumulator</elcode> declaration, or they can be copied from the
               corresponding nodes in a different tree. The second approach (copying the values) is
               available via the <function>snapshot</function> and <function>copy-of</function>
               functions, or by use of the <elcode>xsl:copy-of</elcode> instruction specifying
                  <code>copy-accumulators="yes"</code>. Accumulator values are also copied during
               the implicit invocation of the snapshot function performed by the
                  <elcode>xsl:merge</elcode> instruction.</p>
            <note diff="add" at="R-bug26330">
               <p>Accumulators can apply to trees rooted at any kind of node<phrase diff="del"
                     at="S-bug27273">, other than attribute and namespace nodes</phrase>. But
                  because they are most often applied to trees rooted at a document node, this
                  section sometimes refers to the “document” to which an accumulator applies; use of
                  this term should be taken to include all trees whether or not they are rooted at a
                  document node.</p>
               <p diff="add" at="S-bug27273">Accumulators can apply to trees rooted at nodes (such
                  as text nodes) that cannot have children, though this serves no useful purpose. In
                  the case of a tree rooted at an attribute or namespace node, there is no way to
                  obtain the value of the accumulator.</p>
            </note>
            <p>The following sections give first, the syntax rules for defining an accumulator; then
               an informal description of the semantics; then a more formal definition; and finally,
               examples. But to illustrate the concept intuitively, the following simple example
               shows how an accumulator can be used for numbering of nodes:</p>
            <example>
               <head>Numbering Figures within a Chapter</head>
               <p>This example assumes document input in which <code>figure</code> elements can
                  appear within <code>chapter</code> elements (which we assume are not nested), and
                  the requirement is to render the figures with a caption that includes the figure
                  number within its containing chapter.</p>
               <p>When the document is processed using streaming, the <elcode>xsl:number</elcode>
                  instruction is not available, so a solution using accumulators is needed.</p>
               <p>The required accumulator can be defined and used like this:</p>
               <eg role="xslt-declaration" xml:space="preserve">
   &lt;xsl:accumulator name="figNr" as="xs:integer" 
                    initial-value="0" streamable="yes"&gt;
     &lt;xsl:accumulator-rule match="chapter" select="0"/&gt;
     &lt;xsl:accumulator-rule match="figure" select="$value + 1"/&gt;
   &lt;/xsl:accumulator&gt;
   
   &lt;xsl:mode streamable="yes"/&gt;
   &lt;xsl:template match="figure"&gt;
     &lt;xsl:apply-templates/&gt;
     &lt;p&gt;Figure &lt;xsl:value-of select="accumulator-before('figNr')"/&gt;&lt;/p&gt;
   &lt;/xsl:template&gt;  
                  </eg>
            </example>
            <div3 id="accumulator-declaration">
               <head>Declaring an Accumulator</head>
               <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
                  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="accumulator">
                  <e:in-category name="declaration"/>
                  <e:attribute name="name" required="yes">
                     <e:data-type name="eqname"/>
                  </e:attribute>
                  <e:attribute name="initial-value" required="yes">
                     <e:data-type name="expression"/>
                  </e:attribute>
                  <e:attribute name="as">
                     <e:data-type name="sequence-type"/>
                  </e:attribute>
                  <e:attribute name="streamable">
                     <e:data-type name="boolean"/>
                  </e:attribute>
                  <e:element name="accumulator-rule" repeat="one-or-more"/>
                  <e:allowed-parents>
                     <e:parent name="package"/>
                     <e:parent name="stylesheet"/>
                     <e:parent name="transform"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
                  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="accumulator-rule">
                  <e:attribute name="match" required="yes">
                     <e:data-type name="pattern"/>
                  </e:attribute>
                  <e:attribute name="phase" required="no">
                     <e:constant value="start"/>
                     <e:constant value="end"/>
                  </e:attribute>
                  <e:attribute name="select" required="no">
                     <e:data-type name="expression"/>
                  </e:attribute>
                  <e:model name="sequence-constructor"/>
                  <e:allowed-parents>
                     <e:parent name="accumulator"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p diff="add" at="N">An <elcode>xsl:accumulator</elcode> element is a <termref
                     def="dt-declaration">declaration</termref> of an accumulator. The
                     <code>name</code> attribute defines the name of the accumulator. The value of
                  the <code>name</code> attribute is an <termref def="dt-eqname">EQName</termref>,
                  which is expanded as described in <specref ref="qname"/>.</p>
               <p>An <elcode>xsl:accumulator</elcode> declaration can only appear as a <termref
                     def="dt-top-level"/> element in a stylesheet module.</p>
               <p diff="del" at="O">The effect is to declare one or two functions, each of arity
                  zero. The first function, called the pre-descent function, has the same name as
                  the accumulator itself, and the second, called the post-descent function, has the
                  name given by the <code>post-descent</code> attribute if present; if absent, the
                  post-descent function is not available. Both names follow the same rules as the
                     <code>name</code> attribute on the <elcode>xsl:function</elcode> attribute,
                  which means they must be namespace-qualified. </p>
               <p diff="del" at="O">The functions declared in an <elcode>xsl:accumulator</elcode>
                  declaration are referred to as <term>accumulator functions</term>.</p>
               <p diff="del" at="N">It is a <termref def="dt-static-error">static error</termref> if
                  neither of the attributes <code>name</code> nor <code>post-descent</code> is
                  present.</p>
               <p>The <phrase diff="chg" at="O">functions <function>accumulator-before</function>
                     and <function>accumulator-after</function></phrase> return, respectively, the
                  value of the accumulator before visiting the descendants of a given node, and the
                  value after visiting the descendants of a node. Each of these functions <phrase
                     diff="chg" at="O">takes a single argument, the name of the
                  accumulator</phrase>, and the function applies implicitly to the context node. The
                  type of the return value (for both functions) is determined by the <code>as</code>
                  attribute of the <elcode>xsl:accumulator</elcode> element.</p>
               <p diff="chg" at="O"><termdef id="dt-accumulator-function"
                     term="accumulator function">The functions
                        <function>accumulator-before</function> and
                        <function>accumulator-after</function> are referred to as the
                        <term>accumulator functions</term>.</termdef></p>
               <p><phrase diff="add" at="S-bug27273">For constructs that use accumulators to be
                        <termref def="dt-guaranteed-streamable"/>:</phrase></p>
               <ulist>
                  <item>
                     <p>The <function>accumulator-before</function> function for a streamed node can
                        be called at any time the node is available (it behaves like other
                        properties of the node such as <xfunction>name</xfunction> or
                           <xfunction>base-uri</xfunction>).</p>
                  </item>
                  <item>
                     <p>The <function>accumulator-after</function> function, however, is restricted
                           <phrase diff="del" at="S-bug27273">by virtue of the streamability
                           rules</phrase> to appear after any instruction that reads the descendants
                        of the node in question. The constraints are expressed as static rules: see
                           <specref ref="streamability-fn-accumulator-after"/> for more details.</p>
                  </item>
               </ulist>
               <p diff="del" at="R-bug26330">An accumulator is applicable to a particular document
                  if the <termref def="dt-pattern"/> supplied in the <code>applies-to</code>
                  attribute matches the first element node in the document (typically the outermost
                  element, though the definition allows for document nodes that have more than one
                  element child). The default value for the <code>applies-to</code> attribute is
                     <code>applies-to="*"</code>, which ensures that the accumulator is applicable
                  to every document provided that the document node has an element node child.</p>
               <p diff="del" at="S-bug27660">If the <code>applies-to</code> attribute is present on
                  the <elcode>xsl:accumulator</elcode> declaration then accumulator rules are
                  applied to a particular node only if the node has an ancestor-or-self that matches
                  the pattern supplied in the <code>applies-to</code> attribute. </p>
               <note diff="del" at="S-bug27660">
                  <p>The <code>applies-to</code> attribute can effectively be used to enable or
                     disable processing of an accumulator for a particular document. This is
                     particularly useful for streamed documents, since it may avoid the cost of
                     evaluating accumulator rules unnecessarily, and avoid the risk that evaluating
                     accumulator rules could cause dynamic errors if applied to documents for which
                     they were not designed. It is not an error to call the
                        <function>accumulator-before</function> or
                        <function>accumulator-after</function> functions on a document to which the
                     accumulator does not apply, but if there is no node in the document that
                     matches the <code>applies-to</code> pattern, then the accumulator will always
                     take its initial value.</p>
                  <p>Use of a pattern that can only match a document node or the outermost element
                     node (for example, <code>/x:html</code>, or
                        <code>document-node(element(x:html))</code>) may be more efficient than
                     using a pattern that could match anywhere within a document.</p>
                  <p><phrase diff="chg" at="S-bug27273">For an accumulator to be <termref
                           def="dt-guaranteed-streamable"/></phrase>, the <code>applies-to</code>
                     pattern must be motionless. Note that a pattern of the form
                        <code>document-node(element(fpml))</code> is classified as motionless even
                     though it involves a small amount of look-ahead.</p>
               </note>
               <p>The initial value of the accumulator is obtained by evaluating the expression in
                  the <code>initial-value</code> attribute. <phrase diff="add" at="S-bug27273">This
                     attribute is mandatory.</phrase> The expression in the
                     <code>initial-value</code> attribute is evaluated with <phrase diff="chg"
                     at="R-bug26268">a <termref def="dt-singleton-focus"/> based on the root node of
                     the streamed input tree to which the accumulator is being applied.</phrase></p>
               <p>The values of the accumulator for individual nodes in a tree are obtained by
                  applying the <elcode>xsl:accumulator-rule</elcode> rules contained within the
                     <elcode>xsl:accumulator</elcode> declaration, as described in subsequent
                  sections. <phrase diff="add" at="R-bug26737">The <code>match</code> attribute of
                        <elcode>xsl:accumulator-rule</elcode> is a <termref def="dt-pattern"/> which
                     determines which nodes trigger execution of the rule; the <code>phase</code>
                     attribute indicates whether the rule fires before descendants are processed
                        (<code>phase="start"</code>, which is the default), or after descendants are
                     processed (<code>phase="end"</code>).</phrase></p>
               <p>The <code>select</code> attribute and the contained sequence constructor of the
                     <elcode>xsl:accumulator-rule</elcode> element are mutually exclusive: if the
                     <code>select</code> attribute is present then the sequence constructor must be
                  empty. The expression in the <code diff="chg" at="R-bug26471">select</code>
                  attribute of <elcode>xsl:accumulator-rule</elcode>
                  <phrase diff="add" at="R-bug26471">or the contained sequence constructor</phrase>
                  is evaluated with a static context that follows the normal rules for expressions
                  in stylesheets, except that:</p>
               <ulist>
                  <item>
                     <p>An additional variable is present in the context. The name of this variable
                        is <code>value</code> (in no namespace), and its type is the type that
                        appears in the <code>as</code> attribute of the
                           <elcode>xsl:accumulator</elcode> declaration.</p>
                  </item>
                  <item>
                     <p>The context item for evaluation of the expression <phrase diff="add"
                           at="R-bug26471">or sequence constructor</phrase> will always be a node
                        that matches the <termref def="dt-pattern">pattern</termref> in the
                           <code>match</code> attribute.</p>
                  </item>
               </ulist>
               <p>The result of both the <code>initial-value</code> and <phrase diff="chg"
                     at="R-bug26471"><code>select</code> expressions (or contained sequence
                     constructor)</phrase> is converted to the type declared in the <code>as</code>
                  attribute by applying the <termref def="dt-function-conversion-rules"/>. A
                     <termref def="dt-type-error">type error</termref> occurs if conversion is not
                  possible. The <code>as</code> attribute defaults to <code>item()*</code>.</p>
               <p>The effect of the <code>streamable</code> attribute is defined in <specref
                     ref="streamability-of-accumulators"/>.</p>
            </div3>
            <div3 id="applicability-of-accumulators" diff="add" at="S-bug27660">
               <head>Applicability of Accumulators</head>
               <p>It is not the case that every accumulator is applicable to every tree. The details
                  depend on how the accumulator is declared, and how the tree is created. The rules
                  are as follows:</p>
               <olist diff="chg" at="T-bug29803">
                  <item>
                     <p>An accumulator is applicable to a tree unless otherwise specified in these
                        rules. (For example, when a document is read using the
                           <function>document</function>, <xfunction>doc</xfunction>, or
                           <xfunction>collection</xfunction> functions, all accumulators are
                        applicable. Similarly, all accumulators are applicable to a <termref
                           def="dt-temporary-tree"/> created using
                        <elcode>xsl:variable</elcode>.)</p>
                  </item>
                  <item>
                     <p>Regardless of the rules below, an accumulator is not applicable to a
                           <termref def="dt-streamed-document"/> unless the accumulator is declared
                        with <code>streamable="yes"</code>. (The converse does not apply: for
                        unstreamed documents, accumulators are applicable regardless of the value of
                        the <code>streamable</code> attribute.)</p>
                  </item>
                  <item>
                     <p diff="chg" at="T-bug29805">For a document read using the
                           <elcode>xsl:source-document</elcode> instruction, the accumulators that
                        are applicable are those determined by the <code>use-accumulators</code>
                        attribute of that instruction.</p>
                  </item>
                  <item>
                     <p>For a document read using the <code>for-each-source</code> attribute of an
                           <elcode>xsl:merge-source</elcode> child of an <elcode>xsl:merge</elcode>
                        instruction, the accumulators that are applicable are those determined by
                        the <code>use-accumulators</code> attribute of the
                           <elcode>xsl:merge-source</elcode> element.</p>
                  </item>
                  <item>
                     <p>For a document containing nodes supplied in the <termref
                           def="dt-initial-match-selection"/>, the accumulators that are applicable
                        are those determined by the <elcode>xsl:mode</elcode> declaration of the
                           <termref def="dt-initial-mode"/>. This means that in the absence of an
                           <elcode>xsl:mode</elcode> declaration, no accumulators are
                        applicable.</p>
                  </item>
                  <item>
                     <p>For a tree <var>T</var> created by copying a node in a tree <var>S</var>
                        using the <function>copy-of</function> or <function>snapshot</function>
                        functions, or the instruction <elcode>xsl:copy-of</elcode> with
                           <code>copy-accumulators="yes"</code>, an accumulator is applicable to
                           <var>T</var> if and only if it is applicable to <var>S</var>.</p>
                  </item>
               </olist>
               <p>If an accumulator is not applicable to the tree containing the context item, calls
                  to the functions <function>accumulator-before</function> and
                     <function>accumulator-after</function>, supplying the name of that accumulator,
                  will fail with a dynamic error.</p>
               <note>
                  <p>The reason that accumulators are not automatically applicable to every streamed
                     document is to avoid the cost of evaluating them, and to avoid the possibility
                     of dynamic errors occuring if they are not designed to work with a particular
                     document structure.</p>
                  <p>In the case of unstreamed documents, there are no compelling reasons to
                     restrict which accumulators are applicable, because an implementation can avoid
                     the cost of evaluating every accumulator against every document by evaluating
                     the accumulator lazily, for example, by only evaluating the accumulator for a
                     particular tree the first time its value is requested for a node in that tree.
                     In the interests of orthogonality, however, restricting the applicable
                     accumulators works in the same way for streamable and non-streamable documents.
                  </p>
               </note>
               <p>The value of the <phrase diff="chg" at="S-bug28129"
                     ><code>use-accumulators</code></phrase> attribute of
                     <elcode>xsl:source-document</elcode>, <elcode>xsl:merge-source</elcode>, or
                     <phrase diff="add" at="T-bug29803"><elcode>xsl:mode</elcode></phrase> must
                  either a whitespace-separated list of <termref def="dt-eqname">EQNames</termref>,
                  or the special token <code>#all</code>. The list may be empty, and the default
                  value is an empty list. Every <code>EQName</code> in the list must be the name of
                  an accumulator, visible in the containing package, and declared with
                     <code>streamable="yes"</code>. The value <code>#all</code> indicates that all
                  accumulators that are visible in the containing package are applicable (except
                  that for a streamable input document, an accumulator is not applicable unless it
                  specifies <code>streamable="yes"</code>).</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="3300"><p>It is a <termref
                           def="dt-static-error">static error</termref> if the list of accumulator
                        names <error.extra>in the <code>use-accumulators</code>
                           attribute</error.extra> contains an invalid token, contains the same
                        token more than once, or contains the token <code>#all</code> along with any
                        other value<phrase diff="add" at="S-bug28129">; or if any token (other than
                              <code>#all</code>) is not the name of a <termref
                              def="dt-declared-streamable"/> accumulator visible in the containing
                           package.</phrase></p></error>
               </p>
            </div3>
            <div3 id="accumulator-informal-rules">
               <head>Informal Model for Accumulators</head>
               <p diff="chg" at="S-bug28130"><emph>This section describes how accumulator values are
                     established by evaluating the rules in an <elcode>xsl:accumulator</elcode>
                     declaration. This process does not apply to trees created with accumulator
                     values copied from another document, for example by using the
                        <function>copy-of</function> or <function>snapshot</function>
                     functions.</emph></p>
               <p>Informally, an accumulator is evaluated by traversing a <phrase diff="chg"
                     at="R-bug26330">tree</phrase>, <phrase diff="chg" at="S-bug27273">as
                     follows.</phrase></p>
               <p diff="del" at="S-bug27660">If the <code>applies-to</code> attribute is present,
                  and a node is encountered that does not match the <code>applies-to</code> pattern,
                  then that node and all its descendants are skipped.</p>
               <p>Each node is visited twice, once before processing its descendants, and once after
                  processing its descendants. For consistency, this applies even to leaf nodes: each
                  is visited twice. Attribute and namespace nodes, however, are not visited.</p>
               <p>Before the traversal starts, a variable (called the accumulator variable) is
                  initialized to the value of the expression given as the <code>initial-value</code>
                  attribute.</p>
               <p>On each node visit, the <elcode>xsl:accumulator-rule</elcode> elements are
                  examined to see if there is a matching rule. For a match to occur, the pattern in
                  the <code>match</code> attribute must match the node, and the <code>phase</code>
                  attribute must be <code>start</code> if this is the first visit, and
                     <code>end</code> if it is the second visit. If there is a matching rule, then a
                  new value is computed for the accumulator variable using the expression contained
                  in that rule’s <phrase diff="chg" at="R-bug26471"><code>select</code> attribute or
                     the contained sequence constructor</phrase>. If there is more than one matching
                  rule, the last in document order is used. If there is no matching rule, the value
                  of the accumulator variable does not change.</p>
               <p>Each node is labeled with a pre-descent value for the accumulator, which is the
                  value of the accumulator variable immediately <emph>after</emph> processing the
                  first visit to that node, and with a post-descent value for the accumulator, which
                  is the value of the accumulator variable immediately <phrase diff="chg"
                     at="R-bug26328"><emph>after</emph></phrase> processing the second visit.</p>
               <p diff="add" at="O">The function <function>accumulator-before</function> delivers
                  the pre-descent value of the accumulator at the context node; the function
                     <function>accumulator-after</function> delivers the post-descent value of the
                  accumulator at the context node.</p>
               <p>Although this description is expressed in procedural terms, it can be seen that
                  the two values of the accumulator for any given node depend only on the node and
                  its preceding and (in the case of the post-descent value) descendant nodes.
                  Calculation of both values is therefore deterministic and free of side-effects;
                  moreover, it is clear that the values can be computed during a streaming pass of a
                  document, provided that the rules themselves use only information that is
                  available without repositioning the input stream.</p>
               <p diff="chg" at="O">It is permitted for the <phrase diff="chg" at="R-bug26471"
                        ><code>select</code> expression of an accumulator rule, or the contained
                     sequence constructor</phrase>, to invoke an accumulator function. <phrase
                     diff="chg" at="R-bug26328">For a streamable accumulator, the rules ensure that
                     a rule with <code>phase="start"</code> cannot call the
                        <function>accumulator-after</function> function. When such function calls
                     exist in an accumulator rule, they impose a dependency of one accumulator on
                     another, and create the possibility of cyclic dependencies. Processors are
                     allowed to report the error statically if they can detect it statically.
                     Failing this, processors are allowed to fail catastrophically in the event of a
                     cycle, in the same way as they might fail in the event of infinite function or
                     template recursion. Catastrophic failure might manifest itself, for example, as
                     a stack overflow, or as non-termination of the transformation.</phrase></p>
            </div3>
            <div3 id="accumulator-formal-rules">
               <head>Formal Model for Accumulators</head>
               <p diff="chg" at="S-bug28130"><emph>This section describes how accumulator values are
                     established by evaluating the rules in an <elcode>xsl:accumulator</elcode>
                     declaration. This process does not apply to trees created with accumulator
                     values copied from another document, for example by using the
                        <function>copy-of</function> or <function>snapshot</function>
                     functions.</emph></p>
               <p><termdef id="dt-traversal" term="traversal">A <term>traversal</term> of a tree is
                     a sequence of <termref def="dt-traversal-event">traversal
                     events</termref>.</termdef></p>
               <p><termdef id="dt-traversal-event" term="traversal-event">a <term>traversal
                        event</term> (shortened to <term>event</term> in this section) is a pair
                     comprising a phase (start or end) and a node.</termdef> It is modelled as a map
                  with two entries: <code>map{"phase": p, "node": n}</code> where p is the string
                     <code>"start"</code> or <code>"end"</code> and <code>n</code> is a node.</p>
               <p>The traversal of a <phrase diff="chg" at="R-bug26330">tree</phrase> contains two
                  traversal events for each node in the tree, other than attribute and namespace
                  nodes. One of these events (the “start event”) has phase = "start", the other (the
                  "end event") has phase = "end".</p>
               <p>The order of traversal events within a traversal is such that, given any two nodes
                     <var>M</var> and <var>N</var> with start/end events denoted by <var>M0</var>,
                     <var>M1</var>, <var>N0</var>, and <var>N1</var>, :</p>
               <ulist>
                  <item>
                     <p>For any node <var>N</var>, <var>N0</var> precedes <var>N1</var>;</p>
                  </item>
                  <item>
                     <p>If <var>M</var> is an ancestor of <var>N</var> then <var>M0</var> precedes
                           <var>N0</var> and <var>N1</var> precedes <var>M1</var>;</p>
                  </item>
                  <item>
                     <p>If <var>M</var> is on the preceding axis of <var>N</var> then <var>M1</var>
                        precedes <var>N0</var>.</p>
                  </item>
               </ulist>
               <p>The accumulator defines a (private) delta function <var>Δ</var>. The delta
                  function computes the value of the accumulator for one traversal event in terms of
                  its value for the previous traversal event. The function is defined as
                  follows:</p>
               <olist>
                  <item>
                     <p>The signature of <var>Δ</var> is <code>function ($old-value as T, $event as
                           map(*)) as T</code>, where <var>T</var> is the sequence type declared in
                        the <code>as</code> attribute of the accumulator declaration;</p>
                  </item>
                  <item>
                     <p>The implementation of the function is equivalent to the following
                        algorithm:</p>
                     <olist>
                        <item>
                           <p>Let <var>R</var> be the set of <elcode>xsl:accumulator-rule</elcode>
                              elements among the children of the accumulator declaration whose
                                 <code>phase</code> attribute equals <code>$event("phase")</code>
                              and whose <code>match</code> attribute is a <termref def="dt-pattern"
                                 >pattern</termref> that matches <code>$event("node")</code></p>
                        </item>
                        <item>
                           <p>If <var>R</var> is empty, return <code>$old-value</code></p>
                        </item>
                        <item>
                           <p>Let <var>Q</var> be the <elcode>xsl:accumulator-rule</elcode> in
                                 <var>R</var> that is last in document order</p>
                        </item>
                        <item>
                           <p>Return the value of the expression in the <code>select</code>
                              attribute of <var>Q</var>, <phrase diff="add" at="R-bug26471">or the
                                 contained sequence constructor,</phrase> evaluating this with a
                                 <termref def="dt-singleton-focus">singleton focus</termref> set to
                                 <code>$event("node")</code> and with a dynamic context that binds
                              the variable whose name is <phrase diff="add" at="26289"
                                    ><code>$value</code> (in no namespace)</phrase> to the value
                                 <code>$old-value</code>.</p>
                           <note diff="add" at="26289">
                              <p>The argument names <code>old-value</code> and <code>event</code>
                                 are used here purely for definitional purposes; these names are not
                                 available for use within the <phrase diff="chg" at="R-bug26471"
                                       ><code>select</code> expression or contained sequence
                                    constructor</phrase>.</p>
                           </note>
                        </item>
                     </olist>
                  </item>
               </olist>
               <p>For every node <var>N</var>, other than attribute and namespace nodes, the
                  accumulator defines a pre-descent value <var>B/N</var> and a post-descent value
                     <var>A/N</var> whose values are as follows:</p>
               <olist>
                  <item>
                     <p>Let <var>T</var> be the <termref def="dt-traversal">traversal</termref> of
                        the tree rooted at <code>fn:root(N)</code>.</p>
                  </item>
                  <item>
                     <p>Let <var>SB</var> be the subsequence of <var>T</var> starting at the first
                        event in <var>T</var> and ending with the start event for node <var>N</var>
                        (that is, the event <code>map{ "phase":"start", "node":N }</code>).</p>
                  </item>
                  <item>
                     <p>Let <var>SA</var> be the subsequence of <var>T</var> starting at the first
                        event in <var>T</var>, and ending with the <phrase diff="del"
                           at="R-bug26328">event that immediately precedes the</phrase> end event
                        for node <var>N</var> (that is, the event <code>map{ "phase":"end", "node":N
                           }</code>).</p>
                  </item>
                  <item>
                     <p>Let <var>Z</var> be the result of evaluating the expression contained in the
                           <code>initial-value</code> attribute of the
                           <elcode>xsl:accumulator</elcode> declaration, <phrase diff="chg"
                           at="R-bug26268">evaluated with a <termref def="dt-singleton-focus"/>
                           based on <code>root(N)</code></phrase>.</p>
                  </item>
                  <item>
                     <p>Then the pre-descent value <var>B/N</var> is the value of
                           <code>fn:fold-left(SB, Z, Δ)</code>, and the post-descent value
                           <var>A/N</var> is the value of <code>fn:fold-left(SA, Z, Δ)</code>.</p>
                  </item>
               </olist>
            </div3>
            <div3 id="errors-in-accumulators" diff="add" at="T-bug29813">
               <head>Dynamic Errors in Accumulators</head>
               <p>If a dynamic error occurs when evaluating the <code>initial-value</code>
                  expression of <elcode>xsl:accumulator</elcode>, or the <code>select</code>
                  expression of <elcode>xsl:accumulator-rule</elcode>, then the error is signaled as
                  an error from any subsequent call on <function>accumulator-before</function> or
                     <function>accumulator-after</function> that references the accumulator. If no
                  such call on <function>accumulator-before</function> or
                     <function>accumulator-after</function> happens, then the error goes
                  unreported.</p>
               <note>
                  <p>In the above rule, the phrase <term>subsequent call</term> is to be understood
                     in terms of functional dependency; that is, a call to
                        <function>accumulator-before</function> or
                        <function>accumulator-after</function> signals an error if the accumulator
                     value at the node in question is functionally dependent on a computation that
                     fails with a dynamic error.</p>
               </note>
               <note>
                  <p>Particularly in the case of streamed accumulators, this may mean that the
                     implementation has to “hold back” the error until the next time the accumulator
                     is referenced, to give applications the opportunity to catch the error using
                        <elcode>xsl:try</elcode> and <elcode>xsl:catch</elcode> in a predictable
                     way.</p>
               </note>
               <note>
                  <p>Errors that occur during the evaluation of the pattern in the
                        <code>match</code> attribute of <elcode>xsl:accumulator-rule</elcode> are
                     handled as described in <specref ref="pattern-errors"/>: specifically, the
                     pattern does not match the relevant node, and no error is signaled.</p>
               </note>
            </div3>
            <div3 id="func-accumulator-before" diff="chg" at="Q">
               <head>fn:accumulator-before</head>
               <glist>
                  <gitem>
                     <label>Summary</label>
                     <def>
                        <p>Returns the pre-descent value of the selected accumulator at the context
                           node.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Signature</label>
                     <def>
                        <example role="signature">
                           <proto name="accumulator-before" return-type="item()*" isOp="no"
                              prefix="fn" returnEmptyOk="no" returnSeq="no" returnVaries="no"
                              isSchema="no" isDatatype="no" isSpecial="no">
                              <arg name="name" type="xs:string"/>
                           </proto>
                        </example>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Properties</label>
                     <def>
                        <p>This function is <xtermref spec="FO30" ref="dt-deterministic"
                              >deterministic</xtermref>, <xtermref spec="FO30"
                              ref="dt-context-dependent">context-dependent</xtermref>, and <xtermref
                              spec="FO30" ref="dt-focus-dependent">focus-dependent</xtermref>. </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Rules</label>
                     <def>
                        <p>The <code>$name</code> argument specifies the name of the <termref
                              def="dt-accumulator"/>. The value of the argument
                              <rfc2119>must</rfc2119> be a <phrase diff="chg" at="Q">string
                              containing an <termref def="dt-eqname"/>.</phrase> If it is a <termref
                              def="dt-lexical-qname">lexical QName</termref>, then it is expanded as
                           described in <specref ref="qname"/> (no prefix means no namespace).</p>
                        <p>The function returns the pre-descent value <var>B(N)</var>of the selected
                           accumulator where <var>N</var> is the context node, as defined in
                              <specref ref="accumulator-formal-rules"/>.</p>
                        <p diff="add" at="R-bug26328">If the context item is a node in a streamed
                           document, then the accumulator must be declared with
                              <code>streamable="yes"</code>.</p>
                        <note diff="add" at="R-bug26328">
                           <p>The converse is not true: an accumulator declared to be streamable is
                              available on both streamed and unstreamed nodes.</p>
                        </note>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Error Conditions</label>
                     <def>
                        <p>
                           <error spec="XT" type="dynamic" class="DE" code="3340"><p>It is a
                                    <termref def="dt-dynamic-error"/> if the value of the first
                                 argument to the <function>accumulator-before</function> or
                                    <function>accumulator-after</function> function is not a valid
                                    <termref def="dt-eqname"/>, or if there is no namespace
                                 declaration in scope for the prefix of the QName, or if the name
                                 obtained by expanding the QName is not the same as the expanded
                                 name of any <elcode>xsl:accumulator</elcode> declaration <phrase
                                    diff="chg" at="S-bug27648">appearing</phrase> in the <termref
                                    def="dt-package">package</termref> in which the function call
                                 appears. If the processor is able to detect the error statically
                                 (for example, when the argument is supplied as a string literal),
                                 then the processor <rfc2119>may</rfc2119> optionally signal this as
                                 a <termref def="dt-static-error">static
                              error</termref>.</p></error>
                        </p>
                        <p>
                           <error spec="XT" type="dynamic" class="DE" code="3350"><p>It is a
                                    <termref def="dt-dynamic-error">dynamic error</termref> to call
                                 the <function>accumulator-before</function> or
                                    <function>accumulator-after</function> function when there is no
                                    <termref def="dt-context-item"/>.</p></error>
                        </p>
                        <p>
                           <error spec="XT" type="dynamic" class="TE" code="3360"><p>It is a
                                    <termref def="dt-type-error">type error</termref> to call the
                                    <function>accumulator-before</function> or
                                    <function>accumulator-after</function> function when the
                                    <termref def="dt-context-item"/> is not a node, or when it is an
                                 attribute or namespace node.</p></error>
                        </p>
                        <p diff="chg" at="R-bug26328">
                           <error spec="XT" type="dynamic" class="DE" code="3362"><p>It is a
                                    <termref def="dt-dynamic-error">dynamic error</termref> to call
                                 the <function>accumulator-before</function> or
                                    <function>accumulator-after</function> function when the context
                                 item is a node in a tree to which the selected accumulator is not
                                    <phrase diff="add" at="S-bug27660">applicable (including the
                                    case where it is not applicable because the document is streamed
                                    and the accumulator is not </phrase> declared with
                                    <code>streamable="yes"</code>). <phrase diff="add"
                                    at="S-bug27273">Implementations <rfc2119>may</rfc2119> raise
                                    this error but are <rfc2119>not required</rfc2119> to do so, if
                                    they are capable of streaming documents without imposing this
                                    restriction.</phrase></p></error>
                        </p>
                        <p>
                           <error spec="XT" type="dynamic" class="DE" code="3400"><p diff="chg"
                                 at="R-bug26328">It is an error if there is a cyclic set of
                                 dependencies among accumulators such that the (pre- or
                                 post-descent) value of an accumulator depends directly or
                                 indirectly on itself. A processor <rfc2119>may</rfc2119> report
                                 this as a <termref def="dt-static-error"/> if it can be detected
                                 statically. Alternatively a processor <rfc2119>may</rfc2119> report
                                 this as a <termref def="dt-dynamic-error"/>. As a further option, a
                                 processor may fail catastrophically when this error
                              occurs.</p></error></p>
                        <note>
                           <p>The term <term>catastrophic failure</term> here means a failure
                              similar to infinite function or template recursion, which might result
                              in stack overflow or even in non-termination of the transformation,
                              rather than in a dynamic error of the kind that can be processed using
                                 <elcode>xsl:try</elcode> and <elcode>xsl:catch</elcode>.</p>
                        </note>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Notes</label>
                     <def>
                        <p role="note">The <function>accumulator-before</function> function can be
                           applied to a node whether or not the accumulator has a
                              <code>phase="start"</code> rule for that node. In effect, there is a
                              <code>phase="start"</code> rule for every node, where the default rule
                           is to leave the accumulator value unchanged; the
                              <function>accumulator-before</function> function delivers the value of
                           the accumulator after processing the explicit or implicit
                              <code>phase="start"</code> rule.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Examples</label>
                     <def role="example">
                        <p>Given the accumulator:</p>
                        <eg diff="chg" at="R-bug26737" xml:space="preserve">
&lt;xsl:accumulator name="a" initial-value="0"&gt;
   &lt;xsl:accumulator-rule match="section" select="$value + 1"/&gt;
&lt;/xsl:accumulator&gt;</eg>
                        <p>and the template rule:</p>
                        <eg xml:space="preserve">
&lt;xsl:template match="section"&gt;
   &lt;xsl:value-of select="accumulator-before('a')"/&gt;
   &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;</eg>
                        <p>The stylesheet will precede the output from processing each section with
                           a section number that runs sequentially 1, 2, 3... irrespective of the
                           nesting of sections.</p>
                     </def>
                  </gitem>
               </glist>
            </div3>
            <div3 id="func-accumulator-after" diff="chg" at="Q">
               <head>fn:accumulator-after</head>
               <glist>
                  <gitem>
                     <label>Summary</label>
                     <def>
                        <p>Returns the post-descent value of the selected accumulator at the context
                           node.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Signature</label>
                     <def>
                        <example role="signature">
                           <proto name="accumulator-after" return-type="item()*" isOp="no"
                              prefix="fn" returnEmptyOk="no" returnSeq="no" returnVaries="no"
                              isSchema="no" isDatatype="no" isSpecial="no">
                              <arg name="name" type="xs:string"/>
                           </proto>
                        </example>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Properties</label>
                     <def>
                        <p>This function is <xtermref spec="FO30" ref="dt-deterministic"
                              >deterministic</xtermref>, <xtermref spec="FO30"
                              ref="dt-context-dependent">context-dependent</xtermref>, and <xtermref
                              spec="FO30" ref="dt-focus-dependent">focus-dependent</xtermref>. </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Rules</label>
                     <def>
                        <p>The <code>$name</code> argument specifies the name of the <termref
                              def="dt-accumulator"/>. The value of the argument
                              <rfc2119>must</rfc2119> be a <phrase diff="chg" at="Q">string
                              containing an <termref def="dt-eqname">EQName</termref>.</phrase> If
                           it is a <termref def="dt-lexical-qname">lexical QName</termref>, then it
                           is expanded as described in <specref ref="qname"/> (no prefix means no
                           namespace).</p>
                        <p>The function returns the post-descent value <var>A(N)</var> of the
                           selected accumulator where <var>N</var> is the context node, as defined
                           in <specref ref="accumulator-formal-rules"/>.</p>
                        <p diff="add" at="S-bug27273">If the context item is a node in a streamed
                           document, then the accumulator must be declared with
                              <code>streamable="yes"</code>.</p>
                        <note diff="add" at="S-bug27273">
                           <p>The converse is not true: an accumulator declared to be streamable is
                              available on both streamed and unstreamed nodes.</p>
                        </note>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Error Conditions</label>
                     <def>
                        <p>The following errors apply: <errorref spec="XT" type="dynamic" class="DE"
                              code="3340"/>, <errorref spec="XT" type="dynamic" class="DE"
                              code="3350"/>, <errorref spec="XT" type="type" class="TE" code="3360"
                           />, <errorref spec="XT" type="dynamic" class="DE" code="3362"/>,
                              <errorref spec="XT" type="dynamic" class="DE" code="3400"/>. </p>
                        <p>For constraints on the use of <function>accumulator-after</function> when
                           streaming, see <specref ref="streamability-fn-accumulator-after"/>.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Notes</label>
                     <def>
                        <p role="note">The <function>accumulator-after</function> function can be
                           applied to a node whether or not the accumulator has a
                              <code>phase="end"</code> rule for that node. In effect, there is a
                              <code>phase="end"</code> rule for every node, where the default rule
                           is to leave the accumulator value unchanged; the
                              <function>accumulator-after</function> function delivers the value of
                           the accumulator after processing the explicit or implicit
                              <code>phase="end"</code> rule.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Examples</label>
                     <def role="example">
                        <p>Given the accumulator:</p>
                        <eg xml:space="preserve">
&lt;xsl:accumulator name="w" initial-value="0" streamable="true" as="xs:integer"&gt;
   &lt;xsl:accumulator-rule match="text()" 
                         select="$value + count(tokenize(.))"/&gt;
&lt;/xsl:accumulator&gt;</eg>
                        <p>and the template rule:</p>
                        <eg xml:space="preserve">
&lt;xsl:template match="section"&gt;
   &lt;xsl:apply-templates/&gt;
   (words: &lt;xsl:value-of select="accumulator-after('w') - accumulator-before('w')"/&gt;)
&lt;/xsl:template&gt;</eg>
                        <p>The stylesheet will output at the end of each section a (crude) count of
                           the number of words in that section<phrase diff="del" at="S-bug27273">,
                              irrespective of the nesting of sections</phrase>.</p>
                        <p><emph>Note: the call on <code>tokenize(.)</code> relies on XPath
                              3.1</emph></p>
                     </def>
                  </gitem>
               </glist>
            </div3>
            <div3 id="accumulators-visibility-and-overriding">
               <head>Importing of Accumulators</head>
               <p diff="add" at="N">If a <phrase diff="chg" at="S-bug27273"><termref
                        def="dt-package">package</termref></phrase> contains more than one
                     <elcode>xsl:accumulator</elcode> declaration with a particular name, then the
                  one with the highest <termref def="dt-import-precedence"/> is used.</p>
               <p diff="add" at="N">
                  <error spec="XT" type="static" class="SE" code="3350"><p>It is a <termref
                           def="dt-static-error">static error</termref> for a <termref
                           def="dt-package">package</termref> to contain two or more non-hidden
                        accumulators with the same <termref def="dt-expanded-qname">expanded
                           QName</termref> and the same <termref def="dt-import-precedence">import
                           precedence</termref>, unless there is another accumulator with the same
                           <termref def="dt-expanded-qname">expanded QName</termref>, and a higher
                        import precedence.</p></error>
               </p>
               <p diff="add" at="S-bug27648">Accumulators cannot be referenced from, or overridden
                  in, a different package from the one in which they are declared.</p>
               <p diff="del" at="R-bug24547"><error spec="XT" type="static" class="SE" code="3360"
                        ><p>It is a <termref def="dt-static-error">static error</termref> for a
                           <termref def="dt-package">package</termref> to contain a non-hidden
                        accumulator if either the pre-descent or post-descent functions have the
                        same name as a non-hidden <termref def="dt-stylesheet-function"/> in the
                        same package.</p></error></p>
            </div3>
            <div3 id="streamability-of-accumulators" diff="add" at="O">
               <head>Streamability of Accumulators</head>
               <p diff="chg" at="P">An accumulator is <termref def="dt-guaranteed-streamable"/> if
                  it satisfies <phrase diff="chg" at="R-bug24547">all</phrase> the following
                  conditions:</p>
               <olist>
                  <item diff="add" at="R-bug24649">
                     <p>The <elcode>xsl:accumulator</elcode> declaration has the attribute
                           <code>streamable="yes"</code>.</p>
                  </item>
                  <item diff="del" at="S-bug27660">
                     <p>The <termref def="dt-pattern">pattern</termref> in the
                           <code>applies-to</code> attribute, if present, is a <termref
                           def="dt-motionless"/> pattern <phrase diff="add" at="S-bug27273">(see
                              <specref ref="classifying-patterns"/>)</phrase>.</p>
                  </item>
                  <item>
                     <p>In every contained <elcode>xsl:accumulator-rule</elcode>, the <termref
                           def="dt-pattern">pattern</termref> in the <code>match</code> attribute is
                        a <termref def="dt-motionless"/> pattern <phrase diff="add" at="S-bug27273"
                           >(see <specref ref="classifying-patterns"/>)</phrase>.</p>
                  </item>
                  <item diff="add" at="R-bug24547">
                     <p>The <termref def="dt-expression">expression</termref> in the
                           <code>initial-value</code> attribute is <termref def="dt-grounded"/> and
                           <termref def="dt-motionless"/>.</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-expression">expression</termref> in the <phrase
                           diff="chg" at="R-bug26471"><code>select</code> attribute or contained
                           sequence constructor</phrase> is <phrase diff="add" at="R-bug24547"
                              ><termref def="dt-grounded"/> and</phrase>
                        <termref def="dt-motionless"/>.</p>
                  </item>
               </olist>
               <p diff="add" at="P">Specifying <code>streamable="yes"</code> on an
                     <elcode>xsl:accumulator</elcode> element declares an intent that the
                  accumulator should be <phrase diff="chg" at="S-bug27273">streamable, either
                     because it is <termref def="dt-guaranteed-streamable"/>, or because it takes
                     advantage of streamability extensions offered by a particular
                     processor</phrase>. The consequences of declaring the accumulator to be
                  streamable when it is not in fact guaranteed streamable depend on the conformance
                  level of the processor, and are explained in <specref
                     ref="streamability-guarantees"/>.</p>
               <p diff="chg" at="R-bug26328">When an accumulator is declared to be streamable, the
                  stylesheet author must ensure that the accumulator function
                     <function>accumulator-after</function> is only called at appropriate points in
                  the processing, as explained in <specref ref="streamability-fn-accumulator-after"
                  />.</p>
            </div3>
            <div3 id="copying-accumulators" diff="add" at="S-bug28130">
               <head>Copying Accumulator Values</head>
               <p>When nodes (including streamed nodes) are copied using the
                     <function>snapshot</function> or <function>copy-of</function> functions, or
                  using the <elcode>xsl:copy-of</elcode> instruction with the attribute
                     <code>copy-accumulators="yes"</code>, then the pre-descent and post-descent
                  values of accumulators for that tree are not determined by traversing the tree as
                  described in <specref ref="accumulator-informal-rules"/> and <specref
                     ref="accumulator-formal-rules"/>. Instead the values are the same as the values
                  on the corresponding nodes of the source tree. </p>
               <p>This applies also to the implicit invocation of the <function>snapshot</function>
                  function that happens during the evaluation of <elcode>xsl:merge</elcode>.</p>
               <p>If an accumulator is not applicable to a tree <var>S</var>, then it is also not
                  applicable to any tree formed by copying nodes from <var>S</var> using the above
                  methods.</p>
               <note>
                  <p>During streamed processing, accumulator values will typically be computed “on
                     the fly”; when the <function>copy-of</function> or
                        <function>snapshot</function> functions are applied to a streamed node, the
                     computed accumulator values for the streamed document will typically be
                     materialized and saved as part of the copy.</p>
                  <p>Accumulator values for a non-streamed document will often be computed lazily,
                     that is, they will not be computed unless and until they are needed. A call on
                        <function>copy-of</function> or <function>snapshot</function> on a
                     non-streamed document whose accumulator values have not yet been computed can
                     then be handled in a variety of ways. The implementation might interpret the
                     call on <function>copy-of</function> or <function>snapshot</function> as a
                     trigger causing the accumulator values to be computed; or it might retain a
                     link between the nodes of the copied tree and the nodes of the original tree,
                     so that a request for accumulator values on the copied tree can trigger
                     computation of accumulator values for the original tree. </p>
               </note>
            </div3>
            <div3 id="accumulator-examples">
               <head>Examples of Accumulators</head>
               <example>
                  <head>Remember the Title of a Document</head>
                  <p>Consider an XHTML document in which the title of the document is represented by
                     the content of a <code>title</code> element appearing as a child of the
                        <code>head</code> element, which in turn appears as a child of the
                        <code>html</code> element. Suppose that we want to process the document in
                     streaming mode, and that we want to avoid outputting the content of the
                        <code>h1</code> element if it is the same as the document title.</p>
                  <p>This can be achieved by remembering the value of the title in an accumulator
                     variable.</p>
                  <eg diff="chg" at="S-bug27273" role="xslt-declaration" xml:space="preserve">
  &lt;xsl:accumulator name="firstTitle" as="xs:string?" initial-value="()" 
                                                     streamable="yes"&gt;
    &lt;xsl:accumulator-rule match="/html/head/title/text()" select="string(.)"/&gt;
  &lt;/xsl:accumulator&gt;
  </eg>
                  <p>Subsequently, while processing an <code>h1</code> element appearing later in
                     the document, the value can be referenced:</p>
                  <eg diff="chg" at="P-bug22805" role="xslt-declaration" xml:space="preserve">
  &lt;xsl:template match="h1"&gt;
    &lt;xsl:variable name="firstTitle" select="accumulator-before('firstTitle')"/&gt;
    &lt;xsl:variable name="thisTitle" select="string(.)"/&gt;
    &lt;xsl:if test="$thisTitle ne $firstTitle"&gt;
      &lt;div class="heading-1"&gt;&lt;xsl:value-of select="$thisTitle"/&gt;&lt;/div&gt;
    &lt;/xsl:if&gt;
    &lt;/xsl:template&gt;</eg>
                  <note diff="del" at="R-bug26737">
                     <p>This example illustrates that the order of the variable declarations within
                        a sequence constructor is significant, even when there is no direct
                        dependency of one variable on another.</p>
                  </note>
               </example>
               <example>
                  <head>Keep a Word Count</head>
                  <p>Suppose that there is a requirement to output, at the end of the HTML rendition
                     of a document, a paragraph giving the total number of words in the
                     document.</p>
                  <p>An accumulator can be used to maintain a (crude) word count as follows:</p>
                  <eg role="xslt-declaration" xml:space="preserve">
  &lt;xsl:accumulator name="word-count" 
                   as="xs:integer" 
                   initial-value="0"&gt;
    &lt;xsl:accumulator-rule match="text()" 
         select="$value + count(tokenize(.))"/&gt;
  &lt;/xsl:accumulator&gt;
  </eg>
                  <p><emph>Note: the call on <code>tokenize#1</code> relies on XPath 3.1</emph></p>
                  <p>The final value can be output at the end of the document:</p>
                  <eg role="xslt-declaration" xml:space="preserve">
   &lt;xsl:template match="/"&gt;
     &lt;xsl:apply-templates/&gt;
     &lt;p&gt;Word count: &lt;xsl:value-of select="accumulator-after('word-count')"/&gt;&lt;/p&gt;
   &lt;/xsl:template&gt;</eg>
               </example>
               <example>
                  <head>Output Hierarchic Section Numbers</head>
                  <p>Consider a document in which <code>section</code> elements are nested within
                        <code>section</code> elements to arbitrary depth, and there is a requirement
                     to render the document with hierarchic section numbers of the form
                        <code>3.5.1.4</code>.</p>
                  <p>The current section number can be maintained in an accumulator in the form of a
                     sequence of integers, managed as a stack. The number of integers represents the
                     current level of nesting, and the value of each integer represents the number
                     of preceding sibling sections encountered at that level. For convenience the
                     first item in the sequence represents the top of the stack.</p>
                  <eg role="xslt-declaration" xml:space="preserve">
&lt;xsl:accumulator name="section-nr" as="xs:integer*" 
                 initial-value="0"&gt;
  &lt;xsl:accumulator-rule match="section" phase="start" 
                 select="0, head($value)+1, tail($value)"/&gt;
  &lt;xsl:accumulator-rule match="section" phase="end" 
                 select="tail($value) (:pop:)"/&gt;
&lt;/xsl:accumulator&gt;  
</eg>
                  <p>To illustrate this, consider the values after processing a series of start and
                     end tags:</p>
                  <table class="data">
                     <caption>Example data illustrating the effect of parsing events on an
                        accumulator</caption>
                     <thead>
                        <tr>
                           <th rowspan="1" colspan="1">events</th>
                           <th rowspan="1" colspan="1">accumulator value</th>
                           <th rowspan="1" colspan="1">required section number</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td rowspan="1" colspan="1"><code>&lt;section&gt;</code></td>
                           <td rowspan="1" colspan="1"><code>0, 1</code></td>
                           <td rowspan="1" colspan="1">1</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><code>&lt;section&gt;</code></td>
                           <td rowspan="1" colspan="1"><code>0, 1, 1</code></td>
                           <td rowspan="1" colspan="1">1.1</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><code>&lt;/section&gt;</code></td>
                           <td rowspan="1" colspan="1"><code>1, 1</code></td>
                           <td rowspan="1" colspan="1"> </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><code>&lt;section&gt;</code></td>
                           <td rowspan="1" colspan="1"><code>0, 2, 1</code></td>
                           <td rowspan="1" colspan="1">1.2</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><code>&lt;/section&gt;</code></td>
                           <td rowspan="1" colspan="1"><code>2, 1</code></td>
                           <td rowspan="1" colspan="1"> </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><code>&lt;section&gt;</code></td>
                           <td rowspan="1" colspan="1"><code>0, 3, 1</code></td>
                           <td rowspan="1" colspan="1">1.3</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><code>&lt;section&gt;</code></td>
                           <td rowspan="1" colspan="1"><code>0, 1, 3, 1</code></td>
                           <td rowspan="1" colspan="1">1.3.1</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><code>&lt;/section&gt;</code></td>
                           <td rowspan="1" colspan="1"><code>1, 3, 1</code></td>
                           <td rowspan="1" colspan="1"> </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><code>&lt;section&gt;</code></td>
                           <td rowspan="1" colspan="1"><code>0, 2, 3, 1</code></td>
                           <td rowspan="1" colspan="1">1.3.2</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><code>&lt;/section&gt;</code></td>
                           <td rowspan="1" colspan="1"><code>2, 3, 1</code></td>
                           <td rowspan="1" colspan="1"> </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><code>&lt;/section&gt;</code></td>
                           <td rowspan="1" colspan="1"><code>3, 1</code></td>
                           <td rowspan="1" colspan="1"> </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><code>&lt;/section&gt;</code></td>
                           <td rowspan="1" colspan="1"><code>1</code></td>
                           <td rowspan="1" colspan="1"> </td>
                        </tr>
                     </tbody>
                  </table>
                  <p>The section number for a section can thus be generated as:</p>
                  <eg diff="chg" at="S-bug27273" role="xslt-declaration" xml:space="preserve">
&lt;xsl:template match="section"&gt;
  &lt;p&gt;
    &lt;xsl:value-of select="reverse(tail(accumulator-before('section-nr')))" 
                  separator="."/&gt;
  &lt;/p&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;
                  </eg>
               </example>
               <example>
                  <head>Compute a Histogram showing the Number of Books, by Publisher</head>
                  <eg diff="chg" at="R-bug26737" role="xslt-declaration" xml:space="preserve">
 &lt;xsl:accumulator name="histogram" as="map(xs:string, xs:integer)"
    initial-value="map{}"&gt;
    &lt;xsl:accumulator-rule match="book"&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="map:contains($value, @publisher)"&gt;
          &lt;xsl:sequence select="map:put($value, string(@publisher), 
                                        $value(@publisher)+1)"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:sequence select="map:put($value, string(@publisher), 1)"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/xsl:accumulator-rule&gt;  
 &lt;/xsl:accumulator&gt;</eg>
                  <p>The <code diff="chg" at="R-bug26471">contained sequence constructor</code> is
                     evaluated with the variable <code>$value</code> set to the current value, and
                     with the context node as the node being visited.</p>
                  <note diff="add" at="S-bug28320">
                     <p>In the two calls on <code>map:put()</code>, it is necessary to explicitly
                        convert <code>@publisher</code> to an <code>xs:string</code> value, because
                        this is the declared type of the keys in the result map. Relying on
                        atomization would produce keys of type <code>xs:untypedAtomic</code>, which
                        would not satisfy the declared type of the map.</p>
                  </note>
                  <p diff="add" at="S-bug27273">The accumulated histogram might be displayed as
                     follows:</p>
                  <eg diff="add" at="S-bug27273" role="xslt-instruction" xml:space="preserve">
 &lt;xsl:source-document streamable="yes" href="booklist.xml"&gt;
   .....
   &lt;h1&gt;Number of books, by publisher&lt;/h1&gt;
   &lt;table&gt;
     &lt;thead&gt;
       &lt;th&gt;Publisher&lt;/th&gt;
       &lt;th&gt;Number of books&lt;/th&gt;
     &lt;/thead&gt;
     &lt;tbody&gt;
       &lt;xsl:variable name="histogram" select="accumulator-after('histogram')"/&gt;
       &lt;xsl:for-each select="map:keys($histogram)"&gt;
         &lt;tr&gt;
           &lt;td&gt;&lt;xsl:value-of select="."/&gt;&lt;/td&gt;
           &lt;td&gt;&lt;xsl:value-of select="$histogram(.)"/&gt;&lt;/td&gt;
         &lt;/tr&gt;
       &lt;/xsl:for-each&gt;
     &lt;/tbody&gt;
   &lt;/table&gt;
 &lt;/xsl:source-document&gt;</eg>
               </example>
            </div3>
         </div2>
         <div2 id="func-copy-of">
            <head>fn:copy-of</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>Returns a deep copy of the <phrase diff="chg" at="S-bug29141"
                           >sequence</phrase> supplied as the <code>$input</code> argument, or of
                        the context <phrase diff="chg" at="S-bug29141">item</phrase> if the argument
                        is absent.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signatures</label>
                  <def>
                     <example role="signature">
                        <proto name="copy-of" return-type="item()" isOp="no" prefix="fn"
                           returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no"
                           isDatatype="no" isSpecial="no"/>
                     </example>
                     <example role="signature">
                        <proto name="copy-of" return-type="item()*" isOp="no" prefix="fn"
                           returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no"
                           isDatatype="no" isSpecial="no">
                           <arg name="input" type="item()*"/>
                        </proto>
                     </example>
                  </def>
               </gitem>
               <gitem>
                  <label>Properties</label>
                  <def>
                     <p>The zero-argument form of this function is <xtermref spec="FO30"
                           ref="dt-nondeterministic">nondeterministic</xtermref>, <xtermref
                           spec="FO30" ref="dt-focus-dependent">focus-dependent</xtermref>, and
                           <xtermref spec="FO30" ref="dt-context-independent"
                           >context-independent</xtermref>. </p>
                     <p>The one-argument form of this function is <xtermref spec="FO30"
                           ref="dt-nondeterministic">nondeterministic</xtermref>, <xtermref
                           spec="FO30" ref="dt-focus-independent">focus-independent</xtermref>, and
                           <xtermref spec="FO30" ref="dt-context-independent"
                           >context-independent</xtermref>. </p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>The zero-argument form of this function is defined so that
                           <code>copy-of()</code> returns the value of
                           <code>internal:copy-item(.)</code>, where <code>internal:copy-item</code>
                        (which exists only for the purpose of this exposition) is defined below.
                        Informally, <code>copy-of()</code> copies the context item.</p>
                     <p>The single argument form of this function is defined in terms of the
                           <code>internal:copy-item</code> as follows: <code>copy-of($input)</code>
                        is equivalent to <code>$input ! internal:copy-item(.)</code>. Informally,
                           <code>copy-of($input)</code> copies each item in the input sequence in
                        turn.</p>
                     <p>The <code>internal:copy-item</code> function is defined as follows:</p>
                     <eg xml:space="preserve">
&lt;xsl:function name="internal:copy-item" as="item()" 
              new-each-time="maybe"&gt;
  &lt;xsl:param name="input" as="item()"/&gt;
  &lt;xsl:copy-of select="$input" 
               copy-namespaces="yes"
               copy-accumulators="yes"
               validation="preserve"/&gt;
&lt;/xsl:function&gt;</eg>
                     <p>The streamability analysis, however, is different: see <specref
                           ref="classifying-built-in-functions"/>.</p>
                     <p>The use of <code>new-each-time="maybe"</code> in the above definition means
                        that if the <code>internal:copy-item</code> function is called more than
                        once with the same node as argument (whether or not these calls are part of
                        the same call on <code>copy-of</code>), then it is <termref
                           def="dt-implementation-dependent">implementation-dependent</termref>
                        whether each call returns the same node, or whether multiple calls return
                        different nodes. Returning the original node, however, is not allowed,
                        except as an optimization when the processor can determine that this is
                        equivalent.</p>
                     <note>
                        <p>One case where such optimization might be possible is when the copy is
                           immediately atomized.</p>
                     </note>
                  </def>
               </gitem>
               <gitem>
                  <label>Notes</label>
                  <def>
                     <p role="note">The <function>copy-of</function> function is available for use
                        (and is primarily intended for use) when a source document is processed
                        using streaming. It can also be used when not streaming. The effect, <phrase
                           diff="add" at="S-bug29141">when applied to element and document
                           nodes,</phrase> is to take a copy of the subtree rooted at the current
                        node, and to make this available as a normal tree: one that can be processed
                        without any of the restrictions that apply while streaming, for example only
                        being able to process children once. The copy, of course, does not include
                        siblings or ancestors of the context node, so any attempt to navigate to
                        siblings or ancestors will result in an empty sequence being returned.</p>
                     <p role="note">All nodes in the result sequence will be parentless.</p>
                     <p role="note">If atomic values or functions (including maps and arrays) are
                        present in the input sequence, they will be included unchanged at the
                        corresponding position of the result sequence.</p>
                     <p role="note"><phrase diff="add" at="S-bug28130">Accumulator values are taken
                           from the copied document as described in <specref
                              ref="copying-accumulators"/>.</phrase></p>
                  </def>
               </gitem>
               <gitem>
                  <label>Examples</label>
                  <def role="example">
                     <p>Using <code>copy-of()</code> while streaming:</p>
                     <p>This example copies from the source document all employees who work in
                        marketing and are based in Dubai. Because there are two accesses using the
                        child axis, it is not possible to do this without buffering each employee in
                        memory, which can be achieved using the <function>copy-of</function>
                        function.</p>
                     <eg xml:space="preserve">&lt;xsl:source-document streamable="yes" href="employees.xml"&gt;
  &lt;xsl:sequence select="copy-of(employees/employee)
                          [department='Marketing' and location='Dubai']"/&gt;
&lt;/xsl:source-document&gt;</eg>
                  </def>
               </gitem>
            </glist>
         </div2>
         <div2 id="func-snapshot">
            <head>fn:snapshot</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p diff="chg" at="S-bug29141">Returns a copy of a sequence, retaining copies of
                        the ancestors and descendants of any node in the input sequence, together
                        with their attributes and namespaces.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signatures</label>
                  <def>
                     <example role="signature">
                        <proto name="snapshot" return-type="item()" isOp="no" prefix="fn"
                           returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no"
                           isDatatype="no" isSpecial="no"/>
                     </example>
                     <example role="signature">
                        <proto name="snapshot" return-type="item()*" isOp="no" prefix="fn"
                           returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no"
                           isDatatype="no" isSpecial="no">
                           <arg name="input" type="item()*"/>
                        </proto>
                     </example>
                  </def>
               </gitem>
               <gitem>
                  <label>Properties</label>
                  <def>
                     <p>The zero-argument form of this function is <xtermref spec="FO30"
                           ref="dt-nondeterministic">nondeterministic</xtermref>, <xtermref
                           spec="FO30" ref="dt-focus-dependent">focus-dependent</xtermref>, and
                           <xtermref spec="FO30" ref="dt-context-independent"
                           >context-independent</xtermref>. </p>
                     <p>The one-argument form of this function is <xtermref spec="FO30"
                           ref="dt-nondeterministic">nondeterministic</xtermref>, <xtermref
                           spec="FO30" ref="dt-focus-independent">focus-independent</xtermref>, and
                           <xtermref spec="FO30" ref="dt-context-independent"
                           >context-independent</xtermref>. </p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p diff="chg" at="S-bug29141">The zero-argument form of this function is
                        defined so that <code>snapshot()</code> returns the value of
                           <code>internal:snaphot-item(.)</code>, where
                           <code>internal:snapshot-item</code> (which exists only for the purpose of
                        this exposition) is defined below. Informally, <code>snapshot()</code> takes
                        a snapshot of the context item.</p>
                     <p diff="chg" at="S-bug29141">The single argument form of this function is
                        defined in terms of the <code>internal:snapshot-item</code> as follows:
                           <code>snapshot($input)</code> is equivalent to <code>$input !
                           internal:snapshot-item(.)</code>. Informally,
                           <code>snapshot($input)</code> takes a snapshot of each item in the input
                        sequence in turn.</p>
                     <p diff="chg" at="S-bug29141">The <code>internal:snapshot-item</code> function
                        behaves as follows:</p>
                     <ulist>
                        <item>
                           <p diff="add" at="S-bug29141">If the supplied item is an atomic value or
                              a function item (including maps and arrays), then it returns that item
                              unchanged.</p>
                        </item>
                        <item>
                           <p>If the supplied item is a node, then it returns a <termref
                                 def="dt-snapshot"/> of that node, as defined below.</p>
                        </item>
                     </ulist>
                     <p>
                        <termdef id="dt-snapshot" term="snapshot">A <term>snapshot</term> of a node
                              <var>N</var> is a deep copy of <var>N</var>, as produced by the
                              <elcode>xsl:copy-of</elcode> instruction with
                              <code>copy-namespaces</code> set to <code>yes</code>, <phrase
                              diff="add" at="S-bug28130"><code>copy-accumulators</code> set to
                                 <code>yes</code>,</phrase> and <code>validation</code> set to
                              <code>preserve</code>, with the additional property that for every
                           ancestor of <var>N</var>, the copy also has a corresponding ancestor
                           whose name, node-kind, and base URI are the same as the corresponding
                           ancestor of <var>N</var>, and that has copies of the attributes,
                           namespaces <phrase diff="add" at="S-bug28130">and accumulator
                              values</phrase> of the corresponding ancestor of <var>N</var>. But the
                           ancestor has a type annotation of <code>xs:anyType</code>, has the
                           properties <code>nilled</code>, <code>is-id</code>, and
                              <code>is-idref</code> set to false, and has no children other than the
                           child that is a copy of <var>N</var> or one of its ancestors.</termdef>
                     </p>
                     <p>If the function is called more than once with the same argument, it is
                           <termref def="dt-implementation-dependent"
                           >implementation-dependent</termref> whether each call returns the same
                        node, or whether multiple calls return different nodes. That is, the result
                        of the expression <code>snapshot($X) is snapshot($X)</code> is <termref
                           def="dt-implementation-dependent">implementation-dependent</termref>.</p>
                     <p><phrase diff="chg" at="S-bug28130">Except for the effect on
                           accumulators</phrase>, the <code>internal:snapshot-item</code> function
                        can be expressed as follows:</p>
                     <eg xml:space="preserve">
    &lt;xsl:function name="internal:snapshot-item" as="item()"&gt;
        &lt;xsl:param name="input" as="item()"/&gt;
        &lt;xsl:apply-templates select="$input" mode="internal:snapshot"/&gt;
    &lt;/xsl:function&gt;
    
    &lt;!-- for atomic values and function items, return the item unchanged --&gt;
    
    &lt;xsl:template match="." mode="internal:snapshot" priority="1"&gt;
        &lt;xsl:sequence select="."/&gt;
    &lt;/xsl:template&gt;
    
    &lt;!-- for a document node, or any other root node, return a deep copy --&gt;
    
    &lt;xsl:template match="root()" mode="internal:snapshot" priority="5"&gt;
        &lt;xsl:copy-of select="."/&gt;
    &lt;/xsl:template&gt;
    
    &lt;!-- for an element, comment, text node, or processing instruction: --&gt;
    
    &lt;xsl:template match="node()" mode="internal:snapshot" 
                                 as="node()" priority="3"&gt;
        &lt;xsl:sequence select="internal:graft-to-parent(
                                ., .., function($n){$n/node()})"/&gt;
    &lt;/xsl:template&gt;
    
    &lt;!-- for an attribute: --&gt;
    
    &lt;xsl:template match="@*" mode="internal:snapshot" 
                             as="attribute()" priority="3"&gt;
        &lt;xsl:variable name="name" select="node-name(.)"/&gt;
        &lt;xsl:sequence select="internal:graft-to-parent(., .., 
                                function($n){$n/@*[node-name(.) = $name]})"/&gt;
    &lt;/xsl:template&gt;
    
    &lt;!-- for a namespace node: --&gt;
    
    &lt;xsl:template match="namespace-node()" mode="internal:snapshot" 
                  as="namespace-node()" priority="3"&gt;
        &lt;xsl:variable name="name" select="local-name(.)"/&gt;
        &lt;xsl:sequence select="internal:graft-to-parent(., .., 
                  function($n){$n/namespace-node()[local-name(.) = $name]})"/&gt;
    &lt;/xsl:template&gt;
    
    &lt;!-- make a copy C of a supplied node N, grafting it to a shallow copy of 
         C's original parent, and returning the copy C --&gt;
    
    &lt;xsl:function name="internal:graft-to-parent" as="node()"&gt;
        &lt;xsl:param name="n" as="node()"/&gt;
        &lt;xsl:param name="original-parent" as="node()?"/&gt;
        &lt;xsl:param name="down-function" as="function(node()) as node()"/&gt;
        &lt;xsl:choose&gt;
            &lt;xsl:when test="exists($original-parent)"&gt;
                &lt;xsl:variable name="p" as="node()"&gt;
                    &lt;xsl:copy select="$original-parent"&gt;
                        &lt;xsl:copy-of select="@*"/&gt;
                        &lt;xsl:copy-of select="$n"/&gt;
                    &lt;/xsl:copy&gt;
                &lt;/xsl:variable&gt;
                &lt;xsl:variable name="copied-parent" 
                     select="internal:graft-to-parent(
                        $p, $original-parent/.., function($n){$n/node()}))"/&gt;
                &lt;xsl:sequence select="$down-function($copied-parent)"/&gt;              
            &lt;/xsl:when&gt;
            &lt;xsl:otherwise&gt;
                &lt;xsl:sequence select="$n"/&gt;
            &lt;/xsl:otherwise&gt;
        &lt;/xsl:choose&gt;
    &lt;/xsl:function&gt;
    
</eg>
                  </def>
               </gitem>
               <gitem>
                  <label>Notes</label>
                  <def>
                     <p role="note">The <function>snapshot</function> function is available for use
                        (and is primarily intended for use) when a source document is processed
                        using streaming. It can also be used when not streaming. The effect is to
                        take a copy of the subtree rooted at the current node, along with copies of
                        the ancestors and their attributes, and to make this available as a normal
                        tree, that can be processed without any of the restrictions that apply while
                        streaming, for example only being able to process children once. The copy,
                        of course, does not include siblings of the context node or of its
                        ancestors, so any attempt to navigate to these siblings will result in an
                        empty sequence being returned.</p>
                     <p role="note">For parentless nodes, the effect of <code>snapshot($x)</code> is
                        identical to the effect of <code>copy-of($x)</code>.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Examples</label>
                  <def role="example">
                     <p>Using <code>snapshot()</code> while streaming:</p>
                     <p>This example copies from the source document all employees who work in
                        marketing and are based in Dubai. It assumes that employees are grouped by
                        location. Because there are two accesses using the child axis (referencing
                           <code>department</code> and <code>salary</code>), it is not possible to
                        do this without buffering each employee in memory. The
                           <function>snapshot</function> function is used in preference to the
                        simpler <function>copy-of</function> so that access to attributes of the
                        parent <code>location</code> element remains possible.</p>
                     <eg xml:space="preserve">&lt;xsl:source-document streamable="yes" href="employees.xml"&gt;
  &lt;xsl:for-each select="snapshot(locations/location[@name='Dubai']
                          /employee)[department='Marketing']"&gt;
    &lt;employee&gt;
      &lt;location code="{../@code}"/&gt;
      &lt;salary value="{salary}"/&gt;
    &lt;/employee&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:source-document&gt;</eg>
                  </def>
               </gitem>
            </glist>
         </div2>
      </div1>
      <div1 id="streamability" diff="chg" at="P">
         <head>Streamability</head>
         <p diff="chg" at="R-bug24493">This section contains rules that can be used to determine
            properties of <termref def="dt-construct">constructs</termref> in the <termref
               def="dt-stylesheet"/> — specifically, the <termref def="dt-posture"/> and <termref
               def="dt-sweep"/> of a construct — which enable the streamability of the stylesheet to
            be assessed.</p>
         <p diff="chg" at="R-bug24493">These properties are used to determine the streamability
            of:</p>
         <ulist diff="chg" at="R-bug24493">
            <item>
               <p><termref def="dt-template-rule">Template rules</termref>: see <specref
                     ref="streamable-templates"/></p>
            </item>
            <item>
               <p>The <elcode>xsl:source-document</elcode> instruction: see <specref
                     ref="source-document-instruction"/></p>
            </item>
            <item>
               <p><termref def="dt-attribute-set">Attribute sets</termref>: see <specref
                     ref="streamability-of-attribute-sets"/></p>
            </item>
            <item>
               <p><termref def="dt-accumulator">Accumulators</termref>: see <specref
                     ref="streamability-of-accumulators"/></p>
            </item>
            <item>
               <p><termref def="dt-stylesheet-function">Stylesheet functions</termref>: see <specref
                     ref="streamable-stylesheet-functions"/></p>
            </item>
            <item>
               <p>The <elcode>xsl:merge</elcode> instruction: see <specref ref="streamable-merging"
                  /></p>
            </item>
         </ulist>
         <p diff="chg" at="R-bug24493">In each case, the conditions for constructs to be <termref
               def="dt-guaranteed-streamable"/> are defined in terms of these properties. The result
            of this analysis in turn (see <specref ref="streamability-guarantees"/>) imposes rules
            on how the constructs are handled by processors that implement the <termref
               def="dt-streaming-feature"/>. The analysis has no effect on the behavior of
            processors that do not implement this feature.</p>
         <p>The analysis is relevant to constructs such as streamable template rules and the
               <elcode>xsl:source-document</elcode> instruction that process a single streamed input
            document. The <elcode>xsl:merge</elcode> instruction, which processes multiple streamed
            inputs, has its own rules.</p>
         <p>The rules in this section operate on the expression tree (more properly, construct tree)
            that is typically output by the XSLT and XPath parser. For the most part, the rules
            depend only on identifying the syntactic constructs that are present.</p>
         <p>The rules in this section generally consider each <termref def="dt-component"
               >component</termref> in the stylesheet (and in the case of <termref
               def="dt-template-rule">template rules</termref>, each template rule) in isolation.
            The exception is that where a component contains references to other components (such as
            global variables, functions, or named templates), then information from the signature of
            the referenced component is sometimes used. This is invariably information that cannot
            be changed if a component is overridden in a different <termref def="dt-package"
               >package</termref>. The analysis thus requires as a pre-condition that function calls
            and calls on named templates have been resolved to the extent that the corresponding
            function/template signature is known. <phrase diff="del" at="R-bug24510">It also
               requires that variable references referring to grouping variables (those declared in
               a <code>bind-XXX</code> attribute of an <elcode>xsl:for-each-group</elcode>,
                  <elcode>xsl:merge</elcode>, or <elcode>xsl:merge-source</elcode> element) have
               been identified as such.</phrase></p>
         <p>The detailed way in which the construct tree is derived from the lexical form of the
            stylesheet is not described in this specification. There are many ways in which the tree
            can be optimized without affecting the result of the rules in this section: for example,
            a sequence constructor containing a single instruction can be replaced by that
            instruction, and a parenthesized expression can be replaced by its content.</p>
         <p><termdef id="dt-construct" term="construct">The term <term>construct</term> refers to
               the union of the following: a <termref def="dt-sequence-constructor"/>, an <termref
                  def="dt-instruction">instruction</termref>, an <termref def="dt-attribute-set"
                  >attribute set</termref>, a <termref def="dt-value-template">value
                  template</termref>, an <termref def="dt-expression">expression</termref>, or a
                  <termref def="dt-pattern">pattern</termref>.</termdef></p>
         <p>These <termref def="dt-construct">constructs</termref> are classified into
               <term>construct kinds</term>: in particular, <termref def="dt-instruction"
               >instructions</termref> are classified according to the name of the XSLT instruction,
            and <termref def="dt-expression">expressions</termref> are classified according to the
            most specific production in the XPath grammar that the expression satisfies. (This
            means, for example, that <code>2+2</code> is classified as an <code>AdditiveExpr</code>,
            rather than say as a <code>UnionExpr</code>; although it also satisfies the production
            rule for <code>UnionExpr</code>, <code>AdditiveExpr</code> is more specific.)</p>
         <p><termdef id="dt-operand-role" term="operand role">For every construct kind, there is a
               set of zero or more <term>operand roles</term>.</termdef> For example, an
               <code>AdditiveExpr</code> has two operand roles, referred to as the left-hand operand
            and the right-hand operand, while an <code>IfExpr</code> has three, referred to as the
            condition, the then-clause, and the else-clause. A function call with three arguments
            has three operand roles, called the first, second, and third arguments. The names of the
            operand roles for each construct kind are not formally listed, but should be clear from
            the context.</p>
         <p><termdef id="dt-operand" term="operand">In an actual instance of a construct, there will
               be a number of <term>operands</term>. Each operand is itself a <termref
                  def="dt-construct"/>; the construct tree can be defined as the transitive relation
               between constructs and their operands.</termdef> Each operand is associated with
            exactly one of the operand roles for the construct type. There may be operand roles
            where the operand is optional (for example, the <code>separator</code> attribute of the
               <elcode>xsl:value-of</elcode> instruction), and there may be operand roles that can
            be occupied by multiple operands (for example, the <code>xsl:when/@test</code> condition
            in <elcode>xsl:choose</elcode>, or the arguments of the <xfunction>concat</xfunction>
            function).</p>
         <p>Operand roles have a number of properties used in the analysis:</p>
         <ulist>
            <item>
               <p>The <termref def="dt-required-type"/> of the <termref def="dt-operand"/>. This is
                  explicit in the case of function calls (the required type is defined in the
                  function signature of the corresponding function). In other cases it is implicit
                  in the detailed rules for the construct in question. In practice streamability
                  analysis makes only modest use of the required type; the main case where it is
                  relevant is for a function or template call, where knowing that the required type
                  is atomic enables the inference that the <termref def="dt-operand-usage"/> for a
                  supplied node is <termref def="dt-absorption"/>.</p>
            </item>
            <item>
               <p><termdef id="dt-operand-usage" term="operand usage">The <term>operand
                     usage</term>. This gives information, in the case where the operand value
                     contains nodes, about how those nodes are used. The operand usage takes one of
                     the values <termref def="dt-absorption"/>, <termref def="dt-inspection"/>,
                        <termref def="dt-transmission"/>, or <termref def="dt-navigation"
                     />.</termdef> The meanings of these terms are explained in <specref
                     ref="operand-roles"/>. If the required type of the <termref def="dt-operand"/>
                  does not permit nodes to be supplied <phrase diff="add" at="Q">(for example
                     because the required type is a function item or a map)</phrase>, then the
                  operand usage is <termref def="dt-inspection"/>, because the only run-time
                  operation on a supplied node will be to inspect it, discover it is a node, and
                  raise a type error.</p>
               <p>In the particular case where the required type is atomic, and any supplied nodes
                  are atomized, the operand usage will be <termref def="dt-absorption"/>, because
                     <termref def="dt-atomization"/> is a special case of absorption.</p>
            </item>
            <item>
               <p><termdef id="dt-higher-order-operand" term="higher-order operand">Whether or not
                     the <termref def="dt-operand"/> is <term>higher-order</term>. For this purpose
                     an operand <var>O</var> of a construct <var>C</var> is higher-order if the
                     semantics of <var>C</var> potentially require <var>O</var> to be evaluated more
                     than once during a single evaluation of <var>C</var>.</termdef> More
                  specifically, <var>O</var> is a <term>higher-order</term> operand of <var>C</var>
                  if any of the following conditions is true:</p>
               <ulist>
                  <item>
                     <p>The <termref def="dt-context-item"/> for evaluation of <var>O</var> is
                        different from the context item for evaluation of <var>C</var>.</p>
                  </item>
                  <item diff="add" at="Q">
                     <p><var>C</var> is an <termref def="dt-instruction"/> and <var>O</var> is a
                           <termref def="dt-pattern"/> (as with the <code>from</code> and
                           <code>count</code> attributes of <elcode>xsl:number</elcode>, and the
                           <code>group-starting-with</code> and <code>group-ending-with</code>
                        attributes of <elcode>xsl:for-each-group</elcode>).</p>
                  </item>
                  <item>
                     <p><var>C</var> is an XPath <code>for</code>, <code>some</code>, or
                           <code>every</code> expression and <var>O</var> is the expression in its
                           <code>return</code> or <code>satisfies</code> clause.</p>
                  </item>
                  <item>
                     <p><var>C</var> is an inline function declaration and <var>O</var> is the
                        expression in its body.</p>
                  </item>
               </ulist>
            </item>
         </ulist>
         <note diff="add" at="T-bug29482">
            <p>There is one known case where this definition makes an operand higher-order even
               though it is only evaluated once: specifically, the sequence constructor contained in
               the body of an <elcode>xsl:copy</elcode> instruction that has a <code>select</code>
               attribute. See <specref ref="streamability-xsl-copy"/> for further details.</p>
         </note>
         <p><termdef id="dt-choice-operand-group" term="choice operand group">For some construct
               kinds, one or more operand roles may be defined to form a <term>choice operand
                  group</term>. This concept is used where it is known that <termref
                  def="dt-operand">operands</termref> are mutually exclusive (for example the
                  <code>then</code> and <code>else</code> clauses in a conditional
               expression).</termdef></p>
         <p diff="add" at="Q"><termdef id="dt-combined-posture" term="combined posture" open="true"
               >The <term>combined posture</term> of a <termref def="dt-choice-operand-group"/> is
               determined by the <termref def="dt-posture">postures</termref> of the <termref
                  def="dt-operand">operands</termref> in the group <phrase diff="chg"
                  at="R-bug24502">(the <term>operand postures</term>)</phrase>, and is the first of
               the following that applies:</termdef></p>
         <olist>
            <item>
               <p>If any of the <phrase diff="chg" at="R-bug24502">operand</phrase> postures is
                     <termref def="dt-roaming"/>, then the combined posture is <termref
                     def="dt-roaming"/>.</p>
            </item>
            <item>
               <p>If all of the <phrase diff="chg" at="R-bug24502">operand</phrase> postures are
                     <termref def="dt-grounded"/>, then the combined posture is <termref
                     def="dt-grounded"/>.</p>
            </item>
            <item>
               <p>If one or more of the <phrase diff="chg" at="R-bug24502">operand</phrase> postures
                  is <termref def="dt-climbing"/> and the remainder (if any) are <termref
                     def="dt-grounded"/>, then the combined posture is <termref def="dt-climbing"
                  />.</p>
            </item>
            <item>
               <p>If one or more of the <phrase diff="chg" at="R-bug24502">operand</phrase> postures
                  is <termref def="dt-striding"/> and the remainder (if any) are <termref
                     def="dt-grounded"/>, then the combined posture is <termref def="dt-striding"
                  />.</p>
            </item>
            <item>
               <p>If one or more of the <phrase diff="chg" at="R-bug24502">operand</phrase> postures
                  is <termref def="dt-crawling"/> and <phrase diff="chg" at="R-bug24503">each of the
                     remainder (if any) is</phrase> either <termref def="dt-striding"/> or <termref
                     def="dt-grounded"/>, then the combined posture is <termref def="dt-crawling"
                  />.</p>
            </item>
            <item>
               <p>Otherwise (for example, if the group includes both an operand with <termref
                     def="dt-climbing"/> posture and one with <termref def="dt-crawling"/> posture),
                  the combined posture is <termref def="dt-roaming"/>. </p>
            </item>
         </olist>
         <p role="closetermdef"/>
         <p><termdef id="dt-type-determined-usage" term="type-determined usage">The
                  <term>type-determined usage</term> of an <termref def="dt-operand"/> is as
               follows: if the required type (ignoring occurrence indicator) is
                  <code>function(*)</code> or a subtype thereof, then <termref def="dt-inspection"
               />; if the required type (ignoring occurrence indicator) is an <phrase diff="chg"
                  at="S-bug28224">atomic or union type</phrase>, then <termref def="dt-absorption"
               />; otherwise <termref def="dt-navigation"/>.</termdef></p>
         <p diff="add" at="S-bug27571"><termdef id="dt-type-adjusted-posture-and-sweep"
               term="type-adjusted posture and sweep">The <term>type-adjusted posture and
                  sweep</term> of a construct <var>C</var>, with respect to a type <var>T</var>, are
               the <termref def="dt-posture"/> and <termref def="dt-sweep"/> established by applying
               the <termref def="dt-general-streamability-rules"/> to a construct <var>D</var> whose
               single operand is the construct <var>C</var>, where the <termref
                  def="dt-operand-usage"/> of <var>C</var> in <var>D</var> is the <termref
                  def="dt-type-determined-usage"/> based on the required type
               <var>T</var>.</termdef></p>
         <note diff="add" at="S-bug27571">
            <p>In effect, the type-adjusted posture and sweep are the posture and sweep of the
               implicit expression formed to apply the <termref def="dt-function-conversion-rules"/>
               to the argument of a function or template call, or to the result of a function or
               template, given knowledge of the required type. For example, an expression such as
                  <code>discount</code> in the function call <code>abs(discount)</code>, which would
               otherwise be <termref def="dt-striding"/> and <termref def="dt-consuming"/>, becomes
                  <termref def="dt-grounded"/> and <termref def="dt-consuming"/> because of the
               implicit atomization triggered by the function conversion rules.</p>
         </note>
         <p>The process of determining whether a construct is streamable reduces to determining
            properties of the constructs in the construct tree. The properties in question (which
            are described in greater detail in subsequent sections) are:</p>
         <olist>
            <item>
               <p>The <term>static type</term> of the construct. When the construct is evaluated,
                  its value will always be an instance of this type. The value is a <phrase
                     diff="chg" at="R-bug24569"><termref def="dt-utype"/></phrase>; although type
                  inferencing is capable of determining information about the cardinality as well as
                  the item type, the streamability analysis makes no use of this.</p>
            </item>
            <item>
               <p>The <term>context item type</term>: that is, the static type of the <termref
                     def="dt-context-item"/> potentially used as input to the construct. When the
                  construct is evaluated, the context item used to evaluate the construct (if it is
                  used at all) will be an instance of this type.</p>
            </item>
            <item>
               <p><termdef id="dt-posture" term="posture">The <term>posture</term> of the
                     expression. This captures information about the way in which the streamed input
                     document is positioned on return from evaluating the construct. The posture
                     takes one of the values <termref def="dt-climbing"/>, <termref
                        def="dt-striding"/>, <termref def="dt-crawling"/>, <termref def="dt-roaming"
                     />, or <termref def="dt-grounded"/>.</termdef> The meanings of these terms are
                  explained in <specref ref="posture"/>.</p>
            </item>
            <item>
               <p><termdef id="dt-context-posture" term="context posture">The <term>context
                        posture</term>. This captures information about how the <termref
                        def="dt-context-item"/> used as input to the construct is positioned
                     relative to the streamed input. The <term>context posture</term> of a construct
                     C is the posture of the expression whose value sets the focus for the
                     evaluation of C.</termdef>
                  <phrase diff="add" at="Q">Rules for determining the context posture of any
                     construct are given in <specref ref="determining-context-posture"
                  />.</phrase></p>
            </item>
            <item>
               <p>The <term>sweep</term> of the construct. The sweep of a construct gives
                  information about whether and how the evaluation of the construct changes the
                  current position in a streamed input document. The possible values are <termref
                     def="dt-motionless"/>, <termref def="dt-consuming"/>, and <termref
                     def="dt-free-ranging"/><phrase diff="del" at="Q">, and
                     caller-determined</phrase>. These terms are explained in <specref ref="sweep"
                  />.</p>
            </item>
         </olist>
         <p>The values of these properties for a top-level construct such as the body of a template
            rule determine whether the construct is streamable.</p>
         <p>The values of these properties are not independent. For example, if the static type is
            atomic, then the posture will always be grounded; if the sweep is free-ranging, then the
            posture will always be roaming.</p>
         <p diff="add" at="Q">The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of a
               <termref def="dt-construct"/>, as defined above, are calculated in relation to a
            particular streamed input document. If there is more than one streamed input document,
            then a construct that is motionless with respect to one streamed input might be
            consuming with respect to another. In practice, though, the streamability analysis is
            only ever concerned with one particular streamed input at a time; constructs are
            analyzed in relation to the innermost containing <elcode>xsl:template</elcode>,
               <elcode>xsl:source-document</elcode>, <elcode>xsl:accumulator</elcode>, or
               <elcode>xsl:merge-source</elcode> element, and this container implicitly defines the
            streamed input document that is relevant. The streamed input document affecting a
            construct is always the document that contains the context item for evaluation of that
               construct<phrase diff="del" at="R-bug24510">, with one exception: a variable
               reference to a variable bound in the <code>bind-group</code> attribute of
                  <elcode>xsl:for-each-group</elcode> or the <code>bind-source</code> attribute of
               an <elcode>xsl:merge-source</elcode> element. To prevent this causing complications,
               there are rules constraining where such variable references may appear</phrase>.</p>
         <div2 id="determining-static-type" diff="chg" at="R-bug24569">
            <head>Determining the Static Type of a Construct</head>
            <p><termdef id="dt-static-type" term="static type">The <term>static type</term> of a
                     <termref def="dt-construct">construct</termref> is such that all values
                  produced by evaluating the construct will conform to that type. The static type of
                  a construct is a <termref def="dt-utype"/>.</termdef></p>
            <p><termdef id="dt-utype" term="U-type">A <term>U-type</term> is a set of <termref
                     def="dt-fundamental-item-type">fundamental item types</termref>.</termdef></p>
            <p><termdef id="dt-fundamental-item-type" term="fundamental item type">There are 28
                     <term>fundamental item types</term>: the 7 node kinds defined in <bibref
                     ref="xpath-datamodel-30"/> (element, attribute, etc.), the 19 primitive atomic
                  types defined in <bibref ref="xmlschema-2"/>, plus the types
                     <code>function(*)</code> and <code>xs:untypedAtomic</code>. The fundamental
                  item types are disjoint, and every item is an instance of exactly one of
                  them.</termdef></p>
            <p>More specifically, the fundamental item types are:</p>
            <ulist>
               <item>
                  <p><code>document-node()</code>, <code>element()</code>, <code>attribute()</code>,
                        <code>text()</code>, <code>comment()</code>,
                        <code>processing-instruction()</code>, <code>namespace-node()</code>;</p>
               </item>
               <item>
                  <p><code>xs:boolean</code>, <code>xs:double</code>, <code>xs:decimal</code>,
                        <code>xs:float</code>, <code>xs:string</code>, <code>xs:dateTime</code>,
                        <code>xs:date</code>, <code>xs:time</code>, <code>xs:gYear</code>,
                        <code>xs:gYearMonth</code>, <code>xs:gMonth</code>,
                        <code>xs:gMonthDay</code>, <code>xs:gDay</code>, <code>xs:anyURI</code>,
                        <code>xs:QName</code>, <code>xs:NOTATION</code>,
                        <code>xs:base64Binary</code>, <code>xs:hexBinary</code>,
                        <code>xs:duration</code></p>
               </item>
               <item>
                  <p><code>function(*)</code></p>
               </item>
               <item>
                  <p><code>xs:untypedAtomic</code></p>
               </item>
            </ulist>
            <p>A value <var>V</var> (in general, a sequence) is an instance of a <termref
                  def="dt-utype"/>
               <var>U</var> if every item in <var>V</var> is an instance of one of the <termref
                  def="dt-fundamental-item-type">fundamental item types</termref> in <var>U</var>.
               For example, the sequence <code>(23, "Paris")</code> is an instance of the U-type
                  <code>U{xs:string, xs:decimal, xs:date}</code> because both items in the sequence
               belong to item types in this U-type. </p>
            <note>
               <p>It is a consequence of this rule that the empty sequence, <code>()</code>, is an
                  instance of every U-type.</p>
            </note>
            <p>A <termref def="dt-utype"/> is represented in this specification using the notation
                  <var>U{t1, t2, t3, ...}</var> where <code>t1, t2, t3, ...</code> are the names of
               the fundamental item types making up the U-type. The item types are represented using
               the syntax of the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                  ref="prod-xpath30-ItemType" xlink:type="simple">ItemType</xnt> production in
               XPath, for example <code>comment()</code> or <code>xs:date</code>.</p>
            <note>
               <p>This means that the order of <code>t1, t2, t3, ...</code> has no significance:
                     <var>U{A, B}</var> is the same U-type as <var>U{B, A}</var>.</p>
            </note>
            <p>The smallest U-type is denoted <var>U{}</var>. This is not an empty type; like every
               other U-type, it has the empty sequence <code>()</code> as an instance. For
               convenience, the universal U-type is represented as <var>U{*}</var>; the U-type
               corresponding to the set of 7 node kinds is written <var>U{N}</var>, and the U-type
               corresponding to all atomic values (that is, the 19 primitive atomic types plus
                  <code>xs:untypedAtomic</code>) is written <var>U{A}</var>.</p>
            <p>Because a <termref def="dt-utype"/> is a set, the operations of union, intersection,
               and difference are defined over U-types, and the result is always a U-type. If one
               U-type <var>U</var> is a subset of another U-type <var>V</var>, then <var>U</var> is
               said to be a subtype of <var>V</var>, and <var>V</var> is said to be a supertype of
                  <var>U</var>.</p>
            <p>In some cases the inference of a <termref def="dt-static-type"/> depends on the
               declared types of variables or functions. Since declared types use the <phrase
                  diff="chg" at="S-bug29079"><termref def="dt-sequence-type"/></phrase> syntax,
               there is therefore a mapping defined from SequenceTypes to U-types. The mapping is as
               follows:</p>
            <ulist>
               <item>
                  <p>The <phrase diff="chg" at="S-bug29079"><termref def="dt-sequence-type"
                        /></phrase>
                     <code>empty-sequence()</code> maps to <var>U{}</var></p>
               </item>
               <item>
                  <p>For every other <phrase diff="chg" at="S-bug29079"><termref
                           def="dt-sequence-type"/></phrase>, the mapping depends only on the item
                     type and ignores the occurrence indicator. The mapping from item types is as
                     follows:</p>
                  <ulist>
                     <item>
                        <p><code>item()</code> maps to <var>U{*}</var></p>
                     </item>
                     <item>
                        <p><code>AnyKindTest</code> (<code>node()</code>) maps to
                           <var>U{N}</var></p>
                     </item>
                     <item>
                        <p><code>DocumentTest</code> maps to <var>U{document-node()}</var></p>
                     </item>
                     <item>
                        <p><code>ElementTest</code> and <code>SchemaElementTest</code> map to
                              <var>U{element()}</var></p>
                     </item>
                     <item>
                        <p><code>AttributeTest</code> and <code>SchemaAttributeTest</code> map to
                              <var>U{attribute()}</var></p>
                     </item>
                     <item>
                        <p><code>TextTest</code> maps to <var>U{text()}</var></p>
                     </item>
                     <item>
                        <p><code>CommentTest</code> maps to <var>U{comment()}</var></p>
                     </item>
                     <item>
                        <p><code>PITest</code> maps to <var>U{processing-instruction()}</var></p>
                     </item>
                     <item>
                        <p><code>NamespaceNodeTest</code> maps to <var>U{namespace-node()}</var></p>
                     </item>
                     <item>
                        <p><code>FunctionTest</code>, <code>MapTest</code>, <phrase diff="chg"
                              at="S-bug29079">and (if the <termref def="dt-xpath31-feature"/> is
                              implemented) <code>ArrayTest</code></phrase> map to
                              <var>U{function(*)}</var></p>
                     </item>
                     <item>
                        <p>The QName <code>xs:error</code> maps to <var>U{}</var></p>
                     </item>
                     <item>
                        <p>A QName <var>Q</var> representing an atomic type that is a fundamental
                           item type maps to <var>U{Q}</var></p>
                     </item>
                     <item>
                        <p>A QName <var>Q</var> representing an atomic type derived from a
                           fundamental item type <var>F</var> maps to <var>U{F}</var></p>
                     </item>
                     <item>
                        <p>A QName <var>Q</var> representing a pure union type maps to a U-type
                           containing the fundamental item types present in the transitive
                           membership of the union, or from which the transitive members of the
                           union are derived.</p>
                     </item>
                  </ulist>
               </item>
            </ulist>
            <p>Although all constructs have a <termref def="dt-static-type"/>, the streamability
               analysis only needs to know the static type of XPath expressions, so the rules here
               are largely confined to that case. <phrase diff="add" at="S-bug27250">For <termref
                     def="dt-pattern">patterns</termref>, the <termref def="dt-static-type"/> is
                  deemed to be <var>U{xs:boolean}</var>, reflecting the fact that a pattern is
                  essentially a function that can be applied to items to deliver a true or false
                  (matching or non-matching) result.</phrase>
               <phrase diff="add" at="Q">For constructs other than <termref def="dt-expression"
                     >expressions</termref>
                  <phrase diff="add" at="S-bug27250">and <termref def="dt-pattern"
                        >patterns</termref></phrase>, the <termref def="dt-static-type"/> for the
                  purpose of streamability analysis is taken as <var>U{*}</var></phrase>.</p>
            <p>The rules given here are deliberately simple. Implementations may well be able to
               compute a more precise <termref def="dt-static-type"/>, but this will rarely be
               useful for streamability analysis. The item type for each kind of XPath expression is
               determined by the rules below. In the first column, numbers in square brackets are
               production numbers from the XPath 3.0 <phrase diff="add" at="T-bug29340">and XPath
                  3.1 specifications respectively</phrase>. <phrase diff="add" at="Q">In the second
                  column, the <term>Proforma</term> uses an informal notation used both to provide a
                  reminder of the syntax of the construct in question, and to attach labels to its
                  operand roles so that they can be referred to in the text of the third
                  column.</phrase></p>
            <table class="data">
               <caption>Inferring a Static Type for XPath 3.0 Expressions</caption>
               <thead>
                  <tr>
                     <th rowspan="1" colspan="1">Construct</th>
                     <th rowspan="1" colspan="1">Proforma</th>
                     <th rowspan="1" colspan="1">Static Type</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td rowspan="1" colspan="1">Expr [6,6] </td>
                     <td rowspan="1" colspan="1"><code>E,F</code></td>
                     <td rowspan="1" colspan="1">the union of the static types of E and F</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">ForExpr [8,8] </td>
                     <td rowspan="1" colspan="1"><code>for $x in S return E</code></td>
                     <td rowspan="1" colspan="1">the static type of E</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">LetExpr [11,11] </td>
                     <td rowspan="1" colspan="1"><code>let $x := S return E</code></td>
                     <td rowspan="1" colspan="1">the static type of E</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">QuantifiedExpr [14,14]</td>
                     <td rowspan="1" colspan="1"><code>some|every $x in S satisfies C</code></td>
                     <td rowspan="1" colspan="1"><var>U{xs:boolean}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">IfExpr [15,15] </td>
                     <td rowspan="1" colspan="1"><code>if (C) then T else E</code></td>
                     <td rowspan="1" colspan="1">the union of the static types of T and E</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">OrExpr [16,16]</td>
                     <td rowspan="1" colspan="1"><code>E or F</code></td>
                     <td rowspan="1" colspan="1"><var>U{xs:boolean}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">AndExpr [17,17]</td>
                     <td rowspan="1" colspan="1"><code>E and F</code></td>
                     <td rowspan="1" colspan="1"><var>U{xs:boolean}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">ComparisonExpr [18,18]</td>
                     <td rowspan="1" colspan="1"><code>E = F, E eq F, E is F</code></td>
                     <td rowspan="1" colspan="1"><var>U{xs:boolean}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">StringConcatExpr [19,19]</td>
                     <td rowspan="1" colspan="1"><code>E || F</code></td>
                     <td rowspan="1" colspan="1"><var>U{xs:string}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">RangeExpr [20,20]</td>
                     <td rowspan="1" colspan="1"><code>E to F</code></td>
                     <td rowspan="1" colspan="1"><var>U{xs:decimal}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">AdditiveExpr [21,21]</td>
                     <td rowspan="1" colspan="1"><code>E + F</code></td>
                     <td rowspan="1" colspan="1"><var>U{A}</var>. <phrase diff="add" at="R-bug25316"
                           >But if the expression is a predicate (that is, if it appears between
                           square brackets in a filter expression or axis step), then
                              <var>U{xs:decimal, xs:double, xs:float}</var></phrase></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">MultiplicativeExpr [22,22]</td>
                     <td rowspan="1" colspan="1"><code>E * F</code></td>
                     <td rowspan="1" colspan="1"><var>U{A}</var>. <phrase diff="add" at="R-bug25316"
                           >But if the expression is a predicate (that is, if it appears between
                           square brackets in a filter expression or axis step), then
                              <var>U{xs:decimal, xs:double, xs:float}</var></phrase></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">UnionExpr [23,23] </td>
                     <td rowspan="1" colspan="1"><code>E | F</code></td>
                     <td rowspan="1" colspan="1">the union of the static types of E and F</td>
                  </tr>
                  <tr>
                     <td rowspan="2" colspan="1">IntersectExceptExpr [24,24] </td>
                     <td rowspan="1" colspan="1"><code>E intersect F</code></td>
                     <td rowspan="1" colspan="1">the intersection of the static types of E and
                        F</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1"><code>E except F</code></td>
                     <td rowspan="1" colspan="1">the static type of E</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">InstanceOfExpr [25,25]</td>
                     <td rowspan="1" colspan="1"><code>E instance of T</code></td>
                     <td rowspan="1" colspan="1"><var>U{xs:boolean}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">TreatExpr [26,26]</td>
                     <td rowspan="1" colspan="1"><code>E treat as T</code></td>
                     <td rowspan="1" colspan="1">the U-type corresponding to the SequenceType T</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">CastableExpr [27,27]</td>
                     <td rowspan="1" colspan="1"><code>E castable as T</code></td>
                     <td rowspan="1" colspan="1"><var>U{xs:boolean}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">CastExpr [28,28] </td>
                     <td rowspan="1" colspan="1"><code>E cast as T</code></td>
                     <td rowspan="1" colspan="1">if T is an atomic or pure union type, the
                        corresponding U-type. Otherwise, for example if T is a list type,
                           <var>U{A}</var>.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">UnaryExpr [29,30]</td>
                     <td rowspan="1" colspan="1"><code>-N</code></td>
                     <td rowspan="1" colspan="1"><var>U{xs:decimal, xs:double, xs:float}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">SimpleMapExpr [34,35] </td>
                     <td rowspan="1" colspan="1"><code>E ! F</code></td>
                     <td rowspan="1" colspan="1">the static type of F</td>
                  </tr>
                  <tr>
                     <td rowspan="3" colspan="1">PathExpr [35,36] </td>
                     <td rowspan="1" colspan="1"><code>/</code></td>
                     <td rowspan="1" colspan="1"><var>U{document-node()}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1"><code>/P</code></td>
                     <td rowspan="1" colspan="1">the static type of P</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1"><code>//P</code></td>
                     <td rowspan="1" colspan="1">the static type of P</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">RelativePathExpr [36,37] </td>
                     <td rowspan="1" colspan="1"><code>P/Q, P//Q</code></td>
                     <td rowspan="1" colspan="1">the static type of <phrase diff="chg"
                           at="S-bug28106">Q</phrase></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">AxisStep [38,39] </td>
                     <td rowspan="1" colspan="1"><code>E[P]</code></td>
                     <td rowspan="1" colspan="1">the static type of E: see <specref
                           ref="static-type-of-steps"/></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">ForwardStep [39,40], ReverseStep [42,43]</td>
                     <td rowspan="1" colspan="1"><code>Axis::NodeTest</code></td>
                     <td rowspan="1" colspan="1">See <specref ref="static-type-of-steps"/></td>
                  </tr>
                  <tr>
                     <td rowspan="2" colspan="1">PostfixExpr [48,49]</td>
                     <td rowspan="1" colspan="1">Filter Expression <code>E[P]</code></td>
                     <td rowspan="1" colspan="1">the static type of E</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Dynamic Function Call <code>F(X, Y)</code></td>
                     <td rowspan="1" colspan="1"><var>U{*}</var>, unless ancillary information is
                        available about the function signature of F: see below.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Literal [53,57]</td>
                     <td rowspan="1" colspan="1"><code>"pH"</code>, <code>93.7</code></td>
                     <td rowspan="1" colspan="1"><var>U{xs:string}</var>, <var>U{xs:decimal}</var>,
                        or <var>U{xs:double}</var>, depending on the form of the literal</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">VarRef [55,59]</td>
                     <td rowspan="1" colspan="1"><code>$V</code></td>
                     <td rowspan="1" colspan="1">For a variable declared using
                           <elcode>xsl:variable</elcode> or <elcode>xsl:param</elcode>, and for
                        parameters of inline function expressions: the declared type of the
                        variable, defaulting to <var>U{*}</var>. For variables declared using
                           <code>for</code>, <code>let</code>, <code>some</code>, and
                           <code>every</code> expressions: the static type of the expression to
                        which the variable is bound.</td>
                  </tr>
                  <tr>
                     <td rowspan="2" colspan="1">ParenthesizedExpr [57,61]</td>
                     <td rowspan="1" colspan="1"><code>(E)</code></td>
                     <td rowspan="1" colspan="1">the type of E</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1"><code>()</code></td>
                     <td rowspan="1" colspan="1"><var>U{}</var> (a type whose only instance is the
                        empty sequence)</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">ContextItemExpr [58,62]</td>
                     <td rowspan="1" colspan="1"><code>.</code></td>
                     <td rowspan="1" colspan="1">the context item type: see below</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">FunctionCall [59,63]</td>
                     <td rowspan="1" colspan="1"><code>F(X, Y)</code></td>
                     <td rowspan="1" colspan="1"><phrase diff="chg" at="R-bug24173">In general: the
                           U-type corresponding to the declared result type of function
                           <var>F</var>. But:</phrase>
                        <ulist>
                           <item diff="chg" at="R-bug24173">
                              <p>If one or more of the arguments to the function have operand usage
                                    <termref def="dt-transmission"/>, then the intersection of the
                                 U-type corresponding to the declared result type with the union of
                                 the static types of the arguments having usage transmission. (For
                                 example, the static type of the function call
                                    <code>head(//text())</code> is <var>U{text()}</var>.)</p>
                           </item>
                           <item diff="add" at="T-bug30033">
                              <p>Special rules apply to the <function>current</function> function:
                                 see <specref ref="static-type-of-current-function"/>.</p>
                           </item>
                        </ulist></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">NamedFunctionRef [63,67]</td>
                     <td rowspan="1" colspan="1"><code>F#n</code></td>
                     <td rowspan="1" colspan="1"><var>U{function(*)}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">InlineFunctionExpr [64,68] </td>
                     <td rowspan="1" colspan="1"><code>function(P) {E}</code></td>
                     <td rowspan="1" colspan="1"><var>U{function(*)}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">MapConstructor <phrase diff="add" at="T-bug29340"
                           >[–,69]</phrase></td>
                     <td rowspan="1" colspan="1"><code>map{"A":E, "B":F}</code></td>
                     <td rowspan="1" colspan="1"><var>U{function(*)}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Postfix Lookup <phrase diff="add" at="T-bug29340"
                           >[–,49]</phrase></td>
                     <td rowspan="1" colspan="1"><code>E ? K</code></td>
                     <td rowspan="1" colspan="1">If the type of <var>E</var> is a map type
                           <code>map(K, V)</code> or an array type <code>array(V)</code>, then the
                        U-type corresponding to the item type of <var>V</var>; otherwise
                           <var>U{*}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">(Unary) Lookup <phrase diff="add" at="T-bug29340"
                           >[–,53]</phrase></td>
                     <td rowspan="1" colspan="1"><code>? K</code></td>
                     <td rowspan="1" colspan="1">If the context item type is a map type <code>map(K,
                           V)</code> or an array type <code>array(V)</code>, then the U-type
                        corresponding to the item type of <var>V</var>; otherwise
                        <var>U{*}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">ArrowExpr <phrase diff="add" at="T-bug29340"
                           >[–,29]</phrase></td>
                     <td rowspan="1" colspan="1"><code>X =&gt; F(Y, Z)</code></td>
                     <td rowspan="1" colspan="1">The static type of the equivalent <phrase
                           diff="chg" at="T-bug29459">static or dynamic function call</phrase>
                        <code>F(X, Y, Z)</code></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">SquareArrayConstructor <phrase diff="add"
                           at="T-bug29340">[–,74]</phrase></td>
                     <td rowspan="1" colspan="1"><code>[X, Y, ...]</code></td>
                     <td rowspan="1" colspan="1"><var>U{function(*)}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">CurlyArrayConstructor <phrase diff="add"
                           at="T-bug29340">[–,75]</phrase></td>
                     <td rowspan="1" colspan="1"><code>array{X, Y, ...}</code></td>
                     <td rowspan="1" colspan="1"><var>U{function(*)}</var></td>
                  </tr>
               </tbody>
            </table>
            <p>Where the <termref def="dt-static-type"/> of an expression is
                  <var>U{function(*)}</var>, it is useful to retain additional information:
               specifically, the signature of the function. This may be regarded as information
               ancillary to the U-type of the expression; it does not play any role in operations
               such as testing whether one U-type is a subtype of another, or forming the union of
               two U-types. This ancillary information is available for a
                  <code>NamedFunctionRef</code>, for an <code>InlineFunctionExpr</code>, for a
                  <code>MapConstructor</code>, for a <code>FunctionCall</code> whose static type is
                  <var>U{function(*)}</var>, and for a <code>VarRef</code> if the variable is bound
               to any of the forgoing, or if it has a declared type corresponding to
                  <var>U{function(*)}</var>.</p>
            <note diff="add" at="R-bug25316">
               <p>The special case type inference used for an <code>AdditiveExpr</code> or
                     <code>MultiplicativeExpr</code> appearing as a predicate is possible because if
                  an arithmetic operation within a predicate produces any other result, for example
                  an <code>xs:duration</code> or <code>xs:dateTime</code>, this would cause a type
                  error (on the grounds that an <code>xs:duration</code> or <code>xs:dateTime</code>
                  has no effective boolean value), and static type inference only needs to consider
                  the type of non-error results. The benefit of this special rule is that filter
                  expressions such as <code>/descendant::section[$i + 1]</code> can be recognized as
                  returning a singleton, and therefore as being <termref def="dt-striding"/>, even
                  if the type of <code>$i</code> is unknown.</p>
            </note>
            <div3 id="static-type-of-steps" diff="add" at="T-bug30032">
               <head>Static Type of an Axis Step</head>
               <p>An <code>AxisStep</code> consists of either a <code>ForwardStep</code> or
                     <code>ReverseStep</code> followed by zero or more predicates. The predicates
                  have no effect on the inferred type of the <code>AxisStep</code>.</p>
               <p>The static type of an abbreviated step is the static type of its expansion, for
                  example the static type of <code>@*</code> is the same as the static type of
                     <code>attribute::*</code>.</p>
               <p>Both the constructs <code>ForwardStep</code> or <code>ReverseStep</code>, in their
                  unabbreviated form, are written as <code>Axis::NodeTest</code>. The static type
                  depends on both the <code>Axis</code> and the <code>NodeTest</code>, and also on
                  the <termref def="dt-context-item-type"/>, determined as described in <specref
                     ref="determining-context-item-type"/>.</p>
               <p>If the <termref def="dt-context-item-type"/> has an empty intersection with
                     <code>U{N}</code> (that is, if the context item type cannot be a node), then
                  evaluation of the <code>AxisStep</code> will always fail; it is permissible to
                  raise a type error statically in this case, but for the sake of the analysis, the
                  static type of the <code>AxisStep</code> can be taken as <code>U{}</code>. In
                  other cases, let <var>CIT</var> be the intersection of the <termref
                     def="dt-context-item-type"/> with <code>U{N}</code>.</p>
               <p>Let <var>K(A, CIT)</var> be the set of <term>reachable node kinds</term> given an
                  axis <var>A</var> (a <termref def="dt-utype"/>) as defined by the following table: </p>
               <table>
                  <thead>
                     <tr>
                        <th rowspan="1" colspan="1">Axis</th>
                        <th rowspan="1" colspan="1">Reachable Node Kinds</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td rowspan="1" colspan="1">self</td>
                        <td rowspan="1" colspan="1"><var>CIT</var></td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">attribute</td>
                        <td rowspan="1" colspan="1">if <var>CIT</var> includes
                              <code>U{element()}</code> then <code>U{attribute()}</code> else
                              <code>U{}</code></td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">namespace</td>
                        <td rowspan="1" colspan="1">if <var>CIT</var> includes
                              <code>U{element()}</code> then <code>U{namespace-node()}</code> else
                              <code>U{}</code></td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">child, descendant</td>
                        <td rowspan="1" colspan="1">if <var>CIT</var> includes
                              <code>U{element()}</code> or <code>U{document-node()}</code> then
                              <code>U{element(), text(), comment(), processing-instruction()}</code>
                           else <code>U{}</code></td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">following-sibling, preceding-sibling, following,
                           preceding</td>
                        <td rowspan="1" colspan="1">if <var>CIT</var> is
                              <code>U{document-node()}</code> then <code>U{}</code> else
                              <code>U{element(), text(), comment(),
                           processing-instruction()}</code></td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">parent, ancestor</td>
                        <td rowspan="1" colspan="1">if <var>CIT</var> is
                              <code>U{document-node()}</code> then <code>U{}</code> else
                              <code>U{element(), document-node()}</code>
                        </td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">ancestor-or-self</td>
                        <td rowspan="1" colspan="1">the union of <var>K(ancestor, CIT)</var> and
                              <var>CIT</var></td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">descendant-or-self</td>
                        <td rowspan="1" colspan="1">the union of <var>K(descendant, CIT)</var> and
                              <var>CIT</var></td>
                     </tr>
                  </tbody>
               </table>
               <p>Let <code>T(NT)</code> be the set of node kinds that are capable of satisfying a
                     <code>NodeTest</code>
                  <var>NT</var>, defined by the following table:</p>
               <table>
                  <thead>
                     <tr>
                        <th rowspan="1" colspan="1">NodeTest</th>
                        <th rowspan="1" colspan="1">Possible Node Kinds</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td rowspan="1" colspan="1"><code>AnyKindTest</code> (that is,
                              <code>node()</code>)</td>
                        <td rowspan="1" colspan="1"><var>U{N}</var> (that is, any node)</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">Any other <code>KindTest</code></td>
                        <td rowspan="1" colspan="1">The corresponding <termref def="dt-utype"/> (for
                           example, <code>U{text()}</code> for the <code>KindTest</code>
                           <code>text()</code>)</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">NameTest</td>
                        <td rowspan="1" colspan="1">The <termref def="dt-utype"/> corresponding to
                           the principal node kind of the specified axis</td>
                     </tr>
                  </tbody>
               </table>
               <p>The static type of an <code>AxisStep</code> with axis <var>A</var> and node test
                     <code>NT</code>, given a context item type <var>CIT</var>, is then defined to
                  be the intersection of <code>K(A, CIT)</code> with <code>T(NT)</code>.</p>
            </div3>
            <div3 id="static-type-of-current-function" diff="add" at="T-bug30033">
               <head>Static Type of a Call to <code>current</code></head>
               <p>The rules in this section define the static type of a call to the
                     <function>current</function> function.</p>
               <olist>
                  <item>
                     <p>If the call is within a <termref def="dt-pattern"/>, the static type of the
                        function call is the <termref def="dt-match-type"/> of the pattern.</p>
                     <note>
                        <p>There is no circularity in this definition: a call to
                              <function>current</function> in a pattern can only appear within a
                           predicate, and the match type of a pattern never depends on anything
                           appearing in a predicate.</p>
                     </note>
                  </item>
                  <item>
                     <p>Otherwise (the function call is within an XPath expression), the static type
                        of the function call is the <termref def="dt-context-item-type"/> that
                        applies to the outermost containing XPath expression, determined by the
                        rules in <specref ref="determining-context-item-type"/>. </p>
                  </item>
               </olist>
            </div3>
            <div3 id="notes-on-schema-aware-analysis">
               <head>Schema-Aware Streamability Analysis</head>
               <note>
                  <p>The streamability analysis in this chapter is not schema-aware. There are cases
                     where use of schema type information might enable a processor to determine that
                     a construct is streamable when it would be unable to make this determination
                     otherwise. Two examples:</p>
                  <ulist>
                     <item>
                        <p>A processor might decide that a construct such as <code>price +
                              salesTax</code> is streamable if both the child elements have a simple
                           type such as <code>xs:decimal</code>, or if the order in which they
                           appear in the input document is known.</p>
                     </item>
                     <item>
                        <p>A processor might decide that a step using the descendant axis, such as
                              <code>.//title</code>, has <termref def="dt-striding"/> rather than
                              <termref def="dt-crawling"/>
                           <termref def="dt-posture"/> if it can establish that two
                              <code>title</code> elements will never <phrase diff="chg"
                              at="R-bug24290">be nested</phrase> (that is, a <code>title</code>
                           cannot contain another <code>title</code>). This would allow the
                           instruction <code>&lt;xsl:apply-templates select=".//title"/&gt;</code>
                           to be used in a streaming template rule.</p>
                     </item>
                  </ulist>
                  <p>Although such constructs are not guaranteed streamable according to this
                     specification, there is nothing to prevent a processor providing a streamed
                     implementation if it is able to do so.</p>
               </note>
            </div3>
         </div2>
         <div2 id="determining-context-item-type" diff="chg" at="Q">
            <head>Determining the Context Item Type</head>
            <p><termdef id="dt-context-item-type" term="context item type">For every expression, it
                  is possible to establish by static analysis, information about the item type of
                  the context item for evaluation of that expression. This is called the
                     <term>context item type</term> of the expression.</termdef></p>
            <p diff="add" at="R-bug24569">The <termref def="dt-context-item-type"/> of an expression
               is a <termref def="dt-utype"/>.</p>
            <p>The semantics of every <termref def="dt-construct">construct</termref>, defined in
               this specification or in the XPath specification, describe how the <termref
                  def="dt-focus"/> for evaluating each <termref def="dt-operand"/> of the construct
               is determined. In most cases the focus is the same as that of the parent construct.
               In some cases the focus is determined by evaluating some other expression, for
               example in the expressions <code>A/B</code>, <code>A!B</code>, or <code>A[B]</code>,
               the focus for evaluating <var>B</var> is <var>A</var>. More generally:</p>
            <ulist>
               <item>
                  <p><termdef id="dt-focus-changing-construct" term="focus-changing construct">A
                           <term>focus-changing construct</term> is a <termref def="dt-construct"/>
                        that has one or more <termref def="dt-operand">operands</termref> that are
                        evaluated with a different <termref def="dt-focus"/> from the parent
                        construct.</termdef></p>
                  <note>
                     <p>Examples of focus-changing constructs include the instructions
                           <elcode>xsl:for-each</elcode>, <elcode>xsl:iterate</elcode>, and
                           <elcode>xsl:for-each-group</elcode>; path expressions, filter
                        expressions, and simple mapping expressions; and all patterns.</p>
                  </note>
               </item>
               <item>
                  <p><termdef id="dt-controlling-operand" term="controlling operand">Within a
                           <termref def="dt-focus-changing-construct"/> there is in many cases one
                           <termref def="dt-operand">operand</termref> whose value determines the
                           <termref def="dt-focus"/> for evaluating other operands; this is referred
                        to as the <term>controlling operand</term>.</termdef></p>
                  <note>
                     <p>For example, the controlling operand of an <elcode>xsl:for-each</elcode>,
                           <elcode>xsl:iterate</elcode>, or <elcode>xsl:for-each-group</elcode>
                        instruction is the expression in its <code>select</code> attribute; the
                        controlling operand of a filter expression <code>E[P]</code> is
                           <code>E</code>, and the controlling operand of a simple mapping
                        expression <code>A!B</code> is <code>A</code>.</p>
                  </note>
               </item>
               <item>
                  <p><termdef id="dt-controlled-operand" term="controlled operand">Within a <termref
                           def="dt-focus-changing-construct"/> there are one or more <termref
                           def="dt-operand">operands</termref> that are evaluated with a <termref
                           def="dt-focus"/> determined by the <termref def="dt-controlling-operand"/>
                        <phrase diff="add" at="Q">(or in some cases such as
                              <elcode>xsl:on-completion</elcode>, with an <termref def="dt-absent"/>
                           <termref def="dt-focus"/>)</phrase>; these are referred to as
                           <term>controlled operands</term>.</termdef></p>
                  <note>
                     <p>For example, the main controlled operand of an
                        <elcode>xsl:for-each</elcode>, <elcode>xsl:iterate</elcode>, or
                           <elcode>xsl:for-each-group</elcode> instruction is the contained sequence
                        constructor; the controlled operand of a filter expression <code>E[P]</code>
                        is <code>P</code>, and the controlled operand of a simple mapping expression
                           <code>A!B</code> is <code>B</code>.</p>
                  </note>
               </item>
               <item>
                  <p><termdef id="dt-focus-setting-container" term="focus-setting container">The
                           <term>focus-setting container</term> of a construct <var>C</var> is the
                        innermost <termref def="dt-focus-changing-construct"/>
                        <var>F</var> (if one exists) such that <var>C</var> is directly or
                        indirectly contained in a <termref def="dt-controlled-operand"/> of
                           <var>F</var>. <phrase diff="add" at="Q">If there is no such construct
                              <var>F</var>, then the focus-setting container is the containing
                              <termref def="dt-declaration"/>, for example an
                              <elcode>xsl:function</elcode> or <elcode>xsl:template</elcode>
                           element.</phrase></termdef></p>
                  <note>
                     <p>For example, if an instruction appears as a child of
                           <elcode>xsl:for-each</elcode>, then its focus-setting container is the
                           <elcode>xsl:for-each</elcode> instruction; if an expression appears
                        within the predicate of a filter expression, its focus-setting container is
                        the filter expression.</p>
                  </note>
               </item>
            </ulist>
            <p>The <termref def="dt-context-item-type"/> of a construct <var>C</var> is the first of
               the following that applies:</p>
            <olist>
               <item>
                  <p>If the <termref def="dt-focus-setting-container"/> of <var>C</var> is an
                        <elcode>xsl:function</elcode> element, an inline function declaration, or an
                        <elcode>xsl:on-completion</elcode> element, then the context item type is
                        <code diff="chg" at="R-bug24569">U{}</code>.</p>
                  <note>
                     <p>This is essentially an error case; expressions that depend on the focus
                        should not normally appear within a construct that sets the focus to
                           <termref def="dt-absent"/>.</p>
                  </note>
               </item>
               <item>
                  <p>If the <termref def="dt-focus-setting-container"/> of <var>C</var> is an
                        <elcode>xsl:source-document</elcode> instruction, then the context item type
                     is <code diff="chg" at="R-bug24569">U{document-node()}</code>.</p>
               </item>
               <item>
                  <p>If the <termref def="dt-focus-setting-container"/> of <var>C</var> is a
                        <termref def="dt-template-rule"/>, then the context item type is the
                        <termref def="dt-match-type"/> of the match pattern of the template rule,
                     defined below.</p>
               </item>
               <item>
                  <p>If the <termref def="dt-focus-setting-container"/> of <var>C</var> is a
                        <code>PredicatePattern</code>, then the context item type is <code
                        diff="chg" at="R-bug24569">U{*}</code>.</p>
               </item>
               <item diff="add" at="T-bug29675">
                  <p>If the <termref def="dt-focus-setting-container"/> is a <termref
                        def="dt-global-variable"/> declaration, the context item type is determined
                     by the <code>type</code> attribute of the
                        <elcode>xsl:global-context-item</elcode> declaration, defaulting to
                        <code>U{*}</code>, or <code>U{}</code> if the
                        <elcode>xsl:global-context-item</elcode> declaration specifies
                        <code>use="absent"</code>.</p>
               </item>
               <item>
                  <p>If the <termref def="dt-focus-setting-container"/> is any other <termref
                        def="dt-declaration"/>, for example <phrase diff="chg" at="T-bug29675"
                           ><elcode>xsl:key</elcode> or <elcode>xsl:accumulator</elcode></phrase>,
                     the context item type is <code diff="chg" at="R-bug24569">U{*}</code>.</p>
               </item>
               <item>
                  <p>Otherwise, the context item type is the <termref def="dt-static-type"/> (see
                        <specref ref="determining-static-type"/>) of the <termref
                        def="dt-controlling-operand"/> of the <termref
                        def="dt-focus-setting-container"/> of <var>C</var>.</p>
               </item>
            </olist>
            <p diff="chg" at="R-bug24569"><termdef id="dt-match-type" term="match type">The
                     <term>match type</term> of a <termref def="dt-pattern"/> is the most specific
                     <termref def="dt-utype"/> that is known to match all items that the pattern can
                  match.</termdef> The match type of a pattern is the inferred <termref
                  def="dt-static-type"/> of the pattern’s equivalent expression, determined
               according to the rules in <specref ref="determining-static-type"/>. For example, the
               match type of the pattern <code>para[1]</code> is <code>U{element()}</code>, while
               that of the pattern <code>@code[.='x']</code> is <code>U{attribute()}</code></p>
         </div2>
         <div2 id="operand-roles">
            <head>Operand Roles</head>
            <p>An <termref def="dt-operand-role"/> gives information about the <termref
                  def="dt-operand">operands</termref> of a particular kind of construct. The two
               important properties of an operand role are the required type and the operand
               usage.</p>
            <p>The <termref def="dt-operand-usage">usage</termref> of an operand role is relevant
               only when the value of an <termref def="dt-operand"/> supplied in that role is a
               node, or a sequence that contains nodes. It is one of the following:</p>
            <ulist>
               <item>
                  <p><termdef id="dt-absorption" term="absorption">An operand usage of
                           <term>absorption</term> indicates that the construct reads the subtree(s)
                        rooted at a supplied node(s).</termdef> Examples are constructs that atomize
                     their <termref def="dt-operand">operands</termref>, or that obtain the string
                     value of a supplied node, or that copy the supplied node to a new tree. Another
                     example is the <xfunction>deep-equal</xfunction> function, which compares the
                     subtrees rooted at the nodes supplied in its first two arguments.</p>
               </item>
               <item>
                  <p><termdef id="dt-inspection" term="inspection">An operand usage of
                           <term>inspection</term> indicates that the construct accesses properties
                        of a supplied node that are available without reading its subtree.</termdef>
                     Examples are functions such as <xfunction>name</xfunction> and
                        <xfunction>base-uri</xfunction>, and the <code>instance of</code> expression
                     which tests the type of a node (or other item), or functions such as
                        <xfunction>count</xfunction>, <xfunction>exists</xfunction>, and
                        <xfunction>boolean</xfunction> which are only interested in the existence of
                     the node, and not in its properties.</p>
               </item>
               <item>
                  <p><termdef id="dt-transmission" term="transmission">An operand usage of
                           <term>transmission</term> indicates that the construct will (potentially)
                        return a supplied node as part of its result to the calling construct (that
                        is, to its parent in the construct tree).</termdef> It also indicates that
                     document order is preserved: if the input is in document order, then the result
                     must be in document order. An example is a filter expression, where nodes in
                     the base expression (the expression being filtered) will typically appear in
                     the result of the filter expression, in their original order.</p>
               </item>
               <item>
                  <p><termdef id="dt-navigation" term="navigation">An operand usage of
                           <term>navigation</term> indicates that the construct may navigate freely
                        from the supplied node to other nodes in the same tree, in a way that is not
                        constrained by the streamability rules.</termdef> This covers several cases:
                     cases where it is known that the construct performs impermissible navigation
                     (for example, the <elcode>xsl:number</elcode> instruction) or reordering (the
                        <xfunction>reverse</xfunction> function), or that require look-ahead (the
                        <xfunction>innermost</xfunction> function) and also cases where the analysis
                     is unable to determine what use is made of the node, for example because it is
                     passed as an argument to a user-defined function, or retained in a
                     variable.</p>
               </item>
            </ulist>
            <p><phrase diff="add" at="S-bug29053">The concept of operand usage is not used for all
                  constructs (for example, it is not used in the analysis of path expressions).
                  Where it is used, </phrase>the assignment of operand usages to each operand role
               of a construct is defined in <specref ref="classifying-constructs"/>.</p>
            <div3 id="operand-usage-examples">
               <head>Examples showing the Effect of Operand Usage</head>
               <example>
                  <head>The Effect of Operand Usage on the Streamability of a Context Item
                     Expression</head>
                  <p>Consider the following construct:</p>
                  <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:source-document streamable="yes" href="emps.xml"&gt;
  &lt;xsl:for-each select="*/emp"&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:source-document&gt;</eg>
                  <p>To assess the streamability, we follow the following logic:</p>
                  <olist>
                     <item>
                        <p>The top-level construct is a <termref def="dt-sequence-constructor"/>. It
                           is evaluated with a document node as the context item, and with a
                              <termref def="dt-striding"/> posture.</p>
                     </item>
                     <item>
                        <p>The sequence constructor has one child <termref def="dt-instruction"/>,
                           which has an <termref def="dt-operand-usage"/> of <termref
                              def="dt-transmission"/>.</p>
                     </item>
                     <item>
                        <p>The <elcode>xsl:for-each</elcode> instruction evaluates its
                              <code>select</code> expression, with the context item and <termref
                              def="dt-posture"/> unchanged.</p>
                     </item>
                     <item>
                        <p>The step <code>child::*</code> is evaluated with this context item and
                           posture. The posture transition rules permit this; we now have a sequence
                           of child elements, and still a <termref def="dt-striding"/> posture.</p>
                     </item>
                     <item>
                        <p>The same applies to the next step, <code>child::emp</code></p>
                     </item>
                     <item>
                        <p>The content of the <elcode>xsl:for-each</elcode> instruction is a
                              <termref def="dt-sequence-constructor"/> which itself has a single
                              <termref def="dt-operand"/>, the <elcode>xsl:value-of</elcode>
                           instruction.</p>
                     </item>
                     <item>
                        <p>The <elcode>xsl:value-of</elcode> instruction is evaluated once for each
                              <code>emp</code> child, with that child as context item and in a
                              <termref def="dt-striding"/> posture. This instruction uses the
                              <termref def="dt-general-streamability-rules"/>. The <termref
                              def="dt-operand-usage"/> of the <code>select</code> expression is
                              <termref def="dt-absorption"/>. This means that the result of the
                              <elcode>xsl:value-of</elcode> instruction is <termref
                              def="dt-grounded"/> and <termref def="dt-consuming"/>.</p>
                     </item>
                     <item>
                        <p>The result of the trivial sequence constructor contained in the
                              <elcode>xsl:for-each</elcode> instruction is therefore <termref
                              def="dt-grounded"/> and <termref def="dt-consuming"/></p>
                     </item>
                     <item>
                        <p>The result of the <elcode>xsl:for-each</elcode> instruction (see <specref
                              ref="streamability-xsl-for-each"/>) is therefore <termref
                              def="dt-grounded"/> and <termref def="dt-consuming"/></p>
                     </item>
                     <item>
                        <p>The result of the trivial sequence constructor contained in the
                              <elcode>xsl:source-document</elcode> instruction is therefore <termref
                              def="dt-grounded"/> and <termref def="dt-consuming"/></p>
                     </item>
                     <item>
                        <p>The <elcode>xsl:source-document</elcode> instruction is therefore
                              <termref def="dt-guaranteed-streamable"/>.</p>
                     </item>
                  </olist>
                  <p>Now consider a slightly different construct:</p>
                  <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:source-document streamable="yes" href="emps.xml"&gt;
  &lt;xsl:for-each select="*/emp"&gt;
    &lt;xsl:sequence select="."/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:source-document&gt;</eg>
                  <p>To assess the streamability, we follow the following logic:</p>
                  <olist>
                     <item>
                        <p>The top-level construct is a <termref def="dt-sequence-constructor"/>. It
                           is evaluated with a document node as the context item, and with a
                              <termref def="dt-striding"/> posture.</p>
                     </item>
                     <item>
                        <p>The sequence constructor has one child <termref def="dt-instruction"/>,
                           which has an <termref def="dt-operand-usage"/> of <termref
                              def="dt-transmission"/>.</p>
                     </item>
                     <item>
                        <p>The <elcode>xsl:for-each</elcode> instruction evaluates its
                              <code>select</code> expression, with the context item and <termref
                              def="dt-posture"/> unchanged.</p>
                     </item>
                     <item>
                        <p>The step <code>child::*</code> is evaluated with this context item and
                           posture. The posture transition rules permit this; we now have a sequence
                           of child elements, and still a <termref def="dt-striding"/> posture.</p>
                     </item>
                     <item>
                        <p>The same applies to the next step, <code>child::emp</code></p>
                     </item>
                     <item>
                        <p>The content of the <elcode>xsl:for-each</elcode> instruction is a
                              <termref def="dt-sequence-constructor"/> which itself has a single
                           operand, the <elcode>xsl:sequence</elcode> instruction.</p>
                     </item>
                     <item>
                        <p>The <elcode>xsl:sequence</elcode> instruction is evaluated once for each
                              <code>emp</code> child, with that child as context item and in a
                              <termref def="dt-striding"/> posture. This instruction uses the
                              <termref def="dt-general-streamability-rules"/>. The <termref
                              def="dt-operand-usage"/> of the <code>select</code> expression is
                              <termref def="dt-transmission"/>. This means that the result of the
                              <elcode>xsl:sequence</elcode> instruction is <termref
                              def="dt-striding"/> and <termref def="dt-motionless"/>.</p>
                     </item>
                     <item>
                        <p>The result of the trivial sequence constructor contained in the
                              <elcode>xsl:for-each</elcode> instruction is therefore also <termref
                              def="dt-striding"/> and <termref def="dt-motionless"/>.</p>
                     </item>
                     <item>
                        <p>The result of the <elcode>xsl:for-each</elcode> instruction (see <specref
                              ref="streamability-xsl-for-each"/>) is therefore <termref
                              def="dt-striding"/> and <phrase diff="chg" at="R-bug25350"><termref
                                 def="dt-consuming"/> (the wider of the sweeps of the
                                 <code>select</code> expression and the sequence
                              constructor)</phrase>.</p>
                     </item>
                     <item>
                        <p>The result of the trivial sequence constructor contained in the
                              <elcode>xsl:source-document</elcode> instruction is therefore <termref
                              def="dt-striding"/> and <phrase diff="chg" at="R-bug25350"><termref
                                 def="dt-consuming"/></phrase>.</p>
                     </item>
                     <item>
                        <p><phrase diff="add" at="R-bug25350">Since the result is not <termref
                                 def="dt-grounded"/>, </phrase> the
                              <elcode>xsl:source-document</elcode> instruction is therefore not
                              <termref def="dt-guaranteed-streamable"/>.</p>
                     </item>
                  </olist>
                  <p>Expressed informally, the result of a <phrase diff="add" at="T-bug29747"
                           ><termref def="dt-declared-streamable"/></phrase>
                     <elcode>xsl:source-document</elcode> instruction (or of a <phrase diff="add"
                        at="T-bug29747"><termref def="dt-declared-streamable"/></phrase> template
                     rule) must not contain streamed nodes. The reason for this is that once
                     streamed nodes are returned to constructs that are not declared streamable and
                     therefore have no streamability constraints, there is no way to analyze what
                     happens to them, and thus to guarantee streamability.</p>
               </example>
               <example>
                  <head>The Effect of Operand Roles on the Streamability of Path Expressions</head>
                  <p>Consider the expression <code>.//chapter</code>.</p>
                  <p>When this appears as an argument to the function <xfunction>count</xfunction>
                     or <xfunction>exists</xfunction>, it can be streamed (it is a <termref
                        def="dt-consuming"/> expression, meaning that the subtree rooted at the
                     context item needs to be read in order to evaluate the expression). A possible
                     strategy for performing a streamed evaluation is to read all descendants of the
                     context item in document order, checking each one to see whether its name is
                        <code>chapter</code>. The <termref def="dt-sweep"/> of the expression will
                     be <termref def="dt-consuming"/>, and its <termref def="dt-posture"/> will be
                        <termref def="dt-crawling"/>.</p>
                  <p>The <termref def="dt-operand-usage"/> (the usage of the argument to
                        <xfunction>count</xfunction> or <xfunction>exists</xfunction>) is defined as
                        <termref def="dt-inspection"/>. The <termref
                        def="dt-general-streamability-rules"/> show that when the posture of an
                        <termref def="dt-operand"/> is <termref def="dt-crawling"/> and the <termref
                        def="dt-operand-usage"/> is <termref def="dt-inspection"/>, the resulting
                     expression is <phrase diff="chg" at="R-bug25364"><termref def="dt-grounded"/>
                        and <termref def="dt-consuming"/>. This means that (in the absence of other
                        consuming expressions) the containing template or function will generally be
                        streamable</phrase>.</p>
                  <p diff="chg" at="R-bug26378">In the expression <code>tail(.//chapter)</code>, the
                        <termref def="dt-operand-usage"/> is classified as <termref
                        def="dt-transmission"/>, meaning that the nodes are simply passed up the
                     tree to the next containing expression. In general, when a <termref
                        def="dt-crawling"/> expression is passed as an argument and the operand role
                     is <termref def="dt-transmission"/>, the containing expression will also be
                        <termref def="dt-crawling"/>. However, there is an exception where the
                     expression is known to deliver a singleton (for example,
                        <code>head(.//chapter)</code>). In this case the returned sequence cannot
                     contain any nested nodes, so it is <termref def="dt-crawling"/>.</p>
                  <p>When the same expression appears as an argument to an atomizing function
                        <xfunction>string-join</xfunction>, the processor knows that it will need to
                     access the subtree of each selected <code>section</code> element in order to
                     compute the result of the function (the argument to
                        <xfunction>string-join</xfunction> is classified as having <termref
                        def="dt-operand-usage"/>
                     <termref def="dt-absorption"/>). The processor does not know whether these
                     subtrees will be <phrase diff="chg" at="R-bug24290">nested</phrase> (one
                        <code>section</code> might contain another). <phrase diff="chg"
                        at="R-bug25185">In most cases they will not be nested, because atomizing a
                        sequence that contains nested nodes is not generally a useful thing to do.
                        The streamability analysis therefore makes an optimistic assumption, by
                        treating atomization of a <termref def="dt-crawling"/> expression as a
                        streamable operation. In the worst case, where it turns out that the
                        selected nodes are indeed nested, the processor must handle this, typically
                        by buffering the content of inner nodes until the end tag of the outer nodes
                        is reached.</phrase></p>
                  <p diff="chg" at="R-bug25185">This treatment of nodes in a <termref
                        def="dt-crawling"/> expression applies to all cases in which the content of
                     the nodes is handled in a way defined entirely by the rules of this
                     specification: for example, operations such as atomization, obtaining the
                     string value of nodes, deep copy of nodes, and the
                        <xfunction>deep-equal</xfunction> function. It does not extend to cases
                     where the processing applied to the nodes is user-defined: for example,
                     operations such as <elcode>xsl:apply-templates</elcode>,
                        <elcode>xsl:for-each</elcode>, or <elcode>xsl:for-each-group</elcode>. In
                     these cases, the nodes selected for processing must not be nested (a <termref
                        def="dt-crawling"/>
                     <termref def="dt-posture"/> is not permitted in these contexts).</p>
                  <p diff="chg" at="R-bug26378">When a <termref def="dt-crawling"/> expression
                     appears as an argument to a call on a user-defined function, <phrase diff="chg"
                        at="S-bug27571">the effect depends on the <termref
                           def="dt-streamability-category"/> of the function, as described in
                           <specref ref="streamable-stylesheet-functions"/></phrase>.</p>
                  <olist diff="del" at="S-bug27571">
                     <item>
                        <p>If the declared type of the relevant argument is an atomic type, then the
                           nodes will be atomized; this is treated just like a call on an atomizing
                           built-in function such as <code>string-join</code>, discussed above.</p>
                     </item>
                     <item>
                        <p>If the user-defined function is declared streamable and is not recursive,
                           then the streamability of the function call depends on an analysis of the
                           function body of the target function, as described in <specref
                              ref="streamability-of-function-calls"/>.</p>
                     </item>
                  </olist>
               </example>
            </div3>
         </div2>
         <div2 id="posture">
            <head>Determining the Posture of a Construct</head>
            <p>The <term>posture</term> of a construct indicates the relationship of the nodes
               selected by the <termref def="dt-construct"/> to a <termref
                  def="dt-streamed-document">streamed input document</termref>. The value is one of
               the following:</p>
            <ulist>
               <item>
                  <p><termdef id="dt-grounded" term="grounded"><term>Grounded</term>: indicates that
                        the value returned by the construct does not contain nodes from the streamed
                        input document</termdef>. Atomic values and function items are always
                     grounded; nodes are grounded if it is known that they are in a non-streamed
                     document. For example the expressions <code>doc('x')</code> and
                        <code>copy-of(.)</code> both return grounded nodes.</p>
               </item>
               <item>
                  <p><termdef id="dt-climbing" term="climbing"><term>Climbing</term>: indicates that
                        streamed nodes returned by the construct are reached by navigating the
                        parent, ancestor[-or-self], attribute, and/or namespace axes from the node
                        at the current streaming position.</termdef> When the <phrase diff="chg"
                        at="Q"><termref def="dt-context-posture"/></phrase> is climbing, use of
                     certain axes such as <code>parent</code> and <code>ancestor</code> is
                     permitted, but use of other axes such as <code>child</code> or
                        <code>descendant</code> violates the streamability rules.</p>
               </item>
               <item>
                  <p><termdef id="dt-crawling" term="crawling"><term>Crawling</term>: typically
                        indicates that streamed nodes returned by a construct are reached by
                        navigating the descendant[-or-self] axis.</termdef> Nodes reached in this
                     way <phrase diff="chg" at="R-bug24290">are potentially nested (one might be an
                        ancestor of another)</phrase>, so further downward navigation is not
                     permitted. <phrase diff="add" at="Q">Expressions that can be statically
                        determined to return a singleton node (for example
                           <code>head(.//title)</code>) generate a result with no <phrase diff="chg"
                           at="R-bug24290">such nesting</phrase>, so they are striding rather than
                        crawling.</phrase></p>
               </item>
               <item>
                  <p><termdef id="dt-striding" term="striding"><term>Striding</term>: indicates that
                        the result of a construct contains a sequence of streamed nodes, in document
                        order, that are peers in the sense that none of them is an ancestor or
                        descendant of any other.</termdef> This is typically achieved by using one
                     or more steps involving the child <phrase diff="add" at="S-bug27051">or
                        attribute</phrase> axes only. Use of the <xfunction>outermost</xfunction>
                     function can also result in a striding posture, <phrase diff="add" at="Q">as
                        can functions such as <xfunction>head</xfunction> or
                           <xfunction>zero-or-one</xfunction> that ensure the result will be a
                        singleton node.</phrase></p>
               </item>
               <item>
                  <p><termdef id="dt-roaming" term="roaming"><term>Roaming</term>: indicates that
                        the nodes returned by an expression could be anywhere in the tree, which
                        inevitably means that the construct cannot be evaluated using
                        streaming.</termdef> For example, the <termref def="dt-posture"/> of an axis
                     step using the <code>following</code> or <code>preceding</code> axis will
                     typically be <termref def="dt-roaming"/>, which leads the analysis to conclude
                     that the construct is not streamable.</p>
               </item>
            </ulist>
            <note>
               <p>One way to think about the posture values is as labels for states in a finite
                  state automaton, where the alphabet of symbols accepted by the automaton is the
                  set of 13 XPath axes, and the sentence being parsed is a path expression
                  containing a sequence of axis steps. For example, use of the
                     <code>descendant</code> axis when the current state is <term>striding</term>
                  moves the new state to <term>crawling</term>, and use of the <code>parent</code>
                  axis then takes it to <term>climbing</term>. </p>
            </note>
            <p>The <termref def="dt-posture"/> of a construct is determined in one of several
               ways:</p>
            <ulist>
               <item>
                  <p>For axis steps, the posture of the expression is determined by the <phrase
                        diff="chg" at="Q"><termref def="dt-context-posture"/></phrase> and the
                     choice of axis. For example, an axis step using the ancestor axis always has a
                     posture of <termref def="dt-climbing"/>, while an axis step using the child
                     axis, if the <phrase diff="chg" at="Q"><termref def="dt-context-posture"
                        /></phrase> is <termref def="dt-striding"/>, will itself have a posture of
                        <termref def="dt-striding"/>. The rules for the posture transitions produced
                     by axis steps are given in <specref ref="streamability-of-axis-steps"/>.</p>
               </item>
               <item>
                  <p>For many other constructs, the posture is determined by the <termref
                        def="dt-general-streamability-rules"/>. These determine the result posture
                     in terms of the <termref def="dt-operand">operands</termref> of the construct
                     and the way in which each operand is used. For example, a construct that
                     accepts a streamed node as the value of an operand, and atomizes that node,
                     will generally have a posture of <termref def="dt-grounded"/>.</p>
               </item>
               <item>
                  <p>Other constructs have their own special rules, which are all listed in this
                     chapter. For example, a call on the <xfunction>root</xfunction> function
                     behaves analogously to an axis step, and is described in <specref
                        ref="streamability-fn-root"/>. Special rules are needed for:</p>
                  <ulist>
                     <item>
                        <p>Constructs that evaluate an <termref def="dt-operand"/> more than once,
                           such as an XPath <code>for</code> expression;</p>
                     </item>
                     <item>
                        <p>Constructs that have alternatives among their operands, such as an XPath
                              <code>if</code> expression;</p>
                     </item>
                     <item>
                        <p>Constructs that navigate relative to the context item, such as axis
                           steps;</p>
                     </item>
                     <item>
                        <p>Constructs with implicit inputs, such as the context item expression
                              <code>.</code> (dot);</p>
                     </item>
                     <item>
                        <p>Constructs that change the focus, such as a filter expression;</p>
                     </item>
                     <item>
                        <p>Constructs that invoke functions or templates.</p>
                     </item>
                  </ulist>
               </item>
            </ulist>
            <p diff="add" at="T-bug29507">The characterization of an expression as striding,
               crawling, climbing, or roaming applies only to the streamed nodes in the the result
               of the expression. The result of the expression may also contain non-streamed
               (grounded) nodes or atomic values. For example if <code>/x/y</code> is a striding
               expression, then <code>(/x/y | $doc//x)</code> is also striding, given that
                  <code>$doc</code> contains non-streamed nodes. The assertion that the nodes in the
               result of a striding expression are in document order and are peers thus applies only
               to the subset of the nodes that are streamed.</p>
            <note diff="add" at="T-bug29507">
               <p>A consequence of this is that when striding expressions are used in a context that
                  requires sorting into document order, for example <code>(/x/y | $doc//x) /
                     @price</code>, the fact that the expression is striding does not eliminate the
                  need for the sequence to be re-ordered. However, there will never be a need for
                  the relative order of the streamed nodes in the value to change.</p>
               <p>Since the data model leaves the relative order of nodes in different trees
                  implementation-defined, and since streamed and unstreamed nodes will necessarily
                  be in different trees, a useful implementation strategy might be to arrange that
                  streamed nodes always precede unstreamed nodes in document order (or vice versa).
                  An operation that needs to process the result of a striding expression in document
                  order can then first deliver all the streamed nodes (by consuming the input
                  stream) in the order they arrive, and then deliver the unstreamed nodes, suitably
                  sorted.</p>
            </note>
         </div2>
         <div2 id="determining-context-posture" diff="chg" at="Q">
            <head>Determining the Context Posture</head>
            <p>In the same way as the type of the context item can be determined for any construct C
               by reference to the type of the construct that establishes the context for the
               evaluation of C, so the posture of the context item C can be determined by reference
               to the posture of the construct that establishes the context.</p>
            <p>The <termref def="dt-context-posture"/> of a construct <var>C</var> is the first of
               the following that applies:</p>
            <olist>
               <item>
                  <p>If the <termref def="dt-focus-setting-container"/> of <var>C</var> is an
                        <elcode>xsl:function</elcode> declaration, an inline function declaration,
                     or an <elcode>xsl:on-completion</elcode> element, then the context posture is
                        <termref def="dt-roaming"/>.</p>
                  <note>
                     <p>This is essentially an error case; expressions that depend on the context
                        item should not normally appear within these constructs.</p>
                  </note>
               </item>
               <item>
                  <p>If the <termref def="dt-focus-setting-container"/> of <var>C</var> is an
                        <elcode>xsl:source-document</elcode> instruction, then the context posture
                     is <termref def="dt-striding"/>
                     <phrase diff="add" at="T-bug29747">if the instruction is <termref
                           def="dt-declared-streamable"/>, or <termref def="dt-grounded"/>
                        otherwise.</phrase></p>
               </item>
               <item>
                  <p>If the <termref def="dt-focus-setting-container"/> of <var>C</var> is a
                        <termref def="dt-template-rule"/> whose mode is declared with
                        <code>streamable="yes"</code>, then the context posture is <termref
                        def="dt-striding"/>.</p>
               </item>
               <item>
                  <p>If the <termref def="dt-focus-setting-container"/> of <var>C</var> is a
                        <termref def="dt-pattern"/>, then the context posture is <termref
                        def="dt-striding"/>.</p>
               </item>
               <item>
                  <p>If the <termref def="dt-focus-setting-container"/> of <var>C</var> is an
                        <elcode>xsl:attribute-set</elcode> declaration with the attribute
                        <code>streamable="yes"</code>, then the context posture is <termref
                        def="dt-striding"/>.</p>
               </item>
               <item>
                  <p>If the <termref def="dt-focus-setting-container"/> is any other <termref
                        def="dt-declaration"/>, for example a global variable declaration, a
                        <termref def="dt-named-template"/>, or a template rule or attribute set that
                     does not specify <code>streamable="yes"</code>, then the context posture is
                        <termref def="dt-roaming"/>.</p>
               </item>
               <item>
                  <p>Otherwise, the context posture is the <termref def="dt-posture"/> of the
                        <termref def="dt-controlling-operand"/> of the <termref
                        def="dt-focus-setting-container"/> of <var>C</var>.</p>
               </item>
            </olist>
         </div2>
         <div2 id="sweep">
            <head>The Sweep of a Construct</head>
            <p><termdef id="dt-sweep" term="sweep">Every construct has a <term>sweep</term>, which
                  is a measure of the extent to which the current position in the input stream moves
                  during the evaluation of the expression. The sweep is one of: <termref
                     def="dt-motionless"/>, <phrase diff="del" at="Q">group-consuming,
                     </phrase><termref def="dt-consuming"/>, or <termref def="dt-free-ranging"/>
                  <phrase diff="del" at="Q">, or caller-determined</phrase>.</termdef> This list of
               values is ordered: a <termref def="dt-free-ranging"/> expression has <term>wider
                  sweep</term> than a <termref def="dt-consuming"/> expression, which has
                  <term>wider sweep</term> than a <termref def="dt-motionless"/> expression. </p>
            <p><termdef id="dt-motionless" term="motionless">A <term>motionless</term> construct is
                  any <termref def="dt-construct"/> deemed motionless by the rules in this section
                     (<specref ref="streamability"/>).</termdef> Informally, a motionless construct
               is one that can be evaluated without changing the current position in the input
               stream.</p>
            <note>
               <p>The context item expression <code>.</code> is classified as motionless; however a
                  construct that uses <code>.</code> as an <termref def="dt-operand"/> (for example,
                     <code>string(.)</code>) might be <termref def="dt-consuming"/>. The
                  streamability rules effectively consider expressions such as <code>.</code> within
                  the context of the containing construct.</p>
            </note>
            <p diff="del" at="Q">A <term>group-consuming</term> construct is any <termref
                  def="dt-construct"/> deemed group-consuming by the rules in this section (<specref
                  ref="streamability"/>). Informally, a group-consuming construct is one whose
               evaluation requires repositioning of the input stream from the start of the first
               node in the current group (always a contiguous sequence of children of the context
               node) to the end of the last node in the current group.</p>
            <p><termdef id="dt-consuming" term="consuming">A <term>consuming</term> construct is any
                     <termref def="dt-construct"/> deemed consuming by the rules in this section
                     (<specref ref="streamability"/>).</termdef> Informally, a consuming construct
               is one whose evaluation requires repositioning of the input stream from the start of
               the current node to the end of the current node.</p>
            <p><termdef id="dt-free-ranging" term="free-ranging">A <term>free-ranging</term>
                  construct is any <termref def="dt-construct"/> deemed free-ranging by the rules in
                  this section (<specref ref="streamability"/>).</termdef> Informally, a
               free-ranging construct is one whose evaluation may require access to information that
               is not available from the subtree rooted at the current node, together with
               information about ancestors of the current node and their attributes.</p>
            <p diff="del" at="Q">The sweep of a construct is classified as
                  <term>caller-determined</term> if the sweep depends not on the construct itself,
               but on the way in which the result is used. The most obvious example of such a
               construct is the context item expression, <code>.</code> (dot). For example,
                  <code>name(.)</code> is motionless, while <code>data(.)</code> is typically
               consuming. The same applies to axis steps, for example <code>name(..)</code> is
               motionless, while <code>data(..)</code> is free-ranging.</p>
            <p diff="del" at="Q">In cases where a <termref def="dt-construct"/>
               <var>C</var> has an <termref def="dt-operand"/> whose <termref def="dt-sweep"/> is
               caller-determined, the sweep of <var>C</var> will depend on two factors: the <termref
                  def="dt-posture"/> of the actual operand, and the classification of the formal
                  <termref def="dt-operand-usage"/>. The result is given by the table in <specref
                  ref="general-streamability-rules"/>.</p>
            <p diff="chg" at="S+">The table below shows some examples of expressions having
               different combinations of <termref def="dt-posture"/> and <termref def="dt-sweep"
               />.</p>
            <table diff="chg" at="S+" class="data">
               <caption>Combinations of Sweep and Posture</caption>
               <thead>
                  <tr>
                     <th rowspan="1" colspan="1"/>
                     <th rowspan="1" colspan="1">Motionless</th>
                     <th rowspan="1" colspan="1">Consuming</th>
                     <th rowspan="1" colspan="1">Free-Ranging</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <th rowspan="1" colspan="1">Grounded</th>
                     <td rowspan="1" colspan="1"><code>name()</code></td>
                     <td rowspan="1" colspan="1"><code>string(title)</code></td>
                     <td rowspan="1" colspan="1">See Note</td>
                  </tr>
                  <tr>
                     <th rowspan="1" colspan="1">Climbing</th>
                     <td rowspan="1" colspan="1"><code diff="chg" at="S-bug27051"
                        >parent::*</code></td>
                     <td rowspan="1" colspan="1"><code>child::x/ancestor::y</code></td>
                     <td rowspan="1" colspan="1">See Note</td>
                  </tr>
                  <tr>
                     <th rowspan="1" colspan="1">Striding</th>
                     <td rowspan="1" colspan="1"><code diff="chg" at="S-bug27051"
                        >@status</code></td>
                     <td rowspan="1" colspan="1"><code>child::*</code></td>
                     <td rowspan="1" colspan="1">See Note</td>
                  </tr>
                  <tr>
                     <th rowspan="1" colspan="1">Crawling</th>
                     <td rowspan="1" colspan="1">The subexpression <code>.</code> in
                           <code>//a/.</code></td>
                     <td rowspan="1" colspan="1"><code>descendant::*</code></td>
                     <td rowspan="1" colspan="1"><code>//x[child::y]</code></td>
                  </tr>
                  <tr>
                     <th rowspan="1" colspan="1">Roaming</th>
                     <td rowspan="1" colspan="1">See Note</td>
                     <td rowspan="1" colspan="1">See Note</td>
                     <td rowspan="1" colspan="1"><code>preceding::*</code></td>
                  </tr>
               </tbody>
            </table>
            <note diff="add" at="S+">
               <p>In all cases where either the <termref def="dt-posture"/> is <termref
                     def="dt-roaming"/>, or the <termref def="dt-sweep"/> is <termref
                     def="dt-free-ranging"/>, or both, the effect is to make an expression
                  non-streamable. For convenience, therefore, evaluation of the streamability rules
                  in most cases returns the values <termref def="dt-roaming"/> and <termref
                     def="dt-free-ranging"/> only in combination with each other. In cases where the
                  rules return a <termref def="dt-posture"/> of <termref def="dt-roaming"/> combined
                  with some other <termref def="dt-sweep"/>, or a <termref def="dt-sweep"/> of
                     <termref def="dt-free-ranging"/> with some other <termref def="dt-posture"/>,
                  the final result of the analysis is always the same as if the expression were both
                     <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
               <p>For an example of a case where an expression is <termref def="dt-roaming"/> but
                  not <termref def="dt-free-ranging"/>, consider the right-hand operand of the
                  relative path expression <code>(preceding::x/.)</code>. The rules for the
                  streamability of a context item expression (see <specref
                     ref="streamability-of-context-item-expression"/>) give "<code>.</code>" in this
                  context a <termref def="dt-roaming"/> posture, combined with <termref
                     def="dt-motionless"/> sweep. But the relative path expression as a whole is
                     <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/> (see <specref
                     ref="streamability-of-path-expressions"/>), so the apparent inconsistency is
                  transient.</p>
            </note>
         </div2>
         <div2 id="grounded-consuming-constructs" diff="add" at="S-bug29153">
            <head>Grounded Consuming Constructs</head>
            <p>A construct is grounded if the items it delivers do not include nodes from a streamed
               document; it is consuming if evaluation of the construct reads nodes from a streamed
               input in a way that requires advancing the current position in the input. </p>
            <p>Grounded consuming constructs play an important role in streaming, and this section
               discusses some of their characteristics. </p>
            <p>Examples of grounded consuming constructs (assuming the context item is a streamed
               node) include: </p>
            <ulist>
               <item>
                  <p><code>sum(.//transaction/@value)</code></p>
               </item>
               <item>
                  <p><code>copy-of(./account/history/event)</code></p>
               </item>
               <item>
                  <p><code>distinct-values(./account/@account-nr)</code></p>
               </item>
               <item>
                  <p><code>&lt;xsl:for-each select="transaction"&gt;&lt;t&gt;&lt;xsl:value-of
                        select="@value"/&gt;&lt;/t&gt;&lt;/xsl:for-each&gt;</code></p>
               </item>
            </ulist>
            <p>XSLT 3.0 provides the two functions <function>copy-of</function> and
                  <code>snapshot</code> with the explicit purpose of creating a sequence of grounded
               nodes, that can be processed one-by-one without the usual restrictions that apply to
               streamed processing, such as the rule permitting at most one downward selection. The
               processing style that exploits these functions is often called “windowed
               streaming”.</p>
            <p>In general the result of a grounded consuming construct is a sequence. Depending on
               how this sequence is used, it may or may not be necessary for the processor to
               allocate sufficient memory to hold the entire sequence. The streamability rules in
               this specification place few constraints on how a grounded sequence is used. This is
               deliberate, because it gives users control: by creating a grounded sequence (for
               example, by use of the copy-of function) stylesheet authors create the possibility to
               process data in arbitrary ways (for example, by sorting the sequence), and accept the
               possibility that this may consume memory. </p>
            <p>Pipelined evaluation of a sequence is analogous to streamed processing of a source
               document. Pipelined evaluation occurs when the items in a sequence can be processed
               one-by-one, without materializing the entire sequence in memory. Pipelining is a
               common optimization technique in all functional programming languages. Operations for
               which pipelined evaluation is commonly performed include filtering
                  (<code>$transactions[@value gt 1000]</code>), mapping (<code>$transactions!(@value
                  - @processing-fee)</code>), and aggregation (<code>sum($transactions)</code>).
               Operations that cannot be pipelined (because, for example, the first item in the
               result sequence cannot be computed without knowing the last item in the input
               sequence) include those that change the order of items (<code>reverse()</code>,
                  <code>sort()</code>). Other operations such as <code>distinct-values()</code>
               allow the input to be processed one item at a time, but require memory that
               potentially increases as the sequence length increases. Saving a grounded sequence in
               a variable is also likely in many cases to require allocation of memory to hold the
               entire sequence. </p>
            <p>When the input to an operation is a grounded consuming sequence (more accurately, a
               sequence resulting from the evaluation of a grounded consuming construct), this
               specification does not attempt to dictate whether the operation is pipelined or not.
               The goal of interoperable streaming in finite memory can therefore only be achieved
               if stylesheet authors take care to avoid constructing grounded sequences that occupy
               large amounts of memory. In practice, however, users can expect that many grounded
               consuming constructs will be pipelined where the semantics permit this. </p>
            <note>
               <p>Some processors may recognize an opportunity for pipelining only if the expression
                  is written in a particular way. For example the constructs
                     <code>copy-of(/a/b/c)</code> and <code>/a/b/c/copy-of(.)</code> are to all
                  intents and purposes equivalent, but some processors might recognize the second
                  form more easily as suitable for pipelining.</p>
               <p>(There is one minor difference between these expressions: the order of nodes in
                     <code>copy-of(/a/b/c)</code> is required to reflect the document order of the
                  nodes in <code>/a/b/c</code>, while the result of <code>/a/b/c/copy-of(.)</code>
                  can be in any order, in consequence of the rule that document order for nodes in
                  different trees is implementation-dependent.)</p>
            </note>
            <p>The use of the <xfunction>last</xfunction> function requires particular care because
               of its effect on pipelining. The streamability rules prevent the use of
                  <code>last()</code> in conjunction with an expression that returns streamed nodes
               (because it would require look-ahead in the stream), but there is no similar
               constraint for grounded sequences. So for example it is not permitted (in a context
               that requires streaming) to write </p>
            <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:for-each select="transaction"&gt;
  &lt;xsl:value-of select="position(), ' of ', last()"/&gt;
&lt;/xsl:for-each&gt;</eg>
            <p>but it is quite permissible to write</p>
            <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:for-each select="transaction/copy-of()"&gt;
  &lt;xsl:value-of select="position(), ' of ', last()"/&gt;
&lt;/xsl:for-each&gt;</eg>
            <p>because the call on <function>copy-of</function> makes the sequence grounded. This
               construct cannot be pipelined because computing the first item in the result sequence
               depends on knowing the length of the input sequence; in consequence, a processor
               might be obliged to buffer all the transactions (or their copies) in memory. In this
               simple example the impact of the call on <xfunction>last</xfunction> is easily
               detected both by the human reader and by the XSLT processor, but there are other
               cases where the effect is less obvious. For example if the stylesheet executes the
               instruction </p>
            <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:apply-templates select="transaction/copy-of(.)"/&gt;</eg>
            <p>then the presence of a call on <xfunction>last</xfunction> in one of the template
               rules that gets invoked might not be easily spotted; yet the effect is exactly the
               same in preventing the result being computed by processing input items strictly one
               at a time. Avoiding such effects is entirely the responsibility of the stylesheet
               author. </p>
            <p>By contrast, there is no intrinsic reason why use of the
                  <xfunction>position</xfunction> should prevent pipelined processing: all it
               requires is for the processor to count how many items have been processed so far.
               Processors may also be able to handle the construct <code>position() = last()</code>
               without storing the entire sequence in memory; rather than actually evaluating the
               numeric values of <code>position()</code> and <code>last()</code>, this can be done
               by testing whether the context item is the last item in the sequence, which only
               requires a one-item lookahead.</p>
         </div2>
         <div2 id="classifying-constructs">
            <head>Classifying Constructs</head>
            <p>This section defines the properties of every kind of <termref def="dt-construct"/>
               that may appear in a <termref def="dt-stylesheet"/>. It identifies the <termref
                  def="dt-operand-role">operand roles</termref> and their <termref
                  def="dt-operand-usage">usage</termref>, and it gives the rules that define the
                  <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the construct. In
               cases where the <termref def="dt-general-streamability-rules"/> apply, there is still
               an entry for the construct in order to define its <termref def="dt-operand"
                  >operands</termref> and their usages, since this information is needed by the
               general rules.</p>
            <p>The following sections describe this categorization for each kind of construct:</p>
            <ulist>
               <item>
                  <p>Sequence constructors: see <specref ref="classifying-sequence-constructors"
                     /></p>
               </item>
               <item>
                  <p>Instructions: see <specref ref="classifying-instructions"/></p>
               </item>
               <item>
                  <p>Stylesheet functions: see <specref ref="streamable-stylesheet-functions"/></p>
               </item>
               <item>
                  <p>Attribute sets: see <specref ref="classifying-attribute-sets"/></p>
               </item>
               <item>
                  <p>Value templates: see <specref ref="classifying-vts"/></p>
               </item>
               <item>
                  <p>Expressions: see <specref ref="classifying-expressions"/></p>
               </item>
               <item>
                  <p>Patterns: see <specref ref="classifying-patterns"/></p>
               </item>
               <item>
                  <p>Calls to built-in functions: see <specref ref="classifying-built-in-functions"
                     /></p>
               </item>
            </ulist>
            <div3 id="general-streamability-rules" diff="add" at="L">
               <head>General Rules for Streamability</head>
               <p><termdef id="dt-general-streamability-rules" term="general streamability rules"
                     >Many <termref def="dt-construct">constructs</termref> share the same
                     streamability rules. These rules, referred to as the <term>general
                        streamability rules</term>, are defined here.</termdef></p>
               <p>Examples of constructs that use these rules are: an arithmetic expression, an
                     <termref def="dt-attribute-value-template"/>, a <termref
                     def="dt-sequence-constructor"/>, the <elcode>xsl:value-of</elcode> instruction,
                  and a call to the <xfunction>doc</xfunction> function.</p>
               <p>The rules determine both the <termref def="dt-posture"/> and <termref
                     def="dt-sweep">sweep</termref> of a construct. To determine the posture and
                  sweep of a construct <var>C</var>, assuming these general rules are applicable to
                  that kind of construct:</p>
               <olist>
                  <item>
                     <p>For each <termref def="dt-operand"/> of <var>C</var>:</p>
                     <olist>
                        <item>
                           <p>Establish:</p>
                           <olist>
                              <item>
                                 <p>The <termref def="dt-static-type"/>
                                    <var>T</var> of the operand (see <specref
                                       ref="determining-static-type"/>). </p>
                                 <note diff="add" at="S-bug27668">
                                    <p>The static type is a <termref def="dt-utype"/>. For example,
                                       the static type of the expression <code>(@*, *)</code> is
                                          <var>U{element(), attribute()}</var>.</p>
                                 </note>
                              </item>
                              <item>
                                 <p>The <termref def="dt-sweep"/>
                                    <var>S</var> and <termref def="dt-posture"/>
                                    <var>P</var> of the operand (by applying the rules in this
                                    section <phrase diff="add" at="Q"><specref
                                          ref="classifying-constructs"/></phrase> to that operand,
                                    recursively).</p>
                              </item>
                              <item>
                                 <p>The <termref def="dt-operand-usage"/>
                                    <var>U</var> corresponding to the <termref def="dt-operand-role"
                                       >role</termref> of the operand within <var>C</var> (from the
                                    information in this section <phrase diff="add" at="Q"><specref
                                          ref="classifying-constructs"/></phrase>).</p>
                              </item>
                           </olist>
                        </item>
                        <item>
                           <p>Compute the adjusted sweep <var>S'</var> of the <termref
                                 def="dt-operand"/> by taking the first of the following that
                              applies:</p>
                           <olist>
                              <item>
                                 <p>If <var>S</var> is <termref def="dt-free-ranging"/> or
                                       <var>P</var> is <termref def="dt-roaming"/>, then
                                       <var>S'</var> is <termref def="dt-free-ranging"/>. (In this
                                    case the posture and sweep of <var>C</var> are <termref
                                       def="dt-roaming"/> and <termref def="dt-free-ranging"/>,
                                    regardless of any other operands.)</p>
                              </item>
                              <item>
                                 <p>If <var>P</var> is <termref def="dt-grounded"/>, then
                                       <var>S'</var> is <var>S</var>.</p>
                              </item>
                              <item>
                                 <p>Otherwise (<var>P</var> is not <termref def="dt-grounded"/>,
                                    which implies that the <termref def="dt-operand"/> is <phrase
                                       diff="add" at="Q">capable of</phrase> returning streamed
                                    nodes), compute <var>S'</var> as follows:</p>
                                 <olist>
                                    <item>
                                       <p>Compute the adjusted usage <var>U'</var> as follows:</p>
                                       <olist>
                                          <item>
                                             <p>If <var>U</var> is <termref def="dt-absorption"/>
                                                and <phrase diff="chg" at="R-bug24569">the
                                                  intersection of <var>T</var> with
                                                  <var>U{element(), document-node()}</var> is
                                                  <var>U{}</var> (that is, if <var>T</var> is a type
                                                  that does not allow nodes with children)</phrase>,
                                                then <var>U'</var> is <termref def="dt-inspection"
                                                />.</p>
                                             <note>
                                                <p>This is because the entire subtree of nodes such
                                                  as text nodes is available without reading further
                                                  data from the input stream.</p>
                                             </note>
                                          </item>
                                          <item>
                                             <p>Otherwise, <var>U'</var> is <var>U</var>.</p>
                                          </item>
                                       </olist>
                                    </item>
                                    <item>
                                       <p>Compute the adjusted <termref def="dt-sweep"/>
                                          <var>S'</var> from the table below:</p>
                                       <table class="data">
                                          <caption>Computing the Adjusted Sweep of an
                                             Expression</caption>
                                          <thead>
                                             <tr>
                                                <th rowspan="2" colspan="1">Posture (P)</th>
                                                <th colspan="4" rowspan="1">Adjusted Usage (U')</th>
                                             </tr>
                                             <tr>
                                                <th rowspan="1" colspan="1">Absorption</th>
                                                <th rowspan="1" colspan="1">Inspection</th>
                                                <th rowspan="1" colspan="1">Transmission</th>
                                                <th rowspan="1" colspan="1">Navigation</th>
                                             </tr>
                                          </thead>
                                          <tbody>
                                             <tr>
                                                <th rowspan="1" colspan="1">Climbing</th>
                                                <td rowspan="1" colspan="1">Free-ranging</td>
                                                <td rowspan="1" colspan="1"><var>S</var></td>
                                                <td rowspan="1" colspan="1"><var>S</var></td>
                                                <td rowspan="1" colspan="1">Free-ranging</td>
                                             </tr>
                                             <tr>
                                                <th rowspan="1" colspan="1">Striding</th>
                                                <td rowspan="1" colspan="1">Consuming</td>
                                                <td rowspan="1" colspan="1"><var>S</var></td>
                                                <td rowspan="1" colspan="1"><var>S</var></td>
                                                <td rowspan="1" colspan="1">Free-ranging</td>
                                             </tr>
                                             <tr>
                                                <th rowspan="1" colspan="1">Crawling</th>
                                                <td rowspan="1" colspan="1"><phrase diff="chg"
                                                  at="R-bug25185">Consuming</phrase></td>
                                                <td rowspan="1" colspan="1"><var>S</var></td>
                                                <td rowspan="1" colspan="1"><var>S</var></td>
                                                <td rowspan="1" colspan="1">Free-ranging</td>
                                             </tr>
                                          </tbody>
                                       </table>
                                    </item>
                                 </olist>
                              </item>
                           </olist>
                        </item>
                        <item diff="add" at="Q">
                           <p><termdef id="dt-potentially-consuming" term="potentially consuming"
                                 open="true">An <termref def="dt-operand"/> is <term>potentially
                                    consuming</term> if at least one of the following conditions
                                 applies:</termdef></p>
                           <olist>
                              <item>
                                 <p>The operand’s adjusted <termref def="dt-sweep"/>
                                    <var>S'</var> is <termref def="dt-consuming"/>.</p>
                              </item>
                              <item>
                                 <p>The <termref def="dt-operand-usage"/> is <termref
                                       def="dt-transmission"/> and the operand is not <termref
                                       def="dt-grounded"/>.</p>
                              </item>
                           </olist>
                           <p role="closetermdef"/>
                        </item>
                     </olist>
                  </item>
                  <item>
                     <p>Having computed the adjusted sweep <var>S'(o)</var> of each <termref
                           def="dt-operand"/>
                        <var>o</var>, the <termref def="dt-posture"/> and <termref def="dt-sweep"
                           >sweep</termref> of <var>C</var> are the first of the following that
                        applies:</p>
                     <olist>
                        <item>
                           <p>If <var>C</var> has no operands, then <termref def="dt-grounded"/> and
                                 <termref def="dt-motionless"/>.</p>
                        </item>
                        <item>
                           <p>If any operand <var>o</var> has an adjusted sweep <var>S'(o)</var> of
                                 <termref def="dt-free-ranging"/>, then <termref def="dt-roaming"/>
                              and <termref def="dt-free-ranging"/>.</p>
                        </item>
                        <item>
                           <p>If more than one operand <phrase diff="chg" at="Q">is <termref
                                    def="dt-potentially-consuming"/></phrase>, then:</p>
                           <olist>
                              <item diff="chg" at="P">
                                 <p>If all these operands form part of a <termref
                                       def="dt-choice-operand-group"/>, then the <termref
                                       def="dt-posture"/> of <var>C</var> is the <termref
                                       def="dt-combined-posture"/> of the operands in this group,
                                    and the <termref def="dt-sweep"/> of <var>C</var> is the widest
                                       <termref def="dt-sweep"/> of the operands in this group</p>
                              </item>
                              <item diff="add" at="S-bug27668">
                                 <p>If all these operands have <var>S'</var> = <termref
                                       def="dt-motionless"/>, (which necessarily means they have
                                       <var>U'</var> = <var>U</var> = <termref def="dt-transmission"
                                    />) and if they all have the same <termref def="dt-posture"/>
                                    <var>P0</var>, then <termref def="dt-motionless"/> with <termref
                                       def="dt-posture"/>
                                    <var>P0</var>.</p>
                                 <note>
                                    <p>For example, the expression <code>(@a, @b)</code> is
                                       motionless and striding.</p>
                                 </note>
                              </item>
                              <item>
                                 <p>Otherwise, <termref def="dt-roaming"/> and <termref
                                       def="dt-free-ranging"/>.</p>
                              </item>
                           </olist>
                        </item>
                        <item>
                           <p>If exactly one operand <var>o</var>
                              <phrase diff="chg" at="Q">is <termref def="dt-potentially-consuming"
                                 /></phrase>, then:</p>
                           <olist>
                              <item diff="add" at="Q">
                                 <p>If <var>o</var> is a <termref def="dt-higher-order-operand"/> of
                                       <var>C</var>, then <termref def="dt-roaming"/> and <termref
                                       def="dt-free-ranging"/>.</p>
                              </item>
                              <item diff="add" at="Q">
                                 <p>If the <termref def="dt-operand-usage"/> of <var>o</var> is
                                       <termref def="dt-absorption"/> or <termref
                                       def="dt-inspection"/>, then <termref def="dt-grounded"/> and
                                       <termref def="dt-consuming"/>.</p>
                              </item>
                              <item diff="add" at="Q">
                                 <p>If the <termref def="dt-posture"/> of <var>o</var> is <termref
                                       def="dt-crawling"/> and <var>C</var> is a function call of a
                                       <phrase diff="add" at="R-bug25679">built-in</phrase> function
                                    whose signature indicates a return type with a maximum
                                    cardinality of one then <termref def="dt-striding"/> and the
                                    adjusted <termref def="dt-sweep"/> of <var>o</var>.</p>
                                 <note>
                                    <p diff="add" at="R-bug24501">Although this rule is written in
                                       general terms, the only functions that it applies to (at the
                                       time of publication) are <xfunction>head</xfunction>,
                                          <xfunction>exactly-one</xfunction>, and
                                          <xfunction>zero-or-one</xfunction>. This rule only applies
                                       if the argument usage is transmission (other cases having
                                       been handled by earlier rules); of the built-in functions,
                                       the three functions listed are the only ones having an
                                       argument with usage transmission and a return type with
                                       maximum cardinality one.</p>
                                 </note>
                              </item>
                              <item>
                                 <p>Otherwise (the <termref def="dt-operand-usage"/> of <var>o</var>
                                    is <termref def="dt-transmission"/>), the <termref
                                       def="dt-posture"/> and adjusted <termref def="dt-sweep"/> of
                                       <var>o</var>.</p>
                              </item>
                           </olist>
                        </item>
                        <item>
                           <p diff="add" at="Q">Otherwise (all operands are <termref
                                 def="dt-motionless"/>) <termref def="dt-grounded"/> and <termref
                                 def="dt-motionless"/>.</p>
                        </item>
                     </olist>
                  </item>
               </olist>
               <note>
                  <p>The rules ensure that if more than one <termref def="dt-operand"/> is <termref
                        def="dt-consuming"/>, that is, if more than one operand reads the subtree of
                     the context node in a way that would cause the current position of the input
                     stream to change, then the construct is not streamable.</p>
                  <p>The rules also prevent multiple streamed nodes being returned in the result of
                     an expression <phrase diff="chg" at="S-bug27051">if they are delivered by
                        different operands</phrase>. For example, the expression <code>count((..,
                        *))</code> is not guaranteed streamable. This is to make static analysis
                     possible: the posture needs to be statically determined to ensure that
                     streaming does not fail at execution time. It is permitted, however, for
                     streamed nodes to be mixed in a sequence with non-streamed nodes or with atomic
                     values; in this case the posture of the result will be that of the streamed
                     nodes. <phrase diff="chg" at="S-bug27051">It is also permitted to have multiple
                        operands delivering streamed nodes in different branches of a conditional,
                        provided the sweep and posture are compatible: for example <code>if (X) then
                           @name else name</code> is guaranteed streamable</phrase>.</p>
                  <p diff="add" at="T-bug29507">Expressions that have more than one operand with
                     usage <termref def="dt-transmission"/>, for example <code>(A, B)</code>, or
                        <code>(A | B)</code>, or <code>insert-before(A, n, B)</code>, generally
                     allow only one of these operands to select streamed nodes. The result of the
                     expression will contain a mixture of streamed and grounded nodes, but its
                     posture and sweep will be that of the streamed operand. The nodes in the result
                     will not necessarily be in document order, but the subset of the nodes that are
                     streamed will always be in document order.</p>
               </note>
            </div3>
            <div3 id="general-streamability-examples">
               <head>Examples of the General Streamability Rules</head>
               <p>This section provides some examples of how the general streamability rules
                  operate. In each example, the emphasis is on the outermost construct shown;
                  explanations for how the sweep and posture of its operands are derived are not
                  given, though in many cases they are explained in earlier examples.</p>
               <p>The examples assume that the context item type for evaluation of the expression
                  shown is an element node, and that its posture is striding.</p>
               <ulist>
                  <item>
                     <p><code>2 + 2</code> is grounded and motionless, because both the operands are
                        grounded and motionless.</p>
                  </item>
                  <item>
                     <p><code>price * 2</code> is grounded and consuming, because one of the
                        operands is consuming and the relevant operand usage is absorption.</p>
                  </item>
                  <item>
                     <p><code>price - discount</code> is roaming and free-ranging, because both the
                        operands are consuming (and they are not members of a parallel operand
                        group).</p>
                  </item>
                  <item>
                     <p><code>price * @discount</code> is grounded and consuming. The <phrase
                           diff="chg" at="R-bug24536">left-hand</phrase> operand is consuming and
                        the corresponding operand usage is absorption, while the <phrase diff="chg"
                           at="R-bug24536">right-hand</phrase> operand is motionless, again with an
                        operand usage of absorption, and its item type is <code>attribute()</code>
                        which changes the effective usage to inspection.</p>
                  </item>
                  <item>
                     <p><code>a/b/c</code> is striding and consuming. This is determined not by the
                        general streamability rules, but by the rules for path expressions in
                           <specref ref="streamability-of-path-expressions"/>.</p>
                  </item>
                  <item>
                     <p><code>a//c</code> is crawling and consuming. This is similarly determined by
                        the rules for path expressions in <specref
                           ref="streamability-of-path-expressions"/>.</p>
                  </item>
                  <item>
                     <p><code>count(a/b/c)</code> is grounded and consuming, because the operand
                        (the argument to the count function) is striding and consuming (see earlier
                        example) and the operand usage is inspection.</p>
                  </item>
                  <item>
                     <p><code>sum(a/b/c)</code> is grounded and consuming, because the operand (the
                        argument to the <phrase diff="chg" at="R-bug25327"><code>sum</code></phrase>
                        function) is striding and consuming (see earlier example) and the operand
                        usage is absorption.</p>
                  </item>
                  <item>
                     <p><code diff="chg" at="R-bug25185">count(descendant::c)</code> is grounded and
                        consuming, because the operand (the argument to the <code>count</code>
                        function) is crawling and consuming (see earlier example) and the operand
                        usage is inspection.</p>
                  </item>
                  <item>
                     <p><code diff="chg" at="R-bug25327">tail(descendant::c)</code> is crawling and
                        consuming. The operand is crawling, the operand usage is transmission, so
                        the posture and sweep of the result are the same as the posture and sweep of
                        the consuming operand.</p>
                  </item>
                  <item>
                     <p><code diff="chg" at="R-bug25327">unordered(a|b)</code> is crawling and
                        consuming. The operand (the argument to the <code>unordered</code> function)
                        is crawling (see <specref ref="streamability-of-union-expressions"/>), and
                        the operand usage is transmission, so the posture and sweep of the result
                        are the same as the posture and sweep of the consuming operand.</p>
                  </item>
                  <item>
                     <p><code diff="chg" at="R-bug25327">zero-or-one(descendant::c)</code> is
                        striding and consuming. Although the operand is crawling, the operand usage
                        is transmission and the cardinality of the expression is zero or one, so the
                        posture of the result is striding. The same analysis applies to
                           <code>exactly-one(descendant::c)</code> and to
                           <code>head(descendant::c)</code>.</p>
                  </item>
                  <item>
                     <p diff="chg" at="R-bug25185"><code>sum(descendant::c)</code> is grounded and
                        consuming, because the operand (the argument to the <code>sum</code>
                        function) is crawling and consuming (see earlier example) and the operand
                        usage is absorption. In theory (although it is unlikely in practice) the
                        selected <code>c</code> elements might <phrase diff="chg" at="R-bug24290">be
                           nested one inside another</phrase>. The processor is expected to handle
                        this situation, which may require some buffering. For example, given the
                        untyped source document
                           <code>&lt;a&gt;&lt;c&gt;&lt;c&gt;1&lt;/c&gt;&lt;c&gt;2&lt;/c&gt;&lt;c&gt;3&lt;/c&gt;&lt;/c&gt;&lt;/a&gt;</code>,
                        the result of the expression is <code>129</code> (123 + 1 + 2 + 3), and to
                        evaluate this, a streaming processor will typically maintain a stack of
                        buffers to accumulate the typed values of each of the four <code>c</code>
                        elements during a single pass of the source document. </p>
                  </item>
                  <item>
                     <p><code>"Q{" || namespace-uri(.) || "}" || local-name(.)</code> is grounded
                        and motionless. The two literal operands are grounded and motionless because
                        they have no operands; the two function calls are grounded and motionless
                        because they have a single operand that is striding and motionless, with an
                        operand usage of inspection.</p>
                  </item>
                  <item>
                     <p><code>copy-of(.)/head/following-sibling::*</code> is grounded and consuming.
                        The <phrase diff="chg" at="R-bug24536">left-hand</phrase> operand
                           <code>copy-of(.)/head</code> is grounded and consuming because, under the
                        rules in <specref ref="streamability-of-path-expressions"/>, its <phrase
                           diff="chg" at="R-bug24536">left-hand</phrase> operand
                           <code>copy-of(.)</code> is grounded and consuming. This in turn is
                        because <code>.</code> is striding and motionless, and the operand usage is
                        absorption.</p>
                  </item>
                  <item diff="del" at="S-bug27051">
                     <p><code>distinct-values((., @code))</code> is roaming and free-ranging.
                        Although it is not difficult to identify a strategy for evaluating this in a
                        streaming manner, the static analysis rules make an expression free-ranging
                        if it has two operands with different posture. This is because in general
                        this prevents streamability being determined statically.</p>
                  </item>
                  <item>
                     <p><code>if ($discounted) then price else discounted-price</code> is striding
                        and consuming, because the two branches of the conditional are both striding
                        and consuming, and they form a <termref def="dt-choice-operand-group"/> with
                        usage transmission.</p>
                  </item>
                  <item>
                     <p><code>if ($gratis) then 0 else price</code> is striding and consuming
                        because there is only one consuming operand (the fact that it is part of a
                           <termref def="dt-choice-operand-group"/> does not affect the
                        reasoning).</p>
                  </item>
                  <item diff="add" at="Q">
                     <p><code>count((author, editor))</code> is roaming and free-ranging. The first
                        argument to the <code>count</code> function is an expression with two
                        operands, both having usage=transmission, and neither being grounded.</p>
                  </item>
                  <item diff="add" at="Q">
                     <p><code>count((author | editor))</code> is grounded and consuming. A union
                        expression is not subject to the general streamability rules; it has its own
                        rules, defined in <specref ref="streamability-of-union-expressions"/>, which
                        establish in this case that the argument to the <xfunction>count</xfunction>
                        is <termref def="dt-crawling"/> and <termref def="dt-consuming"/>. The
                           <xfunction>count</xfunction> function does follow the general
                        streamability rules, with an operand usage of <termref def="dt-inspection"
                        />: under rule 1(b)(iii)(B) the adjusted sweep is <termref
                           def="dt-consuming"/>, and rule 2(d)(iii) then applies.</p>
                  </item>
                  <item diff="add" at="Q">
                     <p><code>('{', author, '}')</code> is striding and consuming. Exactly one
                        operand is consuming; it has usage <termref def="dt-transmission"/>, so the
                        result has the posture and sweep of that operand. (The formal analysis
                        treats comma as a binary operator, but the same result can be obtained by
                        treating the content of the parenthesized expression as an expression with
                        three operands.)</p>
                  </item>
               </ulist>
            </div3>
            <div3 id="classifying-sequence-constructors">
               <head>Classifying Sequence Constructors</head>
               <p>The <termref def="dt-posture"/> and <termref def="dt-sweep">sweep</termref> of a
                     <termref def="dt-sequence-constructor"/> are determined by the <termref
                     def="dt-general-streamability-rules"/>.</p>
               <p>The <termref def="dt-operand-role">operand roles</termref> and their <phrase
                     diff="add" at="R-bug24504"><termref def="dt-operand-usage"
                     >usages</termref></phrase> are:</p>
               <olist>
                  <item>
                     <p>The <phrase diff="add" at="R-bug24504">immediately</phrase> contained
                           <termref def="dt-instruction">instructions</termref>
                        <phrase diff="add" at="S-bug27189">and <termref
                              def="dt-literal-result-element">literal result elements</termref>,
                           including any <elcode>xsl:on-empty</elcode> or
                              <elcode>xsl:on-non-empty</elcode> instructions.</phrase> The <termref
                           def="dt-operand-usage"/> for these operands is <termref
                           def="dt-transmission"/>.</p>
                  </item>
                  <item>
                     <p>Any <termref def="dt-text-value-template">text value templates</termref>
                        appearing in text nodes within the sequence constructor, if text value
                        templates are enabled. The <termref def="dt-operand-usage"/> for these
                        operands is <termref def="dt-absorption"/>.</p>
                  </item>
               </olist>
               <note>
                  <p>Some consequences of these rules are:</p>
                  <olist>
                     <item>
                        <p>An empty sequence constructor is <termref def="dt-motionless"/>, and its
                              <termref def="dt-posture"/> is <termref def="dt-grounded"/>.</p>
                     </item>
                     <item>
                        <p>A sequence constructor containing a single instruction has the same
                              <termref def="dt-sweep"/> and <termref def="dt-posture"/> as that
                           instruction. (This means that sequence constructors containing a single
                           instruction can usefully be dropped from the construct tree.)</p>
                     </item>
                     <item>
                        <p>Informally, a sequence constructor is not streamable if it contains more
                           than one instruction that moves the position of the input stream.</p>
                     </item>
                     <item diff="add" at="S-bug27189">
                        <p><elcode>xsl:on-empty</elcode> or <elcode>xsl:on-non-empty</elcode>
                           instructions are not treated specially. For example, there is no attempt
                           to take into account that they are mutually exclusive: if one is
                           evaluated, the other will not be evaluated. In most use cases for these
                           instructions, they will be motionless, so the additional complexity of
                           doing more advanced analysis would rarely be justified.</p>
                     </item>
                  </olist>
               </note>
               <p diff="del" at="S-bug27275">Instructions within a sequence constructor are further
                  classified to control the use of <termref def="dt-accumulator-function"
                     >accumulator functions</termref>......</p>
            </div3>
            <div3 id="classifying-instructions">
               <head>Classifying Instructions</head>
               <p>This section describes how <termref def="dt-instruction">instructions</termref>
                  are classified with respect to their streamability. The criteria are given first
                  for <termref def="dt-literal-result-element">literal result elements</termref> and
                     <termref def="dt-extension-instruction">extension instructions</termref>,, then
                  for each XSLT instruction, listed alphabetically.</p>
               <div4 id="streamability-literal-result-elements">
                  <head>Streamability of Literal Result Elements</head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of a <termref
                        def="dt-literal-result-element"/> follow the <termref
                        def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role"
                        >operand roles</termref> and their <termref def="dt-operand-usage"
                        >usages</termref> are:</p>
                  <olist>
                     <item>
                        <p>The contained sequence constructor (usage <termref def="dt-absorption"
                           />)</p>
                     </item>
                     <item>
                        <p>Any expressions contained in <termref def="dt-attribute-value-template"
                              >attribute value templates</termref> among the literal result
                           element’s attributes (usage <termref def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>Any <termref def="dt-attribute-set">attribute sets</termref> named in the
                              <code>xsl:use-attribute-sets</code> attribute <phrase diff="chg"
                              at="T-bug29492">(usage irrelevant, but can be taken as <termref
                                 def="dt-inspection"/>)</phrase>.</p>
                        <note diff="add" at="T-bug29492">
                           <p>In practice, a reference to an attribute set that is <termref
                                 def="dt-declared-streamable"/> does not affect the analysis, while
                              a reference to any other attribute set makes the literal result
                              element <termref def="dt-roaming"/> and <termref def="dt-free-ranging"
                              />.</p>
                        </note>
                     </item>
                  </olist>
               </div4>
               <div4 id="streamability-extension-instructions" diff="add" at="Q">
                  <head>Streamability of extension instructions</head>
                  <p>For a processor that recognizes an <termref def="dt-extension-instruction"/>,
                     the <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the
                     instruction are <termref def="dt-implementation-defined"/>.</p>
                  <imp-def-feature id="idf-ext-streamability">The <termref def="dt-posture"/> and
                        <termref def="dt-sweep"/> of <termref def="dt-extension-function">extension
                        functions (and references to extension functions)</termref> and <termref
                        def="dt-extension-instruction">extension instructions</termref> are <termref
                        def="dt-implementation-defined"/>.</imp-def-feature>
                  <p>For a processor that does not recognize an <termref
                        def="dt-extension-instruction"/>, the <termref def="dt-posture"/> and
                        <termref def="dt-sweep"/> of the instruction are determined by applying the
                        <termref def="dt-general-streamability-rules"/>, The <termref
                        def="dt-operand-role">operand roles</termref> and their <termref
                        def="dt-operand-usage">usages</termref> are:</p>
                  <olist>
                     <item>
                        <p>The <termref def="dt-sequence-constructor">sequence
                              constructors</termref> contained in any <elcode>xsl:fallback</elcode>
                           children (usage <termref def="dt-transmission"/>)</p>
                     </item>
                  </olist>
                  <p>Instructions in the XSLT namespace that are present under the provisions for
                        <termref def="dt-forwards-compatible-behavior"/> are treated in the same way
                     as unrecognized extension instructions.</p>
                  <note>
                     <p>These rules mean that if there is no <elcode>xsl:fallback</elcode> child
                        instruction, the containing construct will be classified as streamable.
                        However, any attempt to execute the instruction will lead to a dynamic
                        error, so in fact, neither streamed nor unstreamed evaluation is
                        possible.</p>
                  </note>
               </div4>
               <div4 id="streamability-xsl-analyze-string">
                  <head>Streamability of <elcode>xsl:analyze-string</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:analyze-string</elcode> follow the <termref
                        def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role"
                        >operand roles</termref> and their <termref def="dt-operand-usage"
                        >usages</termref> are:</p>
                  <olist>
                     <item>
                        <p>the <code>select</code> expression (usage <termref def="dt-absorption"
                           />);</p>
                     </item>
                     <item>
                        <p>the <code>regex</code> attribute value template (usage <termref
                              def="dt-absorption"/>);</p>
                     </item>
                     <item>
                        <p>the sequence constructors contained in the
                              <elcode>xsl:matching-substring</elcode> and
                              <elcode>xsl:non-matching-substring</elcode> elements. These have usage
                              <termref def="dt-navigation"/>, because they can be evaluated more
                           than once. The <phrase diff="chg" at="Q"><termref
                                 def="dt-context-posture"/></phrase> for the two sequence
                           constructors is <termref def="dt-grounded"/>, reflecting the fact that
                           their context item type is <code>xs:string</code>.</p>
                     </item>
                  </olist>
                  <note>
                     <p diff="add" at="Q">In practice, the <termref def="dt-sweep"/> of the
                        instruction will usually be the same as the sweep of the <code>select</code>
                        expression, and its <termref def="dt-posture"/> will be <termref
                           def="dt-grounded"/>. Exceptions occur for example if the
                           <code>regex</code> attribute is not <termref def="dt-motionless"/>, or if
                        the contained sequence constructors refer to a grouping variable bound in a
                        contained <elcode>xsl:for-each-group</elcode> instruction.</p>
                  </note>
               </div4>
               <div4 id="streamability-xsl-apply-imports">
                  <head>Streamability of <elcode>xsl:apply-imports</elcode></head>
                  <p>The rules in this section apply also to <elcode>xsl:next-match</elcode>.</p>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of these two
                     instructions follow the <termref def="dt-general-streamability-rules"/>. The
                        <termref def="dt-operand-role">operand roles</termref> and their <termref
                        def="dt-operand-usage">usages</termref> are:</p>
                  <olist>
                     <item>
                        <p>An implicit operand: a context item expression (<code>.</code>), with
                           usage <termref def="dt-absorption"/>;</p>
                     </item>
                     <item>
                        <p>The <code>select</code> attribute or contained <termref
                              def="dt-sequence-constructor"/> of each
                              <elcode>xsl:with-param</elcode> child element, with <termref
                              def="dt-type-determined-usage"/> based on the type declared in the
                              <code>xsl:with-param/@as</code> attribute, or <code>item()*</code> if
                           absent.</p>
                     </item>
                  </olist>
                  <note diff="add" at="Q">
                     <p>The instruction will normally be <termref def="dt-grounded"/> and <termref
                           def="dt-consuming"/>, provided that nodes in a streamed document are not
                        passed as parameters to the called template rule.</p>
                  </note>
               </div4>
               <div4 id="streamability-xsl-apply-templates" diff="chg" at="Q">
                  <head>Streamability of <elcode>xsl:apply-templates</elcode></head>
                  <p diff="add" at="Q">If there is no <code>select</code> attribute, the following
                     analysis assumes the presence of an implicit operand
                        <code>select="child::node()"</code>.</p>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the
                        <elcode>xsl:apply-templates</elcode> instruction are the first of the
                     following that apply:</p>
                  <olist>
                     <item>
                        <p>If the <code>select</code> expression is <termref def="dt-grounded"/>,
                           then the <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the
                              <elcode>xsl:apply-templates</elcode> instruction follow the <termref
                              def="dt-general-streamability-rules"/>, with the <termref
                              def="dt-operand-role">operand roles</termref> and their <termref
                              def="dt-operand-usage">usages</termref> as follows:</p>
                        <olist>
                           <item>
                              <p>The <code>select</code> expression (the <termref
                                    def="dt-operand-usage"/> is irrelevant, but can be taken as
                                    <termref def="dt-absorption"/>)</p>
                           </item>
                           <item>
                              <p>The <code>select</code> expressions and contained sequence
                                 constructors of any child <elcode>xsl:with-param</elcode> elements
                                 (usage <termref def="dt-type-determined-usage"
                                    >type-determined</termref>, based on the type in the
                                    <code>xsl:with-param/@as</code> attribute, defaulting to
                                    <code>item()*</code>)</p>
                           </item>
                           <item>
                              <p>Any attribute value templates appearing in attributes of a child
                                    <elcode>xsl:sort</elcode> instruction (usage <termref
                                    def="dt-absorption"/>)</p>
                           </item>
                           <item>
                              <p>The <code>select</code> expression or contained sequence
                                 constructor of any <elcode>xsl:sort</elcode> children, assessed
                                 with a <termref def="dt-context-posture"/> of <termref
                                    def="dt-grounded"/> (usage <termref def="dt-absorption"/>).</p>
                           </item>
                        </olist>
                        <p>For example, <code>&lt;xsl:apply-templates
                              select="copy-of(.)"/&gt;</code> is <termref def="dt-grounded"/> and
                              <termref def="dt-consuming"/>.</p>
                     </item>
                     <item>
                        <p>If there is an <elcode>xsl:sort</elcode> child element, then <termref
                              def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p>If the implicit or explicit <code>mode</code> attribute identifies a
                              <termref def="dt-mode">mode</termref> that is not declared with
                              <code>streamable="yes"</code><phrase diff="del" at="Q">, or if
                                 <code>mode="#current"</code> is specified</phrase>, then <termref
                              def="dt-roaming"/> and <termref def="dt-free-ranging"/>. </p>
                        <note diff="add" at="Q">
                           <p>When <code>mode="#current"</code> is specified, this is treated as
                              equivalent to specifying a streamable mode; although it is not known
                              statically what the mode will be, it is always the case that if the
                              template is invoked with a streamed node as the context item, then the
                              current mode must be a streamable mode.</p>
                        </note>
                     </item>
                     <item diff="add" at="R-bug25185">
                        <p>If the <code>select</code> expression is <termref def="dt-climbing"/> or
                              <termref def="dt-crawling"/>, then <termref def="dt-roaming"/> and
                              <termref def="dt-free-ranging"/></p>
                     </item>
                     <item>
                        <p>Otherwise, the <termref def="dt-posture"/> and <termref def="dt-sweep"/>
                           of the <elcode>xsl:apply-templates</elcode> instruction follow the
                              <termref def="dt-general-streamability-rules"/>. The <termref
                              def="dt-operand-role">operand roles</termref> and their <termref
                              def="dt-operand-usage">usages</termref> are as follows:</p>
                        <olist>
                           <item>
                              <p>The (explicit or implicit) <code>select</code> expression, with
                                 usage <termref def="dt-absorption"/>; </p>
                           </item>
                           <item>
                              <p>The <code>select</code> attribute or contained <termref
                                    def="dt-sequence-constructor"/> of each
                                    <elcode>xsl:with-param</elcode> child element, with <termref
                                    def="dt-type-determined-usage"/> based on the type declared in
                                 the <code>xsl:with-param/@as</code> attribute, or
                                    <code>item()*</code> if absent.</p>
                           </item>
                        </olist>
                     </item>
                  </olist>
               </div4>
               <div4 id="streamability-xsl-assert">
                  <head>Streamability of <elcode>xsl:assert</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:assert</elcode> follow the <termref
                        def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role"
                        >operand roles</termref> and their <termref def="dt-operand-usage"
                        >usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>test</code> expression (usage <termref def="dt-inspection"
                           />)</p>
                     </item>
                     <item>
                        <p>The <code>select</code> expression (usage <termref def="dt-absorption"
                           />)</p>
                     </item>
                     <item diff="add" at="R-bug24527">
                        <p>The <code>error-code</code> attribute value template (usage <termref
                              def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The contained <termref def="dt-sequence-constructor"/> (usage <termref
                              def="dt-absorption"/>).</p>
                     </item>
                  </olist>
               </div4>
               <div4 id="streamability-xsl-attribute">
                  <head>Streamability of <elcode>xsl:attribute</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:attribute</elcode> follow the <termref
                        def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role"
                        >operand roles</termref> and their <termref def="dt-operand-usage"
                        >usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>name</code> attribute value template (usage <termref
                              def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The <code>namespace</code> attribute value template (usage <termref
                              def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The <code>select</code> expression (usage <termref def="dt-absorption"
                           />)</p>
                     </item>
                     <item>
                        <p>The <code>separator</code> attribute value template (usage <termref
                              def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The contained <termref def="dt-sequence-constructor"/> (usage <termref
                              def="dt-absorption"/>).</p>
                     </item>
                  </olist>
               </div4>
               <div4 id="streamability-xsl-break">
                  <head>Streamability of <elcode>xsl:break</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:break</elcode> follow the <termref
                        def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role"
                        >operand roles</termref> and their <termref def="dt-operand-usage"
                        >usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>select</code> expression (usage <termref def="dt-transmission"
                           />)</p>
                     </item>
                     <item>
                        <p>The contained <termref def="dt-sequence-constructor"/> (usage <termref
                              def="dt-transmission"/>).</p>
                     </item>
                  </olist>
               </div4>
               <div4 id="streamability-xsl-call-template">
                  <head>Streamability of <elcode>xsl:call-template</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:call-template</elcode> follow the <termref
                        def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role"
                        >operand roles</termref> and their <termref def="dt-operand-usage"
                        >usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>Unless the referenced template has a child
                              <elcode>xsl:context-item</elcode> element with the attribute
                              <code>use="prohibited"</code>, there is an implicit operand, a context
                           item expression (<code>.</code>): its <termref def="dt-operand-usage"/>
                           is the <termref def="dt-type-determined-usage"/> based on the type
                           declared in the <code>xsl:context-item/@as</code> attribute of the target
                           named template, defaulting to <code>item()*</code> if absent.</p>
                     </item>
                     <item>
                        <p>The <code>select</code> expression or sequence constructor content of any
                           contained <elcode>xsl:with-param</elcode> child element: its <termref
                              def="dt-operand-usage"/> is the <termref
                              def="dt-type-determined-usage"/> based on the type declared in the
                              <code>xsl:with-param/@as</code> attribute, or the
                              <code>xsl:param/@as</code> attribute of the corresponding parameter on
                           the target named template, whichever is more restrictive, defaulting to
                              <code>item()*</code> if both are absent.</p>
                     </item>
                  </olist>
                  <note>
                     <p>Calling <elcode>xsl:call-template</elcode> will usually make stylesheet code
                        unstreamable if a streamed node is passed explicitly or implicitly to the
                        called template, unless it is atomized by declaring the expected type to be
                        atomic.</p>
                  </note>
               </div4>
               <div4 id="streamability-xsl-choose">
                  <head>Streamability of <elcode>xsl:choose</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:choose</elcode> follow the <termref
                        def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role"
                        >operand roles</termref> and their <termref def="dt-operand-usage"
                        >usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>test</code> attribute of contained <elcode>xsl:when</elcode>
                           elements (usage <termref def="dt-inspection"/>).</p>
                     </item>
                     <item>
                        <p>The sequence constructors contained within <elcode>xsl:when</elcode> and
                              <elcode>xsl:otherwise</elcode> child elements (usage <termref
                              def="dt-transmission"/>). These sequence constructor operands form a
                              <termref def="dt-choice-operand-group"/>.</p>
                     </item>
                  </olist>
                  <note>
                     <p>The effect is to allow either of the following:</p>
                     <olist>
                        <item>
                           <p>Any or all of the sequence constructors in <elcode>xsl:when</elcode>
                              and <elcode>xsl:otherwise</elcode> branch may be <termref
                                 def="dt-consuming"/>, in which case the <code>test</code>
                              expressions must all be <termref def="dt-motionless"/>.</p>
                        </item>
                        <item>
                           <p diff="chg" at="T-bug30034">Any one of the <code>test</code>
                              expressions may be <termref def="dt-consuming"/>, in which case all
                              the other <code>test</code> expressions, and all the sequence
                              constructors, must be <termref def="dt-motionless"/>.</p>
                        </item>
                     </olist>
                  </note>
               </div4>
               <div4 id="streamability-xsl-comment">
                  <head>Streamability of <elcode>xsl:comment</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:comment</elcode> follow the <termref
                        def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role"
                        >operand roles</termref> and their <termref def="dt-operand-usage"
                        >usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>select</code> expression (usage <termref def="dt-absorption"
                           />)</p>
                     </item>
                     <item>
                        <p>The contained <termref def="dt-sequence-constructor"/> (usage <termref
                              def="dt-absorption"/>).</p>
                     </item>
                  </olist>
               </div4>
               <div4 id="streamability-xsl-copy">
                  <head>Streamability of <elcode>xsl:copy</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:copy</elcode> follow the <termref
                        def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role"
                        >operand roles</termref> and their <termref def="dt-operand-usage"
                        >usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The expression in the <code>select</code> attribute, defaulting to a
                           context item expression (<code>.</code>) (usage <termref
                              def="dt-inspection"/>)</p>
                     </item>
                     <item>
                        <p>The contained sequence constructor (usage <termref def="dt-absorption"
                           />), assessed with <termref def="dt-context-posture"/> and context item
                           type based on the <code>select</code> expression if present, or the outer
                           focus otherwise.</p>
                     </item>
                     <item>
                        <p>Any <termref def="dt-attribute-set">attribute sets</termref> named in the
                              <code>use-attribute-sets</code> attribute <phrase diff="chg"
                              at="T-bug29492">(usage irrelevant, but can be taken as <termref
                                 def="dt-inspection"/>)</phrase>.</p>
                        <note diff="add" at="T-bug29492">
                           <p>In practice, a reference to an attribute set that is <termref
                                 def="dt-declared-streamable"/> does not affect the analysis, while
                              a reference to any other attribute set makes the
                                 <elcode>xsl:copy</elcode> instruction <termref def="dt-roaming"/>
                              and <termref def="dt-free-ranging"/>.</p>
                        </note>
                     </item>
                     <item diff="del" at="S-bug27189">
                        <p>The expression contained in the <code>on-empty</code> attribute, if
                           present (usage <termref def="dt-absorption"/>).</p>
                     </item>
                  </olist>
                  <note diff="add" at="T-bug29482">
                     <p>The effect of these rules is that when a <code>select</code> attribute is
                        present, the sequence constructor contained by the <elcode>xsl:copy</elcode>
                        instruction is deemed to be a <termref def="dt-higher-order-operand"/> of
                        the instruction, even though it can only be evaluated once.</p>
                     <p>This has the practical consequence that the following example is not
                           <termref def="dt-guaranteed-streamable"/>, even though it is possible to
                        imagine a strategy for streamed evaluation:</p>
                     <eg role="xslt-instruction" xml:space="preserve">
 &lt;xsl:for-each-group select="product" group-adjacent="@category"&gt;
     &lt;xsl:copy select=".."&gt;
         &lt;xsl:copy-of select="current-group()"/&gt;
     &lt;/xsl:copy&gt;
 &lt;/xsl:for-each-group&gt;</eg>
                     <p>A workaround in this case might be to rewrite the code as follows:</p>
                     <eg role="xslt-instruction" xml:space="preserve">
 &lt;xsl:for-each-group select="product" group-adjacent="@category"&gt;
     &lt;xsl:element name="{name(..)}" namespace-uri="{namespace-uri(..)}"&gt;
         &lt;xsl:copy-of select="current-group()"/&gt;
     &lt;/xsl:element&gt;
 &lt;/xsl:for-each-group&gt;</eg>
                  </note>
               </div4>
               <div4 id="streamability-xsl-copy-of">
                  <head>Streamability of <elcode>xsl:copy-of</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:copy-of</elcode> follow the <termref
                        def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role"
                        >operand roles</termref> and their <termref def="dt-operand-usage"
                        >usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>select</code> expression (usage <termref def="dt-absorption"
                           />).</p>
                     </item>
                  </olist>
               </div4>
               <div4 id="streamability-xsl-document">
                  <head>Streamability of <elcode>xsl:document</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:document</elcode> follow the <termref
                        def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role"
                        >operand roles</termref> and their <termref def="dt-operand-usage"
                        >usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The contained <termref def="dt-sequence-constructor"/> (usage <termref
                              def="dt-absorption"/>).</p>
                     </item>
                  </olist>
               </div4>
               <div4 id="streamability-xsl-element">
                  <head>Streamability of <elcode>xsl:element</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:element</elcode> follow the <termref
                        def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role"
                        >operand roles</termref> and their <termref def="dt-operand-usage"
                        >usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>name</code> attribute value template (usage <termref
                              def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The <code>namespace</code> attribute value template (usage <termref
                              def="dt-absorption"/>)</p>
                     </item>
                     <item diff="del" at="S-bug27189">
                        <p>The <code>on-empty</code> expression (usage <termref def="dt-absorption"
                           />)</p>
                     </item>
                     <item>
                        <p>Any <termref def="dt-attribute-set">attribute sets</termref> named in the
                              <code>use-attribute-sets</code> attribute <phrase diff="chg"
                              at="T-bug29492">(usage irrelevant, but can be taken as <termref
                                 def="dt-inspection"/>)</phrase>.</p>
                        <note diff="add" at="T-bug29492">
                           <p>In practice, a reference to an attribute set that is <termref
                                 def="dt-declared-streamable"/> does not affect the analysis, while
                              a reference to any other attribute set makes the
                                 <elcode>xsl:element</elcode> instruction <termref def="dt-roaming"
                              /> and <termref def="dt-free-ranging"/>.</p>
                        </note>
                     </item>
                     <item>
                        <p>The contained <termref def="dt-sequence-constructor"/> (usage <termref
                              def="dt-absorption"/>).</p>
                     </item>
                  </olist>
               </div4>
               <div4 id="streamability-xsl-evaluate" diff="chg" at="Q">
                  <head>Streamability of <elcode>xsl:evaluate</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:evaluate</elcode> follow the <termref
                        def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role"
                        >operand roles</termref> and their <termref def="dt-operand-usage"
                        >usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>xpath</code> expression (usage <termref def="dt-absorption"
                           />)</p>
                     </item>
                     <item>
                        <p>The <code>context-item</code> expression (usage <termref
                              def="dt-navigation"/>)</p>
                     </item>
                     <item>
                        <p>The <code>with-params</code> expression (usage <termref
                              def="dt-navigation"/>)</p>
                     </item>
                     <item>
                        <p>The <code>base-uri</code> attribute value template (usage <termref
                              def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The <code>namespace-context</code> expression (usage <termref
                              def="dt-inspection"/>)</p>
                     </item>
                     <item diff="add" at="R-bug24522">
                        <p>The <code>schema-aware</code> attribute value template (usage <termref
                              def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The <code>select</code> attributes and contained <termref
                              def="dt-sequence-constructor">sequence constructors</termref> of any
                              <elcode>xsl:with-param</elcode> child elements (usage <termref
                              def="dt-type-determined-usage">type-determined</termref>, based on the
                           type in the <code>xsl:with-param/@as</code> attribute, defaulting to
                              <code>item()*</code>)</p>
                     </item>
                  </olist>
                  <note>
                     <p>In practice, code containing an <elcode>xsl:evaluate</elcode> instruction
                        will usually be streamable provided that streamed nodes are not passed to
                        the dynamic expression either as the context item or as the value of a
                        parameter.</p>
                  </note>
               </div4>
               <div4 id="streamability-xsl-fallback" diff="add" at="R-bug24505">
                  <head>Streamability of <elcode>xsl:fallback</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the
                        <elcode>xsl:fallback</elcode> instruction depend on whether the processor is
                     performing fallback (which is known statically).</p>
                  <p>If the processor is performing fallback, then the <termref def="dt-posture"/>
                     and <termref def="dt-sweep"/> of the <elcode>xsl:fallback</elcode> instruction
                     are the posture and sweep of the contained sequence constructor.</p>
                  <p>If the processor is not performing fallback, then the instruction is <termref
                        def="dt-grounded"/> and <termref def="dt-motionless"/>.</p>
               </div4>
               <div4 id="streamability-xsl-for-each" diff="chg" at="Q">
                  <head>Streamability of <elcode>xsl:for-each</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the
                        <elcode>xsl:for-each</elcode> instruction are the first of the following
                     that applies:</p>
                  <olist>
                     <item>
                        <p>If the <code>select</code> expression is <termref def="dt-grounded"/>,
                           then the <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the
                              <elcode>xsl:for-each</elcode> instruction follow the <termref
                              def="dt-general-streamability-rules"/>, with the <termref
                              def="dt-operand-role">operand roles</termref> and their <termref
                              def="dt-operand-usage">usages</termref> as follows:</p>
                        <olist>
                           <item>
                              <p>The <code>select</code> expression (the <termref
                                    def="dt-operand-usage"/> is irrelevant, but can be taken as
                                    <termref def="dt-inspection"/>)</p>
                           </item>
                           <item>
                              <p>The contained <termref def="dt-sequence-constructor"/> (usage
                                    <termref def="dt-transmission"/>). This is a <termref
                                    def="dt-higher-order-operand">higher-order operand</termref>;
                                 its context posture is <termref def="dt-grounded"/>.</p>
                           </item>
                           <item>
                              <p>Any attribute value templates appearing in attributes of a child
                                    <elcode>xsl:sort</elcode> instruction (usage <termref
                                    def="dt-absorption"/>)</p>
                           </item>
                           <item>
                              <p>The <code>select</code> expression or contained sequence
                                 constructor of any <elcode>xsl:sort</elcode> children, assessed
                                 with a <termref def="dt-context-posture"/> of <termref
                                    def="dt-grounded"/> (usage <termref def="dt-absorption"/>).
                                 These are <termref def="dt-higher-order-operand">higher-order
                                    operands</termref>; their context posture is <termref
                                    def="dt-grounded"/>.</p>
                           </item>
                        </olist>
                     </item>
                     <item>
                        <p>If there is an <elcode>xsl:sort</elcode> child element, then <termref
                              def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p diff="add" at="R-bug25185">If the <termref def="dt-posture"/> of the
                              <code>select</code> expression is <termref def="dt-crawling"/> and the
                              <termref def="dt-sweep"/> of the contained <termref
                              def="dt-sequence-constructor"/> is <termref def="dt-consuming"/>, then
                              <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>. </p>
                     </item>
                     <item>
                        <p>Otherwise:</p>
                        <olist>
                           <item>
                              <p>The <termref def="dt-posture"/> of the instruction is the <termref
                                    def="dt-posture"/> of the contained <termref
                                    def="dt-sequence-constructor"/>, assessed with the <phrase
                                    diff="chg" at="Q"><termref def="dt-context-posture"/></phrase>
                                 and context item type set to the <termref def="dt-posture"/> and
                                 type of the <code>select</code> expression.</p>
                           </item>
                           <item>
                              <p>The <termref def="dt-sweep"/> of the instruction is the wider of
                                 the <termref def="dt-sweep"/> of the <code>select</code> expression
                                 and the <termref def="dt-sweep"/> of the contained <termref
                                    def="dt-sequence-constructor"/>.</p>
                              <note>
                                 <p>The ordering of sweep values is in increasing order: <termref
                                       def="dt-motionless"/>, <termref def="dt-consuming"/>,
                                       <termref def="dt-free-ranging"/>.</p>
                              </note>
                           </item>
                        </olist>
                        <note diff="add" at="S-bug27571">
                           <p>Because the body of the <elcode>xsl:for-each</elcode> instruction is a
                                 <termref def="dt-higher-order-operand"/> of the instruction, any
                              variable reference within the body that is bound to a <termref
                                 def="dt-streaming-parameter"/> of a containing <termref
                                 def="dt-stylesheet-function"/> will not be singular, which in many
                              cases will make the entire function non-streamable.</p>
                        </note>
                     </item>
                  </olist>
               </div4>
               <div4 id="streamability-xsl-for-each-group" diff="chg" at="Q">
                  <head>Streamability of <elcode>xsl:for-each-group</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the
                        <elcode>xsl:for-each-group</elcode> instruction are the first of the
                     following that applies:</p>
                  <olist>
                     <item>
                        <p>If the <code>select</code> expression is <termref def="dt-grounded"/>,
                           then the <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the
                              <elcode>xsl:for-each-group</elcode> instruction follow the <termref
                              def="dt-general-streamability-rules"/>, with the <termref
                              def="dt-operand-role">operand roles</termref> and their <termref
                              def="dt-operand-usage">usages</termref> as follows:</p>
                        <olist>
                           <item>
                              <p>The <code>select</code> expression (the <termref
                                    def="dt-operand-usage"/> is irrelevant, but can be taken as
                                    <termref def="dt-inspection"/>)</p>
                           </item>
                           <item>
                              <p>The <code>collation</code> attribute value template (usage <termref
                                    def="dt-absorption"/>)</p>
                           </item>
                           <item>
                              <p>Any attribute value templates appearing in attributes of a child
                                    <elcode>xsl:sort</elcode> instruction (usage <termref
                                    def="dt-absorption"/>)</p>
                           </item>
                           <item>
                              <p>The <code>group-by</code> or <code>group-adjacent</code>
                                 expression, assessed with a <termref def="dt-context-posture"/> of
                                    <termref def="dt-grounded"/> (usage <termref def="dt-absorption"
                                 />).</p>
                           </item>
                           <item>
                              <p>The <code>select</code> expression or contained sequence
                                 constructor of any <elcode>xsl:sort</elcode> children, assessed
                                 with a <termref def="dt-context-posture"/> of <termref
                                    def="dt-grounded"/> (usage <termref def="dt-absorption"/>).</p>
                           </item>
                           <item>
                              <p diff="add" at="Q">The <code>group-starting-with</code> or
                                    <code>group-ending-with</code> patterns if present; these are
                                    <termref def="dt-higher-order-operand">higher-order
                                    operands</termref> with usage <termref def="dt-inspection"
                                 />.</p>
                           </item>
                        </olist>
                     </item>
                     <item>
                        <p>If there is a <code>group-by</code> attribute <phrase diff="add"
                              at="R-bug24317">and the instruction is not a child of
                                 <elcode>xsl:fork</elcode></phrase>, then <termref def="dt-roaming"
                           /> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p>If there is a <phrase diff="add" at="R-bug24317"><code>group-by</code>
                              or</phrase>
                           <code>group-adjacent</code> attribute that is not <termref
                              def="dt-motionless"/>, then <termref def="dt-roaming"/> and <termref
                              def="dt-free-ranging"/>.</p>
                     </item>
                     <item diff="del" at="Q">
                        <p>If there is a <code>group-starting-with</code> or
                              <code>group-ending-with</code> attribute that is not a <termref
                              def="dt-motionless"/>
                           <termref def="dt-pattern"/>, then <termref def="dt-roaming"/> and
                              <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p>If there is an <elcode>xsl:sort</elcode> child element <phrase diff="add"
                              at="T-bug29502">and the instruction is not a child of
                                 <elcode>xsl:fork</elcode></phrase>, then <termref def="dt-roaming"
                           /> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item diff="del" at="R-bug24510">
                        <p>If there is no <code>bind-group</code> attribute, then <termref
                              def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item diff="del" at="R-bug24510">
                        <p>If there is a <code>group-adjacent</code> attribute but no
                              <code>bind-grouping-key</code> attribute, then <termref
                              def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p diff="add" at="R-bug25185">If the <termref def="dt-posture"/> of the
                              <code>select</code> expression is <termref def="dt-crawling"/> and the
                              <termref def="dt-sweep"/> of the contained <termref
                              def="dt-sequence-constructor"/> is <termref def="dt-consuming"/>, then
                              <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p>Otherwise:</p>
                        <olist>
                           <item>
                              <p>The <termref def="dt-posture"/> of the instruction is the <termref
                                    def="dt-posture"/> of the contained <termref
                                    def="dt-sequence-constructor"/>, assessed with the <phrase
                                    diff="chg" at="Q"><termref def="dt-context-posture"/></phrase>
                                 and context item type set to the <termref def="dt-posture"/> and
                                 type of the <code>select</code> expression.</p>
                           </item>
                           <item>
                              <p>The <termref def="dt-sweep"/> of the instruction is the wider of
                                 the <termref def="dt-sweep">sweeps</termref> of the
                                    <code>select</code> expression and the contained <termref
                                    def="dt-sequence-constructor"/>, where the ordering of
                                 increasing width is <termref def="dt-motionless"/>, <termref
                                    def="dt-consuming"/>, <termref def="dt-free-ranging"/>.</p>
                           </item>
                        </olist>
                        <note diff="add" at="S-bug27571">
                           <p>Because the body of the <elcode>xsl:for-each-group</elcode>
                              instruction is a <termref def="dt-higher-order-operand"/> of the
                              instruction, any variable reference within the body that is bound to a
                                 <termref def="dt-streaming-parameter"/> of a containing <termref
                                 def="dt-stylesheet-function"/> will not be singular, which in many
                              cases will make the entire function non-streamable.</p>
                        </note>
                     </item>
                  </olist>
                  <note>
                     <p diff="del" at="R-bug24510">The above rules do not explicitly mention any
                        constraints on the presence or absence of a variable reference to the
                        variable bound in the <code>bind-group</code> attribute of the
                           <elcode>xsl:for-each-group</elcode> instruction. In practice, however,
                        this plays an important role. In the most common case, the
                           <code>select</code> expression of <elcode>xsl:for-each-group</elcode> is
                        likely to be <termref def="dt-striding"/>, for example an expression that
                        selects all the children of a given element. If the instruction binds a
                        variable <code>$group</code> using the <code>bind-group</code> attribute,
                        then any reference to this variable will ordinarily be <termref
                           def="dt-striding"/> and <termref def="dt-consuming"/>, which is
                        consistent with streaming provided there is only one such reference, and if
                        it appears in a suitable context (for example, not within a predicate).
                           <phrase diff="add" at="Q">If there is more than one reference to the
                           grouping variable, or if it appears in an unsuitable context (for
                           example, within a predicate), then this will have the same effect as
                           multiple appearances of other consuming expressions: the construct as a
                           whole will be <termref def="dt-free-ranging"/>.</phrase> These rules are
                        not spelled out explicitly, but rather emerge as a consequence of the
                        general streamability rules.</p>
                     <p diff="add" at="R-bug24510">The above rules do not explicitly mention any
                        constraints on the presence or absence of a call on the
                           <function>current-group</function> function. In practice, however, this
                        plays an important role. In the most common case, the <code>select</code>
                        expression of <elcode>xsl:for-each-group</elcode> is likely to be striding,
                        for example an expression such as <code>select="*"</code>. Any call on
                           <function>current-group</function> associated with this
                           <elcode>xsl:for-each-group</elcode> instruction will ordinarily be
                           <termref def="dt-striding"/> and <termref def="dt-consuming"/>, which is
                        consistent with streaming provided there is only one such call, and if it
                        appears in a suitable context (for example, not within a predicate). If
                        there is more than one call, or if it appears in an unsuitable context (for
                        example, within a predicate), then this will have the same effect as
                        multiple appearances of other consuming expressions: the construct as a
                        whole will be free-ranging. These rules are not spelled out explicitly, but
                        rather emerge as a consequence of the general streamability rules.</p>
                  </note>
               </div4>
               <div4 id="streamability-xsl-fork" diff="chg" at="Q">
                  <head>Streamability of <elcode>xsl:fork</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:fork</elcode> are the first of the following that applies:</p>
                  <olist diff="chg" at="R-bug24508">
                     <item diff="add" at="R-bug24317">
                        <p diff="chg" at="T-bug29502">If there is a child
                              <elcode>xsl:for-each-group</elcode> instruction, then the <termref
                              def="dt-posture"/> and the <termref def="dt-sweep"/> of that
                           instruction.</p>
                     </item>
                     <item>
                        <p>If there are no child <phrase diff="chg" at="R-bug24317"
                                 ><elcode>xsl:sequence</elcode></phrase> instructions (other than
                              <elcode>xsl:fallback</elcode>), then <termref def="dt-grounded"/> and
                              <termref def="dt-motionless"/>.</p>
                     </item>
                     <item>
                        <p>If there is a child <elcode>xsl:sequence</elcode> instruction whose
                              <termref def="dt-posture"/> is not <termref def="dt-grounded"/>, then
                              <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p>Otherwise, the <termref def="dt-posture"/> is <termref def="dt-grounded"
                           />, and the <termref def="dt-sweep"/> is the widest sweep of the
                              <elcode>xsl:sequence</elcode> child instructions.</p>
                     </item>
                  </olist>
                  <note>
                     <p>None of the branches of <elcode>xsl:fork</elcode> can return streamed nodes.
                        The reason for this is that <elcode>xsl:fork</elcode> has to assemble its
                        results in the correct order, and streamed nodes cannot be re-ordered.</p>
                     <p>The effect of the rules is that each of the child
                           <elcode>xsl:sequence</elcode> instructions can independently consume the
                        streamed input document, provided that the result of each child instruction
                        is <termref def="dt-grounded"/>.</p>
                     <p>Thus the following example is streamable:</p>
                     <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:fork&gt;
   &lt;xsl:sequence select="copy-of(author)"/&gt;
   &lt;xsl:sequence select="copy-of(editor)"/&gt;
&lt;/xsl:fork&gt;</eg>
                     <p>While the following is not streamable, because it returns streamed nodes in
                        an order that might not be document order:</p>
                     <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:fork&gt;
   &lt;xsl:sequence select="author"/&gt;
   &lt;xsl:sequence select="editor"/&gt;
&lt;/xsl:fork&gt;</eg>
                  </note>
               </div4>
               <div4 id="streamability-xsl-if">
                  <head>Streamability of <elcode>xsl:if</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:if</elcode> follow the <termref
                        def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role"
                        >operand roles</termref> and their <termref def="dt-operand-usage"
                        >usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>test</code> expression (usage <termref def="dt-inspection"
                           />)</p>
                     </item>
                     <item>
                        <p>The contained <termref def="dt-sequence-constructor"/> (usage <termref
                              def="dt-transmission"/>).</p>
                     </item>
                  </olist>
               </div4>
               <div4 id="streamability-xsl-iterate" diff="chg" at="Q">
                  <head>Streamability of <elcode>xsl:iterate</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the
                        <elcode>xsl:iterate</elcode> instruction are the first of the following that
                     applies:</p>
                  <olist>
                     <item>
                        <p>If the <code>select</code> expression is <termref def="dt-grounded"/>,
                           then the <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the
                              <elcode>xsl:iterate</elcode> instruction follow the <termref
                              def="dt-general-streamability-rules"/>, with the <termref
                              def="dt-operand-role">operand roles</termref> and their <termref
                              def="dt-operand-usage">usages</termref> as follows:</p>
                        <olist>
                           <item>
                              <p>The <code>select</code> expression (the <termref
                                    def="dt-operand-usage"/> is irrelevant, but can be taken as
                                    <termref def="dt-inspection"/>)</p>
                           </item>
                           <item>
                              <p>The <code>select</code> expression or contained sequence
                                 constructor of any <elcode>xsl:param</elcode> children (usage
                                    <termref def="dt-navigation"/>)</p>
                           </item>
                           <item>
                              <p>The sequence constructor contained within the
                                    <elcode>xsl:iterate</elcode> instruction itself, assessed with
                                 its context item type and <termref def="dt-context-posture"/> based
                                 on the <code>select</code> expression (usage <termref
                                    def="dt-transmission"/>)</p>
                           </item>
                           <item>
                              <p>The <code>select</code> expression or contained sequence
                                 constructor of any child <elcode>xsl:on-completion</elcode>
                                 element, assessed with a context item type of <code>xs:error</code>
                                 and a <termref def="dt-context-posture"/> of <termref
                                    def="dt-roaming"/> to reflect the fact that any attempt to
                                 reference the context item within the
                                    <elcode>xsl:on-completion</elcode> element is an error (usage
                                    <termref def="dt-transmission"/>)</p>
                              <note>
                                 <p diff="add" at="P-bug24524">The <code>on-completion</code>
                                    element can cause the instruction to become non-streamable if,
                                    for example, it contains a call on
                                       <function>current-group</function> or a variable reference
                                    bound to <phrase diff="chg" at="S-bug27571">a <termref
                                          def="dt-streaming-parameter"/></phrase>.</p>
                              </note>
                           </item>
                        </olist>
                     </item>
                     <item diff="add" at="R-bug24524">
                        <p>If there is an <elcode>xsl:param</elcode> child whose initializing
                              <code>select</code> expression or <termref
                              def="dt-sequence-constructor"/> is not <termref def="dt-grounded"/>
                           and <termref def="dt-motionless"/>, then <termref def="dt-roaming"/> and
                              <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item diff="add" at="R-bug24524">
                        <p>If there is an <elcode>xsl:on-completion</elcode> child whose
                              <code>select</code> expression or <termref
                              def="dt-sequence-constructor"/> is not <termref def="dt-grounded"/>
                           and <termref def="dt-motionless"/>, then <termref def="dt-roaming"/> and
                              <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p diff="add" at="R-bug25185">If the <termref def="dt-posture"/> of the
                              <code>select</code> expression is <termref def="dt-crawling"/> and the
                              <termref def="dt-sweep"/> of the contained <termref
                              def="dt-sequence-constructor"/> is <termref def="dt-consuming"/>, then
                              <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p>Otherwise:</p>
                        <olist>
                           <item>
                              <p>The <termref def="dt-posture"/> of the instruction is the <termref
                                    def="dt-posture"/> of the contained <termref
                                    def="dt-sequence-constructor"/>, assessed with the <phrase
                                    diff="chg" at="Q"><termref def="dt-context-posture"/></phrase>
                                 and context item type set to the <termref def="dt-posture"/> and
                                 type of the <code>select</code> expression.</p>
                           </item>
                           <item>
                              <p>The <termref def="dt-sweep"/> of the instruction is the wider of
                                 the <termref def="dt-sweep">sweeps</termref> of <phrase diff="chg"
                                    at="R-bug24524">the <code>select</code> expression and the
                                    contained <termref def="dt-sequence-constructor"/></phrase>,
                                 where the ordering of increasing width is <termref
                                    def="dt-motionless"/>, <termref def="dt-consuming"/>, <termref
                                    def="dt-free-ranging"/>.</p>
                           </item>
                        </olist>
                     </item>
                  </olist>
                  <note>
                     <p>If any <elcode>xsl:break</elcode> or <elcode>xsl:next-iteration</elcode>
                        instructions appear within the sequence constructor, their <termref
                           def="dt-posture"/> and <termref def="dt-sweep"/> will be assessed in the
                        course of evaluating the <termref def="dt-posture"/> and <termref
                           def="dt-sweep"/> of the sequence constructor, by reference to the rules
                        in <specref ref="streamability-xsl-break"/> and <specref
                           ref="streamability-xsl-next-iteration"/> respectively.</p>
                  </note>
                  <note diff="add" at="S-bug27571">
                     <p>Because the body of the <elcode>xsl:iterate</elcode> instruction is a
                           <termref def="dt-higher-order-operand"/> of the instruction, any variable
                        reference within the body that is bound to a <termref
                           def="dt-streaming-parameter"/> of a containing <termref
                           def="dt-stylesheet-function"/> will not be singular, which in many cases
                        will make the entire function non-streamable.</p>
                  </note>
               </div4>
               <div4 id="streamability-xsl-map" diff="chg" at="Q">
                  <head>Streamability of <elcode>xsl:map</elcode></head>
                  <p>The <phrase diff="add" at="Q"><termref def="dt-posture"/></phrase> and <termref
                        def="dt-sweep"/> of the <elcode>xsl:map</elcode> instruction are determined
                     by the first of the following that applies:</p>
                  <olist>
                     <item diff="chg" at="R-bug24530">
                        <p>If the sequence constructor within the instruction consists exclusively
                           of <elcode>xsl:map-entry</elcode> instructions (and
                              <elcode>xsl:fallback</elcode> instructions, which are ignored),
                           then:</p>
                        <olist>
                           <item>
                              <p>If any of these <elcode>xsl:map-entry</elcode> children is <termref
                                    def="dt-roaming"/> or <termref def="dt-free-ranging"/>, then
                                    <termref def="dt-roaming"/> and <termref def="dt-free-ranging"
                                 />;</p>
                           </item>
                           <item>
                              <p>Otherwise, <termref def="dt-grounded"/> and the widest sweep of the
                                    <elcode>xsl:map-entry</elcode> children.</p>
                           </item>
                        </olist>
                     </item>
                     <item>
                        <p>Otherwise, the <termref def="dt-posture"/> and <termref def="dt-sweep"/>
                           of the <elcode>xsl:map</elcode> instruction are the posture and sweep of
                           the contained <termref def="dt-sequence-constructor"/>.</p>
                     </item>
                  </olist>
                  <note>
                     <p>See discussion in <specref ref="maps-streaming"/>.</p>
                     <p>The effect of the rules is that it is possible to compute multiple map
                        entries in a single pass of the streamed input document. For example, the
                        following is streamable:</p>
                     <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:map&gt;
  &lt;xsl:map-entry key="'authors'" select="copy-of(author)"/&gt;
  &lt;xsl:map-entry key="'editors'" select="copy-of(editor)"/&gt;
&lt;/xsl:map&gt;  
</eg>
                     <p>The call on <function>copy-of</function> is necessary to ensure that the
                        content of the map entry is grounded; it is not possible to create a map
                        whose entries contain references to streamed nodes.</p>
                  </note>
               </div4>
               <div4 id="streamability-xsl-map-entry">
                  <head>Streamability of <elcode>xsl:map-entry</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:map-entry</elcode> follow the <termref
                        def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role"
                        >operand roles</termref> and their <termref def="dt-operand-usage"
                        >usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>key</code> expression (usage <termref def="dt-absorption"
                           />)</p>
                     </item>
                     <item>
                        <p diff="chg" at="Q">The <code>select</code> expression (usage <termref
                              def="dt-navigation"/>)</p>
                        <note>
                           <p diff="chg" at="Q">This effectively means that the <code>select</code>
                              expression must not return nodes from a streamed input document.</p>
                        </note>
                     </item>
                     <item>
                        <p diff="chg" at="Q">The contained <termref def="dt-sequence-constructor"/>
                           (usage <termref def="dt-navigation"/>).</p>
                     </item>
                  </olist>
               </div4>
               <div4 id="streamability-xsl-merge">
                  <head>Streamability of <elcode>xsl:merge</elcode></head>
                  <note>
                     <p>This section is concerned with the (not very interesting) impact of the
                           <elcode>xsl:merge</elcode> instruction on the streamability of its
                        containing template rule or <elcode>xsl:source-document</elcode>
                        instruction.</p>
                     <p>For the (more important) rules concerning the way in which
                           <elcode>xsl:merge</elcode> performs streamed processing of its own
                        inputs, see <specref ref="streamable-merging"/>.</p>
                  </note>
                  <p diff="chg" at="R-bug24497">The <termref def="dt-posture"/> and <termref
                        def="dt-sweep"/> of <elcode>xsl:merge</elcode> are as follows:</p>
                  <olist diff="chg" at="R-bug24343">
                     <item>
                        <p>If every <elcode>xsl:merge-source</elcode> child element satisfies all
                           the following conditions:</p>
                        <olist>
                           <item>
                              <p>The expression in the <code>for-each-item</code> attribute is
                                 either absent, or <termref def="dt-grounded"/> and <termref
                                    def="dt-motionless"/>;</p>
                           </item>
                           <item>
                              <p>The expression in the <code>for-each-source</code> attribute is
                                 either absent, or <termref def="dt-grounded"/> and <termref
                                    def="dt-motionless"/>;</p>
                           </item>
                           <item>
                              <p>Either at least one of the attributes <code>for-each-item</code>
                                 and <code>for-each-source</code> is present, or the expression in
                                 the <code>select</code> attribute is <termref def="dt-grounded"/>
                                 and <termref def="dt-motionless"/></p>
                           </item>
                        </olist>
                        <p>then the <elcode>xsl:merge</elcode> instruction is <termref
                              def="dt-grounded"/> and <termref def="dt-motionless"/>.</p>
                     </item>
                     <item>
                        <p>Otherwise, the <elcode>xsl:merge</elcode> instruction <termref
                              def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                  </olist>
               </div4>
               <div4 id="streamability-xsl-message">
                  <head>Streamability of <elcode>xsl:message</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:message</elcode> follow the <termref
                        def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role"
                        >operand roles</termref> and their <termref def="dt-operand-usage"
                        >usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>select</code> expression (usage <termref def="dt-absorption"
                           />)</p>
                     </item>
                     <item>
                        <p>The <code>terminate</code> attribute value template (usage <termref
                              def="dt-absorption"/>)</p>
                     </item>
                     <item diff="add" at="R-bug24525">
                        <p>The <code>error-code</code> attribute value template (usage <termref
                              def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The contained <termref def="dt-sequence-constructor"/> (usage <termref
                              def="dt-absorption"/>).</p>
                     </item>
                  </olist>
               </div4>
               <div4 id="streamability-xsl-namespace">
                  <head>Streamability of <elcode>xsl:namespace</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:namespace</elcode> follow the <termref
                        def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role"
                        >operand roles</termref> and their <termref def="dt-operand-usage"
                        >usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>name</code> attribute value template (usage <termref
                              def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The <code>select</code> expression (usage <termref def="dt-absorption"
                           />)</p>
                     </item>
                     <item>
                        <p>The contained <termref def="dt-sequence-constructor"/> (usage <termref
                              def="dt-absorption"/>).</p>
                     </item>
                  </olist>
               </div4>
               <div4 id="streamability-xsl-next-iteration">
                  <head>Streamability of <elcode>xsl:next-iteration</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:next-iteration</elcode> follow the <termref
                        def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role"
                        >operand roles</termref> and their <termref def="dt-operand-usage"
                        >usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>select</code> expression or <termref
                              def="dt-sequence-constructor"/> content of any contained
                              <elcode>xsl:with-param</elcode> child element: its <termref
                              def="dt-operand-usage"/> is the <termref
                              def="dt-type-determined-usage"/> based on the type declared in the
                              <code>xsl:with-param/@as</code> attribute, or the
                              <code>xsl:param/@as</code> attribute of the corresponding parameter on
                           the containing <elcode>xsl:iterate</elcode> instruction, whichever is
                           more restrictive, defaulting to <code>item()*</code> if both are
                           absent.</p>
                     </item>
                  </olist>
               </div4>
               <div4 id="streamability-xsl-next-match">
                  <head>Streamability of <elcode>xsl:next-match</elcode></head>
                  <p>The rules are the same as for <elcode>xsl:apply-imports</elcode>: see <specref
                        ref="streamability-xsl-apply-imports"/>.</p>
               </div4>
               <div4 id="streamability-xsl-number" diff="chg" at="Q">
                  <head>Streamability of <elcode>xsl:number</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:number</elcode> follow the <termref
                        def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role"
                        >operand roles</termref> and their <termref def="dt-operand-usage"
                        >usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>value</code> attribute if present: usage <termref
                              def="dt-absorption"/></p>
                     </item>
                     <item>
                        <p diff="chg" at="S-bug27250">The <code>select</code> attribute if there is
                           no <code>value</code> attribute, defaulting to the context item
                           expression (<code>.</code>) if the <code>select</code> attribute is also
                           absent: usage <termref def="dt-navigation"/></p>
                     </item>
                     <item>
                        <p>The attribute value templates in the <code>format</code>,
                              <code>lang</code>, <code>letter-value</code>, <code>ordinal</code>,
                              <code>start-at</code>, <code>grouping-separator</code>, and
                              <code>grouping-size</code> attributes (usage <termref
                              def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The <code>from</code> and <code>count</code> patterns if present. <phrase
                              diff="add" at="S-bug27250">These can be treated as <termref
                                 def="dt-higher-order-operand">higher-order operands</termref> with
                              usage <termref def="dt-inspection"/>, though neither of these
                              properties affects the outcome.</phrase></p>
                     </item>
                  </olist>
                  <note>
                     <p>The effect of these rules is that <elcode>xsl:number</elcode> can be used
                        for formatting of numbers supplied directly using the <code>value</code>
                        attribute, and also for numbering of nodes in a non-streamed document, but
                        it cannot be used for numbering streamed nodes.</p>
                     <p>In practice the rules depend very little on the <code>from</code> and
                           <code>count</code> patterns. This is because when the instruction is
                        applied to a streamed node, the instruction will be <termref
                           def="dt-free-ranging"/> regardless of these patterns; while if it is
                        applied to a grounded node or atomic value, the instruction will normally be
                           <termref def="dt-motionless"/> regardless of the values of these
                        patterns. <phrase diff="chg" at="R-bug24528">The pattern does matter,
                           however, if it contains a variable reference bound to <phrase diff="chg"
                              at="S-bug27571">a <termref def="dt-streaming-parameter"/></phrase>;
                           because such a reference occurs within a <termref
                              def="dt-higher-order-operand"/> of the <elcode>xsl:number</elcode>
                           instruction, its presence automatically makes the variable reference
                              <termref def="dt-free-ranging"/>, which in turn ensures that the
                           containing stylesheet function is not <termref
                              def="dt-guaranteed-streamable"/>.</phrase></p>
                  </note>
               </div4>
               <div4 id="streamability-xsl-on-empty" diff="add" at="S-bug28887">
                  <head>Streamability of <elcode>xsl:on-empty</elcode></head>
                  <p>The streamability rules for the <elcode>xsl:on-empty</elcode> instruction are
                     the same as the rules for <elcode>xsl:sequence</elcode>: see <specref
                        ref="streamability-xsl-sequence"/>.</p>
                  <note>
                     <p>The streamability rules for a sequence constructor containing an
                           <elcode>xsl:on-empty</elcode> instruction are given in <specref
                           ref="classifying-sequence-constructors"/>.</p>
                  </note>
               </div4>
               <div4 id="streamability-xsl-on-non-empty" diff="add" at="S-bug28887">
                  <head>Streamability of <elcode>xsl:on-non-empty</elcode></head>
                  <p>The streamability rules for the <elcode>xsl:on-non-empty</elcode> instruction
                     are the same as the rules for <elcode>xsl:sequence</elcode>: see <specref
                        ref="streamability-xsl-sequence"/>.</p>
                  <note>
                     <p>The streamability rules for a sequence constructor containing an
                           <elcode>xsl:on-non-empty</elcode> instruction are given in <specref
                           ref="classifying-sequence-constructors"/>.</p>
                  </note>
               </div4>
               <div4 id="streamability-xsl-perform-sort">
                  <head>Streamability of <elcode>xsl:perform-sort</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:perform-sort</elcode> follow the <termref
                        def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role"
                        >operand roles</termref> and their <termref def="dt-operand-usage"
                        >usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The expression in the <code>select</code> attribute: usage <termref
                              def="dt-navigation"/> (because order is not preserved)</p>
                     </item>
                     <item>
                        <p>The expressions in the attribute value templates of
                              <elcode>xsl:sort</elcode> child elements: usage <termref
                              def="dt-absorption"/></p>
                     </item>
                     <item>
                        <p>The expression in the <code>select</code> attribute <phrase diff="chg"
                              at="Q">or contained sequence constructor</phrase> in child
                              <elcode>xsl:sort</elcode> child elements, with usage <termref
                              def="dt-absorption"/>, assessed with <phrase diff="chg" at="Q"
                                 ><termref def="dt-context-posture"/></phrase> based on the
                           expression in the <code>xsl:perform-sort/@select</code> attribute.</p>
                     </item>
                  </olist>
                  <note>
                     <p>In practice, the <elcode>xsl:perform-sort</elcode> instruction cannot be
                        used to sort nodes from the streamed input document, but it can be used to
                        sort atomic values or <termref def="dt-grounded"/> nodes, for example a copy
                        of nodes from the streamed document made using the
                           <function>copy-of</function> function.</p>
                  </note>
               </div4>
               <div4 id="streamability-xsl-processing-instruction">
                  <head>Streamability of <elcode>xsl:processing-instruction</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:processing-instruction</elcode> follow the <termref
                        def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role"
                        >operand roles</termref> and their <termref def="dt-operand-usage"
                        >usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>name</code> attribute value template (usage <termref
                              def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The <code>select</code> expression (usage <termref def="dt-absorption"
                           />)</p>
                     </item>
                     <item>
                        <p>The contained <termref def="dt-sequence-constructor"/> (usage <termref
                              def="dt-absorption"/>).</p>
                     </item>
                  </olist>
               </div4>
               <div4 id="streamability-xsl-result-document">
                  <head>Streamability of <elcode>xsl:result-document</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:result-document</elcode> follow the <termref
                        def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role"
                        >operand roles</termref> and their <termref def="dt-operand-usage"
                        >usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>href</code> attribute value template (usage <termref
                              def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The attribute value templates containing serialization properties (usage
                              <termref def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The contained <termref def="dt-sequence-constructor"/> (usage <termref
                              def="dt-absorption"/>).</p>
                     </item>
                  </olist>
               </div4>
               <div4 id="streamability-xsl-sequence">
                  <head>Streamability of <elcode>xsl:sequence</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:sequence</elcode> follow the <termref
                        def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role"
                        >operand roles</termref> and their <termref def="dt-operand-usage"
                        >usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>select</code> attribute value template (usage <termref
                              def="dt-transmission"/>)</p>
                     </item>
                     <item>
                        <p>The contained <termref def="dt-sequence-constructor"/> (usage <termref
                              def="dt-transmission"/>).</p>
                     </item>
                  </olist>
               </div4>
               <div4 id="streamability-xsl-stream" diff="chg" at="Q">
                  <head>Streamability of <elcode>xsl:source-document</elcode></head>
                  <note>
                     <p>The concern here is with the impact of <elcode>xsl:source-document</elcode>
                        on any streaming template, or ancestor <elcode>xsl:source-document</elcode>
                        instruction, and not with the streamed processing of the document accessed
                        using the <code>xsl:source-document/@href</code> attribute.</p>
                     <p>The streamability of the document opened by the
                           <elcode>xsl:source-document</elcode> instruction is not assessed using
                        the rules in this section; it depends only on the streamability properties
                        of the contained sequence constructor, as described in <specref
                           ref="source-document-instruction"/></p>
                  </note>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:source-document</elcode> are the first of the following that
                     applies:</p>
                  <olist>
                     <item>
                        <p>If the contained sequence constructor contains, at any depth, a <phrase
                              diff="chg" at="R-bug24510">call on the
                                 <function>current-group</function> function whose nearest
                              containing <elcode>xsl:for-each-group</elcode></phrase> instruction
                           exists and is an ancestor of the <elcode>xsl:source-document</elcode>
                           instruction, then <termref def="dt-roaming"/> and <termref
                              def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p>If the contained sequence constructor contains, at any depth, a <phrase
                              diff="chg" at="R-bug24510">call on the
                                 <function>current-merge-group</function> function whose nearest
                              containing <elcode>xsl:merge</elcode></phrase> instruction exists and
                           is an ancestor of the <elcode>xsl:source-document</elcode> instruction,
                           then <termref def="dt-roaming"/> and <termref def="dt-free-ranging"
                           />.</p>
                     </item>
                     <item>
                        <p>Otherwise, the <termref def="dt-posture"/> is <termref def="dt-grounded"
                           /> and the <termref def="dt-sweep"/> is the <termref def="dt-sweep"/> of
                           the <code>href</code> attribute value template.</p>
                     </item>
                  </olist>
               </div4>
               <div4 id="streamability-xsl-text">
                  <head>Streamability of <elcode>xsl:text</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:text</elcode> follow the <termref
                        def="dt-general-streamability-rules"/>. There are no operands.</p>
                  <note>
                     <p>The instruction is therefore <termref def="dt-grounded"/> and <termref
                           def="dt-motionless"/>.</p>
                  </note>
               </div4>
               <div4 id="streamability-xsl-try">
                  <head>Streamability of <elcode>xsl:try</elcode></head>
                  <p diff="chg" at="R-bug24495">The <termref def="dt-posture"/> and <termref
                        def="dt-sweep">sweep</termref> of the <elcode>xsl:try</elcode> instruction
                     follow the <termref def="dt-general-streamability-rules"/>. The <termref
                        def="dt-operand-role">operand roles</termref> and <termref
                        def="dt-operand-usage">usages</termref> are as follows:</p>
                  <olist diff="chg" at="R-bug24496">
                     <item>
                        <p>The <code>select</code> expression or contained <termref
                              def="dt-sequence-constructor"/> of the <elcode>xsl:try</elcode>
                           element. This has <termref def="dt-operand-usage"/>
                           <termref def="dt-transmission"/>. (Note that the
                              <elcode>xsl:catch</elcode> children of <elcode>xsl:try</elcode> are
                           not part of the sequence constructor and therefore not part of this
                           operand.)</p>
                     </item>
                     <item>
                        <p>The <code>select</code> expressions and/or contained <termref
                              def="dt-sequence-constructor"/> of the <elcode>xsl:catch</elcode>
                           child elements. These form a <termref def="dt-choice-operand-group"/>
                           with <termref def="dt-operand-usage"/>
                           <termref def="dt-transmission"/>.</p>
                     </item>
                  </olist>
                  <note diff="chg" at="R-bug24496">
                     <p>The overall effect of these rules is that either the
                           <elcode>xsl:try</elcode> branch or the <elcode>xsl:catch</elcode> branch
                        may consume the streamed input, but not both. If there is more than one
                           <elcode>xsl:catch</elcode> branch then they may all consume the input,
                        since only one of these branches can be evaluated.</p>
                  </note>
               </div4>
               <div4 id="streamability-xsl-value-of">
                  <head>Streamability of <elcode>xsl:value-of</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:value-of</elcode> follow the <termref
                        def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role"
                        >operand roles</termref> and their <termref def="dt-operand-usage"
                        >usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>select</code> expression (usage <termref def="dt-absorption"
                           />)</p>
                     </item>
                     <item>
                        <p>The <code>separator</code> attribute value template (usage <termref
                              def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The contained <termref def="dt-sequence-constructor"/> (usage <termref
                              def="dt-absorption"/>).</p>
                     </item>
                  </olist>
               </div4>
               <div4 id="streamability-xsl-variable" diff="chg" at="Q">
                  <head>Streamability of <elcode>xsl:variable</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:variable</elcode> follow the <termref
                        def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role"
                        >operand roles</termref> and their <termref def="dt-operand-usage"
                        >usages</termref>
                     <phrase diff="add" at="R-bug24109">depend on the <code>as</code> attribute,
                     </phrase> as follows:</p>
                  <olist>
                     <item diff="add" at="R-bug24109">
                        <p>If there is an <code>as</code> attribute, then:</p>
                        <olist>
                           <item>
                              <p>The <code>select</code> expression (with <termref
                                    def="dt-type-determined-usage"/> based on the <code>as</code>
                                 attribute).</p>
                           </item>
                           <item>
                              <p>The contained <termref def="dt-sequence-constructor"/> (with
                                    <termref def="dt-type-determined-usage"/> based on the
                                    <code>as</code> attribute).</p>
                           </item>
                        </olist>
                     </item>
                     <item>
                        <p diff="add" at="R-bug24109">If there is no <code>as</code> attribute,
                           then:</p>
                        <olist>
                           <item>
                              <p>The <code>select</code> expression (usage <termref
                                    def="dt-navigation"/>).</p>
                           </item>
                           <item>
                              <p>The contained <termref def="dt-sequence-constructor"/> (usage
                                    <termref diff="chg" at="R-bug24109" def="dt-absorption"/>).</p>
                           </item>
                        </olist>
                     </item>
                  </olist>
                  <note>
                     <p>The effect of the initialization expression having usage <termref
                           def="dt-navigation"/> is that it is not possible in streamable constructs
                        to bind a variable to a node in a streamed document.</p>
                  </note>
               </div4>
               <div4 id="streamability-xsl-where-populated" diff="add" at="S-bug28887">
                  <head>Streamability of <elcode>xsl:where-populated</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of an
                        <elcode>xsl:where-populated</elcode> instruction are the <termref
                        def="dt-posture"/> and <termref def="dt-sweep"/> of the contained <termref
                        def="dt-sequence-constructor"/>.</p>
               </div4>
            </div3>
            <div3 id="streamable-stylesheet-functions" diff="chg" at="S-bug27571">
               <head>Classifying Stylesheet Functions</head>
               <p>Under specific conditions, described in this section, a stylesheet function can be
                  used to process nodes from a <termref def="dt-streamed-document">streamed input
                     document</termref>.</p>
               <p><termdef id="dt-streamability-category" term="streamability category">Stylesheet
                     functions belong to one of a number of <term>streamability categories</term>:
                     the choice of category characterizes the way in which the function handles
                     streamed input.</termdef></p>
               <p>The <termref def="dt-streamability-category">category</termref> to which a
                  function belongs is declared in the <code>streamability</code> attribute of the
                     <elcode>xsl:function</elcode> declaration, and defaults to
                     <code>unclassified</code>.</p>
               <p>The streamability categories defined in this specification are:
                     <code>unclassified</code>, <code>absorbing</code>, <code>inspection</code>,
                     <code>filter</code>, <code>shallow-descent</code>, <code>deep-descent</code>,
                  and <code>ascent</code>. It is also possible to specify the streamability category
                  as a QName in an <termref def="dt-implementation-defined"/> namespace, in which
                  case the streamability rules are <termref def="dt-implementation-defined"/>; a
                  processor that does not recognize a category defined in this way
                     <rfc2119>must</rfc2119> analyze the function as if
                     <code>streamability="unclassified"</code> were specified. </p>
               <imp-def-feature id="idf-ext-streamingcategories">Additional <termref
                     def="dt-streamability-category">streamability categories</termref> for
                  stylesheet functions may be defined by an implementation.</imp-def-feature>
               <p>A stylesheet function is <termref def="dt-declared-streamable"/> if the
                     <elcode>xsl:function</elcode> declaration has a <code>streamability</code>
                  attribute with a value other than <code>unclassified</code>.</p>
               <p>The only <termref def="dt-streamability-category">category</termref> permitted for
                  a zero-arity function (one with no arguments) is <code>unclassified</code>. All
                  function calls to zero-arity stylesheet functions are <termref def="dt-grounded"/>
                  and <termref def="dt-motionless"/>.</p>
               <p>In general (subject to more detailed rules below), a node belonging to a <termref
                     def="dt-streamed-document"/> can be present within the value of an argument of
                  a call on a <termref def="dt-stylesheet-function"/> only if one of the following
                  conditions is true:</p>
               <olist>
                  <item>
                     <p>The stylesheet function is <termref def="dt-declared-streamable"/>, and the
                        argument in question is the first argument of the function call.</p>
                  </item>
                  <item>
                     <p>The corresponding <termref def="dt-function-parameter"/> is declared with a
                           <termref def="dt-required-type"/> that triggers <termref
                           def="dt-atomization">atomization</termref> of any supplied node.</p>
                  </item>
               </olist>
               <p><termdef id="dt-streaming-parameter" term="streaming parameter">The first <termref
                        def="dt-function-parameter">parameter</termref> of a <termref
                        def="dt-declared-streamable"/>
                     <termref def="dt-stylesheet-function"/> is referred to as a <term>streaming
                        parameter</term>.</termdef></p>
               <note>
                  <p>If a stylesheet function returns streamed nodes, then these nodes can only
                     derive from streamed nodes passed in an argument to the function. This is
                     because streamed nodes cannot be bound to global variables, and they cannot be
                     returned by an <elcode>xsl:source-document</elcode> instruction within the
                     function body (the result of <elcode>xsl:source-document</elcode> is always
                     grounded).</p>
               </note>
               <p>The choice of <termref def="dt-streamability-category">category</termref> places
                  constraints on the function body, and also on calls to the function. These
                  constraints are defined below, separately for each category. A function is
                     <termref def="dt-guaranteed-streamable"/> only if the constraints are
                  satisfied, <phrase diff="add" at="T-bug29732"> and a static function call is
                     guaranteed-streamable only if the function is guaranteed-streamable and the
                     function call itself satisfies the constraints for the chosen
                     category.</phrase></p>
               <p diff="add" at="T-bug29732">Dynamic function calls are <termref
                     def="dt-guaranteed-streamable"/> only in trivial cases, for example where the
                  function signature indicates that an argument is required to be a text node or an
                  attribute node. For details, see <specref
                     ref="streamability-of-dynamic-function-calls"/>.</p>
               <p>The constraints on the function body are expressed in terms of the <termref
                     def="dt-posture"/> and <termref def="dt-sweep"/> of the function result. The
                     <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the function
                  result are the <termref def="dt-type-adjusted-posture-and-sweep"/> of the <termref
                     def="dt-sequence-constructor"/> contained within the
                     <elcode>xsl:function</elcode> element, given the declared return type of the
                  function, which defaults to <code>item()*</code>.</p>
               <note>
                  <p>Determining the <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                     the function result requires first determining the <termref def="dt-posture"/>
                     and <termref def="dt-sweep"/> of the contained <termref
                        def="dt-sequence-constructor"/>, which is done according to the rules in
                        <specref ref="classifying-sequence-constructors"/>. This in turn will
                     usually involve examination of variable references that are bound to the
                     function’s parameters. The analysis of these variable references is described
                     in <specref ref="streamability-of-variable-references"/>.</p>
               </note>
               <p>If the function is <termref def="dt-declared-streamable"/> but does not satisfy
                  the constraints that make it <termref def="dt-guaranteed-streamable"/>, the
                  consequences are explained in <specref ref="streamability-guarantees"/>.</p>
               <p>If a stylesheet function is overridden in another package (using
                     <elcode>xsl:override</elcode>), then the overriding stylesheet function must
                  belong to the same <termref def="dt-streamability-category"/> as the function that
                  it overrides. This ensures that overriding a function cannot affect the
                  streamability of calls to that function.</p>
               <p>The rules for each <termref def="dt-streamability-category"/> are given in the
                  following sections.</p>
               <div4 id="category-unclassified">
                  <head>Streamability Category: unclassified</head>
                  <p><term>Informal description:</term> Functions in this category cannot be called
                     with streamed nodes supplied in an argument, unless the function signature
                     causes such nodes to be atomized.</p>
                  <p diff="add" at="T-bug29732"><term>Rules for the function signature:</term> there
                     are no constraints.</p>
                  <p><term>Rules for the function body:</term> there are no constraints.</p>
                  <p diff="add" at="S-bug27571"><term>Rules for references to the streaming
                        parameter:</term> not applicable, because there is no streaming
                     parameter.</p>
                  <p><term>Rules for function calls:</term> the <termref
                        def="dt-general-streamability-rules"/> apply. The operands are the
                     expressions appearing in the argument list of the function call, with the
                        <termref def="dt-operand-usage"/> of each operand being the <termref
                        def="dt-type-determined-usage"/> based on the declared type of the
                     corresponding parameter in the function signature. </p>
                  <example>
                     <head>An unclassified stylesheet function that accepts nodes</head>
                     <p>The <termref def="dt-streamability-category"/> is
                        <code>unclassified</code>.</p>
                     <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">
&lt;xsl:function name="f:exclude-first" as="node()*"&gt;
  &lt;xsl:param name="nodes" as="node()*"/&gt;
  &lt;xsl:sequence select="$nodes[not(node-name() = preceding-sibling::*/node-name())]"/&gt;
&lt;/xsl:function&gt;  
                        </eg>
                     <p>The effect of the rules is that a call to this function is guaranteed
                        streamable if and only if the sequence supplied as the value of the
                           <code>$nodes</code> argument is <termref def="dt-grounded"/> (that is, it
                        contains no streamed nodes).</p>
                  </example>
                  <example>
                     <head>An unclassified stylesheet function that accepts atomic values</head>
                     <p>The <termref def="dt-streamability-category"/> is
                        <code>unclassified</code>.</p>
                     <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">
&lt;xsl:function name="f:min" as="xs:integer"&gt;
  &lt;xsl:param name="arg0" as="xs:integer"/&gt;
  &lt;xsl:param name="arg1" as="xs:integer"/&gt;
  &lt;xsl:sequence select="min(($arg0, $arg1))"/&gt;
&lt;/xsl:function&gt;  
                        </eg>
                     <p>The effect of the rules is that a call to this function is streamable under
                        similar circumstances to those that apply to a binary operator such as
                           <code>+</code>. For example, a call is streamable if two atomic values
                        are supplied, or if two attribute nodes are supplied, whether from streamed
                        or unstreamed documents. The main constraint is that it is not permitted for
                        both arguments to be consuming; for example, if the context node is a node
                        in a streamed document, then the function call <code>f:min((price,
                           discount))</code> would not be guaranteed streamable.</p>
                  </example>
               </div4>
               <div4 id="category-absorbing">
                  <head>Streamability Category: absorbing</head>
                  <p><term>Informal description:</term> Functions in this category typically read
                     the subtrees rooted at the node or nodes supplied in the first argument. These
                     subtrees must not overlap each other. The function must not return any streamed
                     nodes.</p>
                  <p diff="add" at="T-bug29732"><term>Rules for the function signature:</term> there
                     are no constraints.</p>
                  <p diff="chg" at="T-bug29710"><term>Rules for the function body:</term> For the
                     function to be <termref def="dt-guaranteed-streamable"/>, the <termref
                        def="dt-type-adjusted-posture-and-sweep">type-adjusted posture</termref> of
                     the function body with respect to the declared return type must be <termref
                        def="dt-grounded"/>, and the <termref
                        def="dt-type-adjusted-posture-and-sweep">type-adjusted sweep</termref> of
                     the function body with respect to the declared return type must be <phrase
                        diff="add" at="T-bug29712"><termref def="dt-motionless"/> or
                        </phrase><termref def="dt-consuming"/>.</p>
                  <p diff="add" at="S-bug27571"><term>Rules for references to the streaming
                        parameter:</term> If the declared type of the <termref
                        def="dt-streaming-parameter"/> permits more than one node, then a variable
                     reference referring to the streaming parameter is <termref def="dt-striding"/>
                     and <termref def="dt-consuming"/>. Otherwise such a variable reference is
                        <termref def="dt-striding"/> and <termref def="dt-motionless"/>.</p>
                  <p><term>Rules for function calls:</term> If the first argument is <termref
                        def="dt-crawling"/> then the function call is <termref def="dt-roaming"/>
                     and <termref def="dt-free-ranging"/>; otherwise the <termref
                        def="dt-general-streamability-rules"/> apply. The operands are the
                     expressions appearing in the argument list of the function call. The <termref
                        def="dt-operand-usage"/> of the first argument is <termref
                        def="dt-absorption"/>; the operand usage of other arguments is the <termref
                        def="dt-type-determined-usage"/> based on the declared type of the
                     corresponding <termref def="dt-parameter"/> in the function signature. </p>
                  <note>
                     <p>Absorbing functions perform an operation analogous to atomization on their
                        supplied arguments, in that they typically use information from the subtree
                        rooted at a node to compute atomic values. Atomization can be seen as a
                        special case of absorption. Calls on absorbing functions are therefore, from
                        a streamability point of view, equivalent to calls on functions that
                        implicitly atomize the supplied nodes.</p>
                     <p>An important difference, however, is that whereas atomization can be applied
                        to any argument of a function call, absorption applies only to the first
                        argument.</p>
                     <p>Another difference is that atomization is allowed on a sequence of nodes in
                           <termref def="dt-crawling"/> posture, whereas generalized absorption is
                        not. Within a sequence, there may be nodes whose subtrees overlap, and the
                        code for atomization is expected to handle this, but more general absorption
                        operations are not. To write a function that accepts streamed nodes and
                        atomizes them, it is better to use the streamability category
                           <code>unclassified</code>, and to declare the first argument with an
                        atomic type, rather than using the category <code>absorbing</code> which
                        allows more general processing, but restricts what can be supplied in the
                        argument to the function call.</p>
                  </note>
                  <example>
                     <head>An absorbing stylesheet function</head>
                     <p>The following function is declared as absorbing, and the function body meets
                        the rules for this category because it makes downward selections only, and
                        returns an atomic value.</p>
                     <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">
&lt;xsl:function name="f:count-descendants" as="xs:integer" streamability="absorbing"&gt;
  &lt;xsl:param name="input" as="node()*"/&gt;
  &lt;xsl:sequence select="count($input//*)"/&gt;
&lt;/xsl:function&gt;  
                        </eg>
                     <p>The effect of the rules is that a call to this function is <termref
                           def="dt-guaranteed-streamable"/> provided that the sequence supplied as
                        the value of the <code>$nodes</code> argument is <termref
                           def="dt-motionless"/> or <termref def="dt-consuming"/>, and is either
                           <termref def="dt-grounded"/> or <termref def="dt-striding"/>.</p>
                  </example>
                  <example>
                     <head>An absorbing stylesheet function with two arguments</head>
                     <p>The following function is declared as absorbing, and the function body meets
                        the rules for this category because it makes downward selections only from
                        the node supplied as the first argument, and returns an atomic value.</p>
                     <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">
&lt;xsl:function name="f:compare-size" as="xs:integer" streamability="absorbing"&gt;
  &lt;xsl:param name="input0" as="node()"/&gt;
  &lt;xsl:param name="input1" as="node()"/&gt;
  &lt;xsl:sequence select="count($input0//*) - count($input1//*)"/&gt;
&lt;/xsl:function&gt;</eg>
                     <p>This function takes two nodes as its arguments. Some examples of function
                        calls include: </p>
                     <ulist>
                        <item>
                           <p>Streamable: <code>f:compare-size(a, b)</code> where <code>a</code> is
                              an element in a streamed document and <code>b</code> is an element in
                              an unstreamed document</p>
                        </item>
                        <item>
                           <p>Streamable: <code>f:compare-size(a, b)</code> where <code>a</code> and
                                 <code>b</code> are both elements in unstreamed documents</p>
                        </item>
                        <item>
                           <p>Not streamable: <code>f:compare-size(a, b)</code> where <code>a</code>
                              is an element in an unstreamed document and <code>b</code> is an
                              element in a streamed document</p>
                        </item>
                     </ulist>
                     <p diff="chg" at="T-bug29733">The reason for the asymmetry is that for the
                        first argument the <termref def="dt-operand-usage"/> is <termref
                           def="dt-absorption"/>, while for the second argument it is <termref
                           def="dt-navigation"/>. It is a consequence of the <termref
                           def="dt-general-streamability-rules"/> that when streamed nodes are
                        supplied to an operand with usage navigation, the resulting expression is
                           <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                  </example>
                  <example>
                     <head>A recursive absorbing stylesheet function</head>
                     <p>The following function is declared as absorbing, and the function body meets
                        the rules for this category. Analysis of the function body reveals that it
                        is grounded and consuming; to establish this, it is necessary to analyze the
                        recursive call <code>f:outline(*)</code>, and this is possible because it is
                        known to be a call on an absorbing stylesheet function.</p>
                     <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">
&lt;xsl:function name="f:outline" as="xs:string" streamability="absorbing"&gt;
  &lt;xsl:param name="input" as="element()*"/&gt;
  &lt;xsl:value-of select="$input ! (name() || '(' || f:outline(*) || ')')" 
                separator=", "/&gt;
&lt;/xsl:function&gt;</eg>
                     <p>The effect of the rules is that a call to this function is guaranteed
                        streamable in the typical case where the sequence supplied as the value of
                        the <code>$input</code> argument is <termref def="dt-striding"/> and
                           <termref def="dt-consuming"/>.</p>
                  </example>
               </div4>
               <div4 id="category-inspection">
                  <head>Streamability Category: inspection</head>
                  <p><term>Informal description:</term> Functions in this category typically return
                     properties of the node supplied in the first argument, where these properties
                     can be determined without advancing the input stream. This allows access to
                     properties such as the name and type of each node, and also to its ancestors,
                     attributes, and namespaces. </p>
                  <p diff="add" at="T-bug29732"><term>Rules for the function signature:</term> If
                     the declared type of the streaming parameter permits more than one node, the
                     function is not <termref def="dt-guaranteed-streamable"/>.</p>
                  <p diff="chg" at="T-bug29710"><term>Rules for the function body:</term> For the
                     function to be <termref def="dt-guaranteed-streamable"/>, the <termref
                        def="dt-type-adjusted-posture-and-sweep">type-adjusted posture</termref> of
                     the function body with respect to the declared return type must be <termref
                        def="dt-grounded"/>, and the <termref
                        def="dt-type-adjusted-posture-and-sweep">type-adjusted sweep</termref> of
                     the function body with respect to the declared return type must be <termref
                        def="dt-motionless"/>.</p>
                  <p diff="chg" at="T-bug29732"><term>Rules for references to the streaming
                        parameter:</term> Such a variable reference is <termref def="dt-striding"/>
                     and <termref def="dt-motionless"/>.</p>
                  <p><term>Rules for function calls:</term> the <termref
                        def="dt-general-streamability-rules"/> apply. The operands are the
                     expressions appearing in the argument list of the function call. The <termref
                        def="dt-operand-usage"/> of the first argument is <termref
                        def="dt-inspection"/>; the operand usage of other arguments is the <termref
                        def="dt-type-determined-usage"/> based on the declared type of the
                     corresponding argument in the function signature. </p>
                  <note diff="add" at="S-bug27571">
                     <p>The <termref def="dt-streaming-parameter"/> is restricted to be a single
                        node because if <code>$input</code> were a sequence of nodes, then an
                        expression such as <code>($input/name(), $input/@id)</code> would not be
                        streamable.</p>
                  </note>
                  <example>
                     <head>Example of an inspection stylesheet function</head>
                     <p>The following function is declared with category <code>inspection</code>,
                        and the function body meets the rules for this category because all
                        references to the supplied node are motionless.</p>
                     <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">
&lt;xsl:function name="f:depth" as="xs:integer" streamability="inspection"&gt;
  &lt;xsl:param name="input" as="node()"/&gt;
  &lt;xsl:sequence select="count($input/ancestor-or-self::*)"/&gt;
&lt;/xsl:function&gt;</eg>
                     <p>The effect of the rules is that a call to this function is guaranteed
                        streamable provided that the expression supplied as the value of the
                           <code>$nodes</code> argument is <termref def="dt-motionless"/> or
                           <termref def="dt-consuming"/>.</p>
                  </example>
                  <example>
                     <head>Example of an inspection stylesheet function with two arguments</head>
                     <p>The following function is declared with category <code>inspection</code>,
                        and the function body meets the rules for this category because the function
                        signature ensures that the second argument cannot be a node.</p>
                     <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">
&lt;xsl:function name="f:get-attribute-value" as="xs:string"&gt;
  &lt;xsl:param name="element" as="node()"/&gt;
  &lt;xsl:param name="attribute-name" as="xs:string"/&gt;
  &lt;xsl:sequence select="string($element/@*[local-name() = $attribute-name])"/&gt;
&lt;/xsl:function&gt;</eg>
                     <p>Although the normal usage of this function might be to supply an element
                        from a streamed document as the first argument, and a literal string as the
                        second, it is also permissible (and guaranteed streamable) to supply an
                        unstreamed element as the first argument, and an element node from a
                        streamed document as the second. When applying the general streamability
                        rules in this case, the first operand is grounded and motionless, while the
                        second is grounded and consuming (by virtue of the rules for type-determined
                        usage), and this makes the function call grounded and consuming.</p>
                  </example>
               </div4>
               <div4 id="category-filter">
                  <head>Streamability Category: filter</head>
                  <p><term>Informal description:</term> Functions in this category typically return
                     either the node supplied in the first argument or nothing, depending on the
                     values of properties that can be determined without advancing the input stream.
                     This allows access to properties such as the name and type of each node, and
                     also to its ancestors, attributes, and namespaces. </p>
                  <p diff="add" at="T-bug29732"><term>Rules for the function signature:</term> If
                     the declared type of the streaming parameter permits more than one node, the
                     function is not <termref def="dt-guaranteed-streamable"/>.</p>
                  <p diff="chg" at="T-bug29710"><term>Rules for the function body:</term> For the
                     function to be <termref def="dt-guaranteed-streamable"/>, the <termref
                        def="dt-type-adjusted-posture-and-sweep">type-adjusted posture</termref> of
                     the function body with respect to the declared return type must be <termref
                        def="dt-striding"/>, and the <termref
                        def="dt-type-adjusted-posture-and-sweep">type-adjusted sweep</termref> of
                     the function body with respect to the declared return type must be <termref
                        def="dt-motionless"/>.</p>
                  <p diff="chg" at="T-bug29732"><term>Rules for references to the streaming
                        parameter:</term> Such a variable reference is <termref def="dt-striding"/>
                     and <termref def="dt-motionless"/>.</p>
                  <p><term>Rules for function calls:</term> The <termref def="dt-posture"/> and
                        <termref def="dt-sweep"/> of a call to a function in this category are
                     determined by applying the <termref def="dt-general-streamability-rules"/>. The
                     operands are the expressions supplied as arguments to the function call. The
                     first argument has <termref def="dt-operand-usage"/>
                     <termref def="dt-transmission"/>; any further arguments have <termref
                        def="dt-type-determined-usage"/> based on the declared type of the
                     corresponding parameter in the function signature.</p>
                  <example>
                     <head>Example of a filtering stylesheet function</head>
                     <p>The following function is declared as filtering, and the function body meets
                        the rules for this category because it selects nodes from the input based on
                        motionless properties (namely, the existence of attributes).</p>
                     <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">
&lt;xsl:function name="f:large-regions" as="element(region)" streamability="filter"&gt;
  &lt;xsl:param name="input" as="element(region)"/&gt;
  &lt;xsl:sequence select="$input[@size gt 1000]"/&gt;
&lt;/xsl:function&gt;</eg>
                     <p diff="chg" at="T-bug29710">The effect of the rules is that the posture and
                        sweep of a function call <code>f:large-regions(EXPR)</code> are the same as
                        the posture and sweep of <code>EXPR</code>.</p>
                     <p diff="del" at="T-bug29710">The effect of the rules is that a call to this
                        function is guaranteed streamable provided that the sequence supplied as the
                        value of the <code>$nodes</code> argument is <termref def="dt-motionless"/>
                        or <termref def="dt-consuming"/>.</p>
                     <p>Although the name <code>filter</code> suggests that the result must always
                        be a subset of the input, this is not strictly required by the rules. The
                        function can also return atomic values, as well as attribute and namespace
                        nodes.</p>
                  </example>
               </div4>
               <div4 id="category-shallow-descent">
                  <head>Streamability Category: shallow-descent</head>
                  <p><term>Informal description:</term> Functions in this category typically return
                     children of the nodes supplied in the first argument. They may also select
                     deeper in the subtrees of these nodes, provided that no node in the result can
                     possibly be an ancestor of any other node in the result. </p>
                  <p diff="add" at="T-bug29732"><term>Rules for the function signature:</term> If
                     the declared type of the streaming parameter permits more than one node, the
                     function is not <termref def="dt-guaranteed-streamable"/>.</p>
                  <p diff="chg" at="T-bug29710"><term>Rules for the function body:</term> For the
                     function to be <termref def="dt-guaranteed-streamable"/>, the <termref
                        def="dt-type-adjusted-posture-and-sweep">type-adjusted posture</termref> of
                     the function body with respect to the declared return type must be <termref
                        def="dt-striding"/>, and the <termref
                        def="dt-type-adjusted-posture-and-sweep">type-adjusted sweep</termref> of
                     the function body with respect to the declared return type must be <phrase
                        diff="add" at="T-bug29712"><termref def="dt-motionless"/> or
                        </phrase><termref def="dt-consuming"/>.</p>
                  <p diff="add" at="T-bug29732"><term>Rules for references to the streaming
                        parameter:</term> Such a variable reference is <termref def="dt-striding"/>
                     and <termref def="dt-motionless"/>.</p>
                  <p><term>Rules for function calls:</term> The rules are as follows, in order:</p>
                  <olist>
                     <item>
                        <p>Let <var>T0</var> be the <termref def="dt-utype"/> corresponding to the
                           declared type of the <termref def="dt-streaming-parameter"/> in the
                           function signature (defaulting to <var>U{*}</var>).</p>
                     </item>
                     <item>
                        <p>Let <var>P0</var> and <var>S0</var> be the <termref
                              def="dt-type-adjusted-posture-and-sweep"/> of the first argument
                           expression, based on type <var>T0</var>.</p>
                     </item>
                     <item>
                        <p>If <var>P0</var> is not <termref def="dt-striding"/> or <termref
                              def="dt-grounded"/>, the function call is <termref def="dt-roaming"/>
                           and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p>Consider a construct <var>C</var> whose operands are the argument
                           expressions other than the first argument, with <termref
                              def="dt-type-determined-usage">type-determined operand usage</termref>
                           based on the declared type of the corresponding parameter in the function
                           signature. Let <var>P1</var> and <var>S1</var> be the <termref
                              def="dt-posture"/> and <termref def="dt-sweep"/> of <var>C</var>,
                           assessed using the <termref def="dt-general-streamability-rules"/>.</p>
                        <note>
                           <p>If there is only one argument, then <var>P1</var> is <termref
                                 def="dt-grounded"/> and <var>S1</var> is <termref
                                 def="dt-motionless"/>.</p>
                        </note>
                     </item>
                     <item>
                        <p>If <var>P1</var> is not <termref def="dt-grounded"/>, the function call
                           is <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p>If <var>S0</var> and <var>S1</var> are both <termref def="dt-consuming"
                           />, or if either is <termref def="dt-free-ranging"/>, then the function
                           call is <termref def="dt-roaming"/> and <termref def="dt-free-ranging"
                           />.</p>
                     </item>
                     <item>
                        <p>If <var>P0</var> is <termref def="dt-grounded"/>, then the <termref
                              def="dt-posture"/> of the function call is <termref def="dt-grounded"
                           />, and the <termref def="dt-sweep"/> of the function call is the wider
                           of <var>S0</var> and <var>S1</var>.</p>
                     </item>
                     <item>
                        <p>Otherwise, the <termref def="dt-posture"/> of the function call is
                              <var>P0</var>, and the <termref def="dt-sweep"/> of the function call
                           is as follows:</p>
                        <olist>
                           <item>
                              <p>If the intersection of <var>T0</var> with <var>U{document-node(),
                                    element()}</var> is empty (that is, the declared type of the
                                 first argument does not permit document or element nodes) then
                                    <var>S0</var>.</p>
                           </item>
                           <item>
                              <p>Let <var>A</var> be the <termref def="dt-static-type"/> of the
                                 expression supplied as the first argument. If the intersection of
                                    <var>A</var> with <var>U{document-node(), element()}</var> is
                                 empty (that is, the inferred type of the expression supplied as the
                                 first argument does not permit document or element nodes) then
                                    <var>S0</var>.</p>
                           </item>
                           <item>
                              <p>Otherwise, <termref def="dt-consuming"/>.</p>
                           </item>
                        </olist>
                     </item>
                  </olist>
                  <example>
                     <head>A shallow-descent stylesheet function</head>
                     <p>The following function is declared as shallow-descent, and the function body
                        meets the rules for this category because it selects children of the
                        supplied input node.</p>
                     <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">
&lt;xsl:function name="f:alternate-children" as="node()*" 
                                          streamability="shallow-descent"&gt;
  &lt;xsl:param name="input" as="element()"/&gt;
  &lt;xsl:sequence select="$input/node()[position() mod 2 = 1]"/&gt;
&lt;/xsl:function&gt;</eg>
                     <p>The effect of the rules is that a call to this function is guaranteed
                        streamable in the typical case where the node supplied as the value of the
                           <code>$input</code> argument is <termref def="dt-striding"/> and <termref
                           def="dt-consuming"/>.</p>
                  </example>
               </div4>
               <div4 id="category-deep-descent">
                  <head>Streamability Category: deep-descent</head>
                  <p><term>Informal description:</term> Functions in this category typically return
                     descendants of the nodes supplied in the first argument. </p>
                  <p diff="add" at="T-bug29732"><term>Rules for the function signature:</term> If
                     the declared type of the streaming parameter permits more than one node, the
                     function is not <termref def="dt-guaranteed-streamable"/>.</p>
                  <p diff="chg" at="T-bug29710"><term>Rules for the function body:</term> For the
                     function to be <termref def="dt-guaranteed-streamable"/>, the <termref
                        def="dt-type-adjusted-posture-and-sweep">type-adjusted posture</termref> of
                     the function body with respect to the declared return type must be <termref
                        def="dt-crawling"/>, and the <termref
                        def="dt-type-adjusted-posture-and-sweep">type-adjusted sweep</termref> of
                     the function body with respect to the declared return type must be <phrase
                        diff="add" at="T-bug29712"><termref def="dt-motionless"/> or
                        </phrase><termref def="dt-consuming"/>.</p>
                  <p diff="add" at="T-bug29732"><term>Rules for references to the streaming
                        parameter:</term> Such a variable reference is <termref def="dt-striding"/>
                     and <termref def="dt-motionless"/>.</p>
                  <p><term>Rules for function calls:</term> The rules are as follows, in order:</p>
                  <olist>
                     <item>
                        <p>Let <var>T0</var> be the <termref def="dt-utype"/> corresponding to the
                           declared type of the <termref def="dt-streaming-parameter"/> in the
                           function signature (defaulting to <var>U{*}</var>).</p>
                     </item>
                     <item>
                        <p>Let <var>P0</var> and <var>S0</var> be the <termref
                              def="dt-type-adjusted-posture-and-sweep"/> of the first argument
                           expression, based on type <var>T0</var>.</p>
                     </item>
                     <item>
                        <p>If <var>P0</var> is not <termref def="dt-striding"/> or <termref
                              def="dt-grounded"/>, the function call is <termref def="dt-roaming"/>
                           and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p>Consider a construct <var>C</var> whose operands are the argument
                           expressions other than the first argument, with <termref
                              def="dt-type-determined-usage">type-determined operand usage</termref>
                           based on the declared type of the corresponding parameter in the function
                           signature. Let <var>P1</var> and <var>S1</var> be the <termref
                              def="dt-posture"/> and <termref def="dt-sweep"/> of <var>C</var>,
                           assessed using the <termref def="dt-general-streamability-rules"/></p>
                        <note>
                           <p>If there is only one argument, then <var>P1</var> is <termref
                                 def="dt-grounded"/> and <var>S1</var> is <termref
                                 def="dt-motionless"/>.</p>
                        </note>
                     </item>
                     <item>
                        <p>If <var>P1</var> is not <termref def="dt-grounded"/>, the function call
                           is <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p>If <var>S0</var> and <var>S1</var> are both <termref def="dt-consuming"
                           />, or if either is <termref def="dt-free-ranging"/>, the function call
                           is <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p>If <var>P0</var> is <termref def="dt-grounded"/>, then the <termref
                              def="dt-posture"/> of the function call is <termref def="dt-grounded"
                           />, and the <termref def="dt-sweep"/> of the function call is the wider
                           of <var>S0</var> and <var>S1</var>.</p>
                     </item>
                     <item>
                        <p>Otherwise, the <termref def="dt-posture"/> of the function call is
                              <termref def="dt-crawling"/>, and the <termref def="dt-sweep"/> of the
                           function call is as follows:</p>
                        <olist>
                           <item>
                              <p>If the intersection of <var>T0</var> with <var>U{document-node(),
                                    element()}</var> is empty (that is, the declared type of the
                                 first argument does not permit document or element nodes) then
                                    <var>S0</var>.</p>
                           </item>
                           <item>
                              <p>Let <var>A</var> be the <termref def="dt-static-type"/> of the
                                 expression supplied as the first argument. If the intersection of
                                    <var>A</var> with <var>U{document-node(), element()}</var> is
                                 empty (that is, the inferred type of the expression supplied as the
                                 first argument does not permit document or element nodes) then
                                    <var>S0</var>.</p>
                           </item>
                           <item>
                              <p>Otherwise, <termref def="dt-consuming"/>.</p>
                           </item>
                        </olist>
                     </item>
                  </olist>
                  <example>
                     <head>A deep-descent stylesheet function</head>
                     <p>The following function is declared as deep-descent, and the function body
                        meets the rules for this category because it selects descendants of the
                        supplied input node.</p>
                     <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">
&lt;xsl:function name="f:all-comments" as="comment()*" 
                                    streamability="deep-descent"&gt;
  &lt;xsl:param name="input" as="element()"/&gt;
  &lt;xsl:sequence select="$input//comment()"/&gt;
&lt;/xsl:function&gt;</eg>
                     <p>The effect of the rules is that a call to this function is guaranteed
                        streamable in the typical case where the node supplied as the value of the
                           <code>$input</code> argument is <termref def="dt-striding"/> and <termref
                           def="dt-consuming"/>.</p>
                  </example>
               </div4>
               <div4 id="category-ascent">
                  <head>Streamability Category: ascent</head>
                  <p><term>Informal description:</term> Functions in this category typically return
                     ancestors of the nodes supplied in the first argument. </p>
                  <p diff="add" at="T-bug29732"><term>Rules for the function signature:</term> If
                     the declared type of the streaming parameter permits more than one node, the
                     function is not <termref def="dt-guaranteed-streamable"/>.</p>
                  <p diff="chg" at="T-bug29710"><term>Rules for the function body:</term> For the
                     function to be <termref def="dt-guaranteed-streamable"/>, the <termref
                        def="dt-type-adjusted-posture-and-sweep">type-adjusted posture</termref> of
                     the function body with respect to the declared return type must be either
                        <termref def="dt-climbing"/> or <termref def="dt-grounded"/>, and the
                        <termref def="dt-type-adjusted-posture-and-sweep">type-adjusted
                        sweep</termref> of the function body with respect to the declared return
                     type must be <termref def="dt-motionless"/>.</p>
                  <p diff="add" at="T-bug29732"><term>Rules for references to the streaming
                        parameter:</term> Such a variable reference is <termref def="dt-climbing"/>
                     and <termref def="dt-motionless"/>.</p>
                  <p><term>Rules for function calls:</term> The <termref def="dt-posture"/> and
                        <termref def="dt-sweep"/> of a call to a function in this category are
                     determined as follows:</p>
                  <olist>
                     <item>
                        <p>Let <var>P0</var> and <var>S0</var> be the <termref def="dt-posture"/>
                           and <termref def="dt-sweep"/> obtained by assessing the function call
                           using the <termref def="dt-general-streamability-rules"/>, where the
                           operands are the arguments to the function call, with an <termref
                              def="dt-operand-usage"/> for the first argument of <termref
                              def="dt-inspection"/>, and an <termref def="dt-operand-usage"/> for
                           arguments after the first being the <termref
                              def="dt-type-determined-usage"/> based on the declared type of the
                           corresponding <termref def="dt-function-parameter"/>.</p>
                     </item>
                     <item>
                        <p>If <var>P0</var> is <termref def="dt-roaming"/> or <var>S0</var> is
                              <termref def="dt-free-ranging"/>, then the function call is <termref
                              def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p>If <var>S0</var> is not <termref def="dt-motionless"/>, then the function
                           call is <termref def="dt-roaming"/> and <termref def="dt-free-ranging"
                           />.</p>
                     </item>
                     <item>
                        <p>If <var>P0</var> is <termref def="dt-roaming"/>, then the function call
                           is <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p>If <var>P0</var> is <termref def="dt-grounded"/>, then the function call
                           is <termref def="dt-grounded"/> and <termref def="dt-motionless"/>.</p>
                     </item>
                     <item>
                        <p>Otherwise, the function call is <termref def="dt-climbing"/> and <termref
                              def="dt-motionless"/>.</p>
                     </item>
                  </olist>
                  <example>
                     <head>An ascending stylesheet function</head>
                     <p>The following function is declared with category <code>ascent</code>, and
                        the function body meets the rules for this category because it selects
                        ancestors of the supplied node.</p>
                     <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">
&lt;xsl:function name="f:containing-section" as="element(section)" 
                                          streamability="ascent"&gt;
  &lt;xsl:param name="input" as="element(para)*"/&gt;
  &lt;xsl:sequence select="$input/ancestor::section[last()]"/&gt;
&lt;/xsl:function&gt;</eg>
                     <p>The effect of the rules is that a call to this function is guaranteed
                        streamable provided that the node supplied as the value of the
                           <code>input</code> argument is not <termref def="dt-roaming"/> or
                           <termref def="dt-free-ranging"/>. There are no other constraints on the
                        node supplied in the input sequence.</p>
                  </example>
               </div4>
            </div3>
            <div3 id="classifying-attribute-sets">
               <head>Classifying Attribute Sets</head>
               <p diff="chg" at="T-bug29492">The <termref def="dt-posture"/> of an <termref
                     def="dt-attribute-set"/> is always <termref def="dt-grounded"/> (its result can
                  never return streamed nodes).</p>
               <p diff="chg" at="T-bug29492">The <termref def="dt-sweep"/> of an <termref
                     def="dt-attribute-set"/> is <termref def="dt-motionless"/> if all the following
                  conditions hold:</p>
               <olist>
                  <item>
                     <p>Every <elcode>xsl:attribute</elcode> instruction within the declarations
                        comprising the attribute set is <termref def="dt-motionless"/> when assessed
                        as described in <specref ref="streamability-of-attribute-sets"/>, using a
                           <termref def="dt-context-posture"/> of <termref def="dt-striding"/>.</p>
                  </item>
                  <item>
                     <p>Every attribute set referenced in the <code>use-attribute-sets</code>
                        attribute of an <elcode>xsl:attribute-set</elcode> declaration of the
                        attribute set has the attribute <code>streamable="yes"</code>.</p>
                  </item>
                  <item>
                     <p/>
                  </item>
               </olist>
               <p diff="chg" at="T-bug29492">If the <termref def="dt-sweep"/> of an <termref
                     def="dt-attribute-set"/> is not <termref def="dt-motionless"/> then it is
                     <termref def="dt-free-ranging"/>.</p>
               <note>
                  <p diff="add" at="Q">Attribute sets will always be <termref def="dt-grounded"/>,
                     because they return newly constructed attribute nodes.</p>
                  <p>Attribute sets will very often be <termref def="dt-motionless"/>, but if they
                     access the context item, they may be <termref def="dt-free-ranging"/>. <phrase
                        diff="chg" at="T-bug29492">Although some attribute sets could theoretically
                        be classified as <termref def="dt-consuming"/>, this option has been
                        excluded because it is unlikely to be useful; given the requirement to
                        create attributes whose values are obtained by reading a streamed input
                        document, use of a streamable <termref def="dt-template-rule"/> is a more
                        versatile approach.</phrase></p>
                  <p diff="add" at="Q">Because attribute sets can be overridden in another <termref
                        def="dt-package"/>, the streamability of a construct such as an
                        <elcode>xsl:element</elcode> instruction containing a
                        <code>use-attribute-sets</code> attribute is based on the declared
                     streamability of the named attribute sets, as defined by the
                        <code>streamable</code> attribute of the <elcode>xsl:attribute-set</elcode>
                     element. If <code>streamable="yes"</code> is specified, then there is a
                     requirement that any overriding attribute set should also specify
                        <code>streamable="yes"</code>, and a streaming processor is required to
                     check that an attribute set containing such a declaration does in fact satisfy
                     the streamability rules.</p>
               </note>
            </div3>
            <div3 id="classifying-vts">
               <head>Classifying Value Templates</head>
               <p>A <termref def="dt-value-template">value template</termref> (that is, an <termref
                     def="dt-attribute-value-template"/> or <termref def="dt-text-value-template"/>)
                  is a <termref def="dt-construct"/> whose operands are the expressions contained
                  within curly brackets. The required type for this operand role is
                     <code>xs:string</code> and the <termref def="dt-operand-usage">usage</termref>
                  is <termref def="dt-absorption"/>.</p>
               <p>The <termref def="dt-sweep"/> and <termref def="dt-posture"/> of a value template
                  are determined using the general rules in <specref
                     ref="general-streamability-rules"/>.</p>
               <p>If there are no expressions contained within curly brackets, the value template is
                     <termref def="dt-motionless"/>.</p>
            </div3>
            <div3 id="classifying-expressions">
               <head>Classifying Expressions</head>
               <p>XPath expressions are classified using the rules in this section.</p>
               <p>In the analysis that follows, <termref def="dt-expression">expressions</termref>
                  are classified according to the most specific production rule that they match for
                  which there is an entry in this section. A production <var>P</var> is considered
                  more specific than a production <var>Q</var> (<var>Q</var> ≠ <var>P</var>) if
                  every expression that matches <var>P</var> also matches <var>Q</var>. For
                  example:</p>
               <ulist>
                  <item>
                     <p>The expression <code>3</code> satisfies the productions
                           <code>NumericLiteral</code>, <code>Literal</code>, and
                           <code>ArithmeticExpression</code>; the most specific of these for which
                        there is an entry in this section is <code>Literal</code>.</p>
                  </item>
                  <item diff="add" at="R-bug24541">
                     <p>The expression <code>text()</code> (appearing as an expression) is a
                           <code>TextTest</code>, and therefore a <code>KindTest</code>, which is
                        itself a <code>NodeTest</code>, and therefore an <code>AxisStep</code> with
                        a defaulted <code>ForwardAxis</code>. The most specific of these for which
                        there is an entry in this section is <code>AxisStep</code>. Although the
                        expression is also a <code>RelativePathExpr</code>, that production is less
                        specific than <code>AxisStep</code> so its rules do not apply.</p>
                  </item>
                  <item diff="add" at="R-bug24541">
                     <p>The expression <code>section/title</code> is a
                        <code>RelativePathExpr</code>, for which there is an entry in this section.
                        Although the expression is also a <code>PathExpr</code>, that production is
                        less specific than <code>RelativePathExpr</code> so its rules do not
                        apply.</p>
                  </item>
               </ulist>
               <p>The production rules for different kinds of expression are listed (with their
                  names and numbers) in the order in which they appear in Appendix A.1 of the XPath
                  3.0 specification<phrase diff="add" at="S-bug29229">; rules are also given for new
                     constructs introduced by XPath 3.1</phrase>. <phrase diff="add" at="T-bug29340"
                     >Where two numbers are given, they are the production rule numbers in XPath 3.0
                     and XPath 3.1 respectively; where there is a single number, it is the
                     production rule number in XPath 3.1.</phrase></p>
               <p>Many expressions can be analyzed using the <termref
                     def="dt-general-streamability-rules"/>. These are indicated in the table below
                  by means of a simple proforma in which the <termref def="dt-operand-role">operand
                     roles</termref> are represented by a short code (A = <termref
                     def="dt-absorption"/>, I = <termref def="dt-inspection"/>, T = <termref
                     def="dt-transmission"/>, N = <termref def="dt-navigation"/>). For example the
                  proforma <code>A + A</code> indicates that for an arithmetic expression, both
                  operands have <termref def="dt-operand-usage"/>
                  <termref def="dt-absorption"/>, while <code>I or I</code> indicates that for an
                     <code>or</code> expression, both operands have <termref def="dt-operand-usage"/>
                  <termref def="dt-inspection"/>. For expressions where further explanation is
                  needed, the table contains a link to the relevant section.</p>
               <table class="data">
                  <caption>Operand Roles for XPath Expressions</caption>
                  <thead>
                     <tr>
                        <th rowspan="1" colspan="1">Construct</th>
                        <th rowspan="1" colspan="1">Proforma or Reference to Detailed Rules</th>
                        <th rowspan="1" colspan="1">Further Information</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td rowspan="1" colspan="1">Expr [6,6] </td>
                        <td rowspan="1" colspan="1"><code>T, T</code></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">ForExpr [8,8] </td>
                        <td rowspan="1" colspan="1">See <specref
                              ref="streamability-of-for-expressions"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">LetExpr [11,11] </td>
                        <td rowspan="1" colspan="1"><code>let $var := N return T</code></td>
                        <td rowspan="1" colspan="1">Binding of variables to streamed nodes is not
                           allowed.</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">QuantifiedExpr [14,14]</td>
                        <td rowspan="1" colspan="1">See <specref
                              ref="streamability-of-quantified-expressions"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">IfExpr [15,15] </td>
                        <td rowspan="1" colspan="1"><phrase diff="chg" at="Q"><code>if (I) then T
                                 else T</code></phrase></td>
                        <td rowspan="1" colspan="1">The then-clause and else-clause form a <termref
                              def="dt-choice-operand-group"/> with usage <termref
                              def="dt-transmission"/></td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">OrExpr [16,16]</td>
                        <td rowspan="1" colspan="1"><code>I or I</code></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">AndExpr [17,17]</td>
                        <td rowspan="1" colspan="1"><code>I and I</code></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">StringConcatExpr [19,19]</td>
                        <td rowspan="1" colspan="1"><code>A || A</code></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">RangeExpr [20,20]</td>
                        <td rowspan="1" colspan="1"><code>A to A</code></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">AdditiveExpr [21,21]</td>
                        <td rowspan="1" colspan="1"><code>A + A</code>, <code>A - A</code></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">MultiplicativeExpr [22,22]</td>
                        <td rowspan="1" colspan="1"><code>A * A</code>, <code>A div A</code>,
                           etc.</td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">UnionExpr [23,23] </td>
                        <td rowspan="1" colspan="1">See <specref
                              ref="streamability-of-union-expressions"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">IntersectExceptExpr [24,24] </td>
                        <td rowspan="1" colspan="1">See <specref
                              ref="streamability-of-union-expressions"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">InstanceOfExpr [25,25]</td>
                        <td rowspan="1" colspan="1">See <specref
                              ref="streamability-of-instance-of-expressions"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">TreatExpr [26,26]</td>
                        <td rowspan="1" colspan="1">See <specref
                              ref="streamability-of-treat-as-expressions"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">CastableExpr [27,27]</td>
                        <td rowspan="1" colspan="1"><code>A castable as TYPE</code></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">CastExpr [28,28] </td>
                        <td rowspan="1" colspan="1"><code>A cast as TYPE</code></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">UnaryExpr [29,30]</td>
                        <td rowspan="1" colspan="1"><code>+A</code>, <code>-A</code></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">GeneralComp [31,32]</td>
                        <td rowspan="1" colspan="1"><code>A = A</code>, <code>A &lt; A</code>,
                              <code>A != A</code>, etc.</td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">ValueComp [32,33]</td>
                        <td rowspan="1" colspan="1"><code>A eq A</code>, <code>A lt A</code>,
                              <code>A ne A</code>, etc.</td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">NodeComp [33,34]</td>
                        <td rowspan="1" colspan="1"><phrase diff="chg" at="Q"><code>I is I</code>,
                                 <code>I &lt;&lt; I</code>, <code>I &gt;&gt; I</code></phrase></td>
                        <td rowspan="1" colspan="1"><phrase diff="add" at="R-bug24531">See Note 1
                              below</phrase></td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">SimpleMapExpr [34,35] </td>
                        <td rowspan="1" colspan="1">See <specref
                              ref="streamability-of-simple-mapping-expressions"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">PathExpr [35,36] </td>
                        <td rowspan="1" colspan="1">See <specref
                              ref="streamability-of-path-expressions"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">RelativePathExpr [36,37] </td>
                        <td rowspan="1" colspan="1">See <specref
                              ref="streamability-of-path-expressions"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">AxisStep [38,39] </td>
                        <td rowspan="1" colspan="1">See <specref ref="streamability-of-axis-steps"
                           /></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">ForwardStep [39,40], ReverseStep [42,43]</td>
                        <td rowspan="1" colspan="1">See <specref ref="streamability-of-axis-steps"
                           /></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">PostfixExpr [48,49]: Filter Expression</td>
                        <td rowspan="1" colspan="1">See <specref
                              ref="streamability-of-filter-expressions"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">PostfixExpr [48,49]: Dynamic Function Call</td>
                        <td rowspan="1" colspan="1">See <specref
                              ref="streamability-of-dynamic-function-calls"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">Literal [53,57]</td>
                        <td rowspan="1" colspan="1"/>
                        <td rowspan="1" colspan="1">There are no operands, so the construct is
                              <termref def="dt-grounded"/> and <termref def="dt-motionless"/></td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">VarRef [55,59]</td>
                        <td rowspan="1" colspan="1">See <specref
                              ref="streamability-of-variable-references"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="2" colspan="1">ParenthesizedExpr [57,61]</td>
                        <td rowspan="1" colspan="1"><code>(T)</code></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1"><code>()</code></td>
                        <td rowspan="1" colspan="1">There are no operands, so the construct is
                              <termref def="dt-grounded"/> and <termref def="dt-motionless"/></td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">ContextItemExpr [58,62]</td>
                        <td rowspan="1" colspan="1">See <specref
                              ref="streamability-of-context-item-expression"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">FunctionCall [59,63]</td>
                        <td rowspan="1" colspan="1">See <specref
                              ref="streamability-of-function-calls"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">NamedFunctionRef [63,67]</td>
                        <td rowspan="1" colspan="1"><phrase diff="chg" at="Q">See <specref
                                 ref="streamability-of-named-function-ref"/></phrase></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">InlineFunctionExpr [64,68] </td>
                        <td rowspan="1" colspan="1"><phrase diff="chg" at="Q">See <specref
                                 ref="streamability-of-inline-functions"/></phrase></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">MapConstructor <phrase diff="add"
                              at="T-bug29340">[–,69]</phrase></td>
                        <td rowspan="1" colspan="1">See <specref
                              ref="streamability-of-map-constructors"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td diff="add" at="S-bug29229" rowspan="1" colspan="1">Lookup (Postfix
                              <phrase diff="add" at="T-bug29340">[–,49]</phrase> and Unary <phrase
                              diff="add" at="T-bug29340">[–,53]</phrase>)</td>
                        <td diff="add" at="S-bug29229" rowspan="1" colspan="1">See <specref
                              ref="streamability-of-lookup-expressions"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td diff="add" at="S-bug29229" rowspan="1" colspan="1">ArrowExpr <phrase
                              diff="add" at="T-bug29340">[–,29]</phrase></td>
                        <td diff="add" at="S-bug29229" rowspan="1" colspan="1">See <specref
                              ref="streamability-of-function-calls"/>
                           <phrase diff="add" at="T-bug29459">and <specref
                                 ref="streamability-of-dynamic-function-calls"/></phrase>: the rules
                           for <code>X =&gt; F(Y, Z)</code> are the same as the rules for <code>F(X,
                              Y, Z)</code></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td diff="add" at="S-bug29229" rowspan="1" colspan="1"
                           >SquareArrayConstructor <phrase diff="add" at="T-bug29340"
                              >[–,74]</phrase></td>
                        <td diff="add" at="S-bug29229" rowspan="1" colspan="1"><code>[N, N,
                              ...]</code></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td diff="add" at="S-bug29229" rowspan="1" colspan="1">CurlyArrayConstructor
                              <phrase diff="add" at="T-bug29340">[–,75]</phrase></td>
                        <td diff="add" at="S-bug29229" rowspan="1" colspan="1"><code>array{N, N,
                              ...}</code></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                  </tbody>
               </table>
               <note diff="add" at="R-bug24531">
                  <olist>
                     <item>
                        <p> The operators <code>is</code>, <code>&lt;&lt;</code>, and
                              <code>&gt;&gt;</code> apply to streamed nodes just as to any other
                           nodes, though there are few practical situations where they will be
                           useful. A streamed document conforms to the rules of the XDM data model,
                           and its nodes are therefore distinct and ordered. They follow the usual
                           rules, for example that a parent node precedes its children in document
                           order. Expressions such as <code>.. is parent::X</code> or
                              <code>ancestor::x[1] &lt;&lt; ancestor::y[1]</code> are therefore
                           perfectly meaningful. The usefulness of the operators is limited by the
                           fact that variables cannot be bound to nodes in a streamed document. It
                           is permitted, though perhaps not useful, for one of the operands to be
                              <termref def="dt-consuming"/>: one can write <code>. &lt;&lt;
                              child::x</code>, and the resulting expression is (by applying the
                           general rules) <termref def="dt-consuming"/> and grounded.</p>
                        <p>The restriction that variables cannot be bound to streamed nodes prevents
                           writing of expressions such as <code>let $x := . return
                              descendant::x[ancestor::y[1] is $x]</code>. As a workaround, the
                           intended effect can be achieved by comparing node identity using the
                              <xfunction>generate-id</xfunction> function: <code>let $x :=
                              generate-id(.) return descendant::x[generate-id(ancestor::y[1]) =
                              $x]</code></p>
                     </item>
                  </olist>
               </note>
               <div4 id="streamability-of-for-expressions" diff="chg" at="Q">
                  <head>Streamability of <code>for</code> Expressions</head>
                  <p>Writing the expression as <code>for $v in S return R</code>, the two operand
                     roles are <var>S</var> and <var>R</var>.</p>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> are determined by
                     the first of the following that applies:</p>
                  <olist>
                     <item>
                        <p>If <var diff="chg" at="S-bug28192">S</var> is not <termref
                              def="dt-grounded"/><phrase diff="del" at="Q">and <termref
                                 def="dt-motionless"/></phrase>, then <termref def="dt-roaming"/>
                           and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item diff="del" at="Q">
                        <p>If the <termref def="dt-sweep"/> of <var>S</var> is caller-determined,
                           then <termref def="dt-roaming"/> and <termref def="dt-free-ranging"
                           />.</p>
                     </item>
                     <item>
                        <p>Otherwise, the <termref def="dt-general-streamability-rules"/> apply. The
                           operand roles are:</p>
                        <olist>
                           <item>
                              <p>The <code>in</code> expression (<code>S</code>). This has <termref
                                    def="dt-operand-usage">usage</termref>
                                 <termref def="dt-navigation"/>.</p>
                           </item>
                           <item>
                              <p>The <code>return</code> expression (<code>R</code>). This is a
                                    <termref def="dt-higher-order-operand"/> with <termref
                                    def="dt-operand-usage">usage</termref>
                                 <termref def="dt-transmission"/>.</p>
                           </item>
                        </olist>
                     </item>
                  </olist>
                  <note>
                     <p>Expressions of the form <code>for $i in 1 to 3 return $i*2</code>, where
                        there is no reference to a streamed node, are clearly streamable.</p>
                     <p>The <code>in</code> expression can also be <termref def="dt-consuming"/>,
                        for example <code>for $e in copy-of(emp) return $e/salary</code>.</p>
                     <p>The rule that <var diff="chg" at="S-bug28192">S</var> must be grounded
                        prevents the variable being bound to a node in a streamed document. This
                        disallows expressions of the form <code>for $x in child::section return
                           $x/para</code>, because this requires data flow analysis (tracing from
                        the binding of a variable to its usages), rather than purely syntactic
                        analysis. Some implementations may be able to stream such constructs.</p>
                     <p>The fact that the return clause is a higher-order operand prevents it from
                        being a <termref def="dt-consuming"/> expression, for example <code>for $i
                           in 1 to 3 return salary</code>. Use of a motionless expression that
                        accesses streamed nodes is however allowed, for example <code>for $i in 1 to
                           3 return name(ancestor::x[$i])</code>.</p>
                  </note>
               </div4>
               <div4 id="streamability-of-quantified-expressions" diff="chg" at="R-bug26752">
                  <head>Streamability of Quantified Expressions</head>
                  <p>An expression with multiple in-clauses is first rewritten using nested
                     quantified expressions: for example <code>some $i in X, $j in Y satisfies $i eq
                        $j</code> can be rewritten as <code>some $i in X satisfies (some $j in Y
                        satisfies $i eq $j)</code>. The analysis therefore only needs to consider
                     expressions with a single in-clause.</p>
                  <p>Writing such an expression as <code>some|every $v in S satisfies C</code>, the
                     two operand roles are <var>S</var> and <var>C</var>.</p>
                  <p>The <termref def="dt-general-streamability-rules"/> apply. The <termref
                        def="dt-operand-role">operand roles</termref> are:</p>
                  <olist>
                     <item>
                        <p>The <code>in</code> expression (<var>S</var>). This has usage <termref
                              def="dt-navigation"/>.</p>
                     </item>
                     <item>
                        <p>The <code>satisfies</code> expression (<var>C</var>). This is a <termref
                              def="dt-higher-order-operand"/> with usage <termref
                              def="dt-inspection"/>.</p>
                     </item>
                  </olist>
                  <note>
                     <p>Expressions of the form some <code>$i in 1 to 3 satisfies $i lt 2</code>,
                        where there is no reference to a streamed node, are clearly streamable. </p>
                     <p>The expression <var>S</var> can be <termref def="dt-consuming"/>, so long as
                        it is grounded: for example <code>some $e in emp/salary/number(.) satisfies
                           $e gt 10000</code>. </p>
                     <p>The rule that <var>S</var> has usage <termref def="dt-navigation"/> prevents
                        the variable being bound to a node in a streamed document. This disallows
                        expressions of the form <code>some $x in child::section satisfies
                           has-children($x)</code>, because this requires data flow analysis
                        (tracing from the binding of a variable to its usages), rather than purely
                        syntactic analysis. Some implementations may be able to stream such
                        constructs. </p>
                     <p>The fact that <var>C</var> is a higher-order operand prevents it from being
                        a <termref def="dt-consuming"/> expression: for example <code>some $i in 1
                           to 3 satisfies author[$i] eq "Kay"</code> is not streamable. Use of a
                        motionless expression that accesses streamed nodes is however allowed, for
                        example <code>some $i in 1 to 3 satisfies @grade = $i</code>. </p>
                     <p>Quantified expressions that fail the streamability rules can often be
                        rewritten as filter expressions. For example, the expression <code>some $x
                           in child::section satisfies has-children($x)</code> can be rewritten as
                           <code>exists(child::section[has-children(.)])</code>, which is grounded
                        and <termref def="dt-consuming"/>. </p>
                  </note>
               </div4>
               <div4 id="streamability-of-if-expressions">
                  <head>Streamability of <code>if</code> expressions</head>
                  <p>Writing the expression as <code>if (C) then T else E</code>, there are three
                     operand roles: <var>C</var>, <var>T</var>, and <var>E</var>. The <termref
                        def="dt-operand-usage">usage</termref> of <var>C</var> is <termref
                        def="dt-inspection"/>, while the <termref def="dt-operand-usage"
                        >usage</termref> of <var>T</var> and <var>E</var> is <termref
                        def="dt-transmission"/>. Operands <var>T</var> and <var>E</var> form a
                        <termref def="dt-choice-operand-group"/>, meaning that they can both consume
                     the input stream, provided they have consistent <termref def="dt-posture"/>.
                     The <termref def="dt-general-streamability-rules"/> apply.</p>
               </div4>
               <div4 id="streamability-of-union-expressions" diff="chg" at="Q">
                  <head>Streamability of <code>union</code>, <code>intersect</code>, and
                        <code>except</code> Expressions</head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> are the first of
                     the following that applies:</p>
                  <olist>
                     <item>
                        <p>If either of the two operands is <termref def="dt-free-ranging"/>, then
                              <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>
                           (Example: <code>. | following-sibling::*</code>).</p>
                     </item>
                     <item>
                        <p>If either of the two operands is <termref def="dt-grounded"/> and
                              <termref def="dt-motionless"/>, then the <termref def="dt-posture"/>
                           and <termref def="dt-sweep"/> of the other operand (Example: <code>. |
                              doc('abc.com')//x</code>)</p>
                     </item>
                     <item>
                        <p diff="chg" at="R-bug24267">If both operands are <termref
                              def="dt-climbing"/>, then <termref def="dt-climbing"/> and and the
                           wider of the sweeps of the two operands (Example: <code diff="chg"
                              at="S-bug27999">parent::A | */ancestor::B</code>).</p>
                     </item>
                     <item>
                        <p>If <phrase diff="chg" at="R-bug24537">the <phrase diff="chg"
                                 at="R-bug24536">left-hand</phrase> operand is <termref
                                 def="dt-striding"/> or <termref def="dt-crawling"/> and the <phrase
                                 diff="chg" at="R-bug24536">right-hand</phrase> operand is also
                                 <termref def="dt-striding"/> or <termref def="dt-crawling"
                              /></phrase>, then <termref def="dt-crawling"/> and the wider of the
                           sweeps of the two operands (Example: <code>* | */*</code>).</p>
                     </item>
                     <item>
                        <p>Otherwise, <termref def="dt-roaming"/> and <termref def="dt-free-ranging"
                           /> (Example: <code diff="chg" at="S-bug27999">child::div |
                              parent::div</code>).</p>
                     </item>
                  </olist>
                  <note>
                     <p>Essentially the principle is that if both operands are streamable, then the
                        result is streamable (this assumes an evaluation strategy where both
                        operands are evaluated during the same pass of the streamed input document,
                        and the results merged). But there are caveats because of the need for
                        static streamability analysis of the result. This prevents constructs such
                        as <code>.. | *</code> that have heterogeneous <termref def="dt-posture"
                        />.</p>
                     <p>Where the two operands are both <termref def="dt-striding"/>, there are
                        cases where an implementation could determine that the result is also
                           <termref def="dt-striding"/>: for example <code>(author | editor)</code>.
                        In general, however, the combination of two striding operands may produce a
                        sequence of nodes that have <phrase diff="chg" at="R-bug24290"
                           >nested</phrase> subtrees (consider <code>author | author/name</code>),
                        so the result is classified as <termref def="dt-crawling"/>.</p>
                     <p>The expression <code>(author | editor)</code>, although it is not <termref
                           def="dt-striding"/>, can be rewritten in the form <code>*[self::author or
                           self::editor]</code>, which is <termref def="dt-striding"/>.</p>
                  </note>
               </div4>
               <div4 id="streamability-of-instance-of-expressions" diff="add" at="S-bug27807">
                  <head>Streamability of <code>instance of</code> Expressions</head>
                  <p>For an expression of the form <var>X</var> instance of <var>ST</var> (where
                        <var>X</var> is an expression and <var>ST</var> is a <phrase diff="chg"
                        at="S-bug29079"><termref def="dt-sequence-type"/></phrase>), the <termref
                        def="dt-posture"/> and <termref def="dt-sweep"/> are determined by the
                        <termref def="dt-general-streamability-rules"/>. There is a single operand
                        <var>X</var>, whose <termref def="dt-operand-usage"/> is as follows:</p>
                  <olist>
                     <item>
                        <p>If the <code>ItemType</code> of <var>ST</var> is a
                              <code>DocumentTest</code>, optionally parenthesized, that contains an
                              <code>ElementTest</code> or <code>SchemaElementTest</code> then
                           absorption</p>
                     </item>
                     <item>
                        <p>Otherwise, inspection.</p>
                     </item>
                  </olist>
                  <note>
                     <p>In general, it is possible to determine whether a node matches an
                           <code>ItemType</code> without consuming the node. For example it can be
                        established whether an element matches the test <code>element(para)</code>
                        when positioned at the start tag.</p>
                     <p>An <code>ItemType</code> of the form <code>document-node(element(X))</code>
                        is a exception to this rule because it matches a document node only if it
                        has exactly one element node child, and this cannot be determined without
                        consuming the document. </p>
                     <p>A processor may have knowledge that the document node cannot contain
                        multiple element nodes, for example because it knows that the source of the
                        streamed document is an XML parser that is not capable of generating such a
                        stream. In such cases the processor may make a different assessment of the
                        streamability of this construct. This comes under the general provision that
                        a processor is always at liberty to use streaming even when the stylesheet
                        is not guaranteed streamable. </p>
                  </note>
                  <note>
                     <p>As with other constructs that are evaluated with inspection usage, for
                        example the <xfunction>name</xfunction> function or access to an attribute
                        node, evaluation of a construct such as <code>$X instance of
                           schema-element(E)</code> as true or false may be invalidated if reading
                        of the input stream subsequently fails. Dynamic errors during streamed
                        processing of an input document invalidate all output generated prior to the
                        failure, and this case is no different. </p>
                  </note>
                  <note>
                     <p>Given an expression such as <code>child::* instance of element(E)*</code>,
                        the expression as a whole is <termref def="dt-consuming"/> and grounded. By
                        contrast, the expression <code>. instance of element(E)*</code> is
                        motionless and grounded. This can be verified by applying the general
                        streamability rules to these cases. </p>
                  </note>
               </div4>
               <div4 id="streamability-of-treat-as-expressions" diff="add" at="T-bug30036">
                  <head>Streamability of <code>treat as</code> Expressions</head>
                  <p/>
                  <p>For an expression of the form <var>X</var> treat as <var>ST</var> (where
                        <var>X</var> is an expression and <var>ST</var> is a <termref
                        def="dt-sequence-type"/>), the <termref def="dt-posture"/> and <termref
                        def="dt-sweep"/> are determined as follows: </p>
                  <olist>
                     <item>
                        <p>If the <code>ItemType</code> of <var>ST</var> is a
                              <code>DocumentTest</code>, optionally parenthesized, that contains an
                              <code>ElementTest</code> or <code>SchemaElementTest</code> then
                              <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p>Otherwise, the <termref def="dt-general-streamability-rules"/> apply.
                           There is a single operand <var>X</var>, whose <termref
                              def="dt-operand-usage"/> is <termref def="dt-transmission"/>.</p>
                     </item>
                  </olist>
                  <note>
                     <p>See the notes in <specref ref="streamability-of-instance-of-expressions"/>
                        for a discussion of the streamability difficulties associated with
                           <code>document-node()</code> tests.</p>
                  </note>
               </div4>
               <div4 id="streamability-of-simple-mapping-expressions">
                  <head>Streamability of Simple Mapping Expressions</head>
                  <p>The mapping operator <code>!</code> is treated as a left-associative binary
                     operator, so the expression <code>a!b!c</code> is processed as
                        <code>(a!b)!c</code>.</p>
                  <p diff="add" at="S-bug28791">The <termref def="dt-posture"/> of the expression is
                     the <termref def="dt-posture"/> of the right-hand operand, assessed with a
                        <phrase diff="chg" at="Q"><termref def="dt-context-posture"/></phrase> and
                     type set to the <termref def="dt-posture"/> and type of the <phrase diff="chg"
                        at="R-bug24536">left-hand</phrase> operand.</p>
                  <p diff="add" at="S-bug28791">The <termref def="dt-sweep"/> of the expression is
                     the wider of the <termref def="dt-sweep">sweeps</termref> of the two
                     operands.</p>
               </div4>
               <div4 id="streamability-of-path-expressions">
                  <head>Streamability of Path Expressions</head>
                  <p>The streamability analysis applies after the expansion of the <code>//</code>
                     pseudo-operator to <code>/descendant-or-self::node()/</code>, and after
                     expanding <code>..</code> to <code>parent::node()</code>, <code>@X</code> to
                        <code>attribute::X</code>, and an omitted axis to <phrase diff="chg"
                        at="S-bug27132">the default axis for the node kind</phrase>.</p>
                  <p>Following the rules in XPath, a leading <code>"/"</code> is converted to
                        <code>(root(self::node()) treat as document-node())/</code> (with the final
                        <code>"/"</code> omitted for the expression <code>"/"</code> on its own).
                     This is followed by a rewrite of the call on <xfunction>root</xfunction>, as
                     described in <specref ref="streamability-fn-root"/>.</p>
                  <note>
                     <p>Taken together, these rewrites have the effect that a path expression such
                        as <code>//a</code> is streamable only if the statically-determined context
                        item type is <code>document-node()</code>, which will be the case for
                        example immediately within <elcode>xsl:source-document</elcode>, or in a
                        template rule with <code>match="/"</code>.</p>
                  </note>
                  <p>A <code>RelativePathExpr</code> with more than two operands (such as
                        <code>a/b/c</code>) is taken as a tree of binary expressions (that is,
                        <code>(a/b)/c</code>).<phrase diff="del" at="R-bug25160"> This prevents some
                        optimizations which are possible if the <code>RelativePathExpr</code> is
                        considered as a whole: these optimizations should be applied by rewriting
                        the tree before this analysis takes place, as described in
                        [pattern-scanning].</phrase></p>
                  <p>The <termref def="dt-sweep"/> of a relative path expression is the wider
                        <termref def="dt-sweep"/> of the two operands, where the ordering of
                     increasing width is <termref def="dt-motionless"/>, <termref def="dt-consuming"
                     />, <termref def="dt-free-ranging"/>.</p>
                  <note diff="add" at="Q">
                     <p>Examples:</p>
                     <ulist>
                        <item>
                           <p>The <termref def="dt-sweep"/> of <code>a/@code</code> is <termref
                                 def="dt-consuming"/> (the wider of <termref def="dt-consuming"/>
                              and <termref def="dt-motionless"/>).</p>
                        </item>
                        <item>
                           <p>The <termref def="dt-sweep"/> of <code>a/descendant::b</code> is
                                 <termref def="dt-consuming"/> (the wider of <termref
                                 def="dt-consuming"/> and <termref def="dt-consuming"/>).</p>
                        </item>
                        <item>
                           <p>The <termref def="dt-sweep"/> of <code>./@code</code> is <termref
                                 def="dt-motionless"/> (the wider of <termref def="dt-motionless"/>
                              and <termref def="dt-motionless"/>).</p>
                        </item>
                        <item>
                           <p>The <termref def="dt-sweep"/> of <code>./a</code> is <termref
                                 def="dt-consuming"/> (the wider of <termref def="dt-motionless"/>
                              and <termref def="dt-consuming"/>).</p>
                        </item>
                        <item>
                           <p>The <termref def="dt-sweep"/> of <code>a/following::b</code> is
                                 <termref def="dt-free-ranging"/> (the wider of <termref
                                 def="dt-consuming"/> and <termref def="dt-free-ranging"/>).</p>
                        </item>
                        <item>
                           <p>The <termref def="dt-sweep"/> of <code>./.</code> is <termref
                                 def="dt-motionless"/> (the wider of <termref def="dt-motionless"/>
                              and <termref def="dt-motionless"/>).</p>
                        </item>
                     </ulist>
                  </note>
                  <p diff="add" at="R-bug25160">The <termref def="dt-posture"/> of a relative path
                     expression is assessed in two phases, as follows:</p>
                  <olist>
                     <item>
                        <p>First, the provisional <termref def="dt-posture"/> is determined as
                           follows: The provisional <termref def="dt-posture"/> of the expression is
                           the <termref def="dt-posture"/> of the right-hand operand, assessed with
                           a <phrase diff="chg" at="Q"><termref def="dt-context-posture"/></phrase>
                           and type set to the <termref def="dt-posture"/> and type of the <phrase
                              diff="chg" at="R-bug24536">left-hand</phrase> operand; and the
                           provisional sweep is the wider of the sweeps of the two operands.</p>
                     </item>
                     <item diff="add" at="R-bug25160">
                        <p>If the provisional <termref def="dt-posture"/> is <phrase diff="chg"
                              at="S-bug27133"><termref def="dt-roaming"/></phrase>, then it is
                           reassessed as follows:</p>
                        <olist>
                           <item diff="chg" at="T-bug29983">
                              <p><termdef id="dt-scanning-expression" term="scanning expression">A
                                       <code>RelativePathExpr</code> is a <term>scanning
                                       expression</term> if and only if it is syntactically
                                    equivalent to some <termref def="dt-motionless"/>
                                    <termref def="dt-pattern"/>.</termdef></p>
                              <note>
                                 <p>This means that a <code>RelativePathExpr</code> is a
                                       <term>scanning expression</term> if it conforms to the
                                    grammar for a <code>RelativePathExprP</code> in the grammar for
                                    patterns (see <specref ref="pattern-syntax"/>), and if, when
                                    considered as a pattern, the pattern is motionless according to
                                    the rules in <specref ref="classifying-patterns"/>.</p>
                                 <p>In practice, the test as to whether the construct is equivalent
                                    to a pattern is likely to be made by examining the structure of
                                    the expression tree, rather than by re-parsing the lexical form
                                    of the expression against the grammar for patterns; but the
                                    outcome is the same.</p>
                              </note>
                           </item>
                           <item diff="chg" at="S-bug27051">
                              <p>If the expression is a <term>scanning expression</term> then:</p>
                              <olist>
                                 <item>
                                    <p>If the static type of the expression contains
                                          <code>U{element}</code> then its <termref def="dt-posture"
                                       /> is <termref def="dt-crawling"/>.</p>
                                 </item>
                                 <item>
                                    <p>Otherwise, its <termref def="dt-posture"/> is <termref
                                          def="dt-striding"/></p>
                                 </item>
                              </olist>
                           </item>
                        </olist>
                     </item>
                     <item>
                        <p>Otherwise (if the provisional <termref def="dt-posture"/> is not <phrase
                              diff="chg" at="S-bug27133"><termref def="dt-roaming"/></phrase>, or
                           the expression is not a <term>scanning expression</term>), the <termref
                              def="dt-posture"/> of the expression is the provisional <termref
                              def="dt-posture"/>.</p>
                     </item>
                  </olist>
                  <note diff="chg" at="T-bug29983">
                     <p>The special rules for scanning expressions are designed to ensure that
                        expressions such as <code>//section/head</code> are streamable. The problem
                        with such an expression is that it is possible to have two nested sections
                           <var>A</var> and <var>B</var>, where <var>A</var> is the parent of
                           <var>B</var> and thus precedes <var>B</var> in document order, but where
                        there are children of <var>A</var> that come <emph>after</emph> children of
                           <var>B</var> in document order. This means that a nested-loop strategy
                        for the evaluation of <code>/descendant::section/child::head</code> is not
                        guaranteed to deliver nodes in document order without a sort, and is
                        therefore not a viable strategy for streaming.</p>
                     <p>However, there is a different strategy for evaluating such an expression,
                        which is in effect to rewrite the expression as
                           <code>/descendant::head[parent::section]</code>; specifically, it is
                        possible to scan all descendants in document order, looking for a
                           <code>head</code> element that has a <code>section</code> parent. Hence
                        the term <term>scanning expressions</term>.</p>
                     <p>The expressions that qualify as scanning expressions are paths that can be
                        evaluated by scanning all descendants and testing each one (independently)
                        to see whether the elements on its ancestor axis match the specified path.
                        The subset of expressions that qualify as scanning expressions is therefore
                        the same as the subset that qualify as motionless patterns.</p>
                     <p>Scanning expressions cannot use positional predicates: for example
                           <code>//section/head[1]</code> is not recognized as a scanning expression
                        because this would require information about a streamed node (specifically,
                        about its preceding siblings) that is not retained during streaming. </p>
                  </note>
                  <note diff="add" at="U-bug30064">
                     <p>Perhaps surprisingly, the expression <code>.//section/head</code> is not a
                        scanning expression and is therefore not guaranteed streamable. This is
                        because it does not take the syntactic form of a <termref def="dt-pattern"
                        />. To make it streamable, it can be rewritten as
                           <code>descendant::section/head</code> or as
                           <code>self::node()//section/head</code>.</p>
                     <p>Similarly, within a streamable stylesheet function whose <termref
                           def="dt-streaming-parameter"/> is <code>$node</code>, the expression
                           <code>$node//section/head</code> is not a scanning expression. In this
                        case the expression does have the syntactic form of a pattern, but the
                        pattern is not classified as motionless. (See <specref
                           ref="classifying-patterns"/> — a motionless pattern cannot contain a
                           <code>RootedPath</code>.) A workaround in this case is to rewrite the
                        expression as <code>$node/(descendant::section/head)</code>. Assuming that
                        the function in question declares <code>streamability="absorbing"</code>,
                        the analysis here is that the left-hand operand (<code>$node</code>) is
                        striding and consuming, while the right hand operand
                           (<code>descendant::section/head</code>) is crawling and consuming
                        (because it is a scanning expression). The expression as a whole is
                        therefore crawling and consuming.</p>
                     <p>These are cases where an implementation might reasonably choose to relax the
                        rules, insofar as this is permitted by <specref
                           ref="streamability-guarantees"/>.</p>
                  </note>
                  <note>
                     <p>Examples:</p>
                     <p>In each of the following cases, assume that the <termref
                           def="dt-context-posture"/> is striding.</p>
                     <ulist>
                        <item>
                           <p>The <termref def="dt-posture"/> of the expression <code>a/b/c</code>
                              is striding, because (under the rules for AxisStep [38]) a child axis
                              step evaluated with striding context <termref def="dt-posture"/>
                              creates a new striding posture.</p>
                        </item>
                        <item>
                           <p>The posture of the expression <code>a/descendant::c</code> is
                              crawling, because a descendant axis step evaluated with striding
                              context posture creates a new crawling posture.</p>
                        </item>
                        <item>
                           <p diff="chg" at="S-bug27051">The posture of the expression
                                 <code>../@status</code> is striding, because a parent axis step
                              evaluated with striding context posture creates a new climbing
                              posture, and an attribute axis step evaluated with climbing context
                              posture creates a new striding posture.</p>
                        </item>
                        <item>
                           <p>The posture of the expression
                                 <code>copy-of(.)//a/following-sibling::*</code> is grounded,
                              because the <function>copy-of</function> evaluated with striding
                              posture creates a grounded posture, and all subsequent axis steps
                              leave this posture unchanged.</p>
                        </item>
                        <item>
                           <p diff="add" at="25160">The expression <code>section//head</code>
                              expands to
                                 <code>(section/descendant-or-self::node())/child::head</code>. The
                              posture of the left-hand operand
                                 <code>section/descendant-or-self::node()</code> is crawling,
                              because a descendant axis step evaluated with striding context posture
                              creates a new crawling posture. The provisional posture of the
                              expression as a whole is therefore <phrase diff="chg" at="S-bug27133"
                                    ><termref def="dt-roaming"/></phrase>, because a child axis step
                              evaluated with crawling context posture gives a resulting <phrase
                                 diff="chg" at="S-bug27133">roaming</phrase> posture. However,
                                 <phrase diff="chg" at="T-bug29983">the expression is a scanning
                                 expression (both <code>section//head</code> and its expansion are
                                 motionless patterns)</phrase>, so the expression as a whole has
                              crawling posture. </p>
                        </item>
                        <item>
                           <p diff="add" at="25160">The expression <code>section//head[1]</code> is
                              free-ranging: unlike the previous example, it contains a positional
                              predicate, which means that the operands do not satisfy the rules for
                              scanning expressions. </p>
                        </item>
                     </ulist>
                  </note>
               </div4>
               <div4 id="streamability-of-axis-steps">
                  <head>Streamability of Axis Steps</head>
                  <p>The <termref def="dt-sweep"/> and <termref def="dt-posture"/> of an AxisStep
                        <var>S</var> are determined by the first of the following rules that
                     applies:</p>
                  <olist>
                     <item>
                        <p>If the <phrase diff="chg" at="Q"><termref def="dt-context-posture"
                              /></phrase> is <termref def="dt-grounded"/>, then the sweep is
                              <termref def="dt-motionless"/> and the posture is <termref
                              def="dt-grounded"/>;</p>
                     </item>
                     <item>
                        <p>If the <phrase diff="chg" at="Q"><termref def="dt-context-posture"
                              /></phrase> is <termref def="dt-roaming"/>, then the sweep is <termref
                              def="dt-free-ranging"/> and the posture is <termref def="dt-roaming"
                           />;</p>
                     </item>
                     <item>
                        <p>If the statically-inferred <termref def="dt-context-item-type"/> is such
                           that the axis will always be empty (for example, applying the child axis
                           to a text node or the parent axis to a document node), <phrase diff="add"
                              at="R-bug24542">or if the <code>NodeTest</code> is one that can never
                              select nodes on the chosen axis (for example, selecting attribute
                              nodes on the child axis),</phrase> then the sweep is <termref
                              def="dt-motionless"/> and the posture is <termref def="dt-grounded"/>
                           (because the expression is statically known to return an empty
                           sequence);</p>
                     </item>
                     <item diff="add" at="R-bug25316">
                        <p>If all the following conditions are satisfied:</p>
                        <olist>
                           <item>
                              <p>The <termref def="dt-context-posture"/> is <termref
                                    def="dt-striding"/></p>
                           </item>
                           <item>
                              <p>The axis is <code>descendant</code> or
                                    <code>descendant-or-self</code></p>
                           </item>
                           <item>
                              <p>There is a predicate <var>P</var> in the <code>PredicateList</code>
                                 that satisfies all the following conditions:</p>
                              <olist>
                                 <item>
                                    <p>The static type of <var>P</var> is a subtype of
                                          <code>U{xs:decimal, xs:double, xs:float}</code></p>
                                 </item>
                                 <item>
                                    <p>Neither <var>P</var>, nor any operand of <var>P</var>, at any
                                       depth provided it has the AxisStep <var>S</var> as its
                                          <termref def="dt-focus-setting-container"/>, is a context
                                       item expression, an axis expression, or a call on a
                                       focus-dependent function;</p>
                                 </item>
                              </olist>
                           </item>
                        </olist>
                        <p>then <termref def="dt-striding"/> and <termref def="dt-consuming"/></p>
                        <note>
                           <p>Examples are <code>descendant::section[1]</code>,
                                 <code>descendant::section[$i+1]</code>,
                                 <code>descendant::section[count($x)]</code>. The significance of
                              this rule is that it detects cases where the descendant axis selects a
                              singleton, and where the posture of the result can therefore be
                                 <termref def="dt-striding"/> rather than <phrase diff="chg"
                                 at="S-bug28233"><termref def="dt-crawling"/></phrase>.</p>
                        </note>
                     </item>
                     <item>
                        <p>If the <code>PredicateList</code> contains a <code>Predicate</code> that
                           is not <termref def="dt-motionless"/>, then the sweep is <termref
                              def="dt-free-ranging"/> and the posture is <termref def="dt-roaming"
                           />;</p>
                     </item>
                     <item>
                        <p>Otherwise, the <termref def="dt-sweep"/> and <termref def="dt-posture"/>
                           of the expression are as determined by the table below, based on the
                              <phrase diff="chg" at="Q"><termref def="dt-context-posture"
                           /></phrase>, the choice of axis, and the node test. The condition
                           “Selects elements?” is true if the <termref def="dt-utype"/> of
                              <var>S</var> has a non-empty intersection with
                           <var>U{element()}</var>.</p>
                        <table class="data">
                           <caption>Streamability of Axis Steps Based on Context Posture</caption>
                           <thead>
                              <tr>
                                 <th rowspan="1" colspan="1">Context posture</th>
                                 <th rowspan="1" colspan="1">Axis</th>
                                 <th diff="chg" at="S-bug27051" rowspan="1" colspan="1">Selects
                                    elements?</th>
                                 <th rowspan="1" colspan="1">Result posture</th>
                                 <th rowspan="1" colspan="1">Sweep</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr>
                                 <td rowspan="1" colspan="1">Grounded</td>
                                 <td rowspan="1" colspan="1">any</td>
                                 <td rowspan="1" colspan="1"/>
                                 <td rowspan="1" colspan="1">Grounded</td>
                                 <td rowspan="1" colspan="1">Motionless</td>
                              </tr>
                              <tr>
                                 <td rowspan="1" colspan="1">Climbing</td>
                                 <td rowspan="1" colspan="1">self, parent, ancestor-or-self,
                                    ancestor</td>
                                 <td rowspan="1" colspan="1"/>
                                 <td rowspan="1" colspan="1">Climbing</td>
                                 <td rowspan="1" colspan="1">Motionless</td>
                              </tr>
                              <tr>
                                 <td rowspan="1" colspan="1">Climbing</td>
                                 <td rowspan="1" colspan="1">attribute, namespace</td>
                                 <td rowspan="1" colspan="1"/>
                                 <td diff="chg" at="S-bug27051" rowspan="1" colspan="1"
                                    >Striding</td>
                                 <td rowspan="1" colspan="1">Motionless</td>
                              </tr>
                              <tr>
                                 <td rowspan="1" colspan="1">Striding</td>
                                 <td rowspan="1" colspan="1"><phrase diff="add" at="Q"
                                       >parent</phrase>, ancestor-or-self, ancestor</td>
                                 <td rowspan="1" colspan="1"/>
                                 <td rowspan="1" colspan="1">Climbing</td>
                                 <td rowspan="1" colspan="1">Motionless</td>
                              </tr>
                              <tr>
                                 <td rowspan="1" colspan="1">Striding</td>
                                 <td rowspan="1" colspan="1">self, attribute, namespace</td>
                                 <td rowspan="1" colspan="1"/>
                                 <td diff="chg" at="S-bug27051" rowspan="1" colspan="1"
                                    >Striding</td>
                                 <td rowspan="1" colspan="1">Motionless</td>
                              </tr>
                              <tr>
                                 <td rowspan="1" colspan="1">Striding</td>
                                 <td rowspan="1" colspan="1">child</td>
                                 <td rowspan="1" colspan="1"/>
                                 <td rowspan="1" colspan="1">Striding</td>
                                 <td rowspan="1" colspan="1">Consuming</td>
                              </tr>
                              <tr>
                                 <td rowspan="1" colspan="1">Striding</td>
                                 <td rowspan="1" colspan="1">descendant, descendant-or-self</td>
                                 <td rowspan="1" colspan="1">Yes</td>
                                 <td rowspan="1" colspan="1">Crawling</td>
                                 <td rowspan="1" colspan="1">Consuming</td>
                              </tr>
                              <tr>
                                 <td rowspan="1" colspan="1">Striding</td>
                                 <td rowspan="1" colspan="1">descendant, descendant-or-self</td>
                                 <td diff="chg" at="S-bug27051" rowspan="1" colspan="1">No</td>
                                 <td diff="chg" at="S-bug27051" rowspan="1" colspan="1"
                                    >Striding</td>
                                 <td rowspan="1" colspan="1">Consuming</td>
                              </tr>
                              <tr>
                                 <td rowspan="1" colspan="1">Crawling</td>
                                 <td rowspan="1" colspan="1"><phrase diff="add" at="Q"
                                       >parent</phrase>, ancestor-or-self, ancestor</td>
                                 <td rowspan="1" colspan="1"/>
                                 <td rowspan="1" colspan="1">Climbing</td>
                                 <td rowspan="1" colspan="1">Motionless</td>
                              </tr>
                              <tr>
                                 <td rowspan="1" colspan="1">Crawling</td>
                                 <td rowspan="1" colspan="1">attribute, namespace</td>
                                 <td rowspan="1" colspan="1"/>
                                 <td diff="chg" at="S-bug27051" rowspan="1" colspan="1"
                                    >Striding</td>
                                 <td rowspan="1" colspan="1">Motionless</td>
                              </tr>
                              <tr>
                                 <td rowspan="1" colspan="1">Crawling</td>
                                 <td rowspan="1" colspan="1">self</td>
                                 <td rowspan="1" colspan="1">Yes</td>
                                 <td rowspan="1" colspan="1">Crawling</td>
                                 <td rowspan="1" colspan="1">Motionless</td>
                              </tr>
                              <tr>
                                 <td rowspan="1" colspan="1">Crawling</td>
                                 <td rowspan="1" colspan="1">self</td>
                                 <td diff="chg" at="S-bug27051" rowspan="1" colspan="1">No</td>
                                 <td diff="chg" at="S-bug27051" rowspan="1" colspan="1"
                                    >Striding</td>
                                 <td rowspan="1" colspan="1">Motionless</td>
                              </tr>
                              <tr>
                                 <td colspan="2" rowspan="1">Any other combination</td>
                                 <td rowspan="1" colspan="1"/>
                                 <td rowspan="1" colspan="1">Roaming</td>
                                 <td rowspan="1" colspan="1">Free-ranging</td>
                              </tr>
                           </tbody>
                        </table>
                     </item>
                  </olist>
                  <note>
                     <p>This analysis does not attempt to classify <code>para[title]</code> as a
                           <termref def="dt-consuming"/> expression; an implementation might choose
                        to do so.</p>
                  </note>
               </div4>
               <div4 id="streamability-of-filter-expressions">
                  <head>Streamability of Filter Expressions</head>
                  <p>For a filter expression <var>F</var> of the form <code>B[P]</code> (where
                        <var>B</var> might itself be a filter expression), the <termref
                        def="dt-posture"/> and <termref def="dt-sweep"/> are the first of the
                     following that applies:</p>
                  <olist>
                     <item diff="chg" at="R-bug25316">
                        <p>If all the following conditions are satisfied:</p>
                        <olist>
                           <item>
                              <p><var>B</var> is crawling;</p>
                           </item>
                           <item>
                              <p>The static type of <var>P</var> is a subtype of <code>U{xs:decimal,
                                    xs:double, xs:float}</code>, and</p>
                           </item>
                           <item>
                              <p>Neither <var>P</var>, nor any operand of <var>P</var>, at any depth
                                 provided it has <var>F</var> as its focus-setting container, is a
                                 context item expression, an axis expression, or a call on a
                                 focus-dependent function</p>
                           </item>
                        </olist>
                        <p>then the <termref def="dt-posture"/> is <termref def="dt-striding"/> and
                           the <termref def="dt-sweep"/> is the sweep of <var>B</var>. </p>
                        <note>
                           <p>This rule captures cases where it can be statically determined that
                              the predicate is numeric and is independent of the focus. In such
                              cases, the filter expression selects at most one node, and the posture
                              can therefore be changed from crawling to striding (if there is only
                              one node, there can be no overlapping trees). Examples of filter
                              expressions that satisfy this test are <code>(//x)[3]</code>,
                                 <code>(//x)[$i+1]</code>, <code>(//x)[index-of($a,
                                 $b)[last()]]</code>, and <code>(//x)[1 to 5]</code>. The last
                              example will actually raise a type error because <code>1 to 5</code>
                              has no effective boolean value; but if expressions are going to fail,
                              it does not matter what their streamability properties are.</p>
                        </note>
                     </item>
                     <item>
                        <p>If <var>P</var> is <termref def="dt-motionless"/>, then the <termref
                              def="dt-posture"/> and <termref def="dt-sweep"/> of <var>B</var>;</p>
                        <note diff="add" at="S-bug27960">
                           <p>This includes the case where <var>B</var> is grounded. The predicate
                                 <var>P</var> is assessed with the posture of <var>B</var> as its
                              context posture, and if this is grounded, then <var>P</var> will
                              almost invariably be motionless, making the filter expression as a
                              whole grounded and motionless. For example if <code>$s</code> is
                              grounded, then <code>$s[child::*]</code> is also grounded. A
                              counter-example is the expression <code>$s[$n = 2]</code> where
                                 <code>$n</code> is a reference to the <phrase diff="chg"
                                 at="S-bug27571">first</phrase> argument of a stylesheet function
                              that is <termref def="dt-declared-streamable"/>: here the predicate is
                              not motionless, so the filter expression is roaming and
                              free-ranging.</p>
                        </note>
                     </item>
                     <item>
                        <p>Otherwise, <termref def="dt-roaming"/> and <termref def="dt-free-ranging"
                           />.</p>
                     </item>
                  </olist>
                  <note>
                     <p>The first rule allows a construct such as <code>&lt;xsl:apply-templates
                           select="(//title)[1]"/&gt;</code>, where a <termref def="dt-crawling"/>
                        operand would not be guaranteed streamable.</p>
                  </note>
                  <note>
                     <p>This section is not applicable to predicates forming part of an axis step,
                        such as <code>//title[1]</code>, as these are not technically filter
                        expressions. See <specref ref="streamability-of-axis-steps"/>.</p>
                  </note>
               </div4>
               <div4 id="streamability-of-dynamic-function-calls">
                  <head>Streamability of Dynamic Function Calls</head>
                  <note>
                     <p diff="add" at="S-bug29229">This section applies to dynamic function calls
                        written using the traditional syntax <code>$F(X, Y, Z)</code> and equally to
                        those using the new XPath 3.1 syntax <code>X =&gt; $F(Y, Z)</code></p>
                  </note>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of a dynamic
                     function call such as <code>$F(X, Y)</code> are determined by the <specref
                        ref="general-streamability-rules"/>. The operands and their usages are as
                     follows:</p>
                  <olist diff="chg" at="R-bug24500">
                     <item>
                        <p>The base expression that computes the function value itself (here
                              <code>$F</code>). This has usage <termref def="dt-inspection"/>.</p>
                     </item>
                     <item>
                        <p>The argument expressions <phrase diff="add" at="R-bug24512">excluding any
                                 <code>?</code> placeholders</phrase> (here <code>X</code> and
                              <code>Y</code>). These have <termref def="dt-type-determined-usage"/>
                           dependent on <phrase diff="add" at="R-bug24569">ancillary information
                              associated with the <termref def="dt-static-type"/> of the base
                              expression, where available (see <specref
                                 ref="determining-static-type"/>). If this information indicates
                              that the base expression is a function with signature</phrase>
                           <code>function(A, B, ...) as R</code>, then the first argument
                              <code>X</code> has <termref def="dt-type-determined-usage"/> based on
                           the first argument type <code>A</code>, the second argument
                              <code>Y</code> has <termref def="dt-type-determined-usage"/> based on
                           the second argument type <code>B</code>, and so on. If <phrase diff="add"
                              at="R-bug24569">no function signature is available</phrase>, then the
                           usage of each of the argument expressions is <termref def="dt-navigation"
                           />.</p>
                     </item>
                  </olist>
                  <note diff="add" at="R-bug24500">
                     <p>As explained in <specref ref="function-lookup"/>, use of a dynamic function
                        call where the function value is bound to a focus-dependent function such as
                           <code>name#0</code>, <code>lang#1</code>, or <code>last#0</code> is
                        likely to lead to a dynamic error if the context item is a node in a
                        streamed document, but this does not affect the static streamability
                        analysis.</p>
                  </note>
                  <note diff="add" at="T-bug29449">
                     <p>Maps and arrays are functions, and it is possible to look up a value in a
                        map or array using a dynamic function call of the form
                           <code>$map($key)</code> or <code>$array($index)</code>. If it is
                        statically known that the function in question is a map or array, then it is
                        also known that the argument type is <code>xs:anyAtomicType</code>, and that
                        the operand usage is therefore <termref def="dt-absorption"/>. A call that
                        passes a streamed node will therefore be <termref def="dt-grounded"/> and
                           <termref def="dt-consuming"/>. However, if it is not known statically
                        that the function is a map or array, then the expression will generally be
                           <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     <p>This means it is desirable to declare the type of any variable holding a map
                        or array. If streamable nodes are used to lookup a value in a map or array,
                        then it may be advisable to use the <code>map:get</code> or
                           <code>array:get</code> functions explicitly; or, if XPath 3.1 is
                        available, the lookup operator (<code>?</code>).</p>
                  </note>
               </div4>
               <div4 id="streamability-of-variable-references">
                  <head>Streamability of Variable References</head>
                  <p diff="chg" at="S-bug27571">For variable references that are bound to the
                        <termref def="dt-streaming-parameter"/> of a <termref
                        def="dt-declared-streamable"/>
                     <termref def="dt-stylesheet-function"/>, see the rules for the <termref
                        def="dt-streamability-category"/> of the containing function, under <specref
                        ref="streamable-stylesheet-functions"/>.</p>
                  <p>In all other cases, variable references are <termref def="dt-grounded"/> and
                        <termref def="dt-motionless"/>.</p>
                  <note diff="del" at="S-bug27571">
                     <p>The only case where a node in a <termref def="dt-streamed-document"/> can be
                        bound to a variable is where the variable is the <termref
                           def="dt-streaming-parameter"/> of a <termref def="dt-stylesheet-function"
                        /> that is <termref def="dt-declared-streamable"/>.</p>
                     <p>It is not necessarily the case that the expression appearing as the
                        corresponding argument in a call to such a function is <termref
                           def="dt-striding"/> and <termref def="dt-motionless"/>. Nevertheless,
                        treating the variable reference as <termref def="dt-striding"/> and <termref
                           def="dt-motionless"/> gives the correct outcome in assessing whether the
                        body of the function meets the rules for the particular <termref
                           def="dt-streamability-category"/> of the function in question. For
                        example:</p>
                     <olist>
                        <item>
                           <p>For streamability categories <code>filter</code>,
                                 <code>inspection</code>, and <code>ascent</code>, the function body
                              is required to be motionless. This effectively prohibits any downward
                              navigation starting from the variable reference. In these cases there
                              can be multiple references to the streaming parameter within the
                              function body, and such references can also appear within constructs
                              that are evaluated repeatedly (that is, <termref
                                 def="dt-higher-order-operand">higher-order operands</termref>).</p>
                        </item>
                        <item>
                           <p>For streamability categories <code>absorbing</code>,
                                 <code>shallow-descent</code>, and <code>deep-descent</code>, the
                              function body is allowed to be consuming. This allows downward
                              navigation starting from the variable reference, provided that there
                              is only one expression that performs such navigation, and provided it
                              is not within an construct that is evaluated repeatedly.</p>
                        </item>
                        <item>
                           <p>For streamability categories <code>absorbing</code> and
                                 <code>inspection</code>, the function body is required to be
                              grounded. This has the effect of preventing the function returning the
                              value of the variable reference directly, or of returning nodes
                              reached by navigation starting with the variable reference.</p>
                        </item>
                     </olist>
                  </note>
               </div4>
               <div4 id="streamability-of-context-item-expression">
                  <head>Streamability of the Context Item Expression</head>
                  <p>The <termref def="dt-posture"/> of the expression is the <phrase diff="chg"
                        at="Q"><termref def="dt-context-posture"/></phrase>, and the <termref
                        def="dt-sweep"/> is <termref def="dt-motionless"/>.</p>
                  <note diff="add" at="Q">
                     <p>Although <code>.</code> is intrinsically motionless, when used in certain
                        contexts (such as <code>data(.)</code>) the containing expression will be
                           <termref def="dt-consuming"/>. This arises because of the <termref
                           def="dt-operand-usage"/>: the argument to <xfunction>data</xfunction> has
                        usage <termref def="dt-absorption"/>, and the combination of a <termref
                           def="dt-motionless"/> operand with usage <termref def="dt-absorption"/>
                        leads to the containing expression being <termref def="dt-consuming"/>.</p>
                     <p>Similarly, if <code>.</code> is used where the <termref
                           def="dt-operand-usage"/> is <termref def="dt-navigation"/>, the
                        containing expression will be <termref def="dt-free-ranging"/>.</p>
                  </note>
               </div4>
               <div4 id="streamability-of-function-calls">
                  <head>Streamability of Static Function Calls</head>
                  <note>
                     <p diff="add" at="S-bug29229">This section applies to static function calls
                        written using the traditional syntax <code>F(X, Y, Z)</code> and equally to
                        those using the new XPath 3.1 syntax <code>X =&gt; F(Y, Z)</code></p>
                  </note>
                  <p>For calls to built-in functions, see <specref
                        ref="classifying-built-in-functions"/>.</p>
                  <p diff="chg" at="S-bug27571">For calls to <termref def="dt-stylesheet-function"
                        >stylesheet functions</termref>, see <specref
                        ref="streamable-stylesheet-functions"/>.</p>
                  <p>For partial function applications (where one or more of the arguments is
                     supplied as a <code>?</code> placeholder), see the rules at the end of this
                     section.</p>
                  <p diff="add" at="Q">For a call to a constructor function, the <specref
                        ref="general-streamability-rules"/> apply. There is a single operand role
                     (the argument to the function), with <termref def="dt-operand-usage"/>
                     <termref def="dt-absorption"/>.</p>
                  <p diff="add" at="R-bug24512">For a call to an <termref
                        def="dt-extension-function"/>, the <termref def="dt-posture"/> and <termref
                        def="dt-sweep"/> are <termref def="dt-implementation-defined"/>.</p>
                  <p diff="chg" at="P-bug22936">If the function call is a partial function
                     application (that is, if one or more of the arguments is given as a
                        <code>?</code> placeholder), then:</p>
                  <olist>
                     <item>
                        <p>If the function is focus-dependent <phrase diff="add" at="P-bug24512">and
                              the <termref def="dt-context-posture"/> is not <termref
                                 def="dt-grounded"/></phrase>, then the function call is <phrase
                              diff="add" at="R-bug24535"><termref def="dt-roaming"/> and</phrase>
                           <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p diff="add" at="R-bug24512">If the target of the function call is a
                              <termref def="dt-stylesheet-function"/>
                           <phrase diff="chg" at="S-bug27571">that is <termref
                                 def="dt-declared-streamable"/></phrase>, and if the <phrase
                              diff="chg" at="S-bug27571">first argument</phrase> is actually
                           supplied (that is, this argument is not supplied as a <code>?</code>
                           placeholder), <phrase diff="chg" at="S-bug27571">and if the expression
                              that is supplied as the first argument is not <termref
                                 def="dt-grounded"/>,</phrase> then the function call is <termref
                              def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p diff="add" at="R-bug24512">If the target is an <termref
                              def="dt-extension-function"/>, the <termref def="dt-posture"/> and
                              <termref def="dt-sweep"/> are <termref def="dt-implementation-defined"
                           />.</p>
                     </item>
                     <item>
                        <p>Otherwise, the <termref def="dt-general-streamability-rules"/> apply.
                              <phrase diff="add" at="Q">The operands of a partial function
                              application are the expressions actually supplied as arguments to the
                              function, ignoring <code>?</code> place-holders; the corresponding
                                 <termref def="dt-operand-usage"/> is the <termref
                                 def="dt-type-determined-usage"/> based on the declared type of that
                              argument.</phrase></p>
                     </item>
                  </olist>
               </div4>
               <div4 id="streamability-of-named-function-ref">
                  <head>Streamability of Named Function References</head>
                  <p>Let <var>F</var> be the function to which the <code>NamedFunctionRef</code>
                     refers.</p>
                  <p>If <var>F</var> is focus-dependent <phrase diff="add" at="R-bug24512">and the
                           <termref def="dt-context-posture"/> is not <termref def="dt-grounded"
                        /></phrase>, then the <code>NamedFunctionRef</code> is <phrase diff="add"
                        at="R-bug24535"><termref def="dt-roaming"/> and </phrase><termref
                        def="dt-free-ranging"/>.</p>
                  <p diff="add" at="R-bug24512">If <var>F</var> is an <termref
                        def="dt-extension-function"/>, the <termref def="dt-posture"/> and <termref
                        def="dt-sweep"/> are <termref def="dt-implementation-defined"/>.</p>
                  <p>Otherwise, the <code>NamedFunctionRef</code> is <phrase diff="add"
                        at="R-bug24535"><termref def="dt-grounded"/> and</phrase>
                     <termref def="dt-motionless"/>. </p>
                  <note diff="add" at="R-bug24512">
                     <p>The main intent behind these rules is to ensure that the function item
                        returned by a named function reference does not encapsulate a reference to a
                        streamed node.</p>
                     <p>In the case of an expression such as <code>local-name#0</code>,
                        implementations might be able to do better by pre-evaluating the function at
                        the point where the named function reference occurs.</p>
                     <p>In the case of extension functions, implementations may be able to
                        distinguish whether the function is focus-dependent, and decide the
                        streamability of the named function reference accordingly.</p>
                  </note>
               </div4>
               <div4 id="streamability-of-inline-functions">
                  <head>Streamability of Inline Function Declarations</head>
                  <p diff="chg" at="S-bug27571">An inline function declaration that textually
                     contains a variable reference bound to a <termref def="dt-streaming-parameter"
                     /> (of some containing stylesheet function) is <termref def="dt-roaming"/> and
                        <termref def="dt-free-ranging"/>.</p>
                  <p diff="chg" at="R-bug24510">All other inline function declarations are <termref
                        def="dt-grounded"/> and <termref def="dt-motionless"/>.</p>
                  <note diff="chg" at="S-bug27571">
                     <p>It is not possible to pass a streamed node as an argument to a call to an
                        inline function unless the declared type of the corresponding function
                        parameter causes the node to be atomized: see <specref
                           ref="streamability-of-dynamic-function-calls"/>. The only other way an
                        inline function could access a streamed node is by having the streamed node
                        in its closure, and this is prevented by the rule above.</p>
                  </note>
               </div4>
               <div4 id="streamability-of-map-constructors" diff="chg" at="Q">
                  <head>Streamability of Map Constructors</head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of a map
                     constructor (see <specref ref="map-constructors"/>) are the same as the
                        <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the equivalent
                        <elcode>xsl:map</elcode> instruction. The equivalent
                        <elcode>xsl:map</elcode> instruction is formed by creating a sequence of
                        <elcode>xsl:map-entry</elcode> instructions, one for each key/value pair in
                     the map expression, where the key expression becomes the value of
                        <code>xsl:map-entry/@key</code>, and the value expression becomes the value
                     of <code>xsl:map-entry/@select</code>; this sequence of
                        <elcode>xsl:map-entry</elcode> instructions is then wrapped in an
                        <elcode>xsl:map</elcode> parent instruction.</p>
                  <p>For example, the map constructor <code>map{'red':false(),
                        'green':true()}</code> translates to the instruction:</p>
                  <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:map&gt;
  &lt;xsl:map-entry key="'red'" select="false()"/&gt;
  &lt;xsl:map-entry key="'green'" select="true()"/&gt;
&lt;/xsl:map&gt;</eg>
                  <p>The rules for the streamability of <elcode>xsl:map</elcode> appear in <specref
                        ref="streamability-xsl-map"/>.</p>
                  <p>See also <specref ref="maps-streaming"/>.</p>
               </div4>
               <div4 id="streamability-of-lookup-expressions" diff="add" at="S-bug29229">
                  <head>Streamability of Lookup Expressions</head>
                  <p>Lookup expressions for maps are defined in <specref ref="map-lookup-operator"
                     />, and are available in XSLT 3.0 whether or not XPath 3.1 is supported. Lookup
                     expressions for arrays are defined in the XPath 3.1 specification (see
                        <xspecref spec="XP31" ref="id-lookup"/>), and are available only in XSLT 3.0
                     processors that provide the XPath 3.1 Feature (see <specref
                        ref="xpath31-feature"/>).</p>
                  <p>For the unary lookup operator, the <termref def="dt-posture"/> and <termref
                        def="dt-sweep"/> of the expression <code>?X</code> are defined to be the
                     same as the <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the
                     postfix lookup expression <code>.?X</code>.</p>
                  <p>For the postfix lookup expression <code>E?K</code>, the <termref
                        def="dt-general-streamability-rules"/> apply as follows:</p>
                  <olist>
                     <item>
                        <p>In the wildcard form of the expression, <code>E?*</code>, there is only
                           one operand, <code>E</code>. This has <termref def="dt-operand-usage"/>
                           <termref def="dt-inspection"/>.</p>
                     </item>
                     <item>
                        <p>Where the construct <code>K</code> is an NCName, the expression
                              <code>E?NAME</code> is treated as equivalent to
                              <code>E?("NAME")</code>.</p>
                     </item>
                     <item>
                        <p>Where the construct <code>K</code> is an integer, the expression
                              <code>E?N</code> is treated as equivalent to <code>E?(N)</code>.</p>
                     </item>
                     <item>
                        <p>In the general case where <code>K</code> is a parenthesized expression,
                           the lookup expression <code>E?(K)</code> has two operands. The first
                           operand <code>E</code> has <termref def="dt-operand-usage"/>
                           <termref def="dt-inspection"/>, while the second operand <code>K</code>
                           has <termref def="dt-operand-usage"/>
                           <termref def="dt-absorption"/>.</p>
                     </item>
                  </olist>
               </div4>
            </div3>
            <div3 id="classifying-built-in-functions">
               <head>Classifying Calls to Built-In Functions</head>
               <p>This section describes the rules that determine the streamability of calls to
                  built-in functions. These differ from user-written functions because it is known
                  (defined in the specification) how nodes supplied as operands are used. Knowledge
                  of the usage of each operand, together with the <termref def="dt-posture"/> of the
                  actual operands, is in most cases enough to determine the <termref
                     def="dt-posture"/> and <termref def="dt-sweep"/> of the function result.</p>
               <p>All the built-in functions are listed below. For most functions, a simple proforma
                  is shown that indicates the operand usage of each argument, using the code (A =
                     <termref def="dt-absorption"/>, I = <termref def="dt-inspection"/>, T =
                     <termref def="dt-transmission"/>, N = <termref def="dt-navigation"/>). So, for
                  example, the entry <code>fn:remove(T, A)</code> means that for the function
                     <code>fn:remove#2</code>, the <termref def="dt-operand-usage"/> of the first
                  argument is <termref def="dt-transmission"/>, and the <termref
                     def="dt-operand-usage"/> of the second argument is <termref def="dt-absorption"
                  />. By reference to the general rules in <specref
                     ref="general-streamability-rules"/>, this demonstrates that if the <phrase
                     diff="chg" at="Q"><termref def="dt-context-posture"/></phrase> is <termref
                     def="dt-striding"/>, the posture and sweep of the expression
                     <code>sum(remove(*,1))</code> will be <code>grounded</code> and
                     <code>consuming</code> respectively. </p>
               <p>For functions that default one of their arguments (typically to the context item),
                  the relevant entry shows the equivalence, and the posture and sweep can in these
                  cases be computed by filling in the default value for the relevant argument.</p>
               <p>Some functions do not follow the general rules, and these are listed with a link
                  to the section where the particular rules for that function are described.</p>
               <ulist>
                  <item>
                     <p>
                        <code>array:append(I, N)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>array:filter(I, I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>array:flatten(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>array:fold-left(I, N, I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>array:fold-right(I, N, I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>array:for-each(I, I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>array:for-each-pair(I, I, I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>array:get(I, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>array:head(I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>array:insert-before(I, A, N)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>array:join(I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>array:put(I, I, N)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>array:remove(I, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>array:reverse(I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>array:size(I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>array:sort(I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>array:sort(I, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>array:sort(I, A, I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>array:subarray(I, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>array:subarray(I, A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>array:tail(I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:abs(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:accumulator-after</code> – See <specref
                           ref="streamability-fn-accumulator-after"/>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:accumulator-before</code> – See <specref
                           ref="streamability-fn-accumulator-before"/>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:adjust-date-to-timezone(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:adjust-date-to-timezone(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:adjust-dateTime-to-timezone(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:adjust-dateTime-to-timezone(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:adjust-time-to-timezone(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:adjust-time-to-timezone(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:analyze-string(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:analyze-string(A, A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:apply(A, I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:available-environment-variables()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:available-system-properties()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:avg(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:base-uri()</code> – Equivalent to <code>fn:base-uri(.)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:base-uri(I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:boolean(I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:ceiling(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:codepoint-equal(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:codepoints-to-string(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:collation-key(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:collation-key(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:collection()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:collection(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:compare(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:compare(A, A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:concat(A, A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:contains(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:contains(A, A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:contains-token(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:contains-token(A, A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:copy-of()</code> – Equivalent to <code>fn:copy-of(.)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:copy-of(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:count(I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:current</code> – See <specref ref="streamability-fn-current"/>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:current-date()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:current-dateTime()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:current-group</code> – See <specref
                           ref="streamability-fn-current-group"/>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:current-grouping-key</code> – See <specref
                           ref="streamability-fn-current-grouping-key"/>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:current-merge-group</code> – See <specref
                           ref="streamability-fn-current-merge-group"/>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:current-merge-key</code> – See <specref
                           ref="streamability-fn-current-merge-key"/>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:current-output-uri()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:current-time()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:data()</code> – Equivalent to <code>fn:data(.)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:data(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:dateTime(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:day-from-date(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:day-from-dateTime(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:days-from-duration(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:deep-equal(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:deep-equal(A, A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:deep-equal(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:deep-equal(A, A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:default-collation()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:default-language()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:distinct-values(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:distinct-values(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:doc(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:doc-available(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:document(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:document(A, I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:document-uri()</code> – Equivalent to
                           <code>fn:document-uri(.)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:document-uri(I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:element-available(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:element-with-id(x)</code> – Equivalent to
                           <code>fn:element-with-id(x, .)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:element-with-id(A, N)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:empty(I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:encode-for-uri(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:ends-with(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:ends-with(A, A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:environment-variable(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:error()</code> – Equivalent to <code>fn:error(x, x, x, x, x,
                           .)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:error(x)</code> – Equivalent to <code>fn:error(x, x, x, x,
                           .)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:error(x, x)</code> – Equivalent to <code>fn:error(x, x, .)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:error(A, A, N)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:escape-html-uri(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:exactly-one(T)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:exists(I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:false()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:filter(N, I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:floor(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:fold-left(N, A, I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:fold-right</code> – See <specref ref="streamability-fn-fold-right"
                        />
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:for-each(N, I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:for-each-pair(N, N, I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:format-date(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:format-date(A, A, A, A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:format-dateTime(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:format-dateTime(A, A, A, A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:format-integer(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:format-integer(A, A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:format-number(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:format-number(A, A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:format-time(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:format-time(A, A, A, A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:function-arity(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:function-available(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:function-available(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:function-lookup</code> – See <specref
                           ref="streamability-fn-function-lookup"/>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:function-name(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:generate-id()</code> – Equivalent to <code>fn:generate-id(.)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:generate-id(I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:has-children()</code> – Equivalent to
                           <code>fn:has-children(.)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:has-children(I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:head(T)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:hours-from-dateTime(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:hours-from-duration(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:hours-from-time(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:id(x)</code> – Equivalent to <code>fn:id(x, .)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:id(A, N)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:idref(x)</code> – Equivalent to <code>fn:idref(x, .)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:idref(A, N)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:implicit-timezone()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:in-scope-prefixes(I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:index-of(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:index-of(A, A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:innermost</code> – See <specref ref="streamability-fn-innermost"/>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:insert-before(T, A, T)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:iri-to-uri(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:json-doc(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:json-doc(A, I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:json-to-xml(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:json-to-xml(A, I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:key(x, x)</code> – Equivalent to <code>fn:key(x, x, /)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:key(A, A, N)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:lang(x)</code> – Equivalent to <code>fn:lang(x, .)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:lang(A, I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:last</code> – See <specref ref="streamability-fn-last"/>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:load-xquery-module(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:load-xquery-module(A, I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:local-name()</code> – Equivalent to <code>fn:local-name(.)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:local-name(I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:local-name-from-QName(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:lower-case(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:matches(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:matches(A, A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:max(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:max(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:min(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:min(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:minutes-from-dateTime(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:minutes-from-duration(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:minutes-from-time(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:month-from-date(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:month-from-dateTime(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:months-from-duration(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:name()</code> – Equivalent to <code>fn:name(.)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:name(I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:namespace-uri()</code> – Equivalent to
                           <code>fn:namespace-uri(.)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:namespace-uri(I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:namespace-uri-for-prefix(A, I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:namespace-uri-from-QName(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:nilled()</code> – Equivalent to <code>fn:nilled(.)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:nilled(I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:node-name()</code> – Equivalent to <code>fn:node-name(.)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:node-name(I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:normalize-space()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:normalize-space(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:normalize-unicode(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:normalize-unicode(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:not(I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:number()</code> – Equivalent to <code>fn:number(.)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:number(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:one-or-more(T)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:outermost</code> – See <specref ref="streamability-fn-outermost"/>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:parse-ietf-date(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:parse-json(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:parse-json(A, I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:parse-xml(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:parse-xml-fragment(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:path()</code> – Equivalent to <code>fn:path(.)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:path(N)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:position</code> – See <specref ref="streamability-fn-position"/>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:prefix-from-QName(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:QName(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:random-number-generator()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:random-number-generator(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:regex-group(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:remove(T, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:replace(A, A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:replace(A, A, A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:resolve-QName(A, I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:resolve-uri(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:resolve-uri(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:reverse</code> – See <specref ref="streamability-fn-reverse"/>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:root</code> – See <specref ref="streamability-fn-root"/>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:round(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:round(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:round-half-to-even(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:round-half-to-even(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:seconds-from-dateTime(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:seconds-from-duration(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:seconds-from-time(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:serialize(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:serialize(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:snapshot()</code> – Equivalent to <code>fn:snapshot(.)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:snapshot(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:sort(N)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:sort(N, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:sort(N, A, I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:starts-with(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:starts-with(A, A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:static-base-uri()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:stream-available(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:string()</code> – Equivalent to <code>fn:string(.)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:string(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:string-join(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:string-join(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:string-length()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:string-length(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:string-to-codepoints(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:subsequence(T, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:subsequence(T, A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:substring(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:substring(A, A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:substring-after(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:substring-after(A, A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:substring-before(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:substring-before(A, A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:sum(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:sum(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:system-property(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:tail(T)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:timezone-from-date(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:timezone-from-dateTime(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:timezone-from-time(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:tokenize(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:tokenize(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:tokenize(A, A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:trace(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:trace(T, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:transform(I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:translate(A, A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:true()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:type-available(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:unordered(T)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:unparsed-entity-public-id(x)</code> – Equivalent to
                           <code>fn:unparsed-entity-public-id(x, /)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:unparsed-entity-public-id(A, I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:unparsed-entity-uri(x)</code> – Equivalent to
                           <code>fn:unparsed-entity-uri(x, /)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:unparsed-entity-uri(A, I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:unparsed-text(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:unparsed-text(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:unparsed-text-available(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:unparsed-text-available(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:unparsed-text-lines(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:unparsed-text-lines(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:upper-case(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:uri-collection()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:uri-collection(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:xml-to-json(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:xml-to-json(A, I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:year-from-date(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:year-from-dateTime(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:years-from-duration(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:zero-or-one(T)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>map:contains(I, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>map:entry(A, N)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>map:find(I, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>map:for-each(I, I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>map:get(I, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>map:keys(I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>map:merge(I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>map:merge(I, I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>map:put(I, A, N)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>map:remove(I, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>map:size(I)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>math:acos(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>math:asin(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>math:atan(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>math:atan2(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>math:cos(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>math:exp(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>math:exp10(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>math:log(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>math:log10(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>math:pi()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>math:pow(A, A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>math:sin(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>math:sqrt(A)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>math:tan(A)</code>
                     </p>
                  </item>
               </ulist>
               <div4 id="streamability-fn-accumulator-after" diff="chg" at="R-bug26328">
                  <head>Streamability of the <function>accumulator-after</function> Function</head>
                  <p>See also <specref ref="streamability-of-accumulators"/>.</p>
                  <p>The <termref def="dt-posture"/> of the function call is in all cases <termref
                        def="dt-grounded"/>.</p>
                  <p>The <termref def="dt-sweep"/> is determined by applying the following rules, in
                     order:</p>
                  <olist>
                     <item>
                        <p>If the first argument (the accumulator name) is not <termref
                              def="dt-motionless"/>, the function is <termref def="dt-free-ranging"
                           />. </p>
                     </item>
                     <item>
                        <p>If the <termref def="dt-context-posture"/> is <termref def="dt-grounded"
                           />, the function is <termref def="dt-motionless"/>. </p>
                     </item>
                     <item>
                        <p>If the <termref def="dt-context-item-type"/> has an empty intersection
                           with <var>U{document-node(), element()}</var> (that is, if the context
                           item cannot have children), the function is <termref def="dt-motionless"
                           />. </p>
                     </item>
                     <item>
                        <p>If the function call is contained in the <code>select</code> expression
                           or contained sequence constructor of an
                              <elcode>xsl:accumulator-rule</elcode> specifying
                              <code>phase="start"</code>, then it is <termref def="dt-free-ranging"
                           />.</p>
                     </item>
                     <item>
                        <p>If the function call is contained in the <code>select</code> expression
                           or contained sequence constructor of an
                              <elcode>xsl:accumulator-rule</elcode> specifying
                              <code>phase="end"</code>, then it is <termref def="dt-motionless"
                           />.</p>
                     </item>
                     <item>
                        <p><phrase diff="chg" at="S-bug27273">If no enclosing node of the function
                              call is part of a <termref def="dt-sequence-constructor"/>, then it is
                                 <termref def="dt-free-ranging"/>. For this purpose, the
                                 <term>enclosing nodes</term> of a function call are the attribute
                              or text node that immediately contains the XPath expression in which
                              the function call appears, and its ancestors.</phrase>
                        </p>
                     </item>
                     <item>
                        <p>If the <termref def="dt-focus-setting-container"/> of the function call
                           is different from the <termref def="dt-focus-setting-container"/> of the
                           innermost containing <termref def="dt-instruction"/>, then the function
                           is <termref def="dt-free-ranging"/>. </p>
                     </item>
                     <item>
                        <p><phrase diff="chg" at="S-bug27273">If no enclosing node <var>N</var> of
                              the function call has a preceding sibling node <var>P</var> such that
                              (a) <var>N</var> and <var>P</var> are part of the same <termref
                                 def="dt-sequence-constructor"/>, and (b) the <termref
                                 def="dt-sweep"/> of <var>P</var> is <termref def="dt-consuming"/>,
                              then the function call is <termref def="dt-consuming"/>. (The term
                                 <term>enclosing node</term> is defined above.)</phrase></p>
                     </item>
                     <item>
                        <p>Otherwise, the function call is <termref def="dt-motionless"/>.</p>
                     </item>
                  </olist>
                  <note>
                     <p>The following notes apply to the above rules with matching numbers:</p>
                     <olist>
                        <item>
                           <p>This rule prevents the accumulator name being computed by reading the
                              streamed source document. This is disallowed primarily because there
                              is no conceivable use case for doing it.</p>
                        </item>
                        <item>
                           <p>If the context posture is grounded, then the target of the accumulator
                              is not a streamed node, so no streaming restrictions apply.</p>
                        </item>
                        <item>
                           <p>If the context item is a childless node (such as a text node), then
                              both the pre-descent and post-descent values of the accumulator can be
                              computed before evaluating any user-written constructs that access
                              this node; there are therefore no constraints on where a call to
                                 <function>accumulator-after</function> can appear.</p>
                        </item>
                        <item>
                           <p>This rule ensures that when computing the pre-descent value of an
                              accumulator for a particular streamed node, the post-descent values of
                              accumulators for that node are not available.</p>
                        </item>
                        <item>
                           <p>This rule states that the post-descent value of an accumulator is
                              allowed to depend on the post-descent values of other accumulators for
                              the same node. There is a rule preventing cycles <errorref spec="XT"
                                 class="DE" code="3400"/>.</p>
                        </item>
                        <item>
                           <p>This rule prevents the use of the function (when applied to a streamed
                              node) in contexts like the <code>use</code> attribute of
                                 <elcode>xsl:key</elcode>. <phrase diff="add" at="S-bug27273">It
                                 allows its use in the attributes of an <termref
                                    def="dt-instruction"/> or <termref
                                    def="dt-literal-result-element"/>, or in a <termref
                                    def="dt-text-value-template"/>. It does not allow use in an
                                    <elcode>xsl:sort</elcode> or <elcode>xsl:param</elcode> element,
                                 as these elements do not form part of a sequence constructor (see
                                    <specref ref="sequence-constructors"/>).</phrase></p>
                        </item>
                        <item>
                           <p>This rule prevents the use of the function (when applied to a streamed
                              node) in contexts such as predicates, or the right-hand side of the
                                 <code>/</code> operator. The focus for evaluation of the function
                              must be the same as the focus for a containing sequence constructor.
                              Sequence constructors are treated differently from all other
                              constructs for this purpose in that their operands (the contained
                              instructions) are treated as ordered: in conjunction with the next
                              rule, this rule is assuming that instructions in a sequence
                              constructor that follow a <termref def="dt-consuming"/> instruction
                              are evaluated after the <termref def="dt-consuming"/> instruction and
                              therefore have access to the post-descent accumulator value.</p>
                        </item>
                        <item>
                           <p>This rule is subtle, and has a number of consequences. <phrase
                                 diff="add" at="S-bug27273">In these notes, the term
                                    <term>instruction</term> should be read as including all nodes
                                 making up a sequence constructor, including XSLT instructions,
                                 extension instructions, literal result elements, and text nodes
                                 containing text value templates.</phrase></p>
                           <ulist>
                              <item>
                                 <p>In a sequence constructor that contains a <termref
                                       def="dt-consuming"/> instruction such as
                                       <code>&lt;xsl:apply-templates/&gt;</code>, it allows any
                                    number of calls on <function>accumulator-after</function> to
                                    appear in instructions that follow the call on
                                       <code>&lt;xsl:apply-templates/&gt;</code>.</p>
                              </item>
                              <item>
                                 <p>In such a sequence constructor it prevents a call on
                                       <function>accumulator-after</function> from appearing in an
                                    instruction that precedes the
                                       <code>&lt;xsl:apply-templates/&gt;</code>, because there
                                    would then be two <termref def="dt-consuming"/>
                                    instructions.</p>
                              </item>
                              <item>
                                 <p>In a sequence constructor that contains calls on
                                       <function>accumulator-after</function>, and contains no other
                                       <termref def="dt-consuming"/> construct, the first
                                    instruction that contains a call on
                                       <function>accumulator-after</function> is consuming (unless
                                    it contains more than one such call, in which case it is
                                    free-ranging), and subsequent instructions containing such a
                                    call are motionless. So it is possible to have two or more calls
                                    on <function>accumulator-after</function> provided they appear
                                    in different instructions, which allows the analysis to assume
                                    an order of execution.</p>
                              </item>
                              <item>
                                 <p>It prevents a call on <function>accumulator-after</function>
                                    from appearing in the same instruction as another consuming
                                    construct: for example it disallows <code>concat(child::p,
                                       accumulator-after('a'))</code>. This rule preserves the
                                    ability to evaluate the arguments of the <code>concat</code>
                                    function in any order.</p>
                              </item>
                              <item>
                                 <p>It disallows a call on <function>accumulator-after</function>
                                    from appearing in a sequence constructor that is required to be
                                    motionless, for example within <elcode>xsl:sort</elcode>.</p>
                              </item>
                              <item>
                                 <p>The reference to a “preceding sibling node within the same
                                    sequence constructor” is carefully worded to ensure that
                                    preceding siblings among the children of
                                       <elcode>xsl:fork</elcode> are not taken into account; the
                                    children of <elcode>xsl:fork</elcode> are sibling instructions,
                                    but do not constitute a sequence constructor. <phrase diff="add"
                                       at="S-bug23237">The term also excludes elements such as
                                          <elcode>xsl:param</elcode> and <elcode>xsl:sort</elcode>
                                       that may precede a sequence constructor but are not part of
                                       it.</phrase></p>
                              </item>
                           </ulist>
                        </item>
                        <item>
                           <p>The final rule states that if none of the previous rules apply, the
                              function is considered motionless. This applies when the
                                 <function>accumulator-after</function> appears after a consuming
                              instruction within the same sequence constructor.</p>
                           <p>Note also that a call to <function>accumulator-after</function> can
                              safely appear within a construct such as a named template or
                              (non-streamable) stylesheet function; this is safe because the rules
                              ensure that in such situations, the context item cannot be a streamed
                              node.</p>
                        </item>
                     </olist>
                  </note>
                  <p>Dynamic invocation of <function>accumulator-after</function> is covered by the
                     rules in <specref ref="function-lookup"/>. These rules ensure that a function
                     item cannot include a streamed node in its closure; circumventing the
                     streamability rules for <function>accumulator-after</function> by making a
                     dynamic call is therefore not possible.</p>
               </div4>
               <div4 id="streamability-fn-accumulator-before">
                  <head>Streamability of the <function>accumulator-before</function> Function</head>
                  <p>See also <specref ref="streamability-of-accumulators"/>.</p>
                  <p diff="add" at="R-bug24651">The <termref def="dt-posture"/> and <termref
                        def="dt-sweep"/> of the function call are assessed as follows:</p>
                  <olist diff="add" at="R-bug24651">
                     <item>
                        <p>If the argument to <function>accumulator-before</function> is motionless,
                           the function call is <termref def="dt-grounded"/> and <termref
                              def="dt-motionless"/>.</p>
                     </item>
                     <item>
                        <p>Otherwise, the function call is <termref def="dt-roaming"/> and <termref
                              def="dt-free-ranging"/>.</p>
                     </item>
                  </olist>
               </div4>
               <div4 id="streamability-fn-current" diff="chg" at="S-bug28833">
                  <head>Streamability of the <function>current</function> Function</head>
                  <p>The <termref def="dt-sweep"/> and <termref def="dt-posture"/> of a call to the
                        <function>current</function> function are determined as follows:</p>
                  <olist>
                     <item>
                        <p diff="add" at="T-bug30033">If the call appears within a pattern, then
                           climbing and motionless.</p>
                        <note>
                           <p>The call to <function>current</function> will always be within a
                              predicate of the pattern. The use of climbing posture here allows
                              predicates such as <code>[@class = current()/@class]</code>, while
                              disallowing downwards navigation from the node returned by the
                              function.</p>
                        </note>
                     </item>
                     <item>
                        <p>Otherwise, let <var>E</var> be the outermost containing XPath expression
                           of the call to the <function>current</function> function.</p>
                     </item>
                     <item>
                        <p>If the <termref def="dt-context-posture"/> of <var>E</var> is <termref
                              def="dt-grounded"/>, then <termref def="dt-motionless"/> and <termref
                              def="dt-grounded"/>.</p>
                     </item>
                     <item>
                        <p>If the path in the expression tree that connects the call on
                              <function>current</function> to <var>E</var> (excluding <var>E</var>
                           itself) contains an expression that is a <termref
                              def="dt-higher-order-operand"/> of its parent expression, then
                              <termref def="dt-motionless"/> and <termref def="dt-climbing"/>. </p>
                        <note>
                           <p>Many common uses of the <function>current</function>, such as
                                 <code>//p[@class=current()/@class]</code>, fall into this category:
                              a predicate is a higher-order operand of its containing filter
                              expression.</p>
                           <p>The use of <termref def="dt-climbing"/> posture here might seem
                              unrelated to its usual connection with the ancestor axis. The
                              explanation (apart from the fact that it happens to produce the right
                              results) lies in the fact that at the point where the
                                 <function>current</function> call is evaluated, the node it returns
                              will always be an ancestor-or-self of the context node, as a
                              consequence of the fact that the containing XPath expression is
                              required to be either <termref def="dt-motionless"/> or <termref
                                 def="dt-consuming"/>.</p>
                           <p diff="chg" at="S-bug29053">The effect of the rule is to allow
                              expressions such as <code>//*[name() = name(current())]</code> or
                                 <code>//*[@ref = current()/@id]</code>.</p>
                        </note>
                     </item>
                     <item>
                        <p diff="add" at="T-bug30033">Otherwise, the <termref def="dt-posture"/> is
                           the <termref def="dt-context-posture"/>, and the <termref def="dt-sweep"
                           /> is <termref def="dt-motionless"/>.</p>
                     </item>
                  </olist>
               </div4>
               <div4 id="streamability-fn-current-group">
                  <head>Streamability of the <function>current-group</function> Function</head>
                  <p diff="del" at="R-bug24510">XSLT 3.0 introduces the <code>bind-group</code>
                     attribute on the <elcode>xsl:for-each-group</elcode> instruction to enable
                     grouping code to be statically analyzed for streamability. Use of the
                        <function>current-group</function> and
                        <function>current-grouping-key</function> functions is therefore
                     incompatible with streaming.</p>
                  <p diff="del" at="R-bug24510">Specifically: a call on the
                        <function>current-group</function> is <termref def="dt-roaming"/> and
                        <termref def="dt-free-ranging"/>.</p>
                  <p diff="add" at="R-bug24510">The <termref def="dt-sweep"/> and <termref
                        def="dt-posture"/> of a call <var>C</var> to the
                        <function>current-group</function> function are as follows:</p>
                  <olist>
                     <item>
                        <p>If all the following conditions are true:</p>
                        <olist>
                           <item>
                              <p><var>C</var> has a containing <elcode>xsl:for-each-group</elcode>
                                 instruction (call it <var>F</var>)</p>
                           </item>
                           <item>
                              <p>The path in the construct tree that connects <var>C</var> to the
                                 sequence constructor forming the body of <var>F</var> is such that
                                 no child construct is a <termref def="dt-higher-order-operand"/> of
                                 its parent</p>
                           </item>
                           <item>
                              <p diff="add" at="Q">The <termref def="dt-focus-setting-container"/>
                                 of <var>C</var> is <var>F</var></p>
                           </item>
                        </olist>
                        <p>then the <termref def="dt-sweep"/> and <termref def="dt-posture"/> of
                              <var>C</var> are the <termref def="dt-sweep"/> and <termref
                              def="dt-posture"/> of the <code>select</code> expression of
                              <var>F</var>.</p>
                     </item>
                     <item>
                        <p>Otherwise, <termref def="dt-roaming"/> and <termref def="dt-free-ranging"
                           />.</p>
                     </item>
                  </olist>
                  <note diff="chg" at="R-bug24510">
                     <p>Informally, for streamed evaluation to be possible, a call to
                           <function>current-group</function> must not appear in a construct that is
                        evaluated repeatedly. For example, the expression <code>for $i in 1 to 10
                           return current-group()</code> would not be streamable.</p>
                  </note>
               </div4>
               <div4 id="streamability-fn-current-grouping-key">
                  <head>Streamability of the <function>current-grouping-key</function>
                     Function</head>
                  <p diff="chg" at="R-bug24510">A call to the
                        <function>current-grouping-key</function> function is grounded and
                     motionless.</p>
               </div4>
               <div4 id="streamability-fn-current-merge-group" diff="add" at="R-bug24510">
                  <head>Streamability of the <function>current-merge-group</function>
                     Function</head>
                  <p diff="chg" at="R-bug25335">A call to the
                        <function>current-merge-group</function> function is <termref
                        def="dt-grounded"/> and <termref def="dt-motionless"/>.</p>
                  <note diff="chg" at="R-bug25335">
                     <p>This is because the nodes to be merged are always snapshots, and therefore
                           <termref def="dt-grounded"/>: see <specref ref="streamable-merging"
                        />.</p>
                  </note>
               </div4>
               <div4 id="streamability-fn-current-merge-key" diff="add" at="R-bug24510">
                  <head>Streamability of the <function>current-merge-key</function> Function</head>
                  <p>A call to the <function>current-merge-key</function> function is <termref
                        def="dt-grounded"/> and <termref def="dt-motionless"/>.</p>
               </div4>
               <div4 id="streamability-fn-fold-left" diff="add" at="R-bug26439">
                  <head>Streamability of the <xfunction>fold-left</xfunction> Function</head>
                  <p>The function call <code>fold-left($seq, $zero, $f)</code>, follows the <termref
                        def="dt-general-streamability-rules"/>, with the first argument
                        <code>$seq</code> having <termref def="dt-type-determined-usage"/> based on
                     the type of the second argument of the function supplied as
                     <code>$f</code>.</p>
                  <p>For example, given the call <code>fold-left(/*/transaction, 0, function($x as
                        xs:decimal, $y as xs:decimal) as xs:decimal {$x+$y})</code>, the <termref
                        def="dt-operand-usage"/> of the argument <code>/*/transaction</code> is
                     determined by the declared type of <code>$y</code>, namely
                        <code>xs:decimal</code>. Since this is an atomic type, the <termref
                        def="dt-type-determined-usage"/> is <termref def="dt-absorption"/>. Applying
                     this to the general streamability rules, the function call is <termref
                        def="dt-grounded"/> and <termref def="dt-consuming"/>.</p>
               </div4>
               <div4 id="streamability-fn-fold-right" diff="add" at="R-bug24125">
                  <head>Streamability of the <xfunction>fold-right</xfunction> Function</head>
                  <p>The function follows the <termref def="dt-general-streamability-rules"/>, with
                     the first argument having <termref def="dt-operand-usage"/>
                     <termref def="dt-navigation"/> to reflect the fact that the supplied sequence
                     is processed in reverse order.</p>
                  <note>
                     <p>The same considerations apply as for the <xfunction>reverse</xfunction>
                        function: see <specref ref="streamability-fn-reverse"/>.</p>
                  </note>
               </div4>
               <div4 id="streamability-fn-for-each" diff="add" at="R-bug26439">
                  <head>Streamability of the <xfunction>for-each</xfunction> Function</head>
                  <p>The function call <code>for-each($seq, $f)</code>, follows the <termref
                        def="dt-general-streamability-rules"/>, with the first argument
                        <code>$seq</code> having <termref def="dt-type-determined-usage"/> based on
                     the type of the (single) argument of the function supplied as
                     <code>$f</code>.</p>
                  <p>For example, given the call <code>for-each(/*/transaction, function($x as
                        xs:decimal) as xs:decimal {abs($x)})</code>, the <termref
                        def="dt-operand-usage"/> of the argument <code>/*/transaction</code> is
                     determined by the declared type of <code>$x</code>, namely
                        <code>xs:decimal</code>. Since this is an atomic type, the <termref
                        def="dt-type-determined-usage"/> is <termref def="dt-absorption"/>. Applying
                     this to the general streamability rules, the function call is <termref
                        def="dt-grounded"/> and <termref def="dt-consuming"/>.</p>
                  <note>
                     <p>In practice, the <xfunction>filter</xfunction> function is streamable if
                        either (a) the supplied sequence is grounded, or (b) the supplied function
                        is statically known to atomize its argument.</p>
                  </note>
               </div4>
               <div4 id="streamability-fn-for-each-pair" diff="add" at="R-bug26439">
                  <head>Streamability of the <xfunction>for-each-pair</xfunction> Function</head>
                  <p>The function call <code>for-each($seq1, $seq2, $f)</code>, follows the <termref
                        def="dt-general-streamability-rules"/>, where:</p>
                  <olist>
                     <item>
                        <p>The first argument <code>$seq1</code> has <termref
                              def="dt-type-determined-usage"/> based on the type of the first
                           argument of the function supplied as <code>$f</code>.</p>
                     </item>
                     <item>
                        <p>The second argument <code>$seq2</code> has <termref
                              def="dt-type-determined-usage"/> based on the type of the second
                           argument of the function supplied as <code>$f</code></p>
                     </item>
                  </olist>
                  <note>
                     <p>In practice, the <xfunction>for-each-pair</xfunction> function is streamable
                        provided (a) at most one of the input sequences is consuming, and (b) either
                        (i) that input sequence is grounded, or (ii) the supplied function is
                        statically known to atomize the relevant argument.</p>
                     <p>If it is necessary to combine two sequences that are both streamed, consider
                        using <elcode>xsl:merge</elcode>.</p>
                  </note>
               </div4>
               <div4 id="streamability-fn-function-lookup">
                  <head>Streamability of the <xfunction>function-lookup</xfunction> Function</head>
                  <p>See <specref ref="function-lookup"/> for special rules that relate to
                     streamability of calls to the <xfunction>function-lookup</xfunction>
                     function.</p>
                  <p>With the caveats given there, the function follows the <termref
                        def="dt-general-streamability-rules"/>, for a function with two arguments
                     that both have <termref def="dt-operand-usage"/>
                     <termref def="dt-absorption"/>.</p>
               </div4>
               <div4 id="streamability-fn-innermost" diff="add" at="R-bug24125">
                  <head>Streamability of the <xfunction>innermost</xfunction> Function</head>
                  <p>The function follows the <termref def="dt-general-streamability-rules"/>, with
                     the first argument having <termref def="dt-operand-usage"/>
                     <termref def="dt-navigation"/>. This is to reflect the fact that the processing
                     is not strictly sequential: it cannot be determined that a node is part of the
                     result sequence of <xfunction>innermost</xfunction> until all its descendants
                     have been read.</p>
               </div4>
               <div4 id="streamability-fn-last">
                  <head>Streamability of the <xfunction>last</xfunction> Function</head>
                  <p>If the <termref def="dt-context-posture"/> for a call on the
                        <xfunction>last</xfunction> function is <termref def="dt-striding"/>,
                        <termref def="dt-crawling"/>, or <termref def="dt-roaming"/>, then the
                        <termref def="dt-posture"/> of the function is <termref def="dt-roaming"/>,
                     and the <termref def="dt-sweep"/> is <termref def="dt-free-ranging"/>.</p>
                  <p>In all other cases the function is <termref def="dt-grounded"/> and <termref
                        def="dt-motionless"/>.</p>
                  <note>
                     <p>The cases where <xfunction>last</xfunction> can be used without affecting
                        streamability are where the context item is either <termref
                           def="dt-grounded"/> or <termref def="dt-climbing"/>. The latter condition
                        makes expressions like <code>ancestor::*[@xml:space][last()]</code>
                        streamable.</p>
                     <p>There are special rules restricting the use of <xfunction>last</xfunction>
                        in the predicate of a pattern: see <specref ref="classifying-patterns"
                        />.</p>
                     <p diff="add" at="S-bug29153">Note that there are no restrictions preventing
                        the use of <code>last()</code> when the context posture is grounded. The
                        implications of this are discussed in <specref
                           ref="grounded-consuming-constructs"/>. In the case where the sequence
                        being processed is delivered by a consuming expression, using
                           <code>last()</code> may result in this sequence being buffered in
                        memory.</p>
                  </note>
               </div4>
               <div4 id="streamability-fn-outermost">
                  <head>Streamability of the <xfunction>outermost</xfunction> Function</head>
                  <p>The single argument to this function has <termref def="dt-operand-usage"/>
                     <termref def="dt-transmission"/>.</p>
                  <p>The streamability of the function call follows the <termref
                        def="dt-general-streamability-rules"/> with one exception: if the <termref
                        def="dt-posture"/> of the argument is <termref def="dt-crawling"/>, then the
                     posture of the result is <termref def="dt-striding"/>.</p>
                  <note>
                     <p>There are cases where the streaming rules allow the construct
                           <code>outermost(//para)</code> but do not allow <code>//para</code>; the
                        function can therefore be useful in cases where it is known that
                           <code>para</code> elements will not be nested, as well as cases where the
                        application actually wishes to process all <code>para</code> elements except
                        those that are nested within another.</p>
                     <p>By contrast, the <xfunction>innermost</xfunction> function offers no
                        streaming benefits. Although it delivers a subset of the input nodes as its
                        result, in the correct order, it is classed as navigational because it needs
                        to look ahead in the input stream before deciding whether a node can be
                        included in the result.</p>
                  </note>
               </div4>
               <div4 id="streamability-fn-position">
                  <head>Streamability of the <xfunction>position</xfunction> Function</head>
                  <p>The <xfunction>position</xfunction> function follows the <termref
                        def="dt-general-streamability-rules"/>. Since it has no operands, this means
                     it is <termref def="dt-grounded"/> and <termref def="dt-motionless"/>.</p>
                  <note>
                     <p>Within an expression, there are no special difficulties in evaluating the
                           <xfunction>position</xfunction> function.</p>
                     <p>It does have special treatment within a predicate of a <termref
                           def="dt-pattern"/>, however: a pattern is not motionless if it contains a
                        call to <xfunction>position</xfunction>, as explained in <specref
                           ref="classifying-patterns"/>. </p>
                  </note>
               </div4>
               <div4 id="streamability-fn-reverse" diff="add" at="R-bug24125">
                  <head>Streamability of the <xfunction>reverse</xfunction> Function</head>
                  <p>The <xfunction>reverse</xfunction> function follows the <termref
                        def="dt-general-streamability-rules"/>, with its operand classified as
                     having <termref def="dt-operand-usage"/>
                     <termref def="dt-navigation"/>.</p>
                  <note>
                     <p>This means in effect that a call on <xfunction>reverse</xfunction> is not
                        streamable unless the operand is grounded. This may cause few surprises:</p>
                     <ulist>
                        <item>
                           <p>The expression <code>reverse(/*/emp/copy-of())</code> is considered
                              streamable, although all the <code>emp</code> elements will typically
                              need to be in memory at the same time. The explanation here is that
                              the streamability rules do not attempt to restrict the amount of
                              memory used for data that is explicitly copied by use of a function
                              such as <function>copy-of</function>.</p>
                        </item>
                        <item>
                           <p>The expression <code>reverse(ancestor::*)/name()</code> is considered
                              non-streamable, because the operand is not grounded. This problem can
                              be circumvented by rewriting the expression as
                                 <code>reverse(ancestor::*/name())</code></p>
                        </item>
                     </ulist>
                  </note>
               </div4>
               <div4 id="streamability-fn-root">
                  <head>Streamability of the <xfunction>root</xfunction> Function</head>
                  <p>The zero-argument function <code>root()</code> is equivalent to
                        <code>root(.)</code>.</p>
                  <p>Given the expression <code>root(X)</code>, if the <termref def="dt-static-type"
                     /> of <code>X</code> is <var>U{document-node()}</var>, and if its <termref
                        def="dt-posture"/> is <termref def="dt-striding"/>, then
                        <code>root(X)</code> is rewritten as <code>X</code>. Otherwise, it is
                     rewritten as <code>head((X)/ancestor-or-self::node())</code>. Streamability
                     analysis is then applied to the rewritten expression.</p>
                  <note>
                     <p>Because path expressions starting with <code>/</code> are rewritten to use
                        the <xfunction>root</xfunction> function, this ensures that a leading slash
                        is ignored if the context item is a document node, for example within a
                        template rule with <code>match="/"</code>. This improves streamability,
                        because upwards navigation followed by downward navigation is
                        disallowed.</p>
                  </note>
               </div4>
            </div3>
            <div3 id="classifying-patterns">
               <head>Classifying Patterns</head>
               <note diff="add" at="P">
                  <p>Patterns differ from other kinds of construct in that they are not composable
                     in the same way. It is best to think of a pattern as specialized syntax for a
                     function that takes an item as its argument and returns a boolean: true if the
                     pattern matches the item, otherwise false. <phrase diff="chg" at="S-bug27250"
                        >The <termref def="dt-static-type"/> of a pattern is therefore taken as
                           <var>U{xs:boolean}</var> (this is not to be confused with the type of the
                        items that the pattern is capable of matching).</phrase></p>
               </note>
               <p diff="add" at="Q">The <termref def="dt-sweep"/> of a <termref def="dt-pattern"/>
                  is either <termref def="dt-motionless"/> or <termref def="dt-free-ranging"/>.
                  (Although there are patterns that could in principle be evaluated by consuming the
                  element node that they match, these are of no interest in the analysis, so they
                  are classified as free-ranging.)</p>
               <p diff="add" at="Q">The <termref def="dt-posture"/> of a <termref def="dt-pattern"/>
                  is <termref def="dt-grounded"/> if the pattern is <termref def="dt-motionless"/>,
                  or <termref def="dt-roaming"/> otherwise. (This reflects the fact that a pattern
                  always returns a boolean result; it never returns a node in a streamed
                  document.)</p>
               <p diff="del" at="Q">The streamability analysis of certain constructs requires
                  determination of whether a <termref def="dt-pattern">pattern</termref> (for
                  example, a pattern used as a match pattern in a streaming template, or for the
                     <code>group-starting-with</code> and <code>group-ending-with</code>
                  instructions in an <elcode>xsl:for-each-group</elcode> instruction within a
                  streaming template) is <termref def="dt-motionless"/>.</p>
               <p diff="chg" at="K">Informally, a <termref def="dt-motionless"/> pattern is one that
                  can be evaluated by a streaming processor when the input stream is positioned at
                  the start <phrase diff="chg" at="Q">of the node being matched</phrase>, without
                  advancing the input stream.</p>
               <p>A pattern is <termref def="dt-motionless"/> if <phrase diff="add" at="P-bug22937"
                     >and only if it satisfies <phrase diff="add" at="Q">all</phrase> the following
                     conditions:</phrase></p>
               <olist>
                  <item diff="chg" at="P-bug22937">
                     <p>The pattern does not contain a <nt
                           xmlns:xlink="http://www.w3.org/1999/xlink"
                           def="doc-xslt30-patterns-RootedPath" xlink:type="simple"
                        >RootedPath</nt>.</p>
                  </item>
                  <item diff="chg" at="P-bug22937">
                     <p>If the pattern contains predicates, then every top-level
                           <code>Predicate</code> in the pattern satisfies all the following
                        conditions:</p>
                     <olist>
                        <item>
                           <p>The expression immediately contained in the predicate is <termref
                                 def="dt-motionless"/>, <phrase diff="add" at="Q">when assessed with
                                 a <termref def="dt-context-posture"/> of <termref def="dt-striding"
                                 />, and a context item type set to the <termref
                                    def="dt-static-type"/> of the expression to which the predicate
                                 applies, determined using the rules in <specref
                                    ref="determining-static-type"/>.</phrase></p>
                        </item>
                        <item>
                           <p>The predicate is a <termref def="dt-non-positional-predicate"/>.</p>
                        </item>
                     </olist>
                     <p>The use of the term <term>top-level</term> in this rule means that
                        predicates that are nested within other predicates do not themselves have to
                        be non-positional, though they may play a role in the analysis of top-level
                        predicates.</p>
                  </item>
                  <item diff="add" at="S-bug27250">
                     <p>The pattern does not contain (at any depth) a variable reference that is
                        bound to a <phrase diff="chg" at="S-bug27571"><termref
                              def="dt-streaming-parameter"/></phrase>. (See <specref
                           ref="streamability-of-function-calls"/>).</p>
                  </item>
                  <item diff="del" at="R-bug24510">
                     <p>The pattern does not contain (at any depth) a variable reference bound to a
                        variable declared in the <code>bind-group</code> attribute of an
                           <elcode>xsl:for-each-group</elcode> instruction.</p>
                  </item>
               </olist>
               <p diff="chg" at="P-bug22937"><termdef id="dt-non-positional-predicate"
                     term="non-positional predicate" open="true">A predicate is a
                        <term>non-positional predicate</term> if it satisfies both of the following
                     conditions:</termdef></p>
               <olist diff="chg" at="P-bug22937">
                  <item>
                     <p>The predicate does not contain a function call or named function reference
                        to any of the following functions, unless that call or reference occurs
                        within a nested predicate:</p>
                     <olist>
                        <item>
                           <p><xfunction>position</xfunction></p>
                        </item>
                        <item>
                           <p><xfunction>last</xfunction></p>
                        </item>
                        <item>
                           <p><xfunction>function-lookup</xfunction>.</p>
                        </item>
                     </olist>
                     <note>
                        <p>The exception for nested predicates is there to ensure that patterns such
                           as <code>match="p[@code = $status[last()]]</code> are not
                           disqualified.</p>
                     </note>
                  </item>
                  <item>
                     <p diff="chg" at="P-bug22937">The expression immediately contained in the
                        predicate is a non-numeric expression. An expression is non-numeric if
                           <phrase diff="chg" at="R-bug24569">the intersection of its <termref
                              def="dt-static-type"/> (see <specref ref="determining-static-type"/>)
                           with <var>U{xs:decimal, xs:double, xs:float}</var> is
                           <var>U{}</var></phrase>.</p>
                  </item>
               </olist>
               <p role="closetermdef"/>
               <note>
                  <p diff="add" at="P-bug22937">A non-positional predicate can be evaluated by
                     considering each item in the filtered sequence independently; the result never
                     depends on the position of other items in the sequence or the length of the
                     sequence.</p>
               </note>
               <p>A pattern that is not <termref def="dt-motionless"/> is classified as <termref
                     def="dt-free-ranging"/>.</p>
               <p diff="add" at="P-bug22937">The following list shows examples of motionless
                  patterns:</p>
               <ulist diff="add" at="P-bug22937">
                  <item>
                     <p><code>/</code></p>
                  </item>
                  <item>
                     <p><code>*</code></p>
                  </item>
                  <item>
                     <p><code>/*</code></p>
                  </item>
                  <item>
                     <p><code>p</code></p>
                  </item>
                  <item>
                     <p><code>p|q</code></p>
                  </item>
                  <item>
                     <p><code>p/q</code></p>
                  </item>
                  <item>
                     <p><code>p[@status='red']</code></p>
                  </item>
                  <item>
                     <p><code>p[base-uri()]</code></p>
                  </item>
                  <item>
                     <p><code>p[@class or @style]</code></p>
                  </item>
                  <item>
                     <p><code>p[@status]</code></p>
                  </item>
                  <item>
                     <p><code>p[@status = $status-codes[1]]</code></p>
                  </item>
                  <item>
                     <p><code>p[@class | @style]</code></p>
                  </item>
                  <item>
                     <p><code>p[contains(@class, ':')]</code></p>
                  </item>
                  <item>
                     <p><code>p[substring-after(@class, ':')]</code></p>
                  </item>
                  <item>
                     <p><code>p[ancestor::*[@xml:lang]]</code></p>
                  </item>
                  <item>
                     <p><code>text()[starts-with(., '$')]</code></p>
                  </item>
                  <item>
                     <p><code>@price</code></p>
                  </item>
                  <item>
                     <p><code>@price[starts-with(., '$')]</code></p>
                  </item>
                  <item>
                     <p><code>//p/text()[. = 'Introduction']</code></p>
                  </item>
                  <item>
                     <p diff="add" at="R-bug24543"><code>document-node(element(html))</code> (Note:
                        this is classified as motionless even though testing a document node against
                        the pattern might require a small amount of look-ahead.)</p>
                  </item>
               </ulist>
               <p diff="add" at="P-bug22937">The following list shows examples of patterns that are
                  not motionless, explaining why not:</p>
               <ulist diff="add" at="P-bug22937">
                  <item>
                     <p><code>id('abc')</code> (contains a <code>RootedPath</code>)</p>
                  </item>
                  <item>
                     <p><code>$doc//p</code> (contains a <code>RootedPath</code>)</p>
                  </item>
                  <item>
                     <p><code>p[b]</code> (the predicate is not motionless)</p>
                  </item>
                  <item>
                     <p><code>p[. = 'Introduction']</code> (the predicate is not motionless)</p>
                  </item>
                  <item>
                     <p><code>p[starts-with(., '$')]</code> (the predicate is not motionless)</p>
                  </item>
                  <item>
                     <p><code>p[preceding-sibling::p[1] = '']</code> (the predicate is not
                        motionless)</p>
                  </item>
                  <item>
                     <p><code>p[1]</code> (contains a positional predicate: return type is
                        numeric)</p>
                  </item>
                  <item>
                     <p><code>p[$pnum + 1]</code> (contains a positional predicate: return type is
                        numeric)</p>
                  </item>
                  <item>
                     <p><code>p[data(@status)]</code> (contains a positional predicate: return type
                        is potentially numeric)</p>
                  </item>
                  <item>
                     <p><code>p[position() gt 2]</code> (contains a positional predicate: calls
                           <code>position()</code>)</p>
                  </item>
                  <item>
                     <p><code>p[last()]</code> (contains a positional predicate: calls
                           <code>last()</code>)</p>
                  </item>
               </ulist>
            </div3>
         </div2>
         <div2 id="streamability-analysis-examples">
            <head>Examples of Streamability Analysis</head>
            <p>The examples in this section are intended to illustrate how the streamability rules
               are applied “top down” to establish whether template rules are guaranteed
               streamable.</p>
            <example diff="chg" at="Q">
               <head>A recursive-descent template rule</head>
               <p>Consider the following template rule, where mode <code>s</code> is defined with
                     <code>streamable="yes"</code>:</p>
               <eg role="xslt-declaration" xml:space="preserve">
&lt;xsl:template match="para" mode="s"&gt;
  &lt;div class="para"&gt;
    &lt;xsl:apply-templates mode="s"/&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;</eg>
               <p>The processor is required to establish that this template meets the streamability
                  rules. Specifically, as stated in <specref ref="streamable-templates"/>, it must
                  satisfy three conditions:</p>
               <olist>
                  <item>
                     <p>The match pattern must be <termref def="dt-motionless"/>.</p>
                  </item>
                  <item>
                     <p>The body of the template rule must be <termref def="dt-grounded"/>.</p>
                  </item>
                  <item>
                     <p>The initializers of any template parameters must be <termref
                           def="dt-motionless"/>.</p>
                  </item>
               </olist>
               <p>The third condition is satisfied trivially because there are no parameters.</p>
               <p>The first rule depends on the rules for assessing patterns, which are given in
                     <specref ref="classifying-patterns"/>. This pattern is motionless because (a)
                  it does not contain a <code>RootedPath</code>, and (b) it contains no
                  predicates.</p>
               <p>So it remains to determine that the body of the template is <termref
                     def="dt-grounded"/>. The proof of this is as follows:</p>
               <olist>
                  <item>
                     <p>The sequence constructor forming the body of the template is assessed
                        according to the rules in <specref ref="classifying-sequence-constructors"
                        />, which tell us that there is a single operand (the
                           <code>&lt;div&gt;</code>
                        <termref def="dt-literal-result-element"/>) which has <termref
                           def="dt-operand-usage"/>
                        <var>U</var> = <termref def="dt-transmission"/>. </p>
                  </item>
                  <item>
                     <p>The assessment of the sequence constructor uses the <termref
                           def="dt-general-streamability-rules"/>. These rules require us to
                        determine the type <var>T</var>, sweep <var>S</var>, posture <var>P</var>,
                        and usage <var>U</var> of each operand. We have already established that
                        there is a single operand, with <var>U</var> = <termref
                           def="dt-transmission"/>. Section <specref ref="determining-static-type"/>
                        tells us that for all instructions, we can take <var>T</var> =
                           <var>U{*}</var>. The <termref def="dt-posture"/>
                        <var>P</var> and <termref def="dt-sweep"/>
                        <var>S</var> of the literal result element are established as follows:</p>
                     <olist>
                        <item>
                           <p>The rules for literal result elements (specifically the
                                 <code>&lt;div&gt;</code> element) are given in <specref
                                 ref="streamability-literal-result-elements"/>. This particular
                              literal result element has only one operand (its contained sequence
                              constructor), with <termref def="dt-operand-usage"/>
                              <var>U</var> = <termref def="dt-absorption"/>.</p>
                        </item>
                        <item>
                           <p>The <termref def="dt-general-streamability-rules"/> again apply. Again
                              the <termref def="dt-static-type"/>
                              <var>T</var> of the operand is <code>U{*}</code>, and we need to
                              determine the <termref def="dt-posture"/>
                              <var>P</var> and <termref def="dt-sweep"/>
                              <var>S</var>.</p>
                        </item>
                        <item>
                           <p>To determine the posture and sweep of this sequence constructor (the
                              one that contains the <elcode>xsl:apply-templates</elcode>
                              instruction) we refer again to the <termref
                                 def="dt-general-streamability-rules"/>.</p>
                           <olist>
                              <item>
                                 <p>The sequence constructor has a single operand (the
                                       <elcode>xsl:apply-templates</elcode> instruction); again
                                       <var>U</var> = <termref def="dt-transmission"/>, <var>T</var>
                                    = <var>U{*}</var>.</p>
                              </item>
                              <item>
                                 <p>The <termref def="dt-posture"/>
                                    <var>P</var> and <termref def="dt-sweep"/>
                                    <var>S</var> of the <elcode>xsl:apply-templates</elcode>
                                    instruction are established as follows:</p>
                                 <olist>
                                    <item>
                                       <p>The rules that apply are in <specref
                                             ref="streamability-xsl-apply-templates"/>.</p>
                                    </item>
                                    <item>
                                       <p>Rule 1 does not apply because the <code>select</code>
                                          expression (which defaults to <code>child::node()</code>)
                                          is not <termref def="dt-grounded"/>. This is a consequence
                                          of the rules in <specref ref="streamability-of-axis-steps"
                                          />, specifically:</p>
                                       <olist>
                                          <item>
                                             <p>The <termref def="dt-context-posture"/> of the axis
                                                step is established by the template rule as a whole,
                                                as <termref def="dt-striding"/>.</p>
                                          </item>
                                          <item>
                                             <p>Therefore rules 1 and 2 do not apply.</p>
                                          </item>
                                          <item>
                                             <p>The statically-inferred context item type is derived
                                                from the match pattern (<code>match="para"</code>).
                                                This gives a type of <var>U{element()}</var>. The
                                                child axis for element nodes is not necessarily
                                                empty, so rule 3 does not apply.</p>
                                          </item>
                                          <item>
                                             <p>Rule 4 does not apply because there are no
                                                predicates.</p>
                                          </item>
                                          <item>
                                             <p>So the <termref def="dt-posture"/> and <termref
                                                  def="dt-sweep"/> of the axis step
                                                  <code>child::node()</code> are given by the table
                                                in rule 5. The entry for (context posture =
                                                striding, axis = child) gives a posture of <termref
                                                  def="dt-striding"/> and a <termref def="dt-sweep"
                                                /> of <termref def="dt-consuming"/>.</p>
                                          </item>
                                          <item>
                                             <p>So the <code>select</code> expression is not
                                                  <termref def="dt-grounded"/>. (The same result can
                                                be reached intuitively: an expression that selects
                                                streamed nodes will never be <termref
                                                  def="dt-grounded"/>.)</p>
                                          </item>
                                       </olist>
                                    </item>
                                    <item>
                                       <p>Rule 2 does not apply because there is no
                                             <elcode>xsl:sort</elcode> element.</p>
                                    </item>
                                    <item>
                                       <p>Rule 3 does not apply because the mode is declared with
                                             <code>streamable="yes"</code>.</p>
                                    </item>
                                    <item>
                                       <p>So the <termref def="dt-posture"/>
                                          <var>P</var> and <termref def="dt-sweep"/>
                                          <var>S</var> of the <elcode>xsl:apply-templates</elcode>
                                          instruction are established by the <termref
                                             def="dt-general-streamability-rules"/>, as follows:</p>
                                       <olist>
                                          <item>
                                             <p>There is a single operand, the implicit
                                                  <code>select="child::node()"</code> expression,
                                                with usage <var>U</var> = <termref
                                                  def="dt-absorption"/>.</p>
                                          </item>
                                          <item>
                                             <p>We have already established that for this operand,
                                                the posture <var>P</var> = <termref
                                                  def="dt-striding"/> and the <termref
                                                  def="dt-sweep"/>
                                                <var>S</var> = <termref def="dt-consuming"/>.</p>
                                          </item>
                                          <item>
                                             <p>By the rules in <specref
                                                  ref="determining-static-type"/>, the type
                                                  <var>T</var> of the <code>select</code> expression
                                                is <code>node()</code>.</p>
                                          </item>
                                          <item>
                                             <p>In the <termref def="dt-general-streamability-rules"
                                                />, the adjusted sweep <var>S'</var> for an operand
                                                with (<var>P</var> = <termref def="dt-striding"/>,
                                                  <var>U</var> = <termref def="dt-absorption"/>) is
                                                  <termref def="dt-consuming"/>, </p>
                                          </item>
                                          <item>
                                             <p>Rule 2(d) then applies, so the
                                                  <elcode>xsl:apply-templates</elcode> instruction
                                                is <termref def="dt-consuming"/> and <termref
                                                  def="dt-grounded"/>.</p>
                                          </item>
                                       </olist>
                                    </item>
                                 </olist>
                              </item>
                              <item>
                                 <p>So the sequence constructor that contains the
                                       <elcode>xsl:apply-templates</elcode> instruction has one
                                    operand with <var>U</var> = <termref def="dt-transmission"/>,
                                       <var>T</var> = <code>item()</code>, <var>P</var> = <termref
                                       def="dt-grounded"/>, <var>S</var> = <termref
                                       def="dt-consuming"/>. Rule 2(d) of the <termref
                                       def="dt-general-streamability-rules"/> applies, so the
                                    sequence constructor itself has <var>P</var> = <termref
                                       def="dt-grounded"/>, <var>S</var> = <termref
                                       def="dt-consuming"/>.</p>
                              </item>
                           </olist>
                        </item>
                        <item>
                           <p>So the literal result element has one operand with <var>U</var> =
                                 <termref def="dt-absorption"/>, <var>T</var> = <code>item()</code>,
                                 <var>P</var> = <termref def="dt-grounded"/>, <var>S</var> =
                                 <termref def="dt-consuming"/>. Rule 2(d) of the <termref
                                 def="dt-general-streamability-rules"/> applies, so the literal
                              result element has <var>P</var> = <termref def="dt-grounded"/>,
                                 <var>S</var> = <termref def="dt-consuming"/>.</p>
                        </item>
                     </olist>
                  </item>
                  <item>
                     <p>So the sequence constructor containing the literal result element has one
                        operand with <var>U</var> = <termref def="dt-transmission"/>, <var>T</var> =
                           <code>item()</code>, <var>P</var> = <termref def="dt-grounded"/>,
                           <var>S</var> = <termref def="dt-consuming"/>. Rule 2(d) of the <termref
                           def="dt-general-streamability-rules"/> applies, so this sequence
                        constructor itself has <var>P</var> = <termref def="dt-grounded"/>,
                           <var>S</var> = <termref def="dt-consuming"/>.</p>
                  </item>
                  <item>
                     <p>So we have established that the sequence constructor forming the body of the
                        template rule is <termref def="dt-grounded"/>.</p>
                  </item>
               </olist>
               <p>Therefore, since the other conditions are also satisfied, the template is <termref
                     def="dt-guaranteed-streamable"/>.</p>
               <p>The analysis presented above could have been simplified by taking into account the
                  fact that the streamability properties of a sequence constructor containing a
                  single instruction are identical to the properties of that instruction. This
                  simplification will be exploited in the next example.</p>
            </example>
            <example diff="chg" at="Q">
               <head>An aggregating template rule</head>
               <p>Consider the following template rule, where mode <code>s</code> is defined with
                     <code>streamable="yes"</code>:</p>
               <eg role="xslt-declaration" xml:space="preserve">
&lt;xsl:template match="transactions[@currency='USD']" mode="s"&gt;
  &lt;total&gt;&lt;xsl:value-of select="sum(transaction/@value)"/&gt;&lt;/total&gt;
&lt;/xsl:template&gt;</eg>
               <p>Again, as stated in <specref ref="streamable-templates"/>, it must satisfy three
                  conditions:</p>
               <olist>
                  <item>
                     <p>The match pattern must be <termref def="dt-motionless"/>.</p>
                  </item>
                  <item>
                     <p>The body of the template rule must be <termref def="dt-grounded"/>.</p>
                  </item>
                  <item>
                     <p>The initializers of any template parameters must be <termref
                           def="dt-motionless"/>.</p>
                  </item>
               </olist>
               <p>The third condition is satisfied trivially because there are no parameters.</p>
               <p>The first rule depends on the rules for assessing patterns, which are given in
                     <specref ref="classifying-patterns"/>. This pattern is motionless because (a)
                  it is not a <code>RootedPath</code>, and (b) every predicate is <termref
                     def="dt-motionless"/> and <termref def="dt-non-positional-predicate"
                     >non-positional</termref>. The analysis that proves the predicate is motionless
                  and non-positional proceeds as follows:</p>
               <olist>
                  <item>
                     <p>First establish that that the expression <code>@currency='USD'</code> is
                           <termref def="dt-motionless"/>, as follows:</p>
                     <olist>
                        <item>
                           <p>The predicate is a general comparison (<code>GeneralComp</code>) which
                              follows the <termref def="dt-general-streamability-rules"/>.</p>
                        </item>
                        <item>
                           <p>There are two operands: an <code>AxisStep</code> with a defaulted
                                 <code>ForwardAxis</code>, and a <code>Literal</code>. Both operand
                              roles are <termref def="dt-absorption"/>.</p>
                        </item>
                        <item>
                           <p>The <phrase diff="chg" at="R-bug24536">left-hand</phrase> operand has
                              type <var>T</var> = <code>attribute()</code>. Its <termref
                                 def="dt-posture"/> and <termref def="dt-sweep"/> are determined by
                              the rules in <specref ref="streamability-of-axis-steps"/>. The
                                 <termref def="dt-context-posture"/> is <termref def="dt-striding"
                              />, so the <termref def="dt-posture"/> and <termref def="dt-sweep"/>
                              are determined by the entry in the table (rule 5) with context posture
                              = <termref def="dt-striding"/>, axis = <code>attribute</code>: that
                              is, the result posture is <phrase diff="chg" at="S-bug27051"><termref
                                    def="dt-striding"/></phrase> and the <termref def="dt-sweep"/>
                              is <termref def="dt-motionless"/>.</p>
                        </item>
                        <item>
                           <p>The <phrase diff="chg" at="R-bug24536">right-hand</phrase> operand,
                              being a literal, is <termref def="dt-grounded"/> and <termref
                                 def="dt-motionless"/>.</p>
                        </item>
                        <item>
                           <p>In the <termref def="dt-general-streamability-rules"/>, rule 2(e)
                              applies, so the predicate is <termref def="dt-grounded"/> and <termref
                                 def="dt-motionless"/></p>
                        </item>
                     </olist>
                  </item>
                  <item>
                     <p>Now establish that that the expression <code>@currency='USD'</code> is
                           <termref def="dt-non-positional-predicate">non-positional</termref>, as
                        follows:</p>
                     <olist>
                        <item>
                           <p>Rule 1 is satisfied: the predicate does not call
                                 <xfunction>position</xfunction>, <xfunction>last</xfunction>, or
                                 <xfunction>function-lookup</xfunction>.</p>
                        </item>
                        <item>
                           <p>Rule 2 is satisfied: the expression <code>@currency='USD'</code> is
                              non-numeric. The <termref def="dt-static-type"/> of the expression is
                              determined using the rules in <specref ref="determining-static-type"/>
                              as <var>U{xs:boolean}</var>, and this has no intersection with
                                 <var>U{xs:decimal, xs:double, xs:float}</var>.</p>
                        </item>
                     </olist>
                  </item>
               </olist>
               <p>So both conditions in <specref ref="classifying-patterns"/> are satisfied, and the
                  pattern is therefore <termref def="dt-motionless"/>.</p>
               <p>It remains to show that the body of the template rule is <termref
                     def="dt-grounded"/>. The proof of this is as follows. Unlike the previous
                  example, the analysis is shown in simplified form; in particular the two sequence
                  constructors which each contain a single instruction are ignored, and replaced in
                  the construct tree by their contained instruction.</p>
               <olist>
                  <item>
                     <p>We need to show that the <code>&lt;total&gt;</code>
                        <termref def="dt-literal-result-element"/> is <termref def="dt-grounded"
                        />.</p>
                  </item>
                  <item>
                     <p>The rules that apply are in <specref
                           ref="streamability-literal-result-elements"/>.</p>
                  </item>
                  <item>
                     <p>These rules refer to the <termref def="dt-general-streamability-rules"/>.
                        There is one operand, the <elcode>xsl:value-of</elcode> child element, which
                        has <termref def="dt-operand-usage"/>
                        <var>U</var> = <termref def="dt-absorption"/>, and type <var>T</var> =
                           <code>item()</code>.</p>
                  </item>
                  <item>
                     <p>So we need to determine the <termref def="dt-posture"/> and <termref
                           def="dt-sweep"/> of the <elcode>xsl:value-of</elcode> instruction.</p>
                     <olist>
                        <item>
                           <p>The rules are given in <specref ref="streamability-xsl-value-of"
                              />.</p>
                        </item>
                        <item>
                           <p>The <termref def="dt-general-streamability-rules"/> apply. There is
                              one operand, the expression <code>sum(transaction/@value)</code>,
                              which has <termref def="dt-operand-usage"/>
                              <var>U</var> = <termref def="dt-absorption"/>.</p>
                        </item>
                        <item>
                           <p>The type <var>T</var> of this operand is the return type defined in
                              the signature of the <xfunction>sum</xfunction> function, that is,
                                 <code>xs:anyAtomicType</code>.</p>
                        </item>
                        <item>
                           <p>The <termref def="dt-posture"/>
                              <var>P</var> and <termref def="dt-sweep"/>
                              <var>S</var> are established as follows:</p>
                           <olist>
                              <item>
                                 <p>The rules that apply to the call on <xfunction>sum</xfunction>
                                    are given in <specref ref="classifying-built-in-functions"
                                    />.</p>
                              </item>
                              <item>
                                 <p>The relevant proforma is <code>fn:sum(A)</code>, indicating that
                                    the <termref def="dt-general-streamability-rules"/> apply, and
                                    that there is a single operand with usage <var>U</var> =
                                       <termref def="dt-absorption"/>.</p>
                              </item>
                              <item>
                                 <p>The type <var>T</var> of the operand
                                       <code>transaction/@value</code> is determined (by the rules
                                    in <specref ref="determining-static-type"/>) as
                                       <code>attribute()</code>.</p>
                              </item>
                              <item>
                                 <p>The <termref def="dt-posture"/>
                                    <var>P</var> and <termref def="dt-sweep"/>
                                    <var>S</var> of the operand <code>transaction/@value</code> are
                                    determined by the rules in <specref
                                       ref="streamability-of-path-expressions"/>, as follows:</p>
                                 <olist>
                                    <item>
                                       <p>The expression is expanded to
                                             <code>child::transaction/attribute::value</code>.</p>
                                    </item>
                                    <item>
                                       <p>The <termref def="dt-posture"/> and <termref
                                             def="dt-sweep"/> of the <phrase diff="chg"
                                             at="R-bug24536">left-hand</phrase> operand
                                             <code>child::transaction</code> are determined by the
                                          rules in <specref ref="streamability-of-axis-steps"/>, as
                                          follows:</p>
                                       <olist>
                                          <item>
                                             <p>The <termref def="dt-context-posture"/> is <termref
                                                  def="dt-striding"/>, because the <termref
                                                  def="dt-focus-setting-container"/> is the template
                                                rule itself.</p>
                                          </item>
                                          <item>
                                             <p>The <termref def="dt-context-item-type"/> is
                                                  <code>element()</code>, based on the <termref
                                                  def="dt-match-type"/> of the pattern
                                                  <code>match="transactions[@currency='USD']"</code>.</p>
                                          </item>
                                          <item>
                                             <p>Rules 1 and 2 do not apply because the <termref
                                                  def="dt-context-posture"/> is <termref
                                                  def="dt-striding"/>.</p>
                                          </item>
                                          <item>
                                             <p>Rule 3 does not apply because the <code>child</code>
                                                axis applied to an element node is not necessarily
                                                empty.</p>
                                          </item>
                                          <item>
                                             <p>Rule 4 does not apply because there are no
                                                predicates.</p>
                                          </item>
                                          <item>
                                             <p>Rule 5 applies, and the table entry with context
                                                posture = <termref def="dt-striding"/>, axis =
                                                  <code>child</code> gives a result <termref
                                                  def="dt-posture"/> of <termref def="dt-striding"/>
                                                and a <termref def="dt-sweep"/> of <termref
                                                  def="dt-consuming"/>.</p>
                                          </item>
                                       </olist>
                                    </item>
                                    <item>
                                       <p>The <termref def="dt-posture"/> of the relative path
                                          expression
                                             <code>child::transaction/attribute::value</code> is
                                          therefore the <termref def="dt-posture"/> of its <phrase
                                             diff="chg" at="R-bug24536">right-hand</phrase> operand
                                             <code>attribute::value</code>, assessed with a <termref
                                             def="dt-context-posture"/> of <termref
                                             def="dt-striding"/>. This is determined by the rules in
                                             <specref ref="streamability-of-axis-steps"/>, as
                                          follows:</p>
                                       <olist>
                                          <item>
                                             <p>The <termref def="dt-context-posture"/>, as we have
                                                seen, is <termref def="dt-striding"/>.</p>
                                          </item>
                                          <item>
                                             <p>The <termref def="dt-context-item-type"/> is
                                                  <code>element()</code>, based on the type of the
                                                  <phrase diff="chg" at="R-bug24536"
                                                  >left-hand</phrase> operand
                                                  <code>child::transaction</code>.</p>
                                          </item>
                                          <item>
                                             <p>Rules 1 and 2 do not apply because the <termref
                                                  def="dt-context-posture"/> is <termref
                                                  def="dt-striding"/>.</p>
                                          </item>
                                          <item>
                                             <p>Rule 3 does not apply because the
                                                  <code>attribute</code> axis applied to an element
                                                node is not necessarily empty.</p>
                                          </item>
                                          <item>
                                             <p>Rule 4 does not apply because there are no
                                                predicates.</p>
                                          </item>
                                          <item>
                                             <p>Rule 5 applies, and the table entry with context
                                                posture = <termref def="dt-striding"/>, axis =
                                                  <code>attribute</code> gives a result <termref
                                                  def="dt-posture"/> of <phrase diff="chg"
                                                  at="S-bug27051"><termref def="dt-striding"
                                                  /></phrase> and a <termref def="dt-sweep"/> of
                                                  <termref def="dt-motionless"/>.</p>
                                          </item>
                                       </olist>
                                    </item>
                                    <item>
                                       <p>The <termref def="dt-posture"/> of the relative path
                                          expression
                                             <code>child::transaction/attribute::value</code> is
                                          therefore <phrase diff="chg" at="S-bug27051"><termref
                                                def="dt-striding"/></phrase>.</p>
                                    </item>
                                    <item>
                                       <p>The <termref def="dt-sweep"/> of the relative path
                                          expression
                                             <code>child::transaction/attribute::value</code> is the
                                          wider of the sweeps of its two operands, namely <termref
                                             def="dt-consuming"/> and <termref def="dt-motionless"
                                          />. That is, it is <termref def="dt-consuming"/>.</p>
                                    </item>
                                 </olist>
                              </item>
                              <item>
                                 <p>So the first and only operand to the call on <code>sum()</code>
                                    has <var>U</var> = <termref def="dt-absorption"/>, <var>T</var>
                                    = <code>attribute()</code>, <var>P</var> = <termref
                                       def="dt-climbing"/>, and <var>S</var> = <termref
                                       def="dt-consuming"/></p>
                              </item>
                              <item>
                                 <p>Rule 1(b) of the <termref def="dt-general-streamability-rules"/>
                                    computes the adjusted sweep <var>S'</var>. Rule 1(b)(iii)(A)
                                    applies, so the effective <termref def="dt-operand-usage"/>
                                    <var>U'</var> is <termref def="dt-inspection"/>. Rule
                                    1(b)(iii)(A) then computes the adjusted sweep from the table
                                    entry for <var>P</var> = <termref def="dt-climbing"/>,
                                       <var>U'</var> = <termref def="dt-inspection"/>; this shows
                                       <var>S'</var> = <var>S</var>, that is, <termref
                                       def="dt-consuming"/>.</p>
                              </item>
                              <item>
                                 <p>Rule 2(d) now applies, so the call on <code>sum()</code> is
                                       <termref def="dt-grounded"/> and <termref def="dt-consuming"
                                    />.</p>
                              </item>
                           </olist>
                        </item>
                        <item>
                           <p>Since the <elcode>xsl:value-of</elcode> instruction has one operand
                              with <var>U</var> = <termref def="dt-absorption"/>, <var>T</var> =
                                 <code>xs:anyAtomicType</code>, <var>P</var> = <termref
                                 def="dt-grounded"/>, and <var>S</var> = <termref def="dt-consuming"
                              />, rule 2(d) again applies, and the <elcode>xsl:value-of</elcode>
                              instruction is <termref def="dt-grounded"/> and <termref
                                 def="dt-consuming"/>.</p>
                        </item>
                     </olist>
                  </item>
                  <item>
                     <p>Since the literal result element has one operand with <var>U</var> =
                           <termref def="dt-absorption"/>, <var>T</var> = <code>item()</code>,
                           <var>P</var> = <termref def="dt-grounded"/>, and <var>S</var> = <termref
                           def="dt-consuming"/>, rule 2(d) again applies, and the literal result
                        element is <termref def="dt-grounded"/> and <termref def="dt-consuming"
                        />.</p>
                  </item>
                  <item>
                     <p>Therefore the body of the template rule is <termref def="dt-grounded"/>, and
                        since the other conditions are also satisfied, it is <termref
                           def="dt-guaranteed-streamable"/>.</p>
                  </item>
               </olist>
            </example>
            <example diff="chg" at="R-bug24510">
               <head>Streamed Grouping</head>
               <p>Consider the following code, which is designed to process a transaction file
                  containing transactions in chronological order, and output the total value of the
                  transactions for each day.</p>
               <eg role="xslt-declaration" xml:space="preserve">
&lt;xsl:template name="go"&gt;
  &lt;out&gt;
    &lt;xsl:source-document streamable="yes" href="transactions.xml"&gt;
      &lt;xsl:for-each-group select="/account/transaction" 
                          group-adjacent="xs:date(@timestamp)"&gt;
         &lt;total date="{current-grouping-key()}" value="{sum(current-group()/@value)}"/&gt;
      &lt;/xsl:for-each-group&gt;
    &lt;/xsl:source-document&gt;
  &lt;/out&gt;
&lt;/xsl:template&gt;</eg>
               <p>The rules for <elcode>xsl:source-document</elcode> say that the instruction is
                     <termref def="dt-guaranteed-streamable"/> if the contained <termref
                     def="dt-sequence-constructor"/> is <termref def="dt-grounded"/>, and the task
                  of streamability analysis is to prove that this is the case. As in the previous
                  example, we will take a short-cut by making the assumption that a sequence
                  constructor containing a single instruction can be replaced by that instruction in
                  the construct tree.</p>
               <p>So the task is to show that the <elcode>xsl:for-each-group</elcode> instruction is
                     <termref def="dt-grounded"/>, which we can do as follows:</p>
               <olist>
                  <item>
                     <p>The relevant rules are to be found in <specref
                           ref="streamability-xsl-for-each-group"/>.</p>
                     <note>
                        <p>Rule numbers may be different in a version of the specification with
                           change markings.</p>
                     </note>
                  </item>
                  <item>
                     <p>Rule 1 applies only if the <code>select</code> expression is <termref
                           def="dt-grounded"/>. It is easy to see informally that this is not the
                        case (an expression that returns streamed nodes is never grounded). More
                        formally:</p>
                     <olist>
                        <item>
                           <p>The <code>select</code> expression is a path expression; the rules in
                                 <specref ref="streamability-of-path-expressions"/> apply.</p>
                        </item>
                        <item>
                           <p>The expression is rewritten as <code>((root(.) treat as
                                 document-node())/child::account)/child::transaction</code></p>
                        </item>
                        <item>
                           <p>The left-hand operand <code>(root(.) treat as
                                 document-node())/child::account</code> is also a path expression,
                              so the rules in <specref ref="streamability-of-path-expressions"/>
                              apply recursively:</p>
                           <olist>
                              <item>
                                 <p>The left-hand operand <code>root(.) treat as
                                       document-node()</code> follows the rules for a
                                       <code>TreatExpr</code> in <specref
                                       ref="classifying-expressions"/>; the proforma <code>T treat
                                       as TYPE</code> indicates that the <termref
                                       def="dt-general-streamability-rules"/> apply with a single
                                    operand having usage <termref def="dt-transmission"/>.</p>
                              </item>
                              <item>
                                 <p>This single operand <code>root(.)</code> follows the rules in
                                       <specref ref="streamability-fn-root"/>. The item type of the
                                    operand <code>.</code> is the <termref
                                       def="dt-context-item-type"/>, which is the type established
                                    by the <elcode>xsl:source-document</elcode> instruction, namely
                                       <code>document-node()</code>. Under these conditions
                                       <code>root(.)</code> is rewritten as <code>.</code>, so the
                                       <termref def="dt-posture"/> is the <termref
                                       def="dt-context-posture"/> established by the
                                       <elcode>xsl:source-document</elcode> instruction, namely
                                       <termref def="dt-striding"/>. The <termref def="dt-sweep"/>
                                    is <termref def="dt-motionless"/>.</p>
                              </item>
                              <item>
                                 <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                                    the expression <code>root(.) treat as document-node()</code> are
                                    the same as the <termref def="dt-posture"/> and <termref
                                       def="dt-sweep"/> of <code>root(.)</code>, namely <termref
                                       def="dt-striding"/> and <termref def="dt-motionless"/></p>
                              </item>
                              <item>
                                 <p>The right-hand operand <code>child::account</code> is governed
                                    by the rules in <specref ref="streamability-of-axis-steps"/>.
                                    The <termref def="dt-context-posture"/> is <termref
                                       def="dt-striding"/>, and the axis is <code>child</code>, so
                                    the result posture is <termref def="dt-striding"/> and the sweep
                                    is <termref def="dt-consuming"/>.</p>
                              </item>
                              <item>
                                 <p>The <termref def="dt-posture"/> of the path expression is the
                                       <termref def="dt-posture"/> of the right-hand operand, that
                                    is <termref def="dt-striding"/>, and its sweep is the wider
                                    sweep of the two operands, that is <termref def="dt-consuming"
                                    /></p>
                              </item>
                           </olist>
                        </item>
                        <item>
                           <p>Returning to the outer path expression, the <termref def="dt-posture"
                              /> of the right hand operand <code>child::transaction</code> is
                                 <termref def="dt-striding"/>, and its sweep is <termref
                                 def="dt-consuming"/>.</p>
                        </item>
                        <item>
                           <p>So the <termref def="dt-posture"/> of the <code>select</code>
                              expression as a whole is the posture of the right hand operand, that
                              is <termref def="dt-striding"/>; and its sweep is the wider of the
                              sweeps of the operands, which is <termref def="dt-consuming"/>.</p>
                        </item>
                     </olist>
                  </item>
                  <item>
                     <p>Rule 2 does not apply: there is no <code>group-by</code> attribute.</p>
                  </item>
                  <item>
                     <p>Rule 3 does not apply: there is a <code>group-adjacent</code> attribute, but
                        it is <termref def="dt-motionless"/>. The reasoning is as follows:</p>
                     <olist>
                        <item>
                           <p>The value is a call to the constructor function <code>xs:date</code>.
                              The rules in <specref ref="streamability-of-function-calls"/> apply.
                              There is a single operand, whose required type is atomic, so the
                                 <termref def="dt-operand-usage"/> is <termref def="dt-absorption"
                              />.</p>
                        </item>
                        <item>
                           <p>These rules refer to the <termref def="dt-general-streamability-rules"
                              />, so we need to determine the <termref def="dt-context-item-type"/>,
                                 <termref def="dt-posture"/>, and <termref def="dt-sweep"/> of the
                              operand expression <code>@timestamp</code>. This is done as
                              follows:</p>
                           <olist>
                              <item>
                                 <p>The expression is an <code>AxisStep</code>, so the relevant
                                    rules are in <specref ref="streamability-of-axis-steps"/>.</p>
                              </item>
                              <item>
                                 <p>The <termref def="dt-context-posture"/> is the <termref
                                       def="dt-posture"/> of the <termref
                                       def="dt-controlling-operand"/> of the <termref
                                       def="dt-focus-setting-container"/>, that is, is the
                                       <code>select</code> expression of the containing
                                       <elcode>xsl:for-each-group</elcode> instruction, which as
                                    established above is <termref def="dt-striding"/>. The <termref
                                       def="dt-context-item-type"/> is similarly the inferred type
                                    of the <code>select</code> expression, and is
                                       <code>element()</code>.</p>
                              </item>
                              <item>
                                 <p>Rules 1 and 2 do not apply because the <termref
                                       def="dt-context-posture"/> is <termref def="dt-striding"
                                    />.</p>
                              </item>
                              <item>
                                 <p>Rule 3 does not apply because the attribute axis for an element
                                    node is not necessarily empty.</p>
                              </item>
                              <item>
                                 <p>Rule 4 does not apply because there is no predicate.</p>
                              </item>
                              <item>
                                 <p>So the <termref def="dt-sweep"/> and <termref def="dt-posture"/>
                                    of the expression <code>@timestamp</code> are given by the table
                                    in Rule 5 as <phrase diff="chg" at="S-bug27051"><termref
                                          def="dt-striding"/></phrase> and <termref
                                       def="dt-motionless"/>.</p>
                              </item>
                           </olist>
                        </item>
                        <item>
                           <p>Returning to the <termref def="dt-general-streamability-rules"/> for
                              the expression <code>xs:date(@timestamp)</code>, the <phrase
                                 diff="chg" at="R-bug24536">operand <code>@timestamp</code></phrase>
                              has <var>U</var> = <termref def="dt-absorption"/>, <var>T</var> =
                                 <code>attribute()</code>, <var>P</var> = <phrase diff="chg"
                                 at="S-bug27051"><termref def="dt-striding"/></phrase>, <var>S</var>
                              = <termref def="dt-motionless"/>. </p>
                        </item>
                        <item>
                           <p>Under Rule 1(b)(iii)(A), because <var>T</var> =
                                 <code>attribute()</code>, the <termref def="dt-operand-usage"/>
                              <var>U'</var> becomes <termref def="dt-inspection"/>.</p>
                        </item>
                        <item>
                           <p>Under Rule 1(b)(iii)(A), <var>S'</var> = <var>S</var> = <termref
                                 def="dt-motionless"/>.</p>
                        </item>
                        <item>
                           <p>Under Rule 2(e), the expression <code>xs:date(@timestamp)</code> is
                                 <termref def="dt-grounded"/> and <termref def="dt-motionless"
                              />.</p>
                        </item>
                     </olist>
                  </item>
                  <item diff="chg" at="R-bug24510">
                     <p>Rule 4 (under <elcode>xsl:for-each-group</elcode>) does not apply, because
                        there is no <elcode>xsl:sort</elcode> child.</p>
                  </item>
                  <item diff="del" at="R-bug24510">
                     <p>Rule 6 does not apply, because there is a <code>bind-group</code>
                        attribute.</p>
                  </item>
                  <item diff="del" at="R-bug24510">
                     <p>Rule 7 does not apply, because both <code>group-adjacent</code> and
                           <code>bind-grouping-key</code> are present.</p>
                  </item>
                  <item>
                     <p>So Rule 5 applies. This relies on knowing the <termref def="dt-posture"/> of
                        the sequence constructor contained in the
                           <elcode>xsl:for-each-group</elcode> instruction: that is, the <termref
                           def="dt-posture"/> of the <code>total</code>
                        <termref def="dt-literal-result-element"/>. This is calculated as
                        follows:</p>
                     <olist>
                        <item>
                           <p>The rules that apply are in <specref
                                 ref="streamability-literal-result-elements"/>. The <termref
                                 def="dt-general-streamability-rules"/> apply; there are two
                              operands, the attribute value templates
                                 <code>{current-grouping-key()}</code> and
                                 <code>{sum(current-group()/@value)}</code>, and in each case the
                              usage is <termref def="dt-absorption"/>. We can simplify the analysis
                              by observing that the empty <termref def="dt-sequence-constructor"/>
                              contained in the literal result element can be ignored, since it is
                                 <termref def="dt-grounded"/> and <termref def="dt-motionless"/>.
                           </p>
                        </item>
                        <item>
                           <p>Consider first the operand <code>{current-grouping-key()}</code>.</p>
                           <olist>
                              <item>
                                 <p>Section <specref ref="classifying-vts"/> applies. This refers to
                                    the <termref def="dt-general-streamability-rules"/>; there is a
                                    single operand, the expression
                                       <code>current-grouping-key()</code>, with usage <termref
                                       def="dt-absorption"/>.</p>
                              </item>
                              <item>
                                 <p>Section <specref ref="streamability-fn-current-grouping-key"/>
                                    applies. This establishes that the expression is <termref
                                       def="dt-grounded"/> and <termref def="dt-motionless"/>.</p>
                              </item>
                              <item>
                                 <p>It follows that the operand
                                       <code>{current-grouping-key()}</code> expression is also
                                       <termref def="dt-grounded"/> and <termref def="dt-motionless"
                                    />.</p>
                              </item>
                           </olist>
                        </item>
                        <item>
                           <p>Now consider the operand
                              <code>{sum(current-group()/@value)}</code>.</p>
                        </item>
                        <item>
                           <p>Section <specref ref="classifying-vts"/> applies. This refers to the
                                 <termref def="dt-general-streamability-rules"/>; there is a single
                              operand, the expression <code>sum(current-group()/@value)</code>, with
                              usage <termref def="dt-absorption"/>.</p>
                        </item>
                        <item>
                           <p>The rules for the <code>sum</code> function appear in <specref
                                 ref="classifying-built-in-functions"/>. The proforma is given there
                              as <code>fn:sum(A)</code>, which means that the <termref
                                 def="dt-general-streamability-rules"/> apply, and that the single
                              operand <code>current-group()/@value</code> has usage <termref
                                 def="dt-absorption"/>. So we need to establish the <termref
                                 def="dt-posture"/>, <termref def="dt-sweep"/>, and type of this
                              expression, which we can do as follows:</p>
                           <olist>
                              <item>
                                 <p>The expression is a <code>RelativePathExpr</code>, so section
                                       <specref ref="streamability-of-path-expressions"/>
                                    applies.</p>
                              </item>
                              <item>
                                 <p>The expression is expanded to
                                       <code>current-group()/attribute::value</code>.</p>
                              </item>
                              <item>
                                 <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                                    the left-hand operand <code>current-group()</code> are defined
                                    in <specref ref="streamability-fn-current-group"/>. Since all
                                    the required conditions are satisfied, the <termref
                                       def="dt-posture"/> of <code>current-group()</code> is the
                                       <termref def="dt-posture"/> of the <code>select</code>
                                    expression, that is <termref def="dt-striding"/>, and its
                                       <termref def="dt-sweep"/> is the <termref def="dt-sweep"/> of
                                    the <code>select</code> expression, that is <termref
                                       def="dt-consuming"/>.</p>
                              </item>
                              <item>
                                 <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                                    the right hand operand <code>@value</code> are defined in
                                       <specref ref="streamability-of-axis-steps"/>. The <termref
                                       def="dt-context-posture"/> is the <termref def="dt-posture"/>
                                    of the left-hand operand <code>current-group()</code>, namely
                                       <termref def="dt-striding"/>; the table in Rule 5 applies,
                                    giving the result <termref def="dt-climbing"/> and <termref
                                       def="dt-motionless"/></p>
                              </item>
                              <item>
                                 <p>The <termref def="dt-posture"/> of the
                                       <code>RelativePathExpr</code> is the <termref
                                       def="dt-posture"/> of the right hand operand, namely <phrase
                                       diff="chg" at="S-bug27051"><termref def="dt-striding"
                                       /></phrase>. The <termref def="dt-sweep"/> of the
                                       <code>RelativePathExpr</code> is the wider of the <termref
                                       def="dt-sweep">sweeps</termref> of its operands, which is
                                       <termref def="dt-consuming"/></p>
                              </item>
                              <item>
                                 <p>The type of the expression <code>current-group()/@value</code>
                                    is determined using the rules in <specref
                                       ref="determining-static-type"/> as
                                    <code>attribute()</code>.</p>
                              </item>
                           </olist>
                        </item>
                        <item>
                           <p>So the <code>sum</code> function has a single operand with
                                 <var>U</var> = <termref def="dt-absorption"/>, <var>P</var> =
                                 <phrase diff="chg" at="S-bug27051"><termref def="dt-striding"
                                 /></phrase>, <var>S</var> = <termref def="dt-consuming"/>,
                                 <var>T</var> = <code>attribute()</code>.</p>
                        </item>
                        <item>
                           <p>In the <termref def="dt-general-streamability-rules"/>, Rule
                              1(b)(iii)(A) gives the adjusted usage as <var>U'</var> = <termref
                                 def="dt-inspection"/>, and Rule 1(b)(iii)(B) gives the adjusted
                              sweep as <var>S'</var> = <var>S</var> = <termref def="dt-consuming"/>.
                              Rule 2(d) gives the posture and sweep of the call to <code>sum</code>
                              as <termref def="dt-grounded"/> and <termref def="dt-consuming"/>.
                           </p>
                        </item>
                     </olist>
                  </item>
                  <item>
                     <p>So the literal result element has two operands, one of which is <termref
                           def="dt-grounded"/> and <termref def="dt-motionless"/>, the other
                           <termref def="dt-grounded"/> and <termref def="dt-consuming"/>. Rule 2(d)
                        of the <termref def="dt-general-streamability-rules"/> determines that the
                        literal result element is <termref def="dt-grounded"/> and <termref
                           def="dt-consuming"/>.</p>
                  </item>
                  <item>
                     <p>So the content of the <elcode>xsl:source-document</elcode> instruction is
                           <termref def="dt-grounded"/>, which means that the instruction is
                           <termref def="dt-guaranteed-streamable"/>.</p>
                  </item>
               </olist>
            </example>
         </div2>
         <div2 id="streamability-guarantees">
            <head>Streamability Guarantees</head>
            <p>Certain constructs allow a stylesheet author to declare that a construct is
               streamable. Specifically:</p>
            <ulist>
               <item>
                  <p>Specifying <code>streamable="yes"</code> on <elcode>xsl:mode</elcode> declares
                     that all template rules in that mode <phrase diff="add" at="Q">(and all
                        template rules that specify <code>mode="#all"</code>)</phrase> are
                     streamable;</p>
               </item>
               <item>
                  <p><phrase diff="add" at="T-bug29747">Specifying <code>streamable="yes"</code> on
                           <elcode>xsl:source-document</elcode> declares</phrase> that its contained
                     sequence constructor is streamable;</p>
               </item>
               <item diff="add" at="R-bug25679">
                  <p>Specifying <code>streamable="yes"</code> on <elcode>xsl:function</elcode>
                     declares that the <termref def="dt-stylesheet-function"/> in question is
                     streamable;</p>
               </item>
               <item>
                  <p>Specifying <code>streamable="yes"</code> on <elcode>xsl:attribute-set</elcode>
                     declares that the attribute set in question is streamable;</p>
               </item>
               <item>
                  <p diff="chg" at="T-bug29698">Specifying <code>streamable="yes"</code> (explicitly
                     or implicitly) on <elcode>xsl:merge-source</elcode> declares that the merging
                     process is streamable with respect to that particular input.</p>
               </item>
               <item>
                  <p>Specifying <code>streamable="yes"</code> on <elcode>xsl:accumulator</elcode>
                     declares that the accumulator can be evaluated on a streamed document.</p>
               </item>
               <item diff="del" at="T-bug29696">
                  <p>Specifying <code>streamable="yes"</code> on
                        <elcode>xsl:global-context-item</elcode> declares that the global context
                     item may be a node in a streamed document.</p>
               </item>
            </ulist>
            <p diff="add" at="R-bug24510"><termdef id="dt-declared-streamable"
                  term="declared-streamable">The above constructs (template rules belonging to a
                  mode declared with <code>streamable="yes"</code>; and
                     <elcode>xsl:source-document</elcode>, <elcode>xsl:attribute-set</elcode>,
                     <elcode>xsl:function</elcode>, <phrase diff="chg" at="T-bug29698"
                        ><elcode>xsl:merge-source</elcode></phrase>, and
                     <elcode>xsl:accumulator</elcode>
                  <phrase diff="del" at="R-bug24543">and
                     <elcode>xsl:global-context-item</elcode></phrase> elements specifying
                     <code>streamable="yes"</code>) are said to be
                  <term>declared-streamable</term>.</termdef></p>
            <p>In each case the construct in question is said to be
                  <term>guaranteed-streamable</term> if it satisfies two conditions:</p>
            <olist>
               <item>
                  <p>The construct is <termref def="dt-declared-streamable"/>.</p>
               </item>
               <item>
                  <p>Streamability analysis following the rules defined in this specification
                     determines that streamed processing is possible (the detailed conditions vary
                     from one construct to another).</p>
               </item>
            </olist>
            <p><termdef id="dt-guaranteed-streamable" term="guaranteed-streamable">A
                     <term>guaranteed-streamable</term> construct is a <termref def="dt-construct"
                     >construct</termref> that is declared to be streamable and that follows the
                  particular rules for that construct to make streaming possible, as defined by the
                  analysis in this specification.</termdef></p>
            <p>For a streaming processor, that is, a processor that claims conformance with the
                  <termref def="dt-streaming-feature"/>:</p>
            <olist>
               <item>
                  <p>If a construct is <termref def="dt-guaranteed-streamable"/>
                     <phrase diff="add" at="T-bug29690">and the input is provided in streamable
                        form,</phrase> then the input <rfc2119 at="F" diff="chg">must</rfc2119> be
                     processed using streaming.</p>
                  <note diff="add" at="T-bug29690">
                     <p>The requirement to process the input using streaming does not apply if the
                        processor is able to determine that this would convey no benefit: for
                        example, if the input is supplied as a tree in memory. However, this does
                        not remove the requirement to verify that the relevant stylesheet constructs
                        are <termref def="dt-guaranteed-streamable"/>.</p>
                  </note>
               </item>
               <item>
                  <p>If a construct is declared as streamable but is not <termref
                        def="dt-guaranteed-streamable"/> (that is, if it fails to satisfy the
                     conditions for streamability defined in this specification), then the processor
                        <rfc2119>must</rfc2119> be prepared to do any one of the following at user
                     option:</p>
                  <olist>
                     <item>
                        <p>Signal a static error <errorref spec="XT" class="SE" code="3430"/></p>
                     </item>
                     <item>
                        <p>Process the stylesheet as if it were a non-streaming processor (see
                           below)</p>
                     </item>
                     <item>
                        <p>Process the stylesheet with streaming if it is able to do so, or signal a
                           static error <errorref spec="XT" class="SE" code="3430"/> if it is not
                           able to do so.</p>
                     </item>
                  </olist>
               </item>
            </olist>
            <p diff="add" at="Q"><error spec="XT" type="static" class="SE" code="3430"><p>It is a
                        <termref def="dt-static-error"/> if a <termref def="dt-package" diff="chg"
                        at="R-bug24763">package</termref> contains a construct that is declared to
                     be streamable but which is not <termref def="dt-guaranteed-streamable"/>,
                     unless the user has indicated that the processor is to handle this situation by
                     processing the stylesheet without streaming or by making use of processor
                     extensions to the streamability rules where available.</p></error></p>
            <p>For a non-streaming processor, the processor <rfc2119 at="F" diff="chg"
                  >must</rfc2119> evaluate the <phrase diff="chg" at="F">construct</phrase>
               delivering the same results as if execution used streaming, but with no constraints
               on the evaluation strategy. (Processing <rfc2119 at="F" diff="chg">may</rfc2119>, of
               course, fail due to insufficient memory being available, or for other reasons.)
                  <phrase diff="add" at="S-bug27660">A non-streaming processor is <rfc2119>not
                     required</rfc2119> to assess whether constructs are <termref
                     def="dt-guaranteed-streamable"/>, or to apply restrictions such as the rules
                  for where calls on the functions <function>accumulator-before</function> and
                     <function>accumulator-after</function> may appear. However, a non-streaming
                  processor <rfc2119>must</rfc2119> enforce the constraint implied by a
                     <code>use-accumulators</code> attribute restricting which accumulators can be
                  used with a particular document.</phrase></p>
            <note>
               <p>This specification does not attempt to legislate precisely what constitutes
                  evaluation “using streaming”. The most important test is that the amount of memory
                  needed should be for practical purposes independent of the size of the source
                  document, and in particular that the finite size of memory available should not
                  impose a limit on the size of source document that can be processed.</p>
               <p>The rules are designed to ensure that streaming processors can analyze
                  streamability using rules different from those in this specification, provided
                  that all constructs that are <termref def="dt-guaranteed-streamable"/> according
                  to this specification are actually streamable by the implementation. Furthermore,
                  non-streaming processors are not required to analyze streamability at all.</p>
               <p diff="del" at="Q">The rules in this version of the specification are deliberately
                  restrictive in order to keep the rules simple. In particular, the rules have been
                  chosen so that they can be assessed by simple syntactic examination of the source
                  code, without recourse to static type analysis or dataflow analysis.
                  Implementations may well be able to relax the rules, and are permitted to do
                  so.</p>
            </note>
         </div2>
         <div2 id="pattern-scanning" diff="del" at="R-bug25160">
            <head>An Optimization: Pattern-Based Scanning</head>
            <p>The rules given elsewhere in this chapter for determining streamability produce the
               result that the expression <code>count(//section/head)</code> is not streamable. The
               reason for this is that a naive nested loop evaluation of the path expression
                  <code>//section/head</code> will not always deliver nodes in document order; this
               can be seen by examining the source document below, where a child of the first
                  <code>section</code> appears in document order <emph>after</emph> a child of the
               second <code>section</code>:</p>
            <eg role="xml" xml:space="preserve">
&lt;section&gt;
  &lt;section&gt;
     &lt;head/&gt;
  &lt;/section&gt;
  &lt;head/&gt;
&lt;/section&gt;  </eg>
            <p>An implementation that literally followed the semantics of path expressions as
               defined in <bibref ref="xpath-30"/> would therefore require to sort the nodes into
               document order, and sorting is incompatible with streaming.</p>
            <p>There is however a viable strategy for processing this expression in a streaming
               manner, for example to rewrite the expression as
                  <code>count(/descendant::head[parent::section])</code>.</p>
            <p>In order to make such expressions streamable, implementations must therefore detect
               this situation in the construct tree and perform an appropriate rewrite before
               continuing with the analysis. Specifically, any <code>PathExpr</code>
               <var>E</var> that is the equivalent expression of some <termref def="dt-motionless"/>
               pattern <var>P</var> is replaced by a call on a streamable function that selects the
               same nodes as would have been selected by <var>E</var> in the absence of streaming
               restrictions. This function call has a sweep of <phrase diff="chg" at="Q"><termref
                     def="dt-consuming"/></phrase> and a posture of <termref def="dt-crawling"/>;
               its static type is that of the original expression <var>E</var>. This makes it
               eligible to be used, for example, as the argument of the <xfunction>count</xfunction>
               function.</p>
            <note>
               <p>The function used in this rewrite needs to do more than simply test all descendant
                  nodes to see if they match the pattern; for example if the expression is
                     <code>p//q</code> then it must also check that the relevant <code>p</code>
                  element is indeed a child of the original context item.</p>
               <p>This rewrite will not always succeed in making the construct streamable. For
                  example <code>&lt;xsl:value-of select="//head"/&gt;</code> will still fail the
                  streamability tests, because of the possibility that one <code>head</code> element
                  is a child of another. This problem can be remedied by writing
                     <code>&lt;xsl:value-of select="//head/text()"/&gt;</code>.</p>
               <p>It should also be noted that not all downward path expressions are equivalent to
                  motionless patterns; an example is <code>a[2]</code>. Positional predicates are
                  allowed in streamable path expressions, but not in motionless patterns.</p>
               <p>In practice, of course, processors may use a different algorithm if it achieves
                  the same effect.</p>
            </note>
         </div2>
      </div1>
      <div1 id="add-func">
         <head>Additional Functions</head>
         <p>This section describes XSLT-specific additions to the XPath function library. Some of
            these additional functions also make use of information specified by <termref
               def="dt-declaration">declarations</termref> in the stylesheet; this section also
            describes these declarations.</p>
         <div2 id="func-document">
            <head>fn:document</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>Provides access to XML documents identified by a URI.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signatures</label>
                  <def>
                     <example role="signature">
                        <proto name="document" return-type="node()*" isOp="no" prefix="fn"
                           returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no"
                           isDatatype="no" isSpecial="no">
                           <arg name="uri-sequence" type="item()*"/>
                        </proto>
                     </example>
                     <example role="signature">
                        <proto name="document" return-type="node()*" isOp="no" prefix="fn"
                           returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no"
                           isDatatype="no" isSpecial="no">
                           <arg name="uri-sequence" type="item()*"/>
                           <arg name="base-node" type="node()"/>
                        </proto>
                     </example>
                  </def>
               </gitem>
               <gitem>
                  <label>Properties</label>
                  <def>
                     <p>The one-argument form of this function is <xtermref spec="FO30"
                           ref="dt-deterministic">deterministic</xtermref>, <xtermref spec="FO30"
                           ref="dt-focus-independent">focus-independent</xtermref>, and <xtermref
                           spec="FO30" ref="dt-context-dependent">context-dependent</xtermref>. It
                        depends on static base URI. </p>
                     <p>The two-argument form of this function is <xtermref spec="FO30"
                           ref="dt-deterministic">deterministic</xtermref>, <xtermref spec="FO30"
                           ref="dt-focus-independent">focus-independent</xtermref>, and <xtermref
                           spec="FO30" ref="dt-context-independent">context-independent</xtermref>.
                     </p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>The <function>document</function> function allows access to XML documents
                        identified by a URI.</p>
                     <p>The first argument contains a sequence of URI references. The second
                        argument, if present, is a node whose base URI is used to resolve any
                        relative URI references contained in the first argument.</p>
                     <p>A sequence of absolute URI references is obtained as follows.</p>
                     <ulist>
                        <item>
                           <p>For an item in <code>$uri-sequence</code> that is an instance of
                                 <code>xs:string</code>, <code>xs:anyURI</code>, or
                                 <code>xs:untypedAtomic</code>, the value is cast to
                                 <code>xs:anyURI</code>. If the resulting URI reference is an
                              absolute URI reference then it is used <emph>as is</emph>. If it is a
                              relative URI reference, then it is resolved as follows:</p>
                           <olist diff="chg" at="T-bug29461">
                              <item>
                                 <p>If <code>$base-node</code> is supplied, then it is resolved
                                    against the base URI of <code>$base-node</code>.</p>
                              </item>
                              <item>
                                 <p>Otherwise it is resolved against the static base URI from the
                                    static context of the expression containing the call to the
                                       <function>document</function> function. In cases where the
                                    source code of the stylesheet is available at execution time,
                                    this will typically be the location of the relevant stylesheet
                                    module.</p>
                              </item>
                           </olist>
                        </item>
                        <item>
                           <p>For an item in <code>$uri-sequence</code> that is a node, the node is
                                 <termref def="dt-atomization">atomized</termref>. The result
                                 <rfc2119>must</rfc2119> be a sequence whose items are all instances
                              of <code>xs:string</code>, <code>xs:anyURI</code>, or
                                 <code>xs:untypedAtomic</code>. Each of these values is cast to
                                 <code>xs:anyURI</code>, and if the resulting URI reference is an
                              absolute URI reference then it is used <emph>as is</emph>. If it is a
                              relative URI reference, then it is resolved against the base URI of
                                 <code>$base-node</code> if supplied, or against the base URI of the
                              node that contained it otherwise.</p>
                        </item>
                        <item>
                           <p diff="chg" at="T-bug29461">A relative URI is resolved against a base
                              URI using the rules of the <xfunction>resolve-uri</xfunction>
                              function. A dynamic error occurs (see below) if no base URI is
                              available.</p>
                        </item>
                        <item diff="add" at="R-bug7353">
                           <p> If <code>$uri-sequence</code> (after atomizing any nodes) contains an
                                 <phrase diff="chg" at="S-bug28153">item other than an atomic value
                                 of type</phrase>
                              <code>xs:string</code>, <code>xs:anyURI</code>, or
                                 <code>xs:untypedAtomic</code> then a type error is raised
                                 <xerrorref spec="XP30" class="TY" code="0004"/>. </p>
                        </item>
                     </ulist>
                     <p>Each of these absolute URI references is then processed as follows. Any
                        fragment identifier that is present in the URI reference is removed, and the
                        resulting absolute URI is cast to a string and then passed to the
                           <xfunction>doc</xfunction> function defined in <bibref
                           ref="xpath-functions-30"/>. This returns a document node. If an error
                        occurs during evaluation of the <xfunction>doc</xfunction> function, the
                        processor <rfc2119>may</rfc2119> either signal this error in the normal way,
                        or <rfc2119>may</rfc2119> recover by ignoring the failure, in which case the
                        failing URI will not contribute any nodes to the result of the
                           <function>document</function> function.</p>
                     <p>If the URI reference contained no fragment identifier, then this document
                        node is included in the sequence of nodes returned by the
                           <function>document</function> function.</p>
                     <p>If the URI reference contained a fragment identifier, then the fragment
                        identifier is interpreted according to the rules for the media type of the
                        resource representation identified by the URI, and is used to select zero or
                        more nodes that are descendant-or-self nodes of the returned document node.
                        As described in <specref ref="initiating"/>, the media type is available as
                        part of the evaluation context for a transformation.</p>
                     <p>The sequence of nodes returned by the function is in document order, with no
                        duplicates. This order has no necessary relationship to the order in which
                        URIs were supplied in the <code>$uri-sequence</code> argument.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Error Conditions</label>
                  <def>
                     <p>
                        <error spec="XT" type="dynamic" class="DE" code="1160"><p>When a URI
                              reference <error.extra>supplied to the <function>document</function>
                                 function</error.extra> contains a fragment identifier, it is a
                                 <termref def="dt-dynamic-error"/> if the media type is not one that
                              is recognized by the processor, or if the fragment identifier does not
                              conform to the rules for fragment identifiers for that media type, or
                              if the fragment identifier selects something other than a sequence of
                              nodes (for example, if it selects a range of characters within a text
                              node). </p></error>
                     </p>
                     <p diff="add" at="Q">A processor <rfc2119>may</rfc2119> provide an option
                        which, if selected, causes the processor instead of signaling this error, to
                        ignore the fragment identifier and return the document node.</p>
                     <p>The set of media types recognized by a processor is <termref
                           def="dt-implementation-defined">implementation-defined</termref>.</p>
                     <imp-def-feature>The set of media types recognized by the processor, for the
                        purpose of interpreting fragment identifiers in URI references passed to the
                           <function>document</function> function, is
                        implementation-defined.</imp-def-feature>
                     <p diff="add" at="G">
                        <error spec="XT" type="dynamic" class="DE" code="1162"><p>When a URI
                              reference <error.extra>supplied to the <function>document</function>
                                 function</error.extra> is a relative reference, it is a <termref
                                 def="dt-dynamic-error">dynamic error</termref> if no base URI is
                              available to resolve the relative reference. This can arise for
                              example when the URI is contained in a node that has no base URI (for
                              example a parentless text node), or when the second argument to the
                              function is a node that has no base URI, or when the base URI from the
                              static context is undefined. </p></error>
                     </p>
                  </def>
               </gitem>
               <gitem>
                  <label>Notes</label>
                  <def>
                     <p role="note">One effect of these rules is that <phrase diff="add"
                           at="T-bug29461">in an interpreted environment where the source code of
                           the stylesheet is available and its base URI is known</phrase>, then
                        unless XML entities or <code>xml:base</code> are used, the expression
                           <code>document("")</code> refers to the document node of the containing
                        stylesheet module (the definitive rules are in <bibref ref="RFC3986"/>). The
                        XML resource containing the stylesheet module is then processed exactly as
                        if it were any other XML document, for example there is no special
                        recognition of <elcode>xsl:text</elcode> elements, and no special treatment
                        of comments and processing instructions.</p>
                     <p role="note">The XPath rules for function calling ensure that it is a type
                        error if the supplied value of the second argument is anything other than a
                        single node. If <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility
                           mode</termref> is enabled, then a sequence of nodes may be supplied, and
                        the first node in the sequence will be used.</p>
                  </def>
               </gitem>
            </glist>
         </div2>
         <div2 id="key">
            <head>Keys</head>
            <p>Keys provide a way to work with documents that contain an implicit cross-reference
               structure. They make it easier to locate the nodes within a document that have a
               given value for a given attribute or child element, and they provide a hint to the
               implementation that certain access paths in the document need to be efficient.</p>
            <div3 id="xsl-key">
               <head>The <elcode>xsl:key</elcode> Declaration</head>
               <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
                  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="key">
                  <e:in-category name="declaration"/>
                  <e:attribute name="name" required="yes">
                     <e:data-type name="eqname"/>
                  </e:attribute>
                  <e:attribute name="match" required="yes">
                     <e:data-type name="pattern"/>
                  </e:attribute>
                  <e:attribute name="use">
                     <e:data-type name="expression"/>
                  </e:attribute>
                  <e:attribute name="composite">
                     <e:data-type name="boolean"/>
                  </e:attribute>
                  <e:attribute name="collation" required="no">
                     <e:data-type name="uri"/>
                  </e:attribute>
                  <e:model name="sequence-constructor"/>
                  <e:allowed-parents>
                     <e:parent name="package"/>
                     <e:parent name="stylesheet"/>
                     <e:parent name="transform"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p>The <elcode>xsl:key</elcode>
                  <termref def="dt-declaration">declaration</termref> is used to declare <termref
                     def="dt-key">keys</termref>. The <code>name</code> attribute specifies the name
                  of the key. The value of the <code>name</code> attribute is an <phrase diff="chg"
                     at="K"><termref def="dt-eqname">EQName</termref></phrase>, which is expanded as
                  described in <specref ref="qname"/>. The <code>match</code> attribute is a <nt
                     xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xslt30-patterns-Pattern30"
                     xlink:type="simple">Pattern</nt>; an <elcode>xsl:key</elcode> element applies
                  to all nodes that match the pattern specified in the <code>match</code>
                  attribute.</p>
               <p>
                  <termdef id="dt-key" term="key">A <term>key</term> is defined as a set of
                        <elcode>xsl:key</elcode> declarations in the <phrase diff="chg" at="I">same
                           <termref def="dt-package">package</termref></phrase> that share the same
                     name.</termdef>
               </p>
               <p diff="add" at="I">The key name is scoped to the containing <termref
                     def="dt-package">package</termref>, and is available for use in calls to the
                     <function>key</function> function within that package.</p>
               <p>The value of the key may be specified either using the <code>use</code> attribute
                  or by means of the contained <termref def="dt-sequence-constructor">sequence
                     constructor</termref>.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="1205"><p>It is a <termref
                           def="dt-static-error">static error</termref> if an
                           <elcode>xsl:key</elcode> declaration has a <code>use</code> attribute and
                        has non-empty content, or if it has empty content and no <code>use</code>
                        attribute.</p></error>
               </p>
               <p>If the <code>use</code> attribute is present, its value is an <termref
                     def="dt-expression">expression</termref> specifying the values of the key. The
                  expression will be evaluated with <phrase diff="chg" at="D">a <termref
                        def="dt-singleton-focus">singleton focus</termref> based on the node that
                     matches the pattern</phrase>. The result of evaluating the expression is
                     <termref def="dt-atomization">atomized</termref>. </p>
               <p>Similarly, if a <termref def="dt-sequence-constructor">sequence
                     constructor</termref> is present, it is used to determine the values of the
                  key. The sequence constructor will be evaluated with the node that matches the
                  pattern as the context node. The result of evaluating the sequence constructor is
                     <termref def="dt-atomization">atomized</termref>.</p>
               <p>
                  <termdef id="dt-key-specifier" term="key specifier">The expression in the
                        <code>use</code> attribute and the <termref def="dt-sequence-constructor"
                        >sequence constructor</termref> within an <elcode>xsl:key</elcode>
                     declaration are referred to collectively as the <term>key specifier</term>. The
                     key specifier determines the values that may be used to find a node using this
                        <termref def="dt-key">key</termref>.</termdef>
               </p>
               <p diff="add" at="G">When evaluation of the <termref def="dt-key-specifier">key
                     specifier</termref> results in a sequence (after atomization) containing more
                  than one atomic value, the effect depends on the value of the
                     <code>composite</code> attribute:</p>
               <ulist diff="add" at="G">
                  <item>
                     <p>When the attribute is absent or has the value <code>no</code>, each atomic
                        value in the sequence acts as an individual key. For example, if
                           <code>match="book" use="author" composite="no"</code> is specified, then
                        a <code>book</code> element may be located using the value of any
                           <code>author</code> element.</p>
                  </item>
                  <item>
                     <p>When the attribute is present and has the value <code>yes</code>, the
                        sequence of atomic values is treated as a composite key that must be matched
                        in its entirety. For example, if <code>match="book" use="author"
                           composite="yes"</code> is specified, then a <code>book</code> element may
                        be located using the value of all its <code>author</code> elements, supplied
                        in the correct order.</p>
                  </item>
               </ulist>
               <p diff="add" at="G">If there are several <elcode>xsl:key</elcode> declarations in
                  the <phrase diff="chg" at="I">same package</phrase> with the same key name, then
                  they must all have the same effective value for their <code>composite</code>
                  attribute. The effective value is the actual value of the attribute if present, or
                     <code>"no"</code> if the attribute is absent.</p>
               <note>
                  <p>There is no requirement that all the values of a key should have the same
                     type.</p>
               </note>
               <p>The presence of an <elcode>xsl:key</elcode> declaration makes it easy to find a
                  node that matches the <code>match</code> pattern if <phrase diff="del" at="G">any
                     of</phrase> the values of the <termref def="dt-key-specifier">key
                     specifier</termref> (when applied to that node) are known. It also provides a
                  hint to the implementation that access to the nodes by means of these values needs
                  to be efficient (many implementations are likely to construct an index or hash
                  table to achieve this). <phrase diff="del" at="G">Note that the <termref
                        def="dt-key-specifier">key specifier</termref> in general returns a sequence
                     of values, and any one of these may be used to locate the node.</phrase></p>
               <note>
                  <p>An <elcode>xsl:key</elcode> declaration is not bound to a specific source
                     document. The source document to which it applies is determined only when the
                        <function>key</function> function is used to locate nodes using the key.
                     Keys can be used to locate nodes within any source document (including
                     temporary trees), but each use of the <function>key</function> function
                     searches one document only.</p>
                  <p diff="add" at="T-bug29796">Keys can only be used to search within a tree that
                     is rooted at a document node.</p>
               </note>
               <p>The optional <code>collation</code> attribute is used only when deciding whether
                  two strings are equal for the purposes of key matching. Specifically, two key
                  values <code>$a</code> and <code>$b</code> are considered equal if the result of
                  the function call <phrase diff="chg" at="G"><code>deep-equal($a, $b,
                        $collation)</code> is true</phrase>. The effective collation for an
                     <elcode>xsl:key</elcode> declaration is the collation specified in its
                     <code>collation</code> attribute if present, resolved against the base URI of
                  the <elcode>xsl:key</elcode> element, or the <termref def="dt-default-collation"
                     >default collation</termref> that is in scope for the <elcode>xsl:key</elcode>
                  declaration otherwise; the effective collation must be the same for all the
                     <elcode>xsl:key</elcode> declarations making up a <termref def="dt-key"
                     >key</termref>.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="1210"><p>It is a <termref
                           def="dt-static-error">static error</termref> if the
                           <elcode>xsl:key</elcode> declaration has a <code>collation</code>
                        attribute whose value (after resolving against the base URI) is not a URI
                        recognized by the implementation as referring to a collation.</p></error>
               </p>
               <p>
                  <error spec="XT" type="static" class="SE" code="1220"><p>It is a <termref
                           def="dt-static-error">static error</termref> if there are several
                           <elcode>xsl:key</elcode> declarations in the <phrase diff="chg" at="I"
                           >same <termref def="dt-package">package</termref></phrase> with the same
                        key name and different effective collations. Two collations are the same if
                        their URIs are equal under the rules for comparing <code>xs:anyURI</code>
                        values, or if the implementation can determine that they are different URIs
                        referring to the same collation.</p></error>
               </p>
               <p diff="add" at="G">
                  <error spec="XT" type="static" class="SE" code="1222"><p>It is a <termref
                           def="dt-static-error">static error</termref> if there are several
                           <elcode>xsl:key</elcode> declarations in a <termref def="dt-package"
                           diff="chg" at="R-bug24763">package</termref> with the same key name and
                        different effective values for the <code>composite</code>
                     attribute.</p></error>
               </p>
               <p>It is possible to have:</p>
               <ulist>
                  <item>
                     <p>multiple <elcode>xsl:key</elcode> declarations with the same name;</p>
                  </item>
                  <item>
                     <p>a node that matches the <code>match</code> patterns of several different
                           <elcode>xsl:key</elcode> declarations, whether these have the same key
                        name or different key names;</p>
                  </item>
                  <item>
                     <p>a node that returns more than one value from its <termref
                           def="dt-key-specifier">key specifier</termref>
                        <phrase diff="add" at="G">(which can be treated either as separate
                           individual key values, or as a single composite key value)</phrase>;</p>
                  </item>
                  <item>
                     <p>a key value that identifies more than one node (the key values for different
                        nodes do not need to be unique).</p>
                  </item>
               </ulist>
               <p>An <elcode>xsl:key</elcode> declaration with higher <termref
                     def="dt-import-precedence">import precedence</termref> does not override
                  another of lower import precedence; all the <elcode>xsl:key</elcode> declarations
                  in the stylesheet are effective regardless of their import precedence.</p>
            </div3>
            <div3 id="func-key">
               <head>fn:key</head>
               <glist>
                  <gitem>
                     <label>Summary</label>
                     <def>
                        <p>Returns the nodes that match a supplied key value.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Signatures</label>
                     <def>
                        <example role="signature">
                           <proto name="key" return-type="node()*" isOp="no" prefix="fn"
                              returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no"
                              isDatatype="no" isSpecial="no">
                              <arg name="key-name" type="xs:string"/>
                              <arg name="key-value" type="xs:anyAtomicType*"/>
                           </proto>
                        </example>
                        <example role="signature">
                           <proto name="key" return-type="node()*" isOp="no" prefix="fn"
                              returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no"
                              isDatatype="no" isSpecial="no">
                              <arg name="key-name" type="xs:string"/>
                              <arg name="key-value" type="xs:anyAtomicType*"/>
                              <arg name="top" type="node()"/>
                           </proto>
                        </example>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Properties</label>
                     <def>
                        <p>The two-argument form of this function is <xtermref spec="FO30"
                              ref="dt-deterministic">deterministic</xtermref>, <xtermref spec="FO30"
                              ref="dt-focus-dependent">focus-dependent</xtermref>, and <xtermref
                              spec="FO30" ref="dt-context-dependent">context-dependent</xtermref>. </p>
                        <p>The three-argument form of this function is <xtermref spec="FO30"
                              ref="dt-deterministic">deterministic</xtermref>, <xtermref spec="FO30"
                              ref="dt-focus-independent">focus-independent</xtermref>, and <xtermref
                              spec="FO30" ref="dt-context-dependent">context-dependent</xtermref>.
                        </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Rules</label>
                     <def>
                        <p>The <function>key</function> function does for keys what the <phrase
                              diff="chg" at="D"><xfunction>element-with-id</xfunction></phrase>
                           function does for IDs.</p>
                        <p>The <code>$key-name</code> argument specifies the name of the <termref
                              def="dt-key">key</termref>. The value of the argument
                              <rfc2119>must</rfc2119> be a <phrase diff="chg" at="Q">string
                              containing an <termref def="dt-eqname"/>.</phrase> If it is a <termref
                              def="dt-lexical-qname">lexical QName</termref>, then it is expanded as
                           described in <specref ref="qname"/> (no prefix means no namespace).</p>
                        <p>The <code>$key-value</code> argument to the <function>key</function>
                           function is considered as a sequence. <phrase diff="add" at="G">The
                              effect depends on the value of the <code>composite</code> attribute of
                              the corresponding <code>xsl:key</code> declaration.</phrase></p>
                        <ulist>
                           <item>
                              <p><phrase diff="add" at="G">If <code>composite</code> is
                                       <code>no</code> or absent,</phrase> the set of requested key
                                 values is formed by atomizing the supplied value of the argument,
                                 using the standard <termref def="dt-function-conversion-rules"
                                    >function conversion rules</termref>. Each of the resulting
                                 atomic values is considered as a requested key value. The result of
                                 the function is a sequence of nodes, in document order and with
                                 duplicates removed, comprising those nodes in the selected subtree
                                 (see below) that are matched by an <elcode>xsl:key</elcode>
                                 declaration whose name is the same as the supplied key name, where
                                 the result of evaluating the <termref def="dt-key-specifier">key
                                    specifier</termref> contains a value that is equal to one of
                                 these requested key values, under the rules appropriate to the
                                 XPath <code>eq</code> operator for the two values in question,
                                 using the <code>collation</code> attributes of the
                                    <elcode>xsl:key</elcode> declaration when comparing strings. No
                                 error is reported if two values are encountered that are not
                                 comparable; they are regarded for the purposes of this function as
                                 being not equal. </p>
                              <p>If the second argument is an empty sequence, the result of the
                                 function will be an empty sequence.</p>
                           </item>
                           <item>
                              <p diff="add" at="G">If <code>composite</code> is <code>yes</code>,
                                 the requested key value is the sequence formed by atomizing the
                                 supplied value of the argument, using the standard <termref
                                    def="dt-function-conversion-rules">function conversion
                                    rules</termref>. The result of the function is a sequence of
                                 nodes, in document order and with duplicates removed, comprising
                                 those nodes in the selected subtree (see below) that are matched by
                                 an <elcode>xsl:key</elcode> declaration whose name is the same as
                                 the supplied key name, where the result of evaluating the <termref
                                    def="dt-key-specifier">key specifier</termref> is deep-equal to
                                 the requested key value, under the rules appropriate to the
                                    <xfunction>deep-equal</xfunction> function applied to the two
                                 values in question, using the <code>collation</code> attributes of
                                 the <elcode>xsl:key</elcode> declaration when comparing strings.
                                 Note that the <xfunction>deep-equal</xfunction> function reports no
                                 error if two values are encountered that are not comparable; they
                                 are regarded for the purposes of this function as being not
                                 equal.</p>
                              <p diff="add" at="G">If the second argument is an empty sequence, the
                                 result of the function will be the set of nodes having an empty
                                 sequence as the value of the key specifier.</p>
                           </item>
                        </ulist>
                        <p>Different rules apply when <phrase diff="chg" at="D"><termref
                                 def="dt-xslt-10-behavior">XSLT 1.0 compatible behavior</termref> is
                              enabled.</phrase></p>
                        <p diff="chg" at="P-erratumE33">A key (that is, a set of
                              <elcode>xsl:key</elcode> declarations sharing the same key name) is
                           processed in backwards compatible mode if (a) at least one of the xsl:key
                           elements in the definition of the key enables backwards compatible
                           behavior, and (b) the effective value of the <code>composite</code>
                           attribute is <code>no</code>.</p>
                        <p diff="chg" at="P-erratumE33">When a key is processed in backwards
                           compatible mode, then:</p>
                        <ulist diff="chg" at="P-erratumE33">
                           <item>
                              <p>The result of evaluating the key specifier in any
                                    <elcode>xsl:key</elcode> declaration having this key name is
                                 converted after atomization to a sequence of strings, by applying a
                                 cast to each item in the sequence.</p>
                           </item>
                           <item>
                              <p>When the first argument to the <function>key</function> function
                                 specifies this key name, then the value of the second argument is
                                 converted after atomization to a sequence of strings, by applying a
                                 cast to each item in the sequence. The values are then compared as
                                 strings.</p>
                           </item>
                        </ulist>
                        <p>The third argument is used to identify the selected subtree. If the
                           argument is present, the selected subtree is the set of nodes that have
                              <var>$top</var> as an ancestor-or-self node. If the argument is
                           omitted, the selected subtree is the document containing the context
                           node. This means that the third argument effectively defaults to
                              <code>/</code>.</p>
                        <p>The result of the <function>key</function> function can be described more
                           specifically as follows. The result is a sequence containing every node
                              <var>$N</var> that satisfies the following conditions:</p>
                        <ulist>
                           <item>
                              <p>
                                 <code>$N/ancestor-or-self::node() intersect $top</code> is
                                 non-empty. (If the third argument is omitted, <code>$top</code>
                                 defaults to <code>/</code>)</p>
                           </item>
                           <item>
                              <p>
                                 <var>$N</var> matches the pattern specified in the
                                    <code>match</code> attribute of an <elcode>xsl:key</elcode>
                                 declaration whose <code>name</code> attribute matches the name
                                 specified in the <code>$key-name</code> argument.</p>
                           </item>
                           <item>
                              <p><phrase diff="add" at="G">When <code>composite="no"</code>,
                                 </phrase> and the <termref def="dt-key-specifier">key
                                    specifier</termref> of that <elcode>xsl:key</elcode> declaration
                                 is evaluated with a <termref def="dt-singleton-focus">singleton
                                    focus</termref> based on <var>$N</var>, the <termref
                                    def="dt-atomization">atomized</termref> value of the resulting
                                 sequence includes a value that compares equal to at least one item
                                 in the atomized value of the sequence supplied as
                                    <code>$key-value</code>, under the rules of the <code>eq</code>
                                 operator with the collation selected as described above.</p>
                              <p><phrase diff="add" at="G">When <code>composite="yes"</code>,
                                 </phrase> and the <termref def="dt-key-specifier">key
                                    specifier</termref> of that <elcode>xsl:key</elcode> declaration
                                 is evaluated with a <termref def="dt-singleton-focus">singleton
                                    focus</termref> based on <var>$N</var>, the <termref
                                    def="dt-atomization">atomized</termref> value of the resulting
                                 sequence compares equal to the atomized value of the sequence
                                 supplied as <code>$key-value</code>, under the rules of the
                                    <xfunction>deep-equal</xfunction> function with the collation
                                 selected as described above.</p>
                           </item>
                        </ulist>
                        <p>The sequence returned by the <function>key</function> function will be in
                           document order, with duplicates (that is, nodes having the same identity)
                           removed. </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Error Conditions</label>
                     <def>
                        <p>
                           <error spec="XT" type="dynamic" class="DE" code="1260"><p>It is a
                                    <termref def="dt-dynamic-error"><phrase diff="del" at="N"
                                       >non-recoverable</phrase> dynamic error</termref> if the
                                 value <error.extra>of the first argument to the
                                       <function>key</function> function</error.extra> is not a
                                 valid QName, or if there is no namespace declaration in scope for
                                 the prefix of the QName, or if the name obtained by expanding the
                                 QName is not the same as the expanded name of any
                                    <elcode>xsl:key</elcode> declaration in the <phrase diff="chg"
                                    at="I">containing <termref def="dt-package"
                                    >package</termref></phrase>. If the processor is able to detect
                                 the error statically (for example, when the argument is supplied as
                                 a string literal), then the processor <rfc2119>may</rfc2119>
                                 optionally signal this as a <termref def="dt-static-error">static
                                    error</termref>.</p></error>
                        </p>
                        <p>
                           <error spec="XT" type="dynamic" class="DE" code="1270"><p>It is a <phrase
                                    diff="chg" at="P"><termref def="dt-dynamic-error">dynamic
                                       error</termref></phrase> to call the <function>key</function>
                                 function with two arguments if there is no <termref
                                    def="dt-context-node">context node</termref>, or if the root of
                                 the tree containing the context node is not a document node; or to
                                 call the function with three arguments if the root of the tree
                                 containing the node supplied in the third argument is not a
                                 document node.</p></error>
                        </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Notes</label>
                     <def>
                        <p role="note">Untyped atomic values are converted to strings, not to the
                           type of the other operand. This means, for example, that if the
                           expression in the <code>use</code> attribute returns a date, supplying an
                           untyped atomic value in the call to the <function>key</function> function
                           will return an empty sequence.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Examples</label>
                     <def role="example">
                        <example>
                           <head>Using a Key to Follow Cross-References</head>
                           <p>Given a declaration</p>
                           <eg xml:space="preserve">&lt;xsl:key name="idkey" match="div" use="@id"/&gt;</eg>
                           <p>an expression <code>key("idkey",@ref)</code> will return the same
                              nodes as <code>id(@ref)</code>, assuming that the only ID attribute
                              declared in the XML source document is:</p>
                           <eg xml:space="preserve">&lt;!ATTLIST div id ID #IMPLIED&gt;</eg>
                           <p>and that the <code>ref</code> attribute of the context node contains
                              no whitespace.</p>
                        </example>
                        <example>
                           <head>Using a Key to Generate Hyperlinks</head>
                           <p>Suppose a document describing a function library uses a
                                 <code>prototype</code> element to define functions</p>
                           <eg xml:space="preserve">&lt;prototype name="sqrt" return-type="xs:double"&gt;
  &lt;arg type="xs:double"/&gt;
&lt;/prototype&gt;</eg>
                           <p>and a <code>function</code> element to refer to function names</p>
                           <eg xml:space="preserve">&lt;function&gt;sqrt&lt;/function&gt;</eg>
                           <p>Then the stylesheet could generate hyperlinks between the references
                              and definitions as follows:</p>
                           <eg xml:space="preserve">&lt;xsl:key name="func" match="prototype" use="@name"/&gt;

&lt;xsl:template match="function"&gt;
&lt;b&gt;
  &lt;a href="#{generate-id(key('func',.))}"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/a&gt;
&lt;/b&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="prototype"&gt;
  &lt;p&gt;
    &lt;a name="{generate-id()}"&gt;
      &lt;b&gt;Function: &lt;/b&gt;
      ...
    &lt;/a&gt;
  &lt;/p&gt;
  &lt;/xsl:template&gt;</eg>
                        </example>
                        <p>When called with two arguments, the <function>key</function> function
                           always returns nodes that are in the same document as the context node.
                           To retrieve a node from any other document, it is necessary either to
                           change the context node, or to supply a third argument.</p>
                        <example>
                           <head>Using Keys to Reference other Documents</head>
                           <p>For example, suppose a document contains bibliographic references in
                              the form <code>&lt;bibref&gt;XSLT&lt;/bibref&gt;</code>, and there is
                              a separate XML document <code>bib.xml</code> containing a
                              bibliographic database with entries in the form:</p>
                           <eg xml:space="preserve">&lt;entry name="XSLT"&gt;...&lt;/entry&gt;</eg>
                           <p>Then the stylesheet could use the following to transform the
                                 <code>bibref</code> elements:</p>
                           <eg xml:space="preserve">&lt;xsl:key name="bib" match="entry" use="@name"/&gt;

&lt;xsl:template match="bibref"&gt;
  &lt;xsl:variable name="name" select="."/&gt;
  &lt;xsl:apply-templates select="document('bib.xml')/key('bib',$name)"/&gt;
&lt;/xsl:template&gt;</eg>
                           <note>
                              <p>This relies on the ability in XPath 2.0 to have a function call on
                                 the right-hand side of the <code>/</code> operator in a path
                                 expression.</p>
                           </note>
                           <p>The following code would also work:</p>
                           <eg xml:space="preserve">&lt;xsl:key name="bib" match="entry" use="@name"/&gt;

&lt;xsl:template match="bibref"&gt;
  &lt;xsl:apply-templates select="key('bib', ., document('bib.xml'))"/&gt;
&lt;/xsl:template&gt;</eg>
                        </example>
                        <example>
                           <head>Using a Composite Key</head>
                           <p>This example uses a composite key consisting of first name and last
                              name to locate employees in an employee file.</p>
                           <p>The key can be defined like this:</p>
                           <eg xml:space="preserve">
&lt;xsl:key name="emp-name-key" 
         match="employee" 
         use="name/first, name/last" 
         composite="yes"/&gt;                     
         </eg>
                           <p>A particular employee can then be located using the function call:</p>
                           <eg xml:space="preserve">key('emp-name-key', ('Tim', 'Berners-Lee'), doc('employees.xml'))</eg>
                        </example>
                     </def>
                  </gitem>
               </glist>
            </div3>
         </div2>
         <div2 id="keys-and-streaming" diff="add" at="T-bug29499">
            <head>Keys and Streaming</head>
            <p>Keys are not applicable to streamed documents.</p>
            <p>This is ensured by the rules for the streamability of the <function>key</function>
               function (see <specref ref="classifying-built-in-functions"/>). These rules make the
                  <termref def="dt-operand-usage"/> of the third argument <termref
                  def="dt-navigation"/>, which has the consequence that when the
                  <function>key</function> function is applied to a streamed input document, the
               call is <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>, which
               effectively makes the containing construct non-streamable.</p>
         </div2>
         <div2 id="misc-func">
            <head>Miscellaneous Additional Functions</head>
            <div3 id="func-current">
               <head>fn:current</head>
               <glist>
                  <gitem>
                     <label>Summary</label>
                     <def>
                        <p>Returns the item that is the context item for the evaluation of the
                           containing XPath expression</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Signature</label>
                     <def>
                        <example role="signature">
                           <proto name="current" return-type="item()" isOp="no" prefix="fn"
                              returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no"
                              isDatatype="no" isSpecial="no"/>
                        </example>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Properties</label>
                     <def>
                        <p>This function is <xtermref spec="FO30" ref="dt-deterministic"
                              >deterministic</xtermref>, <xtermref spec="FO30"
                              ref="dt-context-dependent">context-dependent</xtermref>, and <xtermref
                              spec="FO30" ref="dt-focus-dependent">focus-dependent</xtermref>. </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Rules</label>
                     <def>
                        <p>The <function>current</function> function, used within an XPath <termref
                              def="dt-expression">expression</termref>, returns the item that was
                           the <termref def="dt-context-item">context item</termref> at the point
                           where the expression was invoked from the XSLT <termref
                              def="dt-stylesheet">stylesheet</termref>. This is referred to as the
                           current item. For an outermost expression (an expression not occurring
                           within another expression), the current item is always the same as the
                           context item. Thus,</p>
                        <eg xml:space="preserve">&lt;xsl:value-of select="current()"/&gt;</eg>
                        <p>means the same as</p>
                        <eg xml:space="preserve">&lt;xsl:value-of select="."/&gt;</eg>
                        <p>However, within square brackets, or on the right-hand side of the
                              <code>/</code> operator, the current item is generally different from
                           the context item.</p>
                        <p>If the <function>current</function> function is used within a <termref
                              def="dt-pattern">pattern</termref>, its value is the <phrase
                              diff="chg" at="C">item</phrase> that is being matched against the
                           pattern.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Error Conditions</label>
                     <def>
                        <p>
                           <error spec="XT" type="dynamic" class="DE" code="1360"><p>If the
                                    <function>current</function> function is evaluated within an
                                 expression that is evaluated when the context item is absent, a
                                    <termref def="dt-dynamic-error"><phrase diff="del" at="N"
                                       >non-recoverable</phrase> dynamic error</termref>
                              occurs.</p></error>
                        </p>
                        <p diff="add" at="Q-bug23631">When the <function>current</function> is
                           called by means of a dynamic function call (for example,
                              <code>current#0()</code>), it is evaluated as if the context item is
                           absent (<errorref spec="XT" type="dynamic" class="DE" code="1360"/>).</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Examples</label>
                     <def role="example">
                        <p>The instruction:</p>
                        <eg xml:space="preserve">&lt;xsl:apply-templates select="//glossary/entry[@name=current()/@ref]"/&gt;</eg>
                        <p>will process all <code>entry</code> elements that have a
                              <code>glossary</code> parent element and that have a <code>name</code>
                           attribute with value equal to the value of the current item's
                              <code>ref</code> attribute. This is different from</p>
                        <eg xml:space="preserve">&lt;xsl:apply-templates select="//glossary/entry[@name=./@ref]"/&gt;</eg>
                        <p>which means the same as</p>
                        <eg xml:space="preserve">&lt;xsl:apply-templates select="//glossary/entry[@name=@ref]"/&gt;</eg>
                        <p>and so would process all <code>entry</code> elements that have a
                              <code>glossary</code> parent element and that have a <code>name</code>
                           attribute and a <code>ref</code> attribute with the same value.</p>
                     </def>
                  </gitem>
               </glist>
            </div3>
            <div3 id="func-unparsed-entity-uri">
               <head>fn:unparsed-entity-uri</head>
               <glist>
                  <gitem>
                     <label>Summary</label>
                     <def>
                        <p>Returns the URI (system identifier) of an unparsed entity</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Signatures</label>
                     <def>
                        <example role="signature">
                           <proto name="unparsed-entity-uri" return-type="xs:anyURI" isOp="no"
                              prefix="fn" returnEmptyOk="no" returnSeq="no" returnVaries="no"
                              isSchema="no" isDatatype="no" isSpecial="no">
                              <arg name="entity-name" type="xs:string"/>
                           </proto>
                        </example>
                        <example role="signature">
                           <proto name="unparsed-entity-uri" return-type="xs:anyURI" isOp="no"
                              prefix="fn" returnEmptyOk="no" returnSeq="no" returnVaries="no"
                              isSchema="no" isDatatype="no" isSpecial="no">
                              <arg name="entity-name" type="xs:string"/>
                              <arg name="doc" type="node()"/>
                           </proto>
                        </example>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Properties</label>
                     <def>
                        <p>This function is <xtermref spec="FO30" ref="dt-deterministic"
                              >deterministic</xtermref>, <xtermref spec="FO30"
                              ref="dt-focus-dependent">focus-dependent</xtermref>, and <xtermref
                              spec="FO30" ref="dt-context-dependent">context-dependent</xtermref>.
                        </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Rules</label>
                     <def>
                        <p diff="add" at="S-bug27839">Calling the single-argument form of this
                           function has the same effect as calling the two-argument form with the
                           context item as the second argument<phrase diff="del" at="S-bug29221">,
                              except that a different error code is used in error
                              situations</phrase>.</p>
                        <p>The <phrase diff="add" at="S-bug27839">two-argument</phrase>
                           <function>unparsed-entity-uri</function> function returns the URI of the
                           unparsed entity whose name is given by the value of the
                              <code>$entity-name</code> argument, in the document containing <phrase
                              diff="chg" at="S-bug27839">the node supplied as the value of the
                                 <code>$doc</code> argument</phrase>. It returns the zero-length
                              <code>xs:anyURI</code> if there is no such entity. This function maps
                           to the <code>dm:unparsed-entity-system-id</code> accessor defined in
                              <bibref ref="xpath-datamodel-30"/>.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Error Conditions</label>
                     <def>
                        <p diff="chg" at="S-bug29221">
                           <error spec="XT" type="dynamic" class="DE" code="1370"><p>It is a
                                    <termref def="dt-dynamic-error"/> if <code>$node</code>, or the
                                 context item if the second argument is omitted, is a node in a tree
                                 whose root is not a document node.</p></error>
                        </p>
                        <p>The following errors may be raised when <code>$node</code> is
                           omitted:</p>
                        <ulist>
                           <item>
                              <p>If the context item is absent, <termref def="dt-dynamic-error"/>
                                 <xerrorref spec="XP30" class="DY" code="0002"/>.</p>
                           </item>
                           <item>
                              <p>If the context item is not a node, <termref def="dt-type-error"/>
                                 <xerrorref spec="XP30" class="TY" code="0004"/>.</p>
                           </item>
                        </ulist>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Notes</label>
                     <def>
                        <p role="note">The XDM accessor <code>dm:unparsed-entity-system-id</code> is
                           defined to return an absolute URI, obtained by resolving the system
                           identifier as written against the base URI of the document. If no base
                           URI is available for the document, the
                              <function>unparsed-entity-uri</function> function
                              <rfc2119>should</rfc2119> return the system identifier as written,
                           without any attempt to make it absolute.</p>
                        <p role="note">XML permits more than one unparsed entity declaration with
                           the same name to appear, and says that the first declaration is the one
                           that should be used. This rule <rfc2119>should</rfc2119> be respected
                           during construction of the data model; the data model instance should not
                           contain more than one unparsed entity with the same name.</p>
                     </def>
                  </gitem>
               </glist>
            </div3>
            <div3 id="func-unparsed-entity-public-id">
               <head>fn:unparsed-entity-public-id</head>
               <glist>
                  <gitem>
                     <label>Summary</label>
                     <def>
                        <p>Returns the public identifier of an unparsed entity</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Signatures</label>
                     <def>
                        <example role="signature">
                           <proto name="unparsed-entity-public-id" return-type="xs:string" isOp="no"
                              prefix="fn" returnEmptyOk="no" returnSeq="no" returnVaries="no"
                              isSchema="no" isDatatype="no" isSpecial="no">
                              <arg name="entity-name" type="xs:string"/>
                           </proto>
                        </example>
                        <example role="signature">
                           <proto name="unparsed-entity-public-id" return-type="xs:string" isOp="no"
                              prefix="fn" returnEmptyOk="no" returnSeq="no" returnVaries="no"
                              isSchema="no" isDatatype="no" isSpecial="no">
                              <arg name="entity-name" type="xs:string"/>
                              <arg name="doc" type="node()"/>
                           </proto>
                        </example>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Properties</label>
                     <def>
                        <p>This function is <xtermref spec="FO30" ref="dt-deterministic"
                              >deterministic</xtermref>, <xtermref spec="FO30"
                              ref="dt-focus-dependent">focus-dependent</xtermref>, and <xtermref
                              spec="FO30" ref="dt-context-dependent">context-dependent</xtermref>.
                        </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Rules</label>
                     <def>
                        <p diff="add" at="S-bug27839">Calling the single-argument form of this
                           function has the same effect as calling the two-argument form with the
                           context item as the second argument<phrase diff="del" at="S-bug29221">,
                              except that a different error code is used in error
                              situations</phrase>.</p>
                        <p>The <phrase diff="add" at="S-bug27839">two-argument</phrase>
                           <function>unparsed-entity-public-id</function> function returns the
                           public identifier of the unparsed entity whose name is given by the value
                           of the <code>$entity-name</code> argument, in the document containing
                              <phrase diff="chg" at="S-bug27839">the node supplied as the value of
                              the <code>$doc</code> argument</phrase>. It returns the zero-length
                           string if there is no such entity, or if the entity has no public
                           identifier. This function maps to the
                              <code>dm:unparsed-entity-public-id</code> accessor defined in <bibref
                              ref="xpath-datamodel-30"/>.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Error Conditions</label>
                     <def>
                        <p diff="chg" at="S-bug29221">
                           <error spec="XT" type="dynamic" class="DE" code="1380"><p>It is a
                                    <termref def="dt-dynamic-error"/> if <code>$node</code>, or the
                                 context item if the second argument is omitted, is a node in a tree
                                 whose root is not a document node.</p></error>
                        </p>
                        <p>The following errors may be raised when <code>$node</code> is
                           omitted:</p>
                        <ulist>
                           <item>
                              <p>If the context item is absent, <termref def="dt-dynamic-error"/>
                                 <xerrorref spec="XP30" class="DY" code="0002"/>.</p>
                           </item>
                           <item>
                              <p>If the context item is not a node, <termref def="dt-type-error"/>
                                 <xerrorref spec="XP30" class="TY" code="0004"/>.</p>
                           </item>
                        </ulist>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Notes</label>
                     <def>
                        <p role="note">XML permits more than one unparsed entity declaration with
                           the same name to appear, and says that the first declaration is the one
                           that should be used. This rule <rfc2119>should</rfc2119> be respected
                           during construction of the data model; the data model instance should not
                           contain more than one unparsed entity with the same name.</p>
                     </def>
                  </gitem>
               </glist>
            </div3>
            <div3 id="func-system-property">
               <head>fn:system-property</head>
               <glist>
                  <gitem>
                     <label>Summary</label>
                     <def>
                        <p>Returns the value of a system property</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Signature</label>
                     <def>
                        <example role="signature">
                           <proto name="system-property" return-type="xs:string" isOp="no"
                              prefix="fn" returnEmptyOk="no" returnSeq="no" returnVaries="no"
                              isSchema="no" isDatatype="no" isSpecial="no">
                              <arg name="property-name" type="xs:string"/>
                           </proto>
                        </example>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Properties</label>
                     <def>
                        <p>This function is <xtermref spec="FO30" ref="dt-deterministic"
                              >deterministic</xtermref>, <xtermref spec="FO30"
                              ref="dt-focus-independent">focus-independent</xtermref>, and <xtermref
                              spec="FO30" ref="dt-context-dependent">context-dependent</xtermref>.
                           It depends on namespaces. </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Rules</label>
                     <def>
                        <p diff="chg" at="S-bug29113">The value of the <code>$property-name</code>
                           argument <rfc2119>must</rfc2119> be a string containing an <termref
                              def="dt-eqname">EQName</termref>. If it is a <termref
                              def="dt-lexical-qname">lexical QName</termref> with a prefix, then it
                           is expanded into an <termref def="dt-expanded-qname">expanded
                              QName</termref> using the namespace declarations in the static context
                           of the <termref def="dt-expression">expression</termref>. If there is no
                           prefix, the name is taken as being in no namespace.</p>
                        <p>The <function>system-property</function> function returns a string
                           representing the value of the system property identified by the name. If
                           there is no such system property, the zero-length string is returned.</p>
                        <p>Implementations <rfc2119>must</rfc2119> provide the following system
                           properties, which are all in the <termref def="dt-xslt-namespace">XSLT
                              namespace</termref>:</p>
                        <ulist>
                           <item>
                              <p>
                                 <code>xsl:version</code>, a number giving the version of XSLT
                                 implemented by the <termref def="dt-processor">processor</termref>;
                                 for implementations conforming to the version of XSLT specified by
                                 this document, this is the string <phrase diff="chg" at="A"
                                       ><code>"3.0"</code></phrase>. The value will always be a
                                 string in the lexical space of the decimal datatype defined in XML
                                 Schema (see <bibref ref="xmlschema-2"/>). This allows the value to
                                 be converted to a number for the purpose of magnitude
                                 comparisons.</p>
                           </item>
                           <item>
                              <p>
                                 <code>xsl:vendor</code>, a string identifying the implementer of
                                 the <termref def="dt-processor">processor</termref>
                              </p>
                           </item>
                           <item>
                              <p>
                                 <code>xsl:vendor-url</code>, a string containing a URL identifying
                                 the implementer of the <termref def="dt-processor"
                                    >processor</termref>; typically this is the host page (home
                                 page) of the implementer's Web site.</p>
                           </item>
                           <item>
                              <p>
                                 <code>xsl:product-name</code>, a string containing the name of the
                                 implementation, as defined by the implementer. This
                                    <rfc2119>should</rfc2119> normally remain constant from one
                                 release of the product to the next. It <rfc2119>should</rfc2119>
                                 also be constant across platforms in cases where the same source
                                 code is used to produce compatible products for multiple execution
                                 platforms.</p>
                           </item>
                           <item>
                              <p>
                                 <code>xsl:product-version</code>, a string identifying the version
                                 of the implementation, as defined by the implementer. This
                                    <rfc2119>should</rfc2119> normally vary from one release of the
                                 product to the next, and at the discretion of the implementer it
                                    <rfc2119>may</rfc2119> also vary across different execution
                                 platforms.</p>
                           </item>
                           <item>
                              <p>
                                 <code>xsl:is-schema-aware</code>, returns the string
                                    <code>"yes"</code> in the case of a processor that claims
                                 conformance as a <termref def="dt-schema-aware-xslt-processor"
                                    >schema-aware XSLT processor</termref>, or <code>"no"</code> in
                                 the case of a <termref def="dt-basic-xslt-processor">basic XSLT
                                    processor</termref>.</p>
                           </item>
                           <item>
                              <p>
                                 <code>xsl:supports-serialization</code>, returns the string
                                    <code>"yes"</code> in the case of a processor that offers the
                                    <termref def="dt-serialization-feature">serialization
                                    feature</termref>, or <code>"no"</code> otherwise.</p>
                           </item>
                           <item>
                              <p>
                                 <code>xsl:supports-backwards-compatibility</code>, returns the
                                 string <code>"yes"</code> in the case of a processor that offers
                                 the <phrase diff="chg" at="E"><termref
                                       def="dt-1.0-compatibility-feature"/></phrase>, or
                                    <code>"no"</code> otherwise.</p>
                           </item>
                           <item>
                              <p diff="add" at="A">
                                 <code>xsl:supports-namespace-axis</code>, returns the string
                                    <code>"yes"</code> in the case of a processor that offers the
                                 XPath namespace axis even when not in backwards compatible mode, or
                                    <code>"no"</code> otherwise. Note that a processor that supports
                                 backwards compatible mode must support the namespace axis when in
                                 that mode, so this property is not relevant to that case.</p>
                           </item>
                           <item>
                              <p diff="add" at="A">
                                 <code>xsl:supports-streaming</code>, returns the string
                                    <code>"yes"</code> in the case of a processor that offers the
                                 streaming feature (see <specref ref="streaming-feature"/>), or
                                    <code>"no"</code> otherwise.</p>
                           </item>
                           <item>
                              <p diff="add" at="N">
                                 <code>xsl:supports-dynamic-evaluation</code>, returns the string
                                    <code>"yes"</code> in the case of a processor that offers the
                                 dynamic evaluation feature (see <specref
                                    ref="dynamic-evaluation-feature"/>), or <code>"no"</code>
                                 otherwise.</p>
                           </item>
                           <item>
                              <p diff="add" at="S-bug29251">
                                 <code>xsl:supports-higher-order-functions</code>, returns the
                                 string <code>"yes"</code> in the case of a processor that offers
                                 the <termref def="dt-hof-feature"/>, or <code>"no"</code>
                                 otherwise.</p>
                           </item>
                           <item>
                              <p diff="add" at="S-bug24266">
                                 <code>xsl:xpath-version</code>, a number giving the version of
                                 XPath implemented by the <termref def="dt-processor"
                                    >processor</termref>. The value will always be a string in the
                                 lexical space of the decimal datatype defined in XML Schema (see
                                    <bibref ref="xmlschema-2"/>). This allows the value to be
                                 converted to a number for the purpose of magnitude comparisons.
                                 Typical values are <code>"3.0"</code> or <code>"3.1"</code>. The
                                 value <code>"3.0"</code> indicates that the processor implements
                                 XPath 3.0 plus the extensions defined in <specref ref="map"/> and
                                    <specref ref="json"/>. </p>
                           </item>
                           <item>
                              <p diff="add" at="S-bug24266">
                                 <code>xsl:xsd-version</code>, a number giving the version of XSD
                                 (XML Schema) implemented by the <termref def="dt-processor"
                                    >processor</termref>. The value will always be a string in the
                                 lexical space of the decimal datatype defined in XML Schema (see
                                    <bibref ref="xmlschema-2"/>). This allows the value to be
                                 converted to a number for the purpose of magnitude comparisons.
                                 Typical values are <code>"1.0"</code> or <code>"1.1"</code>. This
                                 property is relevant even when the processor is not schema-aware,
                                 since the built-in datatypes for XSD 1.1 differ from those in XSD
                                 1.0. </p>
                           </item>
                        </ulist>
                        <p>Some of these properties relate to the conformance levels and features
                           offered by the <termref def="dt-processor">processor</termref>: these
                           options are described in <specref ref="conformance"/>.</p>
                        <p>The actual values returned for the above properties are <termref
                              def="dt-implementation-defined">implementation-defined</termref>.</p>
                        <p>The set of system properties that are supported, in addition to those
                           listed above, is also <termref def="dt-implementation-defined"
                              >implementation-defined</termref>. Implementations <rfc2119>must
                              not</rfc2119> define additional system properties in the XSLT
                           namespace.</p>
                        <imp-def-feature>The values returned by the
                              <function>system-property</function> function, and the names of the
                           additional properties that are recognized, are
                           implementation-defined.</imp-def-feature>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Error Conditions</label>
                     <def>
                        <p>
                           <error spec="XT" type="dynamic" class="DE" code="1390"><p>It is a
                                    <termref def="dt-dynamic-error"><phrase diff="del" at="N"
                                       >non-recoverable</phrase> dynamic error</termref> if the
                                 value supplied as the <code>$property-name</code> argument
                                    <error.extra>to the <function>system-property</function>
                                    function</error.extra> is not a valid QName, or if there is no
                                 namespace declaration in scope for the prefix of the QName. If the
                                 processor is able to detect the error statically (for example, when
                                 the argument is supplied as a string literal), then the processor
                                    <rfc2119>may</rfc2119> optionally signal this as a <termref
                                    def="dt-static-error">static error</termref>. </p></error>
                        </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Notes</label>
                     <def>
                        <p role="note">An implementation must not return the value <code>
                              <phrase diff="chg" at="A">3.0</phrase>
                           </code> as the value of the <code>xsl:version</code> system property
                           unless it is conformant to XSLT <phrase diff="chg" at="A"
                           >3.0</phrase>.</p>
                        <p role="note">It is recognized that vendors who are enhancing XSLT 1.0
                              <phrase diff="chg" at="A">or 2.0</phrase> processors may wish to
                           release interim implementations before all the mandatory features of this
                           specification are implemented. Since such products are not conformant to
                           XSLT 3.0, this specification cannot define their behavior. However,
                           implementers of such products are encouraged to return a value for the
                              <code>xsl:version</code> system property that is intermediate between
                           1.0 and 3.0, and to provide the <function>element-available</function>
                           and <function>function-available</function> functions to allow users to
                           test which features have been fully implemented.</p>
                     </def>
                  </gitem>
               </glist>
            </div3>
            <div3 id="func-available-system-properties" diff="add" at="S-bug29109">
               <head>fn:available-system-properties</head>
               <glist>
                  <gitem>
                     <label>Summary</label>
                     <def>
                        <p>Returns a list of system property names that are suitable for passing to
                           the <function>system-property</function> function, as a sequence of
                           QNames.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Signature</label>
                     <def>
                        <example role="signature">
                           <proto name="available-system-properties" return-type="xs:QName*"
                              isOp="no" prefix="fn" returnEmptyOk="no" returnSeq="no"
                              returnVaries="no" isSchema="no" isDatatype="no" isSpecial="no"/>
                        </example>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Properties</label>
                     <def>
                        <p>This function is <xtermref spec="FO30" ref="dt-deterministic"
                              >deterministic</xtermref>, <xtermref spec="FO30"
                              ref="dt-context-independent">context-independent</xtermref>, and
                              <xtermref spec="FO30" ref="dt-focus-independent"
                              >focus-independent</xtermref>. </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Rules</label>
                     <def>
                        <p>The function returns a sequence of QNames, being the names of the system
                           properties recognized by the processor, in some <termref
                              def="dt-implementation-dependent">implementation-dependent</termref>
                           order.</p>
                        <p diff="add" at="T-bug29988">The prefix part of a returned QName is
                              <termref def="dt-implementation-dependent"/>.</p>
                        <p>The function is <xtermref spec="FO30" ref="dt-deterministic"
                              >deterministic</xtermref>: that is, the set of available system
                           properties does not vary during the course of a transformation.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Notes</label>
                     <def>
                        <p role="note">The function returns a list of QNames, containing no
                           duplicates.</p>
                        <p role="note">It is intended that the QNames in this list should be
                           suitable for passing to <function>system-property</function>. <phrase
                              diff="chg" at="T-bug29988">However, they must first be converted to
                              the form expected by the <function>system-property</function>
                              function, which is either a lexical QName or to an EQName in the form
                                 <code>Q{uri}local</code>. Because the prefix of the returned QName
                              is unpredictable, the <code>Q{uri}local</code> is likely to be more
                              convenient. Conversion of an <code>xs:QName</code> value to an EQName
                              in <code>Q{uri}local</code> format can be achieved using the
                              function:</phrase></p>
                        <eg role="note" xml:space="preserve">
&lt;xsl:function name="f:QName-to-brace-notation" as="xs:string"&gt;
  &lt;xsl:param name="qname" as="xs:QName"/&gt;
  &lt;xsl:sequence select="'Q{' || namespace-uri-from-QName($qname) || '}' 
                             || local-name-from-QName($qname)"/&gt;
&lt;/xsl:function&gt;  
            </eg>
                     </def>
                  </gitem>
               </glist>
            </div3>
         </div2>
      </div1>
      <div1 id="map">
         <head>Maps</head>
         <p diff="chg" at="S-bug24266">When XSLT 3.0 is used with XPath 3.0, it extends the type
            system and data model of XPath 3.0 with an additional datatype: the map. A map is an
            additional kind of item. Supporting this additional type are additional XPath language
            constructs, types, and XSLT instructions, all defined in this section.</p>
         <note diff="add" at="S-bug24266">
            <p>The extensions to XPath 3.0 defined in this section have been incorporated into XPath
               3.1. Therefore, when an XSLT 3.0 processor implements the <termref
                  def="dt-xpath31-feature"/>, the relevant parts of this section can be ignored.</p>
         </note>
         <p/>
         <p><termdef id="dt-map" term="map">A map consists of <phrase diff="del" at="N">a collation
                  and </phrase>a set of entries. Each entry comprises a key which is an arbitrary
               atomic value, and an arbitrary sequence called the associated value.</termdef></p>
         <p diff="chg" at="S-bug28632"><termdef id="dt-same-key" term="same key">Within a map, no
               two entries have the <term>same key</term>. <phrase diff="chg" at="N">Two atomic
                  values <code>K1</code> and <code>K2</code> are the <term>same key</term> for this
                  purpose if the relation <code>op:same-key(K1, K2, $UCC)</code>
               holds.</phrase></termdef></p>
         <p diff="chg" at="N">To put it another way, <phrase diff="add" at="S-bug28632">subject to
               the rule above regarding timezones,</phrase> the keys are the same if either <code>K1
               eq K2</code> is true under the Unicode codepoint collation, or if both
               <code>K1</code> and <code>K2</code> are <code>NaN</code>. It is not necessary that
            all the keys should be mutually comparable (for example, they can include a mixture of
            integers and strings). <phrase diff="del" at="N">Key values will never be of type
                  <code>xs:untypedAtomic</code>, and they will never be the <code>xs:float</code> or
                  <code>xs:double</code> value <code>NaN</code>.</phrase></p>
         <p>The function call <code>map:get($map, $key)</code> can be used to retrieve the value
            associated with a given key.</p>
         <p>A <termref def="dt-map">map</termref> can also be viewed as a function from keys to
            associated values. To achieve this, a map is also a function item. The properties of
            this function are as follows:</p>
         <ulist diff="add" at="N">
            <item>
               <p>The <term>name</term> of the function is absent.</p>
            </item>
            <item>
               <p>The <term>arity</term> of the function is 1 (one).</p>
            </item>
            <item>
               <p>The <term>parameter names</term> comprise a sequence of one QName, conventionally
                     <code>$key</code>, though the choice of name has no observable
                  consequences.</p>
            </item>
            <item>
               <p>The <term>signature</term> is <code>function($key as xs:anyAtomicValue) as
                     item()*</code> (with no annotations).</p>
            </item>
            <item>
               <p>The <term>implementation</term> is the expression <code>map:get($self,
                     $key)</code></p>
            </item>
            <item>
               <p>The <term>non-local-variable-bindings</term> comprise a single variable,
                     <code>$self</code>, whose value is the map itself.</p>
            </item>
         </ulist>
         <p>Calling the function has the same effect as calling the <code>get</code> function: the
            expression <code>$map($key)</code> returns the same result as <code>get($map,
               $key)</code>. For example, if <code>$books-by-isbn</code> is a map whose keys are
            ISBNs and whose associated values are <code>book</code> elements, then the expression
               <code>$books-by-isbn("0470192747")</code> returns the <code>book</code> element with
            the given ISBN. The fact that a map is a function item allows it to be passed as an
            argument to higher-order functions that expect a function item as one of their
            arguments.</p>
         <p diff="chg" at="S-bug27040">Like all other values, <termref def="dt-map">maps</termref>
            are immutable. For example, the <function>map:remove</function> function returns a map
            that differs from the supplied map by the omission of one entry, but the supplied map is
            not changed by the operation. Two calls on <function>map:remove</function> with the same
            arguments will return maps that are indistinguishable from each other; there is no way
            of asking whether these are “the same map”.</p>
         <div2 id="map-type">
            <head>The Type of a Map</head>
            <p>The syntax of <xnt xmlns:xlink="http://www.w3.org/1999/xlink"
                  ref="prod-xpath30-ItemType" spec="XP30" xlink:type="simple">ItemType</xnt> as
               defined in XPath is extended as follows:</p>
            <scrap headstyle="show" id="MapType-scrap">
               <head>MapType</head>
               <prodgroup>
                  <prod num="69" id="NT-ItemType-2">
                     <lhs>ItemType</lhs>
                     <rhs>KindTest | ("item" "(" ")") | FunctionTest | AtomicOrUnionType |
                        ParenthesizedItemType<br/> | MapType</rhs>
                  </prod>
                  <prod num="201" id="NT-MapType">
                     <lhs>MapType</lhs>
                     <rhs>'map' '(' ( '*' | (<xnt xmlns:xlink="http://www.w3.org/1999/xlink"
                           ref="doc-xpath30-AtomicOrUnionType" spec="XP30" xlink:type="simple"
                           >AtomicOrUnionType</xnt> ',' <xnt
                           xmlns:xlink="http://www.w3.org/1999/xlink"
                           ref="prod-xpath30-SequenceType" spec="XP30" xlink:type="simple"
                           >SequenceType</xnt>) ')'</rhs>
                  </prod>
               </prodgroup>
            </scrap>
            <p diff="add" at="N">The following rules express the matching rules for a map item type
               and a map, and extend the set of rules given in <xspecref spec="XP30"
                  ref="id-matching-item"/>:</p>
            <ulist>
               <item>
                  <p>The <code>ItemType</code>
                     <code>map(K, V)</code> matches an item <var>M</var> if (a) <var>M</var> is a
                        <termref def="dt-map">map</termref>, and (b) every entry in <var>M</var> has
                     a key that matches <var>K</var> and an associated value that matches
                        <var>V</var>. For example, <code>map(xs:integer, element(employee))</code>
                     matches a map if all the keys in the map are integers, and all the associated
                     values are <code>employee</code> elements. Note that a map (like a sequence)
                     carries no intrinsic type information separate from the types of its entries,
                     and the type of existing entries in a map does not constrain the type of new
                     entries that can be added to the map.</p>
                  <note>
                     <p diff="add" at="N">In consequence, <code>map(K, V)</code> matches an empty
                        map, whatever the types <var>K</var> and <var>V</var> might be.</p>
                  </note>
               </item>
               <item>
                  <p>The <code>ItemType</code>
                     <code>map(*)</code> matches any map regardless of its contents. It is
                     equivalent to <code>map(xs:anyAtomicType, item()*)</code>.</p>
               </item>
            </ulist>
            <p diff="add" at="N">A map also acts as a function. This means that maps match certain
               function item types. Specifically, the following rule extends the list of rules in
                  <xspecref spec="XP30" ref="id-function-test"/>:</p>
            <ulist diff="add" at="N">
               <item>
                  <p><code>function(*)</code> matches any map.</p>
               </item>
               <item>
                  <p><code>function(xs:anyAtomicType) as item()*</code> matches any map.</p>
               </item>
            </ulist>
            <p diff="add" at="N">Because of the rules for subtyping of function types according to
               their signature, it follows that the item type <code>function(A) as item()*</code>,
               where A is an atomic type, also matches any map, regardless of the type of the keys
               actually found in the map. For example, a map whose keys are all strings can be
               supplied where the required type is <code>function(xs:integer) as item()*</code>; a
               call on the map that treats it as a function with an integer argument will always
               succeed, and will always return an empty sequence.</p>
            <p diff="add" at="N">The function signature of the map, treated as a function, is always
                  <code>function(xs:anyAtomicType) as item()*</code>, regardless of the actual types
               of the keys and values in the map. This means that a function item type with a more
               specific return type, such as <code>function(xs:anyAtomicType) as xs:integer</code>,
               does not match a map in the sense required to satisfy the <code>instance of</code>
               operator. However, the rules for function coercion mean that any map can be supplied
               as a value in a context where such a type is the required type, and a type error will
               only occur if an actual call on the map (treated as a function) returns a value that
               is not an instance of the required return type.</p>
            <note diff="add" at="N">
               <p>So, given a map <code>$M</code> whose keys are integers and whose results are
                  strings, such as <code>map{0:"no", 1:"yes"}</code>, the following relations hold,
                  among others:</p>
               <ulist>
                  <item>
                     <p><code>$M instance of map(*)</code></p>
                  </item>
                  <item>
                     <p><code>$M instance of map(xs:integer, xs:string)</code></p>
                  </item>
                  <item>
                     <p><code>$M instance of map(xs:decimal, xs:anyAtomicType)</code></p>
                  </item>
                  <item>
                     <p><code>not($M instance of map(xs:int, xs:string))</code></p>
                  </item>
                  <item>
                     <p><code>not($M instance of map(xs:integer, xs:token))</code></p>
                  </item>
                  <item>
                     <p><code>$M instance of function(*)</code></p>
                  </item>
                  <item>
                     <p><code>$M instance of function(xs:anyAtomicType) as item()*</code></p>
                  </item>
                  <item>
                     <p><code>$M instance of function(xs:integer) as item()*</code></p>
                  </item>
                  <item>
                     <p><code>$M instance of function(xs:int) as item()*</code></p>
                  </item>
                  <item>
                     <p><code>$M instance of function(xs:string) as item()*</code></p>
                  </item>
                  <item>
                     <p><code>not($M instance of function(xs:integer) as xs:string)</code></p>
                  </item>
               </ulist>
               <p>The last case might seem surprising; however, function coercion ensures that
                     <code>$M</code> can be used successfully anywhere that the required type is
                     <code>function(xs:integer) as xs:string</code>.</p>
            </note>
            <p diff="add" at="N">The rules for judging whether one item type is a subtype of
               another, given in <xspecref spec="XP30" ref="id-itemtype-subtype"/>, are extended
               with some additional rules. The judgement <code>subtype-itemtype(Ai, Bi)</code> is
               true if:</p>
            <ulist diff="chg" at="R-bug24456">
               <item>
                  <p><code>Ai</code> is <code>map(K, V)</code> and <code>Bi</code> is
                        <code>map(*)</code>, for any <code>K</code> and <code>V</code>.</p>
               </item>
               <item>
                  <p><code>Ai</code> is <code>map(Ka, Va)</code> and <code>Bi</code> is
                        <code>map(Kb, Vb)</code>, where <code>subtype-itemtype(Ka, Kb)</code> and
                        <code>subtype(Va, Vb)</code>.</p>
               </item>
               <item>
                  <p><code>Ai</code> is <code>map(*)</code> (or, because of the transitivity rules,
                     any other map type) and <code>Bi</code> is <code>function(*)</code>.</p>
               </item>
               <item>
                  <p><code>Ai</code> is <code>map(*)</code>, (or, because of the transitivity rules,
                     any other map type) and <code>Bi</code> is <code>function(xs:anyAtomicType) as
                        item()*</code>.</p>
               </item>
            </ulist>
         </div2>
         <div2 id="map-functions" diff="chg" at="S-bug24266">
            <head>Functions that Operate on Maps</head>
            <p>XSLT 3.0 provides a number of functions that operate on maps, or that are useful in
               conjunction with maps. These functions are specified in <bibref
                  ref="xpath-functions-31"/>, but they are available with XSLT 3.0 whether or not
               the processor offers the <termref def="dt-xpath31-feature"/>.</p>
            <p>Some of the functions defined in this section use a conventional namespace prefix
                  <code>map</code>, which is assumed to be bound to the namespace URI
                  <code>http://www.w3.org/2005/xpath-functions/map</code>.</p>
            <p>Note that there is no operation to atomize a map or convert it to a string.</p>
            <div3 id="func-same-key">
               <head>op:same-key</head>
               <glist>
                  <gitem>
                     <label>Summary</label>
                     <def>
                        <p>Determines whether two atomic values can coexist as separate keys within
                           a map.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Signature</label>
                     <def>
                        <example role="signature">
                           <proto name="same-key" return-type="xs:boolean" isOp="no" prefix="op"
                              returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no"
                              isDatatype="no" isSpecial="no">
                              <arg name="k1" type="xs:anyAtomicType"/>
                              <arg name="k2" type="xs:anyAtomicType"/>
                           </proto>
                        </example>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Properties</label>
                     <def>
                        <p>This function is <xtermref spec="FO30" ref="dt-deterministic"
                              >deterministic</xtermref>, <xtermref spec="FO30"
                              ref="dt-context-independent">context-independent</xtermref>, and
                              <xtermref spec="FO30" ref="dt-focus-independent"
                              >focus-independent</xtermref>. </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Rules</label>
                     <def>
                        <p>The internal function <code>op:same-key</code> (which is not available at
                           the user level) is used to assess whether two atomic values are
                           considered to be duplicates when used as keys in a map. A map cannot
                           contain two separate entries whose keys are <term>the same</term> as
                           defined by this function. The function is also used when matching keys in
                           functions such as <code>map:get</code> and <code>map:remove</code>.</p>
                        <p>The function returns true if and only if one of the following conditions
                           is true:</p>
                        <olist>
                           <item>
                              <p>All of the following conditions are true:</p>
                              <olist>
                                 <item>
                                    <p><code>$k1</code> is an instance of <code>xs:string</code>,
                                          <code>xs:anyURI</code>, or
                                       <code>xs:untypedAtomic</code></p>
                                 </item>
                                 <item>
                                    <p><code>$k2</code> is an instance of <code>xs:string</code>,
                                          <code>xs:anyURI</code>, or
                                       <code>xs:untypedAtomic</code></p>
                                 </item>
                                 <item>
                                    <p><code>fn:codepoint-equal($k1, $k2)</code></p>
                                 </item>
                              </olist>
                              <note>
                                 <p>Strings are compared without any dependency on collations.</p>
                              </note>
                           </item>
                           <item>
                              <p>All of the following conditions are true:</p>
                              <olist>
                                 <item>
                                    <p><code>$k1</code> is an instance of <code>xs:decimal</code>,
                                          <code>xs:double</code>, or <code>xs:float</code></p>
                                 </item>
                                 <item>
                                    <p><code>$k2</code> is an instance of <code>xs:decimal</code>,
                                          <code>xs:double</code>, or <code>xs:float</code></p>
                                 </item>
                                 <item>
                                    <p>One of the following conditions is true:</p>
                                    <olist>
                                       <item>
                                          <p>Both <code>$k1</code> and <code>$k2</code> are
                                                <code>NaN</code></p>
                                          <note>
                                             <p><code>xs:double('NaN')</code> is the same key as
                                                  <code>xs:float('NaN')</code></p>
                                          </note>
                                       </item>
                                       <item>
                                          <p>Both <code>$k1</code> and <code>$k2</code> are positive
                                             infinity</p>
                                          <note>
                                             <p><code>xs:double('INF')</code> is the same key as
                                                  <code>xs:float('INF')</code></p>
                                          </note>
                                       </item>
                                       <item>
                                          <p>Both <code>$k1</code> and <code>$k2</code> are negative
                                             infinity</p>
                                          <note>
                                             <p><code>xs:double('-INF')</code> is the same key as
                                                  <code>xs:float('-INF')</code></p>
                                          </note>
                                       </item>
                                       <item>
                                          <p><code>$k1</code> and <code>$k2</code> when converted to
                                             decimal numbers with no rounding or loss of precision
                                             are mathematically equal.</p>
                                          <note>
                                             <p>Every instance of <code>xs:double</code>,
                                                  <code>xs:float</code>, and <code>xs:decimal</code>
                                                can be represented exactly as a decimal number
                                                provided enough digits are available both before and
                                                after the decimal point. Unlike the <code>eq</code>
                                                relation, which converts both operands to
                                                  <code>xs:double</code> values, possibly losing
                                                precision in the process, this comparison is
                                                transitive.</p>
                                          </note>
                                          <note>
                                             <p>Positive and negative zero are the same key.</p>
                                          </note>
                                       </item>
                                    </olist>
                                 </item>
                              </olist>
                           </item>
                           <item>
                              <p>All of the following conditions are true:</p>
                              <olist>
                                 <item>
                                    <p><code>$k1</code> is an instance of <code>xs:date</code>,
                                          <code>xs:time</code>, <code>xs:dateTime</code>,
                                          <code>xs:gYear</code>, <code>xs:gYearMonth</code>,
                                          <code>xs:gMonth</code>, <code>xs:gMonthDay</code>, or
                                          <code>xs:gDay</code></p>
                                 </item>
                                 <item>
                                    <p><code>$k2</code> is an instance of <code>xs:date</code>,
                                          <code>xs:time</code>, <code>xs:dateTime</code>,
                                          <code>xs:gYear</code>, <code>xs:gYearMonth</code>,
                                          <code>xs:gMonth</code>, <code>xs:gMonthDay</code>, or
                                          <code>xs:gDay</code></p>
                                 </item>
                                 <item>
                                    <p>One of the following conditions is true:</p>
                                    <olist>
                                       <item>
                                          <p>Both <code>$k1</code> and <code>$k2</code> have a
                                             timezone</p>
                                       </item>
                                       <item>
                                          <p>Neither <code>$k1</code> nor <code>$k2</code> has a
                                             timezone</p>
                                       </item>
                                    </olist>
                                 </item>
                                 <item>
                                    <p><code>fn:deep-equal($k1, $k2)</code></p>
                                    <note>
                                       <p>The use of <code>deep-equal</code> rather than
                                             <code>eq</code> ensures that comparing values of
                                          different types yields <code>false</code> rather than an
                                          error.</p>
                                    </note>
                                 </item>
                              </olist>
                              <note>
                                 <p>Unlike the <code>eq</code> operator, this comparison has no
                                    dependency on the implicit timezone, which means that the
                                    question of whether or not a map contains duplicate keys is not
                                    dependent on this aspect of the dynamic context.</p>
                              </note>
                           </item>
                           <item>
                              <p>All of the following conditions are true:</p>
                              <olist>
                                 <item>
                                    <p><code>$k1</code> is an instance of <code>xs:boolean</code>,
                                          <code>xs:hexBinary</code>, <code>xs:base64Binary</code>,
                                          <code>xs:duration</code>, <code>xs:QName</code>, or
                                          <code>xs:NOTATION</code></p>
                                 </item>
                                 <item>
                                    <p><code>$k2</code> is an instance of <code>xs:boolean</code>,
                                          <code>xs:hexBinary</code>, <code>xs:base64Binary</code>,
                                          <code>xs:duration</code>, <code>xs:QName</code>, or
                                          <code>xs:NOTATION</code></p>
                                 </item>
                                 <item>
                                    <p><code>fn:deep-equal($k1, $k2)</code></p>
                                    <note>
                                       <p>The use of <code>deep-equal</code> rather than
                                             <code>eq</code> ensures that comparing values of
                                          different types yields <code>false</code> rather than an
                                          error.</p>
                                    </note>
                                 </item>
                              </olist>
                           </item>
                        </olist>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Notes</label>
                     <def>
                        <p role="note">The rules for comparing keys in a map are chosen to ensure
                           that the comparison is:</p>
                        <ulist role="note">
                           <item>
                              <p><term>Context-free</term>: there is no dependency on the static or
                                 dynamic context</p>
                           </item>
                           <item>
                              <p><term>Error-free</term>: any two atomic values can be compared, and
                                 the result is either true or false, never an error</p>
                           </item>
                           <item>
                              <p><term>Transitive</term>: if A is the same key as B, and B is the
                                 same key as C, then A is the same key as C.</p>
                           </item>
                        </ulist>
                        <p role="note">As always, any algorithm that delivers the right result is
                           acceptable. For example, when testing whether an <code>xs:double</code>
                           value <var>D</var> is the same key as an <code>xs:decimal</code> value
                           that has <var>N</var> significant digits, it is not necessary to know all
                           the digits in the decimal expansion of <var>D</var> to establish the
                           result: computing the first <var>N+1</var> significant digits (or indeed,
                           simply knowing that there are more than <var>N</var> significant digits)
                           is sufficient.</p>
                     </def>
                  </gitem>
               </glist>
            </div3>
            <div3 id="func-map-merge">
               <head>map:merge</head>
               <glist>
                  <gitem>
                     <label>Summary</label>
                     <def>
                        <p>Returns a map that combines the entries from a number of existing
                           maps.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Signatures</label>
                     <def>
                        <example role="signature">
                           <proto name="merge" return-type="map(*)" isOp="no" prefix="map"
                              returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no"
                              isDatatype="no" isSpecial="no">
                              <arg name="maps" type="map(*)*"/>
                           </proto>
                        </example>
                        <example role="signature">
                           <proto name="merge" return-type="map(*)" isOp="no" prefix="map"
                              returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no"
                              isDatatype="no" isSpecial="no">
                              <arg name="maps" type="map(*)*"/>
                              <arg name="options" type="map(*)"/>
                           </proto>
                        </example>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Properties</label>
                     <def>
                        <p>This function is <xtermref spec="FO30" ref="dt-deterministic"
                              >deterministic</xtermref>, <xtermref spec="FO30"
                              ref="dt-context-independent">context-independent</xtermref>, and
                              <xtermref spec="FO30" ref="dt-focus-independent"
                              >focus-independent</xtermref>. </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Rules</label>
                     <def>
                        <p>The function <code>map:merge</code> returns a map that is formed by
                           combining the contents of the maps supplied in the <code>$maps</code>
                           argument.</p>
                        <p>Informally, the supplied maps are combined as follows:</p>
                        <olist>
                           <item>
                              <p>There is one entry in the returned map for each distinct key
                                 present in the union of the input maps, where two keys are distinct
                                 if they are not the <phrase diff="chg" at="N"><termref
                                       def="dt-same-key">same key</termref></phrase>.</p>
                           </item>
                           <item>
                              <p diff="chg" at="E">If there are duplicate keys, that is, if two or
                                 more maps contain entries having the <termref def="dt-same-key"
                                    >same key</termref>, then the way this is handled is controlled
                                 by the second (<code>$options</code>) argument.</p>
                           </item>
                        </olist>
                        <p>The definitive specification is as follows.</p>
                        <olist>
                           <item>
                              <p>The effect of calling the single-argument function is the same as
                                 the effect of calling the two-argument function with an empty map
                                 as the value of <code>$options</code>.</p>
                           </item>
                           <item>
                              <p>The <code>$options</code> argument can be used to control the way
                                 in which duplicate keys are handled. The <termref
                                    def="option-parameter-conventions">option parameter
                                    conventions</termref> apply. </p>
                           </item>
                           <item>
                              <p>The entries that may appear in the <code>$options</code> map are as
                                 follows:</p>
                              <table class="data">
                                 <thead>
                                    <tr>
                                       <th rowspan="1" colspan="1">Key</th>
                                       <th rowspan="1" colspan="1">Value</th>
                                       <th rowspan="1" colspan="1">Meaning</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr>
                                       <td rowspan="6" colspan="1">
                                          <code>duplicates</code>
                                       </td>
                                       <td colspan="2" rowspan="1">Determines the policy for
                                          handling duplicate keys: specifically, the action to be
                                          taken if two maps in the input sequence <code>$maps</code>
                                          contain entries with key values <var>K1</var> and
                                             <var>K2</var> where <var>K1</var> and <var>K2</var> are
                                          the <termref def="dt-same-key">same key</termref>. The
                                          required type is <code>xs:string</code>. The default value
                                          is <code>use-first</code>.</td>
                                    </tr>
                                    <tr>
                                       <td rowspan="1" colspan="1">
                                          <code>reject</code>
                                       </td>
                                       <td rowspan="1" colspan="1">An error is raised <xerrorref
                                             spec="FO31" class="JS" code="0003"/> if duplicate keys
                                          are encountered.</td>
                                    </tr>
                                    <tr>
                                       <td rowspan="1" colspan="1">
                                          <code>use-first</code>
                                       </td>
                                       <td rowspan="1" colspan="1">If duplicate keys are present,
                                          all but the first of a set of duplicates are ignored,
                                          where the ordering is based on the order of maps in the
                                             <code>$maps</code> argument.</td>
                                    </tr>
                                    <tr>
                                       <td rowspan="1" colspan="1">
                                          <code>use-last</code>
                                       </td>
                                       <td rowspan="1" colspan="1">If duplicate keys are present,
                                          all but the last of a set of duplicates are ignored, where
                                          the ordering is based on the order of maps in the
                                             <code>$maps</code> argument.</td>
                                    </tr>
                                    <tr>
                                       <td rowspan="1" colspan="1">
                                          <code>combine</code>
                                       </td>
                                       <td rowspan="1" colspan="1">If duplicate keys are present,
                                          the result map includes an entry for the key whose
                                          associated value is the sequence-concatenation of all the
                                          values associated with the key, retaining order based on
                                          the order of maps in the <code>$maps</code> argument. The
                                          key value in the result map that corresponds to such a set
                                          of duplicates must be the <termref def="dt-same-key">same
                                             key</termref> as each of the duplicates, but it is
                                          otherwise unconstrained: for example if the duplicate keys
                                          are <code>xs:byte(1)</code> and <code>xs:short(1)</code>,
                                          the key in the result could legitimately be
                                             <code>xs:long(1)</code>. </td>
                                    </tr>
                                    <tr>
                                       <td rowspan="1" colspan="1">
                                          <code>unspecified</code>
                                       </td>
                                       <td rowspan="1" colspan="1">If duplicate keys are present,
                                          all but one of a set of duplicates are ignored, and it is
                                             <termref def="dt-implementation-dependent"
                                             >implementation-dependent</termref> which one is
                                          retained. </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </item>
                        </olist>
                        <p>The result of the function call <code>map:merge($MAPS, $OPTIONS)</code>
                           is defined to be consistent with the result of the expression:</p>
                        <eg xml:space="preserve">
let $FOJS0003 := QName("http://www.w3.org/2005/xqt-errors", "FOJS0003"),

$duplicates-handler := map {
  "use-first":   function($a, $b) {$a},
  "use-last":    function($a, $b) {$b},
  "combine":     function($a, $b) {$a, $b},
  "reject":      function($a, $b) {fn:error($FOJS0003)},
  "unspecified": function($a, $b) {fn:random-number-generator()?permute(($a, $b))[1]}
},

$combine-maps := function($A as map(*), $B as map(*), $deduplicator as function(*)) {
    fn:fold-left(map:keys($B), $A, function($z, $k){ 
        if (map:contains($z, $k))
        then map:put($z, $k, $deduplicator($z($k), $B($k)))
        else map:put($z, $k, $B($k))
    })
}
return fn:fold-left($MAPS, map{}, 
    $combine-maps(?, ?, $duplicates-handler(($OPTIONS?duplicates, "use-first")[1]))
            
            </eg>
                        <note>
                           <p>By way of explanation, <code>$combine-maps</code> is a function that
                              combines two maps by iterating over the keys of the second map, adding
                              each key and its corresponding value to the first map as it proceeds.
                              The second call of <code>fn:fold-left</code> in the
                                 <code>return</code> clause then iterates over the maps supplied in
                              the call to <code>map:merge</code>, accumulating a single map that
                              absorbs successive maps in the input sequence by calling
                                 <code>$combine-maps</code>.</p>
                           <p>This algorithm processes the supplied maps in a defined order, but
                              processes the keys within each map in implementation-dependent
                              order.</p>
                           <p>The use of <code>fn:random-number-generator</code> represents one
                              possible conformant implementation for
                                 <code>"duplicates":"unspecified"</code>, but it is not the only
                              conformant implementation and is not necessarily a realistic
                              implementation.</p>
                        </note>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Error Conditions</label>
                     <def>
                        <p>An error is raised <xerrorref spec="FO31" class="JS" code="0003"/> if the
                           value of <code>$options</code> indicates that duplicates are to be
                           rejected, and a duplicate key is encountered.</p>
                        <p>An error is raised <xerrorref spec="FO31" class="JS" code="0005"/> if the
                           value of <code>$options</code> includes an entry whose key is defined in
                           this specification, and whose value is not a permitted value for that
                           key.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Notes</label>
                     <def>
                        <p role="note">If the input is an empty sequence, the result is an empty
                           map.</p>
                        <p role="note">If the input is a sequence of length one, the result map is
                              <phrase diff="chg" at="C">indistinguishable from the supplied
                              map</phrase>.</p>
                        <p role="note">There is no requirement that the supplied input maps should
                           have the same or compatible types. The type of a map (for example
                              <code>map(xs:integer, xs:string)</code>) is descriptive of the entries
                           it currently contains, but is not a constraint on how the map may be
                           combined with other maps.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Examples</label>
                     <def role="example">
                        <eg xml:space="preserve">let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag", 
     3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 
     6:"Samstag"}</eg>
                        <p>The expression <code>map:merge(())</code> returns <code>map{}</code>.
                              <emph>(Returns an empty map).</emph></p>
                        <p>The expression <code>map:merge((map:entry(0, "no"), map:entry(1,
                              "yes")))</code> returns <code>map{0:"no", 1:"yes"}</code>.
                              <emph>(Returns a map with two entries).</emph></p>
                        <p>The expression <code>map:merge(($week, map{7:"Unbekannt"}))</code>
                           returns <code>map{0:"Sonntag", 1:"Montag", 2:"Dienstag", 3:"Mittwoch",
                              4:"Donnerstag", 5:"Freitag", 6:"Samstag", 7:"Unbekannt"}</code>.
                              <emph>(The value of the existing map is unchanged; the <phrase
                                 diff="chg" at="C">returned map contains</phrase> all the entries
                              from <code>$week</code>, supplemented with an additional
                              entry.)</emph></p>
                        <p>The expression <code>map:merge(($week, map{6:"Sonnabend"}),
                              map{"duplicates":"use-last"})</code> returns <code>map{0:"Sonntag",
                              1:"Montag", 2:"Dienstag", 3:"Mittwoch", 4:"Donnerstag", 5:"Freitag",
                              6:"Sonnabend"}</code>. <emph>(The value of the existing map is
                              unchanged; the returned map contains all the entries from
                                 <code>$week</code>, with one entry replaced by a new entry. Both
                              input maps contain an entry with the key <code>6</code>; the one used
                              in the result is the one that comes last in the input
                              sequence.)</emph></p>
                        <p>The expression <code>map:merge(($week, map{6:"Sonnabend"}),
                              map{"duplicates":"use-first"})</code> returns <code>map{0:"Sonntag",
                              1:"Montag", 2:"Dienstag", 3:"Mittwoch", 4:"Donnerstag", 5:"Freitag",
                              6:"Samstag"}</code>. <emph>(The value of the existing map is
                              unchanged; the returned map contains all the entries from
                                 <code>$week</code>, with one entry replaced by a new entry. Both
                              input maps contain an entry with the key <code>6</code>; the one used
                              in the result is the one that comes first in the input
                              sequence.)</emph></p>
                        <p>The expression <code>map:merge(($week, map{6:"Sonnabend"}),
                              map{"duplicates":"combine"})</code> returns <code>map{0:"Sonntag",
                              1:"Montag", 2:"Dienstag", 3:"Mittwoch", 4:"Donnerstag", 5:"Freitag",
                              6:("Samstag", "Sonnabend")}</code>. <emph>(The value of the existing
                              map is unchanged; the returned map contains all the entries from
                                 <code>$week</code>, with one entry replaced by a new entry. Both
                              input maps contain an entry with the key <code>6</code>; the entry
                              that appears in the result is the sequence-concatenation of the
                              entries in the input maps, retaining order.)</emph></p>
                     </def>
                  </gitem>
               </glist>
            </div3>
            <div3 id="func-map-size">
               <head>map:size</head>
               <glist>
                  <gitem>
                     <label>Summary</label>
                     <def>
                        <p>Returns the number of entries in the supplied map.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Signature</label>
                     <def>
                        <example role="signature">
                           <proto name="size" return-type="xs:integer" isOp="no" prefix="map"
                              returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no"
                              isDatatype="no" isSpecial="no">
                              <arg name="map" type="map(*)"/>
                           </proto>
                        </example>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Properties</label>
                     <def>
                        <p>This function is <xtermref spec="FO30" ref="dt-deterministic"
                              >deterministic</xtermref>, <xtermref spec="FO30"
                              ref="dt-context-independent">context-independent</xtermref>, and
                              <xtermref spec="FO30" ref="dt-focus-independent"
                              >focus-independent</xtermref>. </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Rules</label>
                     <def>
                        <p>The function <code>map:size</code> takes any <termref def="dt-map"
                              >map</termref> as its <code>$map</code> argument and returns the
                           number of entries that are present in the map.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Examples</label>
                     <def role="example">
                        <p>The expression <code>map:size(map{})</code> returns <code>0</code>.</p>
                        <p>The expression <code>map:size(map{"true":1, "false":0})</code> returns
                              <code>2</code>.</p>
                     </def>
                  </gitem>
               </glist>
            </div3>
            <div3 id="func-map-keys">
               <head>map:keys</head>
               <glist>
                  <gitem>
                     <label>Summary</label>
                     <def>
                        <p>Returns a sequence containing all the keys present in a map</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Signature</label>
                     <def>
                        <example role="signature">
                           <proto name="keys" return-type="xs:anyAtomicType*" isOp="no" prefix="map"
                              returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no"
                              isDatatype="no" isSpecial="no">
                              <arg name="map" type="map(*)"/>
                           </proto>
                        </example>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Properties</label>
                     <def>
                        <p>This function is <xtermref spec="FO30" ref="dt-deterministic"
                              >deterministic</xtermref>, <xtermref spec="FO30"
                              ref="dt-context-independent">context-independent</xtermref>, and
                              <xtermref spec="FO30" ref="dt-focus-independent"
                              >focus-independent</xtermref>. </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Rules</label>
                     <def>
                        <p>The function <code>map:keys</code> takes any <termref def="dt-map"
                              >map</termref> as its <code>$map</code> argument and returns the keys
                           that are present in the map as a sequence of atomic values, in <termref
                              def="dt-implementation-dependent">implementation-dependent</termref>
                           order.</p>
                        <p diff="add" at="D">The function is <term>non-deterministic with respect to
                              ordering</term> (see <xspecref spec="FO31"
                              ref="properties-of-functions"/>). This means that two calls with the
                           same argument are not guaranteed to produce the results in the same
                           order.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Notes</label>
                     <def>
                        <p role="note">The number of items in the result will be the same as the
                           number of entries in the map, and the result sequence will contain no
                           duplicate values.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Examples</label>
                     <def role="example">
                        <p>The expression <code>map:keys(map{1:"yes", 2:"no"})</code> returns some
                           permutation of <code>(1,2)</code>. <emph>(The result is in <termref
                                 def="dt-implementation-dependent"
                                 >implementation-dependent</termref> order.)</emph></p>
                     </def>
                  </gitem>
               </glist>
            </div3>
            <div3 id="func-map-contains">
               <head>map:contains</head>
               <glist>
                  <gitem>
                     <label>Summary</label>
                     <def>
                        <p>Tests whether a supplied map contains an entry for a given key</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Signature</label>
                     <def>
                        <example role="signature">
                           <proto name="contains" return-type="xs:boolean" isOp="no" prefix="map"
                              returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no"
                              isDatatype="no" isSpecial="no">
                              <arg name="map" type="map(*)"/>
                              <arg name="key" type="xs:anyAtomicType"/>
                           </proto>
                        </example>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Properties</label>
                     <def>
                        <p>This function is <xtermref spec="FO30" ref="dt-deterministic"
                              >deterministic</xtermref>, <xtermref spec="FO30"
                              ref="dt-context-independent">context-independent</xtermref>, and
                              <xtermref spec="FO30" ref="dt-focus-independent"
                              >focus-independent</xtermref>. </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Rules</label>
                     <def>
                        <p>The function <code>map:contains</code> returns true if the <termref
                              def="dt-map">map</termref> supplied as <code>$map</code> contains an
                           entry with <phrase diff="chg" at="N">the <termref def="dt-same-key">same
                                 key</termref> as</phrase> the supplied value of <code>$key</code>;
                           otherwise it returns false.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Examples</label>
                     <def role="example">
                        <eg xml:space="preserve">let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag", 
    3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag"}</eg>
                        <p>The expression <code>map:contains($week, 2)</code> returns
                              <code>true()</code>.</p>
                        <p>The expression <code>map:contains($week, 9)</code> returns
                              <code>false()</code>.</p>
                        <p>The expression <code>map:contains(map{}, "xyz")</code> returns
                              <code>false()</code>.</p>
                        <p>The expression <code>map:contains(map{"xyz":23}, "xyz")</code> returns
                              <code>true()</code>.</p>
                        <p>The expression <code>map:contains(map{"abc":23, "xyz":()}, "xyz")</code>
                           returns <code>true()</code>.</p>
                     </def>
                  </gitem>
               </glist>
            </div3>
            <div3 id="func-map-get">
               <head>map:get</head>
               <glist>
                  <gitem>
                     <label>Summary</label>
                     <def>
                        <p>Returns the value associated with a supplied key in a given map.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Signature</label>
                     <def>
                        <example role="signature">
                           <proto name="get" return-type="item()*" isOp="no" prefix="map"
                              returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no"
                              isDatatype="no" isSpecial="no">
                              <arg name="map" type="map(*)"/>
                              <arg name="key" type="xs:anyAtomicType"/>
                           </proto>
                        </example>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Properties</label>
                     <def>
                        <p>This function is <xtermref spec="FO30" ref="dt-deterministic"
                              >deterministic</xtermref>, <xtermref spec="FO30"
                              ref="dt-context-independent">context-independent</xtermref>, and
                              <xtermref spec="FO30" ref="dt-focus-independent"
                              >focus-independent</xtermref>. </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Rules</label>
                     <def>
                        <p>The function <code>map:get</code> attempts to find an entry within the
                              <termref def="dt-map">map</termref> supplied as <code>$map</code> that
                           has <phrase diff="chg" at="N">the <termref def="dt-same-key">same
                                 key</termref> as</phrase> the supplied value of <code>$key</code>.
                           If there is such an entry, it returns the associated value; otherwise it
                           returns an empty sequence.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Notes</label>
                     <def>
                        <p role="note">A return value of <code>()</code> from <code>map:get</code>
                           could indicate that the key is present in the map with an associated
                           value of <code>()</code>, or it could indicate that the key is not
                           present in the map. The two cases can be distinguished by calling
                              <code>map:contains</code>.</p>
                        <p role="note">Invoking the <termref def="dt-map">map</termref> as a
                           function item has the same effect as calling <code>get</code>: that is,
                           when <code>$map</code> is a map, the expression <code>$map($K)</code> is
                           equivalent to <code>map:get($map, $K)</code>. Similarly, the expression
                              <code>map:get(map:get(map:get($map, 'employee'), 'name'),
                              'first')</code> can be written as
                              <code>$map('employee')('name')('first')</code>. </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Examples</label>
                     <def role="example">
                        <eg xml:space="preserve">let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag", 
     3:"Mittwoch", 4:"Donnerstag", 5:"Freitag",  
     6:"Samstag"}</eg>
                        <p>The expression <code>map:get($week, 4)</code> returns
                              <code>"Donnerstag"</code>.</p>
                        <p>The expression <code>map:get($week, 9)</code> returns <code>()</code>.
                              <emph>(When the key is not present, the function returns an empty
                              sequence.)</emph></p>
                        <p>The expression <code>map:get(map:entry(7,()), 7)</code> returns
                              <code>()</code>. <emph>(An empty sequence as the result can also
                              signify that the key is present and the associated value is an empty
                              sequence.)</emph></p>
                     </def>
                  </gitem>
               </glist>
            </div3>
            <div3 id="func-map-put">
               <head>map:put</head>
               <glist>
                  <gitem>
                     <label>Summary</label>
                     <def>
                        <p>Returns a map containing all the contents of the supplied map, but with
                           an additional entry, which replaces any existing entry for the same
                           key.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Signature</label>
                     <def>
                        <example role="signature">
                           <proto name="put" return-type="map(*)" isOp="no" prefix="map"
                              returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no"
                              isDatatype="no" isSpecial="no">
                              <arg name="map" type="map(*)"/>
                              <arg name="key" type="xs:anyAtomicType"/>
                              <arg name="value" type="item()*"/>
                           </proto>
                        </example>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Properties</label>
                     <def>
                        <p>This function is <xtermref spec="FO30" ref="dt-deterministic"
                              >deterministic</xtermref>, <xtermref spec="FO30"
                              ref="dt-context-independent">context-independent</xtermref>, and
                              <xtermref spec="FO30" ref="dt-focus-independent"
                              >focus-independent</xtermref>. </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Rules</label>
                     <def>
                        <p>The function <code>map:put</code> returns <phrase diff="chg" at="C">a
                                 <termref def="dt-map">map</termref> that</phrase> contains all
                           entries from the supplied <code>$map</code>, with the exception of any
                           entry whose key is the <termref def="dt-same-key">same key</termref> as
                              <code>$key</code>, together with a new entry whose key is
                              <code>$key</code> and whose associated value is
                           <code>$value</code>.</p>
                        <p>The effect of the function call <code>map:put($MAP, $KEY, $VALUE)</code>
                           is equivalent to the result of the following steps:</p>
                        <olist>
                           <item>
                              <p><code>let $MAP2 := map:remove($MAP, $KEY)</code></p>
                              <p>This returns a map in which all entries with the same key as
                                    <code>$KEY</code> have been removed.</p>
                           </item>
                           <item>
                              <p>Construct and return a map containing:</p>
                              <olist>
                                 <item>
                                    <p>All the entries (key/value pairs) in <code>$MAP2</code>,
                                       and</p>
                                 </item>
                                 <item>
                                    <p>The entry <code>map:entry($KEY, $VALUE)</code></p>
                                 </item>
                              </olist>
                           </item>
                        </olist>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Notes</label>
                     <def>
                        <p role="note">There is no requirement that the type of <code>$key</code>
                           and <code>$value</code> be consistent with the types of any existing keys
                           and values in the supplied map.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Examples</label>
                     <def role="example">
                        <eg xml:space="preserve">let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag", 
     3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 
     6:"Samstag"}</eg>
                        <p>The expression <code>map:put($week, 6, "Sonnabend")</code> returns
                              <code>map{0:"Sonntag", 1:"Montag", 2:"Dienstag", 3:"Mittwoch",
                              4:"Donnerstag", 5:"Freitag", 6:"Sonnabend"}</code>.</p>
                        <p>The expression <code>map:put($week, -1, "Unbekannt")</code> returns
                              <code>map{0:"Sonntag", 1:"Montag", 2:"Dienstag", 3:"Mittwoch",
                              4:"Donnerstag", 5:"Freitag", 6:"Samstag", -1:"Unbekannt"}</code>.</p>
                     </def>
                  </gitem>
               </glist>
            </div3>
            <div3 id="func-map-entry">
               <head>map:entry</head>
               <glist>
                  <gitem>
                     <label>Summary</label>
                     <def>
                        <p><phrase diff="chg" at="C">Returns</phrase> a map that contains a single
                           entry (a key-value pair).</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Signature</label>
                     <def>
                        <example role="signature">
                           <proto name="entry" return-type="map(*)" isOp="no" prefix="map"
                              returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no"
                              isDatatype="no" isSpecial="no">
                              <arg name="key" type="xs:anyAtomicType"/>
                              <arg name="value" type="item()*"/>
                           </proto>
                        </example>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Properties</label>
                     <def>
                        <p>This function is <xtermref spec="FO30" ref="dt-deterministic"
                              >deterministic</xtermref>, <xtermref spec="FO30"
                              ref="dt-context-independent">context-independent</xtermref>, and
                              <xtermref spec="FO30" ref="dt-focus-independent"
                              >focus-independent</xtermref>. </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Rules</label>
                     <def>
                        <p>The function <code>map:entry</code> returns a <termref def="dt-map"
                              >map</termref> which <phrase diff="del" at="P">normally</phrase>
                           contains a single entry. <phrase diff="del" at="N">The collation of the
                              new map is the default collation from the static context. </phrase>The
                           key of the entry in the new map is <code>$key</code>, and its associated
                           value is <code>$value</code>.</p>
                        <p diff="del" at="N">If the supplied key is the <code>xs:float</code> or
                              <code>xs:double</code> value <code>NaN</code>, the supplied
                              <code>$map</code> is empty (that is, it contains no entries).</p>
                        <p diff="del" at="N">If the supplied key is <code>xs:untypedAtomic</code>,
                           it is converted to <code>xs:string</code>.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Notes</label>
                     <def>
                        <p role="note">The function <code>map:entry</code> is intended primarily for
                           use in conjunction with the function <code>map:merge</code>. For example,
                           a map containing seven entries may be constructed like this:</p>
                        <eg role="note" xml:space="preserve">
map:merge((
   map:entry("Su", "Sunday"),
   map:entry("Mo", "Monday"),
   map:entry("Tu", "Tuesday"),
   map:entry("We", "Wednesday"),
   map:entry("Th", "Thursday"),
   map:entry("Fr", "Friday"),
   map:entry("Sa", "Saturday")
   ))</eg>
                        <p role="note">Unlike the map expression (<code>map{...}</code>), this
                           technique can be used to construct a map with a variable number of
                           entries, for example:</p>
                        <eg role="note" xml:space="preserve">
map:merge(for $b in //book return map:entry($b/isbn, $b))</eg>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Examples</label>
                     <def role="example">
                        <p>The expression <code>map:entry("M", "Monday")</code> returns
                              <code>{"M":"Monday"}</code>.</p>
                     </def>
                  </gitem>
               </glist>
            </div3>
            <div3 id="func-map-remove">
               <head>map:remove</head>
               <glist>
                  <gitem>
                     <label>Summary</label>
                     <def>
                        <p>Returns a map containing all the entries from a supplied map, except
                              <phrase diff="chg" at="T-bug29660">those having a specified
                              key</phrase>.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Signature</label>
                     <def>
                        <example role="signature">
                           <proto name="remove" return-type="map(*)" isOp="no" prefix="map"
                              returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no"
                              isDatatype="no" isSpecial="no">
                              <arg name="map" type="map(*)"/>
                              <arg name="keys" type="xs:anyAtomicType*"/>
                           </proto>
                        </example>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Properties</label>
                     <def>
                        <p>This function is <xtermref spec="FO30" ref="dt-deterministic"
                              >deterministic</xtermref>, <xtermref spec="FO30"
                              ref="dt-context-independent">context-independent</xtermref>, and
                              <xtermref spec="FO30" ref="dt-focus-independent"
                              >focus-independent</xtermref>. </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Rules</label>
                     <def>
                        <p>The function <code>map:remove</code> returns a <termref def="dt-map"
                              >map</termref> containing all the entries in <code>$map</code> except
                           for any entry whose key is the <termref def="dt-same-key">same
                              key</termref> as <phrase diff="chg" at="T-bug29660">an item
                              in</phrase>
                           <code>$keys</code>.</p>
                        <p>No failure occurs <phrase diff="chg" at="T-bug29660">if an item in
                                 <code>$keys</code> does not correspond to any entry in
                                 <code>$map</code>; that key value is simply ignored</phrase>.</p>
                        <p>The effect of the function call <code>map:remove($MAP, $KEY)</code> can
                           be described more formally as the result of the expression below:</p>
                        <eg diff="chg" at="T-bug29660" xml:space="preserve">
map:merge (
    map:for-each (
       $MAP, function($k, $v) { 
               if (some $key in $KEY satisfies op:same-key($k, $key)) 
               then () 
               else map:entry($k, $v)
             } ) ) </eg>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Examples</label>
                     <def role="example">
                        <eg xml:space="preserve">let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag",
     3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag"}</eg>
                        <p>The expression <code>map:remove($week, 4)</code> returns
                              <code>map{0:"Sonntag", 1:"Montag", 2:"Dienstag", 3:"Mittwoch",
                              5:"Freitag", 6:"Samstag"}</code>.</p>
                        <p>The expression <code>map:remove($week, 23)</code> returns
                              <code>map{0:"Sonntag", 1:"Montag", 2:"Dienstag", 3:"Mittwoch",
                              4:"Donnerstag", 5:"Freitag", 6:"Samstag"}</code>.</p>
                        <p>The expression <code>map:remove($week, (0, 6 to 7))</code> returns
                              <code>map{1:"Montag", 2:"Dienstag", 3:"Mittwoch", 4:"Donnerstag",
                              5:"Freitag"}</code>.</p>
                        <p>The expression <code>map:remove($week, ())</code> returns
                              <code>&gt;map{0:"Sonntag", 1:"Montag", 2:"Dienstag", 3:"Mittwoch",
                              4:"Donnerstag", 5:"Freitag", 6:"Samstag"}</code>.</p>
                     </def>
                  </gitem>
               </glist>
            </div3>
            <div3 id="func-map-for-each">
               <head>map:for-each</head>
               <glist>
                  <gitem>
                     <label>Summary</label>
                     <def>
                        <p>Applies a supplied function to every entry in a map, returning the
                           concatenation of the results.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Signature</label>
                     <def>
                        <example role="signature">
                           <proto name="for-each" return-type="item()*" isOp="no" prefix="map"
                              returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no"
                              isDatatype="no" isSpecial="no">
                              <arg name="map" type="map(*)"/>
                              <arg name="action"
                                 type="function(xs:anyAtomicType, item()*) as item()*"/>
                           </proto>
                        </example>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Properties</label>
                     <def>
                        <p>This function is <xtermref spec="FO30" ref="dt-deterministic"
                              >deterministic</xtermref>, <xtermref spec="FO30"
                              ref="dt-context-independent">context-independent</xtermref>, and
                              <xtermref spec="FO30" ref="dt-focus-independent"
                              >focus-independent</xtermref>. </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Rules</label>
                     <def>
                        <p>The function <code>map:for-each</code> takes any <termref def="dt-map"
                              >map</termref> as its <code>$map</code> argument and applies the
                           supplied function to each entry in the map, in <termref
                              def="dt-implementation-dependent">implementation-dependent</termref>
                           order; the result is the sequence obtained by concatenating the results
                           of these function calls.</p>
                        <p diff="add" at="D">The function is <term>non-deterministic with respect to
                              ordering</term> (see <xspecref spec="FO31"
                              ref="properties-of-functions"/>). This means that two calls with the
                           same arguments are not guaranteed to process the map entries in the same
                           order.</p>
                        <p>The function supplied as <code>$action</code> takes two arguments. It is
                           called supplying the key of the map entry as the first argument, and the
                           associated value as the second argument.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Examples</label>
                     <def role="example">
                        <p>The expression <code>map:for-each(map{1:"yes", 2:"no"}, function($k,
                              $v){$k})</code> returns some permutation of <code>(1,2)</code>.
                              <emph>(This function call is equivalent to calling
                                 <code>map:keys</code>. The result is in implementation-dependent
                              order.)</emph></p>
                        <p>The expression <code>distinct-values(map:for-each(map{1:"yes", 2:"no"},
                              function($k, $v){$v}))</code> returns some permutation of
                              <code>("yes", "no")</code>. <emph>(This function call returns the
                              distinct values present in the map, in implementation-dependent
                              order.)</emph></p>
                        <p>The expression <code>map:merge(map:for-each(map{"a":1, "b":2},
                              function($k, $v){map:entry($k, $v+1)}))</code> returns
                              <code>map{"a":2, "b":3}</code>. <emph>(This function call returns a
                              map with the same keys as the input map, with the value of each entry
                              increased by one.)</emph></p>
                        <example>
                           <head>Converting a Map to an Element Node</head>
                           <p>This XQuery example converts the entries in a map to attributes on a
                              newly constructed element node.</p>
                           <eg xml:space="preserve">
let
  $dimensions := map{'height': 3, 'width': 4, 'depth': 5};
return
  &lt;box&gt;{
     map:for-each($dimensions, function ($k, $v) { attribute {$k} {$v} })
  }&lt;/box&gt;</eg>
                           <p>The result is the element <code>&lt;box height="3" width="4"
                                 depth="5"/&gt;</code>.</p>
                        </example>
                     </def>
                  </gitem>
               </glist>
            </div3>
            <div3 id="func-map-find" diff="add" at="T-bug29783">
               <head>map:find</head>
               <glist>
                  <gitem>
                     <label>Summary</label>
                     <def>
                        <p>Searches the supplied input sequence and any contained maps and arrays
                           for a map entry with the supplied key, and returns the corresponding
                           values.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Signature</label>
                     <def>
                        <example role="signature">
                           <proto name="find" return-type="array(*)" isOp="no" prefix="map"
                              returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no"
                              isDatatype="no" isSpecial="no">
                              <arg name="input" type="item()*"/>
                              <arg name="key" type="xs:anyAtomicType"/>
                           </proto>
                        </example>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Properties</label>
                     <def>
                        <p>This function is <xtermref spec="FO30" ref="dt-deterministic"
                              >deterministic</xtermref>, <xtermref spec="FO30"
                              ref="dt-context-independent">context-independent</xtermref>, and
                              <xtermref spec="FO30" ref="dt-focus-independent"
                              >focus-independent</xtermref>. </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Rules</label>
                     <def>
                        <p>The function <code>map:find</code> searches the sequence supplied as
                              <code>$input</code> looking for map entries whose key is the <termref
                              def="dt-same-key">same key</termref> as <code>$key</code>. The
                           associated value in any such map entry (each being in general a sequence)
                           is returned as a member of the result array.</p>
                        <p>The search processes the <code>$input</code> sequence using the following
                           recursively-defined rules (any equivalent algorithm may be used provided
                           it delivers the same result, respecting those rules that constrain the
                           order of the result):</p>
                        <olist>
                           <item>
                              <p>To process a sequence, process each of its items in order.</p>
                           </item>
                           <item>
                              <p>To process an item that is an array, process each of the array's
                                 members in order (each member is, in general, a sequence).</p>
                           </item>
                           <item>
                              <p>To process an item that is a map, then for each key-value entry
                                    (<var>K</var>, <var>V</var>) in the map (in <termref
                                    def="dt-implementation-dependent"
                                    >implementation-dependent</termref> order) perform both of the
                                 following steps, in order:</p>
                              <olist>
                                 <item>
                                    <p>If <var>K</var> is the <termref def="dt-same-key">same
                                          key</termref> as <code>$key</code>, then add <var>V</var>
                                       as a new member to the end of the result array.</p>
                                 </item>
                                 <item>
                                    <p>Process <var>V</var> (which is, in general, a sequence).</p>
                                 </item>
                              </olist>
                           </item>
                           <item>
                              <p>To process an item that is neither a map nor an array, do nothing.
                                 (Such items are ignored).</p>
                           </item>
                        </olist>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Notes</label>
                     <def>
                        <p role="note">If <code>$input</code> is an empty sequence, map, or array,
                           or if the requested <code>$key</code> is not found, the result will be a
                           zero-length array.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Examples</label>
                     <def role="example">
                        <eg xml:space="preserve">let $responses := [map{0:'no', 1:'yes'},   
     map{0:'non', 1:'oui'},   
     map{0:'nein', 1:('ja', 'doch')}]</eg>
                        <p>The expression <code>map:find($responses, 0)</code> returns <code>['no',
                              'non', 'nein']</code>.</p>
                        <p>The expression <code>map:find($responses, 1)</code> returns <code>['yes',
                              'oui', ('ja', 'doch')]</code>.</p>
                        <p>The expression <code>map:find($responses, 2)</code> returns
                              <code>[]</code>.</p>
                        <eg xml:space="preserve">let $inventory := map{"name":"car", "id":"QZ123",   
     "parts": [map{name":"engine", "id":"YW678", "parts":[]}]}</eg>
                        <p>The expression <code>map:find($inventory, "parts")</code> returns
                              <code>[[map{name":"engine", "id":"YW678", "parts":[]}],
                           []]</code>.</p>
                     </def>
                  </gitem>
               </glist>
            </div3>
            <div3 id="func-collation-key">
               <head>fn:collation-key</head>
               <glist>
                  <gitem>
                     <label>Summary</label>
                     <def>
                        <p diff="chg" at="B-bug25446">Given a string value and a collation,
                           generates an internal value called a collation key, with the property
                           that the matching and ordering of collation keys reflects the matching
                           and ordering of strings under the specified collation.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Signatures</label>
                     <def>
                        <example role="signature">
                           <proto name="collation-key" return-type="xs:base64Binary" isOp="no"
                              prefix="fn" returnEmptyOk="no" returnSeq="no" returnVaries="no"
                              isSchema="no" isDatatype="no" isSpecial="no">
                              <arg name="key" type="xs:string"/>
                           </proto>
                        </example>
                        <example role="signature">
                           <proto name="collation-key" return-type="xs:base64Binary" isOp="no"
                              prefix="fn" returnEmptyOk="no" returnSeq="no" returnVaries="no"
                              isSchema="no" isDatatype="no" isSpecial="no">
                              <arg name="key" type="xs:string"/>
                              <arg name="collation" type="xs:string"/>
                           </proto>
                        </example>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Properties</label>
                     <def>
                        <p>This function is <xtermref spec="FO30" ref="dt-deterministic"
                              >deterministic</xtermref>, <xtermref spec="FO30"
                              ref="dt-context-dependent">context-dependent</xtermref>, and <xtermref
                              spec="FO30" ref="dt-focus-independent">focus-independent</xtermref>.
                           It depends on collations. </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Rules</label>
                     <def>
                        <p>Calling the one-argument version of this function is equivalent to
                           calling the two-argument version supplying the default collation as the
                           second argument.</p>
                        <p>The function returns an <phrase diff="add" at="B-bug25446"><termref
                                 def="dt-implementation-dependent"
                                 >implementation-dependent</termref></phrase> value with the
                           property that, for any two strings <code>$K1</code> and
                           <code>$K2</code>:</p>
                        <ulist>
                           <item>
                              <p><code>collation-key($K1, $C) eq collation-key($K2, $C)</code> if
                                 and only if <code>compare($K1, $K2, $C) eq 0</code></p>
                           </item>
                           <item diff="add" at="B-bug25446">
                              <p><code>collation-key($K1, $C) lt collation-key($K2, $C)</code> if
                                 and only if <code>compare($K1, $K2, $C) lt 0</code></p>
                           </item>
                        </ulist>
                        <p>The collation used by this function is determined in the same way as for
                           other functions accepting a collation URI argument. <phrase diff="add"
                              at="T-bug29853">Collation keys are defined as
                                 <code>xs:base64Binary</code> values to ensure unambiguous and
                              context-free comparison semantics.</phrase></p>
                        <p>An implementation is free to generate a collation key in any convenient
                           way provided that it always generates the same collation key for two
                           strings that are equal under the collation, and different collation keys
                           for strings that are not equal. This holds only within a single <xtermref
                              spec="FO30" ref="execution-scope">execution scope</xtermref>; an
                           implementation is under no obligation to generate the same collation keys
                           during a subsequent unrelated query or transformation.</p>
                        <p>It is possible to define collations that do not have the ability to
                           generate collation keys. Supplying such a collation will cause the
                           function to fail. The ability to generate collation keys is an <termref
                              def="dt-implementation-defined">implementation-defined</termref>
                           property of the collation.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Error Conditions</label>
                     <def>
                        <p>An error is raised <xerrorref spec="FO31" class="CH" code="0004"/> if the
                           specified collation does not support the generation of collation keys.
                        </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Notes</label>
                     <def>
                        <p role="note">The function is provided primarily for use with maps. If a
                           map is required where codepoint equality is inappropriate for comparing
                           keys, then a common technique is to normalize the key so that equality
                           matching becomes feasible. There are many ways keys can be normalized,
                           for example by use of functions such as <code>fn:upper-case</code>,
                              <code>fn:lower-case</code>, <code>fn:normalize-space</code>, or
                              <code>fn:normalize-unicode</code>, but this function provides a way of
                           normalizing them according to the rules of a specified collation. For
                           example, if the collation ignores accents, then the function will
                           generate the same collation key for two input strings that differ only in
                           their use of accents.</p>
                        <p role="note">The result of the function is defined to be an
                              <code>xs:base64Binary</code> value. Binary values are chosen because
                           they have unambiguous and context-free comparison semantics, because the
                           value space is unbounded, and because the ordering rules are such that
                           between any two values in the ordered value space, an arbitrary number of
                           further values can be interpolated. The choice between
                              <code>xs:base64Binary</code> and <code>xs:hexBinary</code> is
                           arbitrary; the only operation that behaves differently between the two
                           binary data types is conversion to/from a string, and this operation is
                           not one that is normally required for effective use of collation keys. </p>
                        <p role="note">For collations based on the Unicode Collation Algorithm, an
                           algorithm for computing collation keys is provided in <bibref
                              ref="UNICODE-TR10"/>. Implementations are <rfc2119>not
                              required</rfc2119> to use this algorithm.</p>
                        <p role="note">This specification does not mandate that collation keys
                           should retain ordering. This is partly because the primary use case is
                           for maps, where only equality comparisons are required, and partly to
                           allow the use of binary data types (which are currently unordered types)
                           for the result. The specification may be revised in a future release to
                           specify that ordering is preserved.</p>
                        <p role="note">The fact that collation keys are ordered can be exploited in
                           XQuery, whose <code>order by</code> clause does not allow the collation
                           to be selected dynamically. This restriction can be circumvented by
                           rewriting the clause <code>order by $e/@key collation "URI"</code> as
                              <code>order by fn:collation-key($e/@key, $collation)</code>, where
                              <code>$collation</code> allows the collation to be chosen
                           dynamically.</p>
                        <p role="note">Note that <code>xs:base64Binary</code> becomes an ordered
                           type in XPath 3.1, making binary collation keys possible. In an
                           implementation that adheres strictly to XPath 3.0, collation keys can be
                           used only for equality matching, not for ordering operations.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Examples</label>
                     <def role="example">
                        <eg xml:space="preserve">let $C := 'http://www.w3.org/2013/collation/UCA?strength=primary'</eg>
                        <p>The expression <code>map:merge((map{collation-key("A", $C):1},
                              map{collation-key("a", $C):2}),
                              map{"duplicates":"use-last"})(collation-key("A", $C))</code> returns
                              <code>2</code>. <emph>(Given that the keys of the two entries are
                              equal under the rules of the chosen collation, only one of the entries
                              can appear in the result; the one that is chosen is the one from the
                              last map in the input sequence.)</emph></p>
                        <p>The expression <code>let $M := map{collation-key("A", $C):1,
                              collation-key("B", $C):2} return $M(collation-key("a", $C))</code>
                           returns <code>1</code>. <emph>(The strings "A" and "a" have the same
                              collation key under this collation.)</emph></p>
                        <p>As the above examples illustrate, it is important that when the
                              <code>collation-key</code> function is used to add entries to a map,
                           then it must also be used when retrieving entries from the map. This
                           process can be made less error-prone by encapsulating the map within a
                           function: <code>function($k) {$M(collation-key($k,
                           $collation)}</code>.</p>
                     </def>
                  </gitem>
               </glist>
            </div3>
            <div3 id="func-deep-equal">
               <head><code>fn:deep-equal</code></head>
               <p>The <xfunction>deep-equal</xfunction> function, when used with XSLT 3.0, is
                  defined to handle maps in the way that is defined in the <bibref
                     ref="xpath-functions-31"/> specification of the function.</p>
               <p>Specifically, two maps are deep-equal if they have the same number of entries, and
                  if there is a one-to-one correspondence in the sense that for every entry
                     <var>E1</var>in the first map, there is a corresponding entry <var>E2</var> in
                  the second map, such that the keys of <var>E1</var> and <var>E2</var> are equal
                  under the <code>op:same-key</code> relation (see <specref ref="func-same-key"/>),
                  and the corresponding values are equal under the <function>deep-equal</function>
                  relation, invoked recursively using the collation supplied as argument to the
                  original <code>deep-equal</code> call, or its default. Note that collations are
                  not used for comparing keys.</p>
            </div3>
         </div2>
         <div2 id="map-instructions" diff="add" at="M">
            <head>Map Instructions</head>
            <p>Two instructions are added to XSLT to facilitate the construction of maps.</p>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="map">
               <e:in-category name="instruction"/>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The instruction <elcode>xsl:map</elcode> constructs and returns a new map.</p>
            <p diff="del" at="P-bug22932">The <code>collation</code> attribute, if present, defines
               the collation of the map. If omitted, the map uses the default collation from the
               static context. Call this collation <var>C</var>.</p>
            <p>The contained sequence constructor <rfc2119>must</rfc2119> evaluate to a sequence of
               maps: call this <code>$maps</code>.</p>
            <p diff="add" at="P-bug22761">The result of the instruction (other than the choice of
               error code) is then given by the XPath 3.1 expression:</p>
            <eg diff="add" at="T-bug29723" role="non-xml" xml:space="preserve">   
map:merge($maps, map{"duplicates":"reject"}) </eg>
            <note>
               <p diff="add" at="P-bug22761">Informally: if there are duplicate keys among the
                  sequence of maps, a dynamic error occurs. Otherwise, the resulting map contains
                  the union of the map entries from the supplied sequence of maps.</p>
            </note>
            <p diff="add" at="P-bug22761"><error spec="XT" class="DE" code="3365" type="dynamic"
                     ><p>A <termref def="dt-dynamic-error">dynamic error</termref> occurs if the set
                     of keys in the maps resulting from evaluating the sequence constructor
                        <error.extra>within an <elcode>xsl:map</elcode> instruction</error.extra>
                     contains duplicates.</p></error></p>
            <p>There is no requirement that the supplied input maps should have the same or
               compatible types. The type of a map (for example <code>map(xs:integer,
                  xs:string)</code>) is descriptive of the entries it currently contains, but is not
               a constraint on how the map may be combined with other maps.</p>
            <p diff="chg" at="P-bug22932"><error spec="XT" class="TE" code="3375" type="type"><p>A
                     type error occurs if the result of evaluating the sequence constructor
                        <error.extra>within an <elcode>xsl:map</elcode> instruction</error.extra> is
                     not an instance of the required type <code>map(*)*</code>.</p></error></p>
            <note>
               <p diff="add" at="P">In practice, the effect of this rule is that the sequence
                  constructor contained in the <elcode>xsl:map</elcode> instruction is severely
                  constrained: it doesn’t make sense, for example, for it to contain instructions
                  such as <elcode>xsl:element</elcode> that create new nodes. As with other type
                  errors, processors are free to signal the error statically if they are able to
                  determine that the sequence constructor would always fail when evaluated.</p>
            </note>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="map-entry">
               <e:in-category name="instruction"/>
               <e:attribute name="key" required="yes">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="select">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The instruction <elcode>xsl:map-entry</elcode> constructs and returns a singleton
               map: that is, a map which <phrase diff="del" at="P">normally</phrase> contains one
               key and one value. Such a map is primarily used as a building block when constructing
               maps using the <elcode>xsl:map</elcode> instruction.</p>
            <p>The <code>select</code> attribute and the contained sequence constructor are mutually
               exclusive: if a <code>select</code> attribute is present, then the content
                  <rfc2119>must</rfc2119> be empty except optionally for
                  <elcode>xsl:fallback</elcode> instructions.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="3280"><p>It is a <termref
                        def="dt-static-error">static error</termref> if the <code>select</code>
                     attribute of the <elcode>xsl:map-entry</elcode> element is present unless the
                     element has no children other than <elcode>xsl:fallback</elcode>
                  elements.</p></error>
            </p>
            <p diff="del" at="P-bug22932">The collation of the new map is the default collation from
               the static context.</p>
            <p>The key of the entry in the new map is the value obtained by evaluating the
               expression in the <code>key</code> attribute, converted to the required type
                  <code>xs:anyAtomicType</code> by applying the <termref
                  def="dt-function-conversion-rules"/>. If the supplied key (after conversion) is of
               type <code>xs:untypedAtomic</code>, it is cast to <code>xs:string</code>.</p>
            <p>The associated value is the value obtained by evaluating the expression in the
                  <code>select</code> attribute, or the contained sequence constructor, with no
               conversion. If there is no <code>select</code> attribute and the sequence constructor
               is empty, the associated value is the empty sequence.</p>
            <p diff="del" at="P">If the supplied key is the <code>xs:float</code> or
                  <code>xs:double</code> value <code>NaN</code>, then the constructed map is empty
               (that is, it contains no entries).</p>
            <example>
               <head>Using XSLT instructions to create a fixed map</head>
               <p>The following example binds a variable to a map whose content is statically
                  known:</p>
               <eg role="xslt-declaration" xml:space="preserve">
&lt;xsl:variable name="week" as="map(xs:string, xs:string)"&gt;
  &lt;xsl:map&gt;
    &lt;xsl:map-entry key="'Mo'" select="'Monday'"/&gt;
    &lt;xsl:map-entry key="'Tu'" select="'Tuesday'"/&gt;
    &lt;xsl:map-entry key="'We'" select="'Wednesday'"/&gt;
    &lt;xsl:map-entry key="'Th'" select="'Thursday'"/&gt;
    &lt;xsl:map-entry key="'Fr'" select="'Friday'"/&gt;
    &lt;xsl:map-entry key="'Sa'" select="'Saturday'"/&gt;
    &lt;xsl:map-entry key="'Su'" select="'Sunday'"/&gt;
  &lt;/xsl:map&gt;
&lt;/xsl:variable&gt;  
</eg>
            </example>
            <example>
               <head>Using XSLT instructions to create a computed map</head>
               <p>The following example binds a variable to a map acting as an index into a source
                  document:</p>
               <eg role="xslt-declaration" xml:space="preserve">
&lt;xsl:variable name="index" as="map(xs:string, element(employee))"&gt;
  &lt;xsl:map&gt;
    &lt;xsl:for-each select="//employee"&gt;
      &lt;xsl:map-entry key="@empNr" select="."/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:map&gt;
&lt;/xsl:variable&gt;  
</eg>
            </example>
         </div2>
         <div2 id="map-constructors">
            <head>Map Constructors</head>
            <p>A Map Constructor is a new kind of expression added to the syntax of XPath.</p>
            <note diff="add" at="S-bug28937">
               <p>Map Constructors are defined in XPath 3.1. They are available in XSLT 3.0 whether
                  or not XPath 3.1 is supported. The specification given here is intended to be
                  identical to the specification in XPath 3.1.</p>
            </note>
            <p>The syntax of <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                  ref="doc-xpath30-PrimaryExpr" xlink:type="simple">PrimaryExpr</xnt> is extended to
               permit <code>MapConstructor</code> as an additional alternative.</p>
            <scrap headstyle="show" diff="chg" at="S-bug27026" id="MapConstructor-scrap">
               <head>MapConstructor</head>
               <prodgroup>
                  <prod num="52" id="NT-PrimaryExpr">
                     <lhs>PrimaryExpr</lhs>
                     <rhs>Literal | VarRef | ParenthesizedExpr | ContextItemExpr | FunctionCall |
                        FunctionItemExpr<br/> | MapConstructor</rhs>
                  </prod>
                  <prod num="202" id="NT-MapConstructor">
                     <lhs>MapConstructor</lhs>
                     <rhs>"map" "{" (MapConstructorEntry ("," MapConstructorEntry )*)? "}" </rhs>
                  </prod>
                  <prod num="203" id="NT-MapConstructorEntry">
                     <lhs>MapConstructorEntry</lhs>
                     <rhs>MapKeyExpr ":" MapValueExpr </rhs>
                  </prod>
                  <prod num="204" id="NT-MapKeyExpr">
                     <lhs>MapKeyExpr</lhs>
                     <rhs><xnt xmlns:xlink="http://www.w3.org/1999/xlink"
                           ref="doc-xpath30-ExprSingle" spec="XP30" xlink:type="simple"
                           >ExprSingle</xnt></rhs>
                  </prod>
                  <prod num="205" id="NT-MapValueExpr">
                     <lhs>MapValueExpr</lhs>
                     <rhs><xnt xmlns:xlink="http://www.w3.org/1999/xlink"
                           ref="doc-xpath30-ExprSingle" spec="XP30" xlink:type="simple"
                           >ExprSingle</xnt></rhs>
                  </prod>
               </prodgroup>
            </scrap>
            <note>
               <p diff="chg" at="N">In some circumstances, it is necessary to include whitespace
                  before or after the colon to ensure that this grammar is correctly parsed; this
                  arises for example when the <code>KeyExpr</code> ends with a name and the
                     <code>ValueExpr</code> starts with a name. </p>
            </note>
            <p>The value of the expression is a map whose entries correspond to the key-value pairs
               obtained by evaluating the successive <code>KeyExpr</code> and <code>ValueExpr</code>
               expressions.</p>
            <p>Each <code>KeyExpr</code> expression is evaluated and atomized; a <phrase diff="chg"
                  at="R-bug25000">type error <xerrorref spec="XP30" class="TY" code="0004"
                  /></phrase> occurs if the result is not a single atomic value. If the key is of
               type <code>xs:untypedAtomic</code> it is converted to <code>xs:string</code>. The
               associated value is the result of evaluating the corresponding
                  <code>ValueExpr</code>.<phrase diff="del" at="P-bug22932"> The collation of the
                  new map is the default collation from the static context. </phrase><phrase
                  diff="del" at="P">If the key is <code>NaN</code> then the key/value pair is not
                  added to the map.</phrase> If two or more entries have the <phrase diff="chg"
                  at="P"><termref def="dt-same-key">same key</termref></phrase> then <phrase
                  diff="del" at="P-bug22761">the last occurrence is added to the map and the others
                  are ignored.</phrase>
               <phrase diff="add" at="P-bug22761">a dynamic error occurs <errorref spec="XT"
                     class="DE" code="3365"/></phrase>.</p>
            <p>For example, the following expression constructs a map with seven entries:</p>
            <eg role="non-xml" xml:space="preserve">
map {
  "Su" : "Sunday",
  "Mo" : "Monday",
  "Tu" : "Tuesday",
  "We" : "Wednesday",
  "Th" : "Thursday",
  "Fr" : "Friday",
  "Sa" : "Saturday"
}</eg>
            <note>
               <p>Unlike the <function>map:merge</function> function, the number of entries in a map
                  that is constructed using a map expression is known statically<phrase diff="del"
                     at="P">, except where duplicate keys or NaN values cause some entries to be
                     ignored</phrase>.</p>
            </note>
         </div2>
         <div2 id="map-lookup-operator" diff="add" at="S-bug28937">
            <head>The Map Lookup Operator</head>
            <p>A new operator is introduced into XPath to allow convenient lookup of entries in a
               map (or a sequence of maps), knowing the key.</p>
            <note>
               <p>Map Lookup Expressions are defined in XPath 3.1. They are available in XSLT 3.0
                  whether or not XPath 3.1 is supported. The specification given here is intended to
                  be identical to the specification in XPath 3.1.</p>
            </note>
            <p>The operator is available in two forms: as a unary (prefix) operator, and as a
               postfix operator.</p>
            <div3 id="unary-lookup-operator">
               <head>The Unary Lookup Operator</head>
               <p><code>[76] UnaryLookup ::= "?" KeySpecifier [54] KeySpecifier ::= NCName |
                     IntegerLiteral | ParenthesizedExpr | "*"</code></p>
               <p>A UnaryLookup expression returns a sequence of values selected from the map that
                  is the context item. If the context item is not a map or an array, a type error is
                  raised [err:XPTY0004] </p>
               <p>The semantics are as follows:</p>
               <olist>
                  <item>
                     <p>If the <code>KeySpecifier</code> is an <code>NCName</code>, the
                           <code>UnaryLookup</code> expression <code>?KS</code> is equivalent to
                           <code>.("KS")</code>. For example, <code>$emp[?name='Jim']</code> is
                        shorthand for <code>$emp[.("name")='Jim']</code>.</p>
                  </item>
                  <item>
                     <p>If the <code>KeySpecifier</code> is an <code>IntegerLiteral</code>, the
                           <code>UnaryLookup</code> expression <code>?N</code> is equivalent to
                           <code>.(N)</code>. This form is only useful for maps whose keys are
                        numeric. For example, <code>$temp[?7 &gt; 30]</code> is shorthand for
                           <code>$temp[.(7) &gt; 30]</code>.</p>
                  </item>
                  <item>
                     <p>If the <code>KeySpecifier</code> is a <code>ParenthesizedExpr</code>, the
                           <code>UnaryLookup</code> expression <code>?(EXP)</code> is equivalent to
                           <code>.(EXP)</code>. This form allows arbitrary keys, including keys
                        computed dynamically. For example, <code>$emp[?('Year of Birth') &gt;
                           1980]</code> is shorthand for <code>$emp[.("Year of Birth") &gt;
                           1980]</code></p>
                  </item>
                  <item>
                     <p>If the <code>KeySpecifier</code> is a wildcard ("*") the
                           <code>UnaryLookup</code> expression <code>?*</code> is equivalent to the
                        expression <code>for $k in map:keys(.) return .($k)</code>. That is, it
                        returns the sequence-concatenation of all the values in the map; since the
                        order of keys is implementation-dependent, so is the order of these
                        values.</p>
                  </item>
               </olist>
            </div3>
            <div3 id="postfix-lookup-operator">
               <head>The Postfix Lookup Operator</head>
               <p><code>[53] Lookup ::= "?" KeySpecifier</code></p>
               <p>The semantics of the postfix lookup operator are defined in terms of the unary
                  lookup operator. The left-hand operand must be a map, or a sequence of maps. The
                  KeySpecifier is applied to each of these maps, in order, and the results are
                  sequence-concatenated.</p>
               <olist>
                  <item>
                     <p>If the <code>KeySpecifier</code> is an <code>NCName</code>, the Postfix
                        Lookup expression <code>E?KS</code> is equivalent to <code>E!?KS</code>. For
                        example, if <code>$emps</code> is a sequence of maps containing information
                        about employees, then <code>$emps?name</code> selects the names of the
                        employees: it is equivalent to <code>$emps!map:get(., "name")</code>.</p>
                  </item>
                  <item>
                     <p>If the <code>KeySpecifier</code> is an <code>IntegerLiteral</code>, the
                        Postfix Lookup expression <code>E?N</code> is equivalent to
                           <code>E!?N</code>. This form is only useful for maps whose keys are
                        numeric.</p>
                     <p>For example, if <code>$emps</code> is a sequence of maps containing
                        information about employees, and if one of the entries in this map
                        represents the salary history, as a map whose keys are the relevant year and
                        whose associated value is the salary, then
                           <code>$emps[?name='John']?2012</code> returns the value of John’s salary
                        in the year 2012.</p>
                  </item>
                  <item>
                     <p>If the <code>KeySpecifier</code> is a <code>ParenthesizedExpr</code>, the
                        Postfix Lookup expression <code>E?(EXP)</code> is equivalent to <code>for $m
                           in E, $k in EXP return $m!?($k)</code>. This form allows arbitrary keys,
                        including keys computed dynamically. It also allows multiple keys.</p>
                     <p>For example, if <code>$emps</code> is a sequence of maps containing
                        information about employees, and if one of the entries in this map
                        represents the salary history, as a map whose keys are the relevant year and
                        whose associated value is the salary, then <code>$emps[?name='John']?(2012
                           to 2015)</code> returns the value of John’s salary in the years 2012
                        through 2015.</p>
                  </item>
                  <item>
                     <p>If the <code>KeySpecifier</code> is a wildcard ("*") the Postfix Lookup
                        expression <code>E?*</code> is equivalent to the expression
                           <code>E!?*</code>. That is, it returns the sequence-concatenation of all
                        the values in all the maps; since the order of keys within each map is
                        implementation-dependent, so is the order of these values.</p>
                  </item>
               </olist>
            </div3>
         </div2>
         <div2 id="maps-streaming" diff="add" at="P-bug22761">
            <head>Maps and Streaming</head>
            <p>Maps have many uses, but their introduction to XSLT 3.0 was strongly motivated by
               streaming use cases. In essence, when a source document is processed in streaming
               mode, data that is encountered in the course of processing may need to be retained in
               variables for subsequent use, because the nodes cannot be revisited. This creates a
               need for a flexible data structure to accommodate such temporary data, and maps were
               designed to fulfil this need.</p>
            <p>The entries in a map are not allowed to contain references to <termref
                  def="dt-streamed-node">streamed nodes</termref>. This is achieved by ensuring that
               for all constructs that supply content to be included in a map (for example the third
               argument of <function>map:put</function>, and the <code>select</code> attribute of
                  <elcode>xsl:map-entry</elcode>), the relevant operand is defined to have operand
               usage <termref def="dt-navigation"/>. Because maps cannot contain references to
               streamed nodes, they are effectively <termref def="dt-grounded"/>, and can therefore
               be used freely in contexts (such as parameters to functions or templates) where only
               grounded operands are permitted.</p>
            <p>The <elcode>xsl:map</elcode> instruction, and the XPath <code>MapConstructor</code>
               construct, are exceptions to the general rule that during streaming, only one
               downward selection (one consuming subexpression) is permitted. They share this
               characteristic with <elcode>xsl:fork</elcode>. As with <elcode>xsl:fork</elcode>, a
               streaming processor is expected to be able to construct the map during a single pass
               of the streamed input document, which may require multiple expressions to be
               evaluated in parallel.</p>
            <p>In the case of the <elcode>xsl:map</elcode> instruction, this exemption applies only
               in the case where the instruction consists exclusively of
                  <elcode>xsl:map-entry</elcode> (and <elcode>xsl:fallback</elcode>) children, and
               not in more complex cases where the map entries are constructed dynamically (for
               example using a control flow implemented using <elcode>xsl:choose</elcode>,
                  <elcode>xsl:for-each</elcode>, or <elcode>xsl:call-template</elcode>). Such cases
               may, of course, be streamable if they only have a single consuming subexpression.</p>
            <p>For example, the following XPath expression is streamable, despite making two
               downward selections:</p>
            <eg role="non-xml" xml:space="preserve">
let $m := map{'price':xs:decimal(price), 'discount':xs:decimal(discount)} 
return ($m?price - $m?discount)</eg>
            <p>Analysis:</p>
            <olist>
               <item>
                  <p>Because the <code>return</code> clause is motionless, the <termref
                        def="dt-sweep"/> of the <code>let</code> expression is the sweep of the map
                     expression (the expression in curly brackets).</p>
               </item>
               <item>
                  <p>The sweep of a map expression is the maximum sweep of its key/value pairs.</p>
               </item>
               <item>
                  <p>For both key/value pairs, the key is <termref def="dt-motionless"/> and the
                     value is <termref def="dt-consuming"/>.</p>
               </item>
               <item>
                  <p diff="add" at="P">The expression carefully atomizes both values, because
                     retaining references to streamed nodes in a map is not permitted.</p>
               </item>
               <item>
                  <p>Therefore the map expression, and hence the expression as a whole, is <termref
                        def="dt-grounded"/> and <termref def="dt-consuming"/>.</p>
               </item>
            </olist>
            <p>See also: <specref ref="streamability-of-map-constructors"/>, <specref
                  ref="streamability-xsl-map"/>, <specref ref="streamability-xsl-map-entry"/></p>
         </div2>
         <div2 id="map-examples">
            <head>Examples using Maps</head>
            <p>This section gives some examples of where maps can be useful.</p>
            <example id="maps-with-iterate">
               <head>Using Maps with xsl:iterate</head>
               <p>This example uses maps in conjunction with the <elcode>xsl:iterate</elcode>
                  instruction to find the highest-earning employee in each department, in a single
                  streaming pass of an input document containing employee records.</p>
               <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:source-document streamable="yes" href="employees.xml"&gt;
  &lt;xsl:iterate select="*/employee"&gt;
    &lt;xsl:param name="highest-earners" 
               as="map(xs:string, element(employee))" 
               select="map{}"/&gt;
    &lt;xsl:on-completion&gt;
      &lt;xsl:for-each select="map:keys($highest-earners)"&gt;
        &lt;department name="{.}"&gt;
          &lt;xsl:copy-of select="$highest-earners(.)"/&gt;
        &lt;/department&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:on-completion&gt;           
    &lt;xsl:variable name="this" select="copy-of(.)" as="element(employee)"/&gt; 
    &lt;xsl:next-iteration&gt;
      &lt;xsl:with-param name="highest-earners"
          select="let $existing := $highest-earners($this/department)
                  return if ($existing/salary gt $this/salary)
                         then $highest-earners
                         else map:put($highest-earners, $this/department, $this)"/&gt;
    &lt;/xsl:next-iteration&gt;
  &lt;/xsl:iterate&gt;
&lt;/xsl:source-document&gt;
</eg>
            </example>
            <example id="example-complex-numbers">
               <head>Using Maps to Implement Complex Numbers</head>
               <p>A complex number might be represented as a map with two entries, the keys being
                  the <code>xs:boolean</code> value <code>true</code> for the real part, and the
                     <code>xs:boolean</code> value <code>false</code> for the imaginary part. A
                  library for manipulation of complex numbers might include functions such as the
                  following:</p>
               <eg role="xslt-declaration xmlns:i='i'" xml:space="preserve">

&lt;xsl:variable name="REAL" static="yes" as="xs:int" select="0"/&gt; 
&lt;xsl:variable name="IMAG" static="yes" as="xs:int" select="1"/&gt; 
                     
&lt;xsl:function name="i:complex" as="map(xs:int, xs:double)"&gt;
  &lt;xsl:param name="real" as="xs:double"/&gt;
  &lt;xsl:param name="imaginary" as="xs:double"/&gt;
  &lt;xsl:sequence select="map{ $REAL : $real, $IMAG : $imaginary }"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:real" as="xs:double"&gt;
  &lt;xsl:param name="complex" as="map(xs:int, xs:double)"/&gt;
  &lt;xsl:sequence select="$complex($REAL)"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:imaginary" as="xs:double"&gt;
  &lt;xsl:param name="complex" as="map(xs:int, xs:double)"/&gt;
  &lt;xsl:sequence select="$complex($IMAG)"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:add" as="map(xs:int, xs:double)"&gt;
  &lt;xsl:param name="arg1" as="map(xs:int, xs:double)"/&gt;
  &lt;xsl:param name="arg2" as="map(xs:int, xs:double)"/&gt;
  &lt;xsl:sequence select="i:complex(i:real($arg1)+i:real($arg2), 
                                  i:imaginary($arg1)+i:imaginary($arg2)"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:multiply" as="map(xs:boolean, xs:double)"&gt;
  &lt;xsl:param name="arg1" as="map(xs:boolean, xs:double)"/&gt;
  &lt;xsl:param name="arg2" as="map(xs:boolean, xs:double)"/&gt;
  &lt;xsl:sequence select="i:complex(
      i:real($arg1)*i:real($arg2) - i:imaginary($arg1)*i:imaginary($arg2),
      i:real($arg1)*i:imaginary($arg2) + i:imaginary($arg1)*i:real($arg2))"/&gt;
&lt;/xsl:function&gt;
</eg>
            </example>
            <example id="map-as-index">
               <head>Using a Map as an Index</head>
               <p>Given a set of <code>book</code> elements, it is possible to construct an index in
                  the form of a map allowing the books to be retrieved by ISBN number.</p>
               <p>Assume the book elements have the form:</p>
               <eg role="xml" xml:space="preserve">
&lt;book&gt;
  &lt;isbn&gt;0470192747&lt;/isbn&gt;
  &lt;author&gt;Michael H. Kay&lt;/author&gt;
  &lt;publisher&gt;Wiley&lt;/publisher&gt;
  &lt;title&gt;XSLT 2.0 and XPath 2.0 Programmer's Reference&lt;/title&gt;
&lt;/book&gt;</eg>
               <p>An index may be constructed as follows: </p>
               <eg role="xslt-declaration xmlns:map='http://www.w3.org/2005/xpath-functions/map" xml:space="preserve">
&lt;xsl:variable name="isbn-index" as="map(xs:string, element(book))"
    select="map:merge(for $b in //book return map{$b/isbn : $b})"/&gt;</eg>
               <p>This index may then be used to retrieve the book for a given ISBN using either of
                  the expressions <code>map:get($isbn-index, "0470192747")</code> or
                     <code>$isbn-index("0470192747")</code>.</p>
               <p>In this simple form, this replicates the functionality available using
                     <elcode>xsl:key</elcode> and the <function>key</function> function. However, it
                  also provides capabilities not directly available using the
                     <function>key</function> function: for example, the index can include
                     <code>book</code> elements in multiple source documents. It also allows
                  processing of all the books using a construct such as <code>&lt;xsl:for-each
                     select="map:keys($isbn-index)"&gt;</code></p>
            </example>
            <example id="map-as-class">
               <head>A Map containing Named Functions</head>
               <p>As in JavaScript, a map whose keys are strings and whose associated values are
                  function items can be used in a similar way to a class in object-oriented
                  programming languages.</p>
               <p>Suppose an application needs to handle customer order information that may arrive
                  in three different formats, with different hierarchic arrangements:</p>
               <olist>
                  <item>
                     <p>Flat structure:</p>
                     <eg role="xml" xml:space="preserve">
&lt;customer id="c123"&gt;...&lt;/customer&gt;
&lt;product id="p789"&gt;...&lt;/product&gt;
&lt;order customer="c123" product="p789"&gt;...&lt;/order&gt;</eg>
                  </item>
                  <item>
                     <p>Orders within customer elements:</p>
                     <eg role="xml" xml:space="preserve">
&lt;customer id="c123"&gt;
   &lt;order product="p789"&gt;...&lt;/order&gt;
&lt;/customer&gt;
&lt;product id="p789"&gt;...&lt;/product&gt;</eg>
                  </item>
                  <item>
                     <p>Orders within product elements:</p>
                     <eg role="xml" xml:space="preserve">
&lt;customer id="c123"&gt;...&lt;/customer&gt;
&lt;product id="p789"&gt;
  &lt;order customer="c123"&gt;...&lt;/order&gt;
&lt;/product&gt;</eg>
                  </item>
               </olist>
               <p>An application can isolate itself from these differences by defining a set of
                  functions to navigate the relationships between customers, orders, and products:
                     <code>orders-for-customer</code>, <code>orders-for-product</code>,
                     <code>customer-for-order</code>, <code>product-for-order</code>. These
                  functions can be implemented in different ways for the three different input
                  formats. For example, with the first format the implementation might be:</p>
               <eg role="xslt-declaration" xml:space="preserve">
&lt;xsl:variable name="flat-input-functions" as="map(xs:string, function(*))*"
  select="map{
            'orders-for-customer' : 
                 function($c as element(customer)) as element(order)* 
                    {$c/../order[@customer=$c/@id]},
            'orders-for-product' : 
                 function($p as element(product)) as element(order)* 
                    {$p/../order[@product=$p/@id]},
            'customer-for-order' : 
                 function($o as element(order)) as element(customer) 
                    {$o/../customer[@id=$o/@customer]},
            'product-for-order' : 
                 function($o as element(order)) as element(product) 
                    {$o/../product[@id=$o/@product]} }                    
         "/&gt;</eg>
               <p>Having established which input format is in use, the application can bind the
                  appropriate implementation of these functions to a variable such as
                     <code>$input-navigator</code>, and can then process the input using XPath
                  expressions such as the following, which selects all products for which there is
                  no order: <code>//product[empty($input-navigator("orders-for-product")(.))]</code>
               </p>
            </example>
         </div2>
      </div1>
      <div1 id="json" diff="chg" at="O">
         <head>Processing JSON Data</head>
         <p>JSON is a popular format for exchange of structured data on the web: it is specified in
               <phrase diff="chg" at="R-bug23594"><bibref ref="rfc7159"/></phrase>. This section
            describes facilities allowing JSON data to be processed using XSLT.</p>
         <note diff="add" at="R-bug23594">
            <p>RFC7159 is taken as the definitive specification of JSON for the purposes of this
               document. The RFC explains its relationship with other JSON specifications such as
                  <bibref ref="ECMA-404"/>.</p>
         </note>
         <note>
            <p diff="add" at="S-bug28937">XPath 3.1 incorporates the functions defined in this
               section. It also provides additional JSON capability, in the form of functions
                  <code>parse-json</code>, <code>json-doc</code>, and extensions to the
                  <xfunction>serialize</xfunction> function. These facilities are incorporated in
               XSLT 3.0 only if the XPath 3.1 feature is supported. They depend on support for
               arrays.</p>
         </note>
         <div2 id="json-to-xml-mapping">
            <head>XML Representation of JSON</head>
            <p>This specification defines a mapping from JSON data to XML (specifically, to XDM
               instances). A function <function>json-to-xml</function> is provided to take a JSON
               string as input and convert it to the XML representation. Two stylesheet modules are
               provided to perform the reverse transformation: one produces JSON in compact linear
               form, the other in indented form suitable for display, editing, or printing.</p>
            <p>The XML representation is designed to be capable of representing any valid JSON text
               other than one that uses characters which are not valid in XML. The transformation is
               lossless: that is, distinct JSON texts convert to distinct XML representations. When
               converting JSON to XML, options are provided to reject unsupported characters, to
               replace them with a substitute character, or to leave them in backslash-escaped
               form.</p>
            <p>The following example demonstrates the correspondence of a JSON text and the
               corresponding XML representation. </p>
            <example diff="chg" at="R-bug24436">
               <head>A JSON Text and its XML Representation</head>
               <p>Consider the following JSON text:</p>
               <eg role="json" xml:space="preserve">
{
  "desc"    : "Distances between several cities, in kilometers.",
  "updated" : "2014-02-04T18:50:45",
  "uptodate": true,
  "author"  : null,
  "cities"  : {
    "Brussels": [
      {"to": "London",    "distance": 322},
      {"to": "Paris",     "distance": 265},
      {"to": "Amsterdam", "distance": 173}
    ],
    "London": [
      {"to": "Brussels",  "distance": 322},
      {"to": "Paris",     "distance": 344},
      {"to": "Amsterdam", "distance": 358}
    ],
    "Paris": [
      {"to": "Brussels",  "distance": 265},
      {"to": "London",    "distance": 344},
      {"to": "Amsterdam", "distance": 431}
    ],
    "Amsterdam": [
      {"to": "Brussels",  "distance": 173},
      {"to": "London",    "distance": 358},
      {"to": "Paris",     "distance": 431}
    ]
  }
}
               </eg>
               <p>The XML representation of this text is as follows. Whitespace is included in the
                  XML representation for purposes of illustration, and is ignored by the stylesheets
                  that convert XML to JSON, but it will not be present in the output of the
                     <function>json-to-xml</function> function.</p>
               <eg role="xml" xml:space="preserve">
  &lt;map xmlns="http://www.w3.org/2005/xpath-functions"&gt;
    &lt;string key='desc'&gt;Distances between several cities, in kilometers.&lt;/string&gt;
    &lt;string key='updated'&gt;2014-02-04T18:50:45&lt;/string&gt;
    &lt;boolean key="uptodate"&gt;true&lt;/boolean&gt;
    &lt;null key="author"/&gt;
    &lt;map key='cities'&gt;
      &lt;array key="Brussels"&gt;
        &lt;map&gt;
            &lt;string key="to"&gt;London&lt;/string&gt;
            &lt;number key="distance"&gt;322&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;Paris&lt;/string&gt;
            &lt;number key="distance"&gt;265&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;Amsterdam&lt;/string&gt;
            &lt;number key="distance"&gt;173&lt;/number&gt;
        &lt;/map&gt; 
      &lt;/array&gt;
      &lt;array key="London"&gt;
        &lt;map&gt;
            &lt;string key="to"&gt;Brussels&lt;/string&gt;
            &lt;number key="distance"&gt;322&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;Paris&lt;/string&gt;
            &lt;number key="distance"&gt;344&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;Amsterdam&lt;/string&gt;
            &lt;number key="distance"&gt;358&lt;/number&gt;
        &lt;/map&gt; 
      &lt;/array&gt;
      &lt;array key="Paris"&gt;
        &lt;map&gt;
            &lt;string key="to"&gt;Brussels&lt;/string&gt;
            &lt;number key="distance"&gt;265&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;London&lt;/string&gt;
            &lt;number key="distance"&gt;344&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;Amsterdam&lt;/string&gt;
            &lt;number key="distance"&gt;431&lt;/number&gt;
        &lt;/map&gt;  
      &lt;/array&gt;
      &lt;array key="Amsterdam"&gt;
        &lt;map&gt;
            &lt;string key="to"&gt;Brussels&lt;/string&gt;
            &lt;number key="distance"&gt;173&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;London&lt;/string&gt;
            &lt;number key="distance"&gt;358&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;Paris&lt;/string&gt;
            &lt;number key="distance"&gt;431&lt;/number&gt;
        &lt;/map&gt;
      &lt;/array&gt;
    &lt;/map&gt;  
  &lt;/map&gt;</eg>
            </example>
            <p>An XSD 1.0 schema for the XML representation is provided in <specref
                  ref="schema-for-json"/>. It is not necessary to import this schema (using
                  <elcode>xsl:import-schema</elcode>) unless the stylesheet makes explicit reference
               to the components defined in the schema. If the stylesheet does import a schema for
               the namespace <code>http://www.w3.org/2005/xpath-functions</code>, then:</p>
            <olist>
               <item>
                  <p>The processor (if it is schema-aware) <rfc2119>must</rfc2119> recognize an
                        <elcode>xsl:import-schema</elcode> declaration for this namespace, whether
                     or not the <code>schema-location</code> is supplied.</p>
               </item>
               <item>
                  <p>If a <code>schema-location</code> is provided, then the schema document at that
                     location <rfc2119>must</rfc2119> be equivalent to the schema document at
                        <specref ref="schema-for-json"/>; the effect if it is not is <termref
                        def="dt-implementation-dependent"/></p>
               </item>
            </olist>
            <p>The rules governing the mapping from JSON to XML are as follows. In these rules, the
               phrase “an element named N” is to be interpreted as meaning “an element node whose
               local name is N and whose namespace URI is
                  <code>http://www.w3.org/2005/xpath-functions</code>”.</p>
            <olist>
               <item>
                  <p>The JSON value <code>null</code> is represented by an element named
                        <code>null</code>, with empty content.</p>
               </item>
               <item>
                  <p>The JSON values <code>true</code> and <code>false</code> are represented by an
                     element named <code>boolean</code>, with content conforming to the type
                        <code>xs:boolean</code>.</p>
               </item>
               <item>
                  <p>A JSON number is represented by an element named <code>number</code>, with
                     content conforming to the type <code>xs:double</code>, with the additional
                     restriction that the value must not be positive or negative infinity, nor
                        <code>NaN</code>.</p>
               </item>
               <item>
                  <p>A JSON string is represented by an element named <code>string</code>, with
                     content conforming to the type <code>xs:string</code>.</p>
               </item>
               <item>
                  <p>A JSON array is represented by an element named <code>array</code>. The content
                     is a sequence of child elements representing the members of the array in order,
                     each such element being the representation of the array member obtained by
                     applying these rules recursively.</p>
               </item>
               <item>
                  <p>A JSON object is represented by an element named <code>map</code>. The content
                     is a sequence of child elements each of which represents one of the name/value
                     pairs in the object. The representation of the name/value pair <var>N:V</var>
                     is obtained by taking the element that represents the value <var>V</var> (by
                     applying these rules recursively) and adding an attribute with name
                        <code>key</code> (in no namespace), whose value is <var>N</var> as an
                     instance of <code>xs:string</code>.</p>
               </item>
            </olist>
            <p>The attribute <code>escaped="true"</code> may be specified on a <code>string</code>
               element to indicate that the string value contains backslash-escaped characters that
               are to be interpreted according to the JSON rules. The attribute
                  <code>escaped-key="true"</code> may be specified on any element with a
                  <code>key</code> attribute to indicate that the key contains backslash-escaped
               characters that are to be interpreted according to the JSON rules. Both attributes
               have the default value <code>false</code>.</p>
            <p diff="add" at="R-bug23594">The JSON grammar for <code>number</code> is a subset of
               the lexical space of the XSD type <code>xs:double</code>. The mapping from JSON
                  <code>number</code> values to <code>xs:double</code> values is defined by the
               XPath rules for casting from <code>xs:string</code> to <code>xs:double</code>. Note
               that these rules will never generate an error for out-of-range values; instead very
               large or very small values will be converted to <code>+INF</code> or
                  <code>-INF</code>. Since JSON does not impose limits on the range or precision of
               numbers, the conversion is not guaranteed to be lossless.</p>
            <p>Although the order of entries in a JSON object is generally considered to have no
               significance, the function <code>json-to-xml</code> and the stylesheets that perform
               the reverse transformation both retain order.</p>
            <p>The XDM representation of a JSON value may either be untyped (all elements annotated
               as <code>xs:untyped</code>, attributes as <code>xs:untypedAtomic</code>), or it may
               be typed. If it is typed, then it <rfc2119>must</rfc2119> have the type annotations
               obtained by validating the untyped representation against the schema given in
                  <specref ref="schema-for-json"/>. If it is untyped, then it
                  <rfc2119>must</rfc2119> be an XDM instance such that validation against this
               schema would succeed.</p>
         </div2>
         <div2 id="options" diff="add" at="T-bug29602">
            <head>Option Parameter Conventions</head>
            <p><emph>This section describes conventions which in principle can be adopted by the
                  specification of any function. At the time of writing, the function which invoke
                  these conventions are <function>xml-to-json</function> and
                     <function>json-to-xml</function>.</emph></p>
            <p>As a matter of convention, a number of functions defined in this document take a
               parameter whose value is a map, defining options controlling the detail of how the
               function is evaluated. Maps are a new data type introduced in XSLT 3.0.</p>
            <p>For example, the function <code>fn:xml-to-json</code> has an options parameter
               allowing specification of whether the output is to be indented. A call might be
               written:</p>
            <eg role="xpath" xml:space="preserve">fn:xml-to-json($input, map{'indent':true()})</eg>
            <p><termdef id="option-parameter-conventions" term="option parameter conventions"
                  >Functions that take an options parameter adopt common conventions on how the
                  options are used. These are referred to as the <term>option parameter
                     conventions</term>. These rules apply only to functions that explicitly refer
                  to them.</termdef></p>
            <p>Where a function adopts the <termref def="option-parameter-conventions"/>, the
               following rules apply:</p>
            <olist>
               <item>
                  <p>The value of the relevant argument must be a map. The entries in the map are
                     referred to as options: the key of the entry is called the option name, and the
                     associated value is the option value. Option names defined in this
                     specification are always strings (single <code>xs:string</code> values). Option
                     values may be of any type.</p>
               </item>
               <item>
                  <p>The type of the options parameter in the function signature is always given as
                        <code>map(*)</code>.</p>
               </item>
               <item>
                  <p>Although option names are described above as strings, the actual key may be any
                     value that compares equal to the required string (using the <code>eq</code>
                     operator with Unicode codepoint collation). For example, instances of
                        <code>xs:untypedAtomic</code> or <code>xs:anyURI</code> are equally
                     acceptable.</p>
                  <note>
                     <p>This means that the implementation of the function can check for the
                        presence and value of particular options using the functions
                           <code>map:contains</code> and/or <code>map:get</code>.</p>
                  </note>
               </item>
               <item>
                  <p>It is not an error if the options map contains options with names other than
                     those described in this specification. Implementations <rfc2119>may</rfc2119>
                     attach an <termref def="dt-implementation-defined"
                        >implementation-defined</termref> meaning to such entries, and
                        <rfc2119>may</rfc2119> define errors that arise if such entries are present
                     with invalid values. Implementations <rfc2119>must</rfc2119> ignore such
                     entries unless they have a specific <termref def="dt-implementation-defined"
                        >implementation-defined</termref> meaning. Implementations that define
                     additional options in this way <rfc2119>should</rfc2119> use values of type
                        <code>xs:QName</code> as the option names, using an appropriate
                     namespace.</p>
               </item>
               <item>
                  <p>All entries in the options map are optional, and supplying an empty map has the
                     same effect as omitting the relevant argument in the function call, assuming
                     this is permitted.</p>
               </item>
               <item>
                  <p>For each named option, the function specification defines a required type for
                     the option value. The value that is actually supplied in the map is converted
                     to this required type using the <xtermref spec="XP31"
                        ref="dt-function-conversion">function conversion rules</xtermref>. <phrase
                        diff="chg" at="D">A type error <xerrorref spec="XP30" class="TY" code="0004"
                           type="type"/> occurs if conversion of the supplied value to the required
                        type is not possible, or if this conversion delivers a coerced function
                        whose invocation fails with a type error.</phrase> A dynamic error occurs if
                     the supplied value after conversion is not one of the permitted values for the
                     option in question: the error codes for this error are defined in the
                     specification of each function.</p>
                  <note>
                     <p>It is the responsibility of each function implementation to invoke this
                        conversion; it does not happen automatically as a consequence of the
                        function calling rules.</p>
                  </note>
               </item>
               <item>
                  <p>In cases where an option is list-valued, by convention the value may be
                     supplied either as a sequence or as an array. Accepting a sequence is
                     convenient if the value is generated programmatically using an XPath
                     expression; while accepting an array allows the options to be held in an an
                     external file in JSON format, to be read using a call on the
                        <code>fn:json-doc</code> function.</p>
               </item>
               <item>
                  <p>In cases where the value of an option is itself a map, the specification of the
                     particular function must indicate whether or not these rules apply recursively
                     to the contents of that map.</p>
               </item>
            </olist>
         </div2>
         <div2 id="func-json-to-xml">
            <head>fn:json-to-xml</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>Parses a string supplied in the form of a JSON text, returning the results
                        in the form of an XML <phrase diff="chg" at="P">document node</phrase>.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signatures</label>
                  <def>
                     <example role="signature">
                        <proto name="json-to-xml" return-type="document-node()" isOp="no"
                           prefix="fn" returnEmptyOk="no" returnSeq="no" returnVaries="no"
                           isSchema="no" isDatatype="no" isSpecial="no">
                           <arg name="json-text" type="xs:string"/>
                        </proto>
                     </example>
                     <example role="signature">
                        <proto name="json-to-xml" return-type="document-node()" isOp="no"
                           prefix="fn" returnEmptyOk="no" returnSeq="no" returnVaries="no"
                           isSchema="no" isDatatype="no" isSpecial="no">
                           <arg name="json-text" type="xs:string"/>
                           <arg name="options" type="map(*)"/>
                        </proto>
                     </example>
                  </def>
               </gitem>
               <gitem>
                  <label>Properties</label>
                  <def>
                     <p>This function is <xtermref spec="FO30" ref="dt-nondeterministic"
                           >nondeterministic</xtermref>, <xtermref spec="FO30"
                           ref="dt-context-dependent">context-dependent</xtermref>, and <xtermref
                           spec="FO30" ref="dt-focus-independent">focus-independent</xtermref>. It
                        depends on static base URI. </p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>The effect of the one-argument form of this function is the same as calling
                        the two-argument form with an empty map as the value of the
                           <code>$options</code> argument.</p>
                     <p>The first argument is a JSON-text (see below) in the form of a string. The
                        function parses this string to return an XDM node.</p>
                     <p>The <code>$options</code> argument can be used to control the way in which
                        the parsing takes place. The value of the argument is a map. The options
                        defined in this specification have keys that are strings. The effect of any
                        map entries whose keys are not defined in this specification is
                        implementation-defined; implementation-defined options
                           <rfc2119>should</rfc2119> use QNames as keys. Implementations
                           <rfc2119>must</rfc2119> ignore any entries in the map whose keys are not
                        defined in this specification, unless the key has a specific <termref
                           def="dt-implementation-defined">implementation-defined</termref> meaning. </p>
                     <p>The entries that may appear in the <code>$options</code> map are as follows.
                        The keys are <code>xs:string</code> values:</p>
                     <table class="data">
                        <thead>
                           <tr>
                              <th rowspan="1" colspan="1">Key</th>
                              <th rowspan="1" colspan="1">Value</th>
                              <th rowspan="1" colspan="1">Meaning</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr diff="chg" at="R-bug23594">
                              <td rowspan="3" colspan="1">
                                 <code>liberal</code>
                              </td>
                              <td colspan="2" rowspan="1">Determines whether deviations from the
                                 syntax of RFC7159 are permitted. The value <rfc2119>must</rfc2119>
                                 be a boolean.</td>
                           </tr>
                           <tr>
                              <td rowspan="1" colspan="1">
                                 <code>false</code>
                              </td>
                              <td rowspan="1" colspan="1">The input <rfc2119>must</rfc2119> consist
                                 of an optional byte order mark (which is ignored) followed by a
                                 string that conforms to the grammar of <code>JSON-text</code> in
                                    <bibref ref="rfc7159"/>. An error <rfc2119>must</rfc2119> be
                                 raised (see below) if the input does not conform to the
                                 grammar.</td>
                           </tr>
                           <tr>
                              <td rowspan="1" colspan="1">
                                 <code>true</code>
                              </td>
                              <td rowspan="1" colspan="1">The input <rfc2119>may</rfc2119> contain
                                 deviations from the grammar of <bibref ref="rfc7159"/>, which are
                                 handled in an <termref def="dt-implementation-defined"/> way.
                                 (Note: some popular extensions include allowing quotes on keys to
                                 be omitted, allowing a comma to appear after the last item in an
                                 array, allowing leading zeroes in numbers, and allowing control
                                 characters such as tab and newline to be present in unescaped
                                 form.) Since the extensions accepted are implementation-defined, an
                                 error <rfc2119>may</rfc2119> be raised (see below) if the input
                                 does not conform to the grammar.</td>
                           </tr>
                           <tr>
                              <td rowspan="3" colspan="1">
                                 <code>validate</code>
                              </td>
                              <td colspan="2" rowspan="1">If the <code>$options</code> map contains
                                 an entry with the key <code>"validate"</code>, then the value
                                    <rfc2119>must</rfc2119> be an <code>xs:boolean</code>. The
                                 default is <code>true</code> for a schema-aware processor,
                                    <code>false</code> for a non-schema-aware processor. If the
                                 value <code>true</code> is supplied and the processor is not
                                 schema-aware, a dynamic error results <errorref spec="XT"
                                    class="DE" code="3245"/>. It is not necessary that the
                                 containing stylesheet should import the relevant schema.</td>
                           </tr>
                           <tr>
                              <td rowspan="1" colspan="1">
                                 <code>true</code>
                              </td>
                              <td rowspan="1" colspan="1">Indicates that the resulting XDM instance
                                 must be typed; that is, the element and attribute nodes must carry
                                 the type annotations that result from validation against the schema
                                 given at <specref ref="schema-for-json"/>, or against an <termref
                                    def="dt-implementation-defined"/> schema if the <phrase
                                    diff="chg" at="r-bug23594"><code>liberal</code> option has the
                                    value <code>yes</code></phrase>.</td>
                           </tr>
                           <tr>
                              <td rowspan="1" colspan="1">
                                 <code>false</code>
                              </td>
                              <td rowspan="1" colspan="1">Indicates that the XDM instance must be
                                 untyped.</td>
                           </tr>
                           <tr>
                              <td rowspan="3" colspan="1">
                                 <code>escape</code>
                              </td>
                              <td colspan="2" rowspan="1">Determines whether special characters are
                                 represented in the XDM output in backslash-escaped form. The
                                 required type is <code>xs:boolean</code>. </td>
                           </tr>
                           <tr>
                              <td rowspan="1" colspan="1">
                                 <phrase diff="chg" at="D"><code>false</code> (default)</phrase>
                              </td>
                              <td diff="chg" at="D" rowspan="1" colspan="1">All characters in the
                                 input that are valid in the version of XML supported by the
                                 implementation, whether or not they are represented in the input by
                                 means of an escape sequence, are represented as unescaped
                                 characters in the result. Any characters or codepoints that are not
                                 valid XML characters (for example, unpaired surrogates) <phrase
                                    diff="add" at="D">are passed to the <code>fallback</code>
                                    function as described below; in the absence of a fallback
                                    function, they are replaced by the Unicode <code>REPLACEMENT
                                       CHARACTER</code> (<code>xFFFD</code>)</phrase>. The
                                 attributes <code>escaped</code> and <code>escaped-key</code> will
                                 not be present in the XDM output.</td>
                           </tr>
                           <tr>
                              <td rowspan="1" colspan="1">
                                 <phrase><code>true</code></phrase>
                              </td>
                              <td rowspan="1" colspan="1">JSON escape sequences are used in the
                                 result to represent special characters in the JSON input, as
                                 defined below, whether or not they were represented using JSON
                                 escape sequences in the input. The characters that are considered
                                 "special" for this purpose are: <ulist>
                                    <item>
                                       <p>all codepoints in the range <code>x00</code> to
                                             <code>x1F</code> or <code>x7F</code> to
                                             <code>x9F</code>;</p>
                                    </item>
                                    <item>
                                       <p>all codepoints that do not represent characters that are
                                          valid in the version of XML supported by the processor,
                                          including codepoints representing unpaired surrogates;</p>
                                    </item>
                                    <item>
                                       <p>the backslash character itself (<code>x5C</code>).</p>
                                    </item>
                                 </ulist> Such characters are represented using a two-character
                                 escape sequence where available (for example, <code>\t</code>), or
                                 a six-character escape sequence otherwise (for example
                                    <code>\uDEAD</code>). Characters other than these will not be
                                 escaped in the result, even if they were escaped in the input. In
                                 the result: <ulist>
                                    <item>
                                       <p>Any <code>string</code> element whose string value
                                          contains a backslash character must have the attribute
                                          value <code>escaped="true"</code>.</p>
                                    </item>
                                    <item>
                                       <p>Any element that contains a <code>key</code> attribute
                                          whose string value contains a backslash character must
                                          have the attribute <code>escaped-key="true"</code>.</p>
                                    </item>
                                    <item>
                                       <p>The values of the <code>escaped</code> and
                                             <code>escaped-key</code> attributes are immaterial when
                                          there is no backslash present, and it is never necessary
                                          to include either attribute when its value is
                                             <code>false</code>.</p>
                                    </item>
                                 </ulist></td>
                           </tr>
                           <tr>
                              <td rowspan="2" colspan="1">
                                 <code>fallback</code>
                              </td>
                              <td colspan="2" rowspan="1">Provides a function which is called when
                                 an invalid character is encountered.</td>
                           </tr>
                           <tr>
                              <td rowspan="1" colspan="1">Function with signature
                                    <code>function(xs:string) as xs:string</code></td>
                              <td rowspan="1" colspan="1">When an invalid character is encountered
                                 this function is called supplying the escaped form of the character
                                 as the argument. The function returns a string which is inserted
                                 into the result in place of the invalid character. The function
                                 also has the option of raising a dynamic error.</td>
                           </tr>
                        </tbody>
                     </table>
                     <p>The various structures that can occur in JSON are transformed recursively to
                        XDM values according to the rules given in <specref
                           ref="json-to-xml-mapping"/>.</p>
                     <p>The function returns <phrase diff="add" at="P">a document node, whose only
                           child is</phrase> the element node representing the outermost construct
                        in the JSON text.</p>
                     <p>The function is not <xtermref spec="FO30" ref="dt-deterministic"
                           >deterministic</xtermref>: that is, if the function is called twice with
                        the same arguments, it is <termref def="dt-implementation-dependent"
                           >implementation-dependent</termref> whether the same node is returned on
                        both occasions.</p>
                     <p>The base URI of the returned document node is taken from the static base URI
                        of the function call.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Error Conditions</label>
                  <def>
                     <p>
                        <error spec="XT" type="dynamic" class="DE" code="3240"><p>It is a <termref
                                 def="dt-dynamic-error">dynamic error</termref> if the value of
                                 <code>$input</code> does not conform to the JSON grammar<phrase
                                 diff="chg" at="R-bug23594"> as defined by <bibref ref="rfc7159"/>,
                                 allowing implementation-defined extensions if the
                                    <code>liberal</code> option is set to
                              <code>yes</code></phrase>.</p></error>
                     </p>
                     <p diff="add" at="P">
                        <error spec="XT" type="dynamic" class="DE" code="3245"><p>It is a <termref
                                 def="dt-dynamic-error">dynamic error</termref> if the value of the
                                 <code>validate</code> option is <code>true</code> and the processor
                              is not schema-aware.</p></error>
                     </p>
                     <p>
                        <error spec="XT" type="dynamic" class="DE" code="3250"><p>It is a <termref
                                 def="dt-dynamic-error">dynamic error</termref> if the value of
                                 <code>$input</code> contains an escaped representation of a
                              character (or codepoint) that is not a valid character in the version
                              of XML supported by the implementation, unless the
                                 <code>unescape</code> option is set to false.</p></error>
                     </p>
                     <p>
                        <error spec="XT" type="dynamic" class="DE" code="3260"><p>It is a <termref
                                 def="dt-dynamic-error">dynamic error</termref> if the value of
                                 <code>$options</code> includes an entry whose key is <phrase
                                 diff="chg" at="R-bug23594"><code>liberal</code>,
                                    <code>validate</code>, <code>unescape</code>, or
                                    <code>fallback</code>, and whose value is not a permitted value
                                 for that key</phrase>.</p></error>
                     </p>
                  </def>
               </gitem>
               <gitem>
                  <label>Notes</label>
                  <def>
                     <p role="note">To read a JSON file, this function can be used in conjunction
                        with the <xfunction>unparsed-text</xfunction> function.</p>
                     <p role="note">ECMA-404 differs from RFC 4627 in two respects: it does not
                        allow the input to depart from the JSON grammar, but it does allow the
                        top-level construct in the input to be a string, boolean, number, or null,
                        rather than requiring an object or array.</p>
                     <p role="note">Many JSON implementations allow commas to be used after the last
                        item in an object or array, although the specification does not permit it.
                        The option <code>spec="liberal"</code> is provided to allow such deviations
                        from the specification to be accepted. Some JSON implementations also allow
                        constructors such as <code>new Date("2000-12-13")</code> to appear as
                        values: specifying <code>spec="liberal"</code> allows such extensions to be
                        accepted, but does not guarantee it. If such extensions are accepted, the
                        resulting value is implementation-defined, and will not necessarily conform
                        to the schema at <specref ref="schema-for-json"/>.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Examples</label>
                  <def role="example">
                     <p>The expression <code>json-to-xml('{"x": 1, "y": [3,4,5]}')</code> returns
                           <code> &lt;map xmlns="http://www.w3.org/2005/xpath-functions"&gt;
                           &lt;number key="x"&gt;1&lt;/number&gt; &lt;array key="y"&gt;
                           &lt;number&gt;3&lt;/number&gt; &lt;number&gt;4&lt;/number&gt;
                           &lt;number&gt;5&lt;/number&gt; &lt;/array&gt; &lt;/map&gt;</code>.</p>
                     <p>The expression <code>json-to-xml('"abcd"', map{'liberal': false()})</code>
                        returns <code>&lt;string
                           xmlns="http://www.w3.org/2005/xpath-functions"&gt;abcd&lt;/string&gt;</code>.</p>
                     <p>The expression <code>json-to-xml('{"x": "\\", "y": "\u0025"}')</code>
                        returns <code> &lt;map xmlns="http://www.w3.org/2005/xpath-functions"&gt;
                           &lt;string key="x"&gt;\&lt;/string&gt; &lt;string
                           key="y"&gt;%&lt;/string&gt; &lt;/map&gt;</code>.</p>
                     <p>The expression <code>json-to-xml('{"x": "\\", "y": "\u0025"}', map{'escape':
                           true()})</code> returns <code> &lt;map
                           xmlns="http://www.w3.org/2005/xpath-functions"&gt; &lt;string
                           escaped="true" key="x"&gt;\\&lt;/string&gt; &lt;string
                           key="y"&gt;%&lt;/string&gt; &lt;/map&gt;</code>. <emph>(But see the
                           detailed rules for alternative values of the <code>escaped</code>
                           attribute on the second <code>string</code> element.)</emph></p>
                     <p>The following example illustrates use of the fallback function to handle
                        characters that are invalid in XML.</p>
                     <eg diff="add" at="D" xml:space="preserve">
 let 
   $jsonstr := unparsed-text('http://example.com/endpoint'),
   $options := map {
     'liberal': true(),
     'fallback': function($char as xs:string) as xs:string {
       let 
         $c0chars := map {
           '\u0000':'[NUL]',
           '\u0001':'[SOH]',
           '\u0002':'[STX]',
           ...
           '\u001E':'[RS]',
           '\u001F':'[US]'
         },
         $replacement := $c0chars($char)
      return 
        if (exists($replacement))
        then $replacement
        else error(xs:QName('err:invalid-char'), 
          'Error: ' || $char || ' is not a C0 control character.')
     }
   }
 return json-to-xml($jsonstr, $options)</eg>
                  </def>
               </gitem>
            </glist>
         </div2>
         <div2 id="func-xml-to-json" diff="chg" at="T-bug29602">
            <head>fn:xml-to-json</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>Converts an XML tree, whose format corresponds to the XML representation of
                        JSON defined in this specification, into a string conforming to the JSON
                        grammar.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signatures</label>
                  <def>
                     <example role="signature">
                        <proto name="xml-to-json" return-type="xs:string?" isOp="no" prefix="fn"
                           returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no"
                           isDatatype="no" isSpecial="no">
                           <arg name="input" type="node()?"/>
                        </proto>
                     </example>
                     <example role="signature">
                        <proto name="xml-to-json" return-type="xs:string?" isOp="no" prefix="fn"
                           returnEmptyOk="no" returnSeq="no" returnVaries="no" isSchema="no"
                           isDatatype="no" isSpecial="no">
                           <arg name="input" type="node()?"/>
                           <arg name="options" type="map(*)"/>
                        </proto>
                     </example>
                  </def>
               </gitem>
               <gitem>
                  <label>Properties</label>
                  <def>
                     <p>This function is <xtermref spec="FO30" ref="dt-deterministic"
                           >deterministic</xtermref>, <xtermref spec="FO30"
                           ref="dt-context-independent">context-independent</xtermref>, and
                           <xtermref spec="FO30" ref="dt-focus-independent"
                           >focus-independent</xtermref>. </p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>The effect of the one-argument form of this function is the same as calling
                        the two-argument form with an empty map as the value of the
                           <code>$options</code> argument.</p>
                     <p>The first argument <code>$input</code> is a node; the subtree rooted at this
                        node will typically be the XML representation of a JSON document as defined
                        in <specref ref="json-to-xml-mapping"/>.</p>
                     <p>If <code>$input</code> is the empty sequence, the function returns the empty
                        sequence.</p>
                     <p diff="chg" at="D">The <code>$options</code> argument can be used to control
                        the way in which the conversion takes place. The <termref
                           def="option-parameter-conventions">option parameter conventions</termref>
                        apply.</p>
                     <p>The entries that may appear in the <code>$options</code> map are as
                        follows:</p>
                     <table class="data">
                        <thead>
                           <tr>
                              <th rowspan="1" colspan="1">Key</th>
                              <th rowspan="1" colspan="1">Value</th>
                              <th rowspan="1" colspan="1">Meaning</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr>
                              <td rowspan="3" colspan="1">
                                 <code>indent</code>
                              </td>
                              <td colspan="2" rowspan="1">Determines whether additional whitespace
                                 should be added to the output to improve readability. The required
                                 type is <code>xs:boolean</code>.</td>
                           </tr>
                           <tr>
                              <td rowspan="1" colspan="1">
                                 <code>false</code>
                              </td>
                              <td rowspan="1" colspan="1">The processor must not insert any
                                 insignificant whitespace between JSON tokens.</td>
                           </tr>
                           <tr>
                              <td rowspan="1" colspan="1">
                                 <code>true</code>
                              </td>
                              <td rowspan="1" colspan="1">The processor <rfc2119>may</rfc2119>
                                 insert whitespace between JSON tokens in order to improve
                                 readability. The specification imposes no constraints on how this
                                 is done.</td>
                           </tr>
                        </tbody>
                     </table>
                     <p>The node supplied as <code>$input</code> must be one of the following:
                           <xerrorref spec="FO31" class="JS" code="0006"/></p>
                     <olist>
                        <item>
                           <p>An element node whose name matches the name of a global element
                              declaration in the schema given in <specref ref="schema-for-json"/>
                              and whose type annotation matches the type of that element declaration
                              (indicating that the element has been validated against this
                              schema).</p>
                        </item>
                        <item>
                           <p>An element node whose name matches the name of a global element
                              declaration in the schema given in <specref ref="schema-for-json"/>,
                                 <phrase diff="del" at="D">whose type annotation is
                                    <code>xs:untyped</code>, </phrase>and whose content after
                              stripping all attributes (at any depth) in namespaces other than
                                 <code>http://www.w3.org/2005/xpath-functions</code> is such that
                              validation against the schema given in <specref ref="schema-for-json"
                              /> would succeed.</p>
                           <note>
                              <p>The reason attributes in alien namespaces are stripped is to avoid
                                 the need for a non-schema-aware processor to take into account the
                                 effect of attributes such as <code>xsi:type</code> and
                                    <code>xsi:nil</code> that would affect the outcome of schema
                                 validation.</p>
                           </note>
                        </item>
                        <item diff="add" at="T-bug29917">
                           <p>An element node <var>E</var> having a <code>key</code> attribute
                              and/or an <code>escaped-key</code> attribute provided that
                                 <var>E</var> would satisfy one of the above conditions if the
                                 <code>key</code> and/or <code>escaped-key</code> attributes were
                              removed.</p>
                        </item>
                        <item>
                           <p>A document node having exactly one element child and no text node
                              children, where the element child satisfies any of the conditions
                              above.</p>
                        </item>
                     </olist>
                     <p diff="add" at="T-bug29588">Furthermore, <code>$input</code> must satisfy the
                        following constraint (which cannot be conveniently expressed in the schema).
                        Every element <var>M</var> that is a descendant-or-self of
                           <code>$input</code> and has local name <code>map</code> and namespace URI
                           <code>http://www.w3.org/2005/xpath-functions</code> must satisfy the
                        following rule: there must not be two distinct children of <var>M</var> (say
                           <var>C1</var> and <var>C2</var>) such that the normalized key of
                           <var>C1</var> is equal to the normalized key of <var>C2</var>. The
                        normalized key of an element <var>C</var> is as follows:</p>
                     <ulist diff="add" at="T-bug29588">
                        <item>
                           <p>If <var>C</var> has the attribute value
                                 <code>escaped-key="true"</code>, then the value of the
                                 <code>key</code> attribute of <var>C</var>, with all JSON escape
                              sequences replaced by the corresponding Unicode characters according
                              to the JSON escaping rules. </p>
                        </item>
                        <item>
                           <p>Otherwise (the <code>escaped-key</code> attribute of <var>C</var> is
                              absent or set to false), the value of the <code>key</code> attribute
                              of <var>C</var>.</p>
                        </item>
                     </ulist>
                     <p>Nodes in the input tree are handled by applying the following rules,
                        recursively. In these rules the term "an element named <var>N</var>" means
                        "an element node whose local name is <var>N</var> and whose namespace URI is
                           <code>http://www.w3.org/2005/xpath-functions</code>".</p>
                     <olist>
                        <item>
                           <p>A document node having a single element node child is processed by
                              processing that child.</p>
                        </item>
                        <item>
                           <p>An element named <code>null</code> results in the output
                                 <code>null</code>.</p>
                        </item>
                        <item>
                           <p>An element <code>$E</code> named <code>boolean</code> results in the
                              output <code>true</code> or <code>false</code> depending on the result
                              of <phrase diff="chg" at="D"
                                 ><code>xs:boolean(fn:string($E))</code></phrase>.</p>
                        </item>
                        <item>
                           <p>An element <code>$E</code> named <code>number</code> results in the
                              output of the string <phrase diff="chg" at="D">result of
                                    <code>xs:string(xs:double(fn:string($E)))</code></phrase>
                           </p>
                        </item>
                        <item>
                           <p>An element named <code>string</code> results in the output of the
                              string value of the element, enclosed in quotation marks, with any
                              special characters in the string escaped as described below.</p>
                        </item>
                        <item>
                           <p>An element named <code>array</code> results in the output of the
                              children of the <code>array</code> element, each processed by applying
                              these rules recursively: the items in the resulting list are enclosed
                              between square brackets, and separated by commas.</p>
                        </item>
                        <item>
                           <p>An element named <code>map</code> results in the output of a sequence
                              of map entries corresponding to the children of the <code>map</code>
                              element, enclosed between curly braces and separated by commas. Each
                              entry comprises the value of the <code>key</code> attribute of the
                              child element, enclosed in quotation marks and escaped as described
                              below, followed by a colon, followed by the result of processing the
                              child element by applying these rules recursively.</p>
                        </item>
                        <item>
                           <p>Comments, processing instructions, and whitespace text node children
                              of <code>map</code> and <code>array</code> are ignored.</p>
                        </item>
                     </olist>
                     <p>Strings are escaped as follows:</p>
                     <olist>
                        <item>
                           <p>If the attribute <code>escaped="true"</code> is present for a string
                              value, or <code>escaped-key="true"</code> for a key value, then:</p>
                           <olist>
                              <item>
                                 <p>any valid JSON escape sequence present in the string is copied
                                    unchanged to the output;</p>
                              </item>
                              <item>
                                 <p>any invalid JSON escape sequence results in a dynamic error
                                       <xerrorref spec="FO31" class="JS" code="0007"/>;</p>
                              </item>
                              <item>
                                 <p>any unescaped occurrence of quotation mark, backspace,
                                    form-feed, newline, carriage return, tab, <phrase diff="add"
                                       at="T-bug29665">or solidus</phrase> is replaced by
                                       <code>\"</code>, <code>\b</code>, <code>\f</code>,
                                       <code>\n</code>, <code>\r</code>, <code>\t</code>
                                    <phrase diff="add" at="T-bug29665">or <code>\/</code></phrase>
                                    respectively; </p>
                              </item>
                              <item>
                                 <p>any other codepoint in the range 1-31 or 127-159 is replaced by
                                    an escape in the form \uHHHH where HHHH is the upper-case
                                    hexadecimal representation of the codepoint value.</p>
                              </item>
                           </olist>
                        </item>
                        <item>
                           <p>Otherwise (that is, in the absence of the attribute
                                 <code>escaped="true"</code> for a string value, or
                                 <code>escaped-key="true"</code> for a key value):</p>
                           <olist>
                              <item>
                                 <p>any occurrence of backslash is replaced by <code>\\</code></p>
                              </item>
                              <item>
                                 <p>any occurrence of quotation mark, backspace, form-feed, newline,
                                    carriage return, or tab is replaced by <code>\"</code>,
                                       <code>\b</code>, <code>\f</code>, <code>\n</code>,
                                       <code>\r</code>, or <code>\t</code> respectively; </p>
                              </item>
                              <item>
                                 <p>any other codepoint in the range 1-31 or 127-159 is replaced by
                                    an escape in the form <code>\uHHHH</code> where
                                       <code>HHHH</code> is the upper-case hexadecimal
                                    representation of the codepoint value.</p>
                              </item>
                           </olist>
                        </item>
                     </olist>
                  </def>
               </gitem>
               <gitem>
                  <label>Error Conditions</label>
                  <def>
                     <p>A dynamic error is raised <xerrorref spec="FO31" class="JS" code="0005"/> if
                        the value of <code>$options</code> includes an entry whose key is defined in
                        this specification, and whose value is not a permitted value for that
                        key.</p>
                     <p>A dynamic error is raised <xerrorref spec="FO31" class="JS" code="0006"/> if
                        the value of <code>$input</code> is not a document or element node or is not
                        valid according to the schema for the XML representation of JSON<phrase
                           diff="add" at="T-bug29588">, or if a <code>map</code> element has two
                           children whose normalized key values are the same.</phrase></p>
                     <p>A dynamic error is raised <xerrorref spec="FO31" class="JS" code="0007"/> if
                        the value of <code>$input</code> includes a string labeled with
                           <code>escaped="true"</code>, or a key labeled with
                           <code>escaped-key="true"</code>, where the content of the string or key
                        contains an invalid JSON escape sequence: specifically, where it contains a
                        backslash (<code>\</code>) that is not followed by one of the characters
                           <code>"</code>, <code>\</code>, <code>/</code>, <code>b</code>,
                           <code>f</code>, <code>n</code>, <code>r</code>, <code>t</code>, or
                           <code>u</code>, or or where it contains the characters <code>\u</code>
                        not followed by four hexadecimal digits (that is
                        <code>[0-9A-Fa-f]{4}</code>). </p>
                  </def>
               </gitem>
               <gitem>
                  <label>Notes</label>
                  <def>
                     <p role="note">The rule requiring schema validity has a number of consequences,
                        including the following:</p>
                     <olist role="note">
                        <item>
                           <p>The input cannot contain no-namespace attributes, or attributes in the
                              namespace <code>http://www.w3.org/2005/xpath-functions</code>, except
                              where explicitly allowed by the schema. Attributes in other
                              namespaces, however, are ignored.</p>
                        </item>
                        <item>
                           <p>Nodes that do not affect schema validity, such as comments, processing
                              instructions, namespace nodes, and whitespace text node children of
                                 <code>map</code> and <code>array</code>, are ignored.</p>
                        </item>
                        <item>
                           <p>Numeric values are restricted to those that are valid in JSON: the
                              schema disallows positive and negative infinity and NaN.</p>
                        </item>
                        <item>
                           <p>Duplicate keys within a map are disallowed. <phrase diff="add"
                                 at="T-bug29588">Most cases of duplicate keys are prevented by the
                                 rules in the schema; additional cases (where the keys are equal
                                 only after expanding JSON escape sequences) are prevented by the
                                 prose rules of this function. For example, the key values
                                    <code>\n</code> and <code>\u000A</code> are treated as
                                 duplicates even though the rules in the schema do not treat them as
                                 such.</phrase></p>
                        </item>
                     </olist>
                     <p role="note">The rule allowing the top-level element to have a
                           <code>key</code> attribute (which is ignored) allows any element in the
                        output of the <code>fn:json-to-xml</code> function to be processed: for
                        example, it is possible to take a JSON document, convert it to XML, select a
                        subtree based on the value of a <code>key</code> attribute, and then convert
                        this subtree back to JSON, perhaps after a transformation. The rule means
                        that an element with the appropriate name will be accepted if it has been
                        validated against one of the types <code>mapWithinMapType</code>,
                           <code>arrayWithinMapType</code>, <code>stringWithinMapType</code>,
                           <code>numberWithinMapType</code>, <code>booleanWithinMapType</code>, or
                           <code>nullWithinMapType</code>.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Examples</label>
                  <def role="example">
                     <p>The input <code>&lt;array
                           xmlns="http://www.w3.org/2005/xpath-functions"&gt;&lt;number&gt;1&lt;/number&gt;&lt;string&gt;is&lt;/string&gt;&lt;boolean&gt;1&lt;/boolean&gt;&lt;/array&gt;</code>
                        produces the result <code>[1,"is",true]</code>.</p>
                     <p>The input <code>&lt;map
                           xmlns="http://www.w3.org/2005/xpath-functions"&gt;&lt;number
                           key="Sunday"&gt;1&lt;/number&gt;&lt;number
                           key="Monday"&gt;2&lt;/number&gt;&lt;/map&gt;</code> produces the result
                           <code>{"Sunday":1,"Monday":2}</code>.</p>
                  </def>
               </gitem>
            </glist>
         </div2>
         <div2 id="xml-to-json-transformation" diff="add" at="R-bug25196">
            <head>Transforming XML to JSON</head>
            <p>Given an XML structure that does not use the XML representation of JSON defined in
                  <specref ref="json-to-xml-mapping"/>, there are two practical ways to convert it
               to JSON: either perform a transformation to the XML representation of JSON and then
               call the <function>xml-to-json</function> function; or transform it to JSON directly
               by using custom template rules.</p>
            <p>To assist with the second approach, a stylesheet is provided in <specref
                  ref="xml-to-json-stylesheet"/>. This stylesheet includes a function
                  <code>j:xml-to-json</code> which, apart from being in a different namespace, is
               functionally <phrase diff="chg" at="T-bug29602">very similar</phrase> to the
                  <function>xml-to-json</function> function described in the previous section.
                  <phrase diff="chg" at="T-bug29602">(It differs in doing less validation of the
                  input than the function specification requires, and in the details of how special
                  characters are escaped.)</phrase> The implementation of the function is exposed,
               using template rules to perform a recursive descent of the supplied input, and the
               behavior of the function can therefore be customized (typically by importing the
               stylesheet and adding additional template rules) to handle arbitrary XML input.</p>
            <p>The stylesheet is provided under the W3C software license for the convenience of
               users. There is no requirement for any conformant XSLT processor to make this
               stylesheet available. Processors <rfc2119>may</rfc2119> implement the
                  <function>xml-to-json</function> function by invoking this stylesheet <phrase
                  diff="chg" at="T-bug29602">(adapted to achieve full conformance)</phrase>, but
               there is no requirement to do so.</p>
         </div2>
      </div1>
      <div1 id="diagnostics">
         <head>Diagnostics</head>
         <div2 id="message">
            <head>Messages</head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="message">
               <e:in-category name="instruction"/>
               <e:attribute name="select">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="terminate">
                  <e:attribute-value-template>
                     <e:data-type name="boolean"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="error-code">
                  <e:attribute-value-template>
                     <e:data-type name="eqname"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:message</elcode> instruction sends a message in an <termref
                  def="dt-implementation-defined">implementation-defined</termref> way. The
                  <elcode>xsl:message</elcode> instruction causes the creation of a new document,
               which is typically serialized and output to an <termref
                  def="dt-implementation-defined">implementation-defined</termref> destination. The
               result of the <elcode>xsl:message</elcode> instruction is an empty sequence.</p>
            <p>The content of the message may be specified by using either or both of the optional
                  <code>select</code> attribute and the <termref def="dt-sequence-constructor"
                  >sequence constructor</termref> that forms the content of the
                  <elcode>xsl:message</elcode> instruction.</p>
            <p>If the <elcode>xsl:message</elcode> instruction contains a <termref
                  def="dt-sequence-constructor">sequence constructor</termref>, then the sequence
               obtained by evaluating this sequence constructor is used to construct the content of
               the new document node, as described in <specref ref="constructing-complex-content"
               />.</p>
            <p>If the <elcode>xsl:message</elcode> instruction has a <code>select</code> attribute,
               then the value of the attribute <rfc2119>must</rfc2119> be an XPath expression. The
               effect of the <elcode>xsl:message</elcode> instruction is then the same as if a
               single <elcode>xsl:copy-of</elcode> instruction with this <code>select</code>
               attribute were added to the start of the <termref def="dt-sequence-constructor"
                  >sequence constructor</termref>.</p>
            <p>If the <elcode>xsl:message</elcode> instruction has no content and no
                  <code>select</code> attribute, then an empty message is produced.</p>
            <imp-def-feature id="idf-err-messageformat">The destination and formatting of messages
               written using the <elcode>xsl:message</elcode> instruction are <termref
                  def="dt-implementation-defined"/>.</imp-def-feature>
            <p>The tree produced by the <elcode>xsl:message</elcode> instruction is not technically
               a <termref def="dt-final-result-tree">final result tree</termref>. The tree has no
               URI and processors are not <rfc2119>required</rfc2119> to make the tree accessible to
               applications.</p>
            <note>
               <p>In many cases, the XML document produced using <elcode>xsl:message</elcode> will
                  consist of a document node owning a single text node. However, it may contain a
                  more complex structure.</p>
            </note>
            <note>
               <p>An implementation might implement <elcode>xsl:message</elcode> by popping up an
                  alert box or by writing to a log file. Because the order of execution of
                  instructions is implementation-defined, the order in which such messages appear is
                  not predictable.</p>
            </note>
            <p>The <code>terminate</code> attribute is interpreted as an <termref
                  def="dt-attribute-value-template">attribute value template</termref>.</p>
            <p>If the <termref def="dt-effective-value">effective value</termref> of the
                  <code>terminate</code> attribute is <code>yes</code>, then the <termref
                  def="dt-processor">processor</termref>
               <rfc2119>must</rfc2119>
               <phrase diff="chg" at="B">signal a <termref def="dt-dynamic-error"><phrase diff="del"
                        at="M">non-recoverable</phrase> dynamic error</termref></phrase> after
               sending the message. <phrase diff="add" at="B">This error may be caught in the same
                  way as any other dynamic error using <elcode>xsl:catch</elcode>.</phrase> The
               default value is <code>no</code>. Note that because the order of evaluation of
               instructions is <termref def="dt-implementation-dependent"
                  >implementation-dependent</termref>, this gives no guarantee that any particular
               instruction will or will not be evaluated before processing terminates.</p>
            <p>The optional <code>error-code</code> attribute <phrase diff="add" at="S">(also
                  interpreted as an <termref def="dt-attribute-value-template"/>)</phrase> may be
               used to indicate the error code associated with the message. This may be used
               irrespective of the value of <code>terminate</code>. The <phrase diff="add" at="S"
                     ><termref def="dt-effective-value">effective value</termref> of the </phrase>
               error code attribute is expected to be an <phrase diff="chg" at="K"><termref
                     def="dt-eqname">EQName</termref></phrase>. If no error code is specified, or if
               the <phrase diff="add" at="S">effective</phrase> value is not a valid EQName, the
               error code will have local part <code>XTMM9000</code> and namespace URI
                  <code>http://www.w3.org/2005/xqt-errors</code>. User-defined error codes
                  <rfc2119>should</rfc2119> be in a namespace other than
                  <code>http://www.w3.org/2005/xqt-errors</code>. When the value of
                  <code>terminate</code> is <code>yes</code>, the error code may be matched in an
                  <elcode>xsl:catch</elcode> element to catch the error and cause processing to
               continue normally.</p>
            <p>
               <error spec="XT" type="dynamic" class="MM" code="9000"><p>When a transformation is
                     terminated by use of <code>&lt;xsl:message terminate="yes"/&gt;</code>, the
                     effect is the same as when a <termref def="dt-dynamic-error"><phrase diff="del"
                           at="M">non-recoverable</phrase> dynamic error</termref> occurs during the
                     transformation. <phrase diff="add" at="B">The default error code is
                           <code>XTMM9000</code>; this may be overridden using the
                           <code>error-code</code> attribute of the <elcode>xsl:message</elcode>
                        instruction.</phrase></p></error>
            </p>
            <example>
               <head>Localizing Messages</head>
               <p>One convenient way to do localization is to put the localized information (message
                  text, etc.) in an XML document, which becomes an additional input file to the
                     <termref def="dt-stylesheet">stylesheet</termref>. For example, suppose
                  messages for a language <code>
                     <var>L</var>
                  </code> are stored in an XML file <code>resources/<var>L</var>.xml</code> in the
                  form:</p>
               <eg role="xml" xml:space="preserve">&lt;messages&gt;
  &lt;message name="problem"&gt;A problem was detected.&lt;/message&gt;
  &lt;message name="error"&gt;An error was detected.&lt;/message&gt;
&lt;/messages&gt;
</eg>
               <p>Then a stylesheet could use the following approach to localize messages:</p>
               <eg role="xslt-declarations" xml:space="preserve">&lt;xsl:param name="lang" select="'en'"/&gt;
&lt;xsl:variable name="messages"
  select="document(concat('resources/', $lang, '.xml'))/messages"/&gt;

&lt;xsl:template name="localized-message"&gt;
  &lt;xsl:param name="name"/&gt;
  &lt;xsl:message select="string($messages/message[@name=$name])"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template name="problem"&gt;
  &lt;xsl:call-template name="localized-message"&gt;
    &lt;xsl:with-param name="name"&gt;problem&lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <p>Any <termref def="dt-dynamic-error">dynamic error</termref> that occurs while
               evaluating the <code>select</code> expression or the contained <termref
                  def="dt-sequence-constructor">sequence constructor</termref>, and any <termref
                  def="dt-serialization-error">serialization error</termref> that occurs while
               processing the result, <phrase diff="chg" at="Q">does not cause the transformation to
                  fail; at worst, it means that no message is output, or that the only message that
                  is output is one that relates to the error that occurred</phrase>.</p>
            <note>
               <p>An example of such an error is the serialization error that occurs when processing
                  the instruction <code>&lt;xsl:message select="@code"/&gt;</code> (on the grounds
                  that free-standing attributes cannot be serialized). Making such errors
                  recoverable means that it is implementation-defined whether or not they are
                  signaled to the user and whether they cause termination of the transformation. If
                  the processor chooses to recover from the error, the content of any resulting
                  message is implementation-dependent.</p>
               <p>One possible recovery action is to include a description of the error in the
                  generated message text.</p>
            </note>
         </div2>
         <div2 id="assertions" diff="add" at="L">
            <head>Assertions</head>
            <p>The <elcode>xsl:assert</elcode> instruction is used to assert that the value of a
               particular expression is true; if the value of the expression is false, and
               assertions are enabled, then a dynamic error occurs.</p>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="assert">
               <e:in-category name="instruction"/>
               <e:attribute name="test" required="yes">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="select">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="error-code">
                  <e:attribute-value-template>
                     <e:data-type name="eqname"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>By default, assertions are <phrase diff="chg" at="S-bug28933">disabled</phrase>.</p>
            <p>An implementation <rfc2119>must</rfc2119> provide an external mechanism to enable or
               disable assertion checking. This may work either statically or dynamically, and may
               be at the level of the stylesheet as a whole, or at the level of an individual
               package, or otherwise. The detail of such mechanisms is <termref
                  def="dt-implementation-defined"/>.</p>
            <imp-def-feature id="idf-api-enablingassertions">The detail of any external mechanism
               allowing a processor to enable or disable checking of assertions is <termref
                  def="dt-implementation-defined"/>.</imp-def-feature>
            <p>If assertion checking is enabled, the instruction is evaluated as follows:</p>
            <olist>
               <item>
                  <p>The expression in the <code>test</code> attribute is evaluated. If the
                     effective boolean value of the result is <code>true</code>, the assertion
                     succeeds, and no further action is taken. If the effective boolean value is
                     false, or if a dynamic error occurs during evaluation of the expression, then
                     the assertion fails.</p>
               </item>
               <item>
                  <p>If the assertion fails, then the effect of the instruction is governed by the
                     rules for evaluation of an <elcode>xsl:message</elcode> instruction with the
                     same <code>select</code> attribute, <code>error-code</code> attribute, and
                     contained <termref def="dt-sequence-constructor"/>, and with the value
                        <code>terminate="yes"</code>. However, the default error code if the
                        <code>error-code</code> attribute is omitted is <code>XTMM9001</code> rather
                     than <code>XTMM9000</code>.</p>
                  <note>
                     <p>To the extent that the behavior of <elcode>xsl:message</elcode> is <termref
                           def="dt-implementation-defined"/>, this rule does not prevent an
                        implementation treating <elcode>xsl:assert</elcode> and
                           <elcode>xsl:message</elcode> differently.</p>
                  </note>
                  <note>
                     <p diff="add" at="S-bug28764">If evaluation of the <code>test</code> expression
                        fails with a dynamic error, the effect is exactly the same as if the
                        evaluation returns <code>false</code>, including the fact that the
                        instruction fails with error code <code>XTMM9001</code>.</p>
                  </note>
               </item>
               <item>
                  <p diff="add" at="S-bug28763">If an assertion fails, then the following sibling
                     instructions of the <elcode>xsl:assert</elcode> instruction are not
                     evaluated.</p>
                  <note>
                     <p diff="add" at="S-bug28763">This means that <elcode>xsl:assert</elcode> can
                        be used (rather like <elcode>xsl:if</elcode> and
                        <elcode>xsl:choose</elcode>) to prevent subsequent instructions from
                        executing if a particular precondition is not true, which might be useful if
                        the subsequent instructions have side-effects (for example, by calling
                        extension functions) or if they can fail in uncatchable ways (for example,
                        non-terminating recursion). It is worth noting that there are limits to this
                        guarantee. It does not ensure, for example, that when an assertion within a
                        template fails, the following siblings of the
                           <elcode>xsl:call-template</elcode> instruction that invokes that template
                        will not be evaluated; nor does it ensure that if an assertion fails while
                        processing the first item of a sequence using <elcode>xsl:for-each</elcode>,
                        then subsequent items in the sequence will not be processed. </p>
                  </note>
               </item>
            </olist>
            <p>
               <error spec="XT" type="dynamic" class="MM" code="9001"><p>When a transformation is
                     terminated by use of <elcode>xsl:assert</elcode>, the effect is the same as
                     when a <termref def="dt-dynamic-error"><phrase diff="del" at="M"
                           >non-recoverable</phrase> dynamic error</termref> occurs during the
                     transformation. The default error code is <code>XTMM9001</code>; this may be
                     overridden using the <code>error-code</code> attribute of the
                        <elcode>xsl:assert</elcode> instruction.</p></error>
            </p>
            <p>As with any other dynamic error, an error caused by an assertion failing may be
               trapped using <elcode>xsl:try</elcode>: see <specref ref="try-catch"/>.</p>
            <p>The result of the <elcode>xsl:assert</elcode> instruction is an empty sequence.</p>
            <example diff="add" at="M">
               <head>Using Assertions with Static Parameters</head>
               <p>The following example shows a stylesheet function that checks that the value of
                  its supplied argument is in range. The check is performed only if the <termref
                     def="dt-static-parameter"/>
                  <code>$DEBUG</code> is set to true.</p>
               <eg role="xslt-declarations" xml:space="preserve">
&lt;xsl:param name="DEBUG" as="xs:boolean" select="false()" 
           static="yes" required="no"/&gt;
&lt;xsl:function name="f:days-elapsed" as="xs:integer"&gt;
  &lt;xsl:param name="date" as="xs:date"/&gt;
  &lt;xsl:assert use-when="$DEBUG" test="$date lt current-date()"/&gt;
  &lt;xsl:sequence select="(current-date() - $since) 
                            div xs:dayTimeDuration('PT1D')"/&gt;
&lt;/xsl:function&gt;</eg>
            </example>
            <note>
               <p>Implementations should avoid optimizing <elcode>xsl:assert</elcode> instructions
                  away. As a guideline, if the result of a sequence constructor is required by the
                  transformation, the implementation should ensure that all
                     <elcode>xsl:assert</elcode> instructions in that sequence constructor are
                  evaluated. Conversely, if the result of a sequence constructor is not required by
                  the transformation, its <elcode>xsl:assert</elcode> instructions should not be
                  evaluated.</p>
               <p>This guidance is not intended to prevent optimizations such as lazy evaluation,
                  where evaluation of a sequence constructor may finish early, as soon as enough
                  information is available to evaluate the containing instruction.</p>
            </note>
            <p>An implementation <rfc2119>may</rfc2119> provide a user option allowing a processor
               to treat assertions as being true without explicit checking. This option
                  <rfc2119>must not</rfc2119> be enabled by default. If such an option is in force,
               the effect of any assertion not being true is <termref
                  def="dt-implementation-dependent"/>.</p>
            <note>
               <p>For example, given the assertion <code>&lt;xsl:assert
                     test="count(//title)=1"/&gt;</code>, a processor might generate code for the
                  expression <code>&lt;xsl:value-of select="//title"/&gt;</code> that stops
                  searching for <code>title</code> elements after finding the first one. In the
                  event that the source document contains more than one <code>title</code>,
                  execution of the stylesheet may fail in arbitrary ways, or it may produce
                  incorrect output.</p>
            </note>
         </div2>
      </div1>
      <div1 id="extension">
         <head>Extensibility and Fallback</head>
         <p>XSLT allows two kinds of extension, extension instructions and extension functions.</p>
         <p>
            <termdef id="dt-extension-instruction" term="extension instruction">An <term>extension
                  instruction</term> is an element within a <termref def="dt-sequence-constructor"
                  >sequence constructor</termref> that is in a namespace (not the <termref
                  def="dt-xslt-namespace">XSLT namespace</termref>) designated as an extension
               namespace.</termdef>
         </p>
         <p diff="chg" at="T-bug29441">
            <termdef id="dt-extension-function" term="extension function">An <term>extension
                  function</term> is a named function introduced to the static or dynamic context by
               mechanisms outside the scope of this specification.</termdef></p>
         <p>This specification does not define any mechanism for creating or binding implementations
            of <termref def="dt-extension-instruction">extension instructions</termref> or <termref
               def="dt-extension-function">extension functions</termref>, and it is not
               <rfc2119>required</rfc2119> that implementations support any such mechanism. Such
            mechanisms, if they exist, are <termref def="dt-implementation-defined"
               >implementation-defined</termref>. Therefore, an XSLT stylesheet that must be
            portable between XSLT implementations cannot rely on particular extensions being
            available. XSLT provides mechanisms that allow an XSLT stylesheet to determine whether
            the implementation makes particular extensions available, and to specify what happens if
            those extensions are not available. If an XSLT stylesheet is careful to make use of
            these mechanisms, it is possible for it to take advantage of extensions and still retain
            portability.</p>
         <p diff="add" at="S-bug29081">
            <error spec="XT" type="static" class="SE" code="0085"><p>It is a <termref
                     def="dt-static-error"/> to use a <termref def="dt-reserved-namespace"/> in the
                  name of any <termref def="dt-extension-function"/> or <termref
                     def="dt-extension-instruction"/>, other than a function or instruction defined
                  in this specification or in a normatively referenced specification. It is a
                     <termref def="dt-static-error"/> to use a prefix bound to a reserved namespace
                  in the <code>[xsl:]extension-element-prefixes</code> attribute. </p></error>
         </p>
         <div2 id="extension-functions">
            <head>Extension Functions</head>
            <p>The set of functions that can be called from a <xnt
                  xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                  ref="prod-xpath30-FunctionCall" xlink:type="simple">FunctionCall</xnt> within an
               XPath <termref def="dt-expression">expression</termref> may include one or more
                  <termref def="dt-extension-function">extension functions</termref>. The <termref
                  def="dt-expanded-qname">expanded QName</termref> of an extension function always
               has a non-null namespace URI<phrase diff="add" at="S-bug29081">, which <rfc2119>must
                     not</rfc2119> be the URI of a <termref def="dt-reserved-namespace"
               /></phrase>.</p>
            <note diff="add" at="T-bug29441">
               <p>The definition of the term <termref def="dt-extension-function"/> is written to
                  exclude user-written <termref def="dt-stylesheet-function">stylesheet
                     functions</termref>, constructor functions for built-in and user-defined types,
                  functions in the <code>fn</code>, <code>math</code>, <code>map</code>, and
                     <code>array</code> namespaces, anonymous XPath inline functions, <termref
                     def="dt-map">maps</termref> and arrays (see <specref ref="arrays"/>), and
                  partial function applications (including partial applications of extension
                  functions). It also excludes functions obtained by invoking XPath-defined
                  functions such as <xfunction spec="FO31">load-xquery-module</xfunction>. The
                  definition allows extension functions to be discovered at evaluation time
                  (typically using <xfunction>function-lookup</xfunction>) rather than necessarily
                  being known statically. </p>
               <p>Technically, the definition of extension functions excludes anonymous functions
                  obtained by calling or partially applying other extension functions. Since such
                  functions are by their nature implementation-defined, they may however share some
                  of the characteristics of extension functions.</p>
            </note>
            <div3 id="func-function-available">
               <head>fn:function-available</head>
               <glist>
                  <gitem>
                     <label>Summary</label>
                     <def>
                        <p>Determines whether a particular function is or is not available for use.
                           The function is particularly useful for calling within an
                              <code>[xsl:]use-when</code> attribute (see <specref
                              ref="conditional-inclusion"/>) to test whether a particular <termref
                              def="dt-extension-function"/> is available.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Signatures</label>
                     <def>
                        <example role="signature">
                           <proto name="function-available" return-type="xs:boolean" isOp="no"
                              prefix="fn" returnEmptyOk="no" returnSeq="no" returnVaries="no"
                              isSchema="no" isDatatype="no" isSpecial="no">
                              <arg name="function-name" type="xs:string"/>
                           </proto>
                        </example>
                        <example role="signature">
                           <proto name="function-available" return-type="xs:boolean" isOp="no"
                              prefix="fn" returnEmptyOk="no" returnSeq="no" returnVaries="no"
                              isSchema="no" isDatatype="no" isSpecial="no">
                              <arg name="function-name" type="xs:string"/>
                              <arg name="arity" type="xs:integer"/>
                           </proto>
                        </example>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Properties</label>
                     <def>
                        <p>This function is <xtermref spec="FO30" ref="dt-deterministic"
                              >deterministic</xtermref>, <xtermref spec="FO30"
                              ref="dt-context-dependent">context-dependent</xtermref>, and <xtermref
                              spec="FO30" ref="dt-focus-independent">focus-independent</xtermref>.
                           It depends on namespaces, and known function signatures. </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Rules</label>
                     <def>
                        <p>A function is said to be available within an XPath expression if it is
                           present in the <xtermref spec="XP30" ref="dt-known-func-signatures"
                              >statically known function signatures</xtermref> for that expression
                           (see <specref ref="static-context"/>). Functions in the static context
                           are uniquely identified by the name of the function (a QName) in
                           combination with its <termref def="dt-arity">arity</termref>.</p>
                        <p>The value of the <code>$function-name</code> argument
                              <rfc2119>must</rfc2119> be a string containing an <termref
                              def="dt-eqname">EQName</termref>. The lexical QName is expanded into
                           an <termref def="dt-expanded-qname">expanded QName</termref> using the
                           namespace declarations in scope for the <termref def="dt-expression"
                              >expression</termref>. If the value is an unprefixed lexical QName,
                           then the <termref def="dt-standard-function-namespace">standard function
                              namespace</termref> is used in the expanded QName.</p>
                        <p>The two-argument version of the <function>function-available</function>
                           function returns true if and only if there is an available function whose
                           name matches the value of the <code>$function-name</code> argument and
                           whose <termref def="dt-arity">arity</termref> matches the value of the
                              <code>$arity</code> argument. </p>
                        <p>The single-argument version of the
                              <function>function-available</function> function returns true if and
                           only if there is at least one available function (with some arity) whose
                           name matches the value of the <code>$function-name</code> argument. </p>
                        <p><phrase diff="chg" at="D">When the containing expression is evaluated
                              with <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility
                                 mode</termref> set to true</phrase>, the
                              <function>function-available</function> function returns false in
                           respect of a function name and arity for which no implementation is
                           available (other than the fallback error function that raises a dynamic
                           error whenever it is called). This means that it is possible (as in XSLT
                           1.0) to use logic such as the following to test whether a function is
                           available before calling it:</p>
                        <example>
                           <head>Calling an extension function with backwards compatibility
                              enabled</head>
                           <eg xml:space="preserve">
&lt;summary xsl:version="1.0"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="function-available('my:summary')"&gt;
      &lt;xsl:value-of select="my:summary()"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:text&gt;Summary not available&lt;/xsl:text&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/summary&gt;</eg>
                        </example>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Error Conditions</label>
                     <def>
                        <p>
                           <error spec="XT" type="dynamic" class="DE" code="1400"><p diff="chg"
                                 at="K">It is a <termref def="dt-dynamic-error"><phrase diff="del"
                                       at="N">non-recoverable</phrase> dynamic error</termref> if
                                 the argument <error.extra>passed to the
                                       <function>function-available</function>
                                    function</error.extra> does not evaluate to a string that is a
                                 valid <termref def="dt-eqname">EQName</termref>, or if the value is
                                 a <termref def="dt-lexical-qname">lexical QName</termref> with a
                                 prefix for which no namespace declaration is present in the static
                                 context. If the processor is able to detect the error statically
                                 (for example, when the argument is supplied as a string literal),
                                 then the processor <rfc2119>may</rfc2119> optionally signal this as
                                 a <termref def="dt-static-error">static
                              error</termref>.</p></error>
                        </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Notes</label>
                     <def>
                        <p role="note">The fact that a function with a given name is available gives
                           no guarantee that any particular call on the function will be successful.
                           For example, it is not possible to determine the types of the arguments
                           expected.</p>
                        <p role="note">The introduction of the
                              <xfunction>function-lookup</xfunction> function in XPath 3.0 reduces
                           the need for <function>function-available</function>, since
                              <xfunction>function-lookup</xfunction> not only tests whether a
                           function is available, but also returns a function item that enables it
                           to be dynamically called.</p>
                        <p role="note">If a function is present in the static context but with no
                           useful functionality (for example, if the system has been configured for
                           security reasons so that
                              <xfunction>available-environment-variables</xfunction> returns no
                           information), then <function>function-available</function> when applied
                           to that function should return false.</p>
                        <p role="note">It is not necessary that there be a direct equivalence
                           between the results of <function>function-available</function> and
                              <xfunction>function-lookup</xfunction> in all cases. For example,
                           there may be <termref def="dt-extension-function">extension
                              functions</termref> whose side-effects are such that for security
                           reasons, dynamic calls to the function are disallowed;
                              <xfunction>function-lookup</xfunction> might then not provide access
                           to the function. The main use-case for
                              <function>function-available</function>, by contrast, is for use in
                              <code>[xsl:]use-when</code> conditions to test whether static calls on
                           the function are possible.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Examples</label>
                     <def role="example">
                        <example>
                           <head>Stylesheet portable between XSLT 1.0, XSLT 2.0, and XSLT 3.0</head>
                           <p>A stylesheet that is designed to use XSLT 2.0 facilities when running
                              under an <phrase diff="chg" at="F">XSLT 2.0 or XSLT 3.0
                                 processor</phrase>, but to fall back to XSLT 1.0 capabilities when
                              not, might be written using the code:</p>
                           <eg xml:space="preserve">
&lt;out xsl:version="2.0"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="function-available('matches')"&gt;
      &lt;xsl:value-of select="matches(/doc/title, '[a-z]*')"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:value-of select="string-length(
	        translate(/doc/title, 'abcdefghijklmnopqrstuvwxyz', '')) = 0"/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/out&gt;</eg>
                           <p>Here an <phrase diff="chg" at="F">XSLT 2.0 or XSLT 3.0</phrase>
                              processor will always take the <elcode>xsl:when</elcode> branch, while
                              a 1.0 processor will follow the <elcode>xsl:otherwise</elcode> branch.
                              The single-argument version of the
                                 <function>function-available</function> function is used here,
                              because that is the only version available in XSLT 1.0. Under the
                              rules of XSLT 1.0, the call on the <code>matches</code> function is
                              not an error, because it is never evaluated.</p>
                        </example>
                        <example>
                           <head>Stylesheet portable between XSLT 3.0 and a future version of
                              XSLT</head>
                           <p>A stylesheet that is designed to use facilities in some future XSLT
                              version when they are available, but to fall back to <phrase
                                 diff="chg" at="F">XSLT 2.0 or XSLT 3.0</phrase> capabilities when
                              not, might be written using code such as the following. This
                              hypothesizes the availability in some future version of a function
                                 <code>pad</code> which pads a string to a fixed length with
                              spaces:</p>
                           <eg xml:space="preserve">
 &lt;xsl:value-of select="pad(/doc/title, 10)" 
               use-when="function-available('pad', 2)"/&gt;
 &lt;xsl:value-of select="concat(/doc/title, string-join(
                          for $i in 1 to 10 - string-length(/doc/title) 
						  return ' ', ''))"
               use-when="not(function-available('pad', 2))"/&gt;
 </eg>
                           <p>In this case the two-argument version of
                                 <function>function-available</function> is used, because there is
                              no requirement for this code to run under XSLT 1.0.</p>
                        </example>
                     </def>
                  </gitem>
               </glist>
            </div3>
            <div3 id="calling-extension-functions">
               <head>Calling Extension Functions</head>
               <p>If the function name used in a <xnt xmlns:xlink="http://www.w3.org/1999/xlink"
                     spec="XP30" ref="prod-xpath30-FunctionCall" xlink:type="simple"
                     >FunctionCall</xnt> within an XPath <termref def="dt-expression"
                     >expression</termref> identifies an extension function, then to evaluate the
                     <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                     ref="prod-xpath30-FunctionCall" xlink:type="simple">FunctionCall</xnt>, the
                  processor will first evaluate each of the arguments in the <xnt
                     xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                     ref="prod-xpath30-FunctionCall" xlink:type="simple">FunctionCall</xnt>. If the
                  processor has information about the datatypes expected by the extension function,
                  then it <rfc2119>may</rfc2119> perform any necessary type conversions between the
                  XPath datatypes and those defined by the implementation language. If multiple
                  extension functions are available with the same name, the processor
                     <rfc2119>may</rfc2119> decide which one to invoke based on the number of
                  arguments, the types of the arguments, or any other criteria. The result returned
                  by the implementation is returned as the result of the function call, again after
                  any necessary conversions between the datatypes of the implementation language and
                  those of XPath. The details of such type conversions are outside the scope of this
                  specification.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1420"><p>It is a <termref
                           def="dt-dynamic-error"><phrase diff="del" at="M">non-recoverable</phrase>
                           dynamic error</termref> if the arguments supplied to a call on an
                        extension function do not satisfy the rules defined for that particular
                        extension function, or if the extension function reports an error, or if the
                        result of the extension function cannot be converted to an XPath
                     value.</p></error>
               </p>
               <note>
                  <p>Implementations may also provide mechanisms allowing extension functions to
                     report recoverable dynamic errors, or to execute within an environment that
                     treats some or all of the errors listed above as recoverable.</p>
               </note>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1425"><p><phrase diff="chg"
                           at="D">When the containing element is processed with <termref
                              def="dt-xslt-10-behavior">XSLT 1.0 behavior</termref>,</phrase> it is
                        a <termref def="dt-dynamic-error"><phrase diff="del" at="M"
                              >non-recoverable</phrase> dynamic error</termref> to evaluate an
                        extension function call if no implementation of the extension function is
                        available.</p></error>
               </p>
               <note>
                  <p>When <phrase diff="chg" at="D">XSLT 1.0 behavior</phrase> is not enabled, this
                     is a static error <xerrorref spec="XP30" class="ST" code="0017"/>.</p>
               </note>
               <note>
                  <p>There is no prohibition on calling extension functions that have side-effects
                     (for example, an extension function that writes data to a file). However, the
                     order of execution of XSLT instructions is not defined in this specification,
                     so the effects of such functions are unpredictable.</p>
               </note>
               <p>Implementations are not <rfc2119>required</rfc2119> to perform full validation of
                  values returned by extension functions. It is an error for an extension function
                  to return a string containing characters that are not permitted in XML, but the
                  consequences of this error are <termref def="dt-implementation-defined"
                     >implementation-defined</termref>. The implementation <rfc2119>may</rfc2119>
                  raise an error, <rfc2119>may</rfc2119> convert the string to a string containing
                  valid characters only, or <rfc2119>may</rfc2119> treat the invalid characters as
                  if they were permitted characters.</p>
               <imp-def-feature id="idf-ext-nonxmlstring">The effect of an extension function
                  returning a string containing characters that are not permitted in XML is
                  implementation-defined.</imp-def-feature>
               <note>
                  <p>The ability to execute extension functions represents a potential security
                     weakness, since untrusted stylesheets may invoke code that has privileged
                     access to resources on the machine where the <termref def="dt-processor"
                        >processor</termref> executes. Implementations may therefore provide
                     mechanisms that restrict the use of extension functions by untrusted
                     stylesheets.</p>
               </note>
               <p>All observations in this section regarding the errors that can occur when invoking
                  extension functions apply equally when invoking <termref
                     def="dt-extension-instruction">extension instructions</termref>.</p>
            </div3>
            <div3 id="external-objects">
               <head>External Objects</head>
               <p>An implementation <rfc2119>may</rfc2119> allow an extension function to return an
                  object that does not have any natural representation in the XDM data model,
                  whether as an atomic value, a node, <phrase diff="add" at="C">or a function
                     item</phrase>. For example, an extension function <code>sql:connect</code>
                  might return an object that represents a connection to a relational database; the
                  resulting connection object might be passed as an argument to calls on other
                  extension functions such as <code>sql:insert</code> and
                  <code>sql:select</code>.</p>
               <p>The way in which such objects are represented in the type system is <termref
                     def="dt-implementation-defined">implementation-defined</termref>. They might be
                  represented by a completely new datatype, or they might be mapped to existing
                  datatypes such as <code>integer</code>, <code>string</code>, or
                     <code>anyURI</code>.</p>
               <imp-def-feature id="idf-ext-externalobjects">The way in which external objects are
                  represented in the type system is implementation-defined.</imp-def-feature>
            </div3>
            <div3 id="func-type-available">
               <head>fn:type-available</head>
               <glist>
                  <gitem>
                     <label>Summary</label>
                     <def>
                        <p>Used to control how a stylesheet behaves if a particular schema type is
                           or is not available in the static context.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Signature</label>
                     <def>
                        <example role="signature">
                           <proto name="type-available" return-type="xs:boolean" isOp="no"
                              prefix="fn" returnEmptyOk="no" returnSeq="no" returnVaries="no"
                              isSchema="no" isDatatype="no" isSpecial="no">
                              <arg name="type-name" type="xs:string"/>
                           </proto>
                        </example>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Properties</label>
                     <def>
                        <p>This function is <xtermref spec="FO30" ref="dt-deterministic"
                              >deterministic</xtermref>, <xtermref spec="FO30"
                              ref="dt-context-dependent">context-dependent</xtermref>, and <xtermref
                              spec="FO30" ref="dt-focus-independent">focus-independent</xtermref>.
                           It depends on namespaces, and schema definitions. </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Rules</label>
                     <def>
                        <p>A schema type (that is, a simple type or a complex type) is said to be
                           available within an XPath expression if it is a type definition that is
                           present in the <xtermref spec="XP30" ref="dt-is-types">in-scope schema
                              types</xtermref> for that expression (see <specref
                              ref="static-context"/>). This includes built-in types, types imported
                           using <elcode>xsl:import-schema</elcode>, and extension types defined by
                           the implementation.</p>
                        <p>The value of the <code>$type-name</code> argument <rfc2119>must</rfc2119>
                           be a string containing an <phrase diff="chg" at="K"><termref
                                 def="dt-eqname">EQName</termref></phrase>. The EQName is expanded
                           into an <termref def="dt-expanded-qname">expanded QName</termref> using
                           the namespace declarations in scope for the <termref def="dt-expression"
                              >expression</termref>. If the value is an unprefixed lexical QName,
                           then the default namespace is used in the expanded QName.</p>
                        <p>The function returns true if and only if there is an available type whose
                           name matches the value of the <code>$type-name</code> argument. </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Error Conditions</label>
                     <def>
                        <p diff="chg" at="K">
                           <error spec="XT" type="dynamic" class="DE" code="1428"><p>It is a
                                    <termref def="dt-dynamic-error"><phrase diff="del" at="N"
                                       >non-recoverable</phrase> dynamic error</termref> if the
                                 argument <error.extra>passed to the
                                       <function>type-available</function> function</error.extra>
                                 does not evaluate to a string that is a valid <termref
                                    def="dt-eqname">EQName</termref>, or if the value is a <termref
                                    def="dt-lexical-qname">lexical QName</termref> with a prefix for
                                 which no namespace declaration is present in the static context. If
                                 the processor is able to detect the error statically (for example,
                                 when the argument is supplied as a string literal), then the
                                 processor <rfc2119>may</rfc2119> optionally signal this as a
                                    <termref def="dt-static-error">static
                              error</termref>.</p></error>
                        </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Notes</label>
                     <def>
                        <p role="note">The <function>type-available</function> function is of
                           limited use within an <code>[xsl:]use-when</code> expression, because the
                           static context for the expression does not include any user-defined
                           types.</p>
                     </def>
                  </gitem>
               </glist>
            </div3>
         </div2>
         <div2 id="extension-instruction">
            <head>Extension Instructions</head>
            <p>
               <termdef id="dt-extension-namespace" term="extension namespace">The <termref
                     def="dt-extension-instruction">extension instruction</termref> mechanism allows
                  namespaces to be designated as <term>extension namespaces</term>. When a namespace
                  is designated as an extension namespace and an element with a name from that
                  namespace occurs in a <termref def="dt-sequence-constructor">sequence
                     constructor</termref>, then the element is treated as an <termref
                     def="dt-instruction">instruction</termref> rather than as a <termref
                     def="dt-literal-result-element">literal result element</termref>.</termdef> The
               namespace determines the semantics of the instruction.</p>
            <note>
               <p>Since an element that is a child of an <elcode>xsl:stylesheet</elcode> element is
                  not occurring <emph>in a <termref def="dt-sequence-constructor">sequence
                        constructor</termref>
                  </emph>, <termref def="dt-data-element">user-defined data elements</termref> (see
                     <specref ref="user-defined-top-level"/>) are not extension elements as defined
                  here, and nothing in this section applies to them.</p>
            </note>
            <div3 id="designating-extension-namespace">
               <head>Designating an Extension Namespace</head>
               <p>A namespace is designated as an extension namespace by using an
                     <code>[xsl:]extension-element-prefixes</code> attribute on an element in the
                  stylesheet (see <specref ref="standard-attributes"/>). The attribute
                     <rfc2119>must</rfc2119> be in the XSLT namespace only if its parent element is
                     <emph>not</emph> in the XSLT namespace. The value of the attribute is a
                  whitespace-separated list of namespace prefixes. The namespace bound to each of
                  the prefixes is designated as an extension namespace.</p>
               <p>The default namespace (as declared by <code>xmlns</code>) may be designated as an
                  extension namespace by including <code>#default</code> in the list of namespace
                  prefixes.</p>
               <p diff="add" at="S-bug29081">A <termref def="dt-reserved-namespace"/> cannot be
                  designated as an extension namespace: see <errorref spec="XT" class="SE"
                     code="0085"/>.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="1430"><p>It is a <termref
                           def="dt-static-error">static error</termref> if there is no namespace
                        bound to the prefix on the element bearing the
                           <code>[xsl:]extension-element-prefixes</code> attribute or, when
                           <code>#default</code> is specified, if there is no default
                     namespace.</p></error>
               </p>
               <p>The designation of a namespace as an extension namespace is effective for the
                  element bearing the <code>[xsl:]extension-element-prefixes</code> attribute and
                  for all descendants of that element within the same stylesheet module.</p>
            </div3>
            <div3 id="func-element-available">
               <head>fn:element-available</head>
               <glist>
                  <gitem>
                     <label>Summary</label>
                     <def>
                        <p>Determines whether a particular instruction is or is not available for
                           use. The function is particularly useful for calling within an
                              <code>[xsl:]use-when</code> attribute (see <specref
                              ref="conditional-inclusion"/>) to test whether a particular <termref
                              def="dt-extension-instruction"/> is available.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Signature</label>
                     <def>
                        <example role="signature">
                           <proto name="element-available" return-type="xs:boolean" isOp="no"
                              prefix="fn" returnEmptyOk="no" returnSeq="no" returnVaries="no"
                              isSchema="no" isDatatype="no" isSpecial="no">
                              <arg name="element-name" type="xs:string"/>
                           </proto>
                        </example>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Properties</label>
                     <def>
                        <p>This function is <xtermref spec="FO30" ref="dt-deterministic"
                              >deterministic</xtermref>, <xtermref spec="FO30"
                              ref="dt-context-dependent">context-dependent</xtermref>, and <xtermref
                              spec="FO30" ref="dt-focus-independent">focus-independent</xtermref>.
                           It depends on namespaces. </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Rules</label>
                     <def>
                        <p diff="chg" at="K">The value of the <code>$element-name</code> argument
                              <rfc2119>must</rfc2119> be a string containing an <termref
                              def="dt-eqname">EQName</termref>. If it is a <termref
                              def="dt-lexical-qname">lexical QName</termref> with a prefix, then it
                           is expanded into an <termref def="dt-expanded-qname">expanded
                              QName</termref> using the namespace declarations in the static context
                           of the <termref def="dt-expression">expression</termref>. If there is a
                           default namespace in scope, then it is used to expand an unprefixed
                              <termref def="dt-lexical-qname">lexical QName</termref>.</p>
                        <p diff="add" at="N"> If the resulting <termref def="dt-expanded-qname"
                              >expanded QName</termref> is in the <termref def="dt-xslt-namespace"
                           />, the function returns true if and only if the local name matches the
                           name of an XSLT element that is defined in this specification and
                           implemented by the XSLT processor.</p>
                        <p>If the <termref def="dt-expanded-qname">expanded QName</termref> has a
                           null namespace URI, the <function>element-available</function> function
                           will return false. </p>
                        <p>If the <termref def="dt-expanded-qname">expanded QName</termref> is not
                           in the <termref def="dt-xslt-namespace">XSLT namespace</termref>, the
                           function returns true if and only if the processor has an implementation
                           available of an <termref def="dt-extension-instruction">extension
                              instruction</termref> with the given expanded QName. This applies
                           whether or not the namespace has been designated as an <termref
                              def="dt-extension-namespace">extension namespace</termref>.</p>
                        <p>If the processor does not have an implementation of a particular
                           extension instruction available, and such an extension instruction is
                           evaluated, then the processor <rfc2119>must</rfc2119> perform fallback
                           for the element as specified in <specref ref="fallback"/>. An
                           implementation <rfc2119>must not</rfc2119> signal an error merely because
                           the stylesheet contains an extension instruction for which no
                           implementation is available.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Error Conditions</label>
                     <def>
                        <p diff="chg" at="K">
                           <error spec="XT" type="dynamic" class="DE" code="1440"><p>It is a
                                    <termref def="dt-dynamic-error"><phrase diff="del" at="N"
                                       >non-recoverable</phrase> dynamic error</termref> if the
                                 argument <error.extra>passed to the
                                       <function>element-available</function> function</error.extra>
                                 does not evaluate to a string that is a valid <termref
                                    def="dt-eqname">EQName</termref>, or if the value is a <termref
                                    def="dt-lexical-qname">lexical QName</termref> with a prefix for
                                 which no namespace declaration is present in the static context. If
                                 the processor is able to detect the error statically (for example,
                                 when the argument is supplied as a string literal), then the
                                 processor <rfc2119>may</rfc2119> optionally signal this as a
                                    <termref def="dt-static-error">static
                              error</termref>.</p></error>
                        </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Notes</label>
                     <def>
                        <p role="note">For element names in the XSLT namespace:</p>
                        <ulist role="note">
                           <item>
                              <p diff="add" at="N"><phrase diff="del" at="T-bug29747">Where
                                    conformance rules make some features of the specification
                                    optional, for example the <code>xsl:stream</code> element, this
                                    function can be used (typically in a <code>use-when</code>
                                    expression) to determine whether the feature is available in a
                                    particular processor. </phrase>This function can be useful to
                                 distinguish processors that implement XSLT 3.0 from processors that
                                 implement other (older or newer) versions of the specification, and
                                 to distinguish full implementations from incomplete
                                 implementations. (Incomplete implementations, of course, cannot be
                                 assumed to behave as described in this specification.)</p>
                           </item>
                           <item>
                              <p diff="add" at="N">In earlier versions of this specification,
                                    <function>element-available</function> was defined to return
                                 true only for elements classified as instructions. The distinction
                                 between instructions and other elements, however, is sometimes
                                 rather technical, and in XSLT 3.0 the effect of the function has
                                 therefore been aligned to do what its name might suggest.</p>
                           </item>
                           <item>
                              <p diff="add" at="M">If an instruction is recognized but offers no
                                 useful functionality (for example, if the system has been
                                 configured for security reasons so that
                                    <elcode>xsl:evaluate</elcode> always raises an error), then
                                    <function>element-available</function> when applied to that
                                 instruction <rfc2119>should</rfc2119> return false.</p>
                           </item>
                        </ulist>
                        <p role="note">For element names in other namespaces:</p>
                        <ulist role="note">
                           <item>
                              <p>The result of the <function>element-available</function> does not
                                 depend on whether or not the namespace of the supplied instruction
                                 name has been designated as an extension element namespace; it
                                 tests whether the instruction would be available if the namespace
                                 were designated as such.</p>
                           </item>
                        </ulist>
                     </def>
                  </gitem>
               </glist>
            </div3>
            <div3 id="fallback">
               <head>Fallback</head>
               <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
                  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="fallback">
                  <e:in-category name="instruction"/>
                  <e:model name="sequence-constructor"/>
                  <e:allowed-parents>
                     <e:parent name="analyze-string"/>
                     <e:parent name="evaluate"/>
                     <e:parent name="fork"/>
                     <e:parent name="merge"/>
                     <e:parent name="next-match"/>
                     <e:parent name="try"/>
                     <e:parent-category name="sequence-constructor"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p>The content of an <elcode>xsl:fallback</elcode> element is a <termref
                     def="dt-sequence-constructor">sequence constructor</termref>, and when
                  performing fallback, the value returned by the <elcode>xsl:fallback</elcode>
                  element is the result of evaluating this sequence constructor.</p>
               <p>When not performing fallback, evaluating an <elcode>xsl:fallback</elcode> element
                  returns an empty sequence: the content of the <elcode>xsl:fallback</elcode>
                  element is <phrase diff="chg" at="S+">not evaluated</phrase>.</p>
               <p>There are two situations where a <termref def="dt-processor">processor</termref>
                  performs fallback: when an extension instruction that is not available is
                  evaluated, and when an instruction in the XSLT namespace, that is not defined in
                  XSLT <phrase diff="chg" at="A">3.0</phrase>, is evaluated within a region of the
                  stylesheet for which <termref def="dt-forwards-compatible-behavior"/> is
                  enabled.</p>
               <note>
                  <p>Fallback processing is not invoked in other situations, for example it is not
                     invoked when an XPath expression uses unrecognized syntax or contains a call to
                     an unknown function. To handle such situations dynamically, the stylesheet
                     should call functions such as <function>system-property</function> and
                        <function>function-available</function> to decide what capabilities are
                     available.</p>
               </note>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1450"><p>When a <termref
                           def="dt-processor">processor</termref> performs fallback for an <termref
                           def="dt-extension-instruction">extension instruction</termref> that is
                        not recognized, if the instruction element has one or more
                           <elcode>xsl:fallback</elcode> children, then the content of each of the
                           <elcode>xsl:fallback</elcode> children <rfc2119>must</rfc2119> be
                        evaluated; it is a <termref def="dt-dynamic-error"><phrase diff="del" at="M"
                              >non-recoverable</phrase> dynamic error</termref> if it has no
                           <elcode>xsl:fallback</elcode> children.</p></error>
               </p>
               <note>
                  <p>This is different from the situation with unrecognized <termref
                        def="dt-xslt-element">XSLT elements</termref>. As explained in <specref
                        ref="forwards"/>, an unrecognized XSLT element appearing within a <termref
                        def="dt-sequence-constructor">sequence constructor</termref> is a static
                     error unless (a) <termref def="dt-forwards-compatible-behavior"/> is enabled,
                     and (b) the instruction has an <elcode>xsl:fallback</elcode> child.</p>
               </note>
            </div3>
         </div2>
      </div1>
      <div1 id="result-trees">
         <head>Transformation Results</head>
         <p diff="add" at="S-bug27258">The output of a transformation includes a <termref
               def="dt-principal-result"/> and zero or more <termref def="dt-secondary-result"
               >secondary results</termref>.</p>
         <p diff="del" at="S-bug27258">The output of a transformation <phrase diff="add"
               at="R-bug24690">(after the optional post-processing step described in <specref
                  ref="post-processing"/>)</phrase> is a set of one or more <termref
               def="dt-final-result-tree">final result trees</termref>.</p>
         <p diff="del" at="S-bug27258">A <termref def="dt-final-result-tree">final result
               tree</termref> can be created explicitly, by evaluating an
               <elcode>xsl:result-document</elcode> instruction. As explained in <specref
               ref="executing-a-transformation"/>
            <phrase diff="add" at="R-bug24690">and <specref ref="post-processing"/></phrase>, a
            final result tree <rfc2119>may</rfc2119> also be created implicitly if no
               <elcode>xsl:result-document</elcode> instruction is evaluated, or if the result of
            evaluating the <termref def="dt-initial-named-template"/> is a non-empty sequence. </p>
         <p>The way in which <phrase diff="add" at="S-bug27258">these results are</phrase>
            <phrase diff="del" at="S-bug27258">a <termref def="dt-final-result-tree">final result
                  tree</termref> is</phrase> delivered to an application is <termref
               def="dt-implementation-defined">implementation-defined</termref>.</p>
         <imp-def-feature id="idf-api-results">The way in which the results of the transformation
            are delivered to an application is implementation-defined.</imp-def-feature>
         <p>Serialization of <phrase diff="add" at="S-bug27258">results</phrase>
            <phrase diff="del" at="S-bug27258"><termref def="dt-final-result-tree">final result
                  trees</termref></phrase> is described further in <specref ref="serialization"/>
         </p>
         <div2 id="creating-result-trees">
            <head>Creating Secondary Results</head>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="result-document">
               <e:in-category name="instruction"/>
               <e:attribute name="format">
                  <e:attribute-value-template>
                     <e:data-type name="eqname"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="href">
                  <e:attribute-value-template>
                     <e:data-type name="uri"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="validation">
                  <e:constant value="strict"/>
                  <e:constant value="lax"/>
                  <e:constant value="preserve"/>
                  <e:constant value="strip"/>
               </e:attribute>
               <e:attribute name="type">
                  <e:data-type name="eqname"/>
               </e:attribute>
               <e:attribute name="method">
                  <e:attribute-value-template>
                     <e:constant value="xml"/>
                     <e:constant value="html"/>
                     <e:constant value="xhtml"/>
                     <e:constant value="text"/>
                     <e:constant value="json"/>
                     <e:constant value="adaptive"/>
                     <e:data-type name="eqname"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="allow-duplicate-names">
                  <e:attribute-value-template>
                     <e:data-type name="boolean"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="build-tree">
                  <e:attribute-value-template>
                     <e:data-type name="boolean"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="byte-order-mark">
                  <e:attribute-value-template>
                     <e:data-type name="boolean"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="cdata-section-elements">
                  <e:attribute-value-template>
                     <e:data-type name="eqnames"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="doctype-public">
                  <e:attribute-value-template>
                     <e:data-type name="string"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="doctype-system">
                  <e:attribute-value-template>
                     <e:data-type name="string"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="encoding">
                  <e:attribute-value-template>
                     <e:data-type name="string"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="escape-uri-attributes">
                  <e:attribute-value-template>
                     <e:data-type name="boolean"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="html-version">
                  <e:attribute-value-template>
                     <e:data-type name="decimal"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="include-content-type">
                  <e:attribute-value-template>
                     <e:data-type name="boolean"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="indent">
                  <e:attribute-value-template>
                     <e:data-type name="boolean"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="item-separator">
                  <e:attribute-value-template>
                     <e:data-type name="string"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="json-node-output-method">
                  <e:attribute-value-template>
                     <e:constant value="xml"/>
                     <e:constant value="html"/>
                     <e:constant value="xhtml"/>
                     <e:constant value="text"/>
                     <e:data-type name="eqname"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="media-type">
                  <e:attribute-value-template>
                     <e:data-type name="string"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="normalization-form">
                  <e:attribute-value-template>
                     <e:constant value="NFC"/>
                     <e:constant value="NFD"/>
                     <e:constant value="NFKC"/>
                     <e:constant value="NFKD"/>
                     <e:constant value="fully-normalized"/>
                     <e:constant value="none"/>
                     <e:data-type name="nmtoken"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="omit-xml-declaration">
                  <e:attribute-value-template>
                     <e:data-type name="boolean"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="parameter-document">
                  <e:attribute-value-template>
                     <e:data-type name="uri"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="standalone">
                  <e:attribute-value-template>
                     <e:data-type name="boolean"/>
                     <e:constant value="omit"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="suppress-indentation">
                  <e:attribute-value-template>
                     <e:data-type name="eqnames"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="undeclare-prefixes">
                  <e:attribute-value-template>
                     <e:data-type name="boolean"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="use-character-maps">
                  <e:data-type name="eqnames"/>
               </e:attribute>
               <e:attribute name="output-version">
                  <e:attribute-value-template>
                     <e:data-type name="nmtoken"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p diff="add" at="S-bug27258">The <elcode>xsl:result-document</elcode> instruction is
               used to create a <termref def="dt-secondary-result"/>. The content of the
                  <elcode>xsl:result-document</elcode> element is a <termref
                  def="dt-sequence-constructor">sequence constructor</termref>, <phrase diff="chg"
                  at="T-bug29431">and the value of the <termref def="dt-secondary-result"/> (known
                  as the <termref def="dt-raw-result"/>) is the <termref def="dt-immediate-result"/>
                  of this sequence constructor. </phrase></p>
            <p diff="add" at="T-bug29431">As with the <termref def="dt-principal-result"/> of the
               transformation, a <termref def="dt-secondary-result"/> may be delivered to the
               calling application in three ways (see <specref ref="post-processing"/>):</p>
            <olist>
               <item>
                  <p>The <termref def="dt-raw-result"/> may be delivered <emph>as is</emph>.</p>
               </item>
               <item>
                  <p>The <termref def="dt-raw-result"/> may be used to construct a <termref
                        def="dt-final-result-tree"/> by invoking the process of <xtermref
                        spec="SER30" ref="sequence-normalization"/>.</p>
               </item>
               <item>
                  <p>The <termref def="dt-raw-result"/> may be serialized to a sequence of octets
                     (which may then, optionally, be saved to a persistent storage location).</p>
               </item>
            </olist>
            <p diff="add" at="T-bug29431">The decision whether or not to serialize the raw result
               depends on the <termref def="dt-processor">processor</termref> and on the way it is
               invoked. This is <termref def="dt-implementation-defined"/>, and it is not controlled
               by anything in the stylesheet.</p>
            <p diff="add" at="T-bug29431">If the result is not serialized, then the decision whether
               to return the <termref def="dt-raw-result"/> or to construct a tree depends on the
               effective value of the <code>build-tree</code> attribute. If the effective value of
               the <code>build-tree</code> attribute is <code>yes</code>, then <phrase diff="chg"
                  at="T-bug29431"> a <termref def="dt-final-result-tree"/> is created by invoking
                  the process of <xtermref spec="SER30" ref="sequence-normalization"/></phrase>. The
               default for the <code>build-tree</code> attribute depends on the serialization
               method. For the <code>xml</code>, <code>html</code>, <code>xhtml</code>, and
                  <code>text</code> methods the default value is <code>yes</code>. <phrase
                  diff="add" at="S-bug24266">For the <code>json</code> and <code>adaptive</code>
                  methods (available only with XPath 3.1) the default value is
                  <code>no</code>.</phrase></p>
            <p diff="chg" at="T-bug29431">The <elcode>xsl:result-document</elcode> instruction
               defines a URI that may be used to identify the <termref def="dt-secondary-result"/>.
               The instruction may optionally specify the output format to be used for serializing
               the result.</p>
            <p>Technically, the result of evaluating the <elcode>xsl:result-document</elcode>
               instruction is an empty sequence. This means it does not contribute anything to the
               result of the sequence constructor it is part of.</p>
            <p>The <termref def="dt-effective-value">effective value</termref> of the
                  <code>format</code> attribute, if specified, <rfc2119>must</rfc2119> be an <phrase
                  diff="chg" at="K"><termref def="dt-eqname">EQName</termref></phrase>. The value is
               expanded using the namespace declarations in scope for the
                  <elcode>xsl:result-document</elcode> element. The resulting <termref
                  def="dt-expanded-qname">expanded QName</termref>
               <rfc2119>must</rfc2119> match the expanded QName of a named <termref
                  def="dt-output-definition">output definition</termref> in the <termref
                  def="dt-stylesheet">stylesheet</termref>. This identifies the
                  <elcode>xsl:output</elcode> declaration that will control the serialization of the
                  <termref def="dt-final-result-tree">final result tree</termref> (see <specref
                  ref="serialization"/>), if the result tree is serialized. If the
                  <code>format</code> attribute is omitted, the unnamed <termref
                  def="dt-output-definition">output definition</termref> is used to control
               serialization of the result tree.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="1460"><p>It is a <termref
                        def="dt-dynamic-error"><phrase diff="del" at="M">non-recoverable</phrase>
                        dynamic error</termref> if the <termref def="dt-effective-value">effective
                        value</termref> of the <code>format</code> attribute <error.extra>of an
                           <elcode>xsl:result-document</elcode> element</error.extra> is not a valid
                        <termref def="dt-eqname">EQName</termref>, or if it does not match the
                        <termref def="dt-expanded-qname">expanded QName</termref> of an <termref
                        def="dt-output-definition">output definition</termref> in the <phrase
                        diff="chg" at="T-bug29431">containing <termref def="dt-package"
                           >package</termref></phrase>. If the processor is able to detect the error
                     statically (for example, when the <code>format</code> attribute contains no
                     curly brackets), then the processor <rfc2119>may</rfc2119> optionally signal
                     this as a <termref def="dt-static-error">static error</termref>.</p></error>
            </p>
            <note>
               <p>The only way to select the unnamed <termref def="dt-output-definition">output
                     definition</termref> is to omit the <code>format</code> attribute.</p>
            </note>
            <p diff="add" at="N">The <code>parameter-document</code> attribute allows serialization
               parameters to be supplied in an external document. The external document must contain
               an <code>output:serialization-parameters</code> element with the format described in
                  <xspecref spec="SER30" ref="serparams-in-xdm-instance"/>, and the parameters are
               interpreted as described in that specification.</p>
            <p diff="add" at="N">If present, the <termref def="dt-effective-value"/> of the URI
               supplied in the <code>parameter-document</code> attribute is dereferenced, after
               resolution against the base URI of the <elcode>xsl:result-document</elcode> element
               if it is a relative reference. <phrase diff="add" at="S-bug29162">The parameter
                  document <rfc2119>should</rfc2119> be read during run-time evaluation of the
                  stylesheet. </phrase> If the location of the stylesheet at development time is
               different from the deployed location, any relative reference should be resolved
               against the deployed location. A serialization error occurs if the result of
               dereferencing the URI is ill-formed or invalid; but if no document can be found at
               the specified location, the attribute <phrase diff="chg" at="S-bug29162"
                     ><code>should</code></phrase> be ignored.</p>
            <p diff="add" at="N">A serialization parameter specified in the
                  <code>parameter-document</code> takes precedence over a value supplied directly as
               an attribute of <elcode>xsl:result-document</elcode>, which in turn takes precedence
               over a value supplied in the selected output definition, except that the values of
               the <code>cdata-section-elements</code> and <code>suppress-indentation</code>
               attributes are merged in the same way as when multiple <elcode>xsl:output</elcode>
               declarations are merged.</p>
            <p>The attributes <code>method</code>, <phrase diff="add" at="S-bug24266"
                     ><code>allow-duplicate-names</code></phrase>, <phrase diff="add" at="27258"
                     ><code>build-tree</code></phrase>, <code>byte-order-mark</code>
               <code>cdata-section-elements</code>, <code>doctype-public</code>,
                  <code>doctype-system</code>, <code>encoding</code>,
                  <code>escape-uri-attributes</code>, <phrase diff="add" at="M"
                     ><code>html-version</code></phrase>, <code>indent</code>, <phrase diff="add"
                  at="Q"><code>item-separator</code>,</phrase>
               <phrase diff="add" at="S-bug24266"><code>json-node-output-method</code></phrase>,
                  <code>media-type</code>, <code>normalization-form</code>,
                  <code>omit-xml-declaration</code>, <code>standalone</code>, <phrase diff="add"
                  at="B"><code>suppress-indentation</code>,</phrase>
               <code>undeclare-prefixes</code>, <code>use-character-maps</code>, and
                  <code>output-version</code> may be used to override attributes defined in the
               selected <termref def="dt-output-definition">output definition</termref>.</p>
            <p>With the exception of <code>use-character-maps</code>, these attributes are all
               defined as <termref def="dt-attribute-value-template">attribute value
                  templates</termref>, so their values may be set dynamically. For any of these
               attributes that is present on the <elcode>xsl:result-document</elcode> instruction,
               the <termref def="dt-effective-value">effective value</termref> of the attribute
               overrides or supplements the corresponding value from the output definition. This
               works in the same way as when one <elcode>xsl:output</elcode> declaration overrides
               another. <phrase diff="add" at="S-bug27258">Some of the attributes have more specific
                  rules:</phrase></p>
            <ulist>
               <item>
                  <p>In the case of <code>cdata-section-elements</code>
                     <phrase diff="add" at="B">and <code>suppress-indentation</code></phrase>, the
                     value of the serialization parameter is the union of the expanded names of the
                     elements named in this instruction and the elements named in the selected
                     output definition.</p>
               </item>
               <item>
                  <p>In the case of <code>use-character-maps</code>, the character maps referenced
                     in this instruction supplement and take precedence over those defined in the
                     selected output definition.</p>
               </item>
               <item diff="add" at="P-erratumE32">
                  <p>In the case of <code>doctype-public</code> and <code>doctype-system</code>,
                     setting the effective value of the attribute to a zero-length string has the
                     effect of overriding any value for these attributes obtained from the output
                     definition. The corresponding serialization parameter is not set (is
                     “absent”).</p>
               </item>
               <item diff="add" at="Q">
                  <p>In the case of <code>item-separator</code>, setting the effective value of the
                     attribute to the special value <code>"#absent"</code> has the effect of
                     overriding any value for this attribute obtained from the output definition.
                     The corresponding serialization parameter is not set (is “absent”). It is not
                     possible to set the value of the serialization parameter to the literal
                     7-character string <code>"#absent"</code>. </p>
               </item>
               <item>
                  <p>In all other cases, the effective value of an attribute actually present on
                     this instruction takes precedence over the value defined in the selected output
                     definition.</p>
               </item>
            </ulist>
            <note>
               <p diff="chg" at="K">In the case of the attributes <code>method</code>,
                     <code>cdata-section-elements</code>, <phrase diff="add" at="B"
                        ><code>suppress-indentation</code></phrase>, and
                     <code>use-character-maps</code>, the <termref def="dt-effective-value"
                     >effective value</termref> of the attribute contains a space-separated list of
                     <termref def="dt-eqname">EQNames</termref>. If any of these is a <termref
                     def="dt-lexical-qname">lexical QName</termref> with a prefix, the prefix is
                  expanded using the in-scope namespaces for the
                     <elcode>xsl:result-document</elcode> element. In the case of
                     <code>cdata-section-elements</code>
                  <phrase diff="add" at="B">and <code>suppress-indentation</code></phrase>, an
                  unprefixed element name is expanded using the default namespace. In the case of
                  the <code>method</code> attribute, if the method is not one of the system-defined
                  methods (xml, html, xhtml, text) then the expanded name must have a non-absent
                  namespace.</p>
            </note>
            <p diff="add" at="S-bug24266">Unless the processor implements the <termref
                  def="dt-xpath31-feature"/>, the <code>method</code> values <code>json</code> and
                  <code>adaptive</code>
               <rfc2119>must</rfc2119> be rejected as invalid, and the attributes
                  <code>allow-duplicate-names</code> and <code>json-node-output-method</code>
               <rfc2119>must</rfc2119> be ignored. The meaning of these output methods and
               serialization parameters is defined in <bibref ref="xslt-xquery-serialization-31"
               />.</p>
            <p>The <code>output-version</code> attribute on the <elcode>xsl:result-document</elcode>
               instruction overrides the <code>version</code> attribute on
                  <elcode>xsl:output</elcode> (it has been renamed because <code>version</code> is
               available with a different meaning as a standard attribute: see <specref
                  ref="standard-attributes"/>). In all other cases, attributes correspond if they
               have the same name.</p>
            <p>There are some serialization parameters that apply to some output methods but not to
               others. For example, the <code>indent</code> attribute has no effect on the
                  <code>text</code> output method. If a value is supplied for an attribute that is
               inapplicable to the output method, its value is not passed to the serializer. The
               processor <rfc2119>may</rfc2119> validate the value of such an attribute, but is not
                  <rfc2119>required</rfc2119> to do so.</p>
            <p diff="chg" at="T-bug29431">The <code>item-separator</code> serialization parameter is
               used when the <termref def="dt-raw-result"/> is used to construct a result tree by
               applying sequence normalization, and it is also used when the result tree is
               serialized. For example, if the sequence constructor delivers a sequence of integers,
               and the <code>text</code> serialization method is used, then the result of
               serialization will be a string obtained by converting each integer to a string, and
               separating the strings using the defined <code>item-separator</code>.</p>
            <p>The <code>href</code> attribute is optional. The default value is the zero-length
               string. The <termref def="dt-effective-value">effective value</termref> of the
               attribute <rfc2119>must</rfc2119> be a <termref def="dt-uri-reference">URI
                  Reference</termref>, which may be absolute or relative. <phrase diff="add"
                  at="S-bug27258">If it is relative, then it is resolved against the <termref
                     def="dt-base-output-uri"/>.</phrase> There <rfc2119>may</rfc2119> be <termref
                  def="dt-implementation-defined">implementation-defined</termref> restrictions on
               the form of absolute URI that may be used, but the implementation is not
                  <rfc2119>required</rfc2119> to enforce any restrictions. Any valid relative URI
                  <phrase diff="add" at="F">reference</phrase>
               <rfc2119>must</rfc2119> be accepted. Note that the zero-length string is a valid
               relative URI <phrase diff="add" at="F">reference</phrase>.</p>
            <imp-def-feature id="idf-api-resultdocumenthref"> It is <termref
                  def="dt-implementation-defined"/> how the URI appearing in the <code>href</code>
               attribute of <elcode>xsl:result-document</elcode> affects the way in which the result
               tree is delivered to the application. There <rfc2119>may</rfc2119> be restrictions on
               the form of this URI. </imp-def-feature>
            <p diff="chg" at="S-bug27258">If the implementation provides an API to access <termref
                  def="dt-secondary-result">secondary results</termref>, then it
                  <rfc2119>must</rfc2119> allow a secondary result to be identified by means of the
               absolutized value of the <code>href</code> attribute. In addition, if a <termref
                  def="dt-final-result-tree"/> is constructed (that is, if the effective value of
                  <code>build-tree</code> is <code>yes</code>), then this value is used as the base
               URI of the document node at the root of the <termref def="dt-final-result-tree">final
                  result tree</termref>. </p>
            <note>
               <p>The base URI of the <termref def="dt-final-result-tree">final result
                     tree</termref> is not necessarily the same thing as the URI of its serialized
                  representation on disk, if any. For example, a server (or browser client) might
                  store final result trees only in memory, or in an internal disk cache. As long as
                  the processor satisfies requests for those URIs, it is irrelevant where they are
                  actually written on disk, if at all.</p>
            </note>
            <note>
               <p>It will often be the case that one <termref def="dt-final-result-tree">final
                     result tree</termref> contains links to another final result tree produced
                  during the same transformation, in the form of a relative URI <phrase diff="add"
                     at="F">reference</phrase>. The mechanism of associating a URI with a final
                  result tree has been chosen to allow the integrity of such links to be preserved
                  when the trees are serialized.</p>
               <p>As well as being potentially significant in any API that provides access to final
                  result trees, the base URI of the new document node is relevant if the final
                  result tree, rather than being serialized, is supplied as input to a further
                  transformation.</p>
            </note>
            <p>The optional attributes <code>type</code> and <code>validation</code> may be used on
               the <elcode>xsl:result-document</elcode> instruction to validate the contents of
                  <phrase diff="chg" at="S-bug27258">a <termref def="dt-final-result-tree"
                  /></phrase>, and to determine the <termref def="dt-type-annotation">type
                  annotation</termref> that elements and attributes within the <termref
                  def="dt-final-result-tree">final result tree</termref> will carry. The permitted
               values and their semantics are described in <specref ref="validating-document-nodes"
               />. <phrase diff="add" at="T-bug29431">Any such validation is applied to the document
                  node produced as the result of <xtermref spec="SER30" ref="sequence-normalization"
                  />. If sequence normalization does not take place (typically because the <termref
                     def="dt-raw-result"/> is delivered to the application directly, or because the
                  selected serialization method does not involve sequence normalization) then the
                     <code>validation</code> and <code>type</code> attributes are
               ignored.</phrase></p>
            <note diff="add" at="T-bug29431">
               <p>Validation applies after inserting item separators as determined by the
                     <code>item-separator</code> serialization parameter, and an inappropriate
                  choice of <code>item-separator</code> may cause the result to become invalid.</p>
            </note>
            <p>A <termref def="dt-processor">processor</termref>
               <rfc2119>may</rfc2119> allow a <termref def="dt-final-result-tree">final result
                  tree</termref> to be serialized. Serialization is described in <specref
                  ref="serialization"/>. However, an implementation (for example, a <termref
                  def="dt-processor">processor</termref> running in an environment with no access to
               writable filestore) is not <rfc2119>required</rfc2119> to support the serialization
               of <termref def="dt-final-result-tree">final result trees</termref>. An
               implementation that does not support the serialization of final result trees
                  <rfc2119>may</rfc2119> ignore the <code>format</code> attribute and the
               serialization attributes. Such an implementation <rfc2119>must</rfc2119> provide the
               application with some means of access to the (un-serialized) result tree, using its
               URI to identify it.</p>
            <p>Implementations may provide additional mechanisms, outside the scope of this
               specification, for defining the way in which <termref def="dt-final-result-tree"
                  >final result trees</termref> are processed. Such mechanisms
                  <rfc2119>may</rfc2119> make use of the XSLT-defined attributes on the
                  <elcode>xsl:result-document</elcode> and/or <elcode>xsl:output</elcode> elements,
               or they <rfc2119>may</rfc2119> use additional elements or attributes in an <termref
                  def="dt-implementation-defined">implementation-defined</termref> namespace.</p>
            <example>
               <head>Multiple Result Documents</head>
               <p> The following example takes an XHTML document as input, and breaks it up so that
                  the text following each &lt;h1&gt; element is included in a separate document. A
                  new document <code>toc.html</code> is constructed to act as an index:</p>
               <eg role="xslt-document" xml:space="preserve">&lt;xsl:stylesheet
	version="3.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:xhtml="http://www.w3.org/1999/xhtml"&gt;
	
&lt;xsl:output name="toc-format" method="xhtml" indent="yes"
     doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
     doctype-public="-//W3C//DTD XHTML 1.0 Strict//EN"/&gt;
            
&lt;xsl:output name="section-format" method="xhtml" indent="no"
     doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
     doctype-public="-//W3C//DTD XHTML 1.0 Transitional//EN"/&gt;	
	 
&lt;xsl:template match="/"&gt;
  &lt;xsl:result-document href="toc.html" 
                       format="toc-format" 
                       validation="strict"&gt;
    &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
      &lt;head&gt;&lt;title&gt;Table of Contents&lt;/title&gt;&lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;Table of Contents&lt;/h1&gt;
        &lt;xsl:for-each select="/*/xhtml:body/(*[1] | xhtml:h1)"&gt;
          &lt;p&gt;
            &lt;a href="section{position()}.html"&gt;
              &lt;xsl:value-of select="."/&gt;
            &lt;/a&gt;
          &lt;/p&gt;
        &lt;/xsl:for-each&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:result-document&gt;
  &lt;xsl:for-each-group select="/*/xhtml:body/*" group-starting-with="xhtml:h1"&gt;
    &lt;xsl:result-document href="section{position()}.html" 
                         format="section-format" validation="strip"&gt;  	
      &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
        &lt;head&gt;&lt;title&gt;&lt;xsl:value-of select="."/&gt;&lt;/title&gt;&lt;/head&gt;
        &lt;body&gt;
          &lt;xsl:copy-of select="current-group()"/&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:result-document&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg>
            </example>
         </div2>
         <div2 id="result-document-restrictions">
            <head>Restrictions on the use of <elcode>xsl:result-document</elcode></head>
            <p>There are restrictions on the use of the <elcode>xsl:result-document</elcode>
               instruction, designed to ensure that the results are fully interoperable even when
               processors optimize the sequence in which instructions are evaluated. Informally, the
               restriction is that the <elcode>xsl:result-document</elcode> instruction can only be
               used while writing a final result tree, not while writing to a temporary tree or a
               sequence. This restriction is defined formally as follows.</p>
            <p>
               <termdef id="dt-output-state" term="output state">Each instruction in the <termref
                     def="dt-stylesheet">stylesheet</termref> is evaluated in one of two possible
                     <term>output states</term>: <termref def="dt-final-output-state">final output
                     state</termref> or <termref def="dt-temporary-output-state">temporary output
                     state</termref>.</termdef></p>
            <p>
               <termdef id="dt-final-output-state" term="final output state">The first of the two
                     <termref def="dt-output-state">output states</termref> is called <term>final
                     output</term> state. This state applies when instructions are writing to a
                     <termref def="dt-final-result-tree">final result tree</termref>.</termdef>
            </p>
            <p>
               <termdef id="dt-temporary-output-state" term="temporary output state">The second of
                  the two <termref def="dt-output-state">output states</termref> is called
                     <term>temporary output</term> state. This state applies when instructions are
                  writing to a <termref def="dt-temporary-tree">temporary tree</termref> or any
                  other non-final destination.</termdef>
            </p>
            <p>The instructions in the <termref def="dt-initial-named-template"/> are evaluated in
                  <termref def="dt-final-output-state">final output state</termref>. An instruction
               is evaluated in the same <termref def="dt-output-state">output state</termref> as its
               calling instruction, except that <elcode>xsl:variable</elcode>,
                  <elcode>xsl:param</elcode>, <elcode>xsl:with-param</elcode>, <phrase diff="del"
                  at="Q-bug22911"><elcode>xsl:attribute</elcode>, <elcode>xsl:comment</elcode>,
                     <elcode>xsl:processing-instruction</elcode>, <elcode>xsl:namespace</elcode>,
                     <elcode>xsl:value-of</elcode>,</phrase>
               <elcode>xsl:function</elcode>, <elcode>xsl:key</elcode>, <elcode>xsl:sort</elcode>,
                  <phrase diff="add" at="Q-bug22911"><elcode>xsl:accumulator-rule</elcode>, and
                     <elcode>xsl:merge-key</elcode></phrase>
               <phrase diff="del" at="Q-bug22911"><elcode>xsl:message</elcode>, and
                     <elcode>xsl:assert</elcode></phrase> always evaluate the instructions in their
               contained <termref def="dt-sequence-constructor">sequence constructor</termref> in
                  <termref def="dt-temporary-output-state">temporary output state</termref>.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="1480"><p>It is a <termref
                        def="dt-dynamic-error"><phrase diff="del" at="M">non-recoverable</phrase>
                        dynamic error</termref> to evaluate the <elcode>xsl:result-document</elcode>
                     instruction in <termref def="dt-temporary-output-state">temporary output
                        state</termref>.</p></error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="1490"><p>It is a <termref
                        def="dt-dynamic-error"><phrase diff="del" at="M">non-recoverable</phrase>
                        dynamic error</termref> for a transformation to generate two or more
                        <termref def="dt-final-result-tree">final result trees</termref> with the
                     same URI.</p></error>
            </p>
            <note>
               <p>Note, this means that it is an error to evaluate more than one
                     <elcode>xsl:result-document</elcode> instruction that omits the
                     <code>href</code> attribute, or to evaluate any
                     <elcode>xsl:result-document</elcode> instruction that omits the
                     <code>href</code> attribute if an initial <termref def="dt-final-result-tree"
                     >final result tree</termref> is created implicitly.</p>
            </note>
            <p diff="add" at="M">In addition, an implementation <rfc2119>may</rfc2119> report this
               error if it is able to detect that two or more final result trees are generated with
               different URIs that refer to the same physical resource.</p>
            <p diff="del" at="M">
               <error spec="XT" type="dynamic" class="RE" code="1495"><p>It is a recoverable dynamic
                     error for a transformation to generate two or more <termref
                        def="dt-final-result-tree">final result trees</termref> with URIs that
                     identify the same physical resource. The optional recovery action is
                     implementation-dependent, since it may be impossible for the processor to
                     detect the error.</p></error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="1500"><p>It is a <termref
                        def="dt-dynamic-error"><phrase diff="del" at="M">recoverable</phrase>
                        dynamic error</termref> for a <termref def="dt-stylesheet"
                        >stylesheet</termref> to write to an external resource and read from the
                     same resource during a single transformation, <phrase diff="add" at="M">if the
                        same absolute URI is used to access the resource in both cases</phrase>.
                  </p></error>
            </p>
            <p diff="add" at="M">In addition, an implementation <rfc2119>may</rfc2119> report this
               error if it is able to detect that a transformation writes to a resource and reads
               from the same resource using different URIs that refer to the same physical resource.
               Note that if the error is not detected, it is <termref
                  def="dt-implementation-dependent"/> whether the document that is read from the
               resource reflects its state before or after the result tree is written.</p>
         </div2>
         <div2 id="current-output-uri" diff="add" at="R-bug24551">
            <head>The Current Output URI</head>
            <p diff="chg" at="S-bug27258"><termdef id="dt-current-output-uri"
                  term="current output URI">The <term>current output URI</term> is the URI
                  associated with the <termref def="dt-principal-result"/> or <termref
                     def="dt-secondary-result"/> that is currently being written.</termdef></p>
            <div3 id="func-current-output-uri">
               <head>fn:current-output-uri</head>
               <glist>
                  <gitem>
                     <label>Summary</label>
                     <def>
                        <p>Returns the value of the <termref def="dt-current-output-uri"/>.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Signature</label>
                     <def>
                        <example role="signature">
                           <proto name="current-output-uri" return-type="xs:anyURI?" isOp="no"
                              prefix="fn" returnEmptyOk="no" returnSeq="no" returnVaries="no"
                              isSchema="no" isDatatype="no" isSpecial="no"/>
                        </example>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Properties</label>
                     <def>
                        <p>This function is <xtermref spec="FO30" ref="dt-deterministic"
                              >deterministic</xtermref>, <xtermref spec="FO30"
                              ref="dt-focus-independent">focus-independent</xtermref>, and <xtermref
                              spec="FO30" ref="dt-context-dependent">context-dependent</xtermref>.
                        </p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Rules</label>
                     <def>
                        <p>On initial invocation of a stylesheet component, the current output uri
                           is set to the <termref def="dt-base-output-uri"/>.</p>
                        <p>During execution of an <elcode>xsl:result-document</elcode> instruction
                           with an <code>href</code> attribute, the current output URI changes to
                           the absolute URI obtained by resolving the <termref
                              def="dt-effective-value"/> of the <code>href</code> attribute against
                           the base output URI.</p>
                        <p diff="chg" at="R-bug24551">The current output URI is cleared (set to
                              <termref def="dt-absent"/>) while evaluating stylesheet functions,
                           dynamic function calls, evaluation of global variables, stylesheet
                           parameters, and patterns. If the function is called when the current
                           output URI is absent, the function returns the empty sequence. </p>
                        <p diff="del" at="R-bug24551">When the <termref def="dt-output-state"/> is
                              <termref def="dt-temporary-output-state"/>, for example while
                           evaluating variables and functions, the current output URI is <termref
                              def="dt-absent"/>, in which case the function returns the empty
                           sequence.</p>
                        <p>The current output URI may also be <termref def="dt-absent"/> in the
                           event that a stylesheet is invoked without supplying a <termref
                              def="dt-base-output-uri"/>.</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>Notes</label>
                     <def>
                        <p role="note">The current output URI is not cleared when evaluating a local
                           variable, even though <elcode>xsl:result-document</elcode> cannot be used
                           while evaluating a local variable. The reason for this is to allow the
                           value of <code>current-output-uri</code> to be set as the value of a
                           tunnel parameter, so that the original base output URI is accessible even
                           when writing nested result documents.</p>
                     </def>
                  </gitem>
               </glist>
            </div3>
         </div2>
         <div2 id="validation">
            <head>Validation</head>
            <p>It is possible to control the <termref def="dt-type-annotation"/> applied to
               individual element and attribute nodes as they are constructed. This is done using
               the <code>type</code> and <code>validation</code> attributes of the
                  <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                  <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>,
                  <elcode>xsl:document</elcode>, and <elcode>xsl:result-document</elcode>
               instructions, or the <code>xsl:type</code> and <code>xsl:validation</code> attributes
               of a <termref def="dt-literal-result-element">literal result element</termref>.
                  <phrase diff="add" at="R-bug26766">The same attributes are used on
                     <elcode>xsl:source-document</elcode> and <elcode>xsl:merge-source</elcode> to
                  control validation of input documents.</phrase></p>
            <p>The <code>[xsl:]type</code> attribute is used to request validation of an element or
               attribute against a specific simple or complex type defined in a schema. The
                  <code>[xsl:]validation</code> attribute is used to request validation against the
               global element or attribute declaration whose name matches the name of the element or
               attribute being validated.</p>
            <p>The <code>[xsl:]type</code> and <code>[xsl:]validation</code> attributes are mutually
               exclusive. Both are optional, but if one is present then the other
                  <rfc2119>must</rfc2119> be omitted. If both attributes are omitted, the effect is
               the same as specifying the <code>validation</code> attribute with the value specified
               in the <phrase diff="chg" at="P"><code>[xsl:]default-validation</code> attribute of
                  the innermost containing element having such an attribute</phrase>; if this is not
               specified, the effect is the same as specifying <code>validation="strip"</code>.</p>
            <p diff="chg" at="P">The <code>[xsl:]default-validation</code> attribute defines the
               default value of the <code>validation</code> attribute of all
                  <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                  <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>,
                  <elcode>xsl:document</elcode>, and <elcode>xsl:result-document</elcode>
               instructions, and of the <code>xsl:validation</code> attribute of all <termref
                  def="dt-literal-result-element">literal result elements</termref>
               <phrase diff="add" at="P">, appearing within its scope</phrase>. It also determines
               the validation applied to the implicit <termref def="dt-final-result-tree">final
                  result tree</termref> created in the absence of an
                  <elcode>xsl:result-document</elcode> instruction. This default applies within the
               containing <termref def="dt-stylesheet-module">stylesheet module</termref> or
                  <termref def="dt-package"/>: it does not extend to included or imported stylesheet
               modules or used packages. If the attribute is omitted, the default is
                  <code>strip</code>. The permitted values are <code>preserve</code> and
                  <code>strip</code>.</p>
            <p diff="add" at="R-bug26766">The <code>[xsl:]default-validation</code> attribute has no
               effect on the <elcode>xsl:source-document</elcode> and
                  <elcode>xsl:merge-source</elcode> elements, which perform no validation unless
               explicitly requested.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="1505"><p>It is a <termref
                        def="dt-static-error">static error</termref> if both the
                        <code>[xsl:]type</code> and <code>[xsl:]validation</code> attributes are
                     present on the <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                        <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>,
                        <elcode>xsl:document</elcode>, <elcode>xsl:result-document</elcode>, <phrase
                        diff="add" at="R-bug26766"><elcode>xsl:source-document</elcode>, or
                           <elcode>xsl:merge-source</elcode></phrase> elements, or on a <termref
                        def="dt-literal-result-element">literal result
                  element</termref>.</p></error>
            </p>
            <p>The detailed rules for validation vary depending on the kind of node being validated.
               The rules for element and attribute nodes are given in <specref
                  ref="validating-constructed-nodes"/>, while those for document nodes are given in
                  <specref ref="validating-document-nodes"/>.</p>
            <div3 id="validating-constructed-nodes">
               <head>Validating Constructed Elements and Attributes</head>
               <div4 id="validating-using-validation-attribute">
                  <head>Validation using the <code>[xsl:]validation</code> Attribute</head>
                  <p>The <code>[xsl:]validation</code> attribute defines the validation action to be
                     taken. It determines not only the <termref def="dt-type-annotation">type
                        annotation</termref> of the node that is constructed by the relevant
                     instruction itself, but also the type annotations of all element and attribute
                     nodes that have the constructed node as an ancestor. Conceptually, the
                     validation requested for a child element or attribute node is applied before
                     the validation requested for its parent element. For example, if the
                     instruction that constructs a child element specifies
                        <code>validation="strict"</code>, this will cause the child element to be
                     checked against an element declaration, but if the instruction that constructs
                     its parent element specifies <code>validation="strip"</code>, then the final
                     effect will be that the child node is annotated as <code>xs:untyped</code>.</p>
                  <p>In the paragraphs below, the term <emph>contained nodes</emph> means the
                     elements and attributes that have the newly constructed node as an
                     ancestor.</p>
                  <olist>
                     <item>
                        <p>The value <code>strip</code> indicates that the new node and each of the
                           contained nodes will have the <termref def="dt-type-annotation">type
                              annotation</termref>
                           <code>xs:untyped</code> if it is an element, or
                              <code>xs:untypedAtomic</code> if it is an attribute. Any previous type
                           annotation present on a contained element or attribute node (for example,
                           a type annotation that is present on an element copied from a source
                           document) is also replaced by <code>xs:untyped</code> or
                              <code>xs:untypedAtomic</code> as appropriate. The typed value of the
                           node is changed to be the same as its string value, as an instance of
                              <code>xs:untypedAtomic</code>. In the case of elements the
                              <code>nilled</code> property is set to <code>false</code>. The values
                           of the <code>is-id</code> and <code>is-idrefs</code> properties are
                           unchanged. Schema validation is not invoked.</p>
                     </item>
                     <item>
                        <p>The value <code>preserve</code> indicates that nodes that are copied will
                           retain their <termref def="dt-type-annotation">type
                           annotations</termref>, but nodes whose content is newly constructed will
                           be annotated as <code>xs:anyType</code> in the case of elements, or
                              <code>xs:untypedAtomic</code> in the case of attributes. Schema
                           validation is not invoked. The detailed effect depends on the
                           instruction:</p>
                        <olist>
                           <item>
                              <p>In the case of <elcode>xsl:element</elcode> and literal result
                                 elements, the new element has a <termref def="dt-type-annotation"
                                    >type annotation</termref> of <code>xs:anyType</code>, and the
                                 type annotations of contained nodes are retained unchanged.</p>
                              <p diff="add" at="S-bug-28565">The <code>nilled</code>,
                                    <code>is-id</code> and <code>is-idrefs</code> properties on the
                                 new element are set to <code>false</code>.</p>
                           </item>
                           <item>
                              <p>In the case of <elcode>xsl:attribute</elcode>, the effect is
                                 exactly the same as specifying <code>validation="strip"</code>:
                                 that is, the new attribute will have the type annotation
                                    <code>xs:untypedAtomic</code>.</p>
                              <p diff="add" at="S-bug-28565">The <code>is-id</code> and
                                    <code>is-idrefs</code> properties on the new attribute are set
                                 to <code>false</code>.</p>
                           </item>
                           <item>
                              <p>In the case of <elcode>xsl:copy-of</elcode>, all the nodes that are
                                 copied will retain their type annotations unchanged. <phrase
                                    diff="add" at="S-bug-28565">The values of their
                                       <code>nilled</code>, <code>is-id</code> and
                                       <code>is-idrefs</code> properties are also
                                 unchanged</phrase>.</p>
                           </item>
                           <item>
                              <p>In the case of <elcode>xsl:copy</elcode>, the effect depends on the
                                 kind of node being copied.</p>
                              <olist>
                                 <item>
                                    <p>Where the node being copied is an attribute, the copied
                                       attribute will retain its <termref def="dt-type-annotation"
                                          >type annotation</termref>
                                       <phrase diff="add" at="S-bug-28565">and the values of its
                                             <code>is-id</code> and <code>is-idrefs</code>
                                          properties</phrase>.</p>
                                 </item>
                                 <item>
                                    <p>Where the node being copied is an element, the copied element
                                       will have a <termref def="dt-type-annotation">type
                                          annotation</termref> of <code>xs:anyType</code> (because
                                       this instruction does not copy the content of the element, it
                                       would be wrong to assume that the type is unchanged); but any
                                       contained nodes will have their type annotations retained in
                                       the same way as with <elcode>xsl:element</elcode>. <phrase
                                          diff="add" at="S-bug-28565">The values of the
                                             <code>nilled</code>, <code>is-id</code>, and
                                             <code>is-idrefs</code> properties are handled in the
                                          same way as <elcode>xsl:element</elcode>.</phrase>
                                    </p>
                                 </item>
                              </olist>
                           </item>
                        </olist>
                     </item>
                     <item>
                        <p>The value <code>strict</code> indicates that <termref
                              def="dt-type-annotation">type annotations</termref> are established by
                           performing strict schema validity assessment on the element or attribute
                           node created by this instruction as follows:</p>
                        <olist>
                           <item>
                              <p>In the case of an element, a top-level element declaration is
                                 identified whose local name and namespace (if any) match the name
                                 of the element, and schema-validity assessment is carried out
                                 according to the rules defined in <bibref ref="xmlschema-1"/>
                                 (section 3.3.4 <quote>Element Declaration Validation Rules</quote>,
                                 validation rule <quote>Schema-Validity Assessment
                                 (Element)</quote>, clauses 1.1 and 2, using the top-level element
                                 declaration as the “declaration stipulated by the processor”, which
                                 is mentioned in clause 1.1.1.1). The element is considered valid if
                                 the result of the schema validity assessment is a PSVI in which the
                                 relevant element node has a <code>validity</code> property whose
                                 value is <code>valid</code>. If there is no matching element
                                 declaration, or if the element is not considered valid, the
                                 transformation fails <errorref class="TE" code="1510"/>, <errorref
                                    class="TE" code="1512"/>. In effect this means that the element
                                 being validated <rfc2119>must</rfc2119> be declared using a
                                 top-level declaration in the schema, and <rfc2119>must</rfc2119>
                                 conform to its declaration. The process of validation applies
                                 recursively to contained elements and attributes to the extent
                                 required by the schema definition.</p>
                              <note>
                                 <p>It is not an error if the identified type definition is a simple
                                    type, although <bibref ref="xmlschema-1"/> does not define
                                    explicitly that this case is permitted.</p>
                              </note>
                           </item>
                           <item>
                              <p>In the case of an attribute, a top-level attribute declaration is
                                 identified whose local name and namespace (if any) match the name
                                 of the attribute, and schema-validity assessment is carried out
                                 according to the rules defined in <bibref ref="xmlschema-1"/>
                                 (section 3.2.4 <quote>Attribute Declaration Validation
                                    Rules</quote>, validation rule <quote>Schema-Validity Assessment
                                    (Attribute)</quote>). The attribute is considered valid if the
                                 result of the schema validity assessment is a PSVI in which the
                                 relevant attribute node has a <code>validity</code> property whose
                                 value is <code>valid</code>. If the attribute is not considered
                                 valid, the transformation fails <errorref class="TE" code="1510"/>.
                                 In effect this means that the attribute being validated
                                    <rfc2119>must</rfc2119> be declared using a top-level
                                 declaration in the schema, and <rfc2119>must</rfc2119> conform to
                                 its declaration.</p>
                           </item>
                           <item>
                              <p>The schema components used to validate an element or attribute may
                                 be located in any way described by <bibref ref="xmlschema-1"/> (see
                                 section 4.3.2, <emph>How schema documents are located on the
                                    Web</emph>). The components in the schema constructed from the
                                 synthetic schema document (see <specref ref="import-schema"/>) will
                                 always be available for validating constructed nodes; if additional
                                 schema components are needed, they <rfc2119>may</rfc2119> be
                                 located in other ways, for example implicitly from knowledge of the
                                 namespace in which the elements and attributes appear, or using the
                                    <code>xsi:schemaLocation</code> attribute of elements within the
                                 tree being validated.</p>
                           </item>
                           <item>
                              <p diff="add" at="S-bug28565">The type annotations on the resulting
                                 nodes, as well as the values of their <code>is-id</code>,
                                    <code>is-idrefs</code>, and <code>nilled</code> properties, are
                                 defined by the rules in <xspecref ref="const-psvi" spec="DM31"
                                 />.</p>
                           </item>
                           <item>
                              <p>If no validation is performed for a node, which can happen when the
                                 schema specifies <code>lax</code> or <code>skip</code> validation
                                 for that node or for a subtree, then the node is annotated as
                                    <code>xs:anyType</code> in the case of an element, and
                                    <code>xs:untypedAtomic</code> in the case of an attribute.</p>
                           </item>
                        </olist>
                     </item>
                     <item>
                        <p>The value <code>lax</code> has the same effect as the value
                              <code>strict</code>, except that whereas <code>strict</code>
                           validation fails if there is no matching top-level element declaration or
                           if the outcome of validity assessment is a <code>validity</code> property
                           of <code>invalid</code> or <code>notKnown</code>, <code>lax</code>
                           validation fails only if the outcome of validity assessment is a
                              <code>validity</code> property of <code>invalid</code>. That is,
                              <code>lax</code> validation does not cause a <termref
                              def="dt-type-error">type error</termref> when the outcome is
                              <code>notKnown</code>.</p>
                        <p>In practice this means that the element or attribute being validated
                              <rfc2119>must</rfc2119> conform to its declaration if a top-level
                           declaration is available. If no such declaration is available, then the
                           element or attribute is not validated, but its attributes and children
                           are validated, again with lax validation. Any nodes whose validation
                           outcome is a <code>validity</code> property of <code>notKnown</code> are
                           annotated as <code>xs:anyType</code> in the case of an element, and
                              <code>xs:untypedAtomic</code> in the case of an attribute.</p>
                        <p diff="add" at="S-bug28565">The type annotations on the resulting nodes,
                           as well as the values of their <code>is-id</code>,
                           <code>is-idrefs</code>, and <code>nilled</code> properties, are defined
                           by the rules in <xspecref ref="const-psvi" spec="DM31"/>.</p>
                        <note>
                           <p>When the parent element lacks a declaration, the XML Schema
                              specification defines the recursive checking of children and
                              attributes as optional. For this specification, this recursive
                              checking is required.</p>
                        </note>
                        <note>
                           <p>If an element that is being validated has an <code>xsi:type</code>
                              attribute, then the value of the <code>xsi:type</code> attribute will
                              be taken into account when performing the validation. However, the
                              presence of an <code>xsi:type</code> attribute will not of itself
                              cause an element to be validated: if validation against a named type
                              is required, as distinct from validation against a top-level element
                              declaration, then it must be requested using the XSLT
                                 <code>[xsl:]type</code> attribute on the instruction that invokes
                              the validation, as described in section <specref
                                 ref="validation-xsl-type"/>
                           </p>
                        </note>
                     </item>
                  </olist>
                  <p>
                     <error spec="XT" type="type" class="TE" code="1510"><p>If the
                              <code>validation</code> attribute of an <elcode>xsl:element</elcode>,
                              <elcode>xsl:attribute</elcode>, <elcode>xsl:copy</elcode>,
                              <elcode>xsl:copy-of</elcode>, or <elcode>xsl:result-document</elcode>
                           instruction, or the <code>xsl:validation</code> attribute of a literal
                           result element, has the effective value <code>strict</code>, and schema
                           validity assessment concludes that the validity of the element or
                           attribute is invalid or unknown, a <termref def="dt-type-error">type
                              error</termref> occurs. As with other type errors, the error
                              <rfc2119>may</rfc2119> be signaled statically if it can be detected
                           statically. </p></error>
                  </p>
                  <p>
                     <error spec="XT" type="type" class="TE" code="1512"><p>If the
                              <code>validation</code> attribute of an <elcode>xsl:element</elcode>,
                              <elcode>xsl:attribute</elcode>, <elcode>xsl:copy</elcode>,
                              <elcode>xsl:copy-of</elcode>, or <elcode>xsl:result-document</elcode>
                           instruction, or the <code>xsl:validation</code> attribute of a literal
                           result element, has the effective value <code>strict</code>, and there is
                           no matching top-level declaration in the schema, then a <termref
                              def="dt-type-error">type error</termref> occurs. As with other type
                           errors, the error <rfc2119>may</rfc2119> be signaled statically if it can
                           be detected statically. </p></error>
                  </p>
                  <p>
                     <error spec="XT" type="type" class="TE" code="1515"><p>If the
                              <code>validation</code> attribute of an <elcode>xsl:element</elcode>,
                              <elcode>xsl:attribute</elcode>, <elcode>xsl:copy</elcode>,
                              <elcode>xsl:copy-of</elcode>, or <elcode>xsl:result-document</elcode>
                           instruction, or the <code>xsl:validation</code> attribute of a literal
                           result element, has the effective value <code>lax</code>, and schema
                           validity assessment concludes that the element or attribute is invalid, a
                              <termref def="dt-type-error">type error</termref> occurs. As with
                           other type errors, the error <rfc2119>may</rfc2119> be signaled
                           statically if it can be detected statically. </p></error>
                  </p>
                  <note>
                     <p>No mechanism is provided to validate an element or attribute against a local
                        declaration in a schema. Such validation can usually be achieved by applying
                        validation to a containing element for which a top-level element declaration
                        exists.</p>
                  </note>
               </div4>
               <div4 id="validation-xsl-type">
                  <head>Validation using the <code>[xsl:]type</code> Attribute</head>
                  <p>The <code>[xsl:]type</code> attribute takes as its value a <code>QName</code>.
                     This <rfc2119>must</rfc2119> be the name of a type definition included in the
                        <termref def="dt-in-scope-schema-component">in-scope schema
                        components</termref> for the stylesheet. If the QName has no prefix, it is
                     expanded using the default namespace established using the effective
                        <code>[xsl:]xpath-default-namespace</code> attribute if there is one;
                     otherwise, it is taken as being a name in no namespace.</p>
                  <p>If the <code>[xsl:]type</code> attribute is present, then the newly constructed
                     element or attribute is validated against the type definition identified by
                     this attribute.</p>
                  <ulist>
                     <item>
                        <p>In the case of an element, schema-validity assessment is carried out
                           according to the rules defined in <bibref ref="xmlschema-1"/> (section
                           3.3.4 <quote>Element Declaration Validation Rules</quote>, validation
                           rule <quote>Schema-Validity Assessment (Element)</quote>, clauses 1.2 and
                           2), using this type definition as the <quote>processor-stipulated type
                              definition</quote>. The element is considered valid if the result of
                           the schema validity assessment is a PSVI in which the relevant element
                           node has a <code>validity</code> property whose value is
                              <code>valid</code>. </p>
                     </item>
                     <item>
                        <p>In the case of an attribute, the attribute is considered valid if (in the
                           terminology of XML Schema) the attribute’s normalized value is locally
                           valid with respect to that type definition according to the rules for
                              <quote>String Valid</quote> (<bibref ref="xmlschema-1"/>, section
                           3.14.4). (Normalization here refers to the process of normalizing
                           whitespace according to the rules of the <code>whiteSpace</code> facet
                           for the datatype).</p>
                     </item>
                     <item>
                        <p>If the element or attribute is not considered valid, as defined above,
                           the transformation fails <errorref class="TE" code="1540"/>.</p>
                     </item>
                  </ulist>
                  <p diff="add" at="N">If an element node is validated against the type
                        <code>xs:untyped</code>, the effect is the same as specifying
                        <code>validation="strip"</code>: that is, the elements and attributes in the
                     subtree rooted at the target element are copied with a type annotation of
                        <code>xs:untyped</code> or <code>xs:untypedAtomic</code> respectively.</p>
                  <p diff="add" at="N">If an element or attribute node is validated against the type
                        <code>xs:untypedAtomic</code>, the effect is the same as specifying
                        <code>[xsl:]type="xs:string"</code> except that when validation succeeds,
                     the returned element or attribute has a type annotation of
                        <code>xs:untypedAtomic</code>. Validation fails in the case of an element
                     with element children.</p>
                  <p>
                     <error spec="XT" type="static" class="SE" code="1520"><p>It is a <termref
                              def="dt-static-error">static error</termref> if the value of the
                              <code>type</code> attribute of an <elcode>xsl:element</elcode>,
                              <elcode>xsl:attribute</elcode>, <elcode>xsl:copy</elcode>,
                              <elcode>xsl:copy-of</elcode>, <elcode>xsl:document</elcode>, or
                              <elcode>xsl:result-document</elcode> instruction, or the
                              <code>xsl:type</code> attribute of a literal result element, is not a
                           valid <code>QName</code>, or if it uses a prefix that is not defined in
                           an in-scope namespace declaration, or if the QName is not the name of a
                           type definition included in the <termref
                              def="dt-in-scope-schema-component">in-scope schema
                              components</termref> for the <termref def="dt-package" diff="chg"
                              at="R-bug24763">package</termref>.</p></error>
                  </p>
                  <p>
                     <error spec="XT" type="static" class="SE" code="1530"><p>It is a <termref
                              def="dt-static-error">static error</termref> if the value of the
                              <code>type</code> attribute of an <elcode>xsl:attribute</elcode>
                           instruction refers to a complex type definition</p></error>.</p>
                  <p diff="add" at="I">
                     <error spec="XT" type="type" class="TE" code="1535"><p>It is a <termref
                              def="dt-type-error">type error</termref> if the value of the
                              <code>type</code> attribute of an <elcode>xsl:copy</elcode> or
                              <elcode>xsl:copy-of</elcode> instruction refers to a complex type
                           definition and one or more of the items being copied is an attribute
                           node.</p></error></p>
                  <p>
                     <error spec="XT" type="type" class="TE" code="1540"><p>It is a <termref
                              def="dt-type-error">type error</termref> if an <code>[xsl:]type</code>
                           attribute is defined for a constructed element or attribute, and the
                           outcome of schema validity assessment against that type is that the
                              <code>validity</code> property of that element or attribute
                           information item is other than <code>valid</code>.</p></error>
                  </p>
                  <note>
                     <p>Like other type errors, this error may be signaled statically if it can be
                        detected statically. For example, the instruction <code>&lt;xsl:attribute
                           name="dob" type="xs:date"&gt;1999-02-29&lt;/xsl:attribute&gt;</code> may
                        result in a static error being signaled. If the error is not signaled
                        statically, it will be signaled when the instruction is evaluated.</p>
                  </note>
               </div4>
               <div4 id="validation-process">
                  <head>The Validation Process</head>
                  <p>As well as checking for validity against the schema, the validity assessment
                     process causes <termref def="dt-type-annotation">type annotations</termref> to
                     be associated with element and attribute nodes. If default values for elements
                     or attributes are defined in the schema, the validation process will where
                     necessary create new nodes containing these default values.</p>
                  <p>Validation of an element or attribute node only takes into account constraints
                     on the content of the element or attribute. Validation rules affecting the
                     document as a whole are not applied. Specifically, this means:</p>
                  <ulist>
                     <item>
                        <p>The validation rule <quote>Validation Root Valid (ID/IDREF)</quote> is
                           not applied. This means that validation will not fail if there are
                           non-unique ID values or dangling IDREF values in the subtree being
                           validated.</p>
                     </item>
                     <item>
                        <p>The validation rule <quote>Validation Rule: Identity-constraint
                              Satisfied</quote>
                           <rfc2119>should</rfc2119> be applied.</p>
                     </item>
                     <item>
                        <p>There is no check that the document contains unparsed entities whose
                           names match the values of nodes of type <code>xs:ENTITY</code> or
                              <code>xs:ENTITIES</code>. (XSLT <phrase diff="chg" at="A">3.0</phrase>
                           provides no facility to construct unparsed entities within a tree.)</p>
                     </item>
                     <item diff="del" at="R-bug6952">
                        <p>There is no check that the document contains notations whose names match
                           the values of nodes of type <code>xs:NOTATION</code>. (The XDM data model
                           makes no provision for notations to be represented in the tree.)</p>
                     </item>
                  </ulist>
                  <p>With these caveats, validating a newly constructed element, using strict or lax
                     validation, is equivalent to the following steps:</p>
                  <olist>
                     <item>
                        <p>The element is serialized to textual XML form, according to the rules
                           defined in <bibref ref="xslt-xquery-serialization-30"/> using the XML
                           output method, with all parameters defaulted. Note that this process
                           discards any existing <termref def="dt-type-annotation">type
                              annotations</termref>.</p>
                     </item>
                     <item>
                        <p>The resulting XML document is parsed to create an XML Information Set
                           (see <bibref ref="xml-infoset"/>.)</p>
                     </item>
                     <item>
                        <p>The Information Set produced in the previous step is validated according
                           to the rules in <bibref ref="xmlschema-1"/>. The result of this step is a
                           Post-Schema Validation Infoset (PSVI). If the validation process is not
                           successful (as defined above), a <termref def="dt-type-error">type
                              error</termref> is raised.</p>
                     </item>
                     <item>
                        <p>The PSVI produced in the previous step is converted back into the XDM
                           data model by the mapping described in <bibref ref="xpath-datamodel-30"/>
                              (<xspecref spec="DM30" ref="PSVI2Types"/>). This process creates nodes
                           with simple or complex <termref def="dt-type-annotation">type
                              annotations</termref> based on the types established during schema
                           validation.</p>
                     </item>
                  </olist>
                  <p diff="add" at="R-bug6255"> The above process must be done in such a way that
                     the base URI property of every node in the resulting XDM tree is the same as
                     the base URI property of the corresponding node in the input tree. </p>
                  <note diff="add" at="R-bug6255">
                     <p> As an alternative to steps 1 and 2, the XDM tree may be converted to an
                        Infoset directly, using the mapping rules given for each kind of node in
                           <bibref ref="xpath-datamodel-30"/> (Section 6). </p>
                  </note>
                  <p>Validating an attribute using strict or lax validation requires a modified
                     version of this procedure. A copy of the attribute is first added to an element
                     node that is created for the purpose, and namespace fixup (see <specref
                        ref="namespace-fixup"/>) is performed on this element node. The name of this
                     element is of no consequence, but it must be the same as the name of a
                     synthesized element declaration of the form:</p>
                  <eg role="xslt-instruction" xml:space="preserve">&lt;xs:element name="E"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:sequence/&gt;
    &lt;xs:attribute ref="A"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</eg>
                  <p>where A is the name of the attribute being validated.</p>
                  <p>This synthetic element is then validated using the procedure given above for
                     validating elements, and if it is found to be valid, a copy of the validated
                     attribute is made, retaining its <termref def="dt-type-annotation">type
                        annotation</termref>, but detaching it from the containing element (and
                     thus, from any namespace nodes).</p>
                  <p>The XDM data model does not permit an attribute node with no parent to have a
                     typed value that includes a namespace-qualified name, that is, a value whose
                     type is derived from <code>xs:QName</code> or <code>xs:NOTATION</code>. This
                     restriction is imposed because these types rely on the namespace nodes of a
                     containing element to resolve namespace prefixes. Therefore, it is an error to
                     validate a parentless attribute against such a type. This affects the
                     instructions <elcode>xsl:attribute</elcode>, <elcode>xsl:copy</elcode>, and
                        <elcode>xsl:copy-of</elcode>.</p>
                  <p>
                     <error spec="XT" type="type" class="TE" code="1545"><p>A <termref
                              def="dt-type-error">type error</termref> occurs if a <code>type</code>
                           or <code>validation</code> attribute is defined (explicitly or
                           implicitly) for an instruction that constructs a new attribute node, if
                           the effect of this is to cause the attribute value to be validated
                           against a type that is derived from, or constructed by list or union
                           from, the primitive types <code>xs:QName</code> or
                              <code>xs:NOTATION</code>.</p></error>
                  </p>
               </div4>
            </div3>
            <div3 id="validating-document-nodes">
               <head>Validating Document Nodes</head>
               <p>It is possible to apply validation to a document node. This happens when a new
                  document node is constructed by one of the XSLT elements <phrase diff="add" at="Q"
                        ><elcode>xsl:source-document</elcode></phrase>, <phrase diff="add"
                     at="R-bug26766"><elcode>xsl:merge-source</elcode></phrase>,
                     <elcode>xsl:document</elcode>, <elcode>xsl:result-document</elcode>,
                     <elcode>xsl:copy</elcode>, or <elcode>xsl:copy-of</elcode>, and this element
                  has a <code>type</code> attribute, or a <code>validation</code> attribute with the
                  value <code>strict</code> or <code>lax</code>.</p>
               <p>Document-level validation is not applied to the document node that is created
                  implicitly when a variable-binding element has no <code>select</code> attribute
                  and no <code>as</code> attribute (see <specref ref="temporary-trees"/>). This is
                  equivalent to using <code>validation="preserve"</code> on
                     <elcode>xsl:document</elcode>: nodes within such trees retain their <termref
                     def="dt-type-annotation">type annotation</termref>. Similarly, validation is
                  not applied to document nodes created using <elcode>xsl:message</elcode>
                  <phrase diff="add" at="L">or <elcode>xsl:assert</elcode></phrase>. </p>
               <p>The values <code>validation="preserve"</code> and <code>validation="strip"</code>
                  do not request validation. In the first case, all element and attribute nodes
                  within the tree rooted at the new document node retain their <termref
                     def="dt-type-annotation">type annotations</termref>. In the second case,
                  elements within the tree have their type annotation set to
                  <code>xs:untyped</code>, while attributes have their type annotation set to
                     <code>xs:untypedAtomic</code>.</p>
               <p>When validation is requested for a document node (that is, when
                     <code>validation</code> is set to <code>strict</code> or <code>lax</code>, or
                  when a <code>type</code> attribute is present), the following processing takes
                  place:</p>
               <ulist>
                  <item>
                     <p>
                        <error spec="XT" type="type" class="TE" code="1550"><p>A <termref
                                 def="dt-type-error">type error</termref> occurs <error.extra>when a
                                 document node is validated</error.extra> unless the children of the
                              document node comprise exactly one element node, no text nodes, and
                              zero or more comment and processing instruction nodes, in any
                              order.</p></error>
                     </p>
                  </item>
                  <item>
                     <p>The single element node child is validated, using the supplied values of the
                           <code>validation</code> and <code>type</code> attributes, as described in
                           <specref ref="validating-constructed-nodes"/>.</p>
                     <note>
                        <p>The <code>type</code> attribute on <phrase diff="add" at="Q"
                                 ><elcode>xsl:source-document</elcode></phrase>,
                              <elcode>xsl:document</elcode> and
                           <elcode>xsl:result-document</elcode>, and on <elcode>xsl:copy</elcode>
                           and <elcode>xsl:copy-of</elcode> when copying a document node, thus
                           refers to the required type of the element node that is the only element
                           child of the document node. It does not refer to the type of the document
                           node itself.</p>
                     </note>
                  </item>
                  <item>
                     <p>The validation rule <quote>Validation Root Valid (ID/IDREF)</quote> is
                        applied to the single element node child of the document node. This means
                        that validation will fail if there are non-unique ID values or dangling
                        IDREF values in the document tree.</p>
                  </item>
                  <item>
                     <p>Identity constraints, as defined in section 3.11 of <bibref
                           ref="xmlschema-1"/>, are checked. (This refers to constraints defined
                        using <code>xs:unique</code>, <code>xs:key</code>, and
                           <code>xs:keyref</code>.)</p>
                  </item>
                  <item>
                     <p>There is no check that the tree contains unparsed entities whose names match
                        the values of nodes of type <code>xs:ENTITY</code> or
                           <code>xs:ENTITIES</code>. This is because there is no facility in XSLT
                           <phrase diff="chg" at="A">3.0</phrase> to create unparsed entities in a
                           <termref def="dt-result-tree">result tree</termref>. It is possible to
                        add unparsed entity declarations to the result document by referencing a
                        suitable DOCTYPE during serialization.</p>
                  </item>
                  <item diff="del" at="R-bug6952">
                     <p>There is no check that the document contains notations whose names match the
                        values of nodes of type <code>xs:NOTATION</code>. This is because notations
                        are not part of the XDM data model. It is possible to add notations to the
                        result document by referencing a suitable DOCTYPE during serialization.</p>
                  </item>
                  <item>
                     <p>All other children of the document node (comments and processing
                        instructions) are copied unchanged.</p>
                  </item>
               </ulist>
               <p>
                  <error spec="XT" type="type" class="TE" code="1555"><p>It is a <termref
                           def="dt-type-error">type error</termref> if, when validating a document
                        node, document-level constraints (such as ID/IDREF constraints) are not
                        satisfied. <phrase diff="del" at="M">These constraints include identity
                           constraints (<code>xs:unique</code>, <code>xs:key</code>, and
                              <code>xs:keyref</code>) and ID/IDREF constraints.</phrase></p></error>
               </p>
            </div3>
            <div3 id="validating-xml-id" diff="add" at="T-bug29975">
               <head>Validating <code>xml:id</code> attributes</head>
               <p>This section provides a non-normative summary of the effect of validation on
                  attributes named <code>xml:id</code>. The normative rules can be inferred from
                  rules given elsewhere in this section.</p>
               <olist>
                  <item>
                     <p>When an attribute named <code>xml:id</code> is encountered in the course of
                        validation:</p>
                     <olist>
                        <item>
                           <p>A validation error occurs if it the attribute is not lexically valid
                              against type <code>xs:ID</code>.</p>
                        </item>
                        <item>
                           <p>The typed value of the attribute is whitespace-normalized.</p>
                        </item>
                        <item>
                           <p>The attribute is labeled with type annotation <code>xs:ID</code>.</p>
                        </item>
                        <item>
                           <p>The attribute acquires the <code>is-id</code> property.</p>
                        </item>
                     </olist>
                  </item>
                  <item>
                     <p>The previous rule applies whether validation is strict, lax, or by type;
                        validation will never fail (or be skipped) on the grounds that no global
                        attribute declaration named <code>xsl:id</code> is available.</p>
                  </item>
                  <item>
                     <p>Checking <code>xml:id</code> attributes for uniqueness happens if and only
                        if validation is applied at the level of a document node.</p>
                  </item>
               </olist>
            </div3>
         </div2>
      </div1>
      <div1 id="serialization">
         <head>Serialization</head>
         <p>A <termref def="dt-processor">processor</termref>
            <rfc2119>may</rfc2119> output a <termref def="dt-final-result-tree">final result
               tree</termref> as a sequence of octets, although it is not
               <rfc2119>required</rfc2119> to be able to do so (see <specref ref="conformance"/>).
            Stylesheet authors can use <elcode>xsl:output</elcode> declarations to specify how they
            wish result trees to be serialized. If a processor serializes a final result tree, it
               <rfc2119>must</rfc2119> do so as specified by these declarations.</p>
         <p>The rules governing the output of the serializer are defined in <bibref
               ref="xslt-xquery-serialization-30"/>. The serialization is controlled using a number
            of serialization parameters. The values of these serialization parameters may be set
            within the <termref def="dt-stylesheet">stylesheet</termref>, using the
               <elcode>xsl:output</elcode>, <elcode>xsl:result-document</elcode>, and
               <elcode>xsl:character-map</elcode> declarations.</p>
         <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="output">
            <e:in-category name="declaration"/>
            <e:attribute name="name">
               <e:data-type name="eqname"/>
            </e:attribute>
            <e:attribute name="method">
               <e:constant value="xml"/>
               <e:constant value="html"/>
               <e:constant value="xhtml"/>
               <e:constant value="text"/>
               <e:constant value="json"/>
               <e:constant value="adaptive"/>
               <e:data-type name="eqname"/>
            </e:attribute>
            <e:attribute name="allow-duplicate-names">
               <e:data-type name="boolean"/>
            </e:attribute>
            <e:attribute name="build-tree">
               <e:data-type name="boolean"/>
            </e:attribute>
            <e:attribute name="byte-order-mark">
               <e:data-type name="boolean"/>
            </e:attribute>
            <e:attribute name="cdata-section-elements">
               <e:data-type name="eqnames"/>
            </e:attribute>
            <e:attribute name="doctype-public">
               <e:data-type name="string"/>
            </e:attribute>
            <e:attribute name="doctype-system">
               <e:data-type name="string"/>
            </e:attribute>
            <e:attribute name="encoding">
               <e:data-type name="string"/>
            </e:attribute>
            <e:attribute name="escape-uri-attributes">
               <e:data-type name="boolean"/>
            </e:attribute>
            <e:attribute name="html-version">
               <e:data-type name="decimal"/>
            </e:attribute>
            <e:attribute name="include-content-type">
               <e:data-type name="boolean"/>
            </e:attribute>
            <e:attribute name="indent">
               <e:data-type name="boolean"/>
            </e:attribute>
            <e:attribute name="item-separator">
               <e:data-type name="string"/>
            </e:attribute>
            <e:attribute name="json-node-output-method">
               <e:constant value="xml"/>
               <e:constant value="html"/>
               <e:constant value="xhtml"/>
               <e:constant value="text"/>
               <e:data-type name="eqname"/>
            </e:attribute>
            <e:attribute name="media-type">
               <e:data-type name="string"/>
            </e:attribute>
            <e:attribute name="normalization-form">
               <e:constant value="NFC"/>
               <e:constant value="NFD"/>
               <e:constant value="NFKC"/>
               <e:constant value="NFKD"/>
               <e:constant value="fully-normalized"/>
               <e:constant value="none"/>
               <e:data-type name="nmtoken"/>
            </e:attribute>
            <e:attribute name="omit-xml-declaration">
               <e:data-type name="boolean"/>
            </e:attribute>
            <e:attribute name="parameter-document">
               <e:data-type name="uri"/>
            </e:attribute>
            <e:attribute name="standalone">
               <e:data-type name="boolean"/>
               <e:constant value="omit"/>
            </e:attribute>
            <e:attribute name="suppress-indentation">
               <!--see bug 6535-->
               <e:data-type name="eqnames"/>
            </e:attribute>
            <e:attribute name="undeclare-prefixes">
               <e:data-type name="boolean"/>
            </e:attribute>
            <e:attribute name="use-character-maps">
               <e:data-type name="eqnames"/>
            </e:attribute>
            <e:attribute name="version">
               <e:data-type name="nmtoken"/>
            </e:attribute>
            <e:empty/>
            <e:allowed-parents>
               <e:parent name="package"/>
               <e:parent name="stylesheet"/>
               <e:parent name="transform"/>
            </e:allowed-parents>
         </e:element-syntax>
         <p>The <elcode>xsl:output</elcode> declaration is optional; if used, it
               <rfc2119>must</rfc2119> always appear as a <termref def="dt-top-level"
               >top-level</termref> element within a stylesheet module.</p>
         <p>A <termref def="dt-stylesheet">stylesheet</termref> may contain multiple
               <elcode>xsl:output</elcode> declarations and may include or import stylesheet modules
            that also contain <elcode>xsl:output</elcode> declarations. The name of an
               <elcode>xsl:output</elcode> declaration is the value of its <code>name</code>
            attribute, if any.</p>
         <p>
            <termdef id="dt-output-definition" term="output definition">All the
                  <elcode>xsl:output</elcode> declarations <phrase diff="chg" at="I">within a
                     <termref def="dt-package">package</termref></phrase> that share the same name
               are grouped into a named <term>output definition</term>; those that have no name are
               grouped into a single unnamed output definition.</termdef>
         </p>
         <p diff="add" at="I">An output definition is scoped to a package. If this is a <termref
               def="dt-library-package">library package</termref> the output definition applies only
            to <elcode>xsl:result-document</elcode> instructions within the same package. If it is
            the <termref def="dt-top-level-package">top-level package</termref>, the output
            definition applies to <elcode>xsl:result-document</elcode> instructions within the same
            package and also to the implicit <termref def="dt-final-result-tree">final result
               tree</termref>.</p>
         <p>A stylesheet always includes an unnamed <termref def="dt-output-definition">output
               definition</termref>; in the absence of an unnamed <elcode>xsl:output</elcode>
            declaration, the unnamed output definition is equivalent to the one that would be used
            if the stylesheet contained an <elcode>xsl:output</elcode> declaration having no
            attributes.</p>
         <p>A named <termref def="dt-output-definition">output definition</termref> is used when its
            name matches the <code>format</code> attribute used in an
               <elcode>xsl:result-document</elcode> element. The unnamed output definition is used
            when an <elcode>xsl:result-document</elcode> element omits the <code>format</code>
            attribute. It is also used when serializing the <phrase diff="add" at="S-bug27258"
                  ><termref def="dt-principal-result"/>.</phrase>
            <phrase diff="del" at="S-bug27258"><termref def="dt-final-result-tree">final result
                  tree</termref> that is created implicitly in the absence of an
                  <elcode>xsl:result-document</elcode> element</phrase>.</p>
         <p>All the <elcode>xsl:output</elcode> elements making up an <termref
               def="dt-output-definition">output definition</termref> are effectively merged. For
            those attributes whose values are namespace-sensitive, the merging is done after
               <termref def="dt-lexical-qname">lexical QNames</termref> have been converted into
               <termref def="dt-expanded-qname">expanded QNames</termref>. For the
               <code>cdata-section-elements</code>
            <phrase diff="add" at="B">and <code>suppress-indentation</code></phrase> attributes, the
            output definition uses the union of the values from all the constituent
               <elcode>xsl:output</elcode> declarations. For the <code>use-character-maps</code>
            attribute, the output definition uses the concatenation of the sequences of <termref
               def="dt-expanded-qname">expanded QNames</termref> values from all the constituent
               <elcode>xsl:output</elcode> declarations, taking them in order of increasing <termref
               def="dt-import-precedence">import precedence</termref>, or where several have the
            same import precedence, in <termref def="dt-declaration-order">declaration
               order</termref>. For other attributes, the <termref def="dt-output-definition">output
               definition</termref> uses the value of that attribute from the
               <elcode>xsl:output</elcode> declaration with the highest <termref
               def="dt-import-precedence">import precedence</termref>.</p>
         <p diff="add" at="N">The <code>parameter-document</code> attribute allows serialization
            parameters to be supplied in an external document. The external document must contain an
               <code>output:serialization-parameters</code> element with the format described in
               <xspecref spec="SER30" ref="serparams-in-xdm-instance"/>, and the parameters are
            interpreted as described in that specification.</p>
         <p diff="add" at="N">If present, the URI supplied in the <code>parameter-document</code>
            attribute is dereferenced, after resolution against the base URI of the
               <elcode>xsl:output</elcode> element if it is a relative reference. <phrase diff="add"
               at="S-bug29162">The parameter document <rfc2119>should</rfc2119> be read during
               static analysis of the stylesheet. </phrase> A serialization error occurs if the
            result of dereferencing the URI is ill-formed or invalid; but if no document can be
            found at the specified location, the attribute <rfc2119>should</rfc2119> be ignored.</p>
         <p diff="add" at="N">A serialization parameter specified in the
               <code>parameter-document</code> takes precedence over a value supplied directly in
            the output declaration, except that the values of the
               <code>cdata-section-elements</code> and <code>suppress-indentation</code> attributes
            are merged in the same way as when multiple <elcode>xsl:output</elcode> declarations are
            merged.</p>
         <p>
            <error spec="XT" type="static" class="SE" code="1560"><p>It is a <termref
                     def="dt-static-error">static error</termref> if two <elcode>xsl:output</elcode>
                  declarations within an <termref def="dt-output-definition">output
                     definition</termref> specify explicit values for the same attribute (other than
                     <code>cdata-section-elements</code>, <phrase diff="add" at="R-bug24237"
                        ><code>suppress-indentation</code>,</phrase> and
                     <code>use-character-maps</code>), with the values of the attributes being not
                  equal, unless there is another <elcode>xsl:output</elcode> declaration within the
                  same <termref def="dt-output-definition">output definition</termref> that has
                  higher import precedence and that specifies an explicit value for the same
                  attribute. </p></error>
         </p>
         <p diff="add" at="S-bug27258">The <code>build-tree</code> attribute controls whether the
            raw <termref def="dt-principal-result"/> or <termref def="dt-secondary-result"/> is
            converted to a <termref def="dt-final-result-tree"/>. The default depends on the value
            of the <code>method</code> attribute: the default is <code>yes</code> if the
               <code>method</code> attribute specifies <code>xml</code>, <code>html</code>,
               <code>xhtml</code>, or <code>text</code>, or if it is omitted; <phrase diff="add"
               at="S-bug24266">the default is <code>no</code> if the <code>method</code> attribute
               specifies <code>json</code> or <code>adaptive</code></phrase>. A <termref
               def="dt-final-result-tree"/> may be constructed whether or not it is subsequently
            serialized.</p>
         <note diff="add" at="S-bug27258">
            <p>The default for <code>build-tree</code> may differ for user-defined serialization
               methods or for serialization methods introduced in future versions of this
               specification.</p>
         </note>
         <p diff="add" at="S-bug24266">Unless the processor implements the <termref
               def="dt-xpath31-feature"/>, the <code>method</code> values <code>json</code> and
               <code>adaptive</code>
            <rfc2119>must</rfc2119> be rejected as invalid, and the attributes
               <code>allow-duplicate-names</code> and <code>json-node-output-method</code>
            <rfc2119>must</rfc2119> be ignored. The meaning of these output methods and
            serialization parameters is defined in <bibref ref="xslt-xquery-serialization-31"/>.</p>
         <p>If none of the <elcode>xsl:output</elcode> declarations within an <termref
               def="dt-output-definition">output definition</termref> specifies a value for a
            particular attribute, then the corresponding serialization parameter takes a default
            value. The default value depends on the chosen output method.</p>
         <p>There are some serialization parameters that apply to some output methods but not to
            others. For example, the <code>indent</code> attribute has no effect on the
               <code>text</code> output method. If a value is supplied for an attribute that is
            inapplicable to the output method, its value is not passed to the serializer. The
            processor <rfc2119>may</rfc2119> validate the value of such an attribute, but is not
               <rfc2119>required</rfc2119> to do so.</p>
         <p>An implementation <rfc2119>may</rfc2119> allow the attributes of the
               <elcode>xsl:output</elcode> declaration to be overridden, or the default values to be
            changed, using the API that controls the transformation.</p>
         <p>The location to which <termref def="dt-final-result-tree">final result trees</termref>
            are serialized (whether in filestore or elsewhere) is <termref
               def="dt-implementation-defined">implementation-defined</termref> (which in practice
               <rfc2119>may</rfc2119> mean that it is controlled using an implementation-defined
            API). However, these locations <rfc2119>must</rfc2119> satisfy the constraint that when
            two <termref def="dt-final-result-tree">final result trees</termref> are both created
            (implicitly or explicitly) using relative URI <phrase diff="add" at="F"
               >references</phrase> in the <code>href</code> attribute of the
               <elcode>xsl:result-document</elcode> instruction, then these relative URI <phrase
               diff="add" at="F">references</phrase> may be used to construct references from one
            tree to the other, and such references <rfc2119>must</rfc2119> remain valid when both
            result trees are serialized. </p>
         <imp-def-feature id="idf-api-serializationlocation">If serialization is supported, then the
            location to which a <termref def="dt-final-result-tree">final result tree</termref> is
            serialized is implementation-defined, subject to the constraint that relative URI
               <phrase diff="add" at="F">references</phrase> used to reference one tree from another
            remain valid.</imp-def-feature>
         <p>The <code>method</code> attribute on the <elcode>xsl:output</elcode> element identifies
            the overall method that is to be used for outputting the <termref
               def="dt-final-result-tree">final result tree</termref>.</p>
         <p diff="chg" at="K">
            <error spec="XT" type="static" class="SE" code="1570"><p>The value <error.extra>of the
                        <code>method</code> attribute on <elcode>xsl:output</elcode>
                  </error.extra>
                  <rfc2119>must</rfc2119> (if present) be a valid <termref def="dt-eqname"
                     >EQName</termref>. If it is a <termref def="dt-lexical-qname">lexical
                     QName</termref> with no a prefix, then it identifies a method specified in
                     <bibref ref="xslt-xquery-serialization-30"/> and <rfc2119>must</rfc2119> be one
                  of <code>xml</code>, <code>html</code>, <code>xhtml</code>, or
                  <code>text</code>.</p></error> If it is a <termref def="dt-lexical-qname">lexical
               QName</termref> with a prefix, then the <termref def="dt-lexical-qname">lexical
               QName</termref> is expanded into an <termref def="dt-expanded-qname">expanded
               QName</termref> as described in <specref ref="qname"/>; the <termref
               def="dt-expanded-qname">expanded QName</termref> identifies the output method; the
            behavior in this case is not specified by this document.</p>
         <p>The default for the <code>method</code> attribute depends on the contents of the tree
            being serialized, and is chosen as follows. If the document node of the <termref
               def="dt-final-result-tree">final result tree</termref> has an element child, and any
            text nodes preceding the first element child of the document node of the result tree
            contain only whitespace characters, then:</p>
         <ulist>
            <item>
               <p>If the <termref def="dt-expanded-qname">expanded QName</termref> of this first
                  element child has local part <code>html</code> (in lower case), and namespace URI
                     <code>http://www.w3.org/1999/xhtml</code>, then the default output method is
                  normally <code>xhtml</code>. However, <phrase diff="chg" at="R-bug24235">if the
                        <termref def="dt-effective-version"/> of the outermost element of the
                        <termref def="dt-principal-stylesheet-module">principal stylesheet
                        module</termref> in the <termref def="dt-top-level-package"/> has the value
                        <code>1.0</code>,</phrase> and if the result tree is generated implicitly
                  (rather than by an explicit <elcode>xsl:result-document</elcode> instruction),
                  then the default output method in this situation is <code>xml</code>.</p>
            </item>
            <item>
               <p>If the <termref def="dt-expanded-qname">expanded QName</termref> of this first
                  element child has local part <code>html</code> (in any combination of upper and
                  lower case) and a null namespace URI, then the default output method is
                     <code>html</code>.</p>
            </item>
         </ulist>
         <p>In all other cases, the default output method is <code>xml</code>.</p>
         <p>The default output method is used if the selected <termref def="dt-output-definition"
               >output definition</termref> does not include a <code>method</code> attribute.</p>
         <p>The other attributes on <elcode>xsl:output</elcode> provide parameters for the output
            method. The following attributes are allowed:</p>
         <ulist>
            <item>
               <p> The value of the <code>encoding</code> attribute provides the value of the
                     <code>encoding</code> parameter to the serialization method. The default value
                  is <termref def="dt-implementation-defined"/>, but in the case of the
                     <code>xml</code> and <code>xhtml</code> methods it <rfc2119>must</rfc2119> be
                  either <code>UTF-8</code> or <code>UTF-16</code>. </p>
               <imp-def-feature id="idf-defaults-serialization">The default value of the
                     <code>encoding</code> attribute of the <elcode>xsl:output</elcode> element is
                  implementation-defined. Where the encoding is UTF-8, the default for the
                     <code>byte-order-mark</code> attribute is
                  implementation-defined.</imp-def-feature>
            </item>
            <item>
               <p>The <code>byte-order-mark</code> attribute defines whether a byte order mark is
                  written at the start of the file. If the value <code>yes</code> is specified, a
                  byte order mark is written; if <code>no</code> is specified, no byte order mark is
                  written. The default value depends on the encoding used. If the encoding is
                     <code>UTF-16</code>, the default is <code>yes</code>; for <code>UTF-8</code> it
                  is <termref def="dt-implementation-defined"/>, and for all other encodings it is
                     <code>no</code>. The value of the byte order mark indicates whether high order
                  bytes are written before or after low order bytes; the actual byte order used is
                     <termref def="dt-implementation-dependent">implementation-dependent</termref>,
                  unless it is defined by the selected encoding. </p>
            </item>
            <item>
               <p> The <code>cdata-section-elements</code> attribute is a whitespace-separated list
                  of QNames. The default value is an empty list. After expansion of these names
                  using the in-scope namespace declarations for the <elcode>xsl:output</elcode>
                  declaration in which they appear, this list of names provides the value of the
                     <code>cdata-section-elements</code> parameter to the serialization method. In
                  the case of an unprefixed name, the default namespace (that is, the namespace
                  declared using <code>xmlns="uri"</code>) is used. </p>
               <note>
                  <p>This differs from the rule for most other QNames used in a stylesheet. The
                     reason is that these names refer to elements in the result document, and
                     therefore follow the same convention as the name of a literal result element or
                     the <code>name</code> attribute of <elcode>xsl:element</elcode>.</p>
               </note>
            </item>
            <item>
               <p> The value of the <code>doctype-system</code> attribute provides the value of the
                     <code>doctype-system</code> parameter to the serialization method. <phrase
                     diff="chg" at="P-erratumE32">If the attribute is absent or has a zero-length
                     string as its value, then the serialization parameter is not set (is
                     “absent”).</phrase>
               </p>
            </item>
            <item>
               <p> The value of the <code>doctype-public</code> attribute provides the value of the
                     <code>doctype-public</code> parameter to the serialization method. <phrase
                     diff="chg" at="P-erratumE32">If the attribute is absent or has a zero-length
                     string as its value, then the serialization parameter is not set (is
                     “absent”).</phrase>
               </p>
               <p>The value of <code>doctype-public</code> must conform to the rules for a <xnt
                     xmlns:xlink="http://www.w3.org/1999/xlink" spec="XML" ref="PubidLiteral"
                     xlink:type="simple">PubidLiteral</xnt> (see <bibref ref="REC-xml"/>).</p>
            </item>
            <item>
               <p> The value of the <code>escape-uri-attributes</code> attribute provides the value
                  of the <code>escape-uri-attributes</code> parameter to the serialization method.
                  The default value is <code>yes</code>. </p>
            </item>
            <item>
               <p diff="add" at="M"> The value of the <code>html-version</code> attribute provides
                  the value of the <code>html-version</code> parameter to the serialization method.
                  The set of permitted values, and the default value, are <termref
                     def="dt-implementation-defined">implementation-defined</termref>. A <termref
                     def="dt-serialization-error">serialization error</termref> will be reported if
                  the requested version is not supported by the implementation. </p>
               <note>
                  <p diff="add" at="M">This serialization parameter is new in version 3.0. If it is
                     absent, the html output method uses the value of the <code>version</code>
                     parameter in its place. For XHTML serialization, the <code>html-version</code>
                     parameter indicates the version of XHTML to be used, while the
                        <code>version</code> parameter indicates the version of XML.</p>
               </note>
            </item>
            <item>
               <p> The value of the <code>include-content-type</code> attribute provides the value
                  of the <code>include-content-type</code> parameter to the serialization method.
                  The default value is <code>yes</code>. </p>
            </item>
            <item>
               <p> The value of the <code>indent</code> attribute provides the value of the
                     <code>indent</code> parameter to the serialization method. The default value is
                     <code>yes</code> in the case of the <code>html</code> and <code>xhtml</code>
                  output methods, <code>no</code> in the case of the <code>xml</code> output method.
               </p>
            </item>
            <item>
               <p> The value of the <code>item-separator</code> attribute provides the value of the
                     <code>item-separator</code> parameter to the serialization method. The value of
                  the serialization parameter can be any string (including a zero-length string), or
                  absent. To set the parameter to absent, the <code>item-separator</code> attribute
                  can either be omitted, or set to the special value
                     <code>item-separator="#absent"</code>; it is not possible to set the value of
                  the serialization parameter to the literal 7-character string
                     <code>"#absent"</code>. </p>
               <note>
                  <p diff="add" at="S-bug27258">The <code>item-separator</code> attribute has no
                     effect if the sequence being serialized contains only one item, which will
                     always be the case if the effective value of <code>build-tree</code> is
                        <code>yes</code>.</p>
               </note>
            </item>
            <item>
               <p> The value of the <code>media-type</code> attribute provides the value of the
                     <code>media-type</code> parameter to the serialization method. The default
                  value is <code>text/xml</code> in the case of the <code>xml</code> output method,
                     <code>text/html</code> in the case of the <code>html</code> and
                     <code>xhtml</code> output methods, and <code>text/plain</code> in the case of
                  the <code>text</code> output method. </p>
            </item>
            <item>
               <p> The value of the <code>normalization-form</code> attribute provides the value of
                  the <code>normalization-form</code> parameter to the serialization method. A value
                  that is an <code>NMTOKEN</code> other than one of those enumerated for the
                     <code>normalization-form</code> attribute specifies an implementation-defined
                  normalization form; the behavior in this case is not specified by this document.
                  The default value is <code>none</code>. </p>
            </item>
            <item>
               <p> The value of the <code>omit-xml-declaration</code> attribute provides the value
                  of the <code>omit-xml-declaration</code> parameter to the serialization method.
                  The default value is <code>no</code>. </p>
            </item>
            <item>
               <p> The value of the <code>standalone</code> attribute provides the value of the
                     <code>standalone</code> parameter to the serialization method. The default
                  value is <code>omit</code>; this means that no <code>standalone</code> attribute
                  is to be included in the XML declaration. </p>
            </item>
            <item diff="add" at="A">
               <p> The <code>suppress-indentation</code> attribute is a whitespace-separated list of
                  QNames. The default value is an empty list. After expansion of these names using
                  the in-scope namespace declarations for the <elcode>xsl:output</elcode>
                  declaration in which they appear, this list of names provides the value of the
                     <code>suppress-indentation</code> parameter to the serialization method. In the
                  case of an unprefixed name, the default namespace (that is, the namespace declared
                  using <code>xmlns="uri"</code>) is used. </p>
               <note>
                  <p>This differs from the rule for most other QNames used in a stylesheet. The
                     reason is that these names refer to elements in the result document, and
                     therefore follow the same convention as the name of a literal result element or
                     the <code>name</code> attribute of <elcode>xsl:element</elcode>.</p>
               </note>
            </item>
            <item>
               <p diff="chg" at="T-bug29933"> The value of the <code>undeclare-prefixes</code>
                  attribute provides the value of the <code>undeclare-prefixes</code> parameter to
                  the serialization method. The default value is <code>no</code>.</p>
            </item>
            <item>
               <p>The <code>use-character-maps</code> attribute provides a list of named character
                  maps that are used in conjunction with this <termref def="dt-output-definition"
                     >output definition</termref>. The way this attribute is used is described in
                     <specref ref="character-maps"/>. The default value is an empty list.</p>
            </item>
            <item>
               <p> The value of the <code>version</code> attribute provides the value of the
                     <code>version</code> parameter to the serialization method. The set of
                  permitted values, and the default value, are <termref
                     def="dt-implementation-defined">implementation-defined</termref>. A <termref
                     def="dt-serialization-error">serialization error</termref> will be reported if
                  the requested version is not supported by the implementation. </p>
            </item>
         </ulist>
         <p diff="del" at="S-bug27258">The <code>item-separator</code> serialization parameter
            defined in <bibref ref="xslt-xquery-serialization-30"/> is not available in
               <elcode>xsl:output</elcode>; it is not applicable, because the sequence that is
            serialized by XSLT is always a singleton document node. Formally therefore, the
            serializer is always invoked passing an empty string as the value of this parameter.</p>
         <imp-def-feature id="idf-spec-serversions">It is implementation-defined which versions of
            XML, HTML, and XHTML are supported in the <code>version</code> attribute of the
               <elcode>xsl:output</elcode> declaration.</imp-def-feature>
         <p>If the processor performs serialization, then it must signal any <phrase diff="del"
               at="M">non-recoverable</phrase> serialization errors that occur. These have the same
            effect as <termref def="dt-dynamic-error"><phrase diff="del" at="M"
                  >non-recoverable</phrase> dynamic errors</termref>: that is, the processor must
            signal the error and must not finish as if the transformation had been successful.</p>
         <div2 id="character-maps">
            <head>Character Maps</head>
            <p>
               <termdef id="dt-character-map" term="character map">A <term>character map</term>
                  allows a specific character appearing in a text or attribute node in the <termref
                     def="dt-final-result-tree">final result tree</termref> to be substituted by a
                  specified string of characters during serialization.</termdef> The effect of
               character maps is defined in <bibref ref="xslt-xquery-serialization-30"/>.</p>
            <p>The character map that is supplied as a parameter to the serializer is determined
               from the <elcode>xsl:character-map</elcode> elements referenced from the
                  <elcode>xsl:output</elcode> declaration for the selected <termref
                  def="dt-output-definition">output definition</termref>.</p>
            <p>The <elcode>xsl:character-map</elcode> element is a declaration that may appear as a
               child of the <elcode>xsl:stylesheet</elcode> element.</p>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="character-map">
               <e:in-category name="declaration"/>
               <e:attribute name="name" required="yes">
                  <e:data-type name="eqname"/>
               </e:attribute>
               <e:attribute name="use-character-maps">
                  <e:data-type name="eqnames"/>
               </e:attribute>
               <e:sequence>
                  <e:element repeat="zero-or-more" name="output-character"/>
               </e:sequence>
               <e:allowed-parents>
                  <e:parent name="package"/>
                  <e:parent name="stylesheet"/>
                  <e:parent name="transform"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:character-map</elcode> declaration declares a character map with a
               name and a set of character mappings. The character mappings are specified by means
               of <elcode>xsl:output-character</elcode> elements contained either directly within
               the <elcode>xsl:character-map</elcode> element, or in further character maps
               referenced in the <code>use-character-maps</code> attribute.</p>
            <p>The <rfc2119>required</rfc2119>
               <code>name</code> attribute provides a name for the character map. When a character
               map is used by an <termref def="dt-output-definition">output definition</termref> or
               another character map, the character map with the highest <termref
                  def="dt-import-precedence">import precedence</termref> is used.</p>
            <p diff="add" at="I">The name of a character map is local to the <termref
                  def="dt-package">package</termref> in which its declaration appears; it may be
               referenced only from within the same package.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="1580"><p>It is a <termref
                        def="dt-static-error">static error</termref> if a <termref def="dt-package"
                        diff="chg" at="R-bug24763">package</termref> contains two or more character
                     maps with the same name and the same <termref def="dt-import-precedence">import
                        precedence</termref>, unless it also contains another character map with the
                     same name and higher import precedence.</p></error>
            </p>
            <p>The optional <code>use-character-maps</code> attribute lists the names of further
               character maps that are included into this character map.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="1590"><p>It is a <termref
                        def="dt-static-error">static error</termref> if a name in the
                        <code>use-character-maps</code> attribute of the <elcode>xsl:output</elcode>
                     or <elcode>xsl:character-map</elcode> elements does not match the
                        <code>name</code> attribute of any <elcode>xsl:character-map</elcode> in the
                        <phrase diff="chg" at="R-bug24763">containing <termref def="dt-package"
                           >package</termref></phrase>.</p></error>
            </p>
            <p>
               <error spec="XT" type="static" class="SE" code="1600"><p>It is a <termref
                        def="dt-static-error">static error</termref> if a character map references
                     itself, directly or indirectly, via a name in the
                        <code>use-character-maps</code> attribute.</p></error>
            </p>
            <p>It is not an error if the same character map is referenced more than once, directly
               or indirectly.</p>
            <p>An <termref def="dt-output-definition">output definition</termref>, after recursive
               expansion of character maps referenced via its <code>use-character-maps</code>
               attribute, may contain several mappings for the same character. In this situation,
               the last character mapping takes precedence. To establish the ordering, the following
               rules are used:</p>
            <ulist>
               <item>
                  <p>Within a single <elcode>xsl:character-map</elcode> element, the characters
                     defined in character maps referenced in the <code>use-character-maps</code>
                     attribute are considered before the characters defined in the child
                        <elcode>xsl:output-character</elcode> elements.</p>
               </item>
               <item>
                  <p>The character maps referenced in a single <code>use-character-maps</code>
                     attribute are considered in the order in which they are listed in that
                     attribute. The expansion is depth-first: each referenced character map is fully
                     expanded before the next one is considered.</p>
               </item>
               <item>
                  <p>Two <elcode>xsl:output-character</elcode> elements appearing as children of the
                     same <elcode>xsl:character-map</elcode> element are considered in document
                     order.</p>
               </item>
            </ulist>
            <p>The <elcode>xsl:output-character</elcode> element is defined as follows:</p>
            <e:element-syntax xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="output-character">
               <e:attribute name="character" required="yes">
                  <e:data-type name="char"/>
               </e:attribute>
               <e:attribute name="string" required="yes">
                  <e:data-type name="string"/>
               </e:attribute>
               <e:empty/>
               <e:allowed-parents>
                  <e:parent name="character-map"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The character map that is passed as a parameter to the serializer contains a mapping
               for the character specified in the <code>character</code> attribute to the string
               specified in the <code>string</code> attribute. </p>
            <p>Character mapping is not applied to characters for which output escaping has been
               disabled as described in <specref ref="disable-output-escaping"/>.</p>
            <p>If a character is mapped, then it is not subjected to XML or HTML escaping.</p>
            <example>
               <head>Using Character Maps to Generate Non-XML Output</head>
               <p>Character maps can be useful when producing serialized output in a format that
                  resembles, but is not strictly conformant to, HTML or XML. For example, when the
                  output is a JSP page, there might be a need to generate the output:</p>
               <eg role="non-xml" xml:space="preserve">&lt;jsp:setProperty name="user" property="id" value='&lt;%= "id" + idValue %&gt;'/&gt;</eg>
               <p>Although this output is not well-formed XML or HTML, it is valid in Java Server
                  Pages. This can be achieved by allocating three Unicode characters (which are not
                  needed for any other purpose) to represent the strings <code>&lt;%</code>,
                     <code>%&gt;</code>, and <code>"</code>, for example:</p>
               <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:character-map name="jsp"&gt;
  &lt;xsl:output-character character="«" string="&amp;lt;%"/&gt;   
  &lt;xsl:output-character character="»" string="%&amp;gt;"/&gt;
  &lt;xsl:output-character character="§" string='"'/&gt;
&lt;/xsl:character-map&gt;</eg>
               <p>When this character map is referenced in the <elcode>xsl:output</elcode>
                  declaration, the required output can be produced by writing the following in the
                  stylesheet:</p>
               <eg role="non-xml" xml:space="preserve">&lt;jsp:setProperty name="user" property="id" value='«= §id§ + idValue »'/&gt;</eg>
               <p>This works on the assumption that when an apostrophe or quotation mark is
                  generated as part of an attribute value by the use of character maps, the
                  serializer will (where possible) use the other choice of delimiter around the
                  attribute value.</p>
            </example>
            <example>
               <head>Constructing a Composite Character Map</head>
               <p>The following example illustrates a composite character map constructed in a
                  modular fashion:</p>
               <eg role="xslt-declarations" xml:space="preserve">
&lt;xsl:output name="htmlDoc" use-character-maps="htmlDoc" /&gt;

&lt;xsl:character-map name="htmlDoc"
  use-character-maps="html-chars doc-entities windows-format" /&gt;
  
&lt;xsl:character-map name="html-chars"
  use-character-maps="latin1 ..." /&gt;

&lt;xsl:character-map name="latin1"&gt;
  &lt;xsl:output-character character="&amp;#160;" string="&amp;amp;nbsp;" /&gt;
  &lt;xsl:output-character character="&amp;#161;" string="&amp;amp;iexcl;" /&gt;
  ...
&lt;/xsl:character-map&gt;

&lt;xsl:character-map name="doc-entities"&gt;
  &lt;xsl:output-character character="&amp;#xE400;" string="&amp;amp;t-and-c;" /&gt;
  &lt;xsl:output-character character="&amp;#xE401;" string="&amp;amp;chap1;" /&gt;
  &lt;xsl:output-character character="&amp;#xE402;" string="&amp;amp;chap2;" /&gt;
  ...
&lt;/xsl:character-map&gt;

&lt;xsl:character-map name="windows-format"&gt;
  &lt;!-- newlines as CRLF --&gt;
  &lt;xsl:output-character character="&amp;#xA;" string="&amp;#xD;&amp;#xA;" /&gt;

  &lt;!-- tabs as three spaces --&gt;
  &lt;xsl:output-character character="&amp;#x9;" string="   " /&gt;

  &lt;!-- images for special characters --&gt;
  &lt;xsl:output-character character="&amp;#xF001;"
    string="&amp;lt;img src='special1.gif' /&amp;gt;" /&gt;
  &lt;xsl:output-character character="&amp;#xF002;"
    string="&amp;lt;img src='special2.gif' /&amp;gt;" /&gt;
  ...
&lt;/xsl:character-map&gt;</eg>
            </example>
            <note diff="add" at="P-erratumE27">
               <p>When character maps are used, there is no guarantee that the serialized output
                  will be well-formed XML (or HTML). Furthermore, the fact that the result tree was
                  validated against a schema gives no guarantee that the serialized output will
                  still be valid against the same schema. Conversely, it is possible to use
                  character maps to produce schema-valid output from a result tree that would fail
                  validation.</p>
            </note>
         </div2>
         <div2 id="disable-output-escaping">
            <head>Disabling Output Escaping</head>
            <p>Normally, when using the XML, HTML, or XHTML output method, the serializer will
               escape special characters such as <code>&amp;</code> and <code>&lt;</code> when
               outputting text nodes. This ensures that the output is well-formed. However, it is
               sometimes convenient to be able to produce output that is almost, but not quite
               well-formed XML; for example, the output may include ill-formed sections which are
               intended to be transformed into well-formed XML by a subsequent non-XML-aware
               process. For this reason, XSLT defines a mechanism for disabling output escaping.</p>
            <p>This feature is <termref def="dt-deprecated">deprecated</termref>.</p>
            <p>This is an optional feature: it is not <rfc2119>required</rfc2119> that an XSLT
               processor that implements the serialization option <rfc2119>should</rfc2119> offer
               the ability to disable output escaping, and there is no conformance level that
               requires this feature.</p>
            <p>This feature that the serializer (described in <bibref
                  ref="xslt-xquery-serialization-30"/>) be extended as follows. Conceptually, the
                  <termref def="dt-final-result-tree">final result tree</termref> provides an
               additional boolean property <code>disable-escaping</code> associated with every
               character in a text node. When this property is set, the normal action of the
               serializer to escape special characters such as <code>&amp;</code> and
                  <code>&lt;</code> is suppressed.</p>
            <p>An <elcode>xsl:value-of</elcode> or <elcode>xsl:text</elcode> element may have a
                  <code>disable-output-escaping</code> attribute; the allowed values are
                  <code>yes</code> or <code>no</code>. The default is <code>no</code>; if the value
               is <code>yes</code>, then every character in the text node generated by evaluating
               the <elcode>xsl:value-of</elcode> or <elcode>xsl:text</elcode> element
                  <rfc2119>should</rfc2119> have the <code diff="chg" at="P-erratumE32"
                  >disable-escaping</code> property set.</p>
            <example>
               <head>Disable Output Escaping</head>
               <p>For example,</p>
               <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:text disable-output-escaping="yes"&gt;&amp;lt;&lt;/xsl:text&gt;</eg>
               <p>should generate the single character <code>&lt;</code>.</p>
            </example>
            <p>If output escaping is disabled for an <elcode>xsl:value-of</elcode> or
                  <elcode>xsl:text</elcode> instruction evaluated when <termref
                  def="dt-temporary-output-state">temporary output state</termref> is in effect, the
               request to disable output escaping is ignored.</p>
            <p diff="add" at="M">Similarly, if an <elcode>xsl:value-of</elcode> or
                  <elcode>xsl:text</elcode> instruction specifies that output escaping is to be
               disabled when writing to a <termref def="dt-final-result-tree">final result
                  tree</termref> that is not being serialized, the request to disable output
               escaping is ignored.</p>
            <note diff="add" at="V-bug30109">
               <p>Furthermore, a request to disable output escaping has no effect when the newly
                  constructed text node is used to form the value of an attribute, comment,
                  processing instruction, or namespace node. This is because the rules for
                  constructing such nodes (see <specref ref="constructing-simple-content"/>) cause
                  the text node to be atomized, and the process of atomizing a text node takes no
                  account of the disable-escaping property.</p>
            </note>
            <p>If output escaping is disabled for text within an element that would normally be
               output using a CDATA section, because the element is listed in the
                  <code>cdata-section-elements</code>, then the relevant text will not be included
               in a CDATA section. In effect, CDATA is treated as an alternative escaping mechanism,
               which is disabled by the <code>disable-output-escaping</code> option.</p>
            <example>
               <head>Interaction of Output Escaping and CDATA</head>
               <p>For example, if <code>&lt;xsl:output cdata-section-elements="title"/&gt;</code> is
                  specified, then the following instructions:</p>
               <eg role="xslt-instruction" xml:space="preserve">&lt;title&gt;
  &lt;xsl:text disable-output-escaping="yes"&gt;This is not &amp;lt;hr/&amp;gt; 
                                          good coding practice&lt;/xsl:text&gt;
&lt;/title&gt;</eg>
               <p>should generate the output:</p>
               <eg role="xml" xml:space="preserve">&lt;title&gt;&lt;![CDATA[This is not ]]&gt;&lt;hr/&gt;&lt;![CDATA[ good coding practice]]&gt;&lt;/title&gt;</eg>
            </example>
            <p>The <code>disable-output-escaping</code> attribute may be used with the
                  <code>html</code> output method as well as with the <code>xml</code> output
               method. The <code>text</code> output method ignores the
                  <code>disable-output-escaping</code> attribute, since this method does not perform
               any output escaping.</p>
            <p>A <termref def="dt-processor">processor</termref> will only be able to disable output
               escaping if it controls how the <termref def="dt-final-result-tree">final result
                  tree</termref> is output. This might not always be the case. For example, the
               result tree might be used as a <termref def="dt-source-tree">source tree</termref>
               for another XSLT transformation instead of being output. It is <termref
                  def="dt-implementation-defined">implementation-defined</termref> whether (and
               under what circumstances) disabling output escaping is supported. <phrase diff="add"
                  at="M">If disabling output escaping is not supported, any request to disable
                  output escaping is ignored.</phrase></p>
            <p diff="del" at="M">
               <error spec="XT" type="dynamic" class="RE" code="1620"><p>It is a recoverable dynamic
                     error if an <elcode>xsl:value-of</elcode> or <elcode>xsl:text</elcode>
                     instruction specifies that output escaping is to be disabled and the
                     implementation does not support this. <error.action>The optional recovery
                        action is to ignore the <code>disable-output-escaping</code>
                        attribute.</error.action>
                  </p></error>
            </p>
            <p diff="del" at="M">
               <error spec="XT" type="dynamic" class="RE" code="1630"><p>It is a recoverable dynamic
                     error if an <elcode>xsl:value-of</elcode> or <elcode>xsl:text</elcode>
                     instruction specifies that output escaping is to be disabled when writing to a
                        <termref def="dt-final-result-tree">final result tree</termref> that is not
                     being serialized. <error.action>The optional recovery action is to ignore the
                           <code>disable-output-escaping</code> attribute.</error.action>
                  </p></error>
            </p>
            <imp-def-feature id="idf-feature-doe">It is implementation-defined whether, and under
               what circumstances, disabling output escaping is supported.</imp-def-feature>
            <p>If output escaping is disabled for a character that is not representable in the
               encoding that the <termref def="dt-processor">processor</termref> is using for
               output, the request to disable output escaping is ignored in respect of that
               character.</p>
            <p>Since disabling output escaping might not work with all implementations and can
               result in XML that is not well-formed, it <rfc2119>should</rfc2119> be used only when
               there is no alternative.</p>
            <note diff="add" at="P-erratumE27">
               <p>When disable-output-escaping is used, there is no guarantee that the serialized
                  output will be well-formed XML (or HTML). Furthermore, the fact that the result
                  tree was validated against a schema gives no guarantee that the serialized output
                  will still be valid against the same schema. Conversely, it is possible to use
                  disable-output-escaping to produce schema-valid output from a result tree that
                  would fail validation.</p>
            </note>
            <note>
               <p>The facility to define character maps for use during serialization, as described
                  in <specref ref="character-maps"/>, has been produced as an alternative mechanism
                  that can be used in many situations where disabling of output escaping was
                  previously necessary, without the same difficulties.</p>
            </note>
         </div2>
      </div1>
      <div1 id="conformance">
         <head>Conformance</head>
         <p diff="chg" at="M">A <termref def="dt-processor">processor</termref> that claims
            conformance with this specification <rfc2119>must</rfc2119> satisfy the conformance
            requirements for a <termref def="dt-basic-xslt-processor">basic XSLT processor</termref>
            and for each of the optional features with which it claims conformance.</p>
         <p>The following optional features are defined:</p>
         <olist>
            <item>
               <p>The schema-awareness feature, defined in <specref ref="schema-aware-conformance"
                  /></p>
            </item>
            <item>
               <p>The serialization feature, defined in <specref ref="serialization-feature"/></p>
            </item>
            <item>
               <p>The backwards compatibility feature, defined in <specref
                     ref="backwards-compatibility-feature"/></p>
            </item>
            <item>
               <p>The streaming feature, defined in <specref ref="streaming-feature"/>.</p>
            </item>
            <item>
               <p diff="add" at="N">The dynamic evaluation feature, defined in <specref
                     ref="dynamic-evaluation-feature"/>.</p>
            </item>
            <item>
               <p diff="add" at="S-bug29251">The higher-order functions feature, defined in <specref
                     ref="hof-feature"/>.</p>
            </item>
            <item>
               <p diff="add" at="S-bug24266">The XPath 3.1 feature, defined in <specref
                     ref="xpath31-feature"/>.</p>
            </item>
            <item diff="del" at="S-bug29251">
               <p>The XQuery invocation feature, defined in <specref ref="xquery-invocation-feature"
                  />.</p>
            </item>
         </olist>
         <p diff="chg" at="M">A processor that does not claim conformance with an optional feature
               <rfc2119>must</rfc2119> satisfy the requirements for processors that do not implement
            that feature.</p>
         <note>
            <p>There is no conformance level or feature defined in this specification that requires
               implementation of the static typing features described in <bibref ref="xpath-30"/>.
               An XSLT processor may provide a user option to invoke static typing, but to be
               conformant with this specification it must allow a stylesheet to be processed with
               static typing disabled. The interaction of XSLT stylesheets with the static typing
               feature of <phrase diff="chg" at="F">XPath 3.0</phrase> has not been specified, so
               the results of using static typing, if available, are implementation-defined.</p>
         </note>
         <p>An XSLT processor takes as its inputs a stylesheet and <phrase diff="chg" at="M"
               >zero</phrase> or more XDM trees conforming to the data model defined in <bibref
               ref="xpath-datamodel-30"/>. It is not <rfc2119>required</rfc2119> that the processor
            supports any particular method of constructing XDM trees, but conformance can only be
            tested if it provides a mechanism that enables XDM trees representing the stylesheet and
            primary source document to be constructed and supplied as input to the processor.</p>
         <p>The output of the XSLT processor consists of zero or more <termref
               def="dt-final-result-tree">final result trees</termref>. It is not
               <rfc2119>required</rfc2119> that the processor supports any particular method of
            accessing a final result tree, but if it does not support the serialization <phrase
               diff="chg" at="M">feature</phrase>, conformance can only be tested if it provides
            some alternative mechanism that enables access to the results of the transformation.</p>
         <p>Certain facilities in this specification are described as producing <termref
               def="dt-implementation-defined">implementation-defined</termref> results. A claim
            that asserts conformance with this specification <rfc2119>must</rfc2119> be accompanied
            by documentation stating the effect of each implementation-defined feature. For
            convenience, a non-normative checklist of implementation-defined features is provided at
               <specref ref="implementation-defined-features"/>.</p>
         <p>A conforming <termref def="dt-processor">processor</termref>
            <rfc2119>must</rfc2119> signal any <termref def="dt-static-error">static error</termref>
            occurring in the stylesheet, or in any XPath <termref def="dt-expression"
               >expression</termref>, except where specified otherwise either for individual error
            conditions or under the general provisions for <termref
               def="dt-forwards-compatible-behavior"/> (see <specref ref="forwards"/>). After
            signaling such an error, the processor <rfc2119>may</rfc2119> continue for the purpose
            of signaling additional errors, but <rfc2119>must</rfc2119> terminate abnormally without
            performing any transformation.</p>
         <p>When a <termref def="dt-dynamic-error">dynamic error</termref> occurs during the course
            of a transformation, <phrase diff="add" at="M">and is not caught using
                  <elcode>xsl:catch</elcode>,</phrase>
            <phrase diff="del" at="M">the action depends on whether the error is classified as a
               recoverable error. If a non-recoverable error occurs,</phrase> the processor
               <rfc2119>must</rfc2119> signal it and <rfc2119>must</rfc2119> eventually terminate
            abnormally. <phrase diff="del" at="S-bug29086">If a recoverable error occurs, the
               processor <rfc2119>must</rfc2119> either signal it and terminate abnormally, or it
                  <rfc2119>must</rfc2119> take the defined recovery action and continue
               processing.</phrase></p>
         <p>Some errors, notably <termref def="dt-type-error">type errors</termref>,
               <rfc2119>may</rfc2119> be treated as <termref def="dt-static-error">static
               errors</termref> or <termref def="dt-dynamic-error">dynamic errors</termref> at the
            discretion of the processor.</p>
         <p>A conforming processor <rfc2119>may</rfc2119> impose limits on the processing resources
            consumed by the processing of a stylesheet.</p>
         <p diff="chg" at="R-bug24266">The mandatory requirements of this specification are taken to
            include the mandatory requirements of <bibref ref="xpath-30"/>, <bibref
               ref="xpath-datamodel-30"/>, and <bibref ref="xpath-functions-30"/>. An XSLT 3.0
            processor <rfc2119>must</rfc2119> provide a mode of operation which conforms to the 3.0
            versions of those specifications as extended by <specref ref="map"/> and <specref
               ref="json"/>.</p>
         <p diff="chg" at="S-bug24266">A processor <rfc2119>may</rfc2119> also provide a mode of
            operation which conforms to the 3.1 versions of those specifications; in this case it
            must do so as described in <termref def="dt-xpath31-feature"/>.</p>
         <p diff="chg" at="S-bug24266">A processor <rfc2119>may</rfc2119> also provide a mode of
            operation which conforms to versions of those specifications later than the 3.1
            versions; in such cases the detail of how XSLT 3.0 interacts with new features
            introduced by such later versions (for example, extensions to the data model) is
               <termref def="dt-implementation-defined"/>.</p>
         <imp-def-feature id="idf-spec-xpath">It is <termref def="dt-implementation-defined"/>
            whether (and if so how) an XSLT 3.0 processor is able to work with versions of XPath
            later than XPath 3.1.</imp-def-feature>
         <p>A requirement is mandatory unless the specification includes wording (such as the use of
            the words <rfc2119>should</rfc2119> or <rfc2119>may</rfc2119>) that clearly indicates
            that it is optional.</p>
         <p diff="add" at="S-bug29251">Some of the optional features are defined in such a way that
            if the feature is not provided, the data model is constrained to exclude certain kinds
            of item. For example:</p>
         <ulist diff="add" at="S-bug29251">
            <item>
               <p>A processor that does not provide the <termref
                     def="dt-schema-aware-xslt-processor">schema-awareness</termref> feature
                  restricts the data model so that it does not contain atomic values of types other
                  than the built-in types, or nodes with non-trivial type annotations.</p>
            </item>
            <item>
               <p>A processor that does not provide the <termref def="dt-hof-feature"/> constrains
                  the data model so that it does not contain function items other than maps or
                  arrays.</p>
            </item>
            <item>
               <p>A processor that does not provide the <termref def="dt-xpath31-feature"/>
                  constrains the data model so that it does not contain arrays.</p>
            </item>
         </ulist>
         <p diff="chg" at="S-bug29251"><error spec="XT" type="dynamic" class="DE" code="1665"><p>A
                     <termref def="dt-dynamic-error"/>
                  <rfc2119>may</rfc2119> be raised if the input to the processor includes an item
                  that requires availability of an optional feature that the processor does not
                  provide.</p></error></p>
         <note>
            <p>It is not necessarily possible to trigger this error. A processor that does not
               provide an optional feature might not define or recognize any representation of the
               items that are disallowed. The error code is provided for use in cases where a
               processor is able to interoperate with other software that does not have the same
               constraints — for example, where a package compiled with a non-schema-aware processor
               is able to invoke functions in a package that was compiled with a schema-aware
               processor. Even in that case, processors have the option of filtering or converting
               the input so that it meets the relevant constraints: for example, a non-schema-aware
               processor when presented with a schema-validated document in the form of a PSVI might
               simply ignore the properties it does not understand.</p>
            <p>The dynamic error is optional: for example a processor might report no error if the
               offending item is not actually used.</p>
            <p diff="chg" at="S-bug29251">The phrase <emph>input to the processor</emph> is
               deliberately wide: it includes (inter alia) the <termref def="dt-global-context-item"
               />, <phrase diff="add" at="R-bug24764">items present in the <termref
                     def="dt-initial-match-selection"/></phrase>, items passed as <termref
                  def="dt-stylesheet-parameter">stylesheet parameters</termref>, items returned by
               functions such as <function>document</function>, <xfunction>doc</xfunction>, and
                  <xfunction>collection</xfunction>, items returned by <termref
                  def="dt-extension-function">extension functions</termref> and <termref
                  def="dt-extension-instruction">extension instructions</termref>, items supplied in
               function or template parameters or results across package boundaries, and nodes
               reachable from any of the above by axis navigation.</p>
         </note>
         <div2 id="basic-conformance">
            <head>Basic XSLT Processor</head>
            <p>
               <termdef id="dt-basic-xslt-processor" term="basic XSLT processor">A <term>basic XSLT
                     processor</term> is an XSLT processor that implements all the mandatory
                  requirements of this specification with the exception of constructs explicitly
                  associated with an optional feature.</termdef> These constructs are listed
               below.</p>
         </div2>
         <div2 id="schema-aware-conformance" diff="chg" at="M">
            <head>Schema-Awareness Conformance Feature</head>
            <p>A conformant processor <rfc2119>must</rfc2119> either be a conformant <termref
                  def="dt-schema-aware-xslt-processor"/> or a conformant <termref
                  def="dt-non-schema-aware-processor"/>.</p>
            <p>
               <termdef id="dt-schema-aware-xslt-processor" term="schema-aware XSLT processor">A
                     <term>schema-aware XSLT processor</term> is an XSLT processor that implements
                  the mandatory requirements of this specification connected with the
                     <elcode>xsl:import-schema</elcode> declaration, the
                     <code>[xsl:]validation</code> and <code>[xsl:]type attributes</code>, and the
                  ability to handle input documents whose nodes have type annotations other than
                     <code>xs:untyped</code> and <code>xs:untypedAtomic</code>. The mandatory
                  requirements of this specification are taken to include the mandatory requirements
                  of <phrase diff="chg" at="F">XPath 3.0</phrase>, as described in <bibref
                     ref="xpath-30"/>. A requirement is mandatory unless the specification includes
                  wording (such as the use of the words <rfc2119>should</rfc2119> or
                     <rfc2119>may</rfc2119>) that clearly indicates that it is optional.</termdef>
            </p>
            <p diff="chg" at="M"><termdef id="dt-non-schema-aware-processor"
                  term="non-schema-aware processor">A <term>non-schema-aware processor</term> is a
                  processor that does not claim conformance with the schema-aware conformance
                  feature. Such a processor <rfc2119>must</rfc2119> handle constructs associated
                  with schema-aware processing as described in this section.</termdef></p>
            <p>
               <error spec="XT" type="static" class="SE" code="1650"><p>A <termref
                        def="dt-non-schema-aware-processor">non-schema-aware processor</termref>
                     <rfc2119>must</rfc2119> signal a <termref def="dt-static-error">static
                        error</termref> if <phrase diff="chg" at="R-bug24763">a <termref
                           def="dt-package">package</termref></phrase> includes an
                        <elcode>xsl:import-schema</elcode> declaration.</p></error>
            </p>
            <note>
               <p>A processor that rejects an <elcode>xsl:import-schema</elcode> declaration will
                  also reject any reference to a user-defined type defined in a schema, or to a
                  user-defined element or attribute declaration; it will not, however, reject
                  references to the built-in types listed in <specref ref="built-in-types"/>.</p>
            </note>
            <p diff="add" at="B">A <termref def="dt-non-schema-aware-processor">non-schema-aware
                  processor</termref> is not able to validate input documents, and is not able to
               handle input documents containing type annotations other than <code>xs:untyped</code>
               or <code>xs:untypedAtomic</code>. Therefore, such a processor <rfc2119>must</rfc2119>
               treat <phrase diff="chg" at="P-bug23328">any <code>[xsl:]validation</code> attribute
                  with a value of <code>preserve</code> or <code>lax</code>, or a
                     <code>[xsl:]default-validation</code> attribute with a value of
                     <code>preserve</code></phrase> as if the value were <code>strip</code>.</p>
            <note diff="add" at="B">
               <p>The values <code>lax</code> and <code>preserve</code> indicate that the validation
                  to be applied depends on the calling application, so it is appropriate for the
                  request to be treated differently by different kinds of processor. By contrast,
                  requesting <code>strict</code> validation, either through the
                     <code>[xsl:]validation</code> attribute or the <code>type</code> attribute,
                  indicates that the stylesheet is expecting to deal with typed data, and therefore
                  cannot be processed without performing the validation.</p>
            </note>
            <p>
               <error spec="XT" type="static" class="SE" code="1660"><p>A <termref
                        def="dt-non-schema-aware-processor">non-schema-aware processor</termref>
                     <rfc2119>must</rfc2119> signal a <termref def="dt-static-error">static
                        error</termref> if <phrase diff="chg" at="R-bug24763">a <termref
                           def="dt-package">package</termref></phrase> includes an
                        <code>[xsl:]type</code> attribute; or an <code>[xsl:]validation</code> or
                        <code>[xsl:]default-validation</code> attribute with a value other than
                        <code>strip</code><phrase diff="add" at="B">, <code>preserve</code>, or
                           <code>lax</code></phrase>; <phrase diff="add" at="S-bug27806">or an
                           <elcode>xsl:mode</elcode> element whose <code>typed</code> attribute is
                        equal to <code>yes</code> or <code>strict</code>; or an <code>as</code>
                        attribute whose value is a <phrase diff="chg" at="S-bug29079"><termref
                              def="dt-sequence-type"/></phrase> that can only match nodes with a
                        type annotation other than <code>xs:untyped</code> or
                           <code>xs:untypedAtomic</code> (for example, <code>as="element(*,
                           xs:integer)"</code>).</phrase></p></error>
            </p>
            <p>A <termref def="dt-non-schema-aware-processor">non-schema-aware processor</termref>
               constrains the data model as follows, and raises a <termref def="dt-dynamic-error"/>
                  (<errorref spec="XT" class="DE" code="1665"/>) if the constraints are not
               satisfied:</p>
            <ulist>
               <item>
                  <p>Atomic values <rfc2119>must</rfc2119> belong to one of the atomic types listed
                     in <specref ref="built-in-types"/> (except as noted below).</p>
                  <p>An atomic value may also belong to an implementation-defined type that has been
                     added to the context for use with <termref def="dt-extension-function"
                        >extension functions</termref> or <termref def="dt-extension-instruction"
                        >extension instructions</termref>.</p>
                  <p>The set of constructor functions available are limited to those that construct
                     values of the above atomic types.</p>
                  <p>The static context, which defines the full set of type names recognized by an
                     XSLT processor and also by the XPath processor, includes these atomic types,
                     plus <code>xs:anyType</code>, <code>xs:anySimpleType</code>,
                        <code>xs:untyped</code>, and <code>xs:anyAtomicType</code>.</p>
               </item>
               <item>
                  <p>Element nodes <rfc2119>must</rfc2119> be annotated with the <termref
                        def="dt-type-annotation">type annotation</termref>
                     <code>xs:untyped</code>, and attribute nodes with the type annotation
                        <code>xs:untypedAtomic</code>.</p>
               </item>
            </ulist>
         </div2>
         <div2 id="serialization-feature">
            <head>Serialization Feature</head>
            <p>
               <termdef id="dt-serialization-feature" term="serialization feature">A processor that
                  claims conformance with the <term>serialization feature</term>
                  <rfc2119>must</rfc2119> support the conversion of a <termref
                     def="dt-final-result-tree">final result tree</termref> to a sequence of octets
                  following the rules defined in <specref ref="serialization"/>.</termdef> It
                  <rfc2119>must</rfc2119> respect all the attributes of the
                  <elcode>xsl:output</elcode> and <elcode>xsl:character-map</elcode> declarations,
               and <rfc2119>must</rfc2119> provide all four output methods, <code>xml</code>,
                  <code>xhtml</code>, <code>html</code>, and <code>text</code>. Where the
               specification uses words such as <rfc2119>must</rfc2119> and
                  <rfc2119>required</rfc2119>, then it <rfc2119>must</rfc2119> serialize the result
               tree in precisely the way described; in other cases it <rfc2119>may</rfc2119> use an
               alternative, equivalent representation.</p>
            <p>A processor may claim conformance with the serialization feature whether or not it
               supports the setting <code>disable-output-escaping="yes"</code> on
                  <elcode>xsl:text</elcode>, or <elcode>xsl:value-of</elcode>. </p>
            <p>A processor that does not claim conformance with the serialization feature
                  <rfc2119>must not</rfc2119> signal an error merely because the <termref
                  def="dt-stylesheet">stylesheet</termref> contains <elcode>xsl:output</elcode> or
                  <elcode>xsl:character-map</elcode> declarations, or serialization attributes on
               the <elcode>xsl:result-document</elcode> instruction. Such a processor
                  <rfc2119>may</rfc2119> check that these declarations and attributes have valid
               values, but is not <rfc2119>required</rfc2119> to do so. Apart from optional
               validation, these declarations <rfc2119>should</rfc2119> be ignored.</p>
            <note diff="add" at="T-bug29392">
               <p>A processor that does not claim conformance with the serialization feature
                     <rfc2119>may</rfc2119> offer alternative serialization capabilities, and these
                     <rfc2119>may</rfc2119> make use of the serialization parameters defined on
                     <elcode>xsl:output</elcode> and/or <elcode>xsl:result-document</elcode>.</p>
            </note>
            <p diff="add" at="T-bug29392">If the processor claims conformance with the serialization
               feature then it <rfc2119>must</rfc2119> fully implement the
                  <xfunction>serialize</xfunction> function defined in <bibref
                  ref="xpath-functions-30"/> or <bibref ref="xpath-functions-31"/> as appropriate,
               and <rfc2119>must not</rfc2119> raise error <xerrorref spec="FO30" code="0010"
                  class="DC"/> as the result of such a call.</p>
            <p diff="add" at="T-bug29392">If the processor does not claim conformance with the
               serialization feature, then it <rfc2119>may</rfc2119> raise error <xerrorref
                  spec="FO30" code="0010" class="DC"/> in respect of some or all calls on the
                  <xfunction>serialize</xfunction> function; it <rfc2119>must not</rfc2119> return a
               result from a call on this function unless the result is conformant with the
               specification, given the parameters actually supplied. </p>
            <p diff="add" at="R-bug24266">A processor that claims conformance with the Serialization
               Feature must satisfy the mandatory requirements of <bibref
                  ref="xslt-xquery-serialization-30"/>. It <rfc2119>must</rfc2119> provide a mode of
               operation which conforms to the 3.0 version of that specification. It
                  <rfc2119>may</rfc2119> also provide a mode of operation which conforms to a later
               version of that specification; in such cases the detail of how XSLT 3.0 interacts
               with new features introduced by such a version (for example, support for new
               serialization properties) is <termref def="dt-implementation-defined"/>.</p>
            <imp-def-feature id="idf-spec-serialization">It is <termref
                  def="dt-implementation-defined"/> whether (and if so how) an XSLT 3.0 processor is
               able to work with versions of <bibref ref="xslt-xquery-serialization-30"/> later than
               3.1.</imp-def-feature>
         </div2>
         <div2 id="backwards-compatibility-feature">
            <head>Compatibility Features</head>
            <p>
               <termdef id="dt-1.0-compatibility-feature" term="XSLT 1.0 compatibility feature">A
                  processor that claims conformance with the <term>XSLT 1.0 compatibility
                     feature</term>
                  <rfc2119>must</rfc2119> support the processing of stylesheet instructions and
                  XPath expressions with <termref def="dt-xslt-10-behavior" diff="chg" at="D">XSLT
                     1.0 behavior</termref>, as defined in <specref ref="backwards"/>.</termdef>
            </p>
            <p diff="del" at="N">
               <termdef id="dt-2.0-compatibility-feature" term="XSLT 2.0 compatibility feature">A
                  processor that claims conformance with the <term>XSLT 2.0 compatibility
                     feature</term>
                  <rfc2119>must</rfc2119> support the processing of stylesheet instructions and
                  XPath expressions with <termref def="dt-xslt-20-behavior" diff="chg" at="D">XSLT
                     2.0 behavior</termref>, as defined in <specref ref="backwards"/>.</termdef>
            </p>
            <p>Note that a processor that does not claim conformance with the <termref
                  def="dt-1.0-compatibility-feature"/>
               <rfc2119>must</rfc2119> raise a <termref def="dt-dynamic-error"><phrase diff="del"
                     at="M">non-recoverable</phrase> dynamic error</termref> if an instruction is
               evaluated whose <termref def="dt-effective-version"/> is 1.0<phrase diff="del" at="N"
                  >; and similarly, a processor that does not claim conformance with the <termref
                     def="dt-2.0-compatibility-feature"/>
                  <rfc2119>must</rfc2119> raise a <termref def="dt-dynamic-error"><phrase diff="del"
                        at="M">non-recoverable</phrase> dynamic error</termref> if an instruction is
                  evaluated whose <termref def="dt-effective-version"/> is 2.0</phrase>. <errorref
                  spec="XT" class="DE" code="0160"/>.</p>
            <note>
               <p>The reason this is a dynamic error rather than a static error is to allow
                  stylesheets to contain conditional logic, following different paths depending on
                  whether the XSLT processor implements <phrase diff="chg" at="D">XSLT 1.0, 2.0, or
                     3.0</phrase>. The selection of which path to use can be controlled by using the
                     <function>system-property</function> function to test the
                     <code>xsl:version</code> system property.</p>
            </note>
            <p>A processor that claims conformance with the <termref
                  def="dt-1.0-compatibility-feature"/>
               <rfc2119>must</rfc2119> permit the use of the namespace axis in XPath expressions
               when backwards compatible behavior is enabled. In all other circumstances, support
               for the namespace axis is optional.</p>
            <note>
               <p diff="add" at="N">There are no incompatibilities between 3.0 and 2.0 that would
                  justify a 2.0-compatibility mode. When a 3.0 processor encounters a stylesheet
                  that specifies <code>version="2.0"</code>, evaluation therefore proceeds exactly
                  as if it specified <code>version="3.0"</code>. However, a software product may
                  invoke an XSLT 2.0 processor in preference to an XSLT 3.0 processor when the
                  stylesheet specifies <phrase diff="chg" at="V-bug30100"
                     ><code>version="2.0"</code></phrase>, in which case any use of new 3.0
                  constructs will be rejected.</p>
            </note>
         </div2>
         <div2 id="streaming-feature" diff="chg" at="M">
            <head>Streaming Feature</head>
            <p>
               <termdef id="dt-streaming-feature" term="streaming feature">A processor that claims
                  conformance with the <term>streaming feature</term>
                  <rfc2119>must</rfc2119> use streamed processing in cases where (a) streaming is
                  requested (for example by using the attribute <code>streamable="yes"</code> on
                     <elcode>xsl:mode</elcode>, or <phrase diff="add" at="T-bug29747">on</phrase>
                  the <elcode>xsl:source-document</elcode> instruction) and (b) the constructs in
                  question are <termref def="dt-guaranteed-streamable"/> according to this
                  specification.</termdef>
            </p>
            <p>A processor that does not claim conformance with the streaming feature is not
               required to use streamed processing and is not required to determine whether any
               construct is guaranteed streamable. Such a processor must, however, implement the
               semantics of all constructs in the language provided that enough memory is available
               to perform the processing without streaming.</p>
            <p diff="add" at="N">A processor that conforms with the feature <rfc2119>must</rfc2119>
               return the value <code>"yes"</code> in response to the function call
                  <code>system-property('xsl:supports-streaming')</code>; a processor that does not
               conform with the feature <rfc2119>must</rfc2119> return the value
               <code>"no"</code>.</p>
            <note>
               <p>The term <emph>streamed processing</emph> as used here means the ability to
                  process arbitrarily large input documents without ever-increasing memory
                  requirements.</p>
            </note>
         </div2>
         <div2 diff="add" at="N" id="dynamic-evaluation-feature">
            <head>Dynamic Evaluation Feature</head>
            <p>
               <termdef id="dt-dynamic-evaluation-feature" term="dynamic evaluation feature">A
                  processor that claims conformance with the <term>dynamic evaluation feature</term>
                  <rfc2119>must</rfc2119> evaluate the <elcode>xsl:evaluate</elcode> function as
                  described in this specification.</termdef>
            </p>
            <p>A processor that does not claim conformance with the dynamic evaluation feature
                  <rfc2119>must</rfc2119> report a dynamic error if an <elcode>xsl:evaluate</elcode>
               instruction is evaluated. It <rfc2119>must not</rfc2119> report a static error merely
               because of the presence of an <elcode>xsl:evaluate</elcode> instruction in the
               stylesheet, unless a processor that conforms with the feature would report the same
               static error.</p>
            <p>A processor that conforms with the feature <rfc2119>must</rfc2119> return the value
                  <code>"yes"</code> in response to the function call
                  <code>system-property('xsl:supports-dynamic-evaluation')</code>; a processor that
               does not conform with the feature <rfc2119>must</rfc2119> return the value
                  <code>"no"</code>.</p>
            <p>A processor that conforms with the feature <rfc2119>must</rfc2119> return the value
                  <code>true</code> in response to the function call
                  <code>element-available('xsl:evaluate')</code>; a processor that does not conform
               with the feature <rfc2119>must</rfc2119> return the value <code>false</code>.</p>
            <note>
               <p>A processor may allow dynamic evaluation to be enabled and disabled by means of
                  configuration settings, perhaps for security reasons. In consequence, it may be
                  impossible to tell during static analysis of the stylesheet whether or not the
                  feature will be available during execution. A stylesheet author wanting to check
                  whether the feature is available should therefore make the test using a run-time
                  call on <code>system-property</code>, rather than relying on tests in an
                     <code>[xsl:]use-when</code> attribute.</p>
            </note>
         </div2>
         <div2 diff="add" at="S-bug24266" id="xpath31-feature">
            <head>XPath 3.1 Feature</head>
            <p><termdef id="dt-xpath31-feature" term="XPath 3.1 Feature">A processor that claims
                  conformance with the <term>XPath 3.1 feature</term>
                  <rfc2119>must</rfc2119> implement XPath 3.1 (including <bibref ref="xpath-31"/>,
                     <bibref ref="xpath-datamodel-31"/>, <bibref ref="xslt-xquery-serialization-31"
                  />, and <bibref ref="xpath-functions-31"/>).</termdef></p>
            <p>Specifically:</p>
            <ulist>
               <item>
                  <p>All constructs where an <termref def="dt-expression"/>, <termref
                        def="dt-pattern"/>, <termref def="dt-sequence-type"/>, or
                        <code>ItemType</code> is expected must accept the XPath 3.1 grammar within
                     those constructs.</p>
               </item>
               <item>
                  <p>All functions defined in <bibref ref="xpath-functions-31"/> are available.</p>
                  <note>
                     <p>Functions labeled as <emph>higher-order</emph> are available only if the
                           <termref def="dt-hof-feature"/> is also available.</p>
                     <p>If both the XPath 3.1 feature and the Higher-Order Functions feature are
                        available, then the <xfunction spec="FO31">load-xquery-module</xfunction>
                        function will be available. However, as prescribed in the specification of
                        that function, it has the option of returning a dynamic error if no suitable
                        XQuery processor is available.</p>
                  </note>
               </item>
               <item>
                  <p>The union type <code>xs:numeric</code> is recognized.</p>
               </item>
               <item>
                  <p>The data model includes maps and arrays.</p>
                  <p>A processor that does not provide the XPath 3.1 feature constrains the data
                     model by disallowing arrays, and may raise a <termref def="dt-dynamic-error"/>
                        (<errorref spec="XT" class="DE" code="1665"/>) if this constraint is not
                     satisfied.</p>
               </item>
               <item>
                  <p>Serialization of final results follows the rules in <bibref
                        ref="xslt-xquery-serialization-31"/> (for example, it supports JSON
                     serialization).</p>
               </item>
               <item>
                  <p>The <elcode>xsl:evaluate</elcode> instruction supports dynamic evaluation of
                     XPath 3.1 expressions.</p>
               </item>
               <item>
                  <p>The result of <code>system-property("xsl:xpath-version")</code> is
                        <code>"3.1"</code>.</p>
               </item>
            </ulist>
            <p>A processor that claims conformance with the XPath 3.1 feature <rfc2119>may</rfc2119>
               accept or reject constructs defined in any version of XPath (and its associated
               specifications) later than 3.1.</p>
            <div3 id="arrays" diff="add" at="S-bug29079">
               <head>Arrays</head>
               <p>XPath 3.1 introduces arrays as a new data structure, along with maps, largely in
                  order to provide improved support for JSON. An array is an item, and it can be
                  used as a function, so if <code>$A</code> is an array, then <code>$A(3)</code>
                  selects the third member of the array, counting from one. The members of an array
                  can be arbitrary values (that is, sequences).</p>
               <p>Arrays become available in XSLT 3.0 when the <termref def="dt-xpath31-feature"/>
                  is implemented. There are no specific constructs in XSLT 3.0 to construct or
                  manipulate arrays, but this can be achieved using facilities in XPath 3.1. The
                  syntax for <termref def="dt-sequence-type">SequenceTypes</termref> is extended to
                  allow arrays to be declared: for example <code>array(xs:integer)</code> represents
                  an array whose members are (single) integers, while <code>array(map(xs:string,
                     node()*))</code> represents an array whose members are maps from strings to
                  sequences of nodes.</p>
               <p>Like maps and sequences, arrays are immutable, and have no discernible identity
                  (two arrays with the same members cannot be distinguished).</p>
               <p>A number of functions for manipulating arrays are defined in <bibref
                     ref="xpath-functions-31"/>.</p>
            </div3>
         </div2>
         <div2 id="hof-feature" diff="add" at="S-bug29251">
            <head>Higher-Order Functions Feature</head>
            <p><termdef id="dt-hof-feature" term="higher-order functions feature">The
                     <term>higher-order functions feature</term> contains functionality connected
                  with the use of functions as items in the data model, that can be stored in
                  variables and passed to other functions.</termdef></p>
            <p><error type="static" spec="XT" class="SE" code="3540"><p>A processor that does not
                     provide the <termref def="dt-hof-feature"/> raises a <termref
                        def="dt-static-error"/> if any of the following XPath constructs are found
                     in an <termref def="dt-expression"/>, <termref def="dt-pattern"/>, <termref
                        def="dt-sequence-type"/>, or <code>ItemType</code>: a <xnt
                        xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                        ref="prod-xpath30-TypedFunctionTest" xlink:type="simple"
                        >TypedFunctionTest</xnt>, a <xnt xmlns:xlink="http://www.w3.org/1999/xlink"
                        spec="XP30" ref="prod-xpath30-NamedFunctionRef" xlink:type="simple"
                        >NamedFunctionRef</xnt>, an <xnt xmlns:xlink="http://www.w3.org/1999/xlink"
                        spec="XP30" ref="prod-xpath30-InlineFunctionExpr" xlink:type="simple"
                        >InlineFunctionExpr</xnt>, or an <xnt
                        xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP30"
                        ref="prod-xpath30-ArgumentPlaceholder" xlink:type="simple"
                        >ArgumentPlaceholder</xnt></p></error>.</p>
            <note>
               <p>The effect is to disallow the three constructs used to create function-valued
                  items: named function references such as <code>round#1</code>, inline function
                  expressions such as <code>function($x){$x+1}</code>, and partial function
                  application such as <code>starts-with(?, '#')</code>, along with sequence types
                  such as <code>function(xs:integer) as xs:string</code> that serve no useful
                  purpose in the absence of such items.</p>
               <p>The item type <code>function(*)</code> is allowed by these rules, and serves as a
                  generic type for maps and arrays.</p>
            </note>
            <p>Where a processor does not provide the <termref def="dt-hof-feature"/>, functions
               whose specification in <bibref ref="xpath-functions-31"/> labels them with the
                  <term>higher-order</term> property are excluded from the static context of
               expressions and patterns. An attempt to reference such a function therefore fails in
               the same way as an attempt to call a non-existent function.</p>
            <note>
               <p>Examples of functions labeled with this property are
                  <xfunction>filter</xfunction>, <xfunction>for-each</xfunction>,
                     <xfunction>fold-left</xfunction>, and <xfunction>fold-right</xfunction>.</p>
            </note>
            <p>A processor that does not provide the higher-order functions feature constrains the
               data model by disallowing function items other than maps and arrays, and may raise a
                  <termref def="dt-dynamic-error"/> (<errorref spec="XT" class="DE" code="1665"/>)
               if this constraint is not satisfied.</p>
            <p>The same rules apply to a dynamic XPath expression processed using
                  <elcode>xsl:evaluate</elcode>.</p>
         </div2>
         <div2 diff="del" at="S-bug29251" id="xquery-invocation-feature">
            <head>XQuery Invocation Feature</head>
            <p>
               <termdef id="dt-xquery-invocation-feature" term="XQuery Invocation Feature">A
                  processor that claims conformance with the <term>XQuery invocation feature</term>
                  <rfc2119>must</rfc2119> allow XQuery library modules to be referenced in
                     <elcode>xsl:use-package</elcode>, and must allow the using package to reference
                  the public functions and variables declared in the referenced library
                  module.</termdef>
            </p>
         </div2>
      </div1>
   </body>
   <back>
      <div1 id="references">
         <head>References</head>
         <div2 id="normative-references">
            <head>Normative References</head>
            <blist>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-datamodel-30"
                  key="XDM 3.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-datamodel-31"
                  key="XDM 3.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-functions-30"
                  key="Functions and Operators 3.0" xlink:type="simple" xlink:show="replace"
                  xlink:actuate="onRequest"/>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-functions-31"
                  key="Functions and Operators 3.1" xlink:type="simple" xlink:show="replace"
                  xlink:actuate="onRequest"/>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xml-infoset"
                  key="XML Information Set" xlink:type="simple" xlink:show="replace"
                  xlink:actuate="onRequest"/>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="ISO15924" key="ISO 15924"
                  xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ISO
                  (International Organization for Standardization) <emph>Information and
                     documentation — Codes for the representation of names of scripts</emph> ISO
                  15924:2004, January 2004. <phrase diff="add" at="R-bug25701">See <loc
                        href="https://www.iso.org/obp/ui/#!iso:std:iso:15924:ed-1:v1:en"
                        xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"
                     /></phrase>.</bibl>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="ISO15924_register"
                  key="ISO 15924 Register" xlink:type="simple" xlink:show="replace"
                  xlink:actuate="onRequest">Unicode Consortium. <emph>Codes for the representation
                     of names of scripts — Alphabetical list of four-letter script codes.</emph> See
                     <loc href="http://www.unicode.org/iso15924/iso15924-codes.html"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>. Retrieved
                  February 2013; continually updated.</bibl>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xslt-xquery-serialization-30"
                  key="XSLT and XQuery Serialization" xlink:type="simple" xlink:show="replace"
                  xlink:actuate="onRequest"/>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xslt-xquery-serialization-31"
                  key="XSLT and XQuery Serialization 3.1" xlink:type="simple" xlink:show="replace"
                  xlink:actuate="onRequest"/>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="rfc7159" key="RFC 7159"
                  xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">IETF. <emph>The
                     JavaScript Object Notation (JSON) Data Interchange Format.</emph>
                  <phrase diff="chg" at="R-bug25701">March 2014</phrase>. See <loc
                     href="http://www.ietf.org/rfc/rfc7159.txt" xlink:type="simple"
                     xlink:show="replace" xlink:actuate="onRequest"
                     >http://www.ietf.org/rfc/rfc7159.txt</loc>
               </bibl>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="UNICODE" key="UNICODE"
                  xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Unicode
                  Consortium. <emph>The Unicode Standard</emph> as updated from time to time by the
                  publication of new versions. See <loc
                     href="http://www.unicode.org/standard/versions/" xlink:type="simple"
                     xlink:show="replace" xlink:actuate="onRequest"/> for the latest version and
                  additional information on versions of the standard and of the Unicode Character
                  Database. The version of Unicode to be used is <termref
                     def="dt-implementation-defined">implementation-defined</termref>, but
                  implementations are recommended to use the latest Unicode version.</bibl>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="UNICODE-TR10" key="UNICODE TR10"
                  xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Unicode
                  Consortium. <emph>Unicode Technical Standard #10. Unicode Collation
                     Algorithm</emph>. Unicode Technical Report. See <loc
                     href="http://www.unicode.org/reports/tr10/" xlink:type="simple"
                     xlink:show="replace" xlink:actuate="onRequest"/>.</bibl>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="UNICODE-TR35" key="UNICODE TR35"
                  xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Unicode
                  Consortium. <emph>Unicode Technical Standard #35. Unicode Locale Data Markup
                     Language</emph>. Unicode Technical Report. See <loc
                     href="http://www.unicode.org/reports/tr35/" xlink:type="simple"
                     xlink:show="replace" xlink:actuate="onRequest"/>.</bibl>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="REC-xml" key="XML 1.0"
                  xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"> World Wide Web
                  Consortium. <emph>Extensible Markup Language (XML) 1.0. W3C Recommendation.</emph>
                  See <loc href="https://www.w3.org/TR/REC-xml" xlink:type="simple"
                     xlink:show="replace" xlink:actuate="onRequest"
                     >http://www.w3.org/TR/REC-xml/</loc>. The edition of XML 1.0 must be no earlier
                  than the Third Edition; the edition used is <termref
                     def="dt-implementation-defined"/>, but we recommend that implementations use
                  the latest version. </bibl>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xml11" key="XML 1.1"
                  xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xmlbase" key="XML Base"
                  xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xml-id" key="xml:id"
                  xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xml-names"
                  key="Namespaces in XML" xlink:type="simple" xlink:show="replace"
                  xlink:actuate="onRequest"/>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xml-names11"
                  key="Namespaces in XML 1.1" xlink:type="simple" xlink:show="replace"
                  xlink:actuate="onRequest"/>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xmlschema-1"
                  key="XML Schema Part 1" xlink:type="simple" xlink:show="replace"
                  xlink:actuate="onRequest"/>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xmlschema-2"
                  key="XML Schema Part 2" xlink:type="simple" xlink:show="replace"
                  xlink:actuate="onRequest"/>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xmlschema11-1"
                  key="XML Schema 1.1 Part 1" xlink:type="simple" xlink:show="replace"
                  xlink:actuate="onRequest"/>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xmlschema11-2"
                  key="XML Schema 1.1 Part 2" xlink:type="simple" xlink:show="replace"
                  xlink:actuate="onRequest"/>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-30" key="XPath 3.0"
                  xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-31" key="XPath 3.1"
                  xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XSLT-Mime-Type"
                  key="XSLT Media Type" xlink:type="simple" xlink:show="replace"
                  xlink:actuate="onRequest">World Wide Web Consortium. <emph>Registration of MIME
                     Media Type application/xslt+xml</emph>. In <loc
                     href="https://www.w3.org/TR/2007/REC-xslt20-20070123/#media-type-registration"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Appendix B.1
                     of the XSLT 2.0 specification.</loc></bibl>
            </blist>
         </div2>
         <div2 id="other-references">
            <head>Other References</head>
            <blist>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="CLDR" key="Unicode CLDR"
                  xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">CLDR - Unicode
                  Common Locale Data Repository. Available at: <loc href="http://cldr.unicode.org"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"
                     >http://cldr.unicode.org</loc></bibl>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="DOM-Level-2-Core"
                  key="DOM Level 2" xlink:type="simple" xlink:show="replace"
                  xlink:actuate="onRequest"/>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="ECMA-404" key="ECMA-404"
                  xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"> ECMA
                  International. <emph>The JSON Data Interchange Format</emph> October 2013. See
                     <loc
                     href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"
                     >http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf</loc>. </bibl>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="ICU" key="ICU"
                  xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ICU -
                  International Components for Unicode. Available at <loc
                     href="http://site.icu-project.org" xlink:type="simple" xlink:show="replace"
                     xlink:actuate="onRequest">http://site.icu-project.org</loc>
               </bibl>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="rfc2119" key="RFC2119"
                  xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">S. Bradner.
                     <emph>Key words for use in RFCs to Indicate Requirement Levels</emph>. IETF RFC
                  2119. See <loc href="http://www.ietf.org/rfc/rfc2119.txt" xlink:type="simple"
                     xlink:show="replace" xlink:actuate="onRequest"/>.</bibl>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC3986" key="RFC3986"
                  xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"> T.
                  Berners-Lee, R. Fielding, and L. Masinter. <emph>Uniform Resource Identifiers
                     (URI): Generic Syntax</emph>. IETF RFC 3986. See <loc
                     href="http://www.ietf.org/rfc/rfc3986.txt" xlink:type="simple"
                     xlink:show="replace" xlink:actuate="onRequest"/>.</bibl>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC3987" key="RFC3987"
                  xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">M. Duerst, M.
                  Suignard. <emph>Internationalized Resource Identifiers (IRIs)</emph>. IETF RFC
                  3987. See <loc href="http://www.ietf.org/rfc/rfc3987.txt" xlink:type="simple"
                     xlink:show="replace" xlink:actuate="onRequest"/>.</bibl>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC4647" key="RFC4647"
                  xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">A. Phillips and
                  M. Davis. <emph>Matching of Language Tags</emph>. IETF RFC 4647. See <loc
                     href="http://www.ietf.org/rfc/rfc4647.txt" xlink:type="simple"
                     xlink:show="replace" xlink:actuate="onRequest"/>.</bibl>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="rfc7303" key="RFC7303"
                  xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">H. Thompson and
                  C. Lilley. <emph>XML Media Types</emph>. IETF RFC 7303. See <loc
                     href="http://www.ietf.org/rfc/rfc7303.txt" xlink:type="simple"
                     xlink:show="replace" xlink:actuate="onRequest"/></bibl>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="SemVer" key="SemVer"
                  xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Tom
                  Preston-Werner, <emph>Semantic Versioning 2.0.0</emph>. See <loc
                     href="http://semver.org/" xlink:type="simple" xlink:show="replace"
                     xlink:actuate="onRequest"/>. Undated (retrieved 1 August 2014).</bibl>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="STX" key="STX"
                  xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Petr Cimprich
                     <emph>et al</emph>, <emph>Streaming Transformations for XML (STX) Version
                     1.0</emph>. Working Draft 27 April 2007. See <loc
                     href="http://stx.sourceforge.net/documents/spec-stx-20070427.html"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               </bibl>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xlink" key="XLink"
                  xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="SCHEMA-AND-XML-1.1"
                  key="XML Schema 1.0 and XML 1.1" xlink:type="simple" xlink:show="replace"
                  xlink:actuate="onRequest">World Wide Web Consortium. <emph>Processing XML 1.1
                     documents with XML Schema 1.0 processors</emph>. W3C Working Group Note 11 May
                  2005. See <loc href="https://www.w3.org/TR/2005/NOTE-xml11schema10-20050511/"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               </bibl>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xml-stylesheet"
                  key="XML Stylesheet" xlink:type="simple" xlink:show="replace"
                  xlink:actuate="onRequest"/>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xptr-framework"
                  key="XPointer Framework" xlink:type="simple" xlink:show="replace"
                  xlink:actuate="onRequest"/>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xsl11" key="XSL-FO"
                  xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xslt" key="XSLT 1.0"
                  xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xslt20" key="XSLT 2.0"
                  xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
            </blist>
         </div2>
      </div1>
      <div1 id="json-in-xml" diff="add" at="O">
         <head>XML Representation of JSON</head>
         <p>This appendix contains the schema for the XML representation of JSON described in
               <specref ref="json-to-xml-mapping"/>, together with the stylesheets used for
            converting from this XML representation to strings matching the JSON grammar.</p>
         <p>These schema documents and stylesheets are also available as separate resources (links
            are listed at the top of this document).</p>
         <div2 id="schema-for-json">
            <head>Schema for the XML Representation of JSON</head>
            <p>The schema is reproduced below:</p>
            <pre class="small">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
    elementFormDefault="qualified"
    targetNamespace="http://www.w3.org/2005/xpath-functions"
    xmlns:j="http://www.w3.org/2005/xpath-functions"&gt;
    
    &lt;!-- 
     * This is a schema for the XML representation of JSON used as the target for the
     * function fn:json-to-xml()
     *
     * The schema is made available under the terms of the W3C software notice and license
     * at http://www.w3.org/Consortium/Legal/copyright-software-19980720
     *
    --&gt;
    
    &lt;xs:element name="map" type="j:mapType"&gt;
        &lt;xs:unique name="unique-key"&gt;
            &lt;xs:selector xpath="*"/&gt;
            &lt;xs:field xpath="@key"/&gt;
            &lt;xs:field xpath="@escaped-key"/&gt;
        &lt;/xs:unique&gt;
    &lt;/xs:element&gt;
    
    &lt;xs:element name="array" type="j:arrayType"/&gt;
    
    &lt;xs:element name="string" type="j:stringType"/&gt;
    
    &lt;xs:element name="number" type="j:numberType"/&gt;
    
    &lt;xs:element name="boolean" type="xs:boolean"/&gt;
    
    &lt;xs:element name="null" type="j:nullType"/&gt;
    
    &lt;xs:complexType name="nullType"&gt;
        &lt;xs:sequence/&gt;
    &lt;/xs:complexType&gt;
    
    &lt;xs:complexType name="stringType"&gt;
        &lt;xs:simpleContent&gt;
            &lt;xs:extension base="xs:string"&gt;
                &lt;xs:attribute name="escaped" type="xs:boolean" use="optional" default="false"/&gt;
            &lt;/xs:extension&gt;
        &lt;/xs:simpleContent&gt;
    &lt;/xs:complexType&gt;
    
    &lt;xs:simpleType name="numberType"&gt;
        &lt;xs:restriction base="xs:double"&gt;
            &lt;!-- exclude positive and negative infinity, and NaN --&gt;
            &lt;xs:minExclusive value="-INF"/&gt;
            &lt;xs:maxExclusive value="INF"/&gt;
        &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
    
    &lt;xs:complexType name="arrayType"&gt;
        &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="j:map"/&gt;
            &lt;xs:element ref="j:array"/&gt;
            &lt;xs:element ref="j:string"/&gt;
            &lt;xs:element ref="j:number"/&gt;
            &lt;xs:element ref="j:boolean"/&gt;
            &lt;xs:element ref="j:null"/&gt;
        &lt;/xs:choice&gt;       
    &lt;/xs:complexType&gt;
    
    &lt;xs:complexType name="mapType"&gt;
        &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element name="map"&gt;
                &lt;xs:complexType&gt;
                    &lt;xs:complexContent&gt;
                        &lt;xs:extension base="j:mapType"&gt;
                            &lt;xs:attribute name="key" type="xs:string"/&gt;
                        &lt;/xs:extension&gt;
                    &lt;/xs:complexContent&gt;
                &lt;/xs:complexType&gt;
                &lt;xs:unique name="unique-key-2"&gt;
                    &lt;xs:selector xpath="*"/&gt;
                    &lt;xs:field xpath="@key"/&gt;
                &lt;/xs:unique&gt;
            &lt;/xs:element&gt;
            &lt;xs:element name="array"&gt;
                &lt;xs:complexType&gt;
                    &lt;xs:complexContent&gt;
                        &lt;xs:extension base="j:arrayType"&gt;
                            &lt;xs:attributeGroup ref="j:key-group"/&gt;
                        &lt;/xs:extension&gt;
                    &lt;/xs:complexContent&gt;
                &lt;/xs:complexType&gt;
            &lt;/xs:element&gt;
            &lt;xs:element name="string"&gt;
                &lt;xs:complexType&gt;
                    &lt;xs:simpleContent&gt;
                        &lt;xs:extension base="j:stringType"&gt;
                            &lt;xs:attributeGroup ref="j:key-group"/&gt;
                        &lt;/xs:extension&gt;
                    &lt;/xs:simpleContent&gt;
                &lt;/xs:complexType&gt;
            &lt;/xs:element&gt;
            &lt;xs:element name="number"&gt;
                &lt;xs:complexType&gt;
                    &lt;xs:simpleContent&gt;
                        &lt;xs:extension base="j:numberType"&gt;
                            &lt;xs:attributeGroup ref="j:key-group"/&gt;
                        &lt;/xs:extension&gt;
                    &lt;/xs:simpleContent&gt;
                &lt;/xs:complexType&gt;
            &lt;/xs:element&gt;
            &lt;xs:element name="boolean"&gt;
                &lt;xs:complexType&gt;
                    &lt;xs:simpleContent&gt;
                        &lt;xs:extension base="xs:boolean"&gt;
                            &lt;xs:attributeGroup ref="j:key-group"/&gt;
                        &lt;/xs:extension&gt;
                    &lt;/xs:simpleContent&gt;
                &lt;/xs:complexType&gt;
            &lt;/xs:element&gt;
            &lt;xs:element name="null"&gt;
                &lt;xs:complexType&gt;
                    &lt;xs:attributeGroup ref="j:key-group"/&gt;
                &lt;/xs:complexType&gt;
            &lt;/xs:element&gt;
        &lt;/xs:choice&gt;
    &lt;/xs:complexType&gt;
    
    &lt;xs:attributeGroup name="key-group"&gt;
        &lt;xs:attribute name="key" type="xs:string" use="required"/&gt;
        &lt;xs:attribute name="escaped-key" type="xs:boolean" use="optional" default="false"/&gt;
    &lt;/xs:attributeGroup&gt;
    
&lt;/xs:schema&gt;
</pre>
         </div2>
         <div2 id="xml-to-json-stylesheet">
            <head>Stylesheet for converting XML to JSON</head>
            <p>This stylesheet contains the implementation of a function very similar to
                  <function>xml-to-json</function>, but implemented in XSLT so that it can be
               customized and extended. This stylesheet is provided for the benefit of users and
               there are no conformance requirements associated with it; there is no requirement
               that processors should make this stylesheet available. The stylesheet is reproduced
               below:</p>
            <pre class="small">&lt;?xml version="1.0" encoding="UTF-8"?&gt;


    &lt;!-- 
        * This is a stylesheet for converting XML to JSON. 
        * It expects the XML to be in the format produced by the XSLT 3.0 function
        * fn:json-to-xml(), but is designed to be highly customizable.
        *
        * The stylesheet is made available under the terms of the W3C software notice and license
        * at http://www.w3.org/Consortium/Legal/copyright-software-19980720
        *
    --&gt;    

&lt;xsl:package
    name="http://www.w3.org/2013/XSLT/xml-to-json"
    package-version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:fn="http://www.w3.org/2005/xpath-functions"
    xmlns:j="http://www.w3.org/2013/XSLT/xml-to-json"
    exclude-result-prefixes="xs fn j" default-mode="j:xml-to-json" version="3.0"&gt;

    &lt;xsl:variable name="quot" visibility="private"&gt;"&lt;/xsl:variable&gt;
    &lt;xsl:param name="indent-spaces" select="2"/&gt;
    
    &lt;!-- The static parameter STREAMABLE controls whether the stylesheet is declared as streamable --&gt;
    
    &lt;xsl:param name="STREAMABLE" static="yes" as="xs:boolean" select="true()"/&gt;
    
    &lt;xsl:mode name="indent" _streamable="{$STREAMABLE}" visibility="public"/&gt;
    &lt;xsl:mode name="no-indent" _streamable="{$STREAMABLE}" visibility="public"/&gt;
    &lt;xsl:mode name="key-attribute" streamable="false" on-no-match="fail" visibility="public"/&gt;
    
    &lt;!-- The static parameter VALIDATE controls whether the input, if untyped, should be validated --&gt;
    
    &lt;xsl:param name="VALIDATE" static="yes" as="xs:boolean" select="false()"/&gt;
    &lt;xsl:import-schema namespace="http://www.w3.org/2005/xpath-functions" use-when="$VALIDATE"/&gt;

    &lt;!-- Entry point: function to convert a supplied XML node to a JSON string --&gt;
    &lt;xsl:function name="j:xml-to-json" as="xs:string" visibility="public"&gt;
        &lt;xsl:param name="input" as="node()"/&gt;
        &lt;xsl:sequence select="j:xml-to-json($input, map{})"/&gt;
    &lt;/xsl:function&gt;

    &lt;!-- Entry point: function to convert a supplied XML node to a JSON string, supplying options --&gt;
    &lt;xsl:function name="j:xml-to-json" as="xs:string" visibility="public"&gt;
        &lt;xsl:param name="input" as="node()"/&gt;
        &lt;xsl:param name="options" as="map(*)"/&gt;
        &lt;xsl:variable name="input" as="node()" use-when="$VALIDATE"&gt;
            &lt;xsl:copy-of select="$input" validation="strict"/&gt;
        &lt;/xsl:variable&gt;
        &lt;xsl:choose&gt;
            &lt;xsl:when test="$options('indent') eq true()"&gt;
                &lt;xsl:apply-templates select="$input" mode="indent"&gt;
                    &lt;xsl:with-param name="fallback" as="(function(element()) as xs:string)?"
                        select="$options('fallback')" tunnel="yes"/&gt;
                &lt;/xsl:apply-templates&gt;
            &lt;/xsl:when&gt;
            &lt;xsl:otherwise&gt;
                &lt;xsl:apply-templates select="$input" mode="no-indent"&gt;
                    &lt;xsl:with-param name="fallback" as="(function(element()) as xs:string)?"
                        select="$options('fallback')" tunnel="yes"/&gt;
                &lt;/xsl:apply-templates&gt;
            &lt;/xsl:otherwise&gt;
        &lt;/xsl:choose&gt;
    &lt;/xsl:function&gt;
    
    &lt;!-- A document node is ignored --&gt;
    
    &lt;xsl:template match="/" mode="indent no-indent"&gt;
        &lt;xsl:apply-templates mode="#current"/&gt;
    &lt;/xsl:template&gt;

    &lt;!-- Template rule for fn:map elements, representing JSON objects --&gt;

    &lt;xsl:template match="fn:map" mode="indent"&gt;
        &lt;xsl:value-of&gt;
            &lt;xsl:variable name="depth" select="count(ancestor::*) + 1"/&gt;
            &lt;xsl:text&gt;{&lt;/xsl:text&gt;
            &lt;xsl:for-each select="*"&gt;
                &lt;xsl:if test="position() gt 1"&gt;
                    &lt;xsl:text&gt;, &lt;/xsl:text&gt;
                    &lt;xsl:value-of select="j:indent($depth)"/&gt;
                &lt;/xsl:if&gt;
                &lt;xsl:apply-templates select="snapshot(@key)" mode="key-attribute"/&gt;
                &lt;xsl:text&gt; : &lt;/xsl:text&gt;
                &lt;xsl:apply-templates select="." mode="#current"/&gt;
            &lt;/xsl:for-each&gt;
            &lt;xsl:text&gt;}&lt;/xsl:text&gt;
        &lt;/xsl:value-of&gt;
    &lt;/xsl:template&gt;

    &lt;xsl:template match="fn:map" mode="no-indent"&gt;
        &lt;xsl:value-of&gt;
            &lt;xsl:text&gt;{&lt;/xsl:text&gt;
            &lt;xsl:for-each select="*"&gt;
                &lt;xsl:if test="position() gt 1"&gt;
                    &lt;xsl:text&gt;,&lt;/xsl:text&gt;
                &lt;/xsl:if&gt;
                &lt;xsl:apply-templates select="snapshot(@key)" mode="key-attribute"/&gt;
                &lt;xsl:text&gt;:&lt;/xsl:text&gt;
                &lt;xsl:apply-templates select="." mode="#current"/&gt;
            &lt;/xsl:for-each&gt;
            &lt;xsl:text&gt;}&lt;/xsl:text&gt;
        &lt;/xsl:value-of&gt;
    &lt;/xsl:template&gt;

    &lt;!-- Template rule for fn:array elements, representing JSON arrays --&gt;
    &lt;xsl:template match="fn:array" mode="indent"&gt;
        &lt;xsl:value-of&gt;
            &lt;xsl:variable name="depth" select="count(ancestor::*) + 1"/&gt;
            &lt;xsl:text&gt;[&lt;/xsl:text&gt;
            &lt;xsl:for-each select="*"&gt;
                &lt;xsl:if test="position() gt 1"&gt;
                    &lt;xsl:text&gt;, &lt;/xsl:text&gt;
                    &lt;xsl:value-of select="j:indent($depth)"/&gt;
                &lt;/xsl:if&gt;
                &lt;xsl:apply-templates select="." mode="#current"/&gt;
            &lt;/xsl:for-each&gt;
            &lt;xsl:text&gt;]&lt;/xsl:text&gt;
        &lt;/xsl:value-of&gt;
    &lt;/xsl:template&gt;

    &lt;xsl:template match="fn:array" mode="no-indent"&gt;
        &lt;xsl:value-of&gt;
            &lt;xsl:text&gt;[&lt;/xsl:text&gt;
            &lt;xsl:for-each select="*"&gt;
                &lt;xsl:if test="position() gt 1"&gt;
                    &lt;xsl:text&gt;,&lt;/xsl:text&gt;
                &lt;/xsl:if&gt;
                &lt;xsl:apply-templates select="." mode="#current"/&gt;
            &lt;/xsl:for-each&gt;
            &lt;xsl:text&gt;]&lt;/xsl:text&gt;
        &lt;/xsl:value-of&gt;
    &lt;/xsl:template&gt;

    &lt;!-- Template rule for fn:string elements in which 
         special characters are already escaped --&gt;
    &lt;xsl:template match="fn:string[@escaped='true']" mode="indent no-indent"&gt;
        &lt;xsl:sequence select="concat($quot, ., $quot)"/&gt;
    &lt;/xsl:template&gt;

    &lt;!-- Template rule for fn:string elements in which 
         special characters need to be escaped --&gt;
    &lt;xsl:template match="fn:string[not(@escaped='true')]" mode="indent no-indent"&gt;
        &lt;xsl:sequence select="concat($quot, j:escape(.), $quot)"/&gt;
    &lt;/xsl:template&gt;

    &lt;!-- Template rule for fn:boolean elements --&gt;
    &lt;xsl:template match="fn:boolean" mode="indent no-indent"&gt;
        &lt;xsl:sequence select="xs:string(xs:boolean(.))"/&gt;
    &lt;/xsl:template&gt;

    &lt;!-- Template rule for fn:number elements --&gt;
    &lt;xsl:template match="fn:number" mode="indent no-indent"&gt;
        &lt;xsl:value-of select="xs:string(xs:double(.))"/&gt;
    &lt;/xsl:template&gt;

    &lt;!-- Template rule for JSON null elements --&gt;
    &lt;xsl:template match="fn:null" mode="indent no-indent"&gt;
        &lt;xsl:text&gt;null&lt;/xsl:text&gt;
    &lt;/xsl:template&gt;

    &lt;!-- Template rule matching a key within a map where 
         special characters in the key are already escaped --&gt;
    &lt;xsl:template match="fn:*[@key-escaped='true']/@key" mode="key-attribute"&gt;
        &lt;xsl:value-of select="concat($quot, ., $quot)"/&gt;
    &lt;/xsl:template&gt;

    &lt;!-- Template rule matching a key within a map where 
         special characters in the key need to be escaped --&gt;
    &lt;xsl:template match="fn:*[not(@key-escaped='true')]/@key" mode="key-attribute"&gt;
        &lt;xsl:value-of select="concat($quot, j:escape(.), $quot)"/&gt;
    &lt;/xsl:template&gt;
    
    &lt;!-- Template matching "invalid" elements --&gt;
    &lt;xsl:template match="*" mode="indent no-indent"&gt;
        &lt;xsl:param name="fallback" as="(function(element()) as xs:string)?"
            tunnel="yes" required="yes"/&gt;
        &lt;xsl:choose&gt;
            &lt;xsl:when test="exists($fallback)"&gt;
                &lt;xsl:value-of select="$fallback(snapshot(.))"/&gt;
            &lt;/xsl:when&gt;
            &lt;xsl:otherwise&gt;
                &lt;xsl:message terminate="yes"&gt;&gt;Inc&lt;/xsl:message&gt;
            &lt;/xsl:otherwise&gt;
        &lt;/xsl:choose&gt;
    &lt;/xsl:template&gt;

    &lt;!-- Template rule matching (and discarding) whitespace text nodes in the XML --&gt;
    &lt;xsl:template match="text()[not(normalize-space())]" mode="indent no-indent"/&gt;

    &lt;!-- Function to escape special characters --&gt;
    &lt;xsl:function name="j:escape" as="xs:string" visibility="final"&gt;
        &lt;xsl:param name="in" as="xs:string"/&gt;
        &lt;xsl:value-of&gt;
            &lt;xsl:for-each select="string-to-codepoints($in)"&gt;
                &lt;xsl:choose&gt;
                    &lt;xsl:when test=". gt 65535"&gt;
                        &lt;xsl:value-of select="concat('\u', j:hex4((. - 65536) idiv 1024 + 55296))"/&gt;
                        &lt;xsl:value-of select="concat('\u', j:hex4((. - 65536) mod 1024 + 56320))"/&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:when test=". = 34"&gt;\"&lt;/xsl:when&gt;
                    &lt;xsl:when test=". = 92"&gt;\\&lt;/xsl:when&gt;
                    &lt;xsl:when test=". = 08"&gt;\b&lt;/xsl:when&gt;
                    &lt;xsl:when test=". = 09"&gt;\t&lt;/xsl:when&gt;
                    &lt;xsl:when test=". = 10"&gt;\n&lt;/xsl:when&gt;
                    &lt;xsl:when test=". = 12"&gt;\f&lt;/xsl:when&gt;
                    &lt;xsl:when test=". = 13"&gt;\r&lt;/xsl:when&gt;
                    &lt;xsl:when test=". lt 32 or (. ge 127 and . le 160)"&gt;
                        &lt;xsl:value-of select="concat('\u', j:hex4(.))"/&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:otherwise&gt;
                        &lt;xsl:value-of select="codepoints-to-string(.)"/&gt;
                    &lt;/xsl:otherwise&gt;
                &lt;/xsl:choose&gt;
            &lt;/xsl:for-each&gt;
        &lt;/xsl:value-of&gt;
    &lt;/xsl:function&gt;

    &lt;!-- Function to convert a UTF16 codepoint into a string of four hex digits --&gt;
    &lt;xsl:function name="j:hex4" as="xs:string" visibility="final"&gt;
        &lt;xsl:param name="ch" as="xs:integer"/&gt;
        &lt;xsl:variable name="hex" select="'0123456789abcdef'"/&gt;
        &lt;xsl:value-of&gt;
            &lt;xsl:value-of select="substring($hex, $ch idiv 4096 + 1, 1)"/&gt;
            &lt;xsl:value-of select="substring($hex, $ch idiv 256 mod 16 + 1, 1)"/&gt;
            &lt;xsl:value-of select="substring($hex, $ch idiv 16 mod 16 + 1, 1)"/&gt;
            &lt;xsl:value-of select="substring($hex, $ch mod 16 + 1, 1)"/&gt;
        &lt;/xsl:value-of&gt;
    &lt;/xsl:function&gt;

    &lt;!-- Function to output whitespace indentation based on 
         the depth of the node supplied as a parameter --&gt;

    &lt;xsl:function name="j:indent" as="text()" visibility="public"&gt;
        &lt;xsl:param name="depth" as="xs:integer"/&gt;
        &lt;xsl:value-of select="'&amp;#xa;', string-join((1 to ($depth + 1) * $indent-spaces) ! ' ', '')"/&gt;
    &lt;/xsl:function&gt;

&lt;/xsl:package&gt;
</pre>
         </div2>
      </div1>
      <inform-div1 id="glossary">
         <head>Glossary</head>
         <?glossary?>
      </inform-div1>
      <inform-div1 id="element-syntax-summary">
         <head>Element Syntax Summary</head>
         <?element-syntax-summary?>
      </inform-div1>
      <inform-div1 id="error-summary">
         <head>Summary of Error Conditions</head>
         <p diff="chg" at="E">This appendix provides a summary of error conditions that a processor
            may signal. This list includes all error codes defined in this specification, but this
            is not an exhaustive list of all errors that can occur. Implementations
               <rfc2119>must</rfc2119> signal errors using these error codes, and applications can
            test for these codes; however, when more than one rule in the specification is violated,
            different processors will not necessarily signal the same error code. Implementations
            are not <rfc2119>required</rfc2119> to signal errors using the descriptive text used
            here.</p>
         <note>
            <p>The appendix is non-normative because the same information is given normatively
               elsewhere.</p>
         </note>
         <?error-summary?>
      </inform-div1>
      <inform-div1 id="implementation-defined-features" diff="chg" at="R-bug28186">
         <head>Checklist of Implementation-Defined Features</head>
         <p>This appendix provides a summary of XSLT language features whose effect is explicitly
               <termref def="dt-implementation-defined"/>. The conformance rules (see <specref
               ref="conformance"/>) require vendors to provide documentation that explains how these
            choices have been exercised.</p>
         <p>The implementation-defined features are grouped into categories for convenience.</p>
         <div2 id="imp-def-api">
            <head>Application Programming Interfaces</head>
            <p>This category covers interfaces for initiating a transformation, setting its
               parameters, initializing the static and dynamic context, and collecting the results.
               In general terms, it is implementation defined how input is passed to the processor
               and how it returns its output. This includes the interpretation of URIs used to refer
               to stylesheet packages and modules, source documents and collections, collations, and
               result documents.</p>
            <p>More specifically:</p>
            <?implementation-defined-features api?>
         </div2>
         <div2 id="imp-def-ext">
            <head>Vendor and User Extensions</head>
            <p>This category covers extensions and extensibility: mechanisms for providing vendor or
               user extensions to the language without sacrificing interoperability.</p>
            <p>In general terms, it is implementation-defined:</p>
            <ulist>
               <item>
                  <p>whether and under what circumstances the implementation recognizes any
                     extension functions, extension instructions, extension attributes, user-defined
                     data elements, additional types, additional serialization methods or
                     serialization parameters, or additional collations, and if so, what effect they
                     have. </p>
               </item>
               <item>
                  <p>whether, how, and under what circumstances the implementation allows users to
                     define extension functions, extension instructions, extension attributes,
                     user-defined data elements, additional types, additional serialization methods
                     or serialization parameters, or additional collations. If it does allow users
                     to do so, it must follow the rules given elsewhere in this specification. </p>
               </item>
               <item>
                  <p>what information is available to such extensions (for example, whether they
                     have access to the static and dynamic context.) </p>
               </item>
               <item>
                  <p>where such extensions are allowed, the extent to which the processor enforces
                     their correct behavior (for example, checking that strings returned by
                     extension functions contain only valid XML characters) </p>
               </item>
            </ulist>
            <p>More specifically:</p>
            <?implementation-defined-features ext?>
         </div2>
         <div2 id="imp-def-feature">
            <head>Localization</head>
            <p>This specification, and the specifications that it refers to, include facilities for
               adapting the output of a transformation to meet local expectations: examples include
               the formatting of numbers and dates, and the choice of collations for sorted output.
               The general principles are:</p>
            <ulist>
               <item>
                  <p>The specification does not mandate any particular localizations that processors
                     must offer: for example, a conformant processor might choose to provide output
                     in Japanese only.</p>
               </item>
               <item>
                  <p>The specification provides fallback mechanisms so that if a particular
                     localization is requested and is not available, processing does not fail.</p>
               </item>
            </ulist>
            <p>More specifically:</p>
            <?implementation-defined-features local?>
         </div2>
         <div2 id="imp-def-optional-feature">
            <head>Optional Features</head>
            <p>As well as the optional conformance features identified in <specref ref="conformance"
               />, some specific features of the specification are defined to be optional.</p>
            <?implementation-defined-features feature?>
         </div2>
         <div2 id="imp-def-dependencies">
            <head>Dependencies</head>
            <p>When this specification refers normatively to other specifications, it generally
               gives implementations freedom to decide (within constraints) which version of the
               referenced specification should be used. Specifically:</p>
            <?implementation-defined-features spec?>
         </div2>
         <div2 id="imp-def-defaults-and-limits">
            <head>Defaults and Limits</head>
            <p>To accommodate variations in the way that the XSLT language is deployed, and the
               constraints of different processing environments, defaults for some options are
               implementation-defined. In addition, limits on the sizes of ranges of values
               permitted are in general implementation-defined:</p>
            <?implementation-defined-features defaults?>
         </div2>
         <div2 id="imp-def-errors">
            <head>Detection and Reporting of Errors</head>
            <p>Some aspects of error handling are implementation-defined:</p>
            <?implementation-defined-features err?>
         </div2>
      </inform-div1>
      <inform-div1 id="summary-list-of-functions" diff="add" at="T">
         <head>Summary of Available Functions</head>
         <div2 id="function-categories">
            <head>Function Classification</head>
            <p>The functions available for use within an XSLT stylesheet can be classified based
               firstly, on where the function is defined, and secondly, on where it can be used.
               Specifically, the set of functions available is slightly different for :</p>
            <ulist>
               <item>
                  <p>Regular XPath expressions within the stylesheet, for example those appearing in
                        <code>select</code> or <code>test</code> attributes, or between braces in a
                        <termref def="dt-text-value-template"/> (<var>R</var>)</p>
               </item>
               <item>
                  <p><termref def="dt-static-expression">Static expressions</termref>
                     (<var>S</var>)</p>
               </item>
               <item>
                  <p>XPath expressions evaluated dynamically using <elcode>xsl:evaluate</elcode>
                        (<var>D</var>)</p>
               </item>
            </ulist>
            <p>The categories are listed in the following table:</p>
            <table class="data">
               <caption>Categories of Function, and their Availability</caption>
               <thead>
                  <tr>
                     <th rowspan="1" colspan="1">Category</th>
                     <th rowspan="1" colspan="1">Defined where?</th>
                     <th rowspan="1" colspan="1">Available where?</th>
                     <th rowspan="1" colspan="1">Notes</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td rowspan="1" colspan="1">User-defined functions</td>
                     <td rowspan="1" colspan="1">Defined using <elcode>xsl:function</elcode>
                        declarations in the stylesheet</td>
                     <td rowspan="1" colspan="1"><var>R</var>, <var>D</var></td>
                     <td rowspan="1" colspan="1">Functions are private by default; private functions
                        can be referenced only within the package where they are declared (and not
                        in <elcode>xsl:evaluate</elcode> expressions).</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Constructor functions for built-in types</td>
                     <td rowspan="1" colspan="1"><xspecref spec="FO30" ref="constructor-functions"
                        /></td>
                     <td rowspan="1" colspan="1"><var>R</var>, <var>S</var>, <var>D</var></td>
                     <td rowspan="1" colspan="1">These functions are all in the namespace
                        conventionally associated with the prefix <code>xs</code>. The semantics of
                        a constructor function are identical to the semantics of a <code>cast</code>
                        expression.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Constructor functions for user-defined types</td>
                     <td rowspan="1" colspan="1"><xspecref spec="FO30" ref="constructor-functions"
                        /></td>
                     <td rowspan="1" colspan="1"><var>R</var>, <var>D</var> (if
                           <code>schema-aware="yes"</code>)</td>
                     <td rowspan="1" colspan="1">This category includes a function for every named
                        user-defined simple type in an imported schema; the function allows the
                        conversion of strings and certain other values to instances of the
                        user-defined type.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Functions defined in XPath 3.0</td>
                     <td rowspan="1" colspan="1"><bibref ref="xpath-functions-30"/></td>
                     <td rowspan="1" colspan="1"><var>R</var>, <var>S</var>, <var>D</var></td>
                     <td rowspan="1" colspan="1">Includes functions in the namespaces conventionally
                        referred to be the prefixes <code>fn</code> and <code>math</code>.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Additional functions defined in XPath 3.1 (where
                        supported)</td>
                     <td rowspan="1" colspan="1"><bibref ref="xpath-functions-31"/></td>
                     <td rowspan="1" colspan="1"><var>R</var>, <var>S</var>, <var>D</var>.</td>
                     <td rowspan="1" colspan="1">This category has an overlap with the set of
                        XSLT-defined-functions. Where a function is defined both in this document
                        and in XPath 3.1, the function is available in an XSLT 3.0 stylesheet
                        whether or not the processor supports XPath 3.1. This category includes
                        functions in namespaces conventionally referred to by the prefixes
                           <code>fn</code>, <code>map</code>, and <code>array</code>.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Functions defined in XSLT 3.0</td>
                     <td rowspan="1" colspan="1">This specification</td>
                     <td rowspan="1" colspan="1"><var>R</var>, <var>S</var> (see note),
                        <var>D</var></td>
                     <td rowspan="1" colspan="1">See <specref ref="XSLT-defined-functions"/>. There
                        is an overlap with the set of functions defined in XPath 3.1. The functions
                        available in static expressions are: <function>element-available</function>,
                           <function>function-available</function>,
                           <function>type-available</function>,
                           <function>available-system-properties</function>, and
                           <function>system-property</function>.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Extension functions</td>
                     <td rowspan="1" colspan="1">Implementation-defined: see <specref
                           ref="extension-functions"/>.</td>
                     <td rowspan="1" colspan="1"><var>R</var>, <var>S</var>, <var>D</var></td>
                     <td rowspan="1" colspan="1">Availability is <termref
                           def="dt-implementation-defined"/></td>
                  </tr>
               </tbody>
            </table>
         </div2>
         <div2 id="XSLT-defined-functions" diff="add" at="E">
            <head>List of XSLT-defined functions</head>
            <p>This appendix acts as an index of functions defined in this specification, to augment
               the set of functions defined in <bibref ref="xpath-functions-30"/>.</p>
            <?xslt-defined-functions?>
         </div2>
      </inform-div1>
      <inform-div1 id="schema-for-xslt">
         <head>Schemas for XSLT 3.0 Stylesheets</head>
         <p>For convenience, schemas are provided for validation of XSLT 3.0 stylesheets using the
            XSD 1.1 and Relax NG schema languages. These are non-normative. Neither will detect
            every static error that might arise in an XSLT 3.0 stylesheet (for example, there is no
            attempt to check the syntax of XPath expressions); in addition, these schemas may reject
            some stylesheets that are valid, for example because they rely on
               <code>xsl:use-when</code> to eliminate sections of code that would otherwise be
            invalid.</p>
         <div2 id="xsd11-schema-for-xslt">
            <head>XSD 1.1 Schema for XSLT Stylesheets</head>
            <p>The following XSD 1.1 schema describes the structure of an XSLT stylesheet module. It
               does not define all the constraints that apply to a stylesheet (for example, it does
               not attempt to define a datatype that precisely represents attributes containing
               XPath <termref def="dt-expression">expressions</termref>). However, every valid
               stylesheet module conforms to this schema, unless it contains elements that invoke
                  <termref def="dt-forwards-compatible-behavior"/>.</p>
            <p>A copy of this schema is available at <loc xmlns:xlink="http://www.w3.org/1999/xlink"
                  href="schema-for-xslt30.xsd" xlink:type="simple" xlink:show="replace"
                  xlink:actuate="onRequest">schema-for-xslt30.xsd</loc>
            </p>
            <note diff="add" at="L">
               <p>The schema as written uses a lax wildcard to permit literal result elements to
                  appear in a sequence constructor. This assumes that the schema used for validation
                  will not contain any global element declaration that matches the element name of a
                  literal result element. The content model for an element such as
                     <code>invoice</code> appearing within a stylesheet is not the same as the
                  content model for the same element appearing within a source document (it is
                  likely to contain XSLT instructions rather than other elements from the target
                  vocabulary): therefore, including such declarations in the schema used for
                  validating a stylesheet is inappropriate.</p>
               <p>The reason that lax validation rather than skip validation is used is so that XSLT
                  instructions appearing as children of the literal result element will themselves
                  be validated, using the appropriate global element declaration.</p>
            </note>
            <note diff="add" at="L">
               <p>The schema uses XSD 1.1 assertions to represent some of the non-grammatical
                  constraints appearing in the specification, for example the rule that some
                  elements can have either a <code>select</code> attribute or a contained sequence
                  constructor, but not both. At this stage, no attempt has been made to represent
                  every such constraint, even where it is not difficult to express the rule. There
                  will always be some constraints that cannot be expressed at all, for example those
                  that require access to multiple stylesheet modules, those that require access to
                  the in-scope schema components, and those that involve parsing a non-regular
                  grammar, such as the grammar for patterns.</p>
               <p>Apart from assertions, the only other significant use of XSD 1.1 features is that
                  the elements <elcode>xsl:param</elcode> and <elcode>xsl:variable</elcode> are in
                  two substitution groups: one containing all instructions, and one containing all
                  declarations. If the schema needs to be converted to an XSD 1.0 schema, removing
                  all assertions is straightforward; the other change needed is to remove
                     <elcode>xsl:param</elcode> and <elcode>xsl:variable</elcode> from the
                  substitution group for declarations, and instead permit them explicitly as
                  children of <elcode>xsl:transform</elcode>.</p>
            </note>
            <?schema-for-xslt?>
         </div2>
         <div2 id="relax-ng-schema-for-xslt" diff="add" at="T">
            <head>Relax-NG Schema for XSLT Stylesheets</head>
            <p>The following Relax-NG schema may be used to validate XSLT 3.0 stylesheet modules.
               Similar caveats apply as for the XSD 1.1 version.</p>
            <p>A copy of this schema is available at <loc xmlns:xlink="http://www.w3.org/1999/xlink"
                  href="schema-for-xslt30.rnc" xlink:type="simple" xlink:show="replace"
                  xlink:actuate="onRequest">schema-for-xslt30.rnc</loc>
            </p>
            <?rng-schema-for-xslt?>
         </div2>
      </inform-div1>
      <inform-div1 id="acknowledgements">
         <head>Acknowledgements</head>
         <p>This specification was developed and approved for publication by the W3C XSLT Working
            Group (WG).</p>
         <p>The chair of the XSLT WG is Sharon Adler. The active membership of the XSLT WG during
            the final stages of the preparation of this specification included:</p>
         <slist>
            <sitem>Sharon Adler (Chair)</sitem>
            <sitem>Anders Berglund</sitem>
            <sitem>Carine Bournez (W3C team)</sitem>
            <sitem>Abel Braaksma</sitem>
            <sitem>Charles Foster</sitem>
            <sitem>Florent Georges</sitem>
            <sitem>Michael Kay (Editor)</sitem>
            <sitem>Jirka Kosek</sitem>
            <sitem>Luis Ibhiabor</sitem>
            <sitem>Michael Sperberg-McQueen</sitem>
            <sitem>Norm Walsh</sitem>
            <sitem>Mohamed Zergaoui</sitem>
         </slist>
         <p>The Working Group wishes to acknowledge the contribution of those who have participated
            in the work at earlier stages, as well as the pioneering work of the developers of STX
            (see <bibref ref="STX"/>) which formed an important intellectual input to the design of
            XSLT 3.0 and demonstrated the feasibility of creating a streaming transformation
            language based on the core XSLT concept of recursive descent of the source tree using
            rule-based templates.</p>
         <p>The Working Group also wishes to thank external reviewers who have provided feedback
            during the development of the specification.</p>
      </inform-div1>
      <inform-div1 id="changes-since-2.0" diff="add" at="B">
         <head>Changes since XSLT 2.0</head>
         <div2 id="xslt-changes-since-2.0">
            <head>Changes in this Specification</head>
            <olist>
               <item>
                  <p>A stylesheet may now consist of multiple packages. The language specification
                     for packages has been designed with a view to allowing packages to be compiled
                     independently of each other. The specification provides control over the
                     interface offered by a package to other packages; in particular it allows
                     functions, variables, named templates and other components to be declared as
                     public, private, final, or abstract.</p>
               </item>
               <item>
                  <p>A new <elcode>xsl:mode</elcode> declaration is added.</p>
                  <olist>
                     <item>
                        <p>A mode may be declared to be streamable, and rules are given that
                           constrain what the template rules in a streamable mode can do.</p>
                     </item>
                     <item diff="del" at="R-bug24764">
                        <p>The <elcode>xsl:mode</elcode> declaration may contain an
                              <elcode>xsl:context-item</elcode> element to declare the expected type
                           of the <termref def="dt-global-context-item"/> when this mode is the
                              <termref def="dt-initial-mode"/>.</p>
                     </item>
                     <item>
                        <p>An <elcode>xsl:mode</elcode> declaration may define the action to be
                           taken when there is no matching template rule, and the action to be taken
                           when there are multiple matching template rules.</p>
                     </item>
                     <item>
                        <p>An <elcode>xsl:mode</elcode> declaration may indicate that the template
                           rules in a given mode are designed to process typed (schema-validated)
                           nodes only, or untyped nodes only. It may also indicate that element
                           names appearing in match patterns for the mode are only to match elements
                           in the source document that have been validated against the corresponding
                           element declarations in the schema.</p>
                     </item>
                     <item>
                        <p>A default mode can be declared for a stylesheet module, making it easier
                           to reuse existing stylesheet modules to construct a composite
                           stylesheet.</p>
                     </item>
                  </olist>
               </item>
               <item>
                  <p>Several new instructions are introduced with the aim of making it easier to
                     write streamable transformations, although all of these instructions can also
                     be used without streaming:</p>
                  <olist>
                     <item>
                        <p>The <elcode>xsl:source-document</elcode> instruction is provided to read
                           and process an input document using streaming.</p>
                     </item>
                     <item>
                        <p>The <elcode>xsl:iterate</elcode> instruction allows iterative processing
                           of a sequence, with the ability for the processing of one item to depend
                           on the results of processing of previous items, and with the ability to
                           terminate the iteration before all the items in the sequence have been
                           processed.</p>
                     </item>
                     <item>
                        <p>The <elcode>xsl:merge</elcode> instruction allows several input sequences
                           to be merged into a single output sequence, based on the value of a merge
                           key.</p>
                     </item>
                     <item>
                        <p>The <elcode>xsl:fork</elcode> instruction allows multiple results to be
                           computed during a single pass of a streamed input document.</p>
                        <p>The <elcode>xsl:sequence</elcode> instruction can now contain a sequence
                           constructor as an alternative to using the <code>select</code> attribute.
                           This is primarily for use cases involving <elcode>xsl:fork</elcode>.</p>
                     </item>
                     <item>
                        <p diff="add" at="S-bug27189">New instructions
                              <elcode>xsl:where-populated</elcode>, <elcode>xsl:on-empty</elcode>,
                           and <elcode>xsl:on-non-empty</elcode> are introduced to allow elements to
                           be generated only when relevant content exists (or does not exist),
                           without requiring the input to be processed more than once.</p>
                     </item>
                  </olist>
               </item>
               <item>
                  <p>Other changes introduced to facilitate the writing of streamable
                     transformations include:</p>
                  <olist>
                     <item>
                        <p>The new <termref def="dt-top-level"/> declaration
                              <elcode>xsl:accumulator</elcode> is introduced. An accumulator
                           represents information about a node in a document that can be computed
                           during a streamed pass over the document, starting at the start and
                           ending at that node.</p>
                     </item>
                     <item>
                        <p>New functions <function>copy-of</function> and
                              <function>snapshot</function> are provided, to enable streaming
                           applications to operate in windowing mode, where the input document is
                           divided into a sequence of small subtrees processed one at a time.</p>
                     </item>
                  </olist>
               </item>
               <item>
                  <p>Some further new instructions are provided, unrelated to streaming:</p>
                  <olist>
                     <item>
                        <p>The <elcode>xsl:try</elcode> instruction allows recovery from dynamic
                           errors.</p>
                     </item>
                     <item>
                        <p>A new <elcode>xsl:evaluate</elcode> instruction is provided, to allow
                           evaluation of XPath expressions constructed dynamically from strings, or
                           read from a source document.</p>
                     </item>
                     <item>
                        <p diff="add" at="L">The <elcode>xsl:assert</elcode> instruction allows
                           arbitrary assertions about the state of variables or the input document,
                           improving testability and robustness.</p>
                     </item>
                  </olist>
               </item>
               <item>
                  <p>Static global variables and parameters can be declared. These act as
                     compile-time constants. The values of static variables can be used in
                     initializing other static variables, or in <code>[xsl:]use-when</code>
                     attributes, or in <emph>shadow attributes</emph>. Shadow attributes allow any
                     attribute of an XSLT instruction or declaration to be parameterized by
                     reference to static variables and parameters.</p>
               </item>
               <item>
                  <p diff="add" at="N">Text nodes within a sequence constructor may now contain
                        <termref def="dt-text-value-template">text value templates</termref> (XPath
                     expressions enclosed in curly brackets), if this is enabled by setting
                        <code>expand-text="yes"&gt;</code> on an enclosing element. This reduces the
                     verbosity of code written to generate boilerplate text with variable
                     inserts.</p>
               </item>
               <item>
                  <p>The syntax of <termref def="dt-pattern">patterns</termref> has been
                     generalized. Patterns may now match any item (not only nodes). In consequence,
                        <elcode>xsl:apply-templates</elcode> can now process sequences of atomic
                     values as well as nodes, and <elcode>xsl:for-each-group</elcode> with the
                        <code>group-starting-with</code> and <code>group-ending-with</code> options
                     can also process atomic sequences. As a further consequence, the <phrase
                        diff="chg" at="R-bug24764">items in the <termref
                           def="dt-initial-match-selection"/> supplied when initiating a
                        transformation are no longer required to be nodes</phrase>.</p>
               </item>
               <item>
                  <p>A new datatype, called a <term>map</term>, has been introduced, together with
                     supporting functions, operators, and type syntax. Maps allow more complex data
                     structures to be created than is possible using atomic values and nodes alone.
                     This has particular applications to streamed processing: since a streamed
                     application can visit each node of its primary input document only once, it
                     often needs more advanced data structures to retain what it has already seen in
                     the document.</p>
               </item>
               <item>
                  <p>Miscellaneous changes to existing instructions and declarations include:</p>
                  <olist>
                     <item>
                        <p diff="add" at="N">The regular expression supplied to the
                              <elcode>xsl:analyze-string</elcode> instruction is now permitted to be
                           one that matches a zero-length string.</p>
                     </item>
                     <item>
                        <p>The <elcode>xsl:copy</elcode> instruction now has a <code>select</code>
                           attribute, which is convenient when it is used inside a function where
                           there is no context item.</p>
                     </item>
                     <item>
                        <p diff="add" at="G">Composite keys are supported in
                              <elcode>xsl:for-each-group</elcode>.</p>
                     </item>
                     <item>
                        <p> Two new attributes have been added to <elcode>xsl:function</elcode> to
                           provide increased scope for optimization: <code>new-each-time</code> and
                              <code>cache</code>. The first indicates whether the identity of nodes
                           created by the function is significant to the application; the second
                           indicates whether the function is to cache its results (memoization).
                        </p>
                     </item>
                     <item>
                        <p diff="add" at="M">The <code>override</code> attribute of
                              <elcode>xsl:function</elcode> is renamed
                              <code>override-extension-function</code>, retaining the old name as a
                           deprecated synonym.</p>
                     </item>
                     <item>
                        <p diff="add" at="M">The rule requiring <elcode>xsl:import</elcode>
                           declarations to precede all other declarations in a stylesheet module has
                           been removed.</p>
                     </item>
                     <item>
                        <p diff="add" at="G">Composite keys are supported in
                              <elcode>xsl:key</elcode>.</p>
                     </item>
                     <item>
                        <p diff="add" at="M">A new attribute on <elcode>xsl:message</elcode> allows
                           specification of an error code.</p>
                     </item>
                     <item>
                        <p diff="add" at="G">The rules for handling conflicts between
                              <elcode>xsl:strip-space</elcode> and
                              <elcode>xsl:preserve-space</elcode> have changed. A conflict that can
                           be detected statically is now signaled as a static error; a run-time
                           conflict between two declarations having the same precedence and priority
                           is now resolved by taking whichever comes last in declaration order.</p>
                     </item>
                     <item>
                        <p diff="add" at="G">An <elcode>xsl:template</elcode> declaration may
                           contain an <elcode>xsl:context-item</elcode> element to declare the
                           required type of the context item when the template is called.</p>
                     </item>
                     <item>
                        <p diff="add" at="M">An empty <elcode>xsl:value-of</elcode> instruction with
                           no <code>select</code> attribute is now permitted; its effect is to
                           construct a zero-length text node.</p>
                     </item>
                     <item>
                        <p diff="add" at="M">The <elcode>xsl:variable</elcode> and
                              <elcode>xsl:param</elcode> elements may now specify
                              <code>static="yes"</code>, denoting that the variable is available
                           statically (informally, “at compile time”). Static variables and
                           parameters make the <code>[xsl:]use-when</code> mechanism more useful,
                           especially in conjunction with <elcode>xsl:assert</elcode>.</p>
                     </item>
                  </olist>
               </item>
               <item>
                  <p>New functions are available to import and export data in JSON format.</p>
               </item>
               <item>
                  <p>A <termref def="dt-basic-xslt-processor">basic XSLT Processor</termref> now
                     recognizes all the built-in types defined in XML Schema.</p>
               </item>
               <item>
                  <p>A <termref def="dt-basic-xslt-processor">basic XSLT Processor</termref> will
                     now accept the attribute <code>validation="lax"</code> and interpret it in the
                     same way as a schema-aware processor when there is no schema component
                     available to perform the validation.</p>
               </item>
               <item>
                  <p>Some functions, including <xfunction>generate-id</xfunction>,
                        <xfunction>format-date</xfunction>, <xfunction>format-dateTime</xfunction>,
                        <xfunction>format-number</xfunction>, <xfunction>format-time</xfunction>,
                     and <xfunction>unparsed-text</xfunction> have been moved from this
                     specification to the Functions and Operators specification, to make them
                     available in other host languages. </p>
               </item>
               <item>
                  <p diff="add" at="M">The rule that effectively prevented references to external
                     documents in <code>[xsl:]use-when</code> expressions has been removed.</p>
               </item>
               <item>
                  <p diff="add" at="M">A default value is defined for the named template to be used
                     when initiating a transformation (specifically,
                        <code>xsl:initial-template</code>).</p>
               </item>
               <item>
                  <p diff="add" at="M"> Serialization to HTML5 and XHTML5 is supported. To this end,
                     a new serialization parameter <code>html-version</code> is provided in
                        <elcode>xsl:output</elcode> and <elcode>xsl:result-document</elcode>. </p>
                  <p>Other new serialization parameters include: <code>item-separator</code>,
                        <code>json-node-output-method</code>, <code>parameter-document</code>,
                        <code>suppress-indentation</code>.</p>
               </item>
               <item>
                  <p> The concept of recoverable dynamic errors has been dropped. Of the remaining
                     recoverable dynamic errors, some are no longer errors, and others are now
                     situations where the behavior of the processor is <termref
                        def="dt-implementation-dependent"/>. The adjective
                        <emph>non-recoverable</emph> in describing other dynamic errors becomes
                     redundant and has therefore been dropped (the term was in any case misleading
                     since the introduction of a try/catch mechanism). Error codes of the form
                        <code>XTREnnnn</code> have been renumbered <code>XTDEnnnn</code>. </p>
                  <p diff="add" at="N">Dynamic errors occurring during pattern evaluation are always
                     masked (they cause the pattern to report a non-match.)</p>
               </item>
               <item>
                  <p diff="add" at="N">A family of collation URIs is defined for selecting
                     collations based on the Unicode Collation Algorithm.</p>
               </item>
               <item>
                  <p diff="add" at="N">The effect of specifying the type <code>xs:untyped</code> or
                        <code>xs:untypedAtomic</code> when validating by type is now defined.</p>
               </item>
               <item>
                  <p diff="add" at="Q">The set of constructs that set <termref
                        def="dt-temporary-output-state"/> has been reduced, and no longer includes
                     instructions that create nodes, such as <elcode>xsl:attribute</elcode> and
                        <elcode>xsl:value-of</elcode>. However, <elcode>xsl:merge-key</elcode> has
                     been added to the list.</p>
               </item>
               <item>
                  <p diff="add" at="Q">The possibilities for invocation of a stylesheet have been
                     expanded; they now include the ability to directly execute a stylesheet
                     function; to supply parameters to the initial template; and to return the
                     results of the invoked template or function as a raw value, without
                     construction of a result tree.</p>
               </item>
            </olist>
         </div2>
         <div2 id="xpath-changes-since-2.0">
            <head>Changes in Other Related Specifications</head>
            <p>A number of changes affecting XSLT 3.0 have been made in other related
               specifications. Some of the more significant changes are as follows:</p>
            <olist>
               <item>
                  <p>A number of new functions have been defined whose aim is to facilitate
                     streaming. These include <xfunction>unparsed-text-lines</xfunction>,
                        <xfunction>innermost</xfunction>, <xfunction>outermost</xfunction>.</p>
               </item>
               <item>
                  <p>XPath 3.0 supports a subset of the <code>let</code> expression from XQuery.</p>
               </item>
               <item>
                  <p>XPath 3.0 supports function items as first-class values (functions can, for
                     example, be bound to variables and passed as parameters to other
                     functions.)</p>
               </item>
               <item>
                  <p>XPath 3.0 supports a new syntax for writing expanded names using the namespace
                     URI and local part only, avoiding the need to create a static context that
                     binds namespace prefixes. This is intended to be particularly useful when XPath
                     expressions are software-generated. Complementing this, a new function
                        <xfunction>path</xfunction> is available to generate a
                     (namespace-context-independent) path to any node that can subsequently be
                     evaluated using the <elcode>xsl:evaluate</elcode> instruction, or
                     otherwise.</p>
               </item>
            </olist>
         </div2>
      </inform-div1>
      <inform-div1 id="changes-since-nov-2015" diff="add" at="T+">
         <head>Changes since the Candidate Recommendation of 19 November 2015</head>
         <p>This section contains a list of changes that were made between the first Candidate
            Recommendation in November 2015 and the second Candidate Recommendation in February
            2017. Design changes affecting the syntax or semantics of the XSLT language are marked
            (**). Minor changes to edge cases, and cases where rules have been supplied that were
            previously missing, are marked (*). Other changes may be considered editorial: these
            include corrections to examples, addition of non-normative notes, removal of ambiguities
            and inconsistencies, and textual clarifications. Changes that are purely typographical
            are not listed.</p>
         <olist>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29234"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: If
                  explicit packages are used, then the initial mode used when a stylesheet is
                  invoked (like an initial template or initial function) must now be declared as
                  public. (**)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29256"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Clarified
                  that it is an error for the top-level package to contain abstract components,
                  whether or not the components are referenced. (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29340"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>:
                  Streamability rules for XPath expressions now include the XPath 3.1 production
                  number as well as the XPath 3.0 production number.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29342"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: The
                  streamability rules for XPath 3.1 arrow expressions did not cover dynamic function
                  calls.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29351"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: An error
                  code has been allocated for the type error that occurs when
                     <code>xsl:evaluate/@with-params</code> is not a map, or is a map of the wrong
                  type. (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29392"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Defined
                  how support for the <xfunction>serialize</xfunction> function relates to the
                  optional <termref def="dt-serialization-feature"/>. (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29425"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: The
                  syntax summary now marks the <elcode>xsl:result-document</elcode> attributes
                     <code>method</code> and <code>json-node-output-method</code> as attribute value
                  templates, bringing it into line with the prose.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29431"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: The rules
                  for returning the principal and secondary results of a transformation, and in
                  particular the interaction of <code>build-tree</code> and
                     <code>item-separator</code>, have been clarified. (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29436"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: The list
                  of instructions in 5.7 that return the results of a contained sequence constructor
                  without alteration has been corrected and made non-normative.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29441"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: The term
                     <termref def="dt-extension-function"/> has been more carefully defined.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29442"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Part of
                  the text on evaluating <termref def="dt-sequence-constructor">sequence
                     constructors</termref> has been rewritten to improve clarity.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29445"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: The
                  summary of the rules for selecting a separator in <specref
                     ref="constructing-simple-content"/> has been made more complete.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29449"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: The
                  section on streamability of dynamic function calls now provides non-normative
                  advice on the use of this construct in conjunction with maps and arrays.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29453"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: An
                     <elcode>xsl:use-package</elcode> declaration may appear in an included
                  stylesheet module but not in an imported stylesheet module. (**)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29455"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Added to
                  the list of items that are considered empty (now <termref def="dt-vacuous"/>) by
                  the <elcode>xsl:on-empty</elcode> and <elcode>xsl:on-non-empty</elcode>
                  instructions, for example to include zero-length strings, and arrays consisting
                  entirely of vacuous items. (**)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29459"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Clarified
                  the rules for streamability of arrow expressions. (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29460"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: The
                  introduction to the concept of packages now mentions that an implementation might
                  allow packages to be written in other languages (for example, XQuery).</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29461"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Clarified
                  how the concept of “static base URI” should be interpreted in situations where the
                  source stylesheet is not available at execution time. (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29468"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Modified
                  the rules for the default visibility of overriding components. (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29473"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Removed a
                  misleading suggestion that the default visibility of overriding components is
                  always <code>private</code>; this is not the case for
                  <elcode>xsl:param</elcode>.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29474"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: There was
                  an incorrect suggestion that <code>xsl:original</code> could be used to refer to a
                  declaration overridden using the traditional mechanism of import precedence. This
                  has been removed.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29478"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: In
                  response to usability feedback, <elcode>xsl:expose</elcode> and
                     <elcode>xsl:accept</elcode> now allow the value <code>component="*"</code> to
                  mean “all kinds of component”. (**)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29480"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Defined
                  that the focus for evaluating attribute sets referenced by
                     <elcode>xsl:copy</elcode> is the same as the focus for evaluating the contained
                  sequence constructor (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29482"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: The
                  Working Group decided not to change the streamability rules to make a particular
                  use case involving <elcode>xsl:copy</elcode>
                  <termref def="dt-guaranteed-streamable"/>, but instead to add a note explaining
                  how to rewrite this use case in a streamable way.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29492"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>:
                  Simplified the rules for streamability of attribute sets. Attribute sets can no
                  longer be <termref def="dt-consuming"/>. (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29502"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: The
                  streamability rules for <elcode>xsl:fork</elcode> were incomplete for the case
                  where the instruction has an <elcode>xsl:for-each-group</elcode> child. (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29507"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Clarified
                  that a striding expression such as <code>(/a/b, $doc/a/b)</code> can deliver a mix
                  of streamed and unstreamed nodes and that the result is not necessarily in
                  document order.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29544"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Clarified
                  that whitespace stripping does not apply to the trees returned by functions such
                  as <xfunction>parse-xml</xfunction> and <xfunction>parse-xml-fragment</xfunction>.
                  (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29558"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: When the
                  namespace used for the XML representation of JSON was changed to
                     <code>http://www.w3.org/2005/xpath-functions</code>, one reference to the old
                  namespace was not updated.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29574"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: By
                  default a public component in a used package now becomes private in the using
                  package. This also affects the treatment of abstract components; as part of this
                  change, the keyword <code>visibility="absent"</code> is dropped. (**)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29588"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: In the
                     <function>xml-to-json</function> function, map keys are now compared after
                  normalizing escape sequences to determine whether duplicates exist. (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29602"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Changes
                  made to the <function>xml-to-json</function> in the XPath 3.1 project have been
                  retrofitted to this document. The changes include the detailed rules for escaping
                  special characters, and the adoption of uniform conventions for type-checking and
                  conversion of parameter options. (**)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29604"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Corrected
                  a throwaway remark in the text of an example concerning how to compute multiple
                  aggregate values in a single pass of the input.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29660"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: The
                  function <function>map:remove</function> can now remove multiple entries from a
                  map in a single call. (**)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29665"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: The
                     <function>xml-to-json</function> now escapes a solidus (<code>/</code> becomes
                     <code>\/</code>), which is useful when the resulting JSON is embedded in HTML.
                  (**)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29666"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Added a
                  note to clarify how the concept of stylesheet levels relates to packages.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29667"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Added a
                  note to confirm that it is not intrinsically an error to have two
                     <elcode>xsl:use-package</elcode> declarations that reference the same
                  package.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29669"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>:
                  Introductory material describing the XSLT processing model has been rewritten for
                  clarity.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29675"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: The rules
                  for determining the context item static type in a global variable declaration take
                  account of the declared type in the <elcode>xsl:global-context-item</elcode>
                  declaration if available. (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29686"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Clarified
                  the rules for compatibility of types when overriding functions. (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29690"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: The
                  requirement that a streaming processor should always use streaming if requested is
                  relaxed if for example (a) the input is supplied as a tree in memory, or (b) the
                  processor is able to determine that the input document is too small for streaming
                  to give any benefit.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29692"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Clarified
                  how stripping of type annotations and whitespace text nodes works when the rules
                  vary by package. (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29696"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: The
                     <termref def="dt-global-context-item"/> is not streamable. (**)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29697"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Clarified
                  where calls on <function>current-merge-group</function> and
                     <function>current-merge-key</function> can be used when
                     <elcode>xsl:merge</elcode> instructions are nested. (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29698"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Corrected
                  several mentions of the <code>streamable</code> attribute of
                     <elcode>xsl:merge</elcode>; the attribute actually appears on
                     <elcode>xsl:merge-source</elcode>.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29699"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Clarified
                  that for the purpose of error <code>XTSE3085</code>, only
                     <elcode>xsl:template</elcode> elements with a <code>match</code> attribute are
                  relevant. (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29709"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Some
                     <elcode>xsl:merge</elcode> examples used obsolete syntax from an earlier
                  working draft.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29710"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Used more
                  precise terminology in some of the rules defining the streamability of stylesheet
                  functions.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29712"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>:
                  Streamable stylesheet functions declared with streamability absorbing,
                  shallow-descent, or deep-descent now allow the function body to be motionless
                  (previously it had to be consuming). (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29716"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Defined
                  additional situations where the <termref def="dt-current-template-rule"/> is
                  cleared. (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29723"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: The
                     <code>map:merge</code> function takes a second argument to control how
                  duplicate keys are handled. (**)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29732"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: The rules
                  for streamable stylesheet functions have been refined. In most cases the argument
                  must now be a single node rather than a sequence of nodes, and constraints on the
                  variable reference have been rewritten as constraints on the function signature.
                  (**)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29733"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: An
                  example for an absorbing stylesheet function was correct, but the explanation for
                  why it was correct was misleading. </p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29738"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: The vague
                  term “streamable stylesheet” is no longer used. </p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29743"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: A new
                  function <code>map:find</code> is provided to allow recursive searching of nested
                  maps. (**)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29747"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: The
                     <code>xsl:stream</code> instruction has been generalized to handle both
                  streamed and unstreamed processing, and it has accordingly been renamed
                     <elcode>xsl:source-document</elcode>, and has a <code>streamable</code>
                  attribute. (**)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29752"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Improved
                  an example where accumulators are used to compute a word count, to give a more
                  realistic real-world result.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29763"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Added
                  rules concerning the effect of <elcode>xsl:expose</elcode> and
                     <elcode>xsl:accept</elcode> on <code>xsl:param</code> declarations (which are
                  always public). (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29768"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: The
                  operand usages for the <function>map:for-each</function> and
                     <function>map:merge</function> functions have been corrected (affecting the
                  streamability of these functions in the unusual case where the functions are
                  called with references to streamed nodes). (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29790"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: The
                  sample stylesheet for the <code>xml-to-json</code> function has been changed to
                  avoid using a reserved namespace.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29793"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Added a
                  note confirming that the <code>input-type-annotations</code> attribute has no
                  effect on an <elcode>xsl:source-document</elcode> instruction when the
                     <code>type</code> or <code>validation</code> attributes are present.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29796"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: A note
                  has been added pointing out that keys only allow searching within a tree that is
                  rooted at a document node.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29802"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Clarified
                  the text describing the function of the <termref def="dt-global-context-item"
                  />.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29803"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Having
                  been dropped from <elcode>xsl:global-context-item</elcode>, the ability to control
                  which accumulators are used on the initial match selection has been moved to
                     <elcode>xsl:mode</elcode>. (**)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29804"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: The
                     <code>for-each-stream</code> attribute of <elcode>xsl:merge-source</elcode> has
                  been generalized to handle both streamed and unstreamed processing, and it has
                  accordingly been renamed <code>for-each-source</code>; streaming of the merge
                  input is controlled using the <code>streamable</code> attribute. (**)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29805"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: The
                     <code>use-accumulators</code> attribute of <elcode>xsl:source-document</elcode>
                  now applies whether or not the instruction is declared streamable. (**)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29811"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Clarified
                  what error code should be used for a particular error involving static variables.
                  (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29813"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: A section
                  has been added explaining how to handle dynamic errors that occur during the
                  evaluation of accumulators. (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29814"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Clarified
                  that XPath comments can appear (only) in attributes of type expression, pattern,
                  item-type, or sequence-type. (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29819"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Dropped
                  the use of the term “core functions” in favour of more precise wording.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29827"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Clarified
                  the rules defining which modes are eligible to be used as the <termref
                     def="dt-initial-mode"/> when a stylesheet is first invoked. (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29853"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: The
                  result of the <function>collation-key</function> function is now always
                     <code>xs:base64Binary</code>, making the comparison semantics unambiguous and
                  context-independent. (**)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29865"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: A new
                  parameter <code>maxVariable</code> is added to UCA collation URIs, to define which
                  groups of characters (such as whitespace and punctuation) are ignored, or treated
                  as less significant, when comparing strings. In addition, interoperable defaults
                  are defined for most of the collation parameters. (**)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29860"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>, <loc
                     xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29861" xlink:type="simple"
                     xlink:show="replace" xlink:actuate="onRequest"/>, <loc
                     xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29862" xlink:type="simple"
                     xlink:show="replace" xlink:actuate="onRequest"/>, <loc
                     xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29865" xlink:type="simple"
                     xlink:show="replace" xlink:actuate="onRequest"/>: Fixed errors in the schema
                  for XSLT 3.0 stylesheets resulting from changes logged elsewhere, notable the
                  renaming of <code>xsl:stream</code> to <elcode>xsl:source-document</elcode>.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29866"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Changed
                  the definition of type <code>EQName</code> in the schema for XSLT 3.0 stylesheets
                  to be more restrictive.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29880"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>:
                  Implementations may impose limits on the values used in a package version number,
                  and minimum values for those limits have been defined. (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29887"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Changed
                  an assertion against <elcode>xsl:for-each-group</elcode> in the schema for XSLT
                  3.0 stylesheets to be allow for the possibility of shadow attributes. (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29889"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Added an
                  introductory section concerning streaming of non-XML data.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29917"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: The
                     <function>xml-to-json</function> function now allows the top-level element of
                  the input to have a <code>key</code> attribute (which is ignored), so that it can
                  successfully process any subtree of the output of <code>json-to-xml</code>.
                  (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29919"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: A
                     <code>use-when</code> attribute on <elcode>xsl:package</elcode> works the same
                  way as on <elcode>xsl:stylesheet</elcode> and <elcode>xsl:transform</elcode>.
                  (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29920"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: The rules
                  for shadow attributes have been rewritten to avoid using the undefined term
                     <emph>target attribute</emph>.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29927"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Clarified
                  that facilities for disabling <elcode>xsl:evaluate</elcode> are
                  implementation-defined.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29933"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: In line
                  with other serialization parameters, the detail of what
                     <code>undeclare-prefixes</code> does is now delegated to the serialization
                  specification.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29960"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>:
                  Processors are now allowed to provide a mode of operation in which there is no
                  requirement to report static errors in code that is never executed. (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29975"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Added a
                  non-normative summary of the rules affecting validation of <code>xml:id</code>
                  attributes.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29978"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Rules
                  relating the the permitted children of <elcode>xsl:stylesheet</elcode> apply also
                  to <elcode>xsl:package</elcode>. (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29980"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Editorial
                  improvements to the definition of error XTSE0760. (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29981"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Relaxed
                  the rule requiring the tunnel parameters on an overriding template to be identical
                  to those on the overridden template. (**)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29982"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Expanded
                  the note explaining the rationale and use cases for tunnel parameters.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29983"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: The
                  justification and explanation for the streamability of <emph>scanning
                     expression</emph> such as <code>//section/head</code> has been rewritten for
                  clarity; and the term itself is now defined in terms of the rules for
                     <emph>motionless patterns</emph> since the two concepts are very closely
                  aligned. (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug29988"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Clarified
                  that in the <code>xs:QName</code> values returned by
                     <function>available-system-properties</function>, the prefix part of the QName
                  is implementation-dependent.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug30002"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Rectified
                  the omission of <code>xsl:function/@cache</code> in the schema for XSLT 3.0.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug30032"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Refined
                  the static typing rules for axis steps to take account of the axis as well as the
                  node test. (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug30033"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Refined
                  the rules for streamability of the <function>current</function> function. (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug30034"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Corrected
                  a note concerning the streamability of <elcode>xsl:choose</elcode> to match the
                  normative rules.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug30036"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>:
                     <code>document-node(E)</code> sequence type tests cause streaming difficulties
                  for <code>treat as</code> expressions just as they do for <code>instance of</code>
                  expressions. (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug30049"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Supplied
                  missing rules regarding the dynamic context for evaluation of XPath expressions
                  (both static expressions and expressions evaluated using
                     <elcode>xsl:evaluate</elcode>), especially as regards the named functions
                  available in the dynamic context for <xfunction>function-lookup</xfunction>.
                  (*)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug30056"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Corrected
                  the expected output of an example of streamed grouping.</p>
            </item>
         </olist>
         <p>A non-normative Relax NG schema for XSLT 3.0 has been added to <specref
               ref="schema-for-xslt"/>.</p>
      </inform-div1>
      <inform-div1 id="changes-since-feb-2017" diff="add" at="U">
         <head>Changes since the Candidate Recommendation of 7 February 2017</head>
         <p>This section contains a list of changes that have been made. Trivial typographic errors
            and changes to non-normative front and back matter are not listed.</p>
         <olist>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug30060"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: An
                  example purporting to show streamable use of <elcode>xsl:iterate</elcode> was not
                  in fact guaranteed-streamable, and has been corrected by injecting a call of the
                     <function>copy-of</function> function.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug30064"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: Added a
                  Note to explain why certain path expressions (such as
                  <code>.//section/head</code>) are not guaranteed-streamable.</p>
            </item>
         </olist>
      </inform-div1>
      <inform-div1 id="changes-since-apr-2017" diff="add" at="V">
         <head>Changes since the Proposed Recommendation of 18 April 2017</head>
         <p>This section contains a list of changes that have been made. Trivial typographic errors
            and changes to non-normative front and back matter are not listed.</p>
         <olist>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug30089"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: A
                  non-normative note in 2.3.6.1 wrongly stated that serializing an array would raise
                  an error. The serialization specification is clear that this is not the case.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug30090"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: A
                  non-normative note in 3.2 referred to the "four standard serialization methods".
                  With the 3.1 version of the serialization specification, there are now six
                  standard methods.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug30091"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: A
                  non-normative note in 3.5.4 advised users to solve a particular problem by using
                  the instruction <code>&lt;xsl:apply-templates/&gt;</code>. Better advice would be
                  to use <code>&lt;xsl:apply-templates select="."/&gt;</code></p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug30093"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: An
                  example in <specref ref="pattern-examples"/> (carried over unchanged from the XSLT
                  2.0 specification) gave incorrect semantics for the pattern
                  <code>//para</code>.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug30094"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: In
                     <specref ref="variables"/> the term <code>local variable</code> is used. The
                  definition of this term appears in <specref ref="local-variables"/>. But rather
                  than linking to the definition, the former section gave an incomplete explanation
                  of its meaning.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug30095"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: In
                     <specref ref="scope-of-variables"/>, the scope of global variables was
                  described without making clear that the discussion was in the context of a single
                  package; a note has been added explaining that the rules for cross-package
                  visibility are defined elsewhere.</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug30099"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: In the
                  proforma for the <code>start-at</code> attribute of <elcode>xsl:number</elcode>
                  (appearing in both section 12 and Appendix D), the type of the attribute was given
                  as <code>integer</code> although the normative description of the syntax and
                  semantics of the attribute makes clear that a whitespace-separated sequence of
                  integers is permitted. (For technical reasons this change is not
                  color-highlighted.)</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug30100"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: A
                  non-normative note in section 27.4 referred to version "3.0", in a context that
                  made no sense unless this is read as version "2.0".</p>
            </item>
            <item>
               <p><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="bug30109"
                     xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>: A
                  non-normative note has been added to explain that as a consequence of the general
                  rules for constructing simple content, the <code>disable-output-escaping</code>
                  attribute has no effect when writing attributes, comments or processing
                  instructions.</p>
            </item>
         </olist>
      </inform-div1>
      <inform-div1 id="incompatibilities" diff="add" at="E">
         <head>Incompatibilities with XSLT 2.0</head>
         <p>This section lists all known incompatibilities with XSLT 2.0, that is, situations
               <phrase diff="chg" at="R-bug24078">where</phrase> a stylesheet that is error-free
            according to the XSLT 2.0 specification and where all elements have an effective version
            of <code>2.0</code> or less, will produce different results depending on whether it is
            run under an XSLT 2.0 processor or an XSLT 3.0 processor.</p>
         <olist>
            <item>
               <p>XSLT 2.0 gave implementations freedom what to do when a node selected by
                     <elcode>xsl:apply-templates</elcode> matched more than one <termref
                     def="dt-template-rule"/>. XSLT 3.0 is more prescriptive in this situation. The
                  behavior prescribed in XSLT 3.0 (selecting the template rule that is last in
                     <termref def="dt-declaration-order"/>) is compatible with the action of some
                  XSLT 2.0 processors but not necessarily others.</p>
            </item>
            <item>
               <p> It is now a static error if the same <code>NameTest</code> appears in both an
                     <elcode>xsl:strip-space</elcode> and an <elcode>xsl:preserve-space</elcode>
                  declaration with the same precedence and priority. Previously this was a dynamic
                  error, and processors were allowed to recover from the error. </p>
            </item>
            <item>
               <p diff="add" at="K"> The current group and current grouping key are now absent
                  rather than empty when not in use, which means that attempting to refer to them in
                  this state gives a dynamic error. </p>
            </item>
            <item>
               <p diff="add" at="L"> As a consequence of functions such as
                     <xfunction>format-date</xfunction> moving from this specification to <bibref
                     ref="xpath-functions-30"/>, error codes associated with these functions have
                  changed. </p>
            </item>
            <item>
               <p diff="add" at="M"> The concept of recoverable dynamic errors has been dropped. Of
                  the remaining recoverable dynamic errors, some are no longer errors, and others
                  are now situations where the behavior of the processor is <termref
                     def="dt-implementation-dependent"/>. Error codes of the form
                     <code>XTREnnnn</code> have been renumbered <code>XTDEnnnn</code>. </p>
            </item>
            <item>
               <p diff="add" at="N"> In previous versions of the specification, the
                     <function>element-available</function> function when applied to names in the
                  XSLT namespace was defined to return <code>false</code> in the case of XSLT
                  elements other than instructions. (Actual practice in implementations was not
                  always consistent with this rule). In XSLT 3.0 the rules have been changed so that
                  it returns <code>true</code> for the names of such elements, bringing the
                  specification of the function into line with the intuitive meaning of its name.
               </p>
            </item>
            <item>
               <p diff="add" at="N"> (This is not strictly speaking an incompatibility, as
                  conforming XSLT 2.0 stylesheets will continue to function correctly without error.
                  It can be considered as migration advice, a warning that care is needed when
                  introducing new XSLT 3.0 features.)</p>
               <p diff="add" at="N"> When a function or template has a parameter with a declared
                  type of <code>item()</code>, it should not assume (as it could in XSLT 2.0) that
                  when the supplied item is not a node, it must be an atomic value, and vice versa.
                  In XSLT 3.0 there is a third option: it might be a function. Functions and
                  templates that fail to cater for this possibility may fail with a type error if
                  the caller supplies a function as the relevant parameter value. </p>
            </item>
            <item>
               <p diff="add" at="R-bug9927"> XSLT 1.0 and 2.0 required the
                     <code>grouping-size</code> attribute of <elcode>xsl:number</elcode> to be a
                     <term>number</term> (a term which in other contexts was defined to mean any
                  decimal value), but no interpretation was provided for non-integer values. XSLT
                  3.0 requires the value to be an integer. </p>
            </item>
            <item>
               <p diff="add" at="S+">In XPath 3.0, the rules for matching node tests of the form
                     <code>element(*, U)</code> or <code>attribute(*, U)</code> have changed in the
                  case where <code>U</code> is a union type. Specifically, an element or attribute
                  whose type annotation is a member type of <code>U</code> will now match such a
                  node test, whereas in XPath 2.0 it did not. Since the semantics of XSLT pattern
                  matching are based on the XPath rules for matching node tests, this change affects
                  which template rules are chosen to match a node when the match patterns use one of
                  these forms.</p>
            </item>
            <item>
               <p diff="add" at="S-bug26965">The handling of XSLT version numbers that do not
                  correspond to any published specification has changed. An example is
                     <code>version="1.1"</code> (which is sometimes encountered because it was used
                  in examples in a popular book). XSLT 2.0 requires processors to treat all values
                  less than 2.0 as if 1.0 were specified. XSLT 3.0 recommends that processors reject
                  such a value as a static error.</p>
            </item>
            <item>
               <p diff="add" at="S-bug29081">XSLT 3.0 disallows the use of certain <termref
                     def="dt-reserved-namespace">reserved namespaces</termref> in extension
                  functions and extension instructions, and in the
                     <code>[xsl:]extension-element-prefixes</code> attribute.</p>
               <note diff="add" at="S-bug29081">
                  <p>For example, it becomes an error to write
                        <code>extension-element-prefixes="xs"</code> where the prefix
                        <code>xs</code> is bound to the XML Schema namespace. Such an attribute is
                     occasionally seen where <code>exclude-result-prefixes</code> was probably
                     intended.</p>
               </note>
            </item>
         </olist>
      </inform-div1>
   </back>
</spec>
