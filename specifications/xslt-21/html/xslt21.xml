<!--XSLT Processor: SAXON 6.5.3 from Michael Kay--><!-- 
   Review comments cycle leading up to 23 April 2010 is draft F.
--><spec xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax" xmlns:t="http://www.w3.org/2008/XSL/Spec/TreeDiagram" xmlns:g="http://www.martin-loetzsch.de/DOTML" w3c-doctype="wd" status="int-review">
   <header>
      <title>XSL Transformations (XSLT)</title> 
      <version>Version 2.1</version>
      <w3c-designation>WD-****</w3c-designation>
      <w3c-doctype>W3C Working Draft</w3c-doctype>
      <pubdate>
         <!-- The value from the stylesheet xslt.xsl is used in preference -->
         <day>23</day>
         <month>April</month>
         <year>2010</year>
      </pubdate> 
      <publoc>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/yyyy/WD-xslt-21-yyyymmdd/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/yyyy/WD-xslt-21-yyyymmdd/</loc>
      </publoc>
      <!--<altlocs>
		    <loc href="Overview-diff.html">HTML with revision markings</loc>
		    <loc href="http://www.w3.org/2007/schema-for-xslt20.xsd">Schema for XSLT 2.0 stylesheets</loc>
		</altlocs>-->
      <latestloc>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/xslt-21/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
      </latestloc>
      <!--<prevlocs>
         <loc href="http://www.w3.org/TR/2007/REC-xslt20-20070123/"
            >http://www.w3.org/TR/2007/REC-xslt20-20070123/</loc>
      </prevlocs>-->
      <authlist>
         <author>
            <name>Michael Kay</name>
            <affiliation>Saxonica</affiliation>
            <email xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.saxonica.com/" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">http://www.saxonica.com/</email>
         </author>
      </authlist>
      <errataloc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/2010/qt-errata/xslt-21-errata.html" xlink:type="simple"/>
      <translationloc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2003/03/Translations/byTechnology?technology=xslt-21" xlink:type="simple"/>
      <status diff="chg" at="D">
         <p><emph>This section describes the status of this document at the time of its publication.
               Other documents may supersede this document. A list of current W3C publications and
               the latest revision of this technical report can be found in the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">W3C technical reports index.</loc></emph></p>
         <p>This is a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2005/10/Process-20051014/tr.html#first-wd" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">First
               Public Working Draft</loc> as described in the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2005/10/Process-20051014/tr.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/> process document. It has
            been developed by the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Style/XSL/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">W3C W3C XSL Working
               Group</loc>, which is part of the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Activity" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML
               Activity</loc>. The Working Group expects to advance this specification to <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2005/10/Process-20051014/tr.html#RecsW3C" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Recommendation</loc> Status.</p>

         <p>This specification has been developed in conjunction with <bibref ref="xpath-21"/> and
            other documents that underpin both XSLT and XQuery. Although the development of this
            family of documents is coordinated, it has not been possible on this occasion to publish
            them simultaneously, and there may therefore be imperfect technical alignment between
            them. This will be corrected in later drafts.</p>

         <p>There are many open issues in this draft, as well as uncompleted editorial work; known
            instances are flagged in the form of editorial notes. Where these relate to technical
            issues, feedback from readers will be especially welcome.</p>

         <p>Please report errors in this document using W3C's <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public Bugzilla system</loc> (instructions can
            be found at <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/2005/04/qt-bugzilla" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>). If access to that
            system is not feasible, you may send your comments to the W3C XSLT/XPath/XQuery public
            comments mailing list, <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:public-qt-comments@w3.org" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public-qt-comments@w3.org</loc>. It will be very helpful if you include the string
            "[XSLT21]" in the subject line of your report, whether made in Bugzilla or in email.
            Please use multiple Bugzilla entries (or, if necessary, multiple email messages) if you
            have more than one comment to make. Archives of the comments and responses are available
            at <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://lists.w3.org/Archives/Public/public-qt-comments/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>.</p>

         <p> Publication as a Working Draft does not imply endorsement by the W3C Membership. This
            is a draft document and may be updated, replaced or obsoleted by other documents at any
            time. It is inappropriate to cite this document as other than work in progress. </p>
         <p>This document was produced by a group operating under the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">5 February 2004 W3C
               Patent Policy</loc>. W3C maintains a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/01/pp-impl/19552/status#disclosures" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public list of any
               patent disclosures</loc> made in connection with the deliverables of the XSL Working
            Group; those pages also include instructions for disclosing a patent. An individual who
            has actual knowledge of a patent which the individual believes contains <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Essential
               Claim(s)</loc> must disclose the information in accordance with <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">section 6
               of the W3C Patent Policy</loc>. </p>
         <p>For a list of changes, see <specref ref="changes-since-2.0"/>.</p>
      </status>
      <abstract diff="chg" at="D">
         <p>This specification defines the syntax and semantics of XSLT <phrase diff="chg" at="A">2.1</phrase>, a language for transforming XML documents into other XML
            documents.</p>
         <p>XSLT 2.1 is a revised version of the XSLT 2.0 Recommendation <bibref ref="xslt20"/>
            published on 23 January 2007.</p>
         <p>The primary purpose of the changes in this version of the language is to enable
            transformations to be performed in streaming mode, where neither the source document nor
            the result document is ever held in memory in its entirety.</p>
         <p>XSLT 2.1 is designed to be used in conjunction with XPath 2.1, which is defined in
               <bibref ref="xpath-21"/>. XSLT shares the same data model as XPath 2.1, which is
            defined in <bibref ref="xpath-datamodel-11"/>, and it uses the library of functions and
            operators defined in <bibref ref="xpath-functions-11"/>. XPath 2.1 and the underlying
            function library introduce a number of enhancements, for example the availability of
            higher-order functions. Some of the functions that were previously defined in <phrase diff="chg" at="F">the XSLT 2.0</phrase> specification, such as the
               <code>format-date</code> and <code>format-number</code> functions, are now defined in
            the standard function library to make them available to other host languages.</p>
         <p>XSLT 2.1 also includes optional facilities to serialize the results of a transformation,
            by means of an interface to the serialization component described in <bibref ref="xslt-xquery-serialization-11"/>.</p>
         <p>
            <emph>This document contains hyperlinks to specific sections or definitions within other
               documents in this family of specifications. These links are indicated visually by a
               superscript identifying the target specification: for example XP for XPath, DM for
               the XDM data model, FO for Functions and Operators.</emph>
         </p>
      </abstract>
      <langusage>
         <language id="EN">English</language>
      </langusage>
      <revisiondesc>
         <slist>
            <sitem>((not used)).</sitem>
         </slist>
      </revisiondesc>
   </header>
   <body>
      <div1 id="introduction">
         <head>Introduction</head>
         <div2 id="what-is-xslt">
            <head>What is XSLT?</head>
            <p>This specification defines the syntax and semantics of the XSLT <phrase diff="chg" at="A">2.1</phrase> language.</p>
            <p>
               <termdef id="dt-stylesheet" term="stylesheet">A transformation in the XSLT language
                  is expressed in the form of a <term>stylesheet</term>, whose syntax is well-formed
                  XML <bibref ref="REC-xml"/> conforming to the Namespaces in XML Recommendation
                     <bibref ref="xml-names"/>.</termdef>
            </p>
            <p>A stylesheet generally includes elements that are defined by XSLT as well as elements
               that are not defined by XSLT. XSLT-defined elements are distinguished by use of the
               namespace <code>http://www.w3.org/1999/XSL/Transform</code> (see <specref ref="xslt-namespace"/>), which is referred to in this specification as the
                  <termref def="dt-xslt-namespace">XSLT namespace</termref>. Thus this specification
               is a definition of the syntax and semantics of the XSLT namespace.</p>
            <p>The term <termref def="dt-stylesheet">stylesheet</termref> reflects the fact that one
               of the important roles of XSLT is to add styling information to an XML source
               document, by transforming it into a document consisting of XSL formatting objects
               (see <bibref ref="xsl11"/>), or into another presentation-oriented format such as HTML,
               XHTML, or SVG. However, XSLT is used for a wide range of transformation tasks, not
               exclusively for formatting and presentation applications.</p>
            <p>A transformation expressed in XSLT describes rules for transforming zero or more
               source trees into one or more result trees. The structure of these trees is described
               in <bibref ref="xpath-datamodel-11"/>. The transformation is achieved by a set of
                  <termref def="dt-template-rule">template rules</termref>. A template rule
               associates a <termref def="dt-pattern">pattern</termref>, which matches nodes in the
               source document, with a <termref def="dt-sequence-constructor">sequence
                  constructor</termref>. In many cases, evaluating the sequence constructor will
               cause new nodes to be constructed, which can be used to produce part of a result
               tree. The structure of the result trees can be completely different from the
               structure of the source trees. In constructing a result tree, nodes from the source
               trees can be filtered and reordered, and arbitrary structure can be added. This
               mechanism allows a <termref def="dt-stylesheet">stylesheet</termref> to be applicable
               to a wide class of documents that have similar source tree structures.</p>
            <p>
               <termdef id="dt-principal-stylesheet-module" term="principal stylesheet module">A
                     <termref def="dt-stylesheet">stylesheet</termref> may consist of several
                     <termref def="dt-stylesheet-module">stylesheet modules</termref>, contained in
                  different XML documents. For a given transformation, one of these functions as the
                     <term>principal stylesheet module</term>. The complete <termref def="dt-stylesheet">stylesheet</termref> is assembled by finding the <termref def="dt-stylesheet-module">stylesheet modules</termref> referenced directly or
                  indirectly from the principal stylesheet module using <elcode>xsl:include</elcode>
                  and <elcode>xsl:import</elcode> elements: see <specref ref="include"/> and
                     <specref ref="import"/>.</termdef>
            </p>
         </div2>
         <div2 id="whats-new-in-xslt2" diff="add" at="D">
            <head>What's New in XSLT 2.1?</head>
            <p>The main focus for enhancements in XSLT 2.1 is the requirement to enable streaming
               of source documents. This is needed when source documents become too large
               to hold in main memory, and also for applications where it is important to start
               delivering results before the entire source document is available.</p>
            <p>While implementations of XSLT that use streaming have always been theoretically possible, the
               nature of the language has made it very difficult to achieve this in practice. The
               approach adopted in this specification is twofold: it identifies a set of
               restrictions which, if followed by stylesheet authors, will enable implementations to
               adopt a streaming mode of operation without placing excessive demands on the
               optimization capabilities of the processor; and it provides new constructs to
               indicate that streaming is required, or to express transformations in a way
               that makes it easier for the processor to adopt a streaming execution plan.</p>
            <p>Capabilities provided in this category include:</p>
            <ulist>
               <item>
                  <p>A new <elcode>xsl:stream</elcode> instruction, which reads and processes a
                     source document in streaming mode;</p>
               </item>
               <item>
                  <p>The ability to declare that a <termref def="dt-mode">mode</termref> is a
                     streaming mode, in which case all the template rules using that mode must be
                     streamable;</p>
               </item>
               <item>
                  <p>A new <elcode>xsl:iterate</elcode> instruction, which iterates over the items
                     in a sequence, allowing parameters for the processing of one item to be set
                     during the processing of the previous item;</p>
               </item>
               <item>
                  <p>A new <elcode>xsl:merge</elcode> instruction, allowing multiple input streams
                     to be merged into a single output stream;</p>
               </item>
               <item>
                  <p>A new <elcode>xsl:fork</elcode> instruction, allowing multiple computations to
                     be performed in parallel during a single pass through an input document.</p>
               </item>
            </ulist>
            <p>Other significant features in XSLT 2.1 include:</p>
            <ulist>
               <item>
                  <p>An <elcode>xsl:evaluate</elcode> instruction allowing evaluation of XPath
                     expressions that are dynamically constructed as strings, or that are read from
                     a source document;</p>
               </item>
               <item>
                  <p>Enhancements to the syntax of <termref def="dt-pattern">patterns</termref>, in
                     particular enabling the matching of atomic values as well as nodes;</p>
               </item>
               <item>
                  <p>An <elcode>xsl:try</elcode> instruction to allow recovery from dynamic
                     errors;</p>
               </item>
               <item>
                  <p>The element <elcode>xsl:context-item</elcode>, used to declare the stylesheet's
                     expectations of the initial context item (notably, its type), given the initial
                     mode.</p>
               </item>
            </ulist>
            <p>XSLT 2.1 also delivers enhancements made to the XPath language and to the standard
               function library, including the following:</p>
            <ulist>
               <item>
                  <p>Variables can now be bound in XPath using the <code>let</code> expression.</p>
               </item>
               <item>
                  <p>Functions are now first class values, and can be passed as arguments to other
                     (higher-order) functions, making XSLT a fully-fledged functional programming
                     language.</p>
               </item>
               <item>
                  <p>A number of new functions are available, for example trigonometric functions,
                     and the functions <xfunction>parse</xfunction> and
                        <xfunction>serialize</xfunction> to convert between lexical and tree
                     representations of XML.</p>
               </item>
            </ulist>
            <p>The XSL Working Group is designing other new features which it hopes to include in
               the final XSLT 2.1 Recommendation, but which are not yet advanced enough to include
               in this Working Draft.</p>
            <p diff="add" at="E">A full list of changes is at <specref ref="changes-since-2.0"/>.</p>
         </div2>
      </div1>
      <div1 id="concepts">
         <head>Concepts</head>
         <div2 id="terminology">
            <head>Terminology</head>
            <p>For a full glossary of terms, see <specref ref="glossary"/>.</p>
            <p>
               <termdef id="dt-processor" term="processor">The software responsible for transforming
                  source trees into result trees using an XSLT stylesheet is referred to as the
                     <term>processor</term>. This is sometimes expanded to <emph>XSLT
                     processor</emph> to avoid any confusion with other processors, for example an
                  XML processor.</termdef>
            </p>
            <p>
               <termdef id="dt-implementation" term="implementation">A specific product that
                  performs the functions of an <termref def="dt-processor">XSLT processor</termref>
                  is referred to as an <term>implementation</term>.
               </termdef></p>
            <p>
               <termdef id="dt-result-tree" term="result tree">The term <term>result tree</term> is
                  used to refer to any tree constructed by <termref def="dt-instruction">instructions</termref> in the stylesheet. A result tree is either a <termref def="dt-final-result-tree">final result tree</termref> or a <termref def="dt-temporary-tree">temporary tree</termref>.</termdef>
            </p>
            <p>
               <termdef id="dt-final-result-tree" term="final result tree">A <term>final result
                     tree</term> is a <termref def="dt-result-tree">result tree</termref> that forms
                  part of the final output of a transformation. Once created, the contents of a
                  final result tree are not accessible within the stylesheet itself.</termdef> The
                  <elcode>xsl:result-document</elcode> instruction always creates a final result
               tree, and a final result tree may also be created implicitly by the <termref def="dt-initial-template">initial template</termref>. The conditions under which
               this happens are described in <specref ref="executing-a-transformation"/>. A final
               result tree <rfc2119>may</rfc2119> be serialized as described in <specref ref="serialization"/>.</p>
            <p>
               <termdef id="dt-source-tree" term="source tree">The term <term>source tree</term>
                  means any tree provided as input to the transformation. This includes the document
                  containing the <phrase diff="chg" at="E"><termref def="dt-initial-context-item"/></phrase> if any, documents containing nodes supplied as the values of
                     <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>,
                  documents obtained from the results of functions such as
                     <function>document</function>, <xfunction>doc</xfunction>, and
                     <xfunction>collection</xfunction>, <phrase diff="add" at="C">documents read
                     using the <elcode>xsl:stream</elcode> instruction,</phrase> and documents
                  returned by extension functions or extension instructions. In the context of a
                  particular XSLT instruction, the term <term>source tree</term> means any tree
                  provided as input to that instruction; this may be a source tree of the
                  transformation as a whole, or it may be a <termref def="dt-temporary-tree">temporary tree</termref> produced during the course of the
                  transformation.</termdef>
            </p>
            <p>
               <termdef id="dt-temporary-tree" term="temporary tree">The term <term>temporary
                     tree</term> means any tree that is neither a <termref def="dt-source-tree">source tree</termref> nor a <termref def="dt-final-result-tree">final result
                     tree</termref>.</termdef> Temporary trees are used to hold intermediate results
               during the execution of the transformation.</p>
            <p diff="add" at="C">The use of the term "tree" in phrases such as <term>source
                  tree</term>, <term>result tree</term>, and <term>temporary tree</term> is not
               confined to documents that the processor materializes in memory in their entirety.
               The processor <rfc2119>may</rfc2119>, and in some cases <rfc2119>must</rfc2119>, use
               streaming techniques to limit the amount of memory used to hold source and result
               documents. When streaming is used, the nodes of the tree may never all be in memory
               at the same time, but at an abstract level the information is still modeled as a tree
               of nodes, and the document is therefore still described as a tree.</p>
            <p>In this specification the phrases <rfc2119>must</rfc2119>, <rfc2119>must
                  not</rfc2119>, <rfc2119>should</rfc2119>, <rfc2119>should not</rfc2119>,
                  <rfc2119>may</rfc2119>, <rfc2119>required</rfc2119>, and
                  <rfc2119>recommended</rfc2119>, 
               <phrase diff="add" at="F">when used in normative text and rendered in capitals,</phrase>
               are to be interpreted as described in <bibref ref="RFC2119"/>.</p>
            <p>Where the phrase <rfc2119>must</rfc2119>, <rfc2119>must not</rfc2119>, or
                  <rfc2119>required</rfc2119> relates to the behavior of the XSLT processor, then an
               implementation is not conformant unless it behaves as specified, subject to the more
               detailed rules in <specref ref="conformance"/>. </p>
            <p>Where the phrase <rfc2119>must</rfc2119>, <rfc2119>must not</rfc2119>, or
                  <rfc2119>required</rfc2119> relates to a stylesheet then the processor
                  <rfc2119>must</rfc2119> enforce this constraint on stylesheets by reporting an
               error if the constraint is not satisfied.</p>
            <p>Where the phrase <rfc2119>should</rfc2119>, <rfc2119>should not</rfc2119>, or
                  <rfc2119>recommended</rfc2119> relates to a stylesheet then a processor
                  <rfc2119>may</rfc2119> produce warning messages if the constraint is not
               satisfied, but <rfc2119>must not</rfc2119> treat this as an error.</p>
            <p>
               <termdef id="dt-implementation-defined" term="implementation-defined">In this
                  specification, the term <term>implementation-defined</term> refers to a feature
                  where the implementation is allowed some flexibility, and where the choices made
                  by the implementation <rfc2119>must</rfc2119> be described in documentation that
                  accompanies any conformance claim.</termdef>
            </p>
            <p>
               <termdef id="dt-implementation-dependent" term="implementation-dependent">The term
                     <term>implementation-dependent</term> refers to a feature where the behavior
                     <rfc2119>may</rfc2119> vary from one implementation to another, and where the
                  vendor is not expected to provide a full specification of the behavior.</termdef>
               (This might apply, for example, to limits on the size of source documents that can be
               transformed.)</p>
            <p>In all cases where this specification leaves the behavior implementation-defined or
               implementation-dependent, the implementation has the option of providing mechanisms
               that allow the user to influence the behavior.</p>
            <p>A paragraph labeled as a <term>Note</term> or described as an <term>example</term> is
               non-normative.</p>
            <p>Many terms used in this document are defined in the XPath specification <bibref ref="xpath-21"/> or the XDM specification <bibref ref="xpath-datamodel-11"/>.
               Particular attention is drawn to the following:</p>
            <ulist>
               <item>
                  <p>
                     <termdef id="dt-atomization" term="atomize">The term <term>atomization</term>
                        is defined in <!--<bibref ref="xpath-21"/>--><xspecref spec="XP21" ref="id-atomization"/>. It is a process that takes as input a sequence of
                           <phrase diff="chg" at="C">items</phrase>, and returns a sequence of
                        atomic values, in which the nodes are replaced by their typed values as
                        defined in <bibref ref="xpath-datamodel-11"/>.</termdef> For some <phrase diff="chg" at="C">items</phrase> (for example, elements with element-only
                     content, <phrase diff="add" at="C">and function items</phrase>), atomization
                     generates a <termref def="dt-dynamic-error">dynamic error</termref>.</p>
               </item>
               <item>
                  <p>
                     <termdef id="dt-typed-value" term="typed value">The term <term>typed
                           value</term> is defined in <xspecref spec="DM11" ref="dm-typed-value"/>.
                        Every node except an element defined in the schema with element-only content
                        has a <termref def="dt-string-value">typed value</termref>. For example, the
                           <termref def="dt-typed-value">typed value</termref> of an attribute of
                        type <code>xs:IDREFS</code> is a sequence of zero or more
                           <code>xs:IDREF</code> values.</termdef>
                  </p>
               </item>
               <item>
                  <p>
                     <termdef id="dt-string-value" term="string value">The term <term>string
                           value</term> is defined in
                           <!--<bibref ref="xpath-datamodel-11"/>--><xspecref spec="DM11" ref="dm-string-value"/>. Every node has a <termref def="dt-string-value">string value</termref>. For example, the <termref def="dt-string-value">string value</termref> of an element is the concatenation of the
                           <termref def="dt-string-value">string values</termref> of all its
                        descendant text nodes.</termdef>
                  </p>
               </item>
               <item>
                  <p>
                     <termdef id="dt-xpath-compat-mode" term="XPath 1.0 compatibility mode">The term
                           <term>XPath 1.0 compatibility mode</term> is defined in <xspecref spec="XP21" ref="static_context"/>. This is a setting in the static
                        context of an XPath expression; it has two values, <code>true</code> and
                           <code>false</code>. When the value is set to true, the semantics of
                        function calls and certain other operations are adjusted to give a greater
                        degree of backwards compatibility between <phrase diff="chg" at="D">XPath
                           2.1</phrase> and XPath 1.0.</termdef>
                  </p>


               </item>
            </ulist>
            <p>
               <termdef id="dt-core-function" term="core function">The term <term>core
                     function</term> means a function that is specified in <bibref ref="xpath-functions-11"/> and that is in the <termref def="dt-standard-function-namespace">standard function
                  namespace</termref>.</termdef>
            </p>
         </div2>
         <div2 id="notation">
            <head>Notation</head>
            <p>
               <termdef id="dt-xslt-element" term="XSLT element">An <term>XSLT element</term> is an
                  element in the <termref def="dt-xslt-namespace">XSLT namespace</termref> whose
                  syntax and semantics are defined in this specification.</termdef> For a
               non-normative list of XSLT elements, see <specref ref="element-syntax-summary"/>.</p>
            <p>In this document the specification of each <termref def="dt-xslt-element">XSLT
                  element</termref> is preceded by a summary of its syntax in the form of a model
               for elements of that element type. A full list of all these specifications can be
               found in <specref ref="element-syntax-summary"/>. The meaning of syntax summary
               notation is as follows:</p>
            <ulist>
               <item>
                  <p>An attribute that is <rfc2119>required</rfc2119> is shown with its name in
                     bold. An attribute that may be omitted is shown with a question mark following
                     its name.</p>
               </item>
               <item>
                  <p>An attribute that is <termref def="dt-deprecated">deprecated</termref> is shown
                     in a grayed font within square brackets.</p>
               </item>
               <item>
                  <p>The string that occurs in the place of an attribute value specifies the allowed
                     values of the attribute. If this is surrounded by curly brackets
                        (<code>{...}</code>), then the attribute value is treated as an <termref def="dt-attribute-value-template">attribute value template</termref>, and
                     the string occurring within curly brackets specifies the allowed values of the
                     result of evaluating the attribute value template. Alternative allowed values
                     are separated by <code>|</code>. A quoted string indicates a value equal to
                     that specific string. An unquoted, italicized name specifies a particular type
                     of value.</p>
                  <!--Text replaced by erratum E2 change 1"-->
                  <p>Except where the set of allowed values of an attribute is specified using the
                     italicized name <emph>string</emph> or <emph>char</emph>, leading and trailing
                     whitespace in the attribute value is ignored. In the case of an <termref def="dt-attribute-value-template">attribute value template</termref>, this
                     applies to the <termref def="dt-effective-value">effective value</termref>
                     obtained when the attribute value template is expanded.</p>
                  <!--End of text replaced by erratum E2-->
               </item>
               <item>
                  <p>Unless the element is <rfc2119>required</rfc2119> to be empty, the model
                     element contains a comment specifying the allowed content. The allowed content
                     is specified in a similar way to an element type declaration in XML;
                        <emph>sequence constructor</emph> means that any mixture of text nodes,
                        <termref def="dt-literal-result-element">literal result elements</termref>,
                        <termref def="dt-extension-instruction">extension instructions</termref>,
                     and <termref def="dt-xslt-element">XSLT elements</termref> from the <termref def="dt-instruction">instruction</termref> category is allowed;
                        <emph>other-declarations</emph> means that any mixture of XSLT elements from
                     the <termref def="dt-declaration">declaration</termref> category, other than
                        <elcode>xsl:import</elcode>, is allowed, together with <termref def="dt-data-element">user-defined data elements</termref>.</p>
               </item>
               <item>
                  <p>The element is prefaced by comments indicating if it belongs to the
                        <code>instruction</code> category or <code>declaration</code> category or
                     both. The category of an element only affects whether it is allowed in the
                     content of elements that allow a <termref def="dt-sequence-constructor">sequence constructor</termref> or <emph>other-declarations</emph>.</p>
               </item>
            </ulist>
            <example>
               <head>Syntax Notation</head>
               <p>This example illustrates the notation used to describe <termref def="dt-xslt-element">XSLT elements</termref>.</p>
               <e:element-syntax name="example-element">
                  <e:in-category name="instruction"/>
                  <e:attribute name="select" required="yes">
                     <e:data-type name="expression"/>
                  </e:attribute>
                  <e:attribute name="debug">
                     <e:attribute-value-template>
                        <e:constant value="yes"/>
                        <e:constant value="no"/>
                     </e:attribute-value-template>
                  </e:attribute>
                  <e:sequence>
                     <e:choice repeat="zero-or-more">
                        <e:element name="variable"/>
                        <e:element name="param"/>
                     </e:choice>
                     <e:element name="sequence"/>
                  </e:sequence>
                  <e:allowed-parents>
                     <e:parent-category name="sequence-constructor"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p>This example defines a (non-existent) element <code>xsl:example-element</code>.
                  The element is classified as an instruction. It takes a mandatory
                     <code>select</code> attribute, whose value is an XPath <termref def="dt-expression">expression</termref>, and an optional <code>debug</code>
                  attribute, whose value <rfc2119>must</rfc2119> be either <code>yes</code> or
                     <code>no</code>; the curly brackets indicate that the value can be defined as
                  an <termref def="dt-attribute-value-template">attribute value template</termref>,
                  allowing a value such as <code>debug="{$debug}"</code>, where the <termref def="dt-variable">variable</termref>
                  <code>debug</code> is evaluated to yield <code>"yes"</code> or <code>"no"</code>
                  at run-time.</p>
               <p>The content of an <code>xsl:example-element</code> instruction is defined to be a
                  sequence of zero or more <elcode>xsl:variable</elcode> and
                     <elcode>xsl:param</elcode> elements, followed by an
                     <elcode>xsl:sequence</elcode> element.</p>
            </example>
            <p>
               <error spec="XT" type="static" class="SE" code="0010">
                  <p>A <termref def="dt-static-error">static error</termref> is signaled if an
                     XSLT-defined element is used in a context where it is not permitted, if a
                        <rfc2119>required</rfc2119> attribute is omitted, or if the content of the
                     element does not correspond to the content that is allowed for the element.</p>
               </error>
            </p>
            <p>Attributes are validated as follows. These rules apply to the value of the attribute
               after removing leading and trailing whitespace.</p>
            <ulist>
               <item>
                  <p>
                     <error spec="XT" type="static" class="SE" code="0020">
                        <p>It is a <termref def="dt-static-error">static error</termref> if an
                           attribute (other than an attribute written using curly brackets in a
                           position where an <termref def="dt-attribute-value-template">attribute
                              value template</termref> is permitted) contains a value that is not
                           one of the permitted values for that attribute.</p>
                     </error>
                  </p>
               </item>
               <item>
                  <p>
                     <error spec="XT" type="dynamic" class="DE" code="0030">
                        <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                              error</termref> if the <termref def="dt-effective-value">effective
                              value</termref> of an attribute written using curly brackets, in a
                           position where an <termref def="dt-attribute-value-template">attribute
                              value template</termref> is permitted, is a value that is not one of
                           the permitted values for that attribute. If the processor is able to
                           detect the error statically (for example, when any XPath expressions
                           within the curly brackets can be evaluated statically), then the
                           processor may optionally signal this as a static error.</p>
                     </error>
                  </p>
               </item>
            </ulist>
            <p>Special rules apply if the construct appears in part of the <termref def="dt-stylesheet">stylesheet</termref> that is processed with <termref def="dt-forwards-compatible-behavior"/>: see
                  <specref ref="forwards"/>.</p>
            <p>
               <termdef id="dt-deprecated" term="deprecated">Some constructs defined in this
                  specification are described as being <term>deprecated</term>. The use of this term
                  implies that stylesheet authors <rfc2119>should not</rfc2119> use the construct,
                  and that the construct may be removed in a later version of this
                  specification.</termdef> All constructs that are <termref def="dt-deprecated">deprecated</termref> in this specification are also (as it happens) optional
               features that <termref def="dt-implementation">implementations</termref> are
                  <rfc2119>not required</rfc2119> to provide.</p>
            <note>
               <p>This working draft includes a non-normative XML Schema for XSLT <termref def="dt-stylesheet-module">stylesheet modules</termref> (see <specref ref="schema-for-xslt"/>). The syntax summaries described in this section are
                  normative.</p>
            </note>
            <p>XSLT defines a set of standard functions which are additional to those defined in
                  <bibref ref="xpath-functions-11"/>. The signatures of these functions are described
               using the same notation as used in <bibref ref="xpath-functions-11"/>. The names of
               these functions are all in the <termref def="dt-standard-function-namespace">standard
                  function namespace</termref>.</p>
         </div2>
         <div2 id="initiating">
            <head>Initiating a Transformation</head>
            <p>This document does not specify any application programming interfaces or other
               interfaces for initiating a transformation. This section, however, describes the
               information that is supplied when a transformation is initiated. Except where
               otherwise indicated, the information is <rfc2119>required</rfc2119>.</p>
            <p>Implementations <rfc2119>may</rfc2119> allow a transformation to run as two or more
               phases, for example parsing, compilation and execution. Such a distinction is outside
               the scope of this specification, which treats transformation as a single process
               controlled using a set of <termref def="dt-stylesheet-module">stylesheet
                  modules</termref>, supplied in the form of XML documents.</p>
            <p>The following information is supplied to execute a transformation:</p>
            <ulist>
               <item>
                  <p>The <termref def="dt-stylesheet-module">stylesheet module</termref> that is to
                     act as the <termref def="dt-principal-stylesheet-module">principal stylesheet
                        module</termref> for the transformation. The complete <termref def="dt-stylesheet">stylesheet</termref> is assembled by recursively
                     expanding the <elcode>xsl:import</elcode> and <elcode>xsl:include</elcode>
                     declarations in the principal stylesheet module, as described in <specref ref="include"/> and <specref ref="import"/>. </p>
               </item>
               <item>
                  <p>A set (possibly empty) of values for <termref def="dt-stylesheet-parameter">stylesheet parameters</termref> (see <specref ref="global-variables"/>).
                     These values are available for use within <termref def="dt-expression">expressions</termref> in the <termref def="dt-stylesheet">stylesheet</termref>.</p>
               </item>
               <item>
                  <p diff="chg" at="E">
                     <termdef id="dt-initial-context-item" term="initial context item">An item that
                        acts as the <term>initial context item</term> for the transformation. This
                        item is accessible within the <termref def="dt-stylesheet">stylesheet</termref> as the initial value of the XPath <termref def="dt-expression">expressions</termref>
                        <code>.</code> (dot) and <code>self::node()</code>, as described in <specref ref="focus"/>
                     </termdef>. </p>
                  <p diff="add" at="D">The value that can be supplied as the <phrase diff="chg" at="E"><termref def="dt-initial-context-item"/></phrase> is constrained by
                     the <elcode>xsl:context-item</elcode> element, if defined for the chosen
                        <termref def="dt-initial-mode"/>.</p>
                  <p>If no initial context item is supplied, then the <termref def="dt-context-item">context item</termref>, <termref def="dt-context-position">context
                        position</termref>, and <termref def="dt-context-size">context
                        size</termref> will initially be undefined, and the evaluation of any
                     expression that references these values will result in a dynamic error. (Note
                     that the initial context size and context position will always be 1 (one) when
                     an <phrase diff="chg" at="E"><termref def="dt-initial-context-item"/></phrase>
                     is supplied, and will be undefined if no initial context item is supplied).</p>
               </item>
               <item>
                  <p>Optionally, the name of a <termref def="dt-named-template">named
                        template</termref> which is to be executed as the entry point to the
                     transformation. This template <rfc2119>must</rfc2119> exist within the <termref def="dt-stylesheet">stylesheet</termref>. If no named template is supplied,
                     then the transformation starts with the <termref def="dt-template-rule">template rule</termref> that best matches the <phrase diff="chg" at="E"><termref def="dt-initial-context-item"/></phrase>, according to the
                     rules defined in <specref ref="conflict"/>. Either a named template, or an
                     initial context item, or both, <rfc2119>must</rfc2119> be supplied.</p>
               </item>
               <item>
                  <p>Optionally, an initial <termref def="dt-mode">mode</termref>.</p>
                  <p><termdef id="dt-initial-mode" term="initial mode">The initial mode, if
                        specified, <rfc2119>must</rfc2119> either be the default mode, or a mode
                        that is explicitly named in the <code>mode</code> attribute of an
                           <elcode>xsl:template</elcode> declaration within the stylesheet. If an
                        initial mode is supplied, then in searching for the <termref def="dt-template-rule">template rule</termref> that best matches the
                           <phrase diff="chg" at="E"><termref def="dt-initial-context-item"/></phrase>, the processor considers only those rules that apply to the
                        initial mode. If no initial mode is supplied, then the mode named in the
                           <code>default-mode</code> attribute of the
                           <elcode>xsl:stylesheet</elcode> element of the <termref def="dt-principal-stylesheet-module"/> is used; or in the absence of such
                        an attribute, the <termref def="dt-unnamed-mode"/>.</termdef></p>


                  <note diff="chg" at="C">
                     <p>If the initial mode is a <termref def="dt-streamable-mode">streamable
                           mode,</termref> then streaming will only be possible if the
                        initial context item is a node that is supplied in a form that allows such
                        processing: for example, as a reference to a stream of parsing events.</p>
                  </note>
                  <note diff="add" at="E">
                     <p>The design of the API for invoking a transformation
                           <rfc2119>should</rfc2119> provide some means for users to designate the
                           <termref def="dt-unnamed-mode"/> as the <termref def="dt-initial-mode"/>
                        in cases where it is not the default mode.</p>
                  </note>
               </item>
               <item>
                  <p>A base output URI. <termdef id="dt-base-output-uri" term="base output URI"> The
                           <term>base output URI</term> is a URI to be used as the base URI when
                        resolving a relative URI <phrase diff="add" at="F">reference</phrase> allocated to a <termref def="dt-final-result-tree">final result tree</termref>. If the transformation generates more than
                        one final result tree, then typically each one will be allocated a URI
                        relative to this base URI. </termdef> The way in which a base output URI is
                     established is <termref def="dt-implementation-defined">implementation-defined</termref>. </p>
                  <imp-def-feature>The way in which a <termref def="dt-base-output-uri"/> is
                     established is <termref def="dt-implementation-defined">implementation-defined</termref></imp-def-feature>
               </item>
               <item>
                  <p>A mechanism for obtaining a document node and a media type, given an absolute
                     URI. The total set of available documents (modeled as a mapping from URIs to
                     document nodes) forms part of the context for evaluating XPath expressions,
                     specifically the <xfunction>doc</xfunction> function. The XSLT
                        <function>document</function> function additionally requires the media type
                     of the resource representation, for use in interpreting any fragment identifier
                     present within a URI Reference.</p>
                  <note>
                     <p>The set of documents that are available to the stylesheet is <termref def="dt-implementation-dependent">implementation-dependent</termref>, as
                        is the processing that is carried out to construct a tree representing the
                        resource retrieved using a given URI. Some possible ways of constructing a
                        document (specifically, rules for constructing a document from an Infoset or
                        from a PSVI) are described in <bibref ref="xpath-datamodel-11"/>.</p>
                  </note>
               </item>
            </ulist>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0040">
                  <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the invocation of the <termref def="dt-stylesheet">stylesheet</termref> specifies a template name that does not match the
                        <termref def="dt-expanded-qname">expanded-QName</termref> of a named
                     template defined in the <termref def="dt-stylesheet">stylesheet</termref>.</p>
               </error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0045">
                  <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the invocation of the <termref def="dt-stylesheet">stylesheet</termref> specifies an initial <termref def="dt-mode">mode</termref> (other than the default mode) that does not match the
                        <termref def="dt-expanded-qname">expanded-QName</termref> in the
                        <code>mode</code> attribute of any template defined in the <termref def="dt-stylesheet">stylesheet</termref>.</p>
               </error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0047">
                  <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the invocation of the <termref def="dt-stylesheet">stylesheet</termref> specifies both an initial <termref def="dt-mode">mode</termref> and an initial template.</p>
               </error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0050">
                  <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the stylesheet that is invoked declares a visible
                        <termref def="dt-stylesheet-parameter">stylesheet parameter</termref> with
                        <code>required="yes"</code> and no value for this parameter is supplied
                     during the invocation of the stylesheet. A stylesheet parameter is visible if
                     it is not masked by another global variable or parameter with the same name and
                     higher <termref def="dt-import-precedence">import precedence</termref>.</p>
               </error>
            </p>
            <p>
               <termdef id="dt-initial-template" term="initial template">The transformation is
                  performed by evaluating an <term>initial template</term>. If a <termref def="dt-named-template">named template</termref> is supplied when the
                  transformation is initiated, then this is the initial template; otherwise, the
                  initial template is the <termref def="dt-template-rule">template rule</termref>
                  selected according to the rules of the <elcode>xsl:apply-templates</elcode>
                  instruction for processing the <phrase diff="chg" at="E"><termref def="dt-initial-context-item"/></phrase> in the initial <termref def="dt-mode">mode</termref>.</termdef>
            </p>
            <p>Parameters passed to the transformation by the client application are matched against
                  <termref def="dt-stylesheet-parameter">stylesheet parameters</termref> (see
                  <specref ref="global-variables"/>), not against the <termref def="dt-template-parameter">template parameters</termref> declared within the
                  <termref def="dt-initial-template">initial template</termref>. All <termref def="dt-template-parameter">template parameters</termref> within the initial
               template to be executed will take their default values.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0060">
                  <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the <termref def="dt-initial-template">initial
                        template</termref> defines a <termref def="dt-template-parameter">template
                        parameter</termref> that specifies <code>required="yes"</code>.</p>
               </error>
            </p>
            <imp-def-feature>The way in which an XSLT processor is invoked, and the way in which
               values are supplied for the source document, starting node, <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>, and <termref def="dt-base-output-uri">base output URI</termref>, are
               implementation-defined.</imp-def-feature>
            <p>A <termref def="dt-stylesheet">stylesheet</termref> can process further source
               documents in addition to those supplied when the transformation is invoked. These
               additional documents can be loaded using the functions <function>document</function>
               (see <specref ref="document"/>) or <xfunction>doc</xfunction> or
                  <xfunction>collection</xfunction> (see <bibref ref="xpath-functions-11"/>), 
               <phrase diff="add" at="F">or using the <elcode>xsl:stream</elcode> instruction</phrase>;
               alternatively, they
               can be supplied as <termref def="dt-stylesheet-parameter">stylesheet
                  parameters</termref> (see <specref ref="global-variables"/>), or returned as the result of
               an <termref def="dt-extension-function">extension function</termref> (see <specref ref="extension-functions"/>).</p>
         </div2>
         <div2 id="executing-a-transformation">
            <head>Executing a Transformation</head>
            <p>
               <termdef id="dt-template-rule" term="template rule">A stylesheet contains a set of
                     <term>template rules</term> (see <specref ref="rules"/>). A template rule has
                  three parts: a <termref def="dt-pattern">pattern</termref> that is matched against
                  nodes, a (possibly empty) set of <termref def="dt-template-parameter">template
                     parameters</termref>, and a <termref def="dt-sequence-constructor">sequence
                     constructor</termref> that is evaluated to produce a sequence of
                  items.</termdef> In many cases these items are newly constructed nodes, which are
               then written to a <termref def="dt-result-tree">result tree</termref>.</p>
            <p>A transformation as a whole is executed by evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref> of the <termref def="dt-initial-template">initial template</termref> as described in <specref ref="sequence-constructors"/>. </p>
            <!--Text replaced by erratum E11 change 1"-->
            <p>The result sequence produced by evaluating the initial template is handled as
               follows:</p>
            <olist>
               <item>
                  <p>If the initial template has an <code>as</code> attribute, then the result
                     sequence of the initial template is checked against the required type in the
                     same way as for any other template.</p>
               </item>
               <item>
                  <p>If the result sequence is non-empty, then it is used to construct an implicit
                        <termref def="dt-final-result-tree">final result tree</termref>, following
                     the rules described in <specref ref="constructing-complex-content"/>: the
                     effect is as if the initial template <var>T</var> were called by an implicit
                     template of the form:</p>
                  <eg xml:space="preserve">
&lt;xsl:template name="IMPLICIT"&gt;
  &lt;xsl:result-document href=""&gt;
    &lt;xsl:call-template name="T"/&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;</eg>
               </item>
            </olist>
            <!--End of text replaced by erratum E11-->
            <p>An implicit result tree is also created when the result sequence is empty, provided
               that no <elcode>xsl:result-document</elcode> instruction has been evaluated during
               the course of the transformation. In this situation the implicit result tree will
               consist of a document node with no children.</p>
            <note>
               <p>This means that there is always at least one result tree. It also means that if
                  the content of the initial template is a single
                     <elcode>xsl:result-document</elcode> instruction, as in the example above, then
                  only one result tree is produced, not two. It is useful to make the result
                  document explicit as this is the only way of invoking document-level
                  validation.</p>
               <p>If the result of the initial template is non-empty, and an explicit
                     <elcode>xsl:result-document</elcode> instruction has been evaluated with the
                  empty attribute <code>href=""</code>, then an error will occur <errorref spec="XT" class="DE" code="1490"/>, since it is not possible to create two final result
                  trees with the same URI.</p>
            </note>
            <p>A <termref def="dt-sequence-constructor">sequence constructor</termref> is a sequence
               of sibling nodes in the stylesheet, each of which is either an <termref def="dt-xslt-instruction">XSLT instruction</termref>, a <termref def="dt-literal-result-element">literal result element</termref>, a text node, or
               an <termref def="dt-extension-instruction">extension instruction</termref>.</p>
            <p>
               <termdef id="dt-instruction" term="instruction">An <term>instruction</term> is either
                  an <termref def="dt-xslt-instruction">XSLT instruction</termref> or an <termref def="dt-extension-instruction">extension instruction</termref>.</termdef>
            </p>
            <p>
               <termdef id="dt-xslt-instruction" term="XSLT instruction">An <term>XSLT
                     instruction</term> is an <termref def="dt-xslt-element">XSLT element</termref>
                  whose syntax summary in this specification contains the annotation <code>&lt;!--
                     category: instruction --&gt;</code>.</termdef>
            </p>
            <p>
               <termref def="dt-extension-instruction">Extension instructions</termref> are
               described in <specref ref="extension-instruction"/>.</p>
            <p>The main categories of <termref def="dt-xslt-instruction">XSLT instruction</termref>
               are as follows:</p>
            <ulist>
               <item>
                  <p>instructions that create new nodes: <elcode>xsl:document</elcode>,
                        <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                        <elcode>xsl:processing-instruction</elcode>, <elcode>xsl:comment</elcode>,
                        <elcode>xsl:value-of</elcode>, <elcode>xsl:text</elcode>,
                        <elcode>xsl:namespace</elcode>;</p>
               </item>
               <item>
                  <p>an instruction that returns an arbitrary sequence by evaluating an XPath
                     expression: <elcode>xsl:sequence</elcode>;</p>
               </item>
               <item>
                  <p>instructions that cause conditional or repeated evaluation of nested
                     instructions: <elcode>xsl:if</elcode>, <elcode>xsl:choose</elcode>,
                        <phrase diff="add" at="F"><elcode>xsl:try</elcode>,</phrase>
                        <elcode>xsl:for-each</elcode>, <elcode>xsl:for-each-group</elcode>,
                     <phrase diff="add" at="F"><elcode>xsl:fork</elcode>,
                        <elcode>xsl:iterate</elcode> and its subordinate instructions
                     <elcode>xsl:next-iteration</elcode> and <elcode>xsl:break</elcode></phrase>;</p>
               </item>
               <item>
                  <p>instructions that invoke templates: <elcode>xsl:apply-templates</elcode>,
                        <elcode>xsl:apply-imports</elcode>, <elcode>xsl:call-template</elcode>,
                        <elcode>xsl:next-match</elcode>;</p>
               </item>
               <item>
                  <p>Instructions that declare variables: <elcode>xsl:variable</elcode>,
                        <elcode>xsl:param</elcode>;</p>
               </item>
               <item>
                  <p>other specialized instructions: <elcode>xsl:number</elcode>,
                        <elcode>xsl:analyze-string</elcode>, <elcode>xsl:message</elcode>,
                        <elcode>xsl:result-document</elcode>, 
                     <phrase diff="add" at="F"><elcode>xsl:stream</elcode>, <elcode>xsl:perform-sort</elcode>, <elcode>xsl:merge</elcode></phrase>.</p>
               </item>
            </ulist>
            <p>Often, a <termref def="dt-sequence-constructor">sequence constructor</termref> will
               include an <elcode>xsl:apply-templates</elcode> instruction, which selects a sequence
               of nodes to be processed. Each of the selected nodes is processed by searching the
               stylesheet for a matching <termref def="dt-template-rule">template rule</termref> and
               evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref>
               of that template rule. The resulting sequences of items are concatenated, in order,
               to give the result of the <elcode>xsl:apply-templates</elcode> instruction, as
               described in <specref ref="applying-templates"/>; this sequence is often added to a
                  <termref def="dt-result-tree">result tree</termref>. Since the <termref def="dt-sequence-constructor">sequence constructors</termref> of the selected
                  <termref def="dt-template-rule">template rules</termref> may themselves contain
                  <elcode>xsl:apply-templates</elcode> instructions, this results in a cycle of
               selecting nodes, identifying <termref def="dt-template-rule">template
               rules</termref>, constructing sequences, and constructing <termref def="dt-result-tree">result trees</termref>, that recurses through a <termref def="dt-source-tree">source tree</termref>. </p>
         </div2>
         <div2 id="context">
            <head>The Evaluation Context</head>
            <p>The results of some expressions and instructions in a stylesheet may depend on
               information provided contextually. This context information is divided into two
               categories: the static context, which is known during static analysis of the
               stylesheet, and the dynamic context, which is not known until the stylesheet is
               evaluated. Although information in the static context is known at analysis time, it
               is sometimes used during stylesheet evaluation.</p>
            <p>Some context information can be set by means of declarations within the stylesheet
               itself. For example, the namespace bindings used for any XPath expression are
               determined by the namespace declarations present in containing elements in the
               stylesheet. Other information may be supplied externally or implicitly: an example is
               the current date and time.</p>
            <p>The context information used in processing an XSLT stylesheet includes as a subset
               all the context information required when evaluating XPath expressions. The <phrase diff="chg" at="D">XPath 2.1</phrase> specification defines a static and dynamic
               context that the host language (in this case, XSLT) may initialize, which affects the
               results of XPath expressions used in that context. XSLT augments the context with
               additional information: this additional information is used firstly by XSLT
               constructs outside the scope of XPath (for example, the <elcode>xsl:sort</elcode>
               element), and secondly, by functions that are defined in the XSLT specification (such
               as <function>key</function> and <function>current-group</function>) that are
               available for use in XPath expressions appearing within a stylesheet.</p>
            <p>The static context for an expression or other construct in a stylesheet is determined
               by the place in which it appears lexically. The details vary for different components
               of the static context, but in general, elements within a stylesheet module affect the
               static context for their descendant elements within the same stylesheet module.</p>
            <p>The dynamic context is maintained as a stack. When an instruction or expression is
               evaluated, it may add dynamic context information to the stack; when evaluation is
               complete, the dynamic context reverts to its previous state. An expression that
               accesses information from the dynamic context always uses the value at the top of the
               stack.</p>
            <p>The most commonly used component of the dynamic context is the <termref def="dt-context-item">context item</termref>. This is an implicit variable whose
               value is the item currently being processed (it may be a node, an atomic value,
                  <phrase diff="add" at="C">or a function item</phrase>). The value of the context
               item can be referenced within an XPath expression using the expression <code>.</code>
               (dot).</p>
            <p>Full details of the static and dynamic context are provided in <specref ref="static-and-dynamic-context"/>.</p>
         </div2>
         <div2 id="parsing-and-serialization">
            <head>Parsing and Serialization</head>
            <p>An XSLT <termref def="dt-stylesheet">stylesheet</termref> describes a process that
               constructs a set of <termref def="dt-final-result-tree">final result trees</termref>
               from a set of <termref def="dt-source-tree">source trees</termref>.</p>
            <p>The <termref def="dt-stylesheet">stylesheet</termref> does not describe how a
                  <termref def="dt-source-tree">source tree</termref> is constructed. Some possible
               ways of constructing source trees are described in <bibref ref="xpath-datamodel-11"/>.
               Frequently an <termref def="dt-implementation">implementation</termref> will operate
               in conjunction with an XML parser (or more strictly, in the terminology of <bibref ref="REC-xml"/>, an <emph>XML processor</emph>), to build a source tree from an
               input XML document. An implementation <rfc2119>may</rfc2119> also provide an
               application programming interface allowing the tree to be constructed directly, or
               allowing it to be supplied in the form of a DOM Document object (see <bibref ref="DOM-Level-2-Core"/>). This is outside the scope of this specification. Users
               should be aware, however, that since the input to the transformation is a tree
               conforming to the XDM data model as described in <bibref ref="xpath-datamodel-11"/>,
               constructs that might exist in the original XML document, or in the DOM, but which
               are not within the scope of the data model, cannot be processed by the <termref def="dt-stylesheet">stylesheet</termref> and cannot be guaranteed to remain
               unchanged in the transformation output. Such constructs include CDATA section
               boundaries, the use of entity references, and the DOCTYPE declaration and internal
               DTD subset.</p>
            <p>
               <termdef id="dt-serialization" term="serialization">A frequent requirement is to
                  output a <termref def="dt-final-result-tree">final result tree</termref> as an XML
                  document (or in other formats such as HTML). This process is referred to as
                     <term>serialization</term>.</termdef>
            </p>
            <p>Like parsing, serialization is not part of the transformation process, and it is not
                  <rfc2119>required</rfc2119> that an XSLT processor <rfc2119>must</rfc2119> be able
               to perform serialization. However, for pragmatic reasons, this specification
               describes declarations (the <elcode>xsl:output</elcode> element and the
                  <elcode>xsl:character-map</elcode> declarations, see <specref ref="serialization"/>), and attributes on the <elcode>xsl:result-document</elcode> instruction, that
               allow a <termref def="dt-stylesheet">stylesheet</termref> to specify the desired
               properties of a serialized output file. When serialization is not being performed,
               either because the implementation does not support the serialization option, or
               because the user is executing the transformation in a way that does not invoke
               serialization, then the content of the <elcode>xsl:output</elcode> and
                  <elcode>xsl:character-map</elcode> declarations has no effect. Under these
               circumstances the processor <rfc2119>may</rfc2119> report any errors in an
                  <elcode>xsl:output</elcode> or <elcode>xsl:character-map</elcode> declaration, or
               in the serialization attributes of <elcode>xsl:result-document</elcode>, but is not
                  <rfc2119>required</rfc2119> to do so.</p>
         </div2>
         <div2 id="extensibility">
            <head>Extensibility</head>
            <p>XSLT defines a number of features that allow the language to be extended by
               implementers, or, if implementers choose to provide the capability, by users. These
               features have been designed, so far as possible, so that they can be used without
               sacrificing interoperability. Extensions other than those explicitly defined in this
               specification are not permitted.</p>
            <p>These features are all based on XML namespaces; namespaces are used to ensure that
               the extensions provided by one implementer do not clash with those of a different
               implementer.</p>
            <p>The most common way of extending the language is by providing additional functions,
               which can be invoked from XPath expressions. These are known as <termref def="dt-extension-function">extension functions</termref>, and are described in
                  <specref ref="extension-functions"/>.</p>
            <p>It is also permissible to extend the language by providing new <termref def="dt-instruction">instructions</termref>. These are referred to as <termref def="dt-extension-instruction">extension instructions</termref>, and are described
               in <specref ref="extension-instruction"/>. A stylesheet that uses extension
               instructions in a particular namespace must declare that it is doing so by using the
                  <code>[xsl:]extension-element-prefixes</code> attribute.</p>
            <p>Extension instructions and extension functions defined according to these rules
                  <rfc2119>may</rfc2119> be provided by the implementer of the XSLT processor, and
               the implementer <rfc2119>may</rfc2119> also provide facilities to allow users to
               create further extension instructions and extension functions.</p>
            <p>This specification defines how extension instructions and extension functions are
               invoked, but the facilities for creating new extension instructions and extension
               functions are <termref def="dt-implementation-defined">implementation-defined</termref>. For further details, see <specref ref="extension"/>.</p>
            <imp-def-feature>The mechanisms for creating new <termref def="dt-extension-instruction">extension instructions</termref> and <termref def="dt-extension-function">extension functions</termref> are <termref def="dt-implementation-defined"/>.</imp-def-feature>
            <p>The XSLT language can also be extended by the use of <termref def="dt-extension-attribute">extension attributes</termref> (see <specref ref="extension-attributes"/>), and by means of <termref def="dt-data-element">user-defined data elements</termref> (see <specref ref="user-defined-top-level"/>).</p>
         </div2>
         <div2 id="stylesheets-and-schemas">
            <head>Stylesheets and XML Schemas</head>
            <p>An XSLT <termref def="dt-stylesheet">stylesheet</termref> can make use of information
               from a schema. An XSLT transformation can take place in the absence of a schema (and,
               indeed, in the absence of a DTD), but where the source document has undergone schema
               validity assessment, the XSLT processor has access to the type information associated
               with individual nodes, not merely to the untyped text.</p>
            <p>Information from a schema can be used both statically (when the <termref def="dt-stylesheet">stylesheet</termref> is compiled), and dynamically (during
               evaluation of the stylesheet to transform a source document).</p>
            <p>There are places within a <termref def="dt-stylesheet">stylesheet</termref>, and
               within XPath <termref def="dt-expression">expressions</termref> and <termref def="dt-pattern">patterns</termref> in a <termref def="dt-stylesheet">stylesheet</termref>, where it is possible to refer to named type definitions in
               a schema, or to element and attribute declarations. For example, it is possible to
               declare the types expected for the parameters of a function. This is done using the
                  <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-SequenceType" xlink:type="simple">SequenceType</xnt> syntax defined
               in <bibref ref="xpath-21"/>.</p>
            <p>
               <termdef id="dt-schema-component" term="schema component">Type definitions and
                  element and attribute declarations are referred to collectively as <term>schema
                     components</term>.</termdef>
            </p>
            <p>
               <termdef id="dt-in-scope-schema-component" term="in-scope schema component">The
                     <termref def="dt-schema-component">schema components</termref> that may be
                  referenced by name in a <termref def="dt-stylesheet">stylesheet</termref> are
                  referred to as the <term>in-scope schema components</term>. This set is the same
                  throughout all the modules of a stylesheet.</termdef>
            </p>
            <p>The conformance rules for XSLT <phrase diff="chg" at="A">2.1</phrase>, defined in
                  <specref ref="conformance"/>, distinguish between a <termref def="dt-basic-xslt-processor">basic XSLT processor</termref> and a <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT processor</termref>. As the
               names suggest, a basic XSLT processor does not support the features of XSLT that
               require access to schema information, either statically or dynamically. A <termref def="dt-stylesheet">stylesheet</termref> that works with a basic XSLT processor
               will produce the same results with a schema-aware XSLT processor provided that the
               source documents are untyped (that is, they are not validated against a schema).
               However, if source documents are validated against a schema then the results may be
               different from the case where they are not validated. Some constructs that work on
               untyped data may fail with typed data (for example, an attribute of type
                  <code>xs:date</code> cannot be used as an argument of the
                  <xfunction>substring</xfunction> function) and other constructs may produce
               different results depending on the data type (for example, given the element
                  <code>&lt;product price="10.00" discount="2.00"/&gt;</code>, the expression
                  <code>@price gt @discount</code> will return true if the attributes have type
                  <code>xs:decimal</code>, but will return false if they are untyped).</p>
            <p>There is a standard set of type definitions that are always available as <termref def="dt-in-scope-schema-component">in-scope schema components</termref> in every
               stylesheet. These are defined in <specref ref="built-in-types"/>. <phrase diff="del" at="E">The set of built-in types varies between a <termref def="dt-basic-xslt-processor">basic XSLT processor</termref> and a <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT
                  processor</termref>.</phrase></p>
            <p>The remainder of this section describes facilities that are available only with a
                  <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT
                  processor</termref>.</p>
            <p>Additional <termref def="dt-schema-component">schema components</termref> (type
               definitions, element declarations, and attribute declarations) may be added to the
                  <termref def="dt-in-scope-schema-component">in-scope schema components</termref>
               by means of the <elcode>xsl:import-schema</elcode> declaration in a stylesheet.</p>
            <p>The <elcode>xsl:import-schema</elcode> declaration may reference an external schema
               document by means of a URI, or it may contain an inline <code>xs:schema</code>
               element.</p>
            <p>It is only necessary to import a schema explicitly if one or more of its <termref def="dt-schema-component">schema components</termref> are referenced explicitly by
               name in the <termref def="dt-stylesheet">stylesheet</termref>; it is not necessary to
               import a schema merely because the stylesheet is used to process a source document
               that has been assessed against that schema. It is possible to make use of the
               information resulting from schema assessment (for example, the fact that a particular
               attribute holds a date) even if no schema has been imported by the stylesheet.</p>
            <p>Importing a schema does not of itself say anything about the type of the source
               document that the <termref def="dt-stylesheet">stylesheet</termref> is expected to
               process. The imported type definitions can be used for temporary nodes or for nodes
               on a <termref def="dt-result-tree">result tree</termref> just as much as for nodes in
               source documents. It is possible to make assertions about the type of an input
               document by means of tests within the <termref def="dt-stylesheet">stylesheet</termref>. For example:</p>
            <example diff="chg" at="C">
               <head>Asserting the Required Type of the Source Document</head>
               <eg xml:space="preserve">&lt;xsl:mode initial="yes"&gt;
  &lt;xsl:context-item required="yes"
                    as="document-node(schema-element(my:invoice))"/&gt;
&lt;/xsl:mode&gt;
</eg>
               <p>This example will cause the transformation to fail with an error message when the
                     <termref def="dt-initial-mode"/> is the unnamed mode, unless the document
                  element of the source document is valid against the top-level element declaration
                     <code>my:invoice</code>, and has been annotated as such.</p>
            </example>
            <p diff="add" at="D">Equally, importing a schema does not of itself say anything about
               the structure of the result tree. It is possible to request validation of a result
               tree against the schema by using the <elcode>xsl:result-document</elcode>
               instruction, for example:</p>
            <example diff="add" at="D">
               <head>Requesting Validation of the Result Document</head>
               <eg xml:space="preserve">&lt;xsl:template match="/"&gt;
  &lt;xsl:result-document validation="strict"&gt;
    &lt;xhtml:html&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xhtml:html&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;
               </eg>
               <p>This example will cause the transformation to fail with an error message unless
                  the document element of the result document is valid against the top-level element
                  declaration <code>xhtml:html</code>.</p>
            </example>

            <p>It is possible that a source document may contain nodes whose <termref def="dt-annotation">type annotation</termref> is not one of the types imported by
               the stylesheet. This creates a potential problem because in the case of an expression
               such as <code>data(.) instance of xs:integer</code> the system needs to know whether
               the type named in the type annotation of the context node is derived by restriction
               from the type <code>xs:integer</code>. This information is not explicitly available
               in an XDM tree, as defined in <bibref ref="xpath-datamodel-11"/>. The implementation may
               choose one of several strategies for dealing with this situation:</p>
            <olist>
               <item>
                  <p>The processor may signal a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if a source document is found to
                     contain a <termref def="dt-annotation">type annotation</termref> that is not
                     known to the processor.</p>
               </item>
               <item>
                  <p>The processor may maintain additional metadata, beyond that described in
                        <bibref ref="xpath-datamodel-11"/>, that allows the source document to be
                     processed as if all the necessary schema information had been imported using
                        <elcode>xsl:import-schema</elcode>. Such metadata might be held in the data
                     structure representing the source document itself, or it might be held in a
                     system catalog or repository.</p>
               </item>
               <item>
                  <p>The processor may be configured to use a fixed set of schemas, which are
                     automatically used to validate all source documents before they can be supplied
                     as input to a transformation. In this case it is impossible for a source
                     document to have a <termref def="dt-annotation">type annotation</termref> that
                     the processor is not aware of.</p>
               </item>
               <item>
                  <p>The processor may be configured to treat the source document as if no schema
                     processing had been performed, that is, effectively to strip all type
                     annotations from elements and attributes on input, marking them instead as
                     having type <code>xs:untyped</code> and <code>xs:untypedAtomic</code>
                     respectively.</p>
               </item>
            </olist>
            <p>Where a stylesheet author chooses to make assertions about the types of nodes or of
                  <termref def="dt-variable">variables</termref> and <termref def="dt-parameter">parameters</termref>, it is possible for an XSLT processor to perform static
               analysis of the <termref def="dt-stylesheet">stylesheet</termref> (that is, analysis
               in the absence of any source document). Such analysis <rfc2119>may</rfc2119> reveal
               errors that would otherwise not be discovered until the transformation is actually
               executed. An XSLT processor is not <rfc2119>required</rfc2119> to perform such static
               type-checking. Under some circumstances (see <specref ref="errors"/>) type errors
               that are detected early <rfc2119>may</rfc2119> be reported as static errors. In
               addition an implementation <rfc2119>may</rfc2119> report any condition found during
               static analysis as a warning, provided that this does not prevent the stylesheet
               being evaluated as described by this specification.</p>
            <p>A <termref def="dt-stylesheet">stylesheet</termref> can also control the <termref def="dt-annotation">type annotations</termref> of nodes that it constructs in a
                  <termref def="dt-final-result-tree">final result tree</termref>, or in <termref def="dt-temporary-tree">temporary trees</termref>. This can be done in a number of
               ways.</p>
            <ulist>
               <item>
                  <p>It is possible to request explicit validation of a complete document, that is,
                     a tree rooted at a document node. This applies both to temporary trees
                     constructed using the <elcode>xsl:document</elcode> (or
                        <elcode>xsl:copy</elcode>) instruction and also to <termref def="dt-final-result-tree">final result trees</termref> constructed using
                        <elcode>xsl:result-document</elcode>. Validation is either strict or lax, as
                     described in <bibref ref="xmlschema-1"/>. If validation of a <termref def="dt-result-tree">result tree</termref> fails (strictly speaking, if the
                     outcome of the validity assessment is <code>invalid</code>), then the
                     transformation fails, but in all other cases, the element and attribute nodes
                     of the tree will be annotated with the names of the types to which these nodes
                     conform. These <termref def="dt-annotation">type annotations</termref> will be
                     discarded if the result tree is serialized as an XML document, but they remain
                     available when the result tree is passed to an application (perhaps another
                        <termref def="dt-stylesheet">stylesheet</termref>) for further
                     processing.</p>
               </item>
               <item>
                  <p>It is also possible to validate individual element and attribute nodes as they
                     are constructed. This is done using the <code>type</code> and
                        <code>validation</code> attributes of the <elcode>xsl:element</elcode>,
                        <elcode>xsl:attribute</elcode>, <elcode>xsl:copy</elcode>, and
                        <elcode>xsl:copy-of</elcode> instructions, or the <code>xsl:type</code> and
                        <code>xsl:validation</code> attributes of a literal result element.</p>
               </item>
               <item>
                  <p>When elements, attributes, or document nodes are copied, either explicitly
                     using the <elcode>xsl:copy</elcode> or <elcode>xsl:copy-of</elcode>
                     instructions, or implicitly when nodes in a sequence are attached to a new
                     parent node, the options <code>validation="strip"</code> and
                        <code>validation="preserve"</code> are available, to control whether
                     existing <termref def="dt-annotation">type annotations</termref> are to be
                     retained or not.</p>
               </item>
            </ulist>
            <p>When nodes in a <termref def="dt-temporary-tree">temporary tree</termref> are
               validated, type information is available for use by operations carried out on the
               temporary tree, in the same way as for a source document that has undergone schema
               assessment.</p>
            <p>For details of how validation of element and attribute nodes works, see <specref ref="validation"/>.</p>
         </div2>
         <div2 id="streaming-concepts" diff="add" at="A">
            <head>Streaming</head>
            <p><termdef id="dt-streaming" term="streaming">The term <term>streaming</term> refers to
                  a manner of processing in which documents (such as source and result documents)
                  are not represented by a complete tree of nodes occupying memory proportional to
                  document size, but instead are processed "on the fly" as a sequence of events,
                  similar in concept to the stream of events notified by an XML parser to represent
                  markup in lexical XML.</termdef></p>

            <p><termdef id="dt-streamed-document" term="streamed document">A <term>streamed
                     document</term> is a <termref def="dt-source-tree">source tree</termref> that
                  is processed using streaming, that is, without constructing a complete tree
                  of nodes in memory.</termdef></p>

            <p><termdef id="dt-streamed-document-node" term="streamed node">A <term>streamed
                     node</term> is a node in a <termref def="dt-streamed-document">streamed
                     document</termref>.</termdef></p>

            <p>Many processors implementing earlier versions of this specification have adopted an
               architecture that allows streaming of the <termref def="dt-result-tree">result
                  tree</termref> directly to a serializer, without first materializing the complete
               result tree in memory. Streaming of the <termref def="dt-source-tree">source
                  tree</termref>, however, has proved to be more difficult without subsetting the
               language. This has created a situation where documents exceeding the capacity of
               virtual memory could not be transformed. XSLT 2.1 therefore introduces facilities
               allowing stylesheets to be written in a way that makes streaming of source documents
               possible, without excessive reliance on processor-specific optimization
               techniques.</p>

            <p>Streaming achieves two important objectives: it allows large documents to be
               transformed without requiring correspondingly large amounts of memory; and it allows
               the processor to start producing output before it has finished receiving its input,
               thus reducing latency.</p>

            <p>This specification does not attempt to legislate precisely which implementation
               techniques fall under the definition of streaming, and which do not. A number of
               techniques are available that reduce memory requirements, while still requiring a
               degree of buffering, or allocation of memory to partial results. A stylesheet that
               requests streaming of a source document is indicating that the processor should avoid
               assuming that the entire source document will fit in memory; in return, the
               stylesheet must be written in a way that makes streaming possible. This
               specification does not attempt to describe the algorithms that the processor should
               actually use, or to impose quantitative constraints on the resources that these
               algorithms should consume.</p>

            <p>Nothing in this specification, nor in its predecessors <bibref ref="xslt"/> and <bibref ref="xslt20"/>,
               prevents a processor using streaming whenever it sees an opportunity to do
               so. However, experience has shown that in order to achieve streaming, it is often
               necessary to write stylesheet code in such a way as to make this possible. Therefore,
               XSLT 2.1 provides explicit constructs allowing the stylesheet author to request
               streaming, and defines explicit static constraints on the structure of the
               code which are designed to make streaming possible.</p>

            <p>A processor that claims conformance with the streaming option offers a guarantee that
               when streaming is requested for a source document, and when the stylesheet conforms
               to the rules that make the processing <termref def="dt-guaranteed-streamable"/>, 
               then an algorithm will be adopted in which
               memory consumption is either completely independent of document size, or increases
               only very slowly as document size increases, allowing documents to be processed that
               are orders-of-magnitude larger than the physical memory available. A processor that
               does not claim conformance with the streaming option must still process a stylesheet
               and deliver the correct results, but is not required to use streaming algorithms, and
               may therefore fail with out-of-memory errors when presented with large source
               documents.</p>

            <p>Apart from the fact that there are constructs to request streaming, and rules that
               must be followed to guarantee that streaming is possible, the language has been designed
               so there are as few differences as possible between streaming and non-streaming
               evaluation. The semantics of the language continue to be expressed in terms of the
               XDM data model, which is substantively unchanged; but readers must take care to
               observe that when terms like "node" and "axis" are used, the concepts are completely
               abstract and may have no direct representation in the run-time execution
               environment.</p>
            <p>Streamed processing of a document can be initiated in one of two ways:</p>
            <ulist>
               <item>
                  <p>The <termref def="dt-initial-mode">initial mode</termref> can be declared as a
                        <termref def="dt-streamable-mode">streamable mode</termref>. In this case
                     the <phrase diff="chg" at="E"><termref def="dt-initial-context-item"/></phrase>
                     will generally be a document node, and it will be supplied by the calling
                     application in a form that allows streaming (that is, in some form
                     other than a tree in memory; for example, as a reference to a push or pull XML
                     parser primed to deliver a stream of events). <phrase diff="chg" at="E">The
                        type of the <termref def="dt-initial-context-item"/> can be constrained
                        using the <elcode>xsl:context-item</elcode> element.</phrase> In this case
                     the <termref def="dt-template-rule">template rule</termref> that matches the
                     document node (in this mode) must be a <termref def="dt-streamable-template">streamable template</termref>, which means that it (as well as all other
                     template rules using this <termref def="dt-mode">mode</termref>) must satisfy
                     certain statically checkable constraints to ensure that streaming is
                     possible.</p>
               </item>
               <item>
                  <p>Streamed processing of any document can be initiated using the
                        <elcode>xsl:stream</elcode> instruction. This has an attribute
                        <code>href</code> whose value is the URI of a document to be processed using
                     streaming, and the actual processing to be applied is defined by the
                     instructions written as children of the <elcode>xsl:stream</elcode>
                     instruction. These instructions must satisfy the same rules as for a <termref def="dt-streamable-template">streamable template</termref>.</p>
               </item>
            </ulist>
            <p>The rules for streamability, which are defined in detail in <specref ref="streamability"/>, impose two main constraints:</p>
            <ulist>
               <item>
                  <p>The only nodes reachable from the node that is currently being processed are
                     its attributes and namespaces, its ancestors and their attributes and
                     namespaces, and its descendants and their attributes and namespaces. The
                     siblings of the node, and the siblings of its ancestors, are not reachable in
                     the tree, and any attempt to use their values is a <termref def="dt-static-error">static error</termref>. However, constructs (for
                     example, simple forms of <elcode>xsl:number</elcode>, and simple positional
                        <termref def="dt-pattern">patterns</termref>) that require knowledge of the
                     number of preceding elements by name are permitted.</p>
               </item>
               <item>
                  <p>When processing a given node in the tree, each descendant node can only be
                     visited once. Essentially this allows two styles of processing: either visit
                     each of the children once, and then process that child with the same
                     restrictions applied; or process all the descendants in a single pass, in which
                     case it is not possible while processing a descendant to make any further
                     downward selection.</p>
               </item>
            </ulist>
            <p diff="chg" at="F">The second restriction, that only one visit to the children is allowed, means that
               XSLT code that was not designed with streaming in mind will often need to be
               rewritten to make it streamable. In many cases it is possible to do this using a
               technique sometimes called <emph>windowing</emph> or <emph>burst-mode
                  streaming</emph> (note this is not
               quite the same meaning as <emph>windowing</emph> in XQuery 1.1.). 
               Many XML documents consist of a large number of
               elements, each of manageable size, representing transactions or business objects
               where each such element can be processed independently: in such cases, an effective
               design pattern is to write a streaming transformation that takes a snapshot of each
               element in turn, processing the snapshot using the full power of the XSLT language.
               Each snapshot is a tree built in memory and is therefore fully navigable.  For details
               see the <function>snapshot</function> and <function>copy-of</function> functions.</p>
            <p>Streaming applications often fall into one of the following categories:</p>
            <ulist>
               <item>
                  <p>Aggregation applications, where a single aggregation operation (perhaps
                        <xfunction>count</xfunction>, <xfunction>sum</xfunction>,
                        <xfunction>exists</xfunction>, or <xfunction>distinct-values</xfunction>) is
                     applied to a set of elements selected from the streamed source document by
                     means of a path expression.</p>
               </item>
               <item>
                  <p>Record-at-a-time applications, where the source document consists of a long
                     sequence of elements with similar structure ("records"), and each "record" is
                     processed using the same logic, independently of any other "records". This kind
                     of processing is facilitated using the <function>snapshot</function> and
                        <function>copy-of</function> function mentioned earlier.</p>
               </item>
               <item>
                  <p>Grouping applications, where the output follows the structure of the input,
                     except that an extra layer of hierarchy is added. For example, the input might
                     be a flat series of banking transactions in date/time order, and the output
                     might contain the same transactions grouped by date.</p>
               </item>
               <item>
                  <p>Accumulator applications, which are the same as record-at-a-time applications,
                     except that the processing of one "record" might depend on data encountered
                     earlier in the document. A classical example is processing a sequence of
                     banking transactions in which the input transaction contains a debit or credit
                     amount, and the output adds a running total (the account balance). The
                        <elcode>xsl:iterate</elcode> instruction has been introduced to facilitate
                     this style of processing.</p>
               </item>
               <item>
                  <p>Isomorphic transformations, in which there is an ordered (often largely
                     one-to-one) relationship between the nodes of the source tree and the nodes of
                     the result tree: for example, transformations that involve only the renaming or
                     selective deletion of nodes, or scalar manipulations of the values held in the
                     leaf nodes. Such transformations are most conveniently expressed using
                     recursive application of template rules. This is possible with a streamed input
                     document only if all the template rules adhere to the constraints required for
                     streamability. To enforce these rules, while still allowing unrestricted
                     processing of other documents within the same transformation, all streaming
                     evaluation must be carried out using a specific <termref def="dt-mode">mode</termref>, which is declared to be a streaming mode by means of an
                        <elcode>xsl:mode</elcode> declaration in the stylesheet.</p>
               </item>
            </ulist>
            <p>There are important classes of application in which streaming is possible only if
               multiple streams can be processed in parallel. This specification therefore provides
               facilities:</p>
            <olist>
               <item>
                  <p>allowing two sorted input sequences to be merged into one sorted output
                     sequence (the <elcode>xsl:merge</elcode> instruction)</p>
               </item>
               <item>
                  <p>allowing multiple output sequences to be generated during a single pass of an
                     input sequence (the <elcode>xsl:fork</elcode> instruction).</p>
               </item>
            </olist>
            <p>These facilities have been designed in such a way that they can readily be
               implemented using streaming, that is, without materializing the input or output
               sequences in memory.</p>
            <issue id="issue-streaming-pessimism" status="open">
               <p>The design adopted in this specification works on the basis that decisions about
                  streamability should be made statically (at compile time). Sometimes this means
                  taking a pessimistic approach, that is, rejecting a construct as non-streamable
                  based on worst-case assumptions. Two examples of this are (a) disallowing
                     <code>&lt;xsl:with-param name="p" select="@code"/&gt;</code> when calling a
                  streamable template, on the grounds that the called template might perform
                  disallowed navigation from the attribute node; (b) disallowing use of the
                  descendant axis in cases where it might select two elements, one of which is an
                  ancestor of the other. An alternative design approach would allow optimistic
                  assumptions to be made in such cases, creating the risk of dynamic errors: for
                  example it might be a dynamic error in the first case if the called template
                  performs disallowed navigation from the attribute node, and in the second case if
                  the descendant axis actually selects a node that is a descendant of another
                  selected node. The decision to make the analysis pessimistic interacts with the
                  strategy for fallback if streaming is not possible; a non-streaming fallback is
                  feasible if decisions are made statically, but is not realistically possible if
                  the problems are only detected at execution time. The Working Group welcomes
                  discussion of this decision.</p>
            </issue>
         </div2>
         <div2 id="errors">
            <head>Error Handling</head>
            <!--Text replaced by erratum E5 change 1"-->
            <p>
               <termdef id="dt-static-error" term="static error">An error that can be detected by
                  examining a <termref def="dt-stylesheet">stylesheet</termref> before execution
                  starts (that is, before the source document and values of stylesheet parameters
                  are available) is referred to as a <term>static error</term>.</termdef>
            </p>
            <p>Errors classified in this specification as static errors <rfc2119>must</rfc2119> be
               signaled by all implementations: that is, the <termref def="dt-processor">processor</termref>
               <rfc2119>must</rfc2119> indicate that the error is present. A static error
                  <rfc2119>must</rfc2119> be signaled even if it occurs in a part of the <termref def="dt-stylesheet">stylesheet</termref> that is never evaluated. Static errors
               are never recoverable. After signaling a static error, a processor
                  <rfc2119>may</rfc2119> continue for the purpose of signaling additional errors,
               but it <rfc2119>must</rfc2119> eventually terminate abnormally without producing any
                  <termref def="dt-final-result-tree">final result tree</termref>.</p>
            <p>There is an exception to this rule when the stylesheet specifies <termref def="dt-forwards-compatible-behavior"/> (see
                  <specref ref="forwards"/>).</p>
            <p>Generally, errors in the structure of the <termref def="dt-stylesheet">stylesheet</termref>, or in the syntax of XPath <termref def="dt-expression">expressions</termref> contained in the stylesheet, are classified as <termref def="dt-static-error">static errors</termref>. Where this specification states
               that an element in the stylesheet <rfc2119>must</rfc2119> or <rfc2119>must
                  not</rfc2119> appear in a certain position, or that it <rfc2119>must</rfc2119> or
                  <rfc2119>must not</rfc2119> have a particular attribute, or that an attribute
                  <rfc2119>must</rfc2119> or <rfc2119>must not</rfc2119> have a value satisfying
               specified conditions, then any contravention of this rule is a static error unless
               otherwise specified. </p>
            <p>
               <termdef id="dt-dynamic-error" term="dynamic error">An error that is not detected
                  until a source document is being transformed is referred to as a <term>dynamic
                     error</term>.</termdef>
            </p>
            <p>
               <termdef id="dt-recoverable-error" term="recoverable error">Some dynamic errors are
                  classed as <term>recoverable errors</term>. When a recoverable error occurs, this
                  specification allows the processor either to signal the error (by reporting the
                  error condition and terminating execution) or to take a defined recovery action
                  and continue processing.</termdef> It is <termref def="dt-implementation-defined">implementation-defined</termref> whether the error is signaled or the recovery
               action is taken. If the processor chooses to signal the error rather than taking the
               recovery action, the error is then treated in the same way as a <termref def="dt-nonrec-dynamic-error"/> and is therefore eligible to be caught using
                  <elcode>xsl:try</elcode>/<elcode>xsl:catch</elcode>.</p>
            <p>
               <termdef id="dt-optional-recovery-action" term="optional recovery action">If an
                  implementation chooses to recover from a <termref def="dt-recoverable-error">recoverable dynamic error</termref>, it <rfc2119>must</rfc2119> take the
                     <term>optional recovery action</term> defined for that error condition in this
                  specification.</termdef>
            </p>
            <imp-def-feature>Where the specification provides a choice between signaling a dynamic
               error or recovering, the decision that is made (but not the recovery action itself)
               is <termref def="dt-implementation-defined"/>.</imp-def-feature>
            <p>When the implementation makes the choice between signaling a dynamic error or
               recovering, it is not restricted in how it makes the choice; for example, it
                  <rfc2119>may</rfc2119> provide options that can be set by the user. When an
               implementation chooses to recover from a dynamic error, it <rfc2119>may</rfc2119>
               also take other action, such as logging a warning message.</p>
            <p>
               <termdef id="dt-nonrec-dynamic-error" term="non-recoverable dynamic error">A <termref def="dt-dynamic-error">dynamic error</termref> that is not recoverable is
                  referred to as a <term>non-recoverable dynamic error</term>. When a
                  non-recoverable dynamic error occurs, the <termref def="dt-processor">processor</termref>
                  <rfc2119>must</rfc2119> signal the error, and <phrase diff="add" at="B">(unless
                     the error is caught using <elcode>xsl:catch</elcode>)</phrase> the
                  transformation fails.</termdef>
            </p>
            <note diff="add" at="B">
               <p>The term <term>non-recoverable</term> is retained from earlier XSLT versions, and
                  implies that the processor will not recover from the error on its own initiative.
                  However, the introduction of <elcode>xsl:try</elcode> and
                     <elcode>xsl:catch</elcode> in XSLT 2.1 means that such errors can now be
                  recovered by means of application logic.</p>
            </note>
            <p>Because different implementations may optimize execution of the <termref def="dt-stylesheet">stylesheet</termref> in different ways, the detection of
               dynamic errors is to some degree <termref def="dt-implementation-dependent">implementation-dependent</termref>. In cases where an implementation is able to
               produce the <termref def="dt-final-result-tree">final result trees</termref> without
               evaluating a particular construct, the implementation is never
                  <rfc2119>required</rfc2119> to evaluate that construct solely in order to
               determine whether doing so causes a dynamic error. For example, if a <termref def="dt-variable">variable</termref> is declared but never referenced, an
               implementation <rfc2119>may</rfc2119> choose whether or not to evaluate the variable
               declaration, which means that if evaluating the variable declaration causes a dynamic
               error, some implementations will signal this error and others will not.</p>
            <p>There are some cases where this specification requires that a construct <rfc2119>must
                  not</rfc2119> be evaluated: for example, the content of an <elcode>xsl:if</elcode>
               instruction <rfc2119>must not</rfc2119> be evaluated if the test condition is false.
               This means that an implementation <rfc2119>must not</rfc2119> signal any dynamic
               errors that would arise if the construct were evaluated.</p>
            <p>An implementation <rfc2119>may</rfc2119> signal a <termref def="dt-dynamic-error">dynamic error</termref> before any source document is available, but only if it
               can determine that the error would be signaled for every possible source document and
               every possible set of parameter values. For example, some <termref def="circularity">circularity</termref> errors fall into this category: see <specref ref="circularity"/>.</p>
            <p diff="add" at="B">There are also some <termref def="dt-dynamic-error">dynamic
                  errors</termref> where the specification gives a processor license to signal the
               error during the analysis phase even if the construct might never be executed; an
               example is the use of an invalid QName as a literal argument to a function such as
                  <function>key</function>, or the use of an invalid regular expression in the
                  <code>regex</code> attribute of the <elcode>xsl:analyze-string</elcode>
               instruction.</p>
            <p>The XPath specification states (see <xspecref spec="XP21" ref="id-kinds-of-errors"/>)
               that if any expression (at any level) can be evaluated during the analysis phase
               (because all its explicit operands are known and it has no dependencies on the
               dynamic context), then any error in performing this evaluation <rfc2119>may</rfc2119>
               be reported as a static error. For XPath expressions used in an XSLT stylesheet,
               however, any such errors <rfc2119>must not</rfc2119> be reported as static errors in
               the stylesheet unless they would occur in every possible evaluation of that
               stylesheet; instead, they must be signaled as dynamic errors, and signaled only if
               the XPath expression is actually evaluated.</p>
            <example>
               <head>Errors in Constant Subexpressions</head>
               <p>An XPath processor may report statically that the expression <code>1 div 0</code>
                  fails with a "divide by zero" error. But suppose this XPath expression occurs in
                  an XSLT construct such as:</p>
               <eg xml:space="preserve">&lt;xsl:choose&gt;
  &lt;xsl:when test="system-property('xsl:version') = '1.0'"&gt;
    &lt;xsl:value-of select="1 div 0"/&gt;
  &lt;/xsl:when&gt;
  &lt;xsl:otherwise&gt;
    &lt;xsl:value-of select="xs:double('INF')"/&gt;
  &lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;</eg>
               <p>Then the XSLT processor must not report an error, because the relevant XPath
                  construct appears in a context where it will never be executed by an XSLT 2.0
                     <phrase diff="chg" at="A">or 2.1</phrase> processor. (An XSLT 1.0 processor
                  will execute this code successfully, returning positive infinity, because it uses
                  double arithmetic rather than decimal arithmetic.)</p>
            </example>
            <p>
               <termdef id="dt-type-error" term="type errors">Certain errors are classified as
                     <term>type errors</term>. A type error occurs when the value supplied as input
                  to an operation is of the wrong type for that operation, for example when an
                  integer is supplied to an operation that expects a node.</termdef> If a type error
               occurs in an instruction that is actually evaluated, then it <rfc2119>must</rfc2119>
               be signaled in the same way as a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>. Alternatively, an implementation
                  <rfc2119>may</rfc2119> signal a type error during the analysis phase in the same
               way as a <termref def="dt-static-error">static error</termref>, even if it occurs in
               part of the stylesheet that is never evaluated, provided it can establish that
               execution of a particular construct would never succeed.</p>
            <p>It is <termref def="dt-implementation-defined">implementation-defined</termref>
               whether type errors are signaled statically.</p>
            <imp-def-feature>It is <termref def="dt-implementation-defined"/> whether type errors
               are signaled statically.</imp-def-feature>
            <example>
               <head>A Type Error</head>
               <p diff="chg" at="D">The following construct contains a type error, because
                     <code>42</code> is not allowed as the value of the <code>select</code>
                  expression of the <elcode>xsl:number</elcode> instruction (it must be a node). An
                  implementation <rfc2119>may</rfc2119> optionally signal this as a static error,
                  even though the offending instruction will never be evaluated, and the type error
                  would therefore never be signaled as a dynamic error.</p>
               <eg role="error" xml:space="preserve" diff="chg" at="D">&lt;xsl:if test="false()"&gt;
  &lt;xsl:number select="42"/&gt;
&lt;/xsl:if&gt;</eg>
               <p>On the other hand, in the following example it is not possible to determine
                  statically whether the operand of <phrase diff="chg" at="D"><elcode>xsl:number</elcode></phrase> will have a suitable dynamic type. An
                  implementation <rfc2119>may</rfc2119> produce a warning in such cases, but it
                     <rfc2119>must not</rfc2119> treat it as an error.</p>
               <eg xml:space="preserve" diff="chg" at="D">&lt;xsl:template match="para"&gt;
  &lt;xsl:param name="p" as="item()"/&gt;
  &lt;xsl:number select="$p"/&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <p>If more than one error arises, an implementation is not <rfc2119>required</rfc2119>
               to signal any errors other than the first one that it detects. It is <termref def="dt-implementation-dependent">implementation-dependent</termref> which of the
               several errors is signaled. This applies both to static errors and to dynamic errors.
               An implementation is allowed to signal more than one error, but if any errors have
               been signaled, it <rfc2119>must not</rfc2119> finish as if the transformation were
               successful.</p>
            <p>When a transformation signals one or more dynamic errors, the final state of any
               persistent resources updated by the transformation is <termref def="dt-implementation-dependent">implementation-dependent</termref>.
               Implementations are not <rfc2119>required</rfc2119> to restore such resources to
               their initial state. In particular, where a transformation produces multiple result
               documents, it is possible that one or more serialized result documents
                  <rfc2119>may</rfc2119> be written successfully before the transformation
               terminates, but the application cannot rely on this behavior.</p>
            <p>Everything said above about error handling applies equally to errors in evaluating
               XSLT instructions, and errors in evaluating XPath <termref def="dt-expression">expressions</termref>. Static errors and dynamic errors may occur in both
               cases.</p>
            <p>
               <termdef id="dt-serialization-error" term="serialization error">If a transformation
                  has successfully produced a <termref def="dt-final-result-tree">final result
                     tree</termref>, it is still possible that errors may occur in serializing the
                  result tree. For example, it may be impossible to serialize the result tree using
                  the encoding selected by the user. Such an error is referred to as a
                     <term>serialization error</term>.</termdef> If the processor performs
               serialization, then it <rfc2119>must</rfc2119> do so as specified in <specref ref="serialization"/>, and in particular it <rfc2119>must</rfc2119> signal any
               serialization errors that occur.</p>
            <p>Errors are identified by a QName. For errors defined in this specification, the
               namespace of the QName is always <code>http://www.w3.org/2005/xqt-errors</code> (and
               is therefore not given explicitly), while the local part is an 8-character code in
               the form <var>PPSSNNNN</var>. Here <var>PP</var> is always <code>XT</code> (meaning
               XSLT), and <var>SS</var> is one of <code>SE</code> (static error), <code>DE</code>
               (dynamic error), <code>RE</code> (recoverable dynamic error), or <code>TE</code>
               (type error). Note that the allocation of an error to one of these categories is
               purely for convenience and carries no normative implications about the way the error
               is handled. Many errors, for example, can be reported either dynamically or
               statically. These error codes are used to label error conditions in this
               specification, and are summarized in <specref ref="error-summary"/>). <phrase diff="del" at="B">They are provided primarily for ease of reference.
                  Implementations <rfc2119>may</rfc2119> use these error codes when signaling
                  errors, but they are not <rfc2119>required</rfc2119> to do so. An API
                  specification, however, <rfc2119>may</rfc2119> require the use of error codes
                  based on these QNames.</phrase></p>
            <p>Errors defined in related specifications (<bibref ref="xpath-21"/>, <bibref ref="xpath-functions-11"/>
               <bibref ref="xslt-xquery-serialization-11"/>) use QNames with a similar structure, in the same
               namespace. When errors occur in processing XPath expressions, an XSLT processor
                  <rfc2119>should</rfc2119> use the original error code reported by the XPath
               processor, unless a more specific XSLT error code is available.</p>
            <p><phrase diff="add" at="B">Implementations <rfc2119>must</rfc2119> use the codes
                  defined in these specifications when signaling errors, to ensure that
                     <elcode>xsl:catch</elcode> behaves in an interoperable way across
                  implementations. Stylesheet authors should note, however, that there are many
                  examples of errors where more than one rule in this specification is violated, and
                  where the processor therefore has discretion in deciding which error code to
                  associate with the condition: there is therefore no guarantee that different
                  processors will always use the same error code for the same erroneous
                  input.</phrase></p>
            <p>Additional errors defined by an implementation (or by an application)
                  <rfc2119>may</rfc2119> use QNames in an implementation-defined (or user-defined)
               namespace without risk of collision.</p>

         </div2>
      </div1>
      <div1 id="stylesheet-structure">
         <head>Stylesheet Structure</head>
         <p>
            <termdef id="dt-stylesheet-module" term="stylesheet module">A <termref def="dt-stylesheet">stylesheet</termref> consists of one or more <term>stylesheet
                  modules</term>, each one forming all or part of an XML document.</termdef>
         </p>
         <note>
            <p>A stylesheet module is represented by an XDM element node (see <bibref ref="xpath-datamodel-11"/>). In the case of a standard stylesheet module, this will
               be an <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element. In
               the case of a simplified stylesheet module, it can be any element (not in the
                  <termref def="dt-xslt-namespace">XSLT namespace</termref>) that has an
                  <code>xsl:version</code> attribute.</p>
            <p>Although stylesheet modules will commonly be maintained in the form of documents
               conforming to XML 1.0 or XML 1.1, this specification does not mandate such a
               representation. As with <termref def="dt-source-tree">source trees</termref>, the way
               in which stylesheet modules are constructed, from textual XML or otherwise, is
               outside the scope of this specification.</p>
         </note>
         <p>A stylesheet module is either a standard stylesheet module or a simplified stylesheet
            module:</p>
         <ulist>
            <item>
               <p>
                  <termdef id="dt-standard-stylesheet-module" term="standard stylesheet module">A
                        <term>standard stylesheet module</term> is a tree, or part of a tree,
                     consisting of an <elcode>xsl:stylesheet</elcode> or
                        <elcode>xsl:transform</elcode> element (see <specref ref="stylesheet-element"/>) together with its descendant nodes and
                     associated attributes and namespaces.</termdef>
               </p>
            </item>
            <item>
               <p>
                  <termdef id="dt-simplified-stylesheet-module" term="simplified stylesheet module">A <term>simplified stylesheet module</term> is a tree, or part of a tree,
                     consisting of a <termref def="dt-literal-result-element">literal result
                        element</termref> together with its descendant nodes and associated
                     attributes and namespaces. This element is not itself in the XSLT namespace,
                     but it <rfc2119>must</rfc2119> have an <code>xsl:version</code> attribute,
                     which implies that it <rfc2119>must</rfc2119> have a namespace node that
                     declares a binding for the XSLT namespace. For further details see <specref ref="simplified-stylesheet"/>. </termdef>
               </p>
            </item>
         </ulist>
         <p>Both forms of stylesheet module (standard and simplified) can exist either as an entire
            XML document, or embedded as part of another XML document, typically but not necessarily
            a source document that is to be processed using the stylesheet.</p>
         <p>
            <termdef id="dt-standalone-stylesheet-module" term="standalone stylesheet module">A
                  <term>standalone stylesheet module</term> is a stylesheet module that comprises
               the whole of an XML document.</termdef>
         </p>
         <p>
            <termdef id="dt-embedded-stylesheet-module" term="embedded stylesheet module">An
                  <term>embedded stylesheet module</term> is a stylesheet module that is embedded
               within another XML document, typically the source document that is being
               transformed.</termdef> (see <specref ref="embedded"/>).</p>
         <p>There are thus four kinds of stylesheet module:</p>
         <slist>
            <sitem>standalone standard stylesheet modules</sitem>
            <sitem>standalone simplified stylesheet modules</sitem>
            <sitem>embedded standard stylesheet modules</sitem>
            <sitem>embedded simplified stylesheet modules</sitem>
         </slist>
         <div2 id="xslt-namespace">
            <head>XSLT Namespace</head>
            <p>
               <termdef id="dt-xslt-namespace" term="XSLT namespace">The <term>XSLT namespace</term>
                  has the URI <code>http://www.w3.org/1999/XSL/Transform</code>. It is used to
                  identify elements, attributes, and other names that have a special meaning defined
                  in this specification.</termdef>
            </p>
            <note>
               <p>The <code>1999</code> in the URI indicates the year in which the URI was allocated
                  by the W3C. It does not indicate the version of XSLT being used, which is
                  specified by attributes (see <specref ref="stylesheet-element"/> and <specref ref="simplified-stylesheet"/>).</p>
            </note>
            <p>XSLT <termref def="dt-processor">processors</termref>
               <rfc2119>must</rfc2119> use the XML namespaces mechanism <bibref ref="xml-names"/> to recognize elements and attributes from this namespace. Elements from the XSLT
               namespace are recognized only in the <termref def="dt-stylesheet">stylesheet</termref> and not in the source document. The complete list of
               XSLT-defined elements is specified in <specref ref="element-syntax-summary"/>.
                  <termref def="dt-implementation">Implementations</termref>
               <rfc2119>must not</rfc2119> extend the XSLT namespace with additional elements or
               attributes. Instead, any extension <rfc2119>must</rfc2119> be in a separate
               namespace. Any namespace that is used for additional instruction elements
                  <rfc2119>must</rfc2119> be identified by means of the <termref def="dt-extension-instruction">extension instruction</termref> mechanism specified
               in <specref ref="extension-instruction"/>.</p>
            <p>This specification uses a prefix of <code>xsl:</code> for referring to elements in
               the XSLT namespace. However, XSLT stylesheets are free to use any prefix, provided
               that there is a namespace declaration that binds the prefix to the URI of the XSLT
               namespace.</p>
            <note>
               <p>Throughout this specification, an element or attribute that is in no namespace, or
                  an <termref def="dt-expanded-qname">expanded-QName</termref> whose namespace part
                  is an empty sequence, is referred to as having a <term>null namespace
                  URI</term>.</p>
            </note>
            <note>
               <p>The conventions used for the names of <termref def="dt-xslt-element">XSLT
                     elements</termref>, attributes and functions are that names are all lower-case,
                  use hyphens to separate words, and use abbreviations only if they already appear
                  in the syntax of a related language such as XML or HTML. Names of types defined in
                  XML Schema are regarded as single words and are capitalized exactly as in XML
                  Schema. This sometimes leads to composite function names such as
                     <xfunction>current-dateTime</xfunction>.</p>
            </note>
         </div2>
         <div2 id="reserved-namespaces">
            <head>Reserved Namespaces</head>
            <p>
               <termdef id="dt-reserved-namespace" term="reserved namespace">The XSLT namespace,
                  together with certain other namespaces recognized by an XSLT processor, are
                  classified as <term>reserved namespaces</term> and <rfc2119>must</rfc2119> be used
                  only as specified in this and related specifications.</termdef> The reserved
               namespaces are those listed below.</p>
            <ulist>
               <item>
                  <p>The <termref def="dt-xslt-namespace">XSLT namespace</termref>, described in
                        <specref ref="xslt-namespace"/>, is reserved.</p>
               </item>
               <item>
                  <p>
                     <termdef id="dt-standard-function-namespace" term="standard function namespace">The <term>standard function namespace</term>
                        <code>http://www.w3.org/2005/xpath-functions</code> is used for functions in
                        the function library defined in <bibref ref="xpath-functions-11"/> and for
                        standard functions defined in this specification.</termdef>
                  </p>
               </item>
               <item>
                  <p diff="add" at="E"> The namespace
                        <code>http://www.w3.org/2005/xpath-functions/math</code> is used for
                     mathematical functions in the function library defined in <bibref ref="xpath-functions-11"/>. </p>
               </item>
               <item>
                  <p>
                     <termdef id="xml-namespace" term="XML namespace">The <term>XML
                        namespace</term>, defined in <bibref ref="xml-names"/> as
                           <code>http://www.w3.org/XML/1998/namespace</code>, is used for attributes
                        such as <code>xml:lang</code>, <code>xml:space</code>, and
                           <code>xml:id</code>.</termdef>
                  </p>
               </item>
               <item>
                  <p><termdef id="dt-schema-namespace" term="schema namespace">The <term>schema
                           namespace</term>
                        <code>http://www.w3.org/2001/XMLSchema</code> is used as defined in <bibref ref="xmlschema-1"/></termdef>. In a <termref def="dt-stylesheet">stylesheet</termref> this namespace may be used to refer to built-in schema
                     datatypes and to the constructor functions associated with those datatypes.</p>
               </item>
               <item>
                  <p><termdef id="dt-schema-instance-namespace" term="schema instance namespace">The
                           <term>schema instance namespace</term>
                        <code>http://www.w3.org/2001/XMLSchema-instance</code> is used as defined in
                           <bibref ref="xmlschema-1"/></termdef>. Attributes in this namespace, if
                     they appear in a <termref def="dt-stylesheet">stylesheet</termref>, are treated
                     by the XSLT processor in the same way as any other attributes.</p>
               </item>
               <item>
                  <p diff="add" at="B"><termdef id="dt-standard-error-namespace" term="standard error namespace">The <term>standard error namespace</term>
                        <code>http://www.w3.org/2005/xqt-errors</code> is used for error codes
                        defined in this specification and related specifications. It is also used
                        for the names of certain predefined variables accessible within the scope of
                        an <elcode>xsl:catch</elcode> element.</termdef></p>
               </item>
               <item>
                  <p>The namespace <code>http://www.w3.org/2000/xmlns/</code> is reserved for use as
                     described in <bibref ref="xml-names"/>. No element or attribute node can
                     have a name in this namespace, and although the prefix <code>xmlns</code> is
                     implicitly bound to this namespace, no namespace node will ever define this
                     binding.</p>
               </item>
            </ulist>

            <p>Reserved namespaces may be used without restriction to refer to the names of elements
               and attributes in source documents and result documents. As far as the XSLT processor
               is concerned, reserved namespaces other than the XSLT namespace may be used without
               restriction in the names of <termref def="dt-literal-result-element">literal result
                  elements</termref> and <termref def="dt-data-element">user-defined data
                  elements</termref>, and in the names of attributes of literal result elements or
               of <termref def="dt-xslt-element">XSLT elements</termref>: but other processors
                  <rfc2119>may</rfc2119> impose restrictions or attach special meaning to them.
               Reserved namespaces <rfc2119>must not</rfc2119> be used, however, in the names of
               stylesheet-defined objects such as <termref def="dt-variable">variables</termref> and
                  <termref def="dt-stylesheet-function">stylesheet functions</termref>.</p>
            <note>
               <p>With the exception of the XML namespace, any of the above namespaces that are used
                  in a stylesheet must be explicitly declared with a namespace declaration. Although
                  conventional prefixes are used for these namespaces in this specification, any
                  prefix may be used in a user stylesheet.</p>
            </note>
            <p>
               <error spec="XT" type="static" class="SE" code="0080">
                  <p>It is a <termref def="dt-static-error">static error</termref> to use a <termref def="dt-reserved-namespace">reserved namespace</termref> in the name of a
                        <termref def="dt-named-template">named template</termref>, a <termref def="dt-mode">mode</termref>, an <termref def="dt-attribute-set">attribute
                        set</termref>, a <termref def="dt-key">key</termref>, a <termref def="dt-decimal-format">decimal-format</termref>, a <termref def="dt-variable">variable</termref> or <termref def="dt-parameter">parameter</termref>, a <termref def="dt-stylesheet-function">stylesheet
                        function</termref>, a named <termref def="dt-output-definition">output
                        definition</termref>, or a <termref def="dt-character-map">character
                        map</termref>.</p>
               </error>
            </p>

         </div2>
         <div2 id="extension-attributes">
            <head>Extension Attributes</head>
            <p>
               <termdef id="dt-extension-attribute" term="extension attribute">An element from the
                  XSLT namespace may have any attribute not from the XSLT namespace, provided that
                  the <termref def="dt-expanded-qname">expanded-QName</termref> (see <bibref ref="xpath-21"/>) of the attribute has a non-null namespace URI. These
                  attributes are referred to as <term>extension attributes</term>.</termdef> The
               presence of an extension attribute <rfc2119>must not</rfc2119> cause the <termref def="dt-final-result-tree">final result trees</termref> produced by the
               transformation to be different from the result trees that a conformant XSLT <phrase diff="chg" at="A">2.1</phrase> processor might produce. They <rfc2119>must
                  not</rfc2119> cause the processor to fail to signal an error that a conformant
               processor is required to signal. This means that an extension attribute <rfc2119>must
                  not</rfc2119> change the effect of any <termref def="dt-instruction">instruction</termref> except to the extent that the effect is <termref def="dt-implementation-defined">implementation-defined</termref> or <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p>
            <p>Furthermore, if serialization is performed using one of the serialization methods
                  <code>xml</code>, <code>xhtml</code>, <code>html</code>, or <code>text</code>
               described in <bibref ref="xslt-xquery-serialization-11"/>, the presence of an extension attribute
               must not cause the serializer to behave in a way that is inconsistent with the
               mandatory provisions of that specification.</p>
            <note>
               <p>
                  <termref def="dt-extension-attribute">Extension attributes</termref> may be used
                  to modify the behavior of <termref def="dt-extension-function">extension
                     functions</termref> and <termref def="dt-extension-instruction">extension
                     instructions</termref>. They may be used to select processing options in cases
                  where the specification leaves the behavior <termref def="dt-implementation-defined">implementation-defined</termref> or <termref def="dt-implementation-dependent">implementation-dependent</termref>. They may
                  also be used for optimization hints, for diagnostics, or for documentation.</p>
               <p>
                  <termref def="dt-extension-attribute">Extension attributes</termref>
                  <rfc2119>may</rfc2119> also be used to influence the behavior of the serialization
                  methods <code>xml</code>, <code>xhtml</code>, <code>html</code>, or
                     <code>text</code>, to the extent that the behavior of the serialization method
                  is <termref def="dt-implementation-defined">implementation-defined</termref> or
                     <termref def="dt-implementation-dependent">implementation-dependent</termref>.
                  For example, an extension attribute might be used to define the amount of
                  indentation to be used when <code>indent="yes"</code> is specified. If a
                  serialization method other than one of these four is requested (using a prefixed
                  QName in the method parameter) then extension attributes may influence its
                  behavior in arbitrary ways. Extension attributes <rfc2119>must not</rfc2119> be
                  used to cause the four standard serialization methods to behave in a
                  non-conformant way, for example by failing to report serialization errors that a
                  serializer is <rfc2119>required</rfc2119> to report. An implementation that wishes
                  to provide such options must create a new serialization method for the
                  purpose.</p>
               <p>An implementation that does not recognize the name of an extension attribute, or
                  that does not recognize its value, <rfc2119>must</rfc2119> perform the
                  transformation as if the extension attribute were not present. As always, it is
                  permissible to produce warning messages.</p>
               <p>The namespace used for an extension attribute will be copied to the <termref def="dt-result-tree">result tree</termref> in the normal way if it is in scope
                  for a <termref def="dt-literal-result-element">literal result element</termref>.
                  This can be prevented using the <code>[xsl:]exclude-result-prefixes</code>
                  attribute.</p>
            </note>
            <example>
               <head>An Extension Attribute for <code>xsl:message</code>
               </head>
               <p>The following code might be used to indicate to a particular implementation that
                  the <elcode>xsl:message</elcode> instruction is to ask the user for confirmation
                  before continuing with the transformation:</p>
               <eg xml:space="preserve">&lt;xsl:message abc:pause="yes"
    xmlns:abc="http://vendor.example.com/xslt/extensions"&gt;
       Phase 1 complete
&lt;/xsl:message&gt;
</eg>
               <p>Implementations that do not recognize the namespace
                     <code>http://vendor.example.com/xslt/extensions</code> will simply ignore the
                  extra attribute, and evaluate the <elcode>xsl:message</elcode> instruction in the
                  normal way.</p>
            </example>
            <p>
               <error spec="XT" type="static" class="SE" code="0090">
                  <p>It is a <termref def="dt-static-error">static error</termref> for an element
                     from the XSLT namespace to have an attribute whose namespace is either null
                     (that is, an attribute with an unprefixed name) or the XSLT namespace, other
                     than attributes defined for the element in this document.</p>
               </error>
            </p>
         </div2>
         <div2 id="xslt-media-type">
            <head>XSLT Media Type</head>
            <p>The media type <code>application/xslt+xml</code>
               <phrase diff="chg" at="A">has been</phrase> registered for XSLT stylesheet
               modules.</p>
            <p>The definition of the media type is at <bibref ref="XSLT-Mime-Type"/>.</p>
            <p>This media type <rfc2119>should</rfc2119> be used for an XML document containing a
                  <termref def="dt-standard-stylesheet-module">standard stylesheet module</termref>
               at its top level, and it <rfc2119>may</rfc2119> also be used for a <termref def="dt-simplified-stylesheet-module">simplified stylesheet module</termref>. It
                  <rfc2119>should not</rfc2119> be used for an XML document containing an <termref def="dt-embedded-stylesheet-module">embedded stylesheet module</termref>.</p>
         </div2>
         <div2 id="standard-attributes">
            <head>Standard Attributes</head>
            <p>
               <termdef id="dt-standard-attributes" term="standard attributes">There are a number of
                     <term>standard attributes</term> that may appear on any <termref def="dt-xslt-element">XSLT element</termref>: specifically
                  <code>version</code>, <code>exclude-result-prefixes</code>,
                     <code>extension-element-prefixes</code>, <code>xpath-default-namespace</code>,
                     <code>default-collation</code>, and <code>use-when</code>.</termdef>
            </p>
            <p>These attributes may also appear on a <termref def="dt-literal-result-element">literal result element</termref>, but in this case, to distinguish them from
               user-defined attributes, the names of the attributes are in the <termref def="dt-xslt-namespace">XSLT namespace</termref>. They are thus typically written
               as <code>xsl:version</code>, <code>xsl:exclude-result-prefixes</code>,
                  <code>xsl:extension-element-prefixes</code>,
                  <code>xsl:xpath-default-namespace</code>, <code>xsl:default-collation</code>, or
                  <code>xsl:use-when</code>.</p>
            <p>It is <rfc2119>recommended</rfc2119> that all these attributes should also be
               permitted on <termref def="dt-extension-instruction">extension
               instructions</termref>, but this is at the discretion of the implementer of each
               extension instruction. They <rfc2119>may</rfc2119> also be permitted on <termref def="dt-data-element">user-defined data elements</termref>, though they will only
               have any useful effect in the case of data elements that are designed to behave like
               XSLT declarations or instructions.</p>
            <p>In the following descriptions, these attributes are referred to generically as
                  <code>[xsl:]version</code>, and so on.</p>
            <p>These attributes all affect the element they appear on, together with any elements
               and attributes that have that element as an ancestor. The two forms with and without
               the XSLT namespace have the same effect; the XSLT namespace is used for the attribute
               if and only if its parent element is <emph>not</emph> in the XSLT namespace.</p>
            <p>In the case of <code>[xsl:]version</code>,
               <code>[xsl:]xpath-default-namespace</code>, and <code>[xsl:]default-collation</code>,
               the value can be overridden by a different value for the same attribute appearing on
               a descendant element. The effective value of the attribute for a particular
               stylesheet element is determined by the innermost ancestor-or-self element on which
               the attribute appears.</p>
            <p>In an <termref def="dt-embedded-stylesheet-module">embedded stylesheet
                  module</termref>, <termref def="dt-standard-attributes">standard
                  attributes</termref> appearing on ancestors of the outermost element of the
               stylesheet module have no effect.</p>
            <p>In the case of <code>[xsl:]exclude-result-prefixes</code> and
                  <code>[xsl:]extension-element-prefixes</code> the values are cumulative. For these
               attributes, the value is given as a whitespace-separated list of namespace prefixes,
               and the effective value for an element is the combined set of namespace URIs
               designated by the prefixes that appear in this attribute for that element and any of
               its ancestor elements. Again, the two forms with and without the XSLT namespace are
               equivalent.</p>
            <p>The effect of the <code>[xsl:]use-when</code> attribute is described in <specref ref="conditional-inclusion"/>.</p>
            <p>Because these attributes may appear on any <termref def="dt-xslt-element">XSLT
                  element</termref>, they are not listed in the syntax summary of each individual
               element. Instead
               <!--<phrase diff="add" at="T">(with the exception of <code>[xsl:]use-when</code>)</phrase>-->
               they are listed and described in the entry for the <elcode>xsl:stylesheet</elcode>
               and <elcode>xsl:transform</elcode> elements only. This reflects the fact that these
               attributes are often used on the <elcode>xsl:stylesheet</elcode> element only, in
               which case they apply to the entire <termref def="dt-stylesheet-module">stylesheet
                  module</termref>.</p>
            <p>Note that the effect of these attributes does <emph>not</emph> extend to <termref def="dt-stylesheet-module">stylesheet modules</termref> referenced by
                  <elcode>xsl:include</elcode> or <elcode>xsl:import</elcode> declarations.</p>
            <p>For the detailed effect of each attribute, see the following sections:</p>
            <glist>
               <gitem>
                  <label>
                     <code>[xsl:]version</code>
                  </label>
                  <def>
                     <p>see <specref ref="backwards"/> and <specref ref="forwards"/>
                     </p>
                  </def>
               </gitem>
               <gitem>
                  <label>
                     <code>[xsl:]xpath-default-namespace</code>
                  </label>
                  <def>
                     <p>see <specref ref="unprefixed-qnames"/>
                     </p>
                  </def>
               </gitem>
               <gitem>
                  <label>
                     <code>[xsl:]exclude-result-prefixes</code>
                  </label>
                  <def>
                     <p>see <specref ref="lre-namespaces"/>
                     </p>
                  </def>
               </gitem>
               <gitem>
                  <label>
                     <code>[xsl:]extension-element-prefixes</code>
                  </label>
                  <def>
                     <p>see <specref ref="extension-instruction"/>
                     </p>
                  </def>
               </gitem>
               <gitem>
                  <label>
                     <code>[xsl:]use-when</code>
                  </label>
                  <def>
                     <p>see <specref ref="conditional-inclusion"/>
                     </p>
                  </def>
               </gitem>
               <gitem>
                  <label>
                     <code>[xsl:]default-collation</code>
                  </label>
                  <def>
                     <p>see <specref ref="default-collation-attribute"/>
                     </p>
                  </def>
               </gitem>
            </glist>
         </div2>
         <div2 id="stylesheet-element">
            <head>Stylesheet Element</head>
            <e:element-syntax name="stylesheet">
               <e:attribute name="id">
                  <e:data-type name="id"/>
               </e:attribute>
               <e:attribute name="extension-element-prefixes">
                  <e:data-type name="tokens"/>
               </e:attribute>
               <e:attribute name="exclude-result-prefixes">
                  <e:data-type name="tokens"/>
               </e:attribute>
               <e:attribute name="version" required="yes">
                  <e:data-type name="number"/>
               </e:attribute>
               <e:attribute name="xpath-default-namespace">
                  <e:data-type name="uri"/>
               </e:attribute>
               <e:attribute name="default-validation">
                  <e:constant value="preserve"/>
                  <e:constant value="strip"/>
               </e:attribute>
               <e:attribute name="default-collation">
                  <e:data-type name="uri-list"/>
               </e:attribute>
               <e:attribute name="default-mode">
                  <e:data-type name="qname"/>
                  <e:constant value="#unnamed"/>
               </e:attribute>
               <e:attribute name="input-type-annotations">
                  <e:constant value="preserve"/>
                  <e:constant value="strip"/>
                  <e:constant value="unspecified"/>
               </e:attribute>
               <e:sequence>
                  <e:element repeat="zero-or-more" name="import"/>
                  <e:model name="other-declarations"/>
               </e:sequence>
               <e:allowed-parents/>
            </e:element-syntax>
            <e:element-syntax name="transform">
               <e:attribute name="id">
                  <e:data-type name="id"/>
               </e:attribute>
               <e:attribute name="extension-element-prefixes">
                  <e:data-type name="tokens"/>
               </e:attribute>
               <e:attribute name="exclude-result-prefixes">
                  <e:data-type name="tokens"/>
               </e:attribute>
               <e:attribute name="version" required="yes">
                  <e:data-type name="number"/>
               </e:attribute>
               <e:attribute name="xpath-default-namespace">
                  <e:data-type name="uri"/>
               </e:attribute>
               <e:attribute name="default-validation">
                  <e:constant value="preserve"/>
                  <e:constant value="strip"/>
               </e:attribute>
               <e:attribute name="default-collation">
                  <e:data-type name="uri-list"/>
               </e:attribute>
               <e:attribute name="default-mode">
                  <e:data-type name="qname"/>
                  <e:constant value="#unnamed"/>
               </e:attribute>
               <e:attribute name="input-type-annotations">
                  <e:constant value="preserve"/>
                  <e:constant value="strip"/>
                  <e:constant value="unspecified"/>
               </e:attribute>
               <e:sequence>
                  <e:element repeat="zero-or-more" name="import"/>
                  <e:model name="other-declarations"/>
               </e:sequence>
               <e:allowed-parents/>
            </e:element-syntax>
            <p>A stylesheet module is represented by an <elcode>xsl:stylesheet</elcode> element in
               an XML document. <elcode>xsl:transform</elcode> is allowed as a synonym for
                  <elcode>xsl:stylesheet</elcode>; everything this specification says about the
                  <elcode>xsl:stylesheet</elcode> element applies equally to
                  <elcode>xsl:transform</elcode>.</p>
            <p>An <elcode>xsl:stylesheet</elcode> element <rfc2119>must</rfc2119> have a
                  <code>version</code> attribute, indicating the version of XSLT that the stylesheet
               module requires.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0110">
                  <p>The value of the <code>version</code> attribute <rfc2119>must</rfc2119> be a
                     number: specifically, it <rfc2119>must</rfc2119> be a a valid instance of the
                     type <code>xs:decimal</code> as defined in <bibref ref="xmlschema-2"/>.</p>
               </error>
            </p>
            <p diff="chg" at="D">The <code>version</code> attribute is intended to indicate the
               version of the XSLT specification against which the stylesheet is written. In a
               stylesheet written to use XSLT 2.1, the value <rfc2119>should</rfc2119> normally be
               set to <code>2.1</code>. If the value is numerically less than <code>2.1</code>, the
               stylesheet is processed using the rules for <termref def="dt-backwards-compatible-behavior">backwards compatible behavior</termref>
               (see <specref ref="backwards"/>). If the value is numerically greater than
                  <code>2.1</code>, the stylesheet is processed using the rules for <termref def="dt-forwards-compatible-behavior"/> (see
                  <specref ref="forwards"/>).</p>

            <!--For this version of XSLT, the value <rfc2119>should</rfc2119> normally
be <code>
                  <phrase diff="chg" at="A">2.1</phrase>
               </code>.  A value of <code>1.0</code> indicates that the stylesheet module
was written with the intention that it <rfc2119>should</rfc2119> be processed using an XSLT 1.0 processor,
               <phrase diff="add" at="D">while a value of <code>2.0</code> indicates that the module
                  was intended to be processed using an XSLT 2.0 processor</phrase>.</p>
            <p>If a <termref def="dt-stylesheet">stylesheet</termref>
that specifies <code>[xsl:]version="1.0"</code> in the
outermost element of the <termref def="dt-principal-stylesheet-module">principal
stylesheet module</termref> (that is, <code>version="1.0"</code> in the case of a 
<termref def="dt-standard-stylesheet-module">standard stylesheet module</termref>, or
<code>xsl:version="1.0"</code> in the case of a <termref def="dt-simplified-stylesheet-module">simplified
stylesheet module</termref>) is submitted to an XSLT <phrase diff="chg" at="A">2.1</phrase> processor, the processor <rfc2119>should</rfc2119> output
a warning advising the user of possible incompatibilities, unless the user has requested otherwise. 
The processor <rfc2119>must</rfc2119> then process the stylesheet
using the rules for <termref def="dt-backwards-compatible-behavior"/>.
These rules require that if the processor does not support 
<termref def="dt-backwards-compatible-behavior"/>, it <rfc2119>must</rfc2119>
signal an error and <rfc2119>must not</rfc2119> execute the transformation.</p>
            <p>When the value of the <code>version</code> attribute is greater than <phrase diff="chg" at="A">2.1</phrase>, 
<termref def="dt-forwards-compatible-behavior">forwards compatible behavior</termref> 
is enabled (see <specref ref="forwards"/>).</p>
            <note>
               <p>XSLT 1.0 allowed the <code>[xsl:]version</code> attribute to take any numeric value,
and specified that if the value was not equal to 1.0, the <termref def="dt-stylesheet">stylesheet</termref> would be executed in
forwards compatible mode. XSLT 2.0 <phrase diff="chg" at="A">and 2.1</phrase>continue to allow the attribute to take any unsigned decimal value.
A software product that includes both an XSLT <phrase diff="chg" at="A">2.1</phrase> processor and
<phrase diff="chg" at="A">a processor supporting a different XSLT version</phrase> (or that can execute as either) may use the <code>[xsl:]version</code> attribute to 
decide which processor to invoke; such behavior is outside the scope of this specification. 
When the stylesheet is executed with an XSLT <phrase diff="chg" at="A">2.1</phrase> processor, the value
<code>1.0</code> is taken to indicate that the stylesheet module
was written with XSLT 1.0
in mind: if this value appears on the outermost element of the principal stylesheet module then
an XSLT <phrase diff="chg" at="A">2.1</phrase> processor will either reject the stylesheet or execute it in backwards compatible
mode, as described above. 
Setting <code>version="<phrase diff="chg" at="A">2.1</phrase>"</code> indicates that the <termref def="dt-stylesheet">stylesheet</termref> is to be
executed with neither backwards nor forwards compatible behavior enabled. Any other value less than
<code>2.0</code> enables backwards compatible behavior, while any value greater than <code>
                     <phrase diff="chg" at="A">2.1</phrase>
                  </code>
enables forwards compatible behavior.</p>
               
               <p>When developing a <termref def="dt-stylesheet">stylesheet</termref> that is designed to execute under either XSLT 1.0 or XSLT 2.0,
the recommended practice is to create two alternative <termref def="dt-stylesheet-module">stylesheet modules</termref>, 
one specifying
<code>version="1.0"</code>, and the other specifying <code>version="2.0"</code>; these
modules can use <elcode>xsl:include</elcode> or <elcode>xsl:import</elcode> to incorporate 
the common code. When running under an XSLT 1.0 processor, the <code>version="1.0"</code> module can
be selected as the <termref def="dt-principal-stylesheet-module">principal stylesheet module</termref>;
when running under an XSLT 2.0 processor, the <code>version="2.0"</code> module can
be selected as the <termref def="dt-principal-stylesheet-module">principal stylesheet module</termref>.
Stylesheet modules that are included or imported should specify <code>version="2.0"</code> if they make use of XSLT 2.0 facilities,
and <code>version="1.0"</code> otherwise.</p>
            </note>-->
            <p>The effect of the <code>input-type-annotations</code> attribute is described in
                  <specref ref="stripping-annotations"/>.</p>
            <p>The <code>default-validation</code> attribute defines the default value of the
                  <code>validation</code> attribute of all <elcode>xsl:document</elcode>,
                  <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                  <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>, and
                  <elcode>xsl:result-document</elcode> instructions, and of the
                  <code>xsl:validation</code> attribute of all <termref def="dt-literal-result-element">literal result elements</termref>. It also
               determines the validation applied to the implicit <termref def="dt-final-result-tree">final result tree</termref> created in the absence of an
                  <elcode>xsl:result-document</elcode> instruction. This default applies within the
                  <termref def="dt-stylesheet-module">stylesheet module</termref>: it does not
               extend to included or imported stylesheet modules. If the attribute is omitted, the
               default is <code>strip</code>. The permitted values are <code>preserve</code> and
                  <code>strip</code>. For details of the effect of this attribute, see <specref ref="validation"/>.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0120">
                  <p>An <elcode>xsl:stylesheet</elcode> element <rfc2119>must not</rfc2119> have any
                     text node children.</p>
               </error> (This rule applies after stripping of <termref def="dt-whitespace-text-node">whitespace text nodes</termref> as described in <specref ref="stylesheet-stripping"/>.)</p>
            <p>
               <termdef id="dt-top-level" term="top-level">An element occurring as a child of an
                     <elcode>xsl:stylesheet</elcode> element is called a <term>top-level</term>
                  element.</termdef>
            </p>
            <p>
               <termdef id="dt-declaration" term="declaration">Top-level elements fall into two
                  categories: declarations, and user-defined data elements. Top-level elements whose
                  names are in the <termref def="dt-xslt-namespace">XSLT namespace</termref> are
                     <term>declarations</term>. Top-level elements in any other namespace are
                     <termref def="dt-data-element">user-defined data elements</termref> (see
                     <specref ref="user-defined-top-level"/>)</termdef>.</p>
            <p>The <termref def="dt-declaration">declaration</termref> elements permitted in the
                  <elcode>xsl:stylesheet</elcode> element are:</p>
            <slist>
               <sitem>
                  <elcode>xsl:import</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:include</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:attribute-set</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:character-map</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:decimal-format</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:function</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:import-schema</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:key</elcode>
               </sitem>
               <sitem>
                  <phrase diff="add" at="A">
                     <elcode>xsl:mode</elcode>
                  </phrase>
               </sitem>
               <sitem>
                  <elcode>xsl:namespace-alias</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:output</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:param</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:preserve-space</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:strip-space</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:template</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:variable</elcode>
               </sitem>
            </slist>
            <p>Note that the <elcode>xsl:variable</elcode> and <elcode>xsl:param</elcode> elements
               can act either as <termref def="dt-declaration">declarations</termref> or as <termref def="dt-instruction">instructions</termref>. A global variable or parameter is
               defined using a declaration; a local variable or parameter using an instruction.</p>
            <p>If there are <elcode>xsl:import</elcode> elements, these <rfc2119>must</rfc2119> come
               before any other elements. Apart from this, the child elements of the
                  <elcode>xsl:stylesheet</elcode> element may appear in any order. <phrase diff="chg" at="D">In most cases, the ordering of these elements does not affect
                  the results of the transformation; however, as described in <specref ref="conflict"/>, when two template rules with the same <termref def="dt-priority">priority</termref> match the same nodes, there are situations
                  where the order of the template rules will affect which is chosen.</phrase></p>
            <div3 id="default-collation-attribute">
               <head>The <code>default-collation</code> attribute</head>
               <p>The <code>default-collation</code> attribute is a <termref def="dt-standard-attributes">standard attribute</termref> that may appear on
                  any element in the XSLT namespace, or (as <code>xsl:default-collation</code>) on a
                     <termref def="dt-literal-result-element">literal result element</termref>.</p>
               <p>The attribute is used to specify the default collation used by all XPath
                  expressions appearing in the attributes of this element, or attributes of
                  descendant elements, unless overridden by another <code>default-collation</code>
                  attribute on an inner element. It also determines the collation used by certain
                  XSLT constructs (such as <elcode>xsl:key</elcode> and
                     <elcode>xsl:for-each-group</elcode>) within its scope.</p>
               <p>The value of the attribute is a whitespace-separated list of collation URIs. If
                  any of these URIs is a relative URI <phrase diff="add" at="F">reference</phrase>, then it is resolved relative to the base URI
                  of the attribute's parent element. If the implementation recognizes one or more of
                  the resulting absolute collation URIs, then it uses the first one that it
                  recognizes as the default collation.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0125">
                     <p>It is a <termref def="dt-static-error">static error</termref> if the value
                        of an <code>[xsl:]default-collation</code> attribute, after resolving
                        against the base URI, contains no URI that the implementation recognizes as
                        a collation URI.</p>
                  </error>
               </p>
               <note>
                  <p>The reason the attribute allows a list of collation URIs is that collation URIs
                     will often be meaningful only to one particular XSLT implementation.
                     Stylesheets designed to run with several different implementations can
                     therefore specify several different collation URIs, one for use with each. To
                     avoid the above error condition, it is possible to specify the Unicode
                     Codepoint Collation as the last collation URI in the list.</p>
               </note>
               <p>The <code>[xsl:]default-collation</code> attribute does not affect the collation
                  used by <code>xsl:sort</code>.</p>
            </div3>
            <div3 id="default-mode" diff="add" at="A">
               <head>The <code>default-mode</code> attribute</head>
               <p>The <code>default-mode</code> attribute defines the default value for the <termref def="dt-mode">mode</termref> attribute of all <elcode>xsl:template</elcode> and
                     <elcode>xsl:apply-templates</elcode> elements within the stylesheet module. It
                  also determines which mode is referred to when the token <code>#default</code> is
                  used in either of these attributes.</p>
               <p>The value <rfc2119>must</rfc2119> either be a <termref def="dt-lexical-qname">lexical QName</termref>, or the token <code>#unnamed</code> which refers to
                  the <termref def="dt-unnamed-mode">unnamed mode</termref>. It is not necessary for
                  the referenced mode to be explicitly declared in an <elcode>xsl:mode</elcode>
                  declaration. </p>
               <p>If the <code>default-mode</code> attribute is omitted, then the default mode for
                  the stylesheet module is the <termref def="dt-unnamed-mode">unnamed
                  mode</termref>. This is equivalent to specifying <code>#unnamed</code>.</p>
               <note>
                  <p>This attribute is provided to support an approach to stylesheet modularity in
                     which all the template rules for one <termref def="dt-mode">mode</termref> are
                     collected together into a single <termref def="dt-stylesheet-module">stylesheet
                        module</termref>. Using this attribute reduces the risk of forgetting to
                     specify the mode in one or more places where it is needed, and it also makes it
                     easier to reuse an existing stylesheet module that does not use modes in an
                     application where modes are needed to avoid conflicts with existing template
                     rules.</p>
               </note>
               <issue id="issue-chameleon-modes" status="open">
                  <p>Would it be useful to be able to specify the default mode for an included
                     module on the <elcode>xsl:include</elcode> element, in the style of chameleon
                     includes in XSD? The WG has discussed such a feature; it is recognized that it
                     would be useful, but it is not clear whether it would be useful enough to
                     justify the extra complexity.</p>
               </issue>
            </div3>
            <div3 id="user-defined-top-level">
               <head>User-defined Data Elements</head>
               <p>
                  <termdef id="dt-data-element" term="user-defined data element">In addition to
                        <termref def="dt-declaration">declarations</termref>, the
                        <elcode>xsl:stylesheet</elcode> element may contain among its children any
                     element not from the <termref def="dt-xslt-namespace">XSLT namespace</termref>,
                     provided that the <termref def="dt-expanded-qname">expanded-QName</termref> of
                     the element has a non-null namespace URI. Such elements are referred to as
                        <term>user-defined data elements</term>.</termdef>
               </p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0130">
                     <p>It is a <termref def="dt-static-error">static error</termref> if the
                           <elcode>xsl:stylesheet</elcode> element has a child element whose name
                        has a null namespace URI.</p>
                  </error>
               </p>
               <p>An implementation <rfc2119>may</rfc2119> attach an <termref def="dt-implementation-defined">implementation-defined</termref> meaning to
                  user-defined data elements that appear in particular namespaces. The set of
                  namespaces that are recognized for such data elements is <termref def="dt-implementation-defined">implementation-defined</termref>. The presence
                  of a user-defined data element <rfc2119>must not</rfc2119> change the behavior of
                     <termref def="dt-xslt-element">XSLT elements</termref> and functions defined in
                  this document; for example, it is not permitted for a user-defined data element to
                  specify that <elcode>xsl:apply-templates</elcode> should use different rules to
                  resolve conflicts. The constraints on what user-defined data elements can and
                  cannot do are exactly the same as the constraints on <termref def="dt-extension-attribute">extension attributes</termref>, described in
                     <specref ref="extension-attributes"/>. Thus, an implementation is always free
                  to ignore user-defined data elements, and <rfc2119>must</rfc2119> ignore such data
                  elements without giving an error if it does not recognize the namespace URI. </p>
               <imp-def-feature>The set of namespaces that are specially recognized by the
                  implementation (for example, for user-defined data elements, and <termref def="dt-extension-attribute">extension attributes</termref>) is <termref def="dt-implementation-defined"/>.</imp-def-feature>
               <imp-def-feature>The effect of user-defined data elements whose name is in a
                  namespace recognized by the implementation is <termref def="dt-implementation-defined"/>.</imp-def-feature>
               <p>User-defined data elements can provide, for example,</p>
               <ulist>
                  <item>
                     <p>information used by <termref def="dt-extension-instruction">extension
                           instructions</termref> or <termref def="dt-extension-function">extension
                           functions</termref> (see <specref ref="extension"/>),</p>
                  </item>
                  <item>
                     <p>information about what to do with any <termref def="dt-final-result-tree">final result tree</termref>,</p>
                  </item>
                  <item>
                     <p>information about how to construct <termref def="dt-source-tree">source
                           trees</termref>,</p>
                  </item>
                  <item>
                     <p>optimization hints for the <termref def="dt-processor">processor</termref>,</p>
                  </item>
                  <item>
                     <p>metadata about the stylesheet,</p>
                  </item>
                  <item>
                     <p>structured documentation for the stylesheet.</p>
                  </item>
               </ulist>
               <p>A <termref def="dt-data-element">user-defined data element</termref>
                  <rfc2119>must not</rfc2119> precede an <elcode>xsl:import</elcode> element within
                  a <termref def="dt-stylesheet-module">stylesheet module</termref>
                  <errorref spec="XT" class="SE" code="0200"/>
               </p>
            </div3>
         </div2>
         <div2 id="simplified-stylesheet">
            <head>Simplified Stylesheet Modules</head>
            <p>A simplified syntax is allowed for a <termref def="dt-stylesheet-module">stylesheet
                  module</termref> that defines only a single template rule for the document node.
               The stylesheet module may consist of just a <termref def="dt-literal-result-element">literal result element</termref> (see <specref ref="literal-result-element"/>)
               together with its contents. The literal result element must have an
                  <code>xsl:version</code> attribute (and it must therefore also declare the XSLT
               namespace). Such a stylesheet module is equivalent to a standard stylesheet module
               whose <elcode>xsl:stylesheet</elcode> element contains a <termref def="dt-template-rule">template rule</termref> containing the literal result
               element, minus its <code>xsl:version</code> attribute; the template rule has a match
                  <termref def="dt-pattern">pattern</termref> of <code>/</code>.</p>
            <example>
               <head>A Simplified Stylesheet</head>
               <p>For example:</p>
               <eg xml:space="preserve">&lt;html xsl:version="2.1"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns="http://www.w3.org/1999/xhtml"&gt;
  &lt;head&gt;
    &lt;title&gt;Expense Report Summary&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Total Amount: &lt;xsl:value-of select="expense-report/total"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</eg>
               <p>has the same meaning as</p>
               <eg xml:space="preserve">&lt;xsl:stylesheet version="2.1"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;xsl:template match="/"&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Expense Report Summary&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Total Amount: &lt;xsl:value-of select="expense-report/total"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</eg>
               <p>Note that it is not possible, using a simplified stylesheet, to request that the
                  serialized output contains a <code>DOCTYPE</code> declaration. This can only be
                  done by using a standard stylesheet module, and using the
                     <elcode>xsl:output</elcode> element.</p>
            </example>
            <p>More formally, a simplified stylesheet module is equivalent to the standard
               stylesheet module that would be generated by applying the following transformation to
               the simplified stylesheet module, invoking the transformation by calling the <termref def="dt-named-template">named template</termref>
               <code>expand</code>, with the containing literal result element as the <termref def="dt-context-node">context node</termref>: </p>
            <eg xml:space="preserve">&lt;xsl:stylesheet version="2.1"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template name="expand"&gt;
  &lt;xsl:element name="xsl:stylesheet"&gt;
    &lt;xsl:attribute name="version" select="@xsl:version"/&gt;
    &lt;xsl:element name="xsl:template"&gt;
      &lt;xsl:attribute name="match" select="'/'"/&gt;
      &lt;xsl:copy-of select="."/&gt;
    &lt;/xsl:element&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;  

&lt;/xsl:stylesheet&gt;</eg>
            <p>
               <error spec="XT" type="static" class="SE" code="0150">
                  <p>A <termref def="dt-literal-result-element">literal result element</termref>
                     that is used as the outermost element of a simplified stylesheet module
                        <rfc2119>must</rfc2119> have an <code>xsl:version</code> attribute.</p>
               </error> This indicates the version of XSLT that the stylesheet requires. For this
               version of XSLT, the value will normally be <code>
                  <phrase diff="chg" at="A">2.1</phrase>
               </code>; the value <rfc2119>must</rfc2119> be a valid instance of the type
                  <code>xs:decimal</code> as defined in <bibref ref="xmlschema-2"/>.</p>
            <p diff="del" at="D">Other <termref def="dt-literal-result-element">literal result
                  elements</termref> may also have an <code>xsl:version</code> attribute. When the
                  <code>xsl:version</code> attribute is numerically less than <code>2.0</code>,
               <termref def="dt-backwards-compatible-behavior"/> is enabled (see <specref ref="backwards"/>).
               When the <code>xsl:version</code> attribute is numerically greater than
                  <code>2.0</code>, <termref def="dt-forwards-compatible-behavior"/> is enabled (see <specref ref="forwards"/>).</p>
            <p>The allowed content of a literal result element when used as a simplified stylesheet
               is the same as when it occurs within a <termref def="dt-sequence-constructor">sequence constructor</termref>. Thus, a literal result element used as the
               document element of a simplified stylesheet cannot contain <termref def="dt-declaration">declarations</termref>. Simplified stylesheets therefore
               cannot use <termref def="dt-template-rule">template rules</termref>, <termref def="dt-global-variable">global variables</termref>, <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>, <termref def="dt-stylesheet-function">stylesheet functions</termref>, <termref def="dt-key">keys</termref>, <termref def="dt-attribute-set">attribute-sets</termref>, or
                  <termref def="dt-output-definition">output definitions</termref>. In turn this
               means that the only useful way to initiate the transformation is to supply a document
               node as the <phrase diff="chg" at="E"><termref def="dt-initial-context-item"/></phrase>, to be matched by the implicit <code>match="/"</code> template rule
               using the <termref def="dt-unnamed-mode">unnamed mode</termref>. </p>
         </div2>
         <div2 id="backwards" diff="chg" at="D">
            <head>Backwards Compatible Processing</head>
            <p><termdef id="dt-effective-version" term="effective version">The <term>effective
                     version</term> of an element in the stylesheet is the decimal value of the
                     <code>[xsl:]version</code> attribute (see <specref ref="standard-attributes"/>)
                  on that element or on the innermost ancestor element that has such an attribute,
                  excluding the <code>version</code> attribute on an <elcode>xsl:output</elcode>
                  element.</termdef></p>
            <p>
               <termdef id="dt-backwards-compatible-behavior" term="backwards compatible behavior">An element is processed with <term>backwards compatible behavior</term> if its
                     <termref def="dt-effective-version">effective version</termref> is less than
                     <code diff="chg" at="D">2.1</code>.</termdef>
            </p>
            <p>Specifically:</p>
            <ulist>
               <item>
                  <p>If the <termref def="dt-effective-version">effective version</termref> is equal
                     to 1.0, then the element is processed with XSLT 1.0 behavior as described in
                        <specref ref="backwards-1.0"/>.</p>
               </item>
               <item>
                  <p>If the <termref def="dt-effective-version">effective version</termref> is equal
                     to 2.0, then the element is processed with XSLT 2.0 behavior as described in
                        <specref ref="backwards-2.0"/>.</p>
               </item>
               <item>
                  <p>If the <termref def="dt-effective-version">effective version</termref> is any
                     other value less than 2.1, the <rfc2119>recommended</rfc2119> action is to
                     report a static error; however, processors <rfc2119>may</rfc2119> recognize
                     such values and process the element in an <termref def="dt-implementation-defined"/> way.</p>
                  <imp-def-feature>If the <termref def="dt-effective-version">effective
                        version</termref> of any element in the stylesheet is not 1.0 or 2.0 but is
                     less than 2.1, the <rfc2119>recommended</rfc2119> action is to report a static
                     error; however, processors <rfc2119>may</rfc2119> recognize such values and
                     process the element in an <termref def="dt-implementation-defined"/>
                     way.</imp-def-feature>
                  <note>
                     <p>XSLT 1.0 allowed the <code>version</code> attribute to take any decimal
                        value, and invoked forwards compatible processing for any value other than
                        1.0. XSLT 2.0 allowed the attribute to take any decimal value, and invoked
                        backwards compatible (i.e. 1.0-compatible) processing for any value less
                        than 2.0. Some stylesheets may therefore be encountered that use values
                        other than 1.0 or 2.0. In particular, the value 1.1 is sometimes
                        encountered, as it was used at one stage in a draft language proposal.</p>
                  </note>
               </item>
            </ulist>
            <p>These rules do not apply to the <elcode>xsl:output</elcode> element, whose
                  <code>version</code> attribute has an entirely different purpose: it is used to
               define the version of the output method to be used for serialization.</p>

            <p diff="del" at="D">An element that has an <code>[xsl:]version</code> attribute whose
               value is greater than or equal to <code>2.0</code> disables backwards compatible
               behavior for itself, its attributes, its descendants and their attributes. The
               compatibility behavior established by an element overrides any compatibility behavior
               established by an ancestor element.</p>

            <p>It is <termref def="dt-implementation-defined">implementation-defined</termref>
               whether a particular XSLT 2.1 implementation supports backwards compatible behavior
               for any XSLT version earlier than XSLT 2.1.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0160">
                  <p diff="chg" at="D">It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if an element has an <termref def="dt-effective-version">effective version</termref> of <var>V</var> (with
                        <var>V</var> &lt; 2.1) when the implementation does not support
                     backwards compatible behavior for XSLT version <var>V</var>.</p>
               </error>
            </p>
            <imp-def-feature>It is implementation-defined whether an <phrase diff="chg" at="D">XSLT
                  2.1</phrase> processor supports backwards compatible behavior for any XSLT version
               earlier than XSLT 2.1.</imp-def-feature>

            <note>
               <p>By making use of backwards compatible behavior, it is possible to write the
                  stylesheet in a way that ensures that its results when processed with an XSLT 2.1
                  processor are identical to the effects of processing the same stylesheet using
                     <phrase diff="chg" at="D">a processor for an earlier version of XSLT</phrase>.
                  To assist with transition, some parts of a stylesheet may be processed with
                  backwards compatible behavior enabled, and other parts with this behavior
                  disabled.</p>
               <p>All data values manipulated by an <phrase diff="chg" at="D">XSLT 2.1</phrase>
                  processor are defined by the XDM data model, whether or not the relevant
                  expressions use backwards compatible behavior. Because the same data model is used
                  in both cases, expressions are fully composable. The result of evaluating
                  instructions or expressions with backwards compatible behavior is fully defined in
                  the <phrase diff="chg" at="D">XSLT 2.1</phrase> and <phrase diff="chg" at="D">XPath 2.1</phrase> specifications, it is not defined by reference to <phrase diff="chg" at="D">earlier versions of the XSLT and XPath
                     specifications</phrase>. </p>

               <p>To write a stylesheet that makes use of <phrase diff="chg" at="D">features that
                     are new in version <var>N</var>, while also working with a processor that only
                     supports XSLT version <var>M</var> (<var>M</var> &lt; <var>N</var>)</phrase>, it is
                  necessary to understand both the rules for backwards compatible behavior in
                     <phrase diff="chg" at="D">XSLT version <var>N</var></phrase>, and the rules for
                  forwards compatible behavior in <phrase diff="chg" at="D">XSLT version
                        <var>M</var></phrase>. If the <elcode>xsl:stylesheet</elcode> element
                  specifies <code>version="2.0"</code>
                  <phrase diff="add" at="D">or <code>version="2.1"</code></phrase>, then an XSLT 1.0
                  processor will ignore XSLT 2.0 <phrase diff="add" at="D">and XSLT
                     2.1</phrase><termref def="dt-declaration">declarations</termref> that were not
                  defined in XSLT 1.0, for example <elcode>xsl:function</elcode> and
                     <elcode>xsl:import-schema</elcode>. If any new <phrase diff="chg" at="D">XSLT
                     2.1</phrase> instructions are used (for example <elcode>xsl:evaluate</elcode>
                  or <elcode>xsl:stream</elcode>), or if new <phrase diff="chg" at="D">XPath
                     2.1</phrase> features are used (for example, new functions, or <phrase diff="chg" at="D">let</phrase> expressions), then the stylesheet must provide
                  fallback behavior that relies only on facilities <phrase diff="chg" at="D">available in the earliest XSLT version supported</phrase>. The fallback
                  behavior can be invoked by using the <elcode>xsl:fallback</elcode> instruction, or
                  by testing the results of the <function>function-available</function> or
                     <function>element-available</function> functions, or by testing the value of
                  the <code>xsl:version</code> property returned by the
                     <function>system-property</function> function.</p>
            </note>

            <div3 id="backwards-1.0" diff="add" at="D">
               <head>XSLT 1.0 compatibility mode</head>
               <p><termdef id="dt-xslt-10-behavior" term="XSLT 1.0 behavior">An element in the stylesheet is processed
                     with <term>XSLT 1.0 behavior</term> if its <termref def="dt-effective-version">effective version</termref> is equal to 1.0.</termdef></p>
               <p>In this mode, if any attribute contains an XPath <termref def="dt-expression">expression</termref>, then the expression is evaluated with <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> set to
                     <code>true</code>. For details of this mode, see <xspecref spec="XP21" ref="static_context"/>.</p>

               <p>Furthermore, in such an expression any function call for which no implementation
                  is available (unless it uses the <termref def="dt-standard-function-namespace">standard function namespace</termref>) is bound to a fallback error function
                  whose effect when evaluated is to raise a dynamic error <errorref spec="XT" class="DE" code="1425"/> . The effect is that with backwards compatible
                  behavior enabled, calls on <termref def="dt-extension-function">extension
                     functions</termref> that are not available in a particular implementation do
                  not cause an error unless the function call is actually evaluated. For further
                  details, see <specref ref="extension-functions"/>.</p>
               <note>
                  <p>This might appear to contradict the specification of XPath <phrase diff="chg" at="D">2.1</phrase>, which states that a static error [XPST0017] is raised
                     when an expression contains a call to a function that is not present (with
                     matching name and arity) in the static context. This apparent contradiction is
                     resolved by specifying that the XSLT processor constructs a static context for
                     the expression in which every possible function name and arity (other than
                     names in the <termref def="dt-standard-function-namespace">standard function
                        namespace</termref>) is present; when no other implementation of the
                     function is available, the function call is bound to a fallback error function
                     whose run-time effect is to raise a dynamic error.</p>
               </note>
               <p>Certain XSLT constructs also produce different results when XSLT 1.0 compatibility
                  mode is enabled. This is described separately for each such construct.</p>

            </div3>
            <div3 id="backwards-2.0" diff="add" at="D">
               <head>XSLT 2.0 compatibility mode</head>
               <p><termdef id="dt-xslt-20-behavior" term="XSLT 2.0 behavior">An element is processed
                     with <term>XSLT 2.0 behavior</term> if its <termref def="dt-effective-version">effective version</termref> is equal to 2.0.</termdef></p>
               <p>In this working draft, no differences are defined for XSLT 2.0 behavior. An XSLT
                  2.1 processor will therefore produce the same results whether the <termref def="dt-effective-version">effective version</termref> of an element is set to
                  2.0 or 2.1.</p>
               <note>
                  <p>An XSLT 2.0 processor, by contrast, will in some cases produce different
                     results in the two cases. For example, if the stylesheet contains an
                        <elcode>xsl:iterate</elcode> instruction with an
                        <elcode>xsl:fallback</elcode> child, an XSLT 2.1 processor will process the
                        <elcode>xsl:iterate</elcode> instruction regardless whether the effective
                     version is 2.0 or 2.1, while an XSLT 2.0 processor will report a static error
                     if the effective version is 2.0, and will take the fallback action if the
                     effective version is 2.1.</p>
               </note>
            </div3>
         </div2>
         <div2 id="forwards">
            <head>Forwards Compatible Processing</head>
            <p>The intent of forwards compatible behavior is to make it possible to write a
               stylesheet that takes advantage of features introduced in some version of XSLT
               subsequent to <phrase diff="chg" at="D">XSLT 2.1</phrase>, while retaining the
               ability to execute the stylesheet with an <phrase diff="chg" at="D">XSLT 2.1</phrase>
               processor using appropriate fallback behavior.</p>
            <p>It is always possible to write conditional code to run under different XSLT versions
               by using the <code>use-when</code> feature described in <specref ref="conditional-inclusion"/>. The rules for forwards compatible behavior
               supplement this mechanism in two ways:</p>
            <ulist>
               <item>
                  <p>certain constructs in the stylesheet that mean nothing to an <phrase diff="chg" at="D">XSLT 2.1</phrase> processor are ignored, rather than being treated as
                     errors.</p>
               </item>
               <item>
                  <p>explicit fallback behavior can be defined for instructions defined in a future
                     XSLT release, using the <elcode>xsl:fallback</elcode> instruction.</p>
               </item>
            </ulist>
            <p>The detailed rules follow.</p>
            <p diff="chg" at="D">
               <termdef id="dt-forwards-compatible-behavior" term="forwards compatible behavior">An
                  element is processed with <term>forwards compatible behavior</term> if its
                     <termref def="dt-effective-version">effective version</termref> is greater than
                     <code diff="chg" at="D">2.1</code>.</termdef>
            </p>
            <p diff="del" at="D">An element that has an <code>[xsl:]version</code> attribute whose
               value is less than or equal to <code>
                  <phrase diff="chg" at="A">2.1</phrase>
               </code> disables forwards compatible behavior for itself, its attributes, its
               descendants and their attributes. The compatibility behavior established by an
               element overrides any compatibility behavior established by an ancestor element.</p>
            <p>These rules do not apply to the <code>version</code> attribute of the
                  <elcode>xsl:output</elcode> element, which has an entirely different purpose: it
               is used to define the version of the output method to be used for serialization.</p>
            <p diff="chg" at="D">When an element is processed with forwards compatible behavior:</p>
            <ulist>
               <item>
                  <p>if the element is in the XSLT namespace and appears as a child of the
                        <elcode>xsl:stylesheet</elcode> element, and XSLT <phrase diff="chg" at="A">2.1</phrase> does not allow the element to appear as a child of the
                        <elcode>xsl:stylesheet</elcode> element, then the element and its content
                        <rfc2119>must</rfc2119> be ignored.</p>
               </item>
               <item>
                  <p>if the element has an attribute that XSLT <phrase diff="chg" at="A">2.1</phrase> does not allow the element to have, then the attribute
                        <rfc2119>must</rfc2119> be ignored.</p>
               </item>
               <item>
                  <p>if the element is in the XSLT namespace and appears as part of a <termref def="dt-sequence-constructor">sequence constructor</termref>, and XSLT
                        <phrase diff="chg" at="A">2.1</phrase> does not allow such elements to
                     appear as part of a sequence constructor, then:</p>
                  <olist>
                     <item>
                        <p>If the element has one or more <elcode>xsl:fallback</elcode> children,
                           then no error is reported either statically or dynamically, and the
                           result of evaluating the instruction is the concatenation of the
                           sequences formed by evaluating the sequence constructors within its
                              <elcode>xsl:fallback</elcode> children, in document order. Siblings of
                           the <elcode>xsl:fallback</elcode> elements are ignored, even if they are
                           valid XSLT <phrase diff="chg" at="A">2.1</phrase> instructions.</p>
                     </item>
                     <item>
                        <p>If the element has no <elcode>xsl:fallback</elcode> children, then a
                           static error is reported in the same way as if forwards compatible
                           behavior were not enabled.</p>
                     </item>
                  </olist>
               </item>
            </ulist>
            <example>
               <head>Forwards Compatible Behavior</head>
               <p>For example, an XSLT <phrase diff="chg" at="A">2.1</phrase>
                  <termref def="dt-processor">processor</termref> will process the following
                  stylesheet without error, although the stylesheet includes elements from the
                     <termref def="dt-xslt-namespace">XSLT namespace</termref> that are not defined
                  in this specification:</p>
               <eg xml:space="preserve">&lt;xsl:stylesheet version="17.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:template match="/"&gt;
    &lt;xsl:exciting-new-17.0-feature&gt;
      &lt;xsl:fly-to-the-moon/&gt;
      &lt;xsl:fallback&gt;
        &lt;html&gt;
          &lt;head&gt;
            &lt;title&gt;XSLT 17.0 required&lt;/title&gt;
          &lt;/head&gt;
          &lt;body&gt;
            &lt;p&gt;Sorry, this stylesheet requires XSLT 17.0.&lt;/p&gt;
          &lt;/body&gt;
        &lt;/html&gt;
      &lt;/xsl:fallback&gt;
    &lt;/xsl:exciting-new-17.0-feature&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</eg>
            </example>
            <note>
               <p>If a stylesheet depends crucially on a <termref def="dt-declaration">declaration</termref> introduced by a version of XSLT after <phrase diff="chg" at="A">2.1</phrase>, then the stylesheet can use an
                     <elcode>xsl:message</elcode> element with <code>terminate="yes"</code> (see
                     <specref ref="message"/>) to ensure that implementations that conform to an
                  earlier version of XSLT will not silently ignore the <termref def="dt-declaration">declaration</termref>.</p>
            </note>
            <example>
               <head>Testing the XSLT Version</head>
               <p>For example,</p>
               <eg xml:space="preserve">&lt;xsl:stylesheet version="18.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:important-new-17.0-declaration/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="number(system-property('xsl:version')) lt 17.0"&gt;
        &lt;xsl:message terminate="yes"&gt;
          &lt;xsl:text&gt;Sorry, this stylesheet requires XSLT 17.0.&lt;/xsl:text&gt;
        &lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        ...
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
  ...
&lt;/xsl:stylesheet&gt;</eg>
            </example>
         </div2>
         <div2 id="combining-modules">
            <head>Combining Stylesheet Modules</head>
            <p>XSLT provides two mechanisms to construct a <termref def="dt-stylesheet">stylesheet</termref> from multiple <termref def="dt-stylesheet-module">stylesheet
                  modules</termref>:</p>
            <ulist>
               <item>
                  <p>an inclusion mechanism that allows stylesheet modules to be combined without
                     changing the semantics of the modules being combined, and</p>
               </item>
               <item>
                  <p>an import mechanism that allows stylesheet modules to override each other.</p>
               </item>
            </ulist>
            <div3 id="locating-modules">
               <head>Locating Stylesheet Modules</head>
               <p>The include and import mechanisms use two declarations,
                     <elcode>xsl:include</elcode> and <elcode>xsl:import</elcode>, which are defined
                  in the sections that follow.</p>
               <p>These declarations use an <code>href</code> attribute, whose value is a <termref def="dt-uri-reference">URI reference</termref>, to identify the <termref def="dt-stylesheet-module">stylesheet module</termref> to be included or
                  imported. If the value of this attribute is a relative URI <phrase diff="add" at="F">reference</phrase>, it is resolved as
                  described in <specref ref="uri-references"/>.</p>
               <p>After resolving against the base URI, the way in which the URI reference is used
                  to locate a representation of a <termref def="dt-stylesheet-module">stylesheet
                     module</termref>, and the way in which the stylesheet module is constructed
                  from that representation, are <termref def="dt-implementation-defined">implementation-defined</termref>. In particular, it is implementation-defined
                  which URI schemes are supported, whether fragment identifiers are supported, and
                  what media types are supported. Conventionally, the URI is a reference to a
                  resource containing the stylesheet module as a source XML document, or it may
                  include a fragment identifier that selects an embedded stylesheet module within a
                  source XML document; but the implementation is free to use other mechanisms to
                  locate the stylesheet module identified by the URI reference.</p>
               <p>The referenced <termref def="dt-stylesheet-module">stylesheet module</termref> may
                  be any of the four kinds of stylesheet module: that is, it may be <termref def="dt-standalone-stylesheet-module">standalone</termref> or <termref def="dt-embedded-stylesheet-module">embedded</termref>, and it may be <termref def="dt-standard-stylesheet-module">standard</termref> or <termref def="dt-simplified-stylesheet-module">simplified</termref>. If it is a <termref def="dt-simplified-stylesheet-module">simplified stylesheet module</termref>
                  then it is transformed into the equivalent <termref def="dt-standard-stylesheet-module">standard stylesheet module</termref> by
                  applying the transformation described in <specref ref="simplified-stylesheet"/>.</p>
               <p>Implementations <rfc2119>may</rfc2119> choose to accept URI references containing
                  a fragment identifier defined by reference to the XPointer specification (see
                     <bibref ref="xptr-framework"/>). Note that if the implementation does not
                  support the use of fragment identifiers in the URI reference, then it will not be
                  possible to include an <termref def="dt-embedded-stylesheet-module">embedded
                     stylesheet module</termref>.</p>
               <imp-def-feature>It is implementation-defined what forms of URI reference are
                  acceptable in the <code>href</code> attribute of the <elcode>xsl:include</elcode>
                  and <elcode>xsl:import</elcode> elements, for example, the URI schemes that may be
                  used, the forms of fragment identifier that may be used, and the media types that
                  are supported.</imp-def-feature>
               <p>
                  <error spec="XT" type="static" class="SE" code="0165">
                     <p>It is a <termref def="dt-static-error">static error</termref> if the
                        processor is not able to retrieve the resource identified by the URI
                           reference<error.extra> in the <code>href</code> attribute of
                              <elcode>xsl:include</elcode> or <elcode>xsl:import</elcode>
                        </error.extra>, or if the resource that is retrieved does not contain a
                        stylesheet module conforming to this specification.</p>
                  </error>
               </p>
            </div3>
            <div3 id="include">
               <head>Stylesheet Inclusion</head>
               <e:element-syntax name="include">
                  <e:in-category name="declaration"/>
                  <e:attribute name="href" required="yes">
                     <e:data-type name="uri-reference"/>
                  </e:attribute>
                  <e:empty/>
                  <e:allowed-parents>
                     <e:parent name="stylesheet"/>
                     <e:parent name="transform"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p>A stylesheet module may include another stylesheet module using an
                     <elcode>xsl:include</elcode> declaration.</p>
               <p>The <elcode>xsl:include</elcode> declaration has a <rfc2119>required</rfc2119>
                  <code>href</code> attribute whose value is a URI reference identifying the
                  stylesheet module to be included. This attribute is used as described in <specref ref="locating-modules"/>.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0170">
                     <p>An <elcode>xsl:include</elcode> element <rfc2119>must</rfc2119> be a
                           <termref def="dt-top-level">top-level</termref> element.</p>
                  </error>
               </p>
               <p>
                  <termdef id="dt-stylesheet-level" term="stylesheet level">A <term>stylesheet
                        level</term> is a collection of <termref def="dt-stylesheet-module">stylesheet modules</termref> connected using <elcode>xsl:include</elcode>
                     declarations: specifically, two stylesheet modules <var>A</var> and
                        <var>B</var> are part of the same stylesheet level if one of them includes
                     the other by means of an <elcode>xsl:include</elcode> declaration, or if there
                     is a third stylesheet module <var>C</var> that is in the same stylesheet level
                     as both <var>A</var> and <var>B</var>.</termdef>
               </p>
               <p>
                  <termdef id="dt-declaration-order" term="declaration order">The <termref def="dt-declaration">declarations</termref> within a <termref def="dt-stylesheet-level">stylesheet level</termref> have a total ordering
                     known as <term>declaration order</term>. The order of declarations within a
                     stylesheet level is the same as the document order that would result if each
                     stylesheet module were inserted textually in place of the
                        <elcode>xsl:include</elcode> element that references it.</termdef> In other
                  respects, however, the effect of <elcode>xsl:include</elcode> is not equivalent to
                  the effect that would be obtained by textual inclusion.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0180">
                     <p>It is a <termref def="dt-static-error">static error</termref> if a
                        stylesheet module directly or indirectly includes itself.</p>
                  </error>
               </p>
               <note>
                  <p>It is not intrinsically an error for a <termref def="dt-stylesheet">stylesheet</termref> to include the same module more than once. However,
                     doing so can cause errors because of duplicate definitions. Such multiple
                     inclusions are less obvious when they are indirect. For example, if stylesheet
                        <var>B</var> includes stylesheet <var>A</var>, stylesheet <var>C</var>
                     includes stylesheet <var>A</var>, and stylesheet <var>D</var> includes both
                     stylesheet <var>B</var> and stylesheet <var>C</var>, then <var>A</var> will be
                     included indirectly by <var>D</var> twice. If all of <var>B</var>, <var>C</var>
                     and <var>D</var> are used as independent stylesheets, then the error can be
                     avoided by separating everything in <var>B</var> other than the inclusion of
                        <var>A</var> into a separate stylesheet <var>B'</var> and changing
                        <var>B</var> to contain just inclusions of <var>B'</var> and <var>A</var>,
                     similarly for <var>C</var>, and then changing <var>D</var> to include
                        <var>A</var>, <var>B'</var>, <var>C'</var>.</p>
               </note>
            </div3>
            <div3 id="import">
               <head>Stylesheet Import</head>
               <e:element-syntax name="import">
                  <e:in-category name="declaration"/>
                  <e:attribute name="href" required="yes">
                     <e:data-type name="uri-reference"/>
                  </e:attribute>
                  <e:empty/>
                  <e:allowed-parents>
                     <e:parent name="stylesheet"/>
                     <e:parent name="transform"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p>A stylesheet module may import another <termref def="dt-stylesheet-module">stylesheet module</termref> using an <elcode>xsl:import</elcode>
                  <termref def="dt-declaration">declaration</termref>. Importing a stylesheet module
                  is the same as including it (see <specref ref="include"/>) except that <termref def="dt-template-rule">template rules</termref> and other <termref def="dt-declaration">declarations</termref> in the importing module take
                  precedence over template rules and declarations in the imported module; this is
                  described in more detail below.</p>
               <p>The <elcode>xsl:import</elcode> declaration has a <rfc2119>required</rfc2119>
                  <code>href</code> attribute whose value is a URI reference identifying the
                  stylesheet module to be included. This attribute is used as described in <specref ref="locating-modules"/>.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0190">
                     <p>An <elcode>xsl:import</elcode> element <rfc2119>must</rfc2119> be a <termref def="dt-top-level">top-level</termref> element.</p>
                  </error>
               </p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0200">
                     <p>The <elcode>xsl:import</elcode> element children <rfc2119>must</rfc2119>
                        precede all other element children of an <elcode>xsl:stylesheet</elcode>
                        element, including any <elcode>xsl:include</elcode> element children and any
                           <termref def="dt-data-element">user-defined data elements</termref>.</p>
                  </error>
               </p>
               <example>
                  <head>Using <code>xsl:import</code>
                  </head>
                  <p>For example,</p>
                  <eg xml:space="preserve">&lt;xsl:stylesheet version="2.1"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:import href="article.xsl"/&gt;
  &lt;xsl:import href="bigfont.xsl"/&gt;
  &lt;xsl:attribute-set name="note-style"&gt;
    &lt;xsl:attribute name="font-style"&gt;italic&lt;/xsl:attribute&gt;
  &lt;/xsl:attribute-set&gt;
&lt;/xsl:stylesheet&gt;</eg>
               </example>
               <p>
                  <termdef id="dt-import-tree" term="import tree">The <termref def="dt-stylesheet-level">stylesheet levels</termref> making up a <termref def="dt-stylesheet">stylesheet</termref> are treated as forming an
                        <term>import tree</term>. In the import tree, each stylesheet level has one
                     child for each <elcode>xsl:import</elcode> declaration that it
                     contains.</termdef> The ordering of the children is the <termref def="dt-declaration-order">declaration order</termref> of the
                     <elcode>xsl:import</elcode> declarations within their stylesheet level.</p>
               <p>
                  <termdef id="dt-import-precedence" term="import precedence">A <termref def="dt-declaration">declaration</termref>
                     <var>D</var> in the stylesheet is defined to have lower <term>import
                        precedence</term> than another declaration <var>E</var> if the stylesheet
                     level containing <var>D</var> would be visited before the stylesheet level
                     containing <var>E</var> in a post-order traversal of the import tree (that is,
                     a traversal of the import tree in which a stylesheet level is visited after its
                     children). Two declarations within the same stylesheet level have the same
                     import precedence.</termdef>
               </p>
               <p>For example, suppose</p>
               <ulist>
                  <item>
                     <p>stylesheet module <var>A</var> imports stylesheet modules <var>B</var> and
                           <var>C</var> in that order;</p>
                  </item>
                  <item>
                     <p>stylesheet module <var>B</var> imports stylesheet module <var>D</var>;</p>
                  </item>
                  <item>
                     <p>stylesheet module <var>C</var> imports stylesheet module <var>E</var>.</p>
                  </item>
               </ulist>
               <p>Then the import tree has the following structure:</p>


               <g:graph rankdir="LR">
                  <g:node label="A" shape="box">
                     <g:node label="B" shape="box">
                        <g:node label="D" shape="box"/>
                     </g:node>
                     <g:node label="C" shape="box">
                        <g:node label="E" shape="box"/>
                     </g:node>
                  </g:node>
               </g:graph>

               <p><emph>Here you should see a diagram. If it does not appear correctly in your
                     browser, you need to install an SVG Plugin.</emph></p>

               <p>The order of import precedence (lowest first) is <var>D</var>, <var>B</var>,
                     <var>E</var>, <var>C</var>, <var>A</var>.</p>
               <p>In general, a <termref def="dt-declaration">declaration</termref> with higher
                  import precedence takes precedence over a declaration with lower import
                  precedence. This is defined in detail for each kind of declaration.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0210">
                     <p>It is a <termref def="dt-static-error">static error</termref> if a
                        stylesheet module directly or indirectly imports itself.</p>
                  </error>
               </p>
               <note>
                  <p>The case where a stylesheet module with a particular URI is imported several
                     times is not treated specially. The effect is exactly the same as if several
                     stylesheet modules with different URIs but identical content were imported.
                     This might or might not cause an error, depending on the content of the
                     stylesheet module.</p>
               </note>
            </div3>
         </div2>
         <div2 id="embedded">
            <head>Embedded Stylesheet Modules</head>
            <p>An <termref def="dt-embedded-stylesheet-module">embedded stylesheet module</termref>
               is a <termref def="dt-stylesheet-module">stylesheet module</termref> whose containing
               element is not the outermost element of the containing XML document. Both <termref def="dt-standard-stylesheet-module">standard stylesheet modules</termref> and
                  <termref def="dt-simplified-stylesheet-module">simplified stylesheet
                  modules</termref> may be embedded in this way.</p>
            <p>Two situations where embedded stylesheets may be useful are:</p>
            <ulist>
               <item>
                  <p>The stylesheet may be embedded in the source document to be transformed.</p>
               </item>
               <item>
                  <p>The stylesheet may be embedded in an XML document that describes a sequence of
                     processing of which the XSLT transformation forms just one part.</p>
               </item>
            </ulist>
            <p>The <elcode>xsl:stylesheet</elcode> element <rfc2119>may</rfc2119> have an
                  <code>id</code> attribute to facilitate reference to the stylesheet module within
               the containing document.</p>
            <note>
               <p>In order for such an attribute value to be used as a fragment identifier in a URI,
                  the XDM attribute node must generally have the <code>is-id</code> property: see
                     <xspecref spec="DM11" ref="dm-is-id"/>. This property will typically be set if
                  the attribute is defined in a DTD as being of type <code>ID</code>, or if is
                  defined in a schema as being of type <code>xs:ID</code>. It is also necessary that
                  the media type of the containing document should support the use of ID values as
                  fragment identifiers. <phrase diff="del" at="F">Such support is widespread in existing products, and is
                  expected to be endorsed in respect of the media type <code>application/xml</code>
                  by a future revision of <bibref ref="RFC3023"/></phrase>
                  <phrase diff="add" at="F">Such support is widespread in existing products, and is
                     endorsed in respect of the media type <code>application/xml</code> by <bibref ref="xptr-framework"/></phrase>.</p>
               
               <p>An alternative, if the implementation supports it, is to use an
                     <code>xml:id</code> attribute. XSLT allows this attribute (like other
                  namespaced attributes) to appear on any <termref def="dt-xslt-element">XSLT
                     element</termref>.</p>
            </note>
            <example>
               <head>The <code>xml-stylesheet</code> Processing Instruction</head>
               <p>The following example shows how the <code>xml-stylesheet</code> processing
                  instruction (see <bibref ref="xml-stylesheet"/>) can be used to allow a source
                  document to contain its own stylesheet. The URI reference uses <phrase diff="del" at="F">a relative URI with</phrase>
                  a fragment identifier to locate the <elcode>xsl:stylesheet</elcode> element:</p>
               <eg xml:space="preserve">&lt;?xml-stylesheet type="application/xslt+xml" href="#style1"?&gt;
&lt;!DOCTYPE doc SYSTEM "doc.dtd"&gt;
&lt;doc&gt;
  &lt;head&gt;
    &lt;xsl:stylesheet id="style1"
                    version="2.1"
                    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                    xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;
    &lt;xsl:import href="doc.xsl"/&gt;
    &lt;xsl:template match="id('foo')"&gt;
      &lt;fo:block font-weight="bold"&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="xsl:stylesheet"&gt;
      &lt;!-- ignore --&gt;
    &lt;/xsl:template&gt;
    &lt;/xsl:stylesheet&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;para id="foo"&gt;
    ...
    &lt;/para&gt;
  &lt;/body&gt;
&lt;/doc&gt;
</eg>
            </example>
            <note>
               <p>A stylesheet module that is embedded in the document to which it is to be applied
                  typically needs to contain a <termref def="dt-template-rule">template
                     rule</termref> that specifies that <elcode>xsl:stylesheet</elcode> elements are
                  to be ignored.</p>
            </note>
            <note>
               <p diff="chg" at="C">The above example uses the pseudo-attribute
                     <code>type="application/xslt+xml"</code> in the <code>xml-stylesheet</code>
                  processing instruction to denote an XSLT stylesheet. This is the officially
                  registered media type for XSLT: see <specref ref="xslt-media-type"/>. However,
                  browsers developed before this media type was registered are more likely to accept
                  the unofficial designation <code>type="text/xsl"</code>.</p>
            </note>
            <note>
               <p>Support for the <code>xml-stylesheet</code> processing instruction is not required
                  for conformance with this Recommendation. Implementations are not constrained in
                  the mechanisms they use to identify a stylesheet when a transformation is
                  initiated: see <specref ref="initiating"/>.</p>
            </note>
         </div2>
         <div2 id="conditional-inclusion">
            <head>Conditional Element Inclusion</head>
            <p>Any element in the XSLT namespace may have a <code>use-when</code> attribute whose
               value is an XPath expression that can be evaluated statically. If the attribute is
               present and the <xtermref spec="XP21" ref="dt-ebv">effective boolean value</xtermref>
               of the expression is false, then the element, together with all the nodes having that
               element as an ancestor, is effectively excluded from the <termref def="dt-stylesheet-module">stylesheet module</termref>. When a node is effectively
               excluded from a stylesheet module the stylesheet module has the same effect as if the
               node were not there. Among other things this means that no static or dynamic errors
               will be reported in respect of the element and its contents, other than errors in the
                  <code>use-when</code> attribute itself.</p>
            <note>
               <p>This does not apply to XML parsing or validation errors, which will be reported in
                  the usual way. It also does not apply to attributes that are necessarily processed
                  before <code>[xsl:]use-when</code>, examples being <code>xml:space</code> and
                     <code>[xsl:]xpath-default-namespace</code>.</p>
            </note>
            <p>A <termref def="dt-literal-result-element">literal result element</termref>, or any
               other element within a <termref def="dt-stylesheet-module">stylesheet
                  module</termref> that is not in the XSLT namespace, may similarly carry an
                  <code>xsl:use-when</code> attribute.</p>
            <p>If the <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element
               itself is effectively excluded, the effect is to exclude all the children of the
                  <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element, but not
               the <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element or its
               attributes.</p>
            <note>
               <p>This allows all the declarations that depend on the same condition to be included
                  in one stylesheet module, and for their inclusion or exclusion to be controlled by
                  a single <code>use-when</code> attribute at the level of the module.</p>
            </note>
            <p>Conditional element exclusion happens after stripping of whitespace text nodes from
               the stylesheet, as described in <specref ref="stylesheet-stripping"/>.</p>
            <p>There are no syntactic constraints on the XPath expression that can be used as the
               value of the <code>use-when</code> attribute. However, there are severe constraints
               on the information provided in its evaluation context. These constraints are designed
               to ensure that the expression can be evaluated at the earliest possible stage of
               stylesheet processing, without any dependency on information contained in the
               stylesheet itself or in any source document.</p>
            <p>Specifically, the components of the static and dynamic context are defined by the
               following two tables:</p>
            <table border="1" cellpadding="5" width="100%">
               <caption>Static Context Components for <code>use-when</code> Expressions</caption>
               <col align="left" width="30%" span="1"/>
               <col align="left" span="1"/>
               <thead>
                  <tr>
                     <th rowspan="1" colspan="1">Component</th>
                     <th rowspan="1" colspan="1">Value</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">XPath 1.0 compatibility mode</td>
                     <td rowspan="1" colspan="1">false</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">In scope namespaces</td>
                     <td rowspan="1" colspan="1">determined by the in-scope namespaces for the
                        containing element in the stylesheet</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">Default element/type namespace</td>
                     <td rowspan="1" colspan="1">determined by the
                           <code>xpath-default-namespace</code> attribute if present (see <specref ref="unprefixed-qnames"/>); otherwise the null namespace</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">Default function namespace</td>
                     <td rowspan="1" colspan="1">The <termref def="dt-standard-function-namespace">standard function namespace</termref>
                     </td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">In scope type definitions</td>
                     <td rowspan="1" colspan="1">The type definitions that would be available in the
                        absence of any <elcode>xsl:import-schema</elcode> declaration</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">In scope element declarations</td>
                     <td rowspan="1" colspan="1">None</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">In scope attribute declarations</td>
                     <td rowspan="1" colspan="1">None</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">In scope variables</td>
                     <td rowspan="1" colspan="1">None</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">In scope functions</td>
                     <td rowspan="1" colspan="1">The <termref def="dt-core-function">core
                           functions</termref> defined in <bibref ref="xpath-functions-11"/>, together
                        with the functions <function>element-available</function>,
                           <function>function-available</function>,
                           <function>type-available</function>, and
                           <function>system-property</function> defined in this specification, plus
                        the set of extension functions that are present in the static context of
                        every XPath expression (other than a use-when expression) within the content
                        of the element that is the parent of the <code>use-when</code> attribute.
                        Note that <termref def="dt-stylesheet-function">stylesheet
                           functions</termref> are <emph>not</emph> included in the context, which
                        means that the function <function>function-available</function> will return
                           <code>false</code> in respect of such functions. The effect of this rule
                        is to ensure that <function>function-available</function> returns true in
                        respect of functions that can be called within the scope of the
                           <code>use-when</code> attribute. It also has the effect that these
                        extensions functions will be recognized within the <code>use-when</code>
                        attribute itself; however, the fact that a function is available in this
                        sense gives no guarantee that a call on the function will succeed.</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">In scope collations</td>
                     <td rowspan="1" colspan="1">Implementation-defined</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">Default collation</td>
                     <td rowspan="1" colspan="1">The Unicode Codepoint Collation</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">Base URI</td>
                     <td rowspan="1" colspan="1">The base URI of the containing element in the
                        stylesheet</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">Statically known documents</td>
                     <td rowspan="1" colspan="1">None</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">Statically known collections</td>
                     <td rowspan="1" colspan="1">None</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1"><phrase diff="add" at="D">Statically
                           known decimal formats</phrase></td>
                     <td rowspan="1" colspan="1"><phrase diff="add" at="D">A single unnamed <termref def="dt-decimal-format">decimal format</termref> equivalent to the
                           decimal format that is created by an <elcode>xsl:decimal-format</elcode>
                           declaration with no attributes.</phrase></td>
                  </tr>
               </tbody>
            </table>
            <p></p>
            <table border="1" cellpadding="5" width="100%">
               <caption>Dynamic Context Components for <code>use-when</code> Expressions</caption>
               <col align="left" width="30%" span="1"/>
               <col align="left" span="1"/>
               <thead>
                  <tr>
                     <th rowspan="1" colspan="1">Component</th>
                     <th rowspan="1" colspan="1">Value</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">Context item, position, and size</td>
                     <td rowspan="1" colspan="1">Undefined</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">Dynamic variables</td>
                     <td rowspan="1" colspan="1">None</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">Current date and time</td>
                     <td rowspan="1" colspan="1">Implementation-defined</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">Implicit timezone</td>
                     <td rowspan="1" colspan="1">Implementation-defined</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">Available documents</td>
                     <td rowspan="1" colspan="1">None</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">Available collections</td>
                     <td rowspan="1" colspan="1">None</td>
                  </tr>
               </tbody>
            </table>
            <p>Within a <termref def="dt-stylesheet-module">stylesheet module</termref>, all
               expressions contained in <code>[xsl:]use-when</code> attributes are evaluated in a
               single <xtermref spec="FO" ref="execution-scope">execution scope</xtermref>. This
               need not be the same execution scope as that used for <code>[xsl]:use-when</code>
               expressions in other stylesheet modules, or as that used when evaluating XPath
               expressions appearing elsewhere in the stylesheet module. This means that a function
               such as <xfunction>current-date</xfunction> will return the same result when called
               in different <code>[xsl:]use-when</code> expressions within the same stylesheet
               module, but will not necessarily return the same result as the same call in an
                  <code>[xsl:]use-when</code> expression within a different stylesheet module, or as
               a call on the same function executed during the transformation proper.</p>
            <p>The use of <code>[xsl:]use-when</code> is illustrated in the following examples.</p>
            <example>
               <head>Using Conditional Exclusion to Achieve Portability</head>
               <p>This example demonstrates the use of the <code>use-when</code> attribute to
                  achieve portability of a stylesheet across schema-aware and non-schema-aware
                  processors.</p>
               <eg xml:space="preserve">&lt;xsl:import-schema schema-location="http://example.com/schema"
              use-when="system-property('xsl:is-schema-aware')='yes'"/&gt;

&lt;xsl:template match="/" 
              use-when="system-property('xsl:is-schema-aware')='yes'" 
              priority="2"&gt;
  &lt;xsl:result-document validation="strict"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;</eg>
               <p>The effect of these declarations is that a non-schema-aware processor ignores the
                     <elcode>xsl:import-schema</elcode> declaration and the first template rule, and
                  therefore generates no errors in respect of the schema-related constructs in these
                  declarations.</p>
            </example>
            <example>
               <head>Including Variant Stylesheet Modules</head>
               <p>This example includes different stylesheet modules depending on which XSLT
                  processor is in use.</p>
               <eg xml:space="preserve">&lt;xsl:include href="module-A.xsl" 
     use-when="system-property('xsl:vendor')='vendor-A'"/&gt;
&lt;xsl:include href="module-B.xsl" 
     use-when="system-property('xsl:vendor')='vendor-B'"/&gt;</eg>
            </example>
         </div2>
         <div2 id="built-in-types">
            <head>Built-in Types</head>

            <p>Every XSLT <phrase diff="chg" at="A">2.1</phrase> processor includes the following
               named type definitions in the <termref def="dt-in-scope-schema-component">in-scope
                  schema components</termref>:</p>
            <ulist>
               <item>
                  <p/>
               </item>
               <item>
                  <p><phrase diff="del" at="C">All the primitive atomic types defined in <bibref ref="xmlschema-2"/>
                     with the exception of
                     <code>xs:NOTATION</code>. That is: <code>xs:string</code>,
                     <code>xs:boolean</code>, <code>xs:decimal</code>, <code>xs:double</code>,
                     <code>xs:float</code>, <code>xs:date</code>, <code>xs:time</code>,
                     <code>xs:dateTime</code>, <code>xs:duration</code>, <code>xs:QName</code>,
                     <code>xs:anyURI</code>, <code>xs:gDay</code>, <code>xs:gMonthDay</code>,
                     <code>xs:gMonth</code>, <code>xs:gYearMonth</code>, <code>xs:gYear</code>,
                     <code>xs:base64Binary</code>, and <code>xs:hexBinary</code>.</phrase>
                     <phrase diff="add" at="F">All built-in types defined in <bibref ref="xmlschema-2"/>,
                        including <code>xs:anyType</code> and <code>xs:anySimpleType</code>.</phrase></p>
               </item>
               
               <item>
                  <p>The following types defined in <bibref ref="xpath-21"/>:
                        <code>xs:yearMonthDuration</code>, <code>xs:dayTimeDuration</code>,
                        <code>xs:anyAtomicType</code>, <code>xs:untyped</code>, and
                        <code>xs:untypedAtomic</code>.</p>
               </item>
            </ulist>
            <issue id="xsd11-additional-types" status="open">
               <p>It is likely that the new types from XSD 1.1 will be added to this list when XSD
                  1.1 becomes a Recommendation.</p>
            </issue>
            <p>A <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT processor</termref>
               additionally supports:</p>
            <ulist>
               <item diff="del" at="C">
                  <p>All other built-in types defined in <bibref ref="xmlschema-2"/>
                  </p>
               </item>
               <item>
                  <p>User-defined types, and element and attribute declarations, that are imported
                     using an <elcode>xsl:import-schema</elcode> declaration as described in
                        <specref ref="import-schema"/>. These may include both simple and complex
                     types.</p>
               </item>
            </ulist>
            <note>
               <p>The names that are imported from the XML Schema namespace do not include all the
                  names of top-level types defined in either the Schema for Schemas or the Schema
                  for Datatypes. The Schema for Datatypes, as well as defining built-in types such
                  as <code>xs:integer</code> and <code>xs:double</code>, also defines types that are
                  intended for use only within the Schema for DataTypes, such as
                     <code>xs:derivationControl</code>. A <termref def="dt-stylesheet">stylesheet</termref> that is designed to process XML Schema documents as its
                  input or output may import the Schema for Schemas.</p>
            </note>
            <p>An implementation may define mechanisms that allow additional <termref def="dt-schema-component">schema components</termref> to be added to the <termref def="dt-in-scope-schema-component">in-scope schema components</termref> for the
               stylesheet. For example, the mechanisms used to define <termref def="dt-extension-function">extension functions</termref> (see <specref ref="extension-functions"/>) may also be used to import the types used in the
               interface to such functions.</p>
            <imp-def-feature>An implementation may define mechanisms, above and beyond
                  <elcode>xsl:import-schema</elcode> that allow <termref def="dt-schema-component">schema components</termref> such as type definitions to be made available within
               a stylesheet.</imp-def-feature>
            <p>These <termref def="dt-schema-component">schema components</termref> are the only
               ones that may be referenced in XPath expressions within the stylesheet, or in the
                  <code>[xsl:]type</code> and <code>as</code> attributes of those elements that
               permit these attributes.</p>
            <p diff="del" at="C">For a Basic XSLT Processor, schema built-in types that are not
               included in the static context (for example, <code>xs:NCName</code>) are "unknown
               types" in the sense of <xspecref spec="XP21" ref="id-sequencetype-matching"/>. In the
               language of that section, a Basic XSLT Processor <rfc2119>must</rfc2119> be able to
               determine whether these unknown types are derived from known schema types such as
                  <code>xs:string</code>. The purpose of this rule is to ensure that system
               functions such as <xfunction>local-name-from-QName</xfunction>, which is defined to
               return an <code>xs:NCName</code>, behave correctly. A stylesheet that uses a Basic
               XSLT Processor will not be able to test whether the returned value is an
                  <code>xs:NCName</code>, but it will be able to use it as if it were an
                  <code>xs:string</code>. </p>
         </div2>
         <div2 id="import-schema">
            <head>Importing Schema Components</head>
            <note>
               <p>The facilities described in this section are not available with a <termref def="dt-basic-xslt-processor">basic XSLT processor</termref>. They require a
                     <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT
                     processor</termref>, as described in <specref ref="conformance"/>.</p>
            </note>
            <e:element-syntax name="import-schema">
               <e:in-category name="declaration"/>
               <e:attribute name="namespace">
                  <e:data-type name="uri-reference"/>
               </e:attribute>
               <e:attribute name="schema-location">
                  <e:data-type name="uri-reference"/>
               </e:attribute>
               <e:element repeat="zero-or-one" name="xs:schema"/>
               <e:allowed-parents>
                  <e:parent name="stylesheet"/>
                  <e:parent name="transform"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:import-schema</elcode> declaration is used to identify <termref def="dt-schema-component">schema components</termref> (that is, top-level type
               definitions and top-level element and attribute declarations) that need to be
               available statically, that is, before any source document is available. Names of such
               components used statically within the <termref def="dt-stylesheet">stylesheet</termref> must refer to an <termref def="dt-in-scope-schema-component">in-scope schema component</termref>, which means they must either be built-in
               types as defined in <specref ref="built-in-types"/>, or they must be imported using
               an <elcode>xsl:import-schema</elcode> declaration.</p>
            <p>The <elcode>xsl:import-schema</elcode> declaration identifies a namespace containing
               the names of the components to be imported (or indicates that components whose names
               are in no namespace are to be imported). The effect is that the names of top-level
               element and attribute declarations and type definitions from this namespace (or
               non-namespace) become available for use within XPath expressions in the <termref def="dt-stylesheet">stylesheet</termref>, and within other stylesheet constructs
               such as the <code>type</code> and <code>as</code> attributes of various <termref def="dt-xslt-element">XSLT elements</termref>.</p>
            <p>The same schema components are available in all stylesheet modules; importing
               components in one stylesheet module makes them available throughout the <termref def="dt-stylesheet">stylesheet</termref>.</p>
            <p>The <code>namespace</code> and <code>schema-location</code> attributes are both
               optional.</p>
            <!--Text replaced by erratum E9 change 1"-->
            <p>If the <elcode>xsl:import-schema</elcode> element contains an <code>xs:schema</code>
               element, then the <code>schema-location</code> attribute <rfc2119>must</rfc2119> be
               absent, and one of the following <rfc2119>must</rfc2119> be true:</p>
            <ulist>
               <item>
                  <p>the <code>namespace</code> attribute of the <elcode>xsl:import-schema</elcode>
                     element and the <code>targetNamespace</code> attribute of the
                        <code>xs:schema</code> element are both absent (indicating a no-namespace
                     schema), or</p>
               </item>
               <item>
                  <p>the <code>namespace</code> attribute of the <elcode>xsl:import-schema</elcode>
                     element and the <code>targetNamespace</code> attribute of the
                        <code>xs:schema</code> element are both present and both have the same
                     value, or</p>
               </item>
               <item>
                  <p>the <code>namespace</code> attribute of the <elcode>xsl:import-schema</elcode>
                     element is absent and the <code>targetNamespace</code> attribute of the
                        <code>xs:schema</code> element is present, in which case the target
                     namespace is as given on the <code>xs:schema</code> element.</p>
               </item>
            </ulist>
            <!--End of text replaced by erratum E9-->
            <p>
               <error spec="XT" type="static" class="SE" code="0215">
                  <p>It is a <termref def="dt-static-error">static error</termref> if an
                        <elcode>xsl:import-schema</elcode> element that contains an
                        <code>xs:schema</code> element has a <code>schema-location</code> attribute,
                     or if it has a <code>namespace</code> attribute that conflicts with the target
                     namespace of the contained schema.</p>
               </error>
            </p>
            <p>If two <elcode>xsl:import-schema</elcode> declarations specify the same namespace, or
               if both specify no namespace, then only the one with highest <termref def="dt-import-precedence">import precedence</termref> is used. If this leaves
               more than one, then all the declarations at the highest import precedence are used
               (which may cause conflicts, as described below).</p>
            <p>After discarding any <elcode>xsl:import-schema</elcode> declarations under the above
               rule, the effect of the remaining <elcode>xsl:import-schema</elcode> declarations is
               defined in terms of a hypothetical document called the synthetic schema document,
               which is constructed as follows. The synthetic schema document defines an arbitrary
               target namespace that is different from any namespace actually used by the
               application, and it contains <code>xs:import</code> elements corresponding
               one-for-one with the <elcode>xsl:import-schema</elcode> declarations in the <termref def="dt-stylesheet">stylesheet</termref>, with the following correspondence:</p>
            <ulist>
               <item>
                  <p>The <code>namespace</code> attribute of the <code>xs:import</code> element is
                     copied from the <code>namespace</code> attribute of the
                        <elcode>xsl:import-schema</elcode> declaration if it is explicitly present,
                     or is implied by the <code>targetNamespace</code> attribute of a contained
                        <code>xs:schema</code> element, and is absent if it is absent.</p>
               </item>
               <item>
                  <p>The <code>schemaLocation</code> attribute of the <code>xs:import</code> element
                     is copied from the <code>schema-location</code> attribute of the
                        <elcode>xsl:import-schema</elcode> declaration if present, and is absent if
                     it is absent. If there is a contained <code>xs:schema</code> element, the
                     effective value of the <code>schemaLocation</code> attribute is a URI
                     referencing a document containing a copy of the <code>xs:schema</code>
                     element.</p>
               </item>
               <item>
                  <p>The base URI of the <code>xs:import</code> element is the same as the base URI
                     of the <elcode>xsl:import-schema</elcode> declaration.</p>
               </item>
            </ulist>
            <p>The schema components included in the <termref def="dt-in-scope-schema-component">in-scope schema components</termref> (that is, the components whose names are
               available for use within the stylesheet) are the top-level element and attribute
               declarations and type definitions that are available for reference within the
               synthetic schema document. See <bibref ref="xmlschema-1"/> (section 4.2.3,
                  <emph>References to schema components across namespaces</emph>).</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0220">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the synthetic
                     schema document does not satisfy the constraints described in <bibref ref="xmlschema-1"/> (section 5.1, <emph>Errors in Schema Construction and
                        Structure</emph>). This includes, without loss of generality, conflicts such
                     as multiple definitions of the same name.</p>
               </error>
            </p>
            <note>
               <p>The synthetic schema document does not need to be constructed by a real
                  implementation. It is purely a mechanism for defining the semantics of
                     <elcode>xsl:import-schema</elcode> in terms of rules that already exist within
                  the XML Schema specification. In particular, it implicitly defines the rules that
                  determine whether the set of <elcode>xsl:import-schema</elcode> declarations are
                  mutually consistent.</p>
               <p>These rules do not cause names to be imported transitively. The fact that a name
                  is available for reference within a schema document A does not of itself make the
                  name available for reference in a stylesheet that imports the target namespace of
                  schema document A. (See <bibref ref="xmlschema-1"/> section 3.15.3, Constraints on
                  XML Representations of Schemas.) The stylesheet must import all the namespaces
                  containing names that it actually references.</p>
               <p>The <code>namespace</code> attribute indicates that a schema for the given
                  namespace is required by the <termref def="dt-stylesheet">stylesheet</termref>.
                  This information may be enough on its own to enable an implementation to locate
                  the required schema components. The <code>namespace</code> attribute may be
                  omitted to indicate that a schema for names in no namespace is being imported. The
                  zero-length string is not a valid namespace URI, and is therefore not a valid
                  value for the <code>namespace</code> attribute.</p>
               <p>The <code>schema-location</code> attribute is a <termref def="dt-uri-reference">URI Reference</termref> that gives a hint indicating where a schema document
                  or other resource containing the required definitions may be found. It is likely
                  that a <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT
                     processor</termref> will be able to process a schema document found at this
                  location.</p>
               <p>The XML Schema specification gives implementations flexibility in how to handle
                  multiple imports for the same namespace. Multiple imports do not cause errors if
                  the definitions do not conflict.</p>
               <p>A consequence of these rules is that it is not intrinsically an error if no schema
                  document can be located for a namespace identified in an
                     <elcode>xsl:import-schema</elcode> declaration. This will cause an error only
                  if it results in the stylesheet containing references to names that have not been
                  imported.</p>
               <p>An inline schema document (using an <code>xs:schema</code> element as a child of
                  the <code>xsl:import-schema</code> element) has the same status as an external
                  schema document, in the sense that it acts as a hint for a source of schema
                  components in the relevant namespace. To ensure that the inline schema document is
                  always used, it is advisable to use a target namespace that is unique to this
                  schema document.</p>
            </note>
            <p>The use of a namespace in an <elcode>xsl:import-schema</elcode> declaration does not
               by itself associate any namespace prefix with the namespace. If names from the
               namespace are used within the stylesheet module then a namespace declaration must be
               included in the stylesheet module, in the usual way.</p>
            <example>
               <head>An Inline Schema Document</head>
               <p>The following example shows an inline schema document. This declares a simple type
                     <code>local:yes-no</code>, which the stylesheet then uses in the declaration of
                  a variable.</p>
               <p>The example assumes the namespace declaration
                     <code>xmlns:local="http://example.com/ns/yes-no"</code>
               </p>
               <eg xml:space="preserve">&lt;xsl:import-schema&gt;
  &lt;xs:schema targetNamespace="http://example.com/ns/yes-no"
             xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;xs:simpleType name="local:yes-no"&gt;
      &lt;xs:restriction base="xs:string"&gt;
        &lt;xs:enumeration value="yes"/&gt;
        &lt;xs:enumeration value="no"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:schema&gt;
&lt;/xsl:import-schema&gt;

&lt;xs:variable name="condition" select="'yes'" as="local:yes-no"/&gt;
</eg>
            </example>
         </div2>
      </div1>
      <div1 id="data-model">
         <head>Data Model</head>
         <p>The data model used by XSLT is the <phrase diff="chg" at="F">XPath 2.1 and XQuery 1.1</phrase> data model (XDM), as defined
            in <bibref ref="xpath-datamodel-11"/>. XSLT operates on source, result and stylesheet
            documents using the same data model.</p>
         <p>This section elaborates on some particular features of XDM as it is used by XSLT:</p>
         <p>The rules in <specref ref="stylesheet-stripping"/> and <specref ref="strip"/> make use
            of the concept of a whitespace text node.</p>
         <p>
            <termdef id="dt-whitespace-text-node" term="whitespace text node">A <term>whitespace
                  text node</term> is a text node whose content consists entirely of whitespace
               characters (that is, #x09, #x0A, #x0D, or #x20).</termdef>
         </p>
         <note>
            <p>Features of a source XML document that are not represented in the XDM tree will have
               no effect on the operation of an XSLT stylesheet. Examples of such features are
               entity references, CDATA sections, character references, whitespace within element
               tags, and the choice of single or double quotes around attribute values.</p>
         </note>
         <div2 id="xml-versions">
            <head>XML Versions</head>
            <p>The XDM data model defined in <bibref ref="xpath-datamodel-11"/> is capable of
               representing either an XML 1.0 document (conforming to <bibref ref="REC-xml"/> and
                  <bibref ref="xml-names"/>) or an XML 1.1 document (conforming to <bibref ref="xml11"/> and <bibref ref="xml-names11"/>), and it makes no distinction
               between the two. In principle, therefore, XSLT <phrase diff="chg" at="A">2.1</phrase>
               can be used with either of these XML versions.</p>
            <p>Construction of the XDM tree is outside the scope of this specification, so XSLT
                  <phrase diff="chg" at="A">2.1</phrase> places no formal requirements on an XSLT
               processor to accept input from either XML 1.0 documents or XML 1.1 documents or both.
               This specification does define a serialization capability (see <specref ref="serialization"/>), though from a conformance point of view it is an optional
               feature. Although facilities are described for serializing the XDM tree as either XML
               1.0 or XML 1.1 (and controlling the choice), there is again no formal requirement on
               an XSLT processor to support either or both of these XML versions as serialization
               targets.</p>
            <p>Because the XDM tree is the same whether the original document was XML 1.0 or XML
               1.1, the semantics of XSLT processing do not depend on the version of XML used by the
               original document. There is no reason in principle why all the input and output
               documents used in a single transformation must conform to the same version of
               XML.</p>
            <p>Some of the syntactic constructs in XSLT <phrase diff="chg" at="A">2.1</phrase> and
               <phrase diff="chg" at="F">XPath 2.1</phrase>, for example the productions <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XML" ref="Char" xlink:type="simple">Char</xnt> and <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names" ref="NT-NCName" xlink:type="simple">NCName</xnt>, are defined by reference to the XML and
               XML Namespaces specifications. There are slight variations between the XML 1.0 and
               XML 1.1 versions of these productions <phrase diff="add" at="D">(and, indeed, between
                  different editions of XML 1.0)</phrase>. Implementations <rfc2119>may</rfc2119>
               support <phrase diff="chg" at="D">any</phrase> version; it is
                  <rfc2119>recommended</rfc2119> that an XSLT <phrase diff="chg" at="A">2.1</phrase>
               processor that implements the 1.1 versions <rfc2119>should</rfc2119> also provide a
               mode that supports the 1.0 versions. It is thus <termref def="dt-implementation-defined">implementation-defined</termref> whether the XSLT
               processor supports XML 1.0 with XML Namespaces 1.0, or XML 1.1 with XML Namespaces
               1.1, or supports both versions at user option.</p>
            <note>
               <p>The specification referenced as <bibref ref="xml-names"/> was actually
                  published without a version number.</p>
            </note>
            <imp-def-feature>It is implementation-defined which versions of XML and XML Namespaces
               (1.0 and/or 1.1) are supported.</imp-def-feature>
            <p><phrase diff="chg" at="D">The current version of <bibref ref="xmlschema-2"/> (that
                  is, XSD 1.0) does not reference the XML 1.1 specifications.</phrase> This means
               that data types such as <code>xs:NCName</code> and <code>xs:ID</code> are constrained
               by the XML 1.0 rules, and do not allow the full range of values permitted by XML 1.1.
               This situation will not be resolved until a new version of <bibref ref="xmlschema-2"/> becomes available; in the meantime, it is <rfc2119>recommended</rfc2119> that
               implementers wishing to support XML 1.1 should consult <bibref ref="SCHEMA-AND-XML-1.1"/> for guidance. An XSLT <phrase diff="chg" at="A">2.1</phrase> processor that supports XML 1.1 <rfc2119>should</rfc2119> implement
               the rules in later versions of <bibref ref="xmlschema-2"/> as they become
               available.</p>
         </div2>
         <div2 id="stylesheet-stripping">
            <head>Stripping Whitespace from the Stylesheet</head>
            <p>The tree representing the stylesheet is preprocessed as follows:</p>
            <olist>
               <item>
                  <p>All comments and processing instructions are removed.</p>
               </item>
               <item>
                  <p>Any text nodes that are now adjacent to each other are merged.</p>
               </item>
               <item>
                  <p>Any <termref def="dt-whitespace-text-node">whitespace text node</termref> that
                     satisfies both the following conditions is removed from the tree:</p>
                  <ulist>
                     <item>
                        <p>The parent of the text node is not an <elcode>xsl:text</elcode>
                           element</p>
                     </item>
                     <item>
                        <p>The text node does not have an ancestor element that has an
                              <code>xml:space</code> attribute with a value of
                           <code>preserve</code>, unless there is a closer ancestor element having
                           an <code>xml:space</code> attribute with a value of
                           <code>default</code>.</p>
                     </item>
                  </ulist>
               </item>
               <item>
                  <p>Any <termref def="dt-whitespace-text-node">whitespace text node</termref> whose
                     parent is one of the following elements is removed from the tree, regardless of
                     any <code>xml:space</code> attributes:</p>
                  <slist>
                     <sitem>
                        <elcode>xsl:analyze-string</elcode>
                     </sitem>
                     <sitem>
                        <elcode>xsl:apply-imports</elcode>
                     </sitem>
                     <sitem>
                        <elcode>xsl:apply-templates</elcode>
                     </sitem>
                     <sitem>
                        <elcode>xsl:attribute-set</elcode>
                     </sitem>
                     <sitem>
                        <elcode>xsl:call-template</elcode>
                     </sitem>
                     <sitem>
                        <elcode>xsl:character-map</elcode>
                     </sitem>
                     <sitem>
                        <elcode>xsl:choose</elcode>
                     </sitem>
                     <sitem>
                        <phrase diff="add" at="B">
                           <elcode>xsl:evaluate</elcode>
                        </phrase>
                     </sitem>
                     <sitem>
                        <phrase diff="add" at="D">
                           <elcode>xsl:merge</elcode>
                        </phrase>
                     </sitem>
                     <sitem>
                        <phrase diff="add" at="D">
                           <elcode>xsl:merge-source</elcode>
                        </phrase>
                     </sitem>
                     <sitem>
                        <phrase diff="add" at="D">
                           <elcode>xsl:next-iteration</elcode>
                        </phrase>
                     </sitem>
                     <sitem>
                        <elcode>xsl:next-match</elcode>
                     </sitem>
                     <sitem>
                        <elcode>xsl:stylesheet</elcode>
                     </sitem>
                     <sitem>
                        <elcode>xsl:transform</elcode>
                     </sitem>
                  </slist>
               </item>
               <item>
                  <p>Any <termref def="dt-whitespace-text-node">whitespace text node</termref> whose
                     immediate following-sibling node is an <phrase diff="add" at="D"><elcode>xsl:merge-key</elcode>,</phrase>
                     <elcode>xsl:param</elcode>, or <elcode>xsl:sort</elcode> element is removed
                     from the tree, regardless of any <code>xml:space</code> attributes.</p>
               </item>
               <item>
                  <p diff="add" at="B">Any <termref def="dt-whitespace-text-node">whitespace text
                        node</termref> whose immediate preceding-sibling node is an
                        <elcode>xsl:catch</elcode> or <elcode>xsl:on-completion</elcode> element is
                     removed from the tree, regardless of any <code>xml:space</code> attributes.</p>
               </item>
            </olist>
            <p>
               <error spec="XT" type="static" class="SE" code="0260">
                  <p>Within an <termref def="dt-xslt-element">XSLT element</termref> that is
                        <rfc2119>required</rfc2119> to be empty, any content other than comments or
                     processing instructions, including any <termref def="dt-whitespace-text-node">whitespace text node</termref> preserved using the
                        <code>xml:space="preserve"</code> attribute, is a <termref def="dt-static-error">static error</termref>.</p>
               </error>
            </p>
            <note>
               <p>Using <code>xml:space="preserve"</code> in parts of the stylesheet that contain
                     <termref def="dt-sequence-constructor">sequence constructors</termref> will
                  cause all text nodes in that part of the stylesheet, including those that contain
                  whitespace only, to be copied to the result of the sequence constructor. When the
                  result of the sequence constructor is used to form the content of an element, this
                  can cause errors if such text nodes are followed by attribute nodes generated
                  using <elcode>xsl:attribute</elcode>.</p>
            </note>
            <note>
               <p>If an <code>xml:space</code> attribute is specified on a <termref def="dt-literal-result-element">literal result element</termref>, it will be
                  copied to the result tree in the same way as any other attribute.</p>
            </note>
         </div2>
         <div2 id="stripping-annotations">
            <head>Stripping Type Annotations from a Source Tree</head>
            <p>
               <termdef id="dt-annotation" term="type annotation">The term <term>type
                     annotation</term> is used in this specification to refer to the value returned
                  by the <code>dm:type-name</code> accessor of a node: see <xspecref spec="DM11" ref="dm-type-name"/>.</termdef>
            </p>
            <p>There is sometimes a requirement to write stylesheets that produce the same results
               whether or not the source documents have been validated against a schema. To achieve
               this, an option is provided to remove any <termref def="dt-annotation">type
                  annotations</termref> on element and attribute nodes in a <termref def="dt-source-tree">source tree</termref>, replacing them with an annotation of
                  <code>xs:untyped</code> in the case of element nodes, and
                  <code>xs:untypedAtomic</code> in the case of attribute nodes.</p>
            <p>Such stripping of <termref def="dt-annotation">type annotations</termref> can be
               requested by specifying <code>input-type-annotations="strip"</code> on the
                  <elcode>xsl:stylesheet</elcode> element. This attribute has three permitted
               values: <code>strip</code>, <code>preserve</code>, and <code>unspecified</code>. The
               default value is <code>unspecified</code>. Stripping of type annotations takes place
               if at least one <termref def="dt-stylesheet-module">stylesheet module</termref> in
               the <termref def="dt-stylesheet">stylesheet</termref> specifies
                  <code>input-type-annotations="strip"</code>.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0265">
                  <p> It is a <termref def="dt-static-error">static error</termref> if there is a
                        <termref def="dt-stylesheet-module">stylesheet module</termref> in the
                        <termref def="dt-stylesheet">stylesheet</termref> that specifies
                        <code>input-type-annotations="strip"</code> and another <termref def="dt-stylesheet-module">stylesheet module</termref> that specifies
                        <code>input-type-annotations="preserve"</code>.</p>
               </error>
            </p>
            <p>The <termref def="dt-source-tree">source trees</termref> to which this applies are
               the same as those affected by <elcode>xsl:strip-space</elcode> and
                  <elcode>xsl:preserve-space</elcode>: see <specref ref="strip"/>.</p>
            <p>When type annotations are stripped, the following changes are made to the source
               tree:</p>
            <ulist>
               <item>
                  <p>The type annotation of every element node is changed to <code>xs:untyped</code>
                  </p>
               </item>
               <item>
                  <p>The type annotation of every attribute node is changed to
                        <code>xs:untypedAtomic</code>
                  </p>
               </item>
               <item>
                  <p>The typed value of every element and attribute node is set to be the same as
                     its string value, as an instance of <code>xs:untypedAtomic</code>.</p>
               </item>
               <item>
                  <p>The <code>is-nilled</code> property of every element node is set to
                        <code>false</code>.</p>
               </item>
            </ulist>
            <p>The values of the <code>is-id</code> and <code>is-idrefs</code> properties are not
               changed.</p>
            <note>
               <p>Stripping type annotations does not necessarily return the document to the state
                  it would be in had validation not taken place. In particular, any defaulted
                  elements and attributes that were added to the tree by the validation process will
                  still be present , and elements and attributes validated as IDs will still be
                  accessible using the <xfunction>id</xfunction> function.</p>
            </note>
         </div2>
         <div2 id="strip">
            <head>Stripping Whitespace from a Source Tree</head>
            <p>A <termref def="dt-source-tree">source tree</termref> supplied as input to the
               transformation process may contain <termref def="dt-whitespace-text-node">whitespace
                  text nodes</termref> that are of no interest, and that do not need to be retained
               by the transformation. Conceptually, an XSLT <termref def="dt-processor">processor</termref> makes a copy of the source tree from which unwanted <termref def="dt-whitespace-text-node">whitespace text nodes</termref> have been removed.
               This process is referred to as whitespace stripping. </p>
            <p>For the purposes of this section, the term <term>source tree</term> means the
               document containing the <termref def="dt-initial-context-item">initial context
                  item</termref>
               <phrase diff="chg" at="E">if it is a node</phrase>, and any document returned by the
               functions <function>document</function>, <xfunction>doc</xfunction>, or
                  <xfunction>collection</xfunction>. It does not include documents passed as the
               values of <termref def="dt-stylesheet-parameter">stylesheet parameters</termref> or
               returned from <termref def="dt-extension-function">extension functions</termref>.</p>
            <p>The stripping process takes as input a set of element names whose child <termref def="dt-whitespace-text-node">whitespace text nodes</termref> are to be preserved.
               The way in which this set of element names is established using the
                  <elcode>xsl:strip-space</elcode> and <elcode>xsl:preserve-space</elcode>
               declarations is described later in this section.</p>
            <p>A <termref def="dt-whitespace-text-node">whitespace text node</termref> is preserved
               if either of the following apply:</p>
            <ulist>
               <item>
                  <p>The element name of the parent of the text node is in the set of
                     whitespace-preserving element names.</p>
               </item>
               <item>
                  <p>An ancestor element of the text node has an <code>xml:space</code> attribute
                     with a value of <code>preserve</code>, and no closer ancestor element has
                        <code>xml:space</code> with a value of <code>default</code>.</p>
               </item>
            </ulist>
            <p>Otherwise, the <termref def="dt-whitespace-text-node">whitespace text node</termref>
               is stripped.</p>
            <p>The <code>xml:space</code> attributes are not removed from the tree.</p>
            <e:element-syntax name="strip-space">
               <e:in-category name="declaration"/>
               <e:attribute name="elements" required="yes">
                  <e:data-type name="tokens"/>
               </e:attribute>
               <e:empty/>
               <e:allowed-parents>
                  <e:parent name="stylesheet"/>
                  <e:parent name="transform"/>
               </e:allowed-parents>
            </e:element-syntax>
            <e:element-syntax name="preserve-space">
               <e:in-category name="declaration"/>
               <e:attribute name="elements" required="yes">
                  <e:data-type name="tokens"/>
               </e:attribute>
               <e:empty/>
               <e:allowed-parents>
                  <e:parent name="stylesheet"/>
                  <e:parent name="transform"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The set of whitespace-preserving element names is specified by
                  <elcode>xsl:strip-space</elcode> and <elcode>xsl:preserve-space</elcode>
               <termref def="dt-declaration">declarations</termref>. Whether an element name is
               included in the set of whitespace-preserving names is determined by the best match
               among all the <elcode>xsl:strip-space</elcode> or <elcode>xsl:preserve-space</elcode>
               declarations: it is included if and only if there is no match or the best match is an
                  <elcode>xsl:preserve-space</elcode> element. The <elcode>xsl:strip-space</elcode>
               and <elcode>xsl:preserve-space</elcode> elements each have an <code>elements</code>
               attribute whose value is a whitespace-separated list of <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-NameTest" xlink:type="simple">NameTests</xnt>; an element name matches an
                  <elcode>xsl:strip-space</elcode> or <elcode>xsl:preserve-space</elcode> element if
               it matches one of the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-NameTest" xlink:type="simple">NameTests</xnt>.
               An element matches a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-NameTest" xlink:type="simple">NameTest</xnt> if
               and only if the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-NameTest" xlink:type="simple">NameTest</xnt> would be
               true for the element as an XPath node test. When more than one
                  <elcode>xsl:strip-space</elcode> and <elcode>xsl:preserve-space</elcode> element
               matches, the best matching element is determined by the best matching <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-NameTest" xlink:type="simple">NameTest</xnt>. This is determined in the
               same way as with <termref def="dt-template-rule">template rules</termref>:</p>
            <ulist>
               <item>
                  <p>First, any match with lower <termref def="dt-import-precedence">import
                        precedence</termref> than another match is ignored.</p>
               </item>
               <item>
                  <p>Next, any match that has a lower <termref def="dt-default-priority">default
                        priority</termref> than the <termref def="dt-default-priority">default
                        priority</termref> of another match is ignored.</p>
               </item>
            </ulist>
            <p>
               <error spec="XT" type="dynamic" class="RE" code="0270">
                  <p>It is a <termref def="dt-recoverable-error">recoverable dynamic error</termref>
                     if this <error.extra>the process of finding an <elcode>xsl:strip-space</elcode>
                        or <elcode>xsl:preserve-space</elcode> declaration to match an element in
                        the source document</error.extra> leaves more than one match, unless all the
                     matched declarations are equivalent (that is, they are all
                        <elcode>xsl:strip-space</elcode> or they are all
                        <elcode>xsl:preserve-space</elcode>). <error.action>The <termref def="dt-optional-recovery-action">optional recovery action</termref> is
                        to select, from the matches that are left, the one that occurs last in
                           <termref def="dt-declaration-order">declaration order</termref>.
                     </error.action>
                  </p>
               </error>
            </p>
            <issue id="issue-multiple-match-on-strip-space" status="open"><p>We have changed the rules for handling
            ambiguous matches on template rules. Should we make a corresponding change for ambiguous matches
            on <elcode>xsl:strip-space</elcode>, or is this overkill? What is the corresponding change anyway?</p></issue>
            <p>If an element in a source document has a <termref def="dt-annotation">type
                  annotation</termref> that is a simple type or a complex type with simple content,
               then any whitespace text nodes among its children are preserved, regardless of any
                  <elcode>xsl:strip-space</elcode> declarations. The reason for this is that
               stripping a whitespace text node from an element with simple content could make the
               element invalid: for example, it could cause the <code>minLength</code> facet to be
               violated.</p>
            <p>Stripping of <termref def="dt-annotation">type annotations</termref> happens before
               stripping of whitespace text nodes, so this situation will not occur if
                  <code>input-type-annotations="strip"</code> is specified.</p>
            <note>
               <p>In <bibref ref="xpath-datamodel-11"/>, processes are described for constructing an
                  XDM tree from an Infoset or from a PSVI. Those processes deal with whitespace
                  according to their own rules, and the provisions in this section apply to the
                  resulting tree. In practice this means that elements that are defined in a DTD or
                  a Schema to contain element-only content will have <termref def="dt-whitespace-text-node">whitespace text nodes</termref> stripped,
                  regardless of the <elcode>xsl:strip-space</elcode> and
                     <elcode>xsl:preserve-space</elcode> declarations in the stylesheet.</p>
               <p>However, source trees are not necessarily constructed using those processes;
                  indeed, they are not necessarily constructed by parsing XML documents. Nothing in
                  the XSLT specification constrains how the source tree is constructed, or what
                  happens to <termref def="dt-whitespace-text-node">whitespace text nodes</termref>
                  during its construction. The provisions in this section relate only to whitespace
                  text nodes that are present in the tree supplied as input to the XSLT processor.
                  The XSLT processor cannot preserve whitespace text nodes unless they were actually
                  present in the supplied tree.</p>
            </note>
         </div2>
         <div2 id="id-in-data-model">
            <head>Attribute Types and DTD Validation</head>
            <p>The mapping from the Infoset to the XDM data model, described in <bibref ref="xpath-datamodel-11"/>, does not retain attribute types. This means, for example,
               that an attribute described in the DTD as having attribute type <code>NMTOKENS</code>
               will be annotated in the XDM tree as <code>xs:untypedAtomic</code> rather than
                  <code>xs:NMTOKENS</code>, and its typed value will consist of a single
                  <code>xs:untypedAtomic</code> value rather than a sequence of
                  <code>xs:NMTOKEN</code> values.</p>
            <p>Attributes with a DTD-derived type of ID, IDREF, or IDREFS will be marked in the XDM
               tree as having the <code>is-id</code> or <code>is-idrefs</code> properties. It is
               these properties, rather than any <termref def="dt-annotation">type
                  annotation</termref>, that are examined by the functions <xfunction>id</xfunction>
               and <xfunction>idref</xfunction> described in <bibref ref="xpath-functions-11"/>.</p>
         </div2>
         <div2 id="model-for-streaming" diff="add" at="C">
            <head>Data Model for Streaming</head>
            <p>The data model for nodes in a document that is being streamed is no different from
               the standard XDM data model, in that it contains the same objects (nodes) with the
               same properties and relationships. The facilities for streaming do not change the
               data model; instead they impose rules that limit the ability of stylesheets to
               navigate the data model.</p>
            <p>A useful way to visualize streaming is to suppose that at any point in
               time, there is a current position in the streamed input document which may be the
               start or end of the document, the start or end tag of an element, or a text, comment,
               or processing instruction node. From this position, the stylesheet has access to the
               following information: </p>
            <ulist>
               <item>
                  <p>Properties intrinsic to the node, such as its name, its base URI, its type
                     annotation, and its <code>is-id</code> and <code>is-idref</code>
                     properties.</p>
               </item>
               <item>
                  <p>The ancestors of the node (but navigation downwards from the ancestors is not
                     permitted).</p>
               </item>
               <item>
                  <p>The attributes of the node, and the attributes of its ancestors. For each such
                     attribute, all the properties of the node including its string value and typed
                     value are available, but there are limitations that restrict navigation from
                     the attribute node to other nodes in the document.</p>
               </item>
               <item>
                  <p>The in-scope namespace bindings of the node.</p>
               </item>
               <item>
                  <p>In the case of attributes, text nodes, comments, and processing instructions,
                     the string value and typed value of the node.</p>
               </item>
               <item>
                  <p>Summary data about the preceding siblings of the node, and of each of its
                     ancestor nodes: specifically, for each distinct combination of node kind, node
                     name, and type annotation, a count of the number of preceding siblings that
                     have that combination of properties. This information allows patterns such as
                        <code>match="para[1]"</code> to be used, and it permits some limited use of
                     the <elcode>xsl:number</elcode> instruction.</p>
               </item>
            </ulist>
            <p>The children and other descendants of a node are not accessible except as a
               by-product of changing the current position in the document. The same applies to
               properties of an element or document node that require examination of the node's
               descendants, that is, the string value and typed value. This is enforced by means of
               a rule that only one expression requiring downward navigation from a node is
               permitted.</p>
            <p>The detailed rules are defined in <specref ref="streamability"/>.</p>
         </div2>
         <div2 id="limits">
            <head>Limits</head>
            <p>The XDM data model (see <bibref ref="xpath-datamodel-11"/>) leaves it to the host
               language to define limits. This section describes the limits that apply to XSLT.</p>
            <p>Limits on some primitive data types are defined in <bibref ref="xmlschema-2"/>. Other
               limits, listed below, are <termref def="dt-implementation-defined">implementation-defined</termref>. Note that this does not necessarily mean that
               each limit must be a simple constant: it may vary depending on environmental factors
               such as available resources.</p>
            <imp-def-feature>Limits on the value space of primitive data types, where not fixed by
                  <bibref ref="xmlschema-2"/>, are implementation-defined.</imp-def-feature>
            <p>The following limits are <termref def="dt-implementation-defined">implementation-defined</termref>:</p>
            <olist>
               <item>
                  <p>For the <code>xs:decimal</code> type, the maximum number of decimal digits (the
                        <code>totalDigits</code> facet). This must be at least 18 digits. (Note,
                     however, that support for the full value range of <code>xs:unsignedLong</code>
                     requires 20 digits.) </p>
               </item>
               <item>
                  <p>For the types <code>xs:date</code>, <code>xs:time</code>,
                        <code>xs:dateTime</code>, <code>xs:gYear</code>, and
                        <code>xs:gYearMonth</code>: the range of values of the year component, which
                     must be at least +0001 to +9999; and the maximum number of fractional second
                     digits, which must be at least 3.</p>
               </item>
               <item>
                  <p>For the <code>xs:duration</code> type: the maximum absolute values of the
                     years, months, days, hours, minutes, and seconds components. </p>
               </item>
               <item>
                  <p>For the <code>xs:yearMonthDuration</code> type: the maximum absolute value,
                     expressed as an integer number of months.</p>
               </item>
               <item>
                  <p>For the <code>xs:dayTimeDuration</code> type: the maximum absolute value,
                     expressed as a decimal number of seconds.</p>
               </item>
               <item>
                  <p>For the types <code>xs:string</code>, <code>xs:hexBinary</code>,
                        <code>xs:base64Binary</code>, <code>xs:QName</code>, <code>xs:anyURI</code>,
                        <code>xs:NOTATION</code>, and types derived from them: the maximum length of
                     the value. </p>
               </item>
               <item>
                  <p>For sequences, the maximum number of items in a sequence.</p>
               </item>
            </olist>
         </div2>
         <div2 id="d-o-e-in-data-model">
            <head>Disable Output Escaping</head>
            <p>For backwards compatibility reasons, XSLT <phrase diff="chg" at="A">2.1</phrase>
               continues to support the <code>disable-output-escaping</code> feature introduced in
               XSLT 1.0. This is an optional feature and implementations are not
                  <rfc2119>required</rfc2119> to support it. A new facility, that of named <termref def="dt-character-map">character maps</termref> (see <specref ref="character-maps"/>) <phrase diff="chg" at="A">was</phrase> introduced in XSLT 2.0. It provides
               similar capabilities to <code>disable-output-escaping</code>, but without distorting
               the data model.</p>
            <p>If an <termref def="dt-implementation">implementation</termref> supports the
                  <code>disable-output-escaping</code> attribute of <elcode>xsl:text</elcode> and
                  <elcode>xsl:value-of</elcode>, (see <specref ref="disable-output-escaping"/>),
               then the data model for trees constructed by the <termref def="dt-processor">processor</termref> is augmented with a boolean value representing the value of
               this property. This boolean value, however, can be set only within a <termref def="dt-final-result-tree">final result tree</termref> that is being passed to the
               serializer.</p>
            <p>Conceptually, each character in a text node on such a result tree has a boolean
               property indicating whether the serializer is to disable the normal rules for
               escaping of special characters (for example, outputting of <code>&amp;</code> as
                  <code>&amp;amp;</code>) in respect of this character or attribute node.</p>
            <note>
               <p>In practice, the nodes in a <termref def="dt-final-result-tree">final result
                     tree</termref> will often be streamed directly from the XSLT processor to the
                  serializer. In such an implementation, <code>disable-output-escaping</code> can be
                  viewed not so much a property stored with nodes in the tree, but rather as
                  additional information passed across the interface between the XSLT processor and
                  the serializer.</p>
            </note>
         </div2>
      </div1>
      <div1 id="constructs">
         <head>Features of the XSLT Language</head>
         <div2 id="qname">
            <head>Qualified Names</head>
            <p>The name of a stylesheet-defined object, specifically a <termref def="dt-named-template">named template</termref>, a <termref def="dt-mode">mode</termref>, an <termref def="dt-attribute-set">attribute set</termref>, a
                  <termref def="dt-key">key</termref>, a <termref def="dt-decimal-format">decimal-format</termref>, a <termref def="dt-variable">variable</termref> or
                  <termref def="dt-parameter">parameter</termref>, a <termref def="dt-stylesheet-function">stylesheet function</termref>, a named <termref def="dt-output-definition">output definition</termref>, or a <termref def="dt-character-map">character map</termref> is specified as a <termref def="dt-qname">QName</termref> using the syntax for <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names" ref="NT-QName" xlink:type="simple">QName</xnt> as defined in <bibref ref="xml-names"/>.</p>
            <p>
               <termdef id="dt-qname" term="QName">A <term>QName</term> is always written in the
                  form <code>(NCName ":")? NCName</code>, that is, a local name optionally preceded
                  by a namespace prefix. When two QNames are compared, however, they are considered
                  equal if the corresponding <termref def="dt-expanded-qname">expanded-QNames</termref> are the same, as described below.</termdef>
            </p>
            <p>Because an atomic value of type <code>xs:QName</code> is sometimes referred to
               loosely as a QName, this specification also uses the term <termref def="dt-lexical-qname">lexical QName</termref> to emphasize that it is referring
               to a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names" ref="NT-QName" xlink:type="simple">QName</xnt> in its lexical form rather than its
               expanded form. This term is used especially when strings containing lexical QNames
               are manipulated as run-time values.</p>
            <p>
               <termdef id="dt-lexical-qname" term="lexical QName">A <term>lexical QName</term> is a
                  string representing a <termref def="dt-qname">QName</termref> in the form
                     <code>(NCName ":")? NCName</code>, that is, a local name optionally preceded by
                  a namespace prefix.</termdef>
            </p>
            <p>
               <termdef id="dt-defining-element" term="defining element">A string in the form of a
                  lexical QName may occur as the value of an attribute node in a stylesheet module,
                  or within an XPath <termref def="dt-expression">expression</termref> contained in
                  such an attribute node, or as the result of evaluating an XPath expression
                  contained in such an attribute node. The element containing this attribute node is
                  referred to as the <term>defining element</term> of the QName.</termdef>
            </p>
            <p>
               <termdef id="dt-expanded-qname" term="expanded-QName">An <term>expanded-QName</term>
                  contains a pair of values, namely a local name and an optional namespace URI. It
                  may also contain a namespace prefix. Two expanded-QNames are equal if the
                  namespace URIs are the same (or both absent) and the local names are the same. The
                  prefix plays no part in the comparison, but is used only if the expanded-QName
                  needs to be converted back to a string.</termdef>
            </p>
            <p>If the QName has a prefix, then the prefix is expanded into a URI reference using the
               namespace declarations in effect on its <termref def="dt-defining-element">defining
                  element</termref>. The <termref def="dt-expanded-qname">expanded-QName</termref>
               consisting of the local part of the name and the possibly null URI reference is used
               as the name of the object. The default namespace of the defining element (see
                  <xspecref spec="DM11" ref="ElementNode"/>) is <emph>not</emph> used for unprefixed
               names.</p>
            <p>There are three cases where the default namespace of the <termref def="dt-defining-element">defining element</termref>
               <emph>is</emph> used when expanding an unprefixed QName:</p>
            <olist>
               <item>
                  <p>Where a QName is used to define the name of an element being constructed. This
                     applies both to cases where the name is known statically (that is, the name of
                     a literal result element) and to cases where it is computed dynamically (the
                     value of the <code>name</code> attribute of the <elcode>xsl:element</elcode>
                     instruction).</p>
               </item>
               <item>
                  <p>The default namespace is used when expanding the first argument of the function
                        <function>element-available</function>.</p>
               </item>
               <item>
                  <p>The default namespace applies to any unqualified element names appearing in the
                        <code>cdata-section-elements</code> attribute of <elcode>xsl:output</elcode>
                     or <elcode>xsl:result-document</elcode>
                  </p>
               </item>
            </olist>
            <p>In the case of an unprefixed QName used as a <code>NameTest</code> within an XPath
                  <termref def="dt-expression">expression</termref> (see <specref ref="expressions"/>) , and in certain other contexts, the namespace to be used in expanding the QName
               may be specified by means of the <code>[xsl:]xpath-default-namespace</code>
               attribute, as specified in <specref ref="unprefixed-qnames"/>.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0280">
                  <p>In the case of a prefixed <termref def="dt-qname">QName</termref> used as the
                     value of an attribute in the <termref def="dt-stylesheet">stylesheet</termref>,
                     or appearing within an XPath <termref def="dt-expression">expression</termref>
                     in the stylesheet, it is a <termref def="dt-static-error">static
                        error</termref> if the <termref def="dt-defining-element">defining
                        element</termref> has no namespace node whose name matches the prefix of the
                        <termref def="dt-qname">QName</termref>.</p>
               </error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0290">
                  <p>Where the result of evaluating an XPath expression (or an attribute value
                     template) is required to be a <termref def="dt-lexical-qname">lexical
                        QName</termref>, then unless otherwise specified it is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if the
                        <termref def="dt-defining-element">defining element</termref> has no
                     namespace node whose name matches the prefix of the <termref def="dt-lexical-qname">lexical QName</termref>. This error
                        <rfc2119>may</rfc2119> be signaled as a <termref def="dt-static-error">static error</termref> if the value of the expression can be determined
                     statically.</p>
               </error>
            </p>
         </div2>
         <div2 id="unprefixed-qnames">
            <head>Unprefixed QNames in Expressions and Patterns</head>
            <p>The attribute <code>[xsl:]xpath-default-namespace</code> (see <specref ref="standard-attributes"/>) may be used on an element in the <termref def="dt-stylesheet">stylesheet</termref> to define the namespace that will be used
               for an unprefixed element name or type name within an XPath expression, and in
               certain other contexts listed below.</p>
            <p>The value of the attribute is the namespace URI to be used.</p>
            <p>For any element in the <termref def="dt-stylesheet">stylesheet</termref>, this
               attribute has an effective value, which is the value of the
                  <code>[xsl:]xpath-default-namespace</code> on that element or on the innermost
               containing element that specifies such an attribute, or the zero-length string if no
               containing element specifies such an attribute.</p>
            <p>For any element in the <termref def="dt-stylesheet">stylesheet</termref>, the
               effective value of this attribute determines the value of the <emph>default namespace
                  for element and type names</emph> in the static context of any XPath expression
               contained in an attribute of that element (including XPath expressions in <termref def="dt-attribute-value-template">attribute value templates</termref>). The effect
               of this is specified in <bibref ref="xpath-21"/>; in summary, it determines the
               namespace used for any unprefixed type name in the SequenceType production, and for
               any element name appearing in a path expression or in the SequenceType
               production.</p>
            <p>The effective value of this attribute similarly applies to any of the following
               constructs appearing within its scope:</p>
            <ulist>
               <item>
                  <p>any unprefixed element name or type name used in a <termref def="dt-pattern">pattern</termref>
                  </p>
               </item>
               <item>
                  <p>any unprefixed element name used in the <code>elements</code> attribute of the
                        <elcode>xsl:strip-space</elcode> or <elcode>xsl:preserve-space</elcode>
                     instructions</p>
               </item>
               <item>
                  <p>any unprefixed element name or type name used in the <code>as</code> attribute
                     of an <termref def="dt-xslt-element">XSLT element</termref>
                  </p>
               </item>
               <item>
                  <p>any unprefixed type name used in the <code>type</code> attribute of an <termref def="dt-xslt-element">XSLT element</termref>
                  </p>
               </item>
               <item>
                  <p>any unprefixed type name used in the <code>xsl:type</code> attribute of a
                        <termref def="dt-literal-result-element">literal result
                     element</termref>.</p>
               </item>
            </ulist>
            <p>The <code>[xsl:]xpath-default-namespace</code> attribute <rfc2119>must</rfc2119> be
               in the <termref def="dt-xslt-namespace">XSLT namespace</termref> if and only if its
               parent element is <emph>not</emph> in the XSLT namespace.</p>
            <p>If the effective value of the attribute is a zero-length string, which will be the
               case if it is explicitly set to a zero-length string or if it is not specified at
               all, then an unprefixed element name or type name refers to a name that is in no
               namespace. The default namespace of the parent element (see <xspecref spec="DM11" ref="ElementNode"/>) is <emph>not</emph> used.</p>
            <p>The attribute does not affect other names, for example function names, variable
               names, or template names, or strings that are interpreted as <termref def="dt-lexical-qname">lexical QNames</termref> during stylesheet evaluation, such
               as the <termref def="dt-effective-value">effective value</termref> of the
                  <code>name</code> attribute of <elcode>xsl:element</elcode> or the string supplied
               as the first argument to the <function>key</function> function.</p>
         </div2>
         <div2 id="expressions">
            <head>Expressions</head>
            <p>XSLT uses the expression language defined by <phrase>XPath 2.1</phrase>
               <bibref ref="xpath-21"/>. Expressions are used in XSLT for a variety of purposes
               including:</p>
            <ulist>
               <item>
                  <p>selecting nodes for processing;</p>
               </item>
               <item>
                  <p>specifying conditions for different ways of processing a node;</p>
               </item>
               <item>
                  <p>generating text to be inserted in a <termref def="dt-result-tree">result
                        tree</termref>.</p>
               </item>
            </ulist>
            <p>
               <termdef id="dt-expression" term="expression">Within this specification, the term
                     <term>XPath expression</term>, or simply <term>expression</term>, means a
                  string that matches the production <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-Expr" xlink:type="simple">Expr</xnt> defined in <bibref ref="xpath-21"/>.</termdef>
            </p>
            <p>An XPath expression may occur as the value of certain attributes on XSLT-defined
               elements, and also within curly brackets in <termref def="dt-attribute-value-template">attribute value templates</termref>.</p>
            <p>Except where <termref def="dt-forwards-compatible-behavior"/> is enabled 
               (see <specref ref="forwards"/>), it is a <termref def="dt-static-error">static error</termref> if the value of such an attribute,
                  <error.extra>an attribute defined as containing an XPath <termref def="dt-expression">expression</termref>
               </error.extra> or the text between curly brackets in an attribute value template,
               does not match the XPath production <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-Expr" xlink:type="simple">Expr</xnt>, or if it fails to satisfy other static constraints defined in the
               XPath specification, for example that all variable references <rfc2119>must</rfc2119>
               refer to <termref def="dt-variable">variables</termref> that are in scope. Error
               codes are defined in <bibref ref="xpath-21"/>.</p>
            <p>The transformation fails with a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if any XPath <termref def="dt-expression">expression</termref> is evaluated and raises a dynamic error. Error codes are
               defined in <bibref ref="xpath-21"/>.</p>
            <p>The transformation fails with a <termref def="dt-type-error">type error</termref> if
               an XPath <termref def="dt-expression">expression</termref> raises a type error, or if
               the result of evaluating the XPath <termref def="dt-expression">expression</termref>
               is evaluated and raises a type error, or if the XPath processor signals a type error
               during static analysis of an <termref def="dt-expression">expression</termref>. Error
               codes are defined in <bibref ref="xpath-21"/>.</p>
            <p>
               <termdef id="dt-required-type" term="required type">The context within a <termref def="dt-stylesheet">stylesheet</termref> where an XPath <termref def="dt-expression">expression</termref> appears may specify the <term>required
                     type</term> of the expression. The required type indicates the type of the
                  value that the expression is expected to return.</termdef> If no required type is
               specified, the expression may return any value: in effect, the required type is then
                  <code>item()*</code>. </p>
            <p>
               <termdef id="dt-function-conversion-rules" term="function conversion rules">Except
                  where otherwise indicated, the actual value of an <termref def="dt-expression">expression</termref> is converted to the <termref def="dt-required-type">required type</termref> using the <term>function conversion rules</term>.
                  These are the rules defined in <bibref ref="xpath-21"/> for converting the
                  supplied argument of a function call to the required type of that argument, as
                  defined in the function signature. The relevant rules are those that apply when
                     <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> is
                  set to <code>false</code>.</termdef>
            </p>
            <p>This specification also invokes the <phrase diff="chg" at="D">XPath 2.1</phrase>
               <termref def="dt-function-conversion-rules">function conversion rules</termref> to
               convert the result of evaluating an XSLT <termref def="dt-sequence-constructor">sequence constructor</termref> to a required type (for example, the sequence
               constructor enclosed in an <elcode>xsl:variable</elcode>,
                  <elcode>xsl:template</elcode>, or <elcode>xsl:function</elcode> element).</p>
            <p>Any <termref def="dt-dynamic-error">dynamic error</termref> or <termref def="dt-type-error">type error</termref> that occurs when applying the <termref def="dt-function-conversion-rules">function conversion rules</termref> to convert
               a value to a required type results in the transformation failing, in the same way as
               if the error had occurred while evaluating an expression.</p>
            <note>
               <p>Note the distinction between the two kinds of error that may occur. Attempting to
                  convert an integer to a date is a type error, because such a conversion is never
                  possible. Type errors can be reported statically if they can be detected
                  statically, whether or not the construct in question is ever evaluated. Attempting
                  to convert the string <code>2003-02-29</code> to a date is a dynamic error rather
                  than a type error, because the problem is with this particular value, not with its
                  type. Dynamic errors are reported only if the instructions or expressions that
                  cause them are actually evaluated.</p>
            </note>
         </div2>
         <div2 id="static-and-dynamic-context">
            <head>The Static and Dynamic Context</head>
            <p>XPath defines the concept of an <xtermref spec="XP21" ref="dt-expression-context">expression context</xtermref> which contains all the information that can affect
               the result of evaluating an <termref def="dt-expression">expression</termref>. The
               expression context has two parts, the <xtermref spec="XP21" ref="dt-static-context">static context</xtermref>, and the <xtermref spec="XP21" ref="dt-dynamic-context">dynamic context</xtermref>. The components that make up the expression context
               are defined in the XPath specification (see <xspecref spec="XP21" ref="context"/>).
               This section describes the way in which these components are initialized when an
               XPath expression is contained within an XSLT stylesheet.</p>
            <p>As well as providing values for the static and dynamic context components defined in
               the XPath specification, XSLT defines additional context components of its own. These
               context components are used by XSLT instructions (for example,
                  <elcode>xsl:next-match</elcode> and <elcode>xsl:apply-imports</elcode>), and also
               by the functions in the extended function library described in this
               specification.</p>
            <p>The following four sections describe:</p>
            <slist>
               <sitem>
                  <specref ref="static-context"/>
               </sitem>
               <sitem>
                  <specref ref="additional-static-context"/>
               </sitem>
               <sitem>
                  <specref ref="xpath-dynamic-context"/>
               </sitem>
               <sitem>
                  <specref ref="additional-dynamic-context"/>
               </sitem>
            </slist>
            <div3 id="static-context">
               <head>Initializing the Static Context</head>
               <p>The <xtermref spec="XP21" ref="dt-static-context">static context</xtermref> of an
                  XPath expression appearing in an XSLT stylesheet is initialized as follows. In
                  these rules, the term <term>containing element</term> means the element within the
                  stylesheet that is the parent of the attribute whose value contains the XPath
                  expression in question, and the term <term>enclosing element</term> means the
                  containing element or any of its ancestors.</p>
               <ulist>
                  <item>
                     <p diff="chg" at="D">
                        <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref>
                        is set to true if and only if the containing element is processed with
                           <termref def="dt-xslt-10-behavior">XSLT 1.0 behavior</termref> (see
                           <specref ref="backwards"/>).</p>
                  </item>
                  <item>
                     <p>The <xtermref spec="XP21" ref="dt-static-namespaces">statically known
                           namespaces</xtermref> are the namespace declarations that are in scope
                        for the containing element.</p>
                  </item>
                  <item>
                     <p>The <xtermref spec="XP21" ref="dt-def-elemtype-ns">default element/type
                           namespace</xtermref> is the namespace defined by the
                           <code>[xsl:]xpath-default-namespace</code> attribute on the innermost
                        enclosing element that has such an attribute, as described in <specref ref="unprefixed-qnames"/>. The value of this attribute is a namespace
                        URI. If there is no <code>[xsl:]xpath-default-namespace</code> attribute on
                        an enclosing element, the default namespace for element names and type names
                        is the null namespace.</p>
                  </item>
                  <item>
                     <p>The <xtermref spec="XP21" ref="dt-def-fn-ns">default function
                           namespace</xtermref> is the <termref def="dt-standard-function-namespace">standard function namespace</termref>, defined in <bibref ref="xpath-functions-11"/>. This means that it is not necessary to declare
                        this namespace in the <termref def="dt-stylesheet">stylesheet</termref>, nor
                        is it necessary to use the prefix <code>fn</code> (or any other prefix) in
                        calls to the <termref def="dt-core-function">core functions</termref>.</p>
                  </item>
                  <item>
                     <p>The <xtermref spec="XP21" ref="dt-issd">in-scope schema
                           definitions</xtermref> for the XPath expression are the same as the
                           <termref def="dt-in-scope-schema-component">in-scope schema
                           components</termref> for the <termref def="dt-stylesheet">stylesheet</termref>, and are as specified in <specref ref="built-in-types"/>.</p>
                  </item>
                  <item>
                     <p>The <xtermref spec="XP21" ref="dt-in-scope-variables">in-scope
                           variables</xtermref> are defined by the <termref def="dt-variable-binding-element">variable binding elements</termref>
                        that are in scope for the containing element (see <specref ref="variables-and-parameters"/>).</p>
                  </item>
                  <item diff="add" at="D">
                     <p>The <xtermref spec="XP21" ref="dt-context-item-static-type">context item
                           static type</xtermref> may be determined by an XSLT processor that
                        performs static type inferencing, using rules that are outside the scope of
                        this specification; if no static type inferencing is done, then the context
                        item static type for every XPath expression is <code>item()</code>. </p>
                  </item>
                  <item>
                     <p>The <xtermref spec="XP21" ref="dt-function-signature">function
                           signatures</xtermref> are the <termref def="dt-core-function">core
                           functions</termref> defined in <bibref ref="xpath-functions-11"/>, the
                        constructor functions for all the atomic types in the <xtermref spec="XP21" ref="dt-issd">in-scope schema definitions</xtermref>, the additional
                        functions defined in this specification, the <termref def="dt-stylesheet-function">stylesheet functions</termref> defined in
                        the stylesheet, plus any <termref def="dt-extension-function">extension
                           functions</termref> bound using <termref def="dt-implementation-defined">implementation-defined</termref> mechanisms (see <specref ref="extension"/>).</p>
                     <note>
                        <p>It follows from the above that a conformant XSLT processor must implement
                           the entire library of <termref def="dt-core-function">core
                              functions</termref> defined in <bibref ref="xpath-functions-11"/>.</p>
                     </note>
                  </item>
                  <item>
                     <p>The <xtermref spec="XP21" ref="dt-static-collations">statically known
                           collations</xtermref> are <termref def="dt-implementation-defined">implementation-defined</termref>. However, the set of in-scope
                        collations <rfc2119>must</rfc2119> always include the Unicode codepoint
                        collation, defined in <xspecref spec="FO" ref="string-compare"/>.</p>
                  </item>
                  <item>
                     <p>The <xtermref spec="XP21" ref="dt-def-collation">default
                           collation</xtermref> is defined by the value of the
                           <code>[xsl:]default-collation</code> attribute on the innermost enclosing
                        element that has such an attribute. For details, see <specref ref="default-collation-attribute"/>.</p>
                     <p>
                        <termdef id="dt-default-collation" term="default collation">In this
                           specification the term <term>default collation</term> means the collation
                           that is used by XPath operators such as <code>eq</code> and
                              <code>lt</code> appearing in XPath expressions within the
                           stylesheet.</termdef>
                     </p>
                     <p>This collation is also used by default when comparing strings in the
                        evaluation of the <elcode>xsl:key</elcode> and
                           <elcode>xsl:for-each-group</elcode> elements. This <rfc2119>may</rfc2119>
                        also (but need not necessarily) be the same as the default collation used
                        for <elcode>xsl:sort</elcode> elements within the stylesheet. Collations
                        used by <elcode>xsl:sort</elcode> are described in <specref ref="collating-sequences"/>.</p>
                  </item>
                  <item>
                     <p>The <xtermref spec="XP21" ref="dt-base-uri">base URI</xtermref> is the base
                        URI of the containing element in the stylesheet. The concept of the base URI
                        of a node is defined in <xspecref spec="DM11" ref="dm-base-uri"/>
                     </p>
                  </item>
                  <item diff="add" at="D">
                     <p>The set of <xtermref spec="XP21" ref="dt-known-docs">statically known
                           documents</xtermref> is <termref def="dt-implementation-defined">implementation-defined</termref>, and by default is empty. </p>
                     <imp-def-feature>The set of <xtermref spec="XP21" ref="dt-known-docs">statically known documents</xtermref> is <termref def="dt-implementation-defined">implementation-defined</termref>, and by
                        default is empty.</imp-def-feature>
                  </item>
                  <item diff="add" at="D">
                     <p>The set of <xtermref spec="XP21" ref="dt-known-collections">statically known
                           collections</xtermref> is <termref def="dt-implementation-defined">implementation-defined</termref>, and by default is empty. </p>
                     <imp-def-feature>The set of <xtermref spec="XP21" ref="dt-known-collections">statically known collections</xtermref> is <termref def="dt-implementation-defined">implementation-defined</termref>, and by
                        default is empty.</imp-def-feature>
                  </item>
                  <item diff="add" at="D">
                     <p>The <xtermref spec="XP21" ref="dt-known-default-collection">statically known
                           default collection type</xtermref> is <termref def="dt-implementation-defined">implementation-defined</termref>, and by
                        default is <code>node()*</code>. </p>
                     <imp-def-feature>The <xtermref spec="XP21" ref="dt-known-default-collection">statically known default collection type</xtermref> is <termref def="dt-implementation-defined">implementation-defined</termref>, and by
                        default is <code>node()*</code>.</imp-def-feature>
                  </item>
                  <item diff="add" at="D">
                     <p>The set of <xtermref spec="XP21" ref="dt-static-decimal-formats">statically
                           known decimal formats</xtermref> is the set of decimal formats defined by
                           <elcode>xsl:decimal-format</elcode> declarations in the stylesheet. </p>
                  </item>
               </ulist>
               <issue id="issue-recommended-initial-context" status="open"><p>In the rules for defining the 
               initial static context, we sometimes say that the value is implementation-defined, and
               then give a default. We need to be clearer what we are saying here. Essentially the "default"
               is a recommendation to implementors about what the value should be when users don't select
               anything different. Perhaps if we have recommended defaults for some of these values,
               we should have them for all.</p></issue>
            </div3>
            <div3 id="additional-static-context">
               <head>Additional Static Context Components used by XSLT</head>
               <p>Some of the components of the XPath static context are used also by <termref def="dt-xslt-element">XSLT elements</termref>. For example, the
                     <elcode>xsl:sort</elcode> element makes use of the collations defined in the
                  static context, and attributes such as <code>type</code> and <code>as</code> may
                  reference types defined in the <termref def="dt-in-scope-schema-component">in-scope schema components</termref>.</p>
               <p>Many top-level declarations in a stylesheet, and attributes on the
                     <elcode>xsl:stylesheet</elcode> element, affect the behavior of instructions
                  within the stylesheet. Each of these constructs is described in its appropriate
                  place in this specification.</p>
               <p>A number of these constructs are of particular significance because they are used
                  by functions defined in XSLT, which are added to the library of functions
                  available for use in XPath expressions within the stylesheet. These are:</p>
               <ulist>
                  <item>
                     <p>The set of named keys, used by the <function>key</function> function</p>
                  </item>
                  <item diff="del" at="D">
                     <p>The set of named decimal formats, used by the
                           <xfunction>format-number</xfunction> function</p>
                  </item>
                  <item>
                     <p>The values of system properties, used by the
                           <function>system-property</function> function</p>
                  </item>
                  <item>
                     <p>The set of available instructions, used by the
                           <function>element-available</function> function</p>
                  </item>
               </ulist>
            </div3>
            <div3 id="xpath-dynamic-context">
               <head>Initializing the Dynamic Context</head>
               <p>For convenience, the dynamic context is described in two parts: the <termref def="dt-focus">focus</termref>, which represents the place in the source
                  document that is currently being processed, and a collection of additional context
                  variables.</p>
               <p>A number of functions specified in <bibref ref="xpath-functions-11"/> are defined to
                  be <xtermref spec="FO" ref="stable">stable</xtermref>, meaning that if they are
                  called twice during the same <xtermref spec="FO" ref="execution-scope">execution
                     scope</xtermref>, with the same arguments, then they return the same results
                  (see <xspecref spec="FO" ref="terminology"/>). In XSLT, the execution of a
                  stylesheet defines the execution scope. This means, for example, that if the
                  function <xfunction>current-dateTime</xfunction> is called repeatedly during a
                  transformation, it produces the same result each time. By implication, the
                  components of the dynamic context on which these functions depend are also stable
                  for the duration of the transformation. Specifically, the following components
                  defined in <xspecref spec="XP21" ref="eval_context"/> must be stable:
                     <emph>function implementations</emph>, <emph>current dateTime</emph>,
                     <emph>implicit timezone</emph>, <emph>available documents</emph>,
                     <emph>available collections</emph>, and <emph>default collection</emph>. The
                  values of global variables and stylesheet parameters are also stable for the
                  duration of a transformation. The focus is <emph>not</emph> stable; the additional
                  dynamic context components defined in <specref ref="additional-dynamic-context"/>
                  are also <emph>not</emph> stable.</p>
               <p>As specified in <bibref ref="xpath-functions-11"/>, implementations may provide user
                  options that relax the requirement for the <xfunction>doc</xfunction> and
                     <xfunction>collection</xfunction> functions (and therefore, by implication, the
                     <function>document</function> function) to return stable results. By default,
                  however, the functions must be stable. The manner in which such user options are
                  provided, if at all, is <termref def="dt-implementation-defined">implementation-defined</termref>.</p>
               <imp-def-feature>Implementations may provide user options that relax the requirement
                  for the <xfunction>doc</xfunction> and <xfunction>collection</xfunction> functions
                  (and therefore, by implication, the <function>document</function> function) to
                  return stable results. The manner in which such user options are provided, if at
                  all, is <termref def="dt-implementation-defined">implementation-defined</termref>. </imp-def-feature>
               <p>XPath expressions contained in <code>[xsl:]use-when</code> attributes are not
                  considered to be evaluated "during the transformation" as defined above. For
                  details see <specref ref="conditional-inclusion"/>.</p>
               <div4 id="focus">
                  <head>Maintaining Position: the Focus</head>
                  <p>
                     <termdef id="dt-focus" term="focus">When a <termref def="dt-sequence-constructor">sequence constructor</termref> is
                        evaluated, the <termref def="dt-processor">processor</termref> keeps track
                        of which items are being processed by means of a set of implicit variables
                        referred to collectively as the <term>focus</term>.</termdef> More
                     specifically, the focus consists of the following three values:</p>
                  <ulist>
                     <item>
                        <p><termdef id="dt-context-item" term="context item">The <term>context
                                 item</term> is the item currently being processed. An item (see
                                 <bibref ref="xpath-datamodel-11"/>) is either an atomic value (such as
                              an integer, date, or string), a node, <phrase diff="add" at="C">or a
                                 function item</phrase>. The context item is initially set to the
                                 <phrase diff="chg" at="E"><termref def="dt-initial-context-item"/></phrase> supplied when the transformation is invoked (see
                                 <specref ref="initiating"/>). It changes whenever instructions such
                              as <elcode>xsl:apply-templates</elcode> and
                                 <elcode>xsl:for-each</elcode> are used to process a sequence of
                              items; each item in such a sequence becomes the context item while
                              that item is being processed.</termdef> The context item is returned
                           by the XPath <termref def="dt-expression">expression</termref>
                           <code>.</code> (dot).</p>
                     </item>
                     <item>
                        <p><termdef id="dt-context-position" term="context position">The
                                 <term>context position</term> is the position of the context item
                              within the sequence of items currently being processed. It changes
                              whenever the context item changes. When an instruction such as
                                 <elcode>xsl:apply-templates</elcode> or
                                 <elcode>xsl:for-each</elcode> is used to process a sequence of
                              items, the first item in the sequence is processed with a context
                              position of 1, the second item with a context position of 2, and so
                              on.</termdef> The context position is returned by the XPath <termref def="dt-expression">expression</termref>
                           <code>position()</code>.</p>
                     </item>
                     <item>
                        <p><termdef id="dt-context-size" term="context size">The <term>context
                                 size</term> is the number of items in the sequence of items
                              currently being processed. It changes whenever instructions such as
                                 <elcode>xsl:apply-templates</elcode> and
                                 <elcode>xsl:for-each</elcode> are used to process a sequence of
                              items; during the processing of each one of those items, the context
                              size is set to the count of the number of items in the sequence (or
                              equivalently, the position of the last item in the
                              sequence).</termdef> The context size is returned by the XPath
                              <termref def="dt-expression">expression</termref>
                           <code>last()</code>.</p>
                     </item>
                  </ulist>
                  <p>
                     <termdef id="dt-context-node" term="context node">If the <termref def="dt-context-item">context item</termref> is a node (as distinct from
                        an atomic value such as an integer), then it is also referred to as the
                           <term>context node</term>. The context node is not an independent
                        variable, it changes whenever the context item changes. When the context
                        item is an atomic value <phrase diff="add" at="C">or a function
                           item</phrase>, there is no context node.</termdef> The context node is
                     returned by the XPath <termref def="dt-expression">expression</termref>
                     <code>self::node()</code>, and it is used as the starting node for all relative
                     path expressions.</p>
                  <p>Where the containing element of an XPath expression is an <termref def="dt-instruction">instruction</termref> or a <termref def="dt-literal-result-element">literal result element</termref>, the
                     initial context item, context position, and context size for the XPath <termref def="dt-expression">expression</termref> are the same as the <termref def="dt-context-item">context item</termref>, <termref def="dt-context-position">context position</termref>, and <termref def="dt-context-size">context size</termref> for the evaluation of the
                     containing instruction or literal result element.</p>
                  <p>In other cases (for example, where the containing element is
                        <elcode>xsl:sort</elcode>, <elcode>xsl:with-param</elcode>, or
                        <elcode>xsl:key</elcode>), the rules are given in the specification of the
                     containing element.</p>
                  <p>The <function>current</function> function can be used within any XPath <termref def="dt-expression">expression</termref> to select the item that was
                     supplied as the context item to the XPath expression by the XSLT processor.
                     Unlike <code>.</code> (dot) this is unaffected by changes to the context item
                     that occur within the XPath expression. The <function>current</function>
                     function is described in <specref ref="current-function"/>.</p>
                  <p>On completion of an instruction that changes the <termref def="dt-focus">focus</termref> (such as <elcode>xsl:apply-templates</elcode> or
                        <elcode>xsl:for-each</elcode>), the focus reverts to its previous value.</p>
                  <p>When a <termref def="dt-stylesheet-function">stylesheet function</termref> is
                     called, the focus within the body of the function is initially undefined. The
                     focus is also undefined on initial entry to the <termref def="dt-stylesheet">stylesheet</termref> if no <phrase diff="chg" at="E"><termref def="dt-initial-context-item"/></phrase> is supplied.</p>
                  <p>When the focus is undefined, evaluation of any <termref def="dt-expression">expression</termref> that references the context item, context position, or
                     context size results in a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>
                     <!--<xerrorref spec="XP21" class="DY" code="0002"/>--> [XPDY0002] </p>
                  <p>The description above gives an outline of the way the <termref def="dt-focus">focus</termref> works. Detailed rules for the effect of each instruction
                     are given separately with the description of that instruction. In the absence
                     of specific rules, an instruction uses the same focus as its parent
                     instruction.</p>
                  <p>
                     <termdef id="dt-singleton-focus" term="singleton focus">A <term>singleton
                           focus</term> based on an item <var>J</var> has the <phrase diff="chg" at="F"><termref def="dt-context-item">context item</termref> (and therefore the <termref def="dt-context-node">context node</termref>, if <var>J</var> is a node)</phrase> set to <var>J</var>, and
                        the <termref def="dt-context-position">context position</termref> and
                           <termref def="dt-context-size">context size</termref> both set to 1
                        (one).</termdef>
                  </p>
               </div4>





               <div4 id="evaluation-context">
                  <head>Other components of the XPath Dynamic Context</head>
                  <p>The previous section explained how the <termref def="dt-focus">focus</termref>
                     for an XPath expression appearing in an XSLT stylesheet is initialized. This
                     section explains how the other components of the <xtermref spec="XP21" ref="dt-dynamic-context">dynamic context</xtermref> of an XPath expression
                     are initialized.</p>
                  <ulist>
                     <item>
                        <p>The <xtermref spec="XP21" ref="dt-variable-values">dynamic
                              variables</xtermref> are the current values of the in-scope <termref def="dt-variable-binding-element">variable binding
                           elements</termref>.</p>
                     </item>
                     <item>
                        <p>The <emph>current date and time</emph> represents an <termref def="dt-implementation-dependent">implementation-dependent</termref>
                           point in time during processing of the transformation; it does not change
                           during the course of the transformation.</p>
                     </item>
                     <item>
                        <p>The <xtermref spec="XP21" ref="dt-timezone">implicit timezone</xtermref>
                           is <termref def="dt-implementation-defined">implementation-defined</termref>.</p>
                        <imp-def-feature>The implicit timezone for a transformation is
                           implementation-defined.</imp-def-feature>
                     </item>
                     <item>
                        <p>The <xtermref spec="XP21" ref="dt-known-docs">available
                              documents</xtermref>, and the <xtermref spec="XP21" ref="dt-known-collections">available collections</xtermref> are
                           determined as part of the process for initiating a transformation (see
                              <specref ref="initiating"/>).</p>
                        <p>The <xtermref spec="XP21" ref="dt-known-docs">available
                           documents</xtermref> are defined as part of the <phrase diff="chg" at="F">XPath 2.1</phrase> dynamic
                           context to support the <xfunction>doc</xfunction> function, but this
                           component is also referenced by the similar XSLT
                              <function>document</function> function: see <specref ref="document"/>.
                           This variable defines a mapping between URIs passed to the
                              <xfunction>doc</xfunction> or <function>document</function> function
                           and the document nodes that are returned.</p>
                        <note>
                           <p>Defining this as part of the evaluation context is a formal way of
                              specifying that the way in which URIs get turned into document nodes
                              is outside the control of the language specification, and depends
                              entirely on the run-time environment in which the transformation takes
                              place.</p>
                        </note>
                        <p>The XSLT-defined <function>document</function> function allows the use of
                           URI references containing fragment identifiers. The interpretation of a
                           fragment identifier depends on the media type of the resource
                           representation. Therefore, the information supplied in <xtermref spec="XP21" ref="dt-known-docs">available documents</xtermref> for
                           XSLT processing must provide not only a mapping from URIs to document
                           nodes as required by XPath, but also a mapping from URIs to media
                           types.</p>
                     </item>
                     <item>
                        <p>The <xtermref spec="XP21" ref="dt-default-collection">default
                              collection</xtermref> is <termref def="dt-implementation-defined">implementation-defined</termref>. This allows options such as setting
                           the default collection to be an empty sequence, or to be undefined.</p>
                        <imp-def-feature>The <xtermref spec="XP21" ref="dt-default-collection">default collection</xtermref> is <termref def="dt-implementation-defined">implementation-defined</termref>.</imp-def-feature>
                     </item>
                  </ulist>
               </div4>
            </div3>
            <div3 id="additional-dynamic-context">
               <head>Additional Dynamic Context Components used by XSLT</head>
               <p>In addition to the values that make up the <termref def="dt-focus">focus</termref>, an XSLT processor maintains a number of other dynamic context
                  components that reflect aspects of the evaluation context. These components are
                  fully described in the sections of the specification that maintain and use them.
                  They are:</p>
               <ulist>
                  <item>
                     <p>The <termref def="dt-current-template-rule">current template rule</termref>,
                        which is the <termref def="dt-template-rule">template rule</termref> most
                        recently invoked by an <elcode>xsl:apply-templates</elcode>,
                           <elcode>xsl:apply-imports</elcode>, or <elcode>xsl:next-match</elcode>
                        instruction: see <specref ref="apply-imports"/>; </p>
                  </item>
                  <item>
                     <p>The <termref def="dt-current-mode">current mode</termref>, which is the
                           <termref def="dt-mode">mode</termref> set by the most recent call of
                           <elcode>xsl:apply-templates</elcode> (for a full definition see <specref ref="modes"/>);</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-current-group">current group</termref> and <termref def="dt-current-grouping-key">current grouping key</termref>, which
                        provide information about the collection of items currently being processed
                        by an <elcode>xsl:for-each-group</elcode> instruction: see <specref ref="current-group"/> and <specref ref="current-grouping-key"/>;</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-current-captured-substrings">current captured
                           substrings</termref>: this is a sequence of strings, which is maintained
                        when a string is matched against a regular expression using the
                           <elcode>xsl:analyze-string</elcode> instruction, and which is accessible
                        using the <function>regex-group</function> function: see <specref ref="regex-group"/>.</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-output-state">output state</termref>: this is a flag
                        whose two possible values are <termref def="dt-final-output-state">final
                           output state</termref> and <termref def="dt-temporary-output-state">temporary output state</termref>. This flag indicates whether
                        instructions are currently writing to a <termref def="dt-final-result-tree">final result tree</termref> or to an internal data structure. The
                        initial setting is <termref def="dt-final-output-state">final output
                           state</termref>, and it is switched to <termref def="dt-temporary-output-state">temporary output state</termref> by
                        instructions such as <elcode>xsl:variable</elcode>. For more details, see
                           <specref ref="creating-result-trees"/>.</p>
                  </item>
               </ulist>
               <p>The following non-normative table summarizes the initial state of each of the
                  components in the evaluation context, and the instructions which cause the state
                  of the component to change.</p>
               <issue id="issue-normative-evaluation-context" status="open"><p>Although this table is described
               as non-normative, it may be more complete than the same information given normatively elsewhere.</p></issue>
               <table border="1" cellpadding="5">
                  <thead>
                     <tr>
                        <th align="left" rowspan="1" colspan="1">Component</th>
                        <th align="left" rowspan="1" colspan="1">Initial Setting</th>
                        <th align="left" rowspan="1" colspan="1">Set by</th>
                        <th align="left" rowspan="1" colspan="1">Cleared by</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-focus">focus</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">singleton focus based on the
                              <phrase diff="chg" at="E"><termref def="dt-initial-context-item"/></phrase> if supplied</td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:apply-templates</elcode>, <elcode>xsl:for-each</elcode>,
                              <elcode>xsl:for-each-group</elcode>,
                              <elcode>xsl:analyze-string</elcode>
                        </td>
                        <td valign="top" rowspan="1" colspan="1"><termref def="dt-non-contextual-function-call">non-contextual function
                              calls</termref>
                        </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-template-rule">current template rule</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">If a <termref def="dt-named-template">named template</termref> is supplied as the
                           entry point to the transformation, then null; otherwise the <termref def="dt-initial-template">initial template</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>,
                              <elcode>xsl:next-match</elcode>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:for-each</elcode>, <elcode>xsl:for-each-group</elcode>, 
                              <elcode>xsl:analyze-string</elcode>, <phrase diff="add" at="F"><elcode>xsl:iterate</elcode>,
                           <elcode>xsl:stream</elcode>, <elcode>xsl:merge</elcode>, <elcode>xsl:evaluate</elcode>, </phrase>
                           and <termref def="dt-non-contextual-function-call">non-contextual function
                              calls</termref>. Also cleared while evaluating global variables or
                           default values of stylesheet parameters, and the sequence constructors
                           contained in <elcode>xsl:key</elcode> and <elcode>xsl:sort</elcode>.</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-mode">current mode</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">the initial <termref def="dt-mode">mode</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:apply-templates</elcode>
                        </td>
                        <!--Text replaced by erratum E19 change 1"-->
                        <td valign="top" rowspan="1" colspan="1"><termref def="dt-non-contextual-function-call">non-contextual function
                              calls</termref>, evaluation of global variables and stylesheet
                           parameters, evaluation of the sequence constructor contained in
                              <elcode>xsl:key</elcode> or <elcode>xsl:sort</elcode>. Clearing the
                           current mode causes the current mode to be set to the default (unnamed)
                           mode.</td>
                        <!--End of text replaced by erratum E19-->
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-group">current group</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">empty sequence</td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:for-each-group</elcode>
                        </td>
                        <td valign="top" rowspan="1" colspan="1" diff="add" at="D"><termref def="dt-non-contextual-function-call">non-contextual function
                              calls</termref>
                        </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-grouping-key">current grouping key</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">empty sequence</td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:for-each-group</elcode>
                        </td>
                        <td valign="top" rowspan="1" colspan="1" diff="add" at="D"><termref def="dt-non-contextual-function-call">non-contextual function
                              calls</termref>
                        </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-captured-substrings">current captured
                              substrings</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">empty sequence</td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:matching-substring</elcode>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:non-matching-substring</elcode>; <phrase diff="add" at="D"><termref def="dt-non-contextual-function-call">non-contextual
                                 function calls</termref></phrase>
                        </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-output-state">output state</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-final-output-state">final output state</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">Set to <termref def="dt-temporary-output-state">temporary output state</termref> by
                           instructions such as <elcode>xsl:variable</elcode>,
                              <elcode>xsl:attribute</elcode>, etc., and by calls on <termref def="dt-stylesheet-function">stylesheet functions</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">None</td>
                     </tr>
                  </tbody>
               </table>
               <p diff="add" at="D"><termdef id="dt-non-contextual-function-call" term="non-contextual function call">The term <term>non-contextual function
                        call</term> is used to refer to function calls that do not pass the dynamic
                     context to the called function. This includes all calls on <termref def="dt-stylesheet-function">stylesheet functions</termref> and all
                        <xtermref spec="XP21" ref="dt-dynamic-func-invoke">dynamic function
                        invocations</xtermref>, (that is calls to function items as permitted by
                     XPath 2.1). It does not include calls to all <termref def="dt-core-function">core functions</termref> in particular those that explicitly depend on the
                     context, such as the <function>current-group</function> and
                        <function>regex-group</function> functions. It is <termref def="dt-implementation-defined">implementation-defined</termref> whether,
                     and under what circumstances, calls to <termref def="dt-extension-function">extension functions</termref> are non-contextual.</termdef></p>
               <imp-def-feature>It is <termref def="dt-implementation-defined">implementation-defined</termref> whether, and under what circumstances, calls
                  to <termref def="dt-extension-function">extension functions</termref> are <termref def="dt-non-contextual-function-call">non-contextual</termref>.</imp-def-feature>
               <note diff="add" at="D">
                  <p>A consequence of these rules is that whereas the function call
                        <code>current-group()</code> returns the contents of the <termref def="dt-current-group">current group</termref>, the dynamic function
                     invocation <code>current-group#0()</code> always returns the empty
                     sequence.</p>
               </note>
            </div3>
         </div2>
         <div2 id="patterns">
            <head>Patterns</head>

            <p diff="add" at="C">In XSLT 2.1, patterns can match any kind of item: atomic values and
               function items as well as nodes.</p>

            <p>A <termref def="dt-template-rule">template rule</termref> identifies the <phrase diff="chg" at="C">items</phrase> to which it applies by means of a pattern. As
               well as being used in template rules, patterns are used for numbering (see <specref ref="number"/>), for grouping (see <specref ref="grouping"/>), and for declaring
                  <termref def="key">keys</termref> (see <specref ref="key"/>).</p>
            <p><termdef id="dt-pattern" term="pattern">A <term>pattern</term> specifies a set of
                  conditions on an <phrase diff="chg" at="C">item</phrase>. An <phrase diff="chg" at="C">item</phrase> that satisfies the conditions matches the pattern; an
                     <phrase diff="chg" at="C">item</phrase> that does not satisfy the conditions
                  does not match the pattern.</termdef></p>

            <p diff="add" at="C">There are two basic kinds of pattern: type patterns, and path
               patterns. Patterns may also be formed by combining other patterns using union,
               intersection, and difference operators.</p>

            <p diff="add" at="C">A type pattern is written with a leading <code>~</code> (tilde)
               followed by an <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-ItemType" xlink:type="simple">ItemType</xnt> and an
               optional list of predicates: for example, <code>~xs:anyAtomicValue</code> matches any
               atomic value, <code>~xs:integer[. mod 2 = 0]</code> matches any even integer,
                  <code>~node()</code> matches any node, and
                  <code>~function()[empty(function-name(.))]</code> matches any function item that
               refers to an anonymous function. An item matches a type pattern if and only if the
               item is an instance of the specified type and satisfies all the predicates. </p>

            <p>The syntax for <phrase diff="add" at="C">path</phrase> patterns is a subset of the
               syntax for <termref def="dt-expression">expressions</termref>. <phrase diff="add" at="C">Path patterns are used only for matching nodes; an item other than a node
                  will never match a path pattern.</phrase> As explained in detail below, a node
               matches a <phrase diff="add" at="C">path</phrase> pattern if the node can be selected
               by deriving an equivalent expression, and evaluating this expression with respect to
               some possible context.</p>
            <div3 id="pattern-examples">
               <head>Examples of Patterns</head>
               <example>
                  <head>Patterns</head>
                  <p>Here are some examples of patterns:</p>
                  <ulist>
                     <item>
                        <p><code>para</code> matches any <code>para</code> element.</p>
                     </item>
                     <item>
                        <p><code>*</code> matches any element.</p>
                     </item>
                     <item>
                        <p><code>chapter|appendix</code> matches any <code>chapter</code> element
                           and any <code>appendix</code> element.</p>
                     </item>
                     <item>
                        <p><code>olist/entry</code> matches any <code>entry</code> element with an
                              <code>olist</code> parent.</p>
                     </item>
                     <item>
                        <p><code>appendix//para</code> matches any <code>para</code> element with an
                              <code>appendix</code> ancestor element.</p>
                     </item>
                     <item>
                        <p><code>schema-element(us:address)</code> matches any element that is
                           annotated as an instance of the type defined by the schema element
                           declaration <code>us:address</code>, and whose name is either
                              <code>us:address</code> or the name of another element in its
                           substitution group. </p>
                     </item>
                     <item>
                        <p><code>attribute(*, xs:date)</code> matches any attribute annotated as
                           being of type <code>xs:date</code>.</p>
                     </item>
                     <item>
                        <p><code>/</code> matches a document node.</p>
                     </item>
                     <item>
                        <p><code>document-node()</code> matches a document node.</p>
                     </item>
                     <item>
                        <p><code>document-node(schema-element(my:invoice))</code> matches the
                           document node of a document whose document element is named
                              <code>my:invoice</code> and matches the type defined by the global
                           element declaration <code>my:invoice</code>.</p>
                     </item>
                     <item>
                        <p><code>text()</code> matches any text node.</p>
                     </item>
                     <item>
                        <p diff="add" at="C"><code>namespace-node()</code> matches any namespace
                           node.</p>
                     </item>
                     <item>
                        <p><code>node()</code> matches any node other than an attribute node,
                           namespace node, or document node.</p>
                     </item>
                     <item>
                        <p><code>id("W33")</code> matches the element with unique ID
                              <code>W33</code>. </p>
                     </item>
                     <item>
                        <p><code>para[1]</code> matches any <code>para</code> element that is the
                           first <code>para</code> child element of its parent. It also matches a
                           parentless <code>para</code> element.</p>
                     </item>
                     <item>
                        <p><code>//para</code> matches any <code>para</code> element that has a
                           parent node.</p>
                     </item>
                     <item>
                        <p><code>bullet[position() mod 2 = 0]</code> matches any <code>bullet</code>
                           element that is an even-numbered <code>bullet</code> child of its
                           parent.</p>
                     </item>
                     <item>
                        <p><code>div[@class="appendix"]//p</code> matches any <code>p</code> element
                           with a <code>div</code> ancestor element that has a <code>class</code>
                           attribute with value <code>appendix</code>. </p>
                     </item>
                     <item>
                        <p><code>@class</code> matches any <code>class</code> attribute
                              (<emph>not</emph> any element that has a <code>class</code>
                           attribute).</p>
                     </item>
                     <item>
                        <p><code>@*</code> matches any attribute node.</p>
                     </item>
                     <item>
                        <p diff="add" at="C"><code>$xyz</code> matches any node that is present in
                           the value of the variable <code>$xyz</code>.</p>
                     </item>
                     <item>
                        <p diff="add" at="C"><code>$xyz//*</code> matches any element that is a
                           descendant of a node that is present in the value of the variable
                              <code>$xyz</code>.</p>
                     </item>
                     <item>
                        <p diff="add" at="C"><code>doc('product.xml')//*</code> matches any element
                           within the document whose document URI is 'product.xml'.</p>
                     </item>
                     <item>
                        <p diff="add" at="C"><code>~item()</code> matches any item whatsoever.</p>
                     </item>
                     <item>
                        <p diff="add" at="C"><code>~node()</code> matches any node. (Note the
                           distinction from the pattern <code>node()</code>.)</p>
                     </item>
                     <item>
                        <p diff="add" at="C"><code>~element()</code> matches any element. (This is
                           precisely equivalent to the pattern <code>element()</code>.)</p>
                     </item>
                     <item>
                        <p diff="add" at="C"><code>~xs:date</code> matches any atomic value of type
                              <code>xs:date</code> (or a type derived by restriction from
                              <code>xs:date</code>).</p>
                     </item>
                     <item>
                        <p diff="add" at="C"><code>~xs:date[. gt current-date()]</code> matches any
                           date in the future.</p>
                     </item>
                     <item>
                        <p diff="add" at="C"><code>~function()</code> matches any function item.</p>
                     </item>
                     <item>
                        <p diff="add" at="C"><code>~function(xs:integer) as xs:integer</code>
                           matches any function item whose underlying function takes an integer
                           argument and returns an integer result.</p>
                     </item>
                  </ulist>
               </example>
            </div3>
            <div3 id="pattern-syntax">
               <head>Syntax of Patterns</head>
               <p>
                  <error spec="XT" type="static" class="SE" code="0340">
                     <p>Where an attribute is defined to contain a <termref def="dt-pattern">pattern</termref>, it is a <termref def="dt-static-error">static
                           error</termref> if the pattern does not match the production <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-Pattern" xlink:type="simple">Pattern</nt>.</p>
                  </error></p>
               <p diff="add" at="C">The grammar for patterns uses the notation defined in <xspecref spec="XP21" ref="EBNFNotation">Notation</xspecref>. </p>
               <p diff="add" at="C">The lexical rules for patterns are the same as the lexical rules
                  for XPath expressions, as defined in <xspecref spec="XP21" ref="lexical-structure">Lexical structure</xspecref>. Comments are permitted between tokens, using the
                  syntax <code>(: ... :)</code>. All other provisions of the XPath grammar apply
                  where relevant, for example the rules for whitespace handling and
                  extra-grammatical constraints.</p>
               <p diff="del" at="C"> Every pattern is a legal XPath <termref def="dt-expression">expression</termref>, but the converse is not true: <code>2+2</code> is an
                  example of a legal XPath expression that is not a pattern. The XPath expressions
                  that can be used as patterns are those that match the grammar for <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-Pattern" xlink:type="simple">Pattern</nt>, given below.</p>
               <p diff="del" at="C">Informally, a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-Pattern" xlink:type="simple">Pattern</nt> is a set of path
                  expressions separated by <code>|</code>, where each step in the path expression is
                  constrained to be an <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-AxisStep" xlink:type="simple">AxisStep</xnt>
                  that uses only the <code>child</code> or <code>attribute</code> axes. Patterns may
                  also use the <code>//</code> operator. A <xnt xmlns:xlink="http://www.w3.org/1999/xlink" ref="prod-xpath21-Predicate" spec="XP21" xlink:type="simple">Predicate</xnt> within the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-PredicateList" xlink:type="simple">PredicateList</xnt> in a pattern can contain
                  arbitrary XPath expressions (enclosed between square brackets) in the same way as
                  a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-Predicate" xlink:type="simple">predicate</xnt> in a path
                  expression.</p>
               <p diff="del" at="C">Patterns may start with an <xfunction>id</xfunction> or
                     <function>key</function> function call, provided that the value to be matched
                  is supplied as either a literal or a reference to a <termref def="dt-variable">variable</termref> or <termref def="dt-parameter">parameter</termref>, and the
                  key name (in the case of the <function>key</function> function) is supplied as a
                  string literal. These patterns will never match a node in a tree whose root is not
                  a document node.</p>
               <p>If a pattern appears <phrase diff="chg" at="D">in an attribute of an element that
                     is processed with <termref def="dt-xslt-10-behavior">XSLT 1.0
                        behavior</termref></phrase> (see <specref ref="backwards"/>), then the
                  semantics of the pattern are defined on the basis that the equivalent XPath
                  expression is evaluated with <termref def="dt-xpath-compat-mode">XPath 1.0
                     compatibility mode</termref> set to true.</p>
               <scrap headstyle="show" diff="chg" at="C">
                  <head>Patterns</head>
                  <prodgroup pcw5="1" pcw2="10">
                     <prod id="NT-Pattern">
                        <lhs>Pattern</lhs>
                        <rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PatternTerm" xlink:type="simple">PatternTerm</nt> ( ('|' | 'union') <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-Pattern" xlink:type="simple">PatternTerm</nt> )*</rhs>
                     </prod>
                     <prod id="NT-PatternTerm">
                        <lhs>PatternTerm</lhs>
                        <rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-BasicPattern" xlink:type="simple">BasicPattern</nt> ( ('intersect' | 'except')
                              <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-Pattern" xlink:type="simple">BasicPattern</nt> )*</rhs>
                     </prod>
                     <prod id="NT-BasicPattern">
                        <lhs>BasicPattern</lhs>
                        <rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-TypePattern" xlink:type="simple">TypePattern</nt> | <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-TypePattern" xlink:type="simple">PathPattern</nt> | <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-QualifiedPattern" xlink:type="simple">QualifiedPattern</nt></rhs>
                     </prod>
                     <prod id="NT-QualifiedPattern">
                        <lhs>QualifiedPattern</lhs>
                        <rhs>'(' <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-Pattern" xlink:type="simple">Pattern</nt> ')' <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-PredicateList" xlink:type="simple">PredicateList</xnt></rhs>
                     </prod>
                     <prod id="NT-TypePattern">
                        <lhs>TypePattern</lhs>
                        <rhs>'~' <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-ItemType" xlink:type="simple">ItemType</xnt>
                           <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-PredicateList" xlink:type="simple">PredicateList</xnt></rhs>
                     </prod>
                     <prod id="NT-PathPattern">
                        <lhs>PathPattern</lhs>
                        <rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-RelativePathPattern" xlink:type="simple">RelativePathPattern</nt></rhs>
                        <rhs>| '/' <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-RelativePathPattern" xlink:type="simple">RelativePathPattern</nt>?</rhs>
                        <rhs>| '//' <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-RelativePathPattern" xlink:type="simple">RelativePathPattern</nt></rhs>
                        <rhs>| <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-RootedPattern" xlink:type="simple">RootedPattern</nt></rhs>
                     </prod>
                     <prod id="NT-RootedPattern">
                        <lhs>RootedPattern</lhs>
                        <rhs>( <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-VarRefRoot" xlink:type="simple">VarRefRoot</nt> | <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-DocCall" xlink:type="simple">DocCall</nt> | <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-IdCall" xlink:type="simple">IdCall</nt> | <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-ElementWithIdCall" xlink:type="simple">ElementWithIdCall</nt> | <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-KeyCall" xlink:type="simple">KeyCall</nt> )</rhs>
                        <rhs> (('/' | '//') <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-RelativePathPattern" xlink:type="simple">RelativePathPattern</nt>)?</rhs>
                     </prod>
                     <prod id="NT-VarRefRoot">
                        <lhs>VarRefRoot</lhs>
                        <rhs><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-VarRef" xlink:type="simple">VarRef</xnt></rhs>
                     </prod>
                     <prod id="NT-RelativePathPattern">
                        <lhs>RelativePathPattern</lhs>
                        <rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PatternStep" xlink:type="simple">PatternStep</nt> (('/' | '//') <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PatternStep" xlink:type="simple">PatternStep</nt>)*</rhs>
                     </prod>
                     <prod id="NT-PatternStep">
                        <lhs>PatternStep</lhs>
                        <rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PatternAxis" xlink:type="simple">PatternAxis</nt>? <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-NodeTest" xlink:type="simple">NodeTest</xnt>
                           <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-PredicateList" xlink:type="simple">PredicateList</xnt>
                        </rhs>
                     </prod>
                     <prod id="NT-PatternAxis">
                        <lhs>PatternAxis</lhs>
                        <rhs>(('child' | 'attribute' | 'descendant' | 'descendant-or-self') '::') |
                           '@' </rhs>
                     </prod>
                     <prod id="NT-DocCall">
                        <lhs>DocCall</lhs>
                        <rhs>'doc' '(' <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-ArgValue" xlink:type="simple">ArgValue</nt> ')'</rhs>
                     </prod>
                     <prod id="NT-IdCall">
                        <lhs>IdCall</lhs>
                        <rhs>'id' '(' <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-ArgValue" xlink:type="simple">ArgValue</nt> (',' <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-ArgValue" xlink:type="simple">ArgValue</nt> )? ')'</rhs>
                     </prod>
                     <prod id="NT-ElementWithIdCall">
                        <lhs>ElementWithIdCall</lhs>
                        <rhs>'element-with-id' '(' <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-ArgValue" xlink:type="simple">ArgValue</nt> (',' <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-ArgValue" xlink:type="simple">ArgValue</nt> )? ')'</rhs>
                     </prod>
                     <prod id="NT-KeyCall">
                        <lhs>KeyCall</lhs>
                        <rhs>'key' '(' <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-ArgValue" xlink:type="simple">ArgValue</nt> ',' <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-ArgValue" xlink:type="simple">ArgValue</nt> (',' <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-ArgValue" xlink:type="simple">ArgValue</nt> )? ')'</rhs>
                     </prod>
                     <prod id="NT-ArgValue">
                        <lhs>ArgValue</lhs>
                        <rhs><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-Literal" xlink:type="simple">Literal</xnt> | <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-VarRef" xlink:type="simple">VarRef</xnt></rhs>
                     </prod>

                  </prodgroup>
               </scrap>
               <p>The constructs <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-ItemType" xlink:type="simple">ItemType</xnt>, <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-NodeTest" xlink:type="simple">NodeTest</xnt>, <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-PredicateList" xlink:type="simple">PredicateList</xnt>, <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-VarRef" xlink:type="simple">VarRef</xnt>, and <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-Literal" xlink:type="simple">Literal</xnt> are part of the XPath expression
                  language, and are defined in <bibref ref="xpath-21"/>.</p>
               <p>In a <code>DocCall</code>, <code>IdCall</code>, <code>ElementWithIdCall</code>, or
                     <code>KeyCall</code>, the construct has the same semantics as a call to the
                  corresponding function in an XPath expression. In particular, the arguments
                     <rfc2119>must</rfc2119> (after conversion using the <termref def="dt-function-conversion-rules">function conversion rules</termref> if
                  necessary) be of the correct type required by the signature of the function. The
                  function conversion rules are applied with XPath 1.0 compatibility mode set to
                  false. If an argument cannot be converted to the required type, a type error
                  results: if the type error can be detected statically then it
                     <rfc2119>may</rfc2119> be signalled statically.</p>
            </div3>
            <div3 id="pattern-semantics" diff="chg" at="C">
               <head>The Meaning of a Pattern</head>
               <p>The meaning of a pattern is defined formally as follows, where "if" is to be read
                  as "if and only if".</p>
               <olist>
                  <item>
                     <p>An item matches the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-Pattern" xlink:type="simple">Pattern</nt>
                        <code>A | B</code> (or equivalently, <code>A union B</code>) if it matches
                        either <code>A</code> or <code>B</code> or both. (The operators
                           <code>|</code> and <code>union</code> are synonyms.)</p>
                  </item>
                  <item>
                     <p>An item matches the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PatternTerm" xlink:type="simple">PatternTerm</nt>
                        <code>A intersect B</code> if it matches both <code>A</code> and
                           <code>B</code>.</p>
                     <note>
                        <p>The operators <code>union</code>, <code>|</code>, <code>intersect</code>,
                           and <code>except</code> are analogous to the XPath operators with the
                           same representation, but there is a difference: in patterns, the
                           definition above gives these operators a meaning when matching atomic
                           values as well as when matching nodes.</p>
                     </note>
                     <note>
                        <p>As with XPath expressions, the pattern <code>/ union /*</code> can be
                           parsed in two different ways, and the chosen interpretation is to treat
                              <code>union</code> as an element name rather than as an operator. The
                           other interpretation can b be achieved by writing <code>(/) union
                              (/*)</code></p>
                     </note>
                  </item>
                  <item>
                     <p>An item matches the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PatternTerm" xlink:type="simple">PatternTerm</nt>
                        <code>A except B</code> if it matches <code>A</code> and does not match
                           <code>B</code>.</p>
                  </item>
                  <item>
                     <p>Multiple <code>intersect</code> and <code>except</code> operators are
                        applied from left to right: for example <code>A intersect B except C</code>
                        means <code>(A intersect B) except C</code>: that is, the item must match
                        both <code>A</code> and <code>B</code>, and must not match
                        <code>C</code>.</p>
                  </item>
                  <item>
                     <p>An item <var>J</var> matches a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-QualifiedPattern" xlink:type="simple">QualifiedPattern</nt> if <var>J</var> matches the parenthesized <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-Pattern" xlink:type="simple">Pattern</nt> and satisfies each of the predicates in the
                           <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-PredicateList" xlink:type="simple">PredicateList</xnt>.
                        The predicates are evaluated with a <termref def="dt-singleton-focus">singleton focus</termref> based on <var>J</var>.</p>
                  </item>
                  <item>
                     <p>An item <var>J</var> matches a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-TypePattern" xlink:type="simple">TypePattern</nt> if
                           <var>J</var> is an instance of the specified <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-ItemType" xlink:type="simple">ItemType</xnt> and satisfies each of the
                        predicates in the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-PredicateList" xlink:type="simple">PredicateList</xnt>. The predicates are evaluated with a <termref def="dt-singleton-focus">singleton focus</termref> based on
                        <var>J</var>.</p>
                  </item>
                  <item>
                     <p>An item <var>N</var> matches a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PathPattern" xlink:type="simple">PathPattern</nt> if
                           <var>N</var> is a node and the result of evaluating the expression
                           <code>root(.)//(EE)</code> with a <termref def="dt-singleton-focus">singleton focus</termref> based on <var>N</var> is a sequence that
                        includes the node <var>N</var>, where <code>EE</code> is the
                           <term>equivalent expression</term> to the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PathPattern" xlink:type="simple">PathPattern</nt>, as defined below. </p>
                     <p>The concept of an <term>equivalent expression</term> is defined as follows.
                        In general, the equivalent expression to a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PathPattern" xlink:type="simple">PathPattern</nt> is the XPath expression that takes the same lexical
                        form as the <code>PathPattern</code> as written. However, if the
                           <code>PathPattern</code> is a <code>RelativePathPattern</code>, then the
                        first <code>PatternStep</code>
                        <var>PS</var> of this <code>RelativePathPattern</code> is adjusted to allow
                        it to match a parentless element, attribute, or namespace node. The
                        adjustment depends on the axis used in this step, whether it appears
                        explicitly or implicitly (according to the rules of <xspecref spec="XP" ref="abbrev"/>), and is made as follows:</p>
                     <olist>
                        <item>
                           <p>If the <code>NodeTest</code> in <var>PS</var> is
                                 <code>document-node()</code> (optionally with arguments), and if no
                              explicit axis is specified, then the axis in step <var>PS</var> is
                              taken as <code>self</code> rather than <code>child</code>.</p>
                        </item>
                        <item>
                           <p>If <var>PS</var> uses the child axis (explicitly or implicitly), and
                              if the <code>NodeTest</code> in <var>PS</var> is not
                                 <code>document-node()</code> (optionally with arguments), then the
                              axis in step <var>PS</var> is replaced by <code>child-or-top</code>,
                              which is defined as follows. If the context node is a parentless
                              element, comment, processing-instruction, or text node then the
                                 <code>child-or-top</code> axis selects the context node; otherwise
                              it selects the children of the context node. It is a forwards axis
                              whose principal node kind is element.</p>
                        </item>
                        <item>
                           <p>If <var>PS</var> uses the attribute axis (explicitly or implicitly),
                              then the axis in step <var>PS</var> is replaced by
                                 <code>attribute-or-top</code>, which is defined as follows. If the
                              context node is an attribute node with no parent, then the
                                 <code>attribute-or-top</code> axis selects the context node;
                              otherwise it selects the attributes of the context node. It is a
                              forwards axis whose principal node kind is attribute.</p>
                        </item>
                        <item>
                           <p>If <var>PS</var> uses the namespace axis (implicitly, by using
                                 <code>namespace-node()</code> as a <code>KindTest</code>), then the
                              axis in step <var>PS</var> is replaced by
                                 <code>namespace-or-top</code>, which is defined as follows. If the
                              context node is a namespace node with no parent, then the
                                 <code>namespace-or-top</code> axis selects the context node;
                              otherwise it selects the namespace nodes of the context node. It is a
                              forwards axis whose principal node kind is namespace.</p>
                           <issue id="issue-implicit-namespace-axis" status="open">
                              <p>In XPath 2.1, as currently defined, the path expression
                                    <code>A/B/namespace-node()</code> selects nothing, because the
                                 default axis for the abbreviated step <code>namespace-node()</code>
                                 is <code>child</code> rather than <code>namespace</code>. This has
                                 been raised as bug 9298. Perhaps we should allow the namespace axis
                                 to be explicit in a pattern.</p>
                           </issue>
                        </item>
                     </olist>
                     <p>The axes <code>child-or-top</code>, <code>attribute-or-top</code>, and
                           <code>namespace-or-top</code> are introduced only for definitional
                        purposes. They cannot be used explicitly in a user-written pattern or
                        expression.</p>
                     <note>
                        <p>The purpose of these adjustments is to ensure that a pattern such as
                              <code>person</code> matches any element named <code>person</code>,
                           even if it has no parent; and similarly, that the pattern
                              <code>@width</code> matches any attribute named <code>width</code>,
                           even a parentless attribute. The rule also ensures that a pattern using a
                              <code>NodeTest</code> of the form <code>document-node(...)</code>
                           matches a document node. The pattern <code>node()</code> will match any
                           element, text node, comment, or processing instruction, whether or not it
                           has a parent. For backwards compatibility reasons, the pattern
                              <code>node()</code>, when used without an explicit axis, does not
                           match document nodes, attribute nodes, or namespace nodes. The rules are
                           also phrased to ensure that positional patterns of the form
                              <code>para[1]</code> continue to count nodes relative to their parent,
                           if they have one. To match any node at all, XSLT 2.1 allows the pattern
                              <code>~node()</code> to be used (note the tilde).</p>
                     </note>

                  </item>
               </olist>
               <example>
                  <head>The Semantics of Path Patterns</head>
                  <p>The path pattern <code>p</code> matches any <code>p</code> element, because a
                        <code>p</code> element will always be present in the result of evaluating
                     the <termref def="dt-expression">expression</termref>
                     <code>root(.)//(child-or-top::p)</code>. Similarly, <code>/</code> matches a
                     document node, and only a document node, because the result of the <termref def="dt-expression">expression</termref>
                     <code>root(.)//(/)</code> returns the root node of the tree containing the
                     context node if and only if it is a document node.</p>
                  <p>The path pattern <code>node()</code> matches all nodes selected by the
                     expression <code>root(.)//(child-or-top::node())</code>, that is, all element,
                     text, comment, and processing instruction nodes, whether or not they have a
                     parent. It does not match attribute or namespace nodes because the expression
                     does not select nodes using the attribute or namespace axes. It does not match
                     document nodes because for backwards compatibility reasons the
                        <code>child-or-top</code> axis does not match a document node.</p>
                  <p>The path pattern <code>$V</code> matches all nodes selected by the expression
                        <code>root(.)//($V)</code>, that is, all nodes in the value of $V (which
                     will typically be a global variable, though when the pattern is used in
                     contexts such as the <elcode>xsl:number</elcode> or
                        <elcode>xsl:for-each-group</elcode> instructions, it can also be a local
                     variable).</p>
                  <p>The path pattern <code>doc('product.xml')//product</code> matches all nodes
                     selected by the expression <code>root(.)//(doc('product.xml')//product)</code>,
                     that is, all <code>product</code> elements in the document whose URI is
                        <code>product.xml</code>.</p>
               </example>
               <p>Although the semantics of path patterns are specified formally in terms of
                  expression evaluation, it is possible to understand pattern matching using a
                  different model. A path pattern such as <code>book/chapter/section</code> can be
                  examined from right to left. A node will only match this pattern if it is a
                     <code>section</code> element; and then, only if its parent is a
                     <code>chapter</code>; and then, only if the parent of that <code>chapter</code>
                  is a <code>book</code>. When the pattern uses the <code>//</code> operator, one
                  can still read it from right to left, but this time testing the ancestors of a
                  node rather than its parent. For example <code>appendix//section</code> matches
                  every <code>section</code> element that has an ancestor <code>appendix</code>
                  element.</p>
               <p>The formal definition, however, is useful for understanding the meaning of a
                  pattern such as <code>para[1]</code>. This matches any node selected by the
                  expression <code>root(.)//(child-or-top::para[1])</code>: that is, any
                     <code>para</code> element that is the first <code>para</code> child of its
                  parent, or a <code>para</code> element that has no parent.</p>
               <note>
                  <p>An implementation, of course, may use any algorithm it wishes for evaluating
                     patterns, so long as the result corresponds with the formal definition above.
                     An implementation that followed the formal definition by evaluating the
                     equivalent expression and then testing the membership of a specific node in the
                     result would probably be very inefficient.</p>
               </note>
            </div3>
            <div3 id="pattern-errors">
               <head>Errors in Patterns</head>
               <p>Any <termref def="dt-dynamic-error">dynamic error</termref> or <termref def="dt-type-error">type error</termref> that occurs during the evaluation of a
                     <termref def="dt-pattern">pattern</termref> against a particular <phrase diff="chg" at="C">item</phrase> is treated as a <termref def="dt-recoverable-error">recoverable error</termref> even if the error would
                  not be recoverable under other circumstances. The <termref def="dt-optional-recovery-action">optional recovery action</termref> is to
                  treat the pattern as not matching that node.</p>
               <note>
                  <p>The reason for this provision is that it is difficult for the stylesheet author
                     to predict which predicates in a pattern will actually be evaluated. In the
                     case of match patterns in template rules, it is not even possible to predict
                     which patterns will be evaluated against a particular node. Making errors in
                     patterns recoverable enables an implementation, if it chooses to do so, to
                     report such errors while stylesheets are under development, while masking them
                     if they occur during production running.</p>
               </note>
               <p>There are several particular cases where a processor <rfc2119>must not</rfc2119>
                  raise a dynamic error:</p>
               <ulist>
                  <item>
                     <p>When evaluating a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PathPattern" xlink:type="simple">PathPattern</nt> that starts with
                           <code>/</code> or <code>//</code> or <phrase diff="chg" at="C">with a
                           call on <xfunction>id</xfunction>,
                           <xfunction>element-with-id</xfunction>, or
                           <function>key</function></phrase>, the result of testing this pattern
                        against a node in a tree whose root is not a document node must be a
                        non-match, rather than a dynamic error. This rule applies to each <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PathPattern" xlink:type="simple">PathPattern</nt> within a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-Pattern" xlink:type="simple">Pattern</nt>.</p>
                     <note>
                        <p>Without the above rule, any attempt to apply templates to a parentless
                           element node would create the risk of a dynamic error if the stylesheet
                           has a template rule specifying <code>match="/"</code>.</p>
                     </note>
                  </item>
                  <item diff="add" at="C">
                     <p>When matching an atomic value against a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PathPattern" xlink:type="simple">PathPattern</nt>, the result <rfc2119>must</rfc2119> always be a
                        non-match, rather than a dynamic error.</p>
                  </item>
                  <item diff="add" at="C">
                     <p>A processor <rfc2119>must not</rfc2119> evaluate a predicate within a
                        pattern unless the item matches the part of the pattern that is qualified by
                        the predicate. (Or equivalently, if it does evaluate the predicate, it must
                        not signal an error when the evaluation fails.) For example, evaluation of
                        the pattern <code>~xs:integer[. gt 5]</code> must not cause an error when
                        testing an item of type <code>xs:date</code>, and the pattern
                           <code>$var[child::*]</code> must not cause an error when testing an
                        atomic value. If there are multiple predicates, they must be evaluated from
                        left to right.</p>
                  </item>
               </ulist>

            </div3>
         </div2>
         <div2 id="attribute-value-templates">
            <head>Attribute Value Templates</head>
            <p>
               <termdef id="dt-attribute-value-template" term="attribute value template">In an
                  attribute that is designated as an <term>attribute value template</term>, such as
                  an attribute of a <termref def="dt-literal-result-element">literal result
                     element</termref>, an <termref def="dt-expression">expression</termref> can be
                  used by surrounding the expression with curly brackets
               (<code>{}</code>)</termdef>.</p>
            <p>An attribute value template consists of an alternating sequence of fixed parts and
               variable parts. A variable part consists of an XPath <termref def="dt-expression">expression</termref> enclosed in curly brackets (<code>{}</code>). A fixed part
               may contain any characters, except that a left curly bracket <rfc2119>must</rfc2119>
               be written as <code>{{</code> and a right curly bracket <rfc2119>must</rfc2119> be
               written as <code>}}</code>. <phrase diff="add" at="C">If the XPath expression ends
                  with a closing curly bracket, this must be separated from the delimiting closing
                  bracket by whitespace.</phrase>
            </p>
            <note>
               <p>An expression within a variable part may contain an unescaped curly bracket within
                  a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-StringLiteral" xlink:type="simple">StringLiteral</xnt> or within
                  a comment.</p>
               <p diff="add" at="C">Currently no XPath expression starts with an opening curly
                  bracket, and the only XPath expression that can end in a closing curly bracket is
                  an inline function literal, which cannot usefully appear in an attribute value
                  template.</p>
            </note>
            <p>
               <error spec="XT" type="static" class="SE" code="0350">
                  <p>It is a <termref def="dt-static-error">static error</termref> if an unescaped
                     left curly bracket appears in a fixed part of an attribute value template
                     without a matching right curly bracket.</p>
               </error>
            </p>
            <p>It is a <termref def="dt-static-error">static error</termref> if the string contained
               between matching curly brackets in an attribute value template does not match the
               XPath production <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-Expr" xlink:type="simple">Expr</xnt>, or if it
               contains other XPath static errors. The error is signaled using the appropriate XPath
               error code.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0370">
                  <p>It is a <termref def="dt-static-error">static error</termref> if an unescaped
                     right curly bracket occurs in a fixed part of an attribute value template.</p>
               </error>
            </p>
            <p>
               <termdef id="dt-effective-value" term="effective value">The result of evaluating an
                  attribute value template is referred to as the <term>effective value</term> of the
                  attribute.</termdef> The effective value is the string obtained by concatenating
               the expansions of the fixed and variable parts:</p>
            <ulist>
               <item>
                  <p>The expansion of a fixed part is obtained by replacing any double curly
                     brackets (<code>{{</code> or <code>}}</code>) by the corresponding single curly
                     bracket.</p>
               </item>
               <item>
                  <p>The expansion of a variable part is obtained by evaluating the enclosed XPath
                        <termref def="dt-expression">expression</termref> and converting the
                     resulting value to a string. This conversion is done using the rules given in
                        <specref ref="constructing-simple-content"/>.</p>
               </item>
            </ulist>
            <note>
               <p>This process can generate dynamic errors, for example if the sequence contains an
                  element with a complex content type (which cannot be atomized).</p>
            </note>
            <p><phrase diff="chg" at="D">If the element containing the attribute is processed with
                     <termref def="dt-xslt-10-behavior">XSLT 1.0 behavior</termref>, then the rules
                  for converting the value of the expression to a string are modified as
                  follows.</phrase> After <termref def="dt-atomization">atomizing</termref> the
               result of the expression, all items other than the first item in the resulting
               sequence are discarded, and the effective value is obtained by converting the first
               item in the sequence to a string. If the atomized sequence is empty, the result is a
               zero-length string.</p>
            <p>Curly brackets are not treated specially in an attribute value in an XSLT <termref def="dt-stylesheet">stylesheet</termref> unless the attribute is specifically
               designated as one that permits an attribute value template; in an element syntax
               summary, the value of such attributes is surrounded by curly brackets.</p>
            <note>
               <p>Not all attributes are designated as attribute value templates. Attributes whose
                  value is an <termref def="dt-expression">expression</termref> or <termref def="dt-pattern">pattern</termref>, attributes of <termref def="dt-declaration">declaration</termref> elements and attributes that refer to named XSLT objects
                  are generally not designated as attribute value templates (an exception is the
                     <code>format</code> attribute of <elcode>xsl:result-document</elcode>).
                  Namespace declarations are not XDM attribute nodes and are therefore never treated
                  as attribute value templates.</p>
            </note>
            <example>
               <head>Attribute Value Templates</head>
               <p>The following example creates an <code>img</code> result element from a
                     <code>photograph</code> element in the source; the value of the
                     <code>src</code> and <code>width</code> attributes are computed using XPath
                  expressions enclosed in attribute value templates:</p>
               <eg xml:space="preserve">&lt;xsl:variable name="image-dir" select="'/images'"/&gt;

&lt;xsl:template match="photograph"&gt;
  &lt;img src="{$image-dir}/{href}" width="{size/@width}"/&gt;
&lt;/xsl:template&gt;</eg>
               <p>With this source</p>
               <eg xml:space="preserve">&lt;photograph&gt;
  &lt;href&gt;headquarters.jpg&lt;/href&gt;
  &lt;size width="300"/&gt;
&lt;/photograph&gt;</eg>
               <p>the result would be</p>
               <eg xml:space="preserve">&lt;img src="/images/headquarters.jpg" width="300"/&gt;</eg>
            </example>
            <example>
               <head>Producing a Space-Separated List</head>
               <p>The following example shows how the values in a sequence are output as a
                  space-separated list. The following literal result element:</p>
               <eg xml:space="preserve">&lt;temperature readings="{10.32, 5.50, 8.31}"/&gt;</eg>
               <p>produces the output node:</p>
               <eg xml:space="preserve">&lt;temperature readings="10.32 5.5 8.31"/&gt;</eg>
            </example>
            <p>Curly brackets are <emph>not</emph> recognized recursively inside expressions.</p>
            <example>
               <head>Curly Brackets can not be Nested</head>
               <p>For example:</p>
               <eg role="error" xml:space="preserve">&lt;a href="#{id({@ref})/title}"&gt;</eg>
               <p>is <emph>not</emph> allowed. Instead, use simply:</p>
               <eg xml:space="preserve">&lt;a href="#{id(@ref)/title}"&gt;</eg>
            </example>
         </div2>
         <div2 id="sequence-constructors">
            <head>Sequence Constructors</head>
            <p>
               <termdef id="dt-sequence-constructor" term="sequence constructor">A <term>sequence
                     constructor</term> is a sequence of zero or more sibling nodes in the <termref def="dt-stylesheet">stylesheet</termref> that can be evaluated to return a
                  sequence of nodes, atomic values, <phrase diff="add" at="C">and function
                     items</phrase>. The way that the resulting sequence is used depends on the
                  containing instruction.</termdef>
            </p>
            <p>Many <termref def="dt-xslt-element">XSLT elements</termref>, and also <termref def="dt-literal-result-element">literal result elements</termref>, are defined to
               take a <termref def="dt-sequence-constructor">sequence constructor</termref> as their
               content.</p>
            <p>Four kinds of nodes may be encountered in a sequence constructor:</p>
            <ulist diff="chg" at="F">
               <item>
                  <p>
                     A <emph>Text node</emph> appearing in the <termref def="dt-stylesheet">stylesheet</termref> (if it has not been removed in the process of
                     whitespace stripping: see <specref ref="stylesheet-stripping"/>) is copied to
                     create a new parentless text node.</p>
               </item>
               <item>
                  <p>
                     A <termref def="dt-literal-result-element">literal result element</termref> is
                     evaluated to create a new parentless element node, having the same <termref def="dt-expanded-qname">expanded-QName</termref> as the literal result
                     element: see <specref ref="literal-result-element"/>.
                  </p>
               </item>
               <item>
                  <p>An XSLT <termref def="dt-instruction">instruction</termref> produces a sequence of
                     zero, one, or more items as its result. For most XSLT instructions, these items are nodes, but some
                     instructions (<phrase diff="add" at="D">such as</phrase>
                     <elcode>xsl:sequence</elcode> and <elcode>xsl:copy-of</elcode>) can also
                     produce atomic values <phrase diff="add" at="C">or function items</phrase>.
                     Several instructions, such as <elcode>xsl:element</elcode>, return a newly
                     constructed parentless node (which may have its own attributes, namespaces,
                     children, and other descendants). Other instructions, such as
                        <elcode>xsl:if</elcode>, pass on the items produced by their own nested
                     sequence constructors. The <elcode>xsl:sequence</elcode> instruction may return
                     atomic values, <phrase diff="add" at="C">function items</phrase>, or existing
                     nodes.</p>
               </item>
               <item>
                  <p>
                     An <termref def="dt-extension-instruction"/> (see
                        <specref ref="extension-instruction"/>) also produces a sequence of items as
                     its result.</p>
               </item>
            </ulist>
            <p diff="add" at="F">The result of evaluating a <termref def="dt-sequence-constructor"/> is the sequence of items
            formed by concatenating the results of evaluating each of the nodes in the sequence constructor,
            retaining order.</p>
            <p>There are several ways the result of a sequence constructor may be used.</p>
            <ulist>
               <item>
                  <p>The sequence may be bound to a variable or returned from a stylesheet function,
                     in which case it becomes available as a value to be manipulated in arbitrary
                     ways by XPath expressions. The sequence is bound to a variable when the
                     sequence constructor appears within one of the elements
                        <elcode>xsl:variable</elcode>, <elcode>xsl:param</elcode>, or
                        <elcode>xsl:with-param</elcode>, when this instruction has an
                        <code>as</code> attribute. The sequence is returned from a stylesheet
                     function when the sequence constructor appears within the
                        <elcode>xsl:function</elcode> element.</p>
                  <note>
                     <p>This will typically expose to the stylesheet elements, attributes, and other
                        nodes that have not yet been attached to a parent node in a <termref def="dt-result-tree">result tree</termref>. The semantics of XPath
                        expressions when applied to parentless nodes are well-defined; however, such
                        expressions should be used with care. For example, the expression
                           <code>/</code> causes a type error if the root of the tree containing the
                        context node is not a document node.</p>
                     <p>Parentless attribute nodes require particular care because they have no
                        namespace nodes associated with them. A parentless attribute node is not
                        permitted to contain namespace-sensitive content (for example, a QName or an
                        XPath expression) because there is no information enabling the prefix to be
                        resolved to a namespace URI. Parentless attributes can be useful in an
                        application (for example, they provide an alternative to the use of
                        attribute sets: see <specref ref="attribute-sets"/>) but they need to be
                        handled with care.</p>
                  </note>
               </item>
               <item>
                  <p>The sequence may be returned as the result of the containing element. This
                     happens when the <phrase diff="chg" at="C">element</phrase> containing the
                     sequence constructor is <elcode>xsl:analyze-string</elcode>,
                        <elcode>xsl:apply-imports</elcode>, <elcode>xsl:apply-templates</elcode>,
                        <phrase diff="add" at="C"><elcode>xsl:break</elcode></phrase>,
                        <elcode>xsl:call-template</elcode>, <phrase diff="add" at="B"><elcode>xsl:catch</elcode></phrase>, <elcode>xsl:choose</elcode>,
                        <elcode>xsl:fallback</elcode>, <elcode>xsl:for-each</elcode>,
                        <elcode>xsl:for-each-group</elcode>, <phrase diff="add" at="C"><elcode>xsl:fork</elcode></phrase>, <elcode>xsl:if</elcode>, <phrase diff="add" at="C"><elcode>xsl:iterate</elcode></phrase>,
                        <elcode>xsl:matching-substring</elcode>, <elcode>xsl:next-match</elcode>,
                        <elcode>xsl:non-matching-substring</elcode>, <phrase diff="add" at="C"><elcode>xsl:on-completion</elcode></phrase>,
                        <elcode>xsl:otherwise</elcode>, <elcode>xsl:perform-sort</elcode>,
                        <elcode>xsl:sequence</elcode>, <phrase diff="add" at="B"><elcode>xsl:try</elcode></phrase>, or <elcode>xsl:when</elcode>. </p>
               </item>
               <item>
                  <p>The sequence may be used to construct the content of a new element or document
                     node. This happens when the sequence constructor appears as the content of a
                        <termref def="dt-literal-result-element">literal result element</termref>,
                     or of one of the instructions <elcode>xsl:copy</elcode>,
                        <elcode>xsl:element</elcode>, <elcode>xsl:document</elcode>,
                        <elcode>xsl:result-document</elcode>, or <elcode>xsl:message</elcode>. It
                     also happens when the sequence constructor is contained in one of the elements
                        <elcode>xsl:variable</elcode>, <elcode>xsl:param</elcode>,
                        <elcode>xsl:with-param</elcode>, or <phrase diff="add" at="D"><elcode>xsl:context-item</elcode></phrase>, when this instruction has no
                        <code>as</code> attribute. For details, see <specref ref="constructing-complex-content"/>.</p>
               </item>
               <item>
                  <p>The sequence may be used to construct the <termref def="dt-string-value">string
                        value</termref> of an attribute node, text node, namespace node, comment
                     node, or processing instruction node. This happens when the sequence
                     constructor is contained in one of the elements <elcode>xsl:attribute</elcode>,
                        <elcode>xsl:value-of</elcode>, <elcode>xsl:namespace</elcode>,
                        <elcode>xsl:comment</elcode>, or
                     <elcode>xsl:processing-instruction</elcode>. For details, see <specref ref="constructing-simple-content"/>.</p>
               </item>
            </ulist>
            <note diff="del" at="A">
               <p>The term <emph>sequence constructor</emph> replaces <emph>template</emph> as used
                  in XSLT 1.0. The change is made partly for clarity (to avoid confusion with
                     <termref def="dt-template-rule">template rules</termref> and <termref def="dt-named-template">named templates</termref>), but also to reflect a more
                  formal definition of the semantics. Whereas XSLT 1.0 described a template as a
                  sequence of instructions that write to the result tree, XSLT 2.0 describes a
                  sequence constructor as something that can be evaluated to return a sequence of
                  items; what happens to these items depends on the containing instruction.</p>
            </note>
            <div3 id="constructing-complex-content">
               <head>Constructing Complex Content</head>
               <p>This section describes how the sequence obtained by evaluating a <termref def="dt-sequence-constructor">sequence constructor</termref> may be used to
                  construct the children of a newly constructed document node, or the children,
                  attributes and namespaces of a newly constructed element node. The sequence of
                  items may be obtained by evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref> contained in an instruction such as
                     <elcode>xsl:copy</elcode>, <elcode>xsl:element</elcode>,
                     <elcode>xsl:document</elcode>, <elcode>xsl:result-document</elcode>, or a
                     <termref def="dt-literal-result-element">literal result element</termref>.</p>
               <p>When constructing the content of an element, the <code>inherit-namespaces</code>
                  attribute of the <elcode>xsl:element</elcode> or <elcode>xsl:copy</elcode>
                  instruction, or the <code>xsl:inherit-namespaces</code> property of the literal
                  result element, determines whether namespace nodes are to be inherited. The effect
                  of this attribute is described in the rules that follow.</p>
               <p>The sequence is processed as follows (applying the rules in the order they are
                  listed):</p>
               <olist>
                  <item>
                     <p>The containing instruction may generate attribute nodes and/or namespace
                        nodes, as specified in the rules for the individual instruction. For
                        example, these nodes may be produced by expanding an
                           <code>[xsl:]use-attribute-sets</code> attribute, or by expanding the
                        attributes of a <termref def="dt-literal-result-element">literal result
                           element</termref>. Any such nodes are prepended to the sequence produced
                        by evaluating the <termref def="dt-sequence-constructor">sequence
                           constructor</termref>.</p>
                  </item>
                  <item>
                     <p>Any atomic value in the sequence is cast to a string.</p>
                     <note>
                        <p>Casting from <code>xs:QName</code> or <code>xs:NOTATION</code> to
                              <code>xs:string</code> always succeeds, because these values retain a
                           prefix for this purpose. However, there is no guarantee that the prefix
                           used will always be meaningful in the context where the resulting string
                           is used.</p>
                     </note>
                  </item>
                  <item>
                     <p>Any consecutive sequence of strings within the result sequence is converted
                        to a single text node, whose <termref def="dt-string-value">string
                           value</termref> contains the content of each of the strings in turn, with
                        a single space (#x20) used as a separator between successive strings.</p>
                  </item>
                  <item>
                     <p>Any document node within the result sequence is replaced by a sequence
                        containing each of its children, in document order.</p>
                  </item>
                  <item>
                     <p>Zero-length text nodes within the result sequence are removed.</p>
                  </item>
                  <item>
                     <p>Adjacent text nodes within the result sequence are merged into a single text
                        node.</p>
                  </item>
                  <item>
                     <p>Invalid <phrase diff="chg" at="C">items in the result sequence</phrase> are
                        detected as follows.</p>
                     <p>
                        <error spec="XT" type="dynamic" class="DE" code="0410">
                           <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                                 error</termref> if the result sequence used to construct the
                              content of an element node contains a namespace node or attribute node
                              that is preceded in the sequence by a node that is neither a namespace
                              node nor an attribute node.</p>
                        </error>
                     </p>
                     <p>
                        <error spec="XT" type="dynamic" class="DE" code="0420">
                           <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                                 error</termref> if the result sequence used to construct the
                              content of a document node contains a namespace node or attribute
                              node.</p>
                        </error>
                     </p>
                     <p>
                        <error spec="XT" type="dynamic" class="DE" code="0430">
                           <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                                 error</termref> if the result sequence contains two or more
                              namespace nodes having the same name but different <termref def="dt-string-value">string values</termref> (that is, namespace
                              nodes that map the same prefix to different namespace URIs).</p>
                        </error>
                     </p>
                     <p>
                        <error spec="XT" type="dynamic" class="DE" code="0440">
                           <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                                 error</termref> if the result sequence contains a namespace node
                              with no name and the element node being constructed has a null
                              namespace URI (that is, it is an error to define a default namespace
                              when the element is in no namespace). </p>
                        </error>
                     </p>
                     <p diff="add" at="C">
                        <error spec="XT" type="dynamic" class="DE" code="0450">
                           <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                                 error</termref> if the result sequence contains a function item.
                           </p>
                        </error>
                     </p>
                  </item>
                  <item>
                     <p>If the result sequence contains two or more namespace nodes with the same
                        name (or no name) and the same <termref def="dt-string-value">string
                           value</termref> (that is, two namespace nodes mapping the same prefix to
                        the same namespace URI), then all but one of the duplicate nodes are
                        discarded.</p>
                     <note>
                        <p>Since the order of namespace nodes is undefined, it is not significant
                           which of the duplicates is retained.</p>
                     </note>
                  </item>
                  <item>
                     <!--Text replaced by erratum E10 change 1"-->
                     <p>If an attribute <var>A</var> in the result sequence has the same name as
                        another attribute <var>B</var> that appears later in the result sequence,
                        then attribute <var>A</var> is discarded from the result sequence. Before
                        discarding attribute <var>A</var>, the processor <rfc2119>may</rfc2119>
                        signal any <termref def="dt-type-error">type errors</termref> that would be
                        signaled if attribute <var>B</var> were not present. </p>
                     <!--End of text replaced by erratum E10-->
                  </item>
                  <item>
                     <p>Each node in the resulting sequence is attached as a namespace, attribute,
                        or child of the newly constructed element or document node. Conceptually
                        this involves making a deep copy of the node; in practice, however, copying
                        the node will only be necessary if the existing node can be referenced
                        independently of the parent to which it is being attached. When copying an
                        element or processing instruction node, its base URI property is changed to
                        be the same as that of its new parent, unless it has an
                           <code>xml:base</code> attribute (see <bibref ref="xmlbase"/>) that
                        overrides this. If the copied element has an <code>xml:base</code>
                        attribute, its base URI is the value of that attribute, resolved (if it is
                        relative) against the base URI of the new parent node.</p>
                  </item>
                  <item>
                     <p>If the newly constructed node is an element node, then namespace fixup is
                        applied to this node, as described in <specref ref="namespace-fixup"/>.</p>
                  </item>
                  <item>
                     <p>If the newly constructed node is an element node, and if namespaces are
                        inherited, then each namespace node of the newly constructed element
                        (including any produced as a result of the namespace fixup process) is
                        copied to each descendant element of the newly constructed element, unless
                        that element or an intermediate element already has a namespace node with
                        the same name (or absence of a name) or that descendant element or an
                        intermediate element is in no namespace and the namespace node has no
                        name.</p>
                  </item>
               </olist>
               <example>
                  <head>A Sequence Constructor for Complex Content</head>
                  <p>Consider the following stylesheet fragment:</p>
                  <eg xml:space="preserve">&lt;td&gt;
  &lt;xsl:attribute name="valign"&gt;top&lt;/xsl:attribute&gt;
  &lt;xsl:value-of select="@description"/&gt;
&lt;/td&gt;</eg>
                  <p>This fragment consists of a literal result element <code>td</code>, containing
                     a sequence constructor that consists of two instructions:
                        <elcode>xsl:attribute</elcode> and <elcode>xsl:value-of</elcode>. The
                     sequence constructor is evaluated to produce a sequence of two nodes: a
                     parentless attribute node, and a parentless text node. The <code>td</code>
                     instruction causes a <code>td</code> element to be created; the new attribute
                     therefore becomes an attribute of the new <code>td</code> element, while the
                     text node created by the <elcode>xsl:value-of</elcode> instruction becomes a
                     child of the <code>td</code> element (unless it is zero-length, in which case
                     it is discarded).</p>
               </example>
               <example>
                  <head>Space Separators in Element Content</head>
                  <p>Consider the following stylesheet fragment:</p>
                  <eg xml:space="preserve">&lt;doc&gt;
  &lt;e&gt;&lt;xsl:sequence select="1 to 5"/&gt;&lt;/e&gt;
  &lt;f&gt;
    &lt;xsl:for-each select="1 to 5"&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/f&gt;
&lt;/doc&gt;</eg>
                  <p>This produces the output (when indented):</p>
                  <eg xml:space="preserve">&lt;doc&gt;
  &lt;e&gt;1 2 3 4 5&lt;/e&gt;
  &lt;f&gt;12345&lt;/f&gt;
&lt;/doc&gt;</eg>
                  <p>The difference between the two cases is that for the <code>e</code> element,
                     the sequence constructor generates a sequence of five atomic values, which are
                     therefore separated by spaces. For the <code>f</code> element, the content is a
                     sequence of five text nodes, which are concatenated without space
                     separation.</p>
                  <p>It is important to be aware of the distinction between
                        <elcode>xsl:sequence</elcode>, which returns the value of its
                        <code>select</code> expression unchanged, and <elcode>xsl:value-of</elcode>,
                     which constructs a text node.</p>
               </example>
            </div3>
            <div3 id="constructing-simple-content">
               <head>Constructing Simple Content</head>
               <p>The instructions <elcode>xsl:attribute</elcode>, <elcode>xsl:comment</elcode>,
                     <elcode>xsl:processing-instruction</elcode>, <elcode>xsl:namespace</elcode>,
                  and <elcode>xsl:value-of</elcode> all create nodes that cannot have children.
                  Specifically, the <elcode>xsl:attribute</elcode> instruction creates an attribute
                  node, <elcode>xsl:comment</elcode> creates a comment node,
                     <elcode>xsl:processing-instruction</elcode> creates a processing instruction
                  node, <elcode>xsl:namespace</elcode> creates a namespace node, and
                     <elcode>xsl:value-of</elcode> creates a text node. The string value of the new
                  node is constructed using either the <code>select</code> attribute of the
                  instruction, or the <termref def="dt-sequence-constructor">sequence
                     constructor</termref> that forms the content of the instruction. The
                     <code>select</code> attribute allows the content to be specified by means of an
                  XPath expression, while the sequence constructor allows it to be specified by
                  means of a sequence of XSLT instructions. The <code>select</code> attribute or
                  sequence constructor is evaluated to produce a result sequence, and the <termref def="dt-string-value">string value</termref> of the new node is derived from
                  this result sequence according to the rules below.</p>
               <p>These rules are also used to compute the <termref def="dt-effective-value">effective value</termref> of an <termref def="dt-attribute-value-template">attribute value template</termref>. In this case the sequence being processed
                  is the result of evaluating an XPath expression enclosed between curly brackets,
                  and the separator is a single space character.</p>
               <olist>
                  <item>
                     <p>Zero-length text nodes in the sequence are discarded.</p>
                  </item>
                  <item>
                     <p>Adjacent text nodes in the sequence are merged into a single text node.</p>
                  </item>
                  <item>
                     <p>The sequence is <termref def="dt-atomization">atomized</termref>
                        <phrase diff="add" at="C">(which may cause a dynamic error)</phrase>.</p>
                  </item>
                  <item>
                     <p>Every value in the atomized sequence is cast to a string.</p>
                  </item>
                  <item>
                     <p>The strings within the resulting sequence are concatenated, with a (possibly
                        zero-length) separator inserted between successive strings. The default
                        separator is a single space. In the case of <elcode>xsl:attribute</elcode>
                        and <elcode>xsl:value-of</elcode>, a different separator can be specified
                        using the <code>separator</code> attribute of the instruction; it is
                        permissible for this to be a zero-length string, in which case the strings
                        are concatenated with no separator. In the case of
                           <elcode>xsl:comment</elcode>,
                        <elcode>xsl:processing-instruction</elcode>, and
                           <elcode>xsl:namespace</elcode>, and when expanding an <termref def="dt-attribute-value-template">attribute value template</termref>, the
                        default separator cannot be changed.</p>
                  </item>
                  <item>
                     <p>In the case of <elcode>xsl:processing-instruction</elcode>, any leading
                        spaces in the resulting string are removed.</p>
                  </item>
                  <item>
                     <p>The resulting string forms the <termref def="dt-string-value">string
                           value</termref> of the new attribute, namespace, comment,
                        processing-instruction, or text node.</p>
                  </item>
               </olist>
               <example>
                  <head>Space Separators in Attribute Content</head>
                  <p>Consider the following stylesheet fragment:</p>
                  <eg xml:space="preserve">&lt;doc&gt;
  &lt;xsl:attribute name="e" select="1 to 5"/&gt;
  &lt;xsl:attribute name="f"&gt;
    &lt;xsl:for-each select="1 to 5"&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:attribute&gt;
&lt;/doc&gt;</eg>
                  <p>This produces the output:</p>
                  <eg xml:space="preserve">&lt;doc e="1 2 3 4 5" f="12345"/&gt;</eg>
                  <p>The difference between the two cases is that for the <code>e</code> attribute,
                     the sequence constructor generates a sequence of five atomic values, which are
                     therefore separated by spaces. For the <code>f</code> attribute, the content is
                     supplied as a sequence of five text nodes, which are concatenated without space
                     separation.</p>
                  <p>Specifying <code>separator=""</code> on the first
                        <elcode>xsl:attribute</elcode> instruction would cause the attribute value
                     to be <code>e="12345"</code>. A <code>separator</code> attribute on the second
                        <elcode>xsl:attribute</elcode> instruction would have no effect, since the
                     separator only affects the way adjacent atomic values are handled: separators
                     are never inserted between adjacent text nodes.</p>
               </example>
               <note>
                  <p>If an attribute value template contains a sequence of fixed and variable parts,
                     no additional whitespace is inserted between the expansions of the fixed and
                     variable parts. For example, the <termref def="dt-effective-value">effective
                        value</termref> of the attribute <code>a="chapters{4 to 6}"</code> is
                        <code>a="chapters4 5 6"</code>.</p>
               </note>
            </div3>
            <div3 id="namespace-fixup">
               <head>Namespace Fixup</head>
               <p>In a tree supplied to or constructed by an XSLT processor, the constraints
                  relating to namespace nodes that are specified in <bibref ref="xpath-datamodel-11"/>
                  <rfc2119>must</rfc2119> be satisfied. For example</p>
               <ulist>
                  <item>
                     <p>If an element node has an <termref def="dt-expanded-qname">expanded-QName</termref> with a non-null namespace URI, then that
                        element node <rfc2119>must</rfc2119> have at least one namespace node whose
                           <termref def="dt-string-value">string value</termref> is the same as that
                        namespace URI.</p>
                  </item>
                  <item>
                     <p>If an element node has an attribute node whose <termref def="dt-expanded-qname">expanded-QName</termref> has a non-null namespace
                        URI, then the element <rfc2119>must</rfc2119> have at least one namespace
                        node whose <termref def="dt-string-value">string value</termref> is the same
                        as that namespace URI and whose name is non-empty.</p>
                  </item>
                  <item>
                     <p>Every element <rfc2119>must</rfc2119> have a namespace node whose <termref def="dt-expanded-qname">expanded-QName</termref> has local-part
                           <code>xml</code> and whose <termref def="dt-string-value">string
                           value</termref> is <code>http://www.w3.org/XML/1998/namespace</code>. The
                        namespace prefix <code>xml</code> must not be associated with any other
                        namespace URI, and the namespace URI
                           <code>http://www.w3.org/XML/1998/namespace</code> must not be associated
                        with any other prefix.</p>
                  </item>
                  <item>
                     <!--Text replaced by erratum E6 change 7"-->
                     <p>A namespace node <rfc2119>must not</rfc2119> have the name
                           <code>xmlns</code> or the string value
                           <code>http://www.w3.org/2000/xmlns/</code>.</p>
                     <!--End of text replaced by erratum E6-->
                  </item>
               </ulist>
               <p>
                  <termdef id="dt-namespace-fixup" term="namespace fixup">The rules for the
                     individual XSLT instructions that construct a <termref def="dt-result-tree">result tree</termref> (see <specref ref="creating-new-nodes"/>) prescribe
                     some of the situations in which namespace nodes are written to the tree. These
                     rules, however, are not sufficient to ensure that the prescribed constraints
                     are always satisfied. The XSLT processor <rfc2119>must</rfc2119> therefore add
                     additional namespace nodes to satisfy these constraints. This process is
                     referred to as <term>namespace fixup</term>.</termdef>
               </p>
               <p>The actual namespace nodes that are added to the tree by the namespace fixup
                  process are <termref def="dt-implementation-dependent">implementation-dependent</termref>, provided firstly, that at the end of the
                  process the above constraints <rfc2119>must</rfc2119> all be satisfied, and
                  secondly, that a namespace node <rfc2119>must not</rfc2119> be added to the tree
                  unless the namespace node is necessary either to satisfy these constraints, or to
                  enable the tree to be serialized using the original namespace prefixes from the
                  source document or <termref def="dt-stylesheet">stylesheet</termref>.</p>
               <p>Namespace fixup <rfc2119>must not</rfc2119> result in an element having multiple
                  namespace nodes with the same name.</p>
               <p>Namespace fixup <rfc2119>may</rfc2119>, if necessary to resolve conflicts, change
                  the namespace prefix contained in the QName value that holds the name of an
                  element or attribute node. This includes the option to add or remove a prefix.
                  However, namespace fixup <rfc2119>must not</rfc2119> change the prefix component
                  contained in a value of type <code>xs:QName</code> or <code>xs:NOTATION</code>
                  that forms the typed value of an element or attribute node.</p>
               <note>
                  <p>Namespace fixup is not used to create namespace declarations for
                        <code>xs:QName</code> or <code>xs:NOTATION</code> values appearing in the
                     content of an element or attribute.</p>
                  <p>Where values acquire such types as the result of validation, namespace fixup
                     does not come into play, because namespace fixup happens before validation: in
                     this situation, it is the user's responsibility to ensure that the element
                     being validated has the required namespace nodes to enable validation to
                     succeed.</p>
                  <p>Where existing elements are copied along with their existing type annotations
                        (<code>validation="preserve"</code>) the rules require that existing
                     namespace nodes are also copied, so that any namespace-sensitive values remain
                     valid.</p>
                  <p>Where existing attributes are copied along with their existing type
                     annotations, the rules of the XDM data model require that a parentless
                     attribute node cannot contain a namespace-sensitive typed value; this means
                     that it is an error to copy an attribute using
                        <code>validation="preserve"</code> if it contains namespace-sensitive
                     content.</p>
               </note>
               <p>Namespace fixup is applied to every element that is constructed using a <termref def="dt-literal-result-element">literal result element</termref>, or one of the
                  instructions <elcode>xsl:element</elcode>, <elcode>xsl:copy</elcode>, or
                     <elcode>xsl:copy-of</elcode>. An implementation is not
                     <rfc2119>required</rfc2119> to perform namespace fixup for elements in any
                  source document, that is, for a document in the initial input sequence, documents
                  loaded using the <function>document</function>, <xfunction>doc</xfunction> or
                     <xfunction>collection</xfunction> function, documents supplied as the value of
                  a <termref def="dt-stylesheet-parameter">stylesheet parameter</termref>, or
                  documents returned by an <termref def="dt-extension-function">extension
                     function</termref> or <termref def="dt-extension-instruction">extension
                     instruction</termref>.</p>
               <note>
                  <p>A source document (an input document, a document returned by the
                        <function>document</function>, <xfunction>doc</xfunction> or
                        <xfunction>collection</xfunction> functions, a document returned by an
                     extension function or extension instruction, or a document supplied as a
                     stylesheet parameter) is required to satisfy the constraints described in
                        <bibref ref="xpath-datamodel-11"/>, including the constraints imposed by the
                     namespace fixup process. The effect of supplying a pseudo-document that does
                     not meet these constraints is undefined.</p>
               </note>
               <p>In an Infoset (see <bibref ref="xml-infoset"/>) created from a document conforming
                  to <bibref ref="xml-names"/>, it will always be true that if a parent element
                  has an in-scope namespace with a non-empty namespace prefix, then its child
                  elements will also have an in-scope namespace with the same namespace prefix,
                  though possibly with a different namespace URI. This constraint is removed in
                     <bibref ref="xml-names11"/>. XSLT <phrase diff="chg" at="A">2.1</phrase>
                  supports the creation of result trees that do not satisfy this constraint: the
                  namespace fixup process does not add a namespace node to an element merely because
                  its parent node in the <termref def="dt-result-tree">result tree</termref> has
                  such a namespace node. However, the process of constructing the children of a new
                  element, which is described in <specref ref="constructing-complex-content"/>, does
                  cause the namespaces of a parent element to be inherited by its children unless
                  this is prevented using <code>[xsl:]inherit-namespaces="no"</code> on the
                  instruction that creates the parent element.</p>
               <note>
                  <p>This has implications on serialization, defined in <bibref ref="xslt-xquery-serialization-11"/>. It means that it is possible to create
                        <termref def="dt-final-result-tree">final result trees</termref> that cannot
                     be faithfully serialized as XML 1.0 documents. When such a result tree is
                     serialized as XML 1.0, namespace declarations written for the parent element
                     will be inherited by its child elements as if the corresponding namespace nodes
                     were present on the child element, except in the case of the default namespace,
                     which can be undeclared using the construct <code>xmlns=""</code>. When the
                     same result tree is serialized as XML 1.1, however, it is possible to undeclare
                     any namespace on the child element (for example, <code>xmlns:foo=""</code>) to
                     prevent this inheritance taking place.</p>
               </note>
            </div3>
         </div2>
         <div2 id="uri-references">
            <head>URI References</head>
            <p>
               <termdef id="dt-uri-reference" term="URI Reference">Within this specification, the
                  term <term>URI Reference</term>, unless otherwise stated, refers to a string in
                  the lexical space of the <code>xs:anyURI</code> data type as defined in <bibref ref="xmlschema-2"/>.</termdef> Note that this is a wider definition than that
               in <bibref ref="RFC3986"/>: in particular, it is designed to accommodate
               Internationalized Resource Identifiers (IRIs) as described in <bibref ref="RFC3987"/>, and thus allows the use of non-ASCII characters without escaping.</p>
            <p>URI References are used in XSLT with three main roles:</p>
            <ulist>
               <item>
                  <p>As namespace URIs</p>
               </item>
               <item>
                  <p>As collation URIs</p>
               </item>
               <item>
                  <p>As identifiers for resources such as stylesheet modules; these resources are
                     typically accessible using a protocol such as HTTP. Examples of such
                     identifiers are the URIs used in the <code>href</code> attributes of
                        <elcode>xsl:import</elcode>, <elcode>xsl:include</elcode>, and
                        <elcode>xsl:result-document</elcode>.</p>
               </item>
            </ulist>
            <p>The rules for namespace URIs are given in <bibref ref="xml-names"/> and <bibref ref="xml-names11"/>. Those specifications deprecate the use of relative URI <phrase diff="add" at="F">references</phrase> as
               namespace URIs.</p>
            <p>The rules for collation URIs are given in <bibref ref="xpath-functions-11"/>.</p>
            <p>URI references used to identify external resources must conform to the same rules as
               the locator attribute (<code>href</code>) defined in section 5.4 of <bibref ref="xlink"/>. If the URI reference is relative, then it is resolved (unless
               otherwise specified) against the base URI of the containing element node, according
               to the rules of <bibref ref="RFC3986"/>, after first escaping all characters that
               need to be escaped to make it a valid RFC3986 URI reference. (But a relative URI <phrase diff="add" at="F">reference</phrase> in
               the <code>href</code> attribute of <elcode>xsl:result-document</elcode> is resolved
               against the <termref def="dt-base-output-uri">Base Output URI</termref>.)</p>
            <p>Other URI references appearing in an XSLT stylesheet document, for example the system
               identifiers of external entities or the value of the <code>xml:base</code> attribute,
               must follow the rules in their respective specifications.</p>
         </div2>
      </div1>
      <div1 id="rules">
         <head>Template Rules</head>
         <p>Template rules define the processing that can be applied to <phrase diff="chg" at="D">items</phrase> that match a particular <termref def="dt-pattern">pattern</termref>.</p>
         <div2 id="defining-templates">
            <head>Defining Templates</head>
            <e:element-syntax name="template">
               <e:in-category name="declaration"/>
               <e:attribute name="match">
                  <e:data-type name="pattern"/>
               </e:attribute>
               <e:attribute name="name">
                  <e:data-type name="qname"/>
               </e:attribute>
               <e:attribute name="priority">
                  <e:data-type name="number"/>
               </e:attribute>
               <e:attribute name="mode">
                  <e:data-type name="tokens"/>
               </e:attribute>
               <e:attribute name="as">
                  <e:data-type name="sequence-type"/>
               </e:attribute>
               <e:sequence>
                  <e:element repeat="zero-or-more" name="param"/>
                  <e:model name="sequence-constructor"/>
               </e:sequence>
               <e:allowed-parents>
                  <e:parent name="stylesheet"/>
                  <e:parent name="transform"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>
               <termdef id="dt-template" term="template">An <elcode>xsl:template</elcode>
                  declaration defines a <term>template</term>, which contains a <termref def="dt-sequence-constructor">sequence constructor</termref> for creating
                  nodes, atomic values, <phrase diff="add" at="C">and/or function items</phrase>. A
                  template can serve either as a <termref def="dt-template-rule">template
                     rule</termref>, invoked by matching <phrase diff="chg" at="C">items</phrase>
                  against a <termref def="dt-pattern">pattern</termref>, or as a <termref def="dt-named-template">named template</termref>, invoked explicitly by name.
                  It is also possible for the same template to serve in both capacities.</termdef>
            </p>
            <p>
               <error spec="XT" type="static" class="SE" code="0500">
                  <p>An <elcode>xsl:template</elcode> element <rfc2119>must</rfc2119> have either a
                        <code>match</code> attribute or a <code>name</code> attribute, or both. An
                        <elcode>xsl:template</elcode> element that has no <code>match</code>
                     attribute <rfc2119>must</rfc2119> have no <code>mode</code> attribute and no
                        <code>priority</code> attribute.</p>
               </error>
            </p>
            <p>If an <elcode>xsl:template</elcode> element has a <code>match</code> attribute, then
               it is a <termref def="dt-template-rule">template rule</termref>. If it has a
                  <code>name</code> attribute, then it is a <termref def="dt-named-template">named
                  template</termref>.</p>
            <p>A <termref def="dt-template">template</termref> may be invoked in a number of ways,
               depending on whether it is a <termref def="dt-template-rule">template rule</termref>,
               a <termref def="dt-named-template">named template</termref>, or both. The result of
               invoking the template is the result of evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref> contained in the
                  <elcode>xsl:template</elcode> element (see <specref ref="sequence-constructors"/>).</p>
            <p>If an <code>as</code> attribute is present, the <code>as</code> attribute defines the
               required type of the result. The result of evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref> is then converted to
               the required type using the <termref def="dt-function-conversion-rules">function
                  conversion rules</termref>. If no <code>as</code> attribute is specified, the
               default value is <code>item()*</code>, which permits any value. No conversion then
               takes place.</p>
            <p>
               <error spec="XT" type="type" class="TE" code="0505">
                  <p>It is a <termref def="dt-type-error">type error</termref> if the result of
                     evaluating the <termref def="dt-sequence-constructor">sequence
                        constructor</termref> cannot be converted to the required type.</p>
               </error>
            </p>
         </div2>
         <div2 id="defining-template-rules">
            <head>Defining Template Rules</head>
            <p>This section describes <termref def="dt-template-rule">template rules</termref>.
                  <termref def="dt-named-template">Named templates</termref> are described in
                  <specref ref="named-templates"/>.</p>
            <p>A <termref def="dt-template-rule">template rule</termref> is specified using the
                  <elcode>xsl:template</elcode> element with a <code>match</code> attribute. The
                  <code>match</code> attribute is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-Pattern" xlink:type="simple">Pattern</nt> that
               identifies the <phrase diff="chg" at="C">items</phrase> to which the rule applies.
               The result of applying the template rule is the result of evaluating the sequence
               constructor contained in the <elcode>xsl:template</elcode> element, with the matching
                  <phrase diff="chg" at="C">item</phrase> used as the <phrase diff="chg" at="C"><termref def="dt-context-item">context item</termref></phrase>.</p>
            <example>
               <head>A simple Template Rule</head>
               <p>For example, an XML document might contain:</p>
               <eg xml:space="preserve">This is an &lt;emph&gt;important&lt;/emph&gt; point.</eg>
               <p>The following <termref def="dt-template-rule">template rule</termref> matches
                     <code>emph</code> elements and produces a <code>fo:wrapper</code> element with
                  a <code>font-weight</code> property of <code>bold</code>.</p>
               <eg xml:space="preserve">&lt;xsl:template match="emph"&gt;
  &lt;fo:wrapper font-weight="bold" 
              xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:wrapper&gt;
&lt;/xsl:template&gt;
</eg>
            </example>
            <p>A <termref def="dt-template-rule">template rule</termref> is evaluated when an
                  <elcode>xsl:apply-templates</elcode> instruction selects <phrase diff="chg" at="C">an item</phrase> that matches the pattern specified in the <code>match</code>
               attribute. The <elcode>xsl:apply-templates</elcode> instruction is described in the
               next section. If several template rules match a selected <phrase diff="chg" at="C">item</phrase>, only one of them is evaluated, as described in <specref ref="conflict"/>.</p>
         </div2>
         <div2 id="applying-templates">
            <head>Applying Template Rules</head>
            <e:element-syntax name="apply-templates">
               <e:in-category name="instruction"/>
               <e:attribute name="select">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="mode">
                  <e:data-type name="token"/>
               </e:attribute>
               <e:choice repeat="zero-or-more">
                  <e:element name="sort"/>
                  <e:element name="with-param"/>
               </e:choice>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:apply-templates</elcode> instruction takes as input a sequence of
                  <phrase diff="chg" at="C">items</phrase> (typically nodes in a <termref def="dt-source-tree">source tree</termref>), and produces as output a sequence of
               items; these will often be nodes to be added to a <termref def="dt-result-tree">result tree</termref>.</p>
            <p>If the instruction has one or more <elcode>xsl:sort</elcode> children, then the input
               sequence is sorted as described in <specref ref="sorting"/>. The result of this sort
               is referred to below as the <term>sorted sequence</term>; if there are no
                  <elcode>xsl:sort</elcode> elements, then the sorted sequence is the same as the
               input sequence.</p>
            <p>Each <phrase diff="chg" at="C">item</phrase> in the input sequence is processed by
               finding a <termref def="dt-template-rule">template rule</termref> whose <termref def="dt-pattern">pattern</termref> matches that <phrase diff="chg" at="C">item</phrase>. If there is more than one such template rule, the best among them
               is chosen, using rules described in <specref ref="conflict"/>. If there is no
               template rule whose pattern matches the <phrase diff="chg" at="C">item</phrase>, a
               built-in template rule is used (see <specref ref="built-in-rule"/>). The chosen
               template rule is evaluated. The rule that matches the <var>N</var>th <phrase diff="chg" at="C">item</phrase> in the sorted sequence is evaluated with that
                  <phrase diff="chg" at="C">item</phrase> as the <termref def="dt-context-item">context item</termref>, with <var>N</var> as the <termref def="dt-context-position">context position</termref>, and with the length of the
               sorted sequence as the <termref def="dt-context-size">context size</termref>. Each
               template rule that is evaluated produces a sequence of items as its result. The
               resulting sequences (one for each <phrase diff="chg" at="C">item</phrase> in the
               sorted sequence) are then concatenated, to form a single sequence. They are
               concatenated retaining the order of the <phrase diff="chg" at="C">items</phrase> in
               the sorted sequence. The final concatenated sequence forms the result of the
                  <elcode>xsl:apply-templates</elcode> instruction. </p>
            <example>
               <head>Applying Template Rules</head>
               <p>Suppose the source document is as follows:</p>
               <eg xml:space="preserve">&lt;message&gt;Proceed &lt;emph&gt;at once&lt;/emph&gt; to the exit!&lt;/message&gt;</eg>
               <p>This can be processed using the two template rules shown below.</p>
               <eg xml:space="preserve">&lt;xsl:template match="message"&gt;
  &lt;p&gt;
    &lt;xsl:apply-templates select="child::node()"/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="emph"&gt;
  &lt;b&gt;
    &lt;xsl:apply-templates select="child::node()"/&gt;
  &lt;/b&gt;
&lt;/xsl:template&gt;</eg>
               <p>There is no template rule for the document node; the built-in template rule for
                  this node will cause the <code>message</code> element to be processed. The
                  template rule for the <code>message</code> element causes a <code>p</code> element
                  to be written to the <termref def="dt-result-tree">result tree</termref>; the
                  contents of this <code>p</code> element are constructed as the result of the
                     <elcode>xsl:apply-templates</elcode> instruction. This instruction selects the
                  three child nodes of the <code>message</code> element (a text node containing the
                  value "<code>Proceed </code>", an <code>emph</code> element node, and a text node
                  containing the value "<code> to the exit!</code>"). The two text nodes are
                  processed using the built-in template rule for text nodes, which returns a copy of
                  the text node. The <code>emph</code> element is processed using the explicit
                  template rule that specifies <code>match="emph"</code>.</p>
               <p>When the <code>emph</code> element is processed, this template rule constructs a
                     <code>b</code> element. The contents of the <code>b</code> element are
                  constructed by means of another <elcode>xsl:apply-templates</elcode> instruction,
                  which in this case selects a single node (the text node containing the value
                     "<code>at once</code>"). This is again processed using the built-in template
                  rule for text nodes, which returns a copy of the text node.</p>
               <p>The final result of the <code>match="message"</code> template rule thus consists
                  of a <code>p</code> element node with three children: a text node containing the
                  value "<code>Proceed </code>", a <code>b</code> element that is the parent of a
                  text node containing the value "<code>at once</code>", and a text node containing
                  the value "<code> to the exit!</code>". This <termref def="dt-result-tree">result
                     tree</termref> might be serialized as:</p>
               <eg xml:space="preserve">&lt;p&gt;Proceed &lt;b&gt;at once&lt;/b&gt; to the exit!&lt;/p&gt;</eg>
            </example>
            <p>The default value of the <code>select</code> attribute is <code>child::node()</code>,
               which causes all the children of the context node to be processed.</p>
            <p>
               <error spec="XT" type="type" class="TE" code="0510">
                  <p>It is a <termref def="dt-type-error">type error</termref> if an
                        <elcode>xsl:apply-templates</elcode> instruction with no <code>select</code>
                     attribute is evaluated when the <termref def="dt-context-item">context
                        item</termref> is not a node. </p>
               </error>
            </p>
            <p>A <code>select</code> attribute can be used to process <phrase diff="chg" at="C">items</phrase> selected by an expression instead of processing all children. The
               value of the <code>select</code> attribute is an <termref def="dt-expression">expression</termref>. <phrase diff="del" at="C">The expression
                     <rfc2119>must</rfc2119> evaluate to a sequence of nodes (it can contain zero,
                  one, or more nodes).</phrase></p>
            <p diff="del" at="C">
               <error spec="XT" type="type" class="TE" code="0520">
                  <p>It is a <termref def="dt-type-error">type error</termref> if the sequence
                     returned by the <code>select</code> expression <error.extra>of
                           <elcode>xsl:apply-templates</elcode>
                     </error.extra> contains an item that is not a node.</p>
               </error>
            </p>
            <note diff="del" at="A">
               <p>In XSLT 1.0, the <code>select</code> attribute selected a set of nodes, which by
                  default were processed in document order. In XSLT 2.0, it selects a sequence of
                  nodes. In cases that would have been valid in XSLT 1.0, the expression will return
                  a sequence of nodes in document order, so the effect is the same.</p>
            </note>
            <example>
               <head>Applying Templates to Selected Nodes</head>
               <p>The following example processes all of the <code>given-name</code> children of the
                     <code>author</code> elements that are children of
                  <code>author-group</code>:</p>
               <eg xml:space="preserve">&lt;xsl:template match="author-group"&gt;
  &lt;fo:wrapper&gt;
    &lt;xsl:apply-templates select="author/given-name"/&gt;
  &lt;/fo:wrapper&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <example>
               <head>Applying Templates to Nodes that are not Descendants</head>
               <p>It is also possible to process elements that are not descendants of the context
                  node. This example assumes that a <code>department</code> element has
                     <code>group</code> children and <code>employee</code> descendants. It finds an
                  employee's department and then processes the <code>group</code> children of the
                     <code>department</code>.</p>
               <eg xml:space="preserve">&lt;xsl:template match="employee"&gt;
  &lt;fo:block&gt;
    Employee &lt;xsl:apply-templates select="name"/&gt; belongs to group
    &lt;xsl:apply-templates select="ancestor::department/group"/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <example>
               <head>Matching Nodes by Schema-Defined Types</head>
               <p>It is possible to write template rules that are matched according to the
                  schema-defined type of an element or attribute. The following example applies
                  different formatting to the children of an element depending on their type:</p>
               <eg xml:space="preserve">&lt;xsl:template match="product"&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/*" priority="3"&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;xsl:value-of select="name()"/&gt;&lt;/td&gt;
    &lt;td&gt;&lt;xsl:next-match/&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/element(*, xs:decimal) | 
                     product/element(*, xs:double)" priority="2"&gt;  
  &lt;xsl:value-of select="format-number(xs:double(.), '#,###0.00')"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/element(*, xs:date)" priority="2"&gt;
  &lt;xsl:value-of select="format-date(., '[Mn] [D], [Y]')"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/*" priority="1.5"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;</eg>
               <p>The <elcode>xsl:next-match</elcode> instruction is described in <specref ref="apply-imports"/>.</p>
            </example>
            <example>
               <head>Re-ordering Elements in the Result Tree</head>
               <p>Multiple <elcode>xsl:apply-templates</elcode> elements can be used within a single
                  template to do simple reordering. The following example creates two HTML tables.
                  The first table is filled with domestic sales while the second table is filled
                  with foreign sales.</p>
               <eg xml:space="preserve">&lt;xsl:template match="product"&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="sales/domestic"/&gt;
  &lt;/table&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="sales/foreign"/&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <example>
               <head>Processing Recursive Structures</head>
               <p>It is possible for there to be two matching descendants where one is a descendant
                  of the other. This case is not treated specially: both descendants will be
                  processed as usual.</p>
               <p> For example, given a source document</p>
               <eg xml:space="preserve">&lt;doc&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/doc&gt;</eg>
               <p>the rule</p>
               <eg xml:space="preserve">&lt;xsl:template match="doc"&gt;
  &lt;xsl:apply-templates select=".//div"/&gt;
&lt;/xsl:template&gt;</eg>
               <p>will process both the outer <code>div</code> and inner <code>div</code>
                  elements.</p>
               <p>This means that if the template rule for the <code>div</code> element processes
                  its own children, then these grandchildren will be processed more than once, which
                  is probably not what is required. The solution is to process one level at a time
                  in a recursive descent, by using <code>select="div"</code> in place of
                     <code>select=".//div"</code>
               </p>
            </example>
            <example diff="add" at="C">
               <head>Applying Templates to Atomic Values</head>
               <p>This example reads a non-XML text file and processes it line-by-line, applying
                  different template rules based on the content of each line:</p>
               <eg xml:space="preserve">&lt;xsl:template name="main"&gt;
  &lt;xsl:apply-templates select="unparsed-text-lines('input.txt')"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="~xs:string[starts-with(., '==')]"&gt;
  &lt;h2&gt;&lt;xsl:value-of select="replace(., '==', '')"/&gt;&lt;/h2&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="~xs:string[starts-with(., '::')]"&gt;
  &lt;p class="indent"&gt;&lt;xsl:value-of select="replace(., '::', '')"/&gt;&lt;/p&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="~xs:string"&gt;
  &lt;p class="body"&gt;&lt;xsl:value-of select="."/&gt;&lt;/p&gt;
&lt;/xsl:template&gt;

</eg>
            </example>
            <note>
               <p>The <elcode>xsl:apply-templates</elcode> instruction is most commonly used to
                  process nodes that are descendants of the context node. Such use of
                     <elcode>xsl:apply-templates</elcode> cannot result in non-terminating
                  processing loops. However, when <elcode>xsl:apply-templates</elcode> is used to
                  process elements that are not descendants of the context node, the possibility
                  arises of non-terminating loops. For example,</p>
               <eg role="error" xml:space="preserve">&lt;xsl:template match="foo"&gt;
  &lt;xsl:apply-templates select="."/&gt;
&lt;/xsl:template&gt;</eg>
               <p>Implementations may be able to detect such loops in some cases, but the
                  possibility exists that a <termref def="dt-stylesheet">stylesheet</termref> may
                  enter a non-terminating loop that an implementation is unable to detect. This may
                  present a denial of service security risk.</p>
            </note>
         </div2>
         <div2 id="conflict">
            <head>Conflict Resolution for Template Rules</head>
            <p>It is possible for <phrase diff="chg" at="C">a selected item</phrase> to match more
               than one <termref def="dt-template-rule">template rule</termref> with a given
                  <termref def="dt-mode">mode</termref>
               <var>M</var>. When this happens, only one template rule is evaluated for the <phrase diff="chg" at="C">item</phrase>. The template rule to be used is determined as
               follows:</p>
            <olist>
               <item>
                  <p>First, only the matching template rule or rules with the highest <termref def="dt-import-precedence">import precedence</termref> are considered. Other
                     matching template rules with lower precedence are eliminated from
                     consideration.</p>
               </item>
               <item>
                  <p>Next, of the remaining matching rules, only those with the highest priority are
                     considered. Other matching template rules with lower priority are eliminated
                     from consideration.</p>
                  <p><termdef term="priority" id="dt-priority">The <term>priority</term> of a
                        template rule is specified by the <code>priority</code> attribute on the
                           <elcode>xsl:template</elcode> declaration. If no priority is specified
                        explicitly for a template rule, its <termref def="dt-default-priority">default priority</termref> is used, as defined in <specref ref="default-priority"/>.</termdef></p>
                  <p>
                     <error spec="XT" type="static" class="SE" code="0530">
                        <p>The value of the <code>priority</code> attribute <error.extra> of the
                                 <elcode>xsl:template</elcode> element</error.extra>
                           <rfc2119>must</rfc2119> conform to the rules for the
                              <code>xs:decimal</code> type defined in <bibref ref="xmlschema-2"/>.
                           Negative values are permitted.</p>
                     </error>
                  </p>

               </item>

               <item diff="add" at="C">
                  <p>If this leaves more than one matching template rule, then:</p>
                  <olist>
                     <item>
                        <p>If the <termref def="dt-mode">mode</termref>
                           <var>M</var> has an <elcode>xsl:mode</elcode> declaration, and the
                           attribute value <code>on-multiple-match="fail"</code> is specified in the
                           mode declaration, a dynamic error is signalled. The error is treated as
                           occurring in the <elcode>xsl:apply-templates</elcode> instruction, and
                           can be recovered by wrapping that instruction in an
                              <elcode>xsl:try</elcode> instruction.</p>
                        <p diff="chg" at="C">
                           <error spec="XT" type="dynamic" class="RE" code="0540">
                              <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable
                                    dynamic error</termref> if the conflict resolution algorithm for
                                 template rules leaves more than one matching template rule <phrase diff="add"> when the declaration of the relevant <termref def="dt-mode">mode</termref> has in
                                       <code>on-multiple-match</code> attribute with the value
                                       <code>fail</code></phrase>.</p>
                           </error></p>
                     </item>
                     <item>
                        <p>Otherwise, of the matching template rules that remain, the one that
                           occurs last in <termref def="dt-declaration-order">declaration
                              order</termref> is used.</p>
                     </item>
                  </olist>

                  <note diff="add" at="C">
                     <p>This was a recoverable error in XSLT 2.0, meaning that it was
                        implementation-defined whether the error was signaled, or whether the
                        ambiguity was resolved by taking the last matching rule in declaration
                        order. The choice of error code reflects this legacy. In XSLT 2.1 this
                        situation is not an error unless the attribute value
                           <code>on-multiple-match="fail"</code> is specified in the mode
                        declaration. It is also possible to request warnings when this condition
                        arises, by means of the attribute 
                        <phrase diff="chg" at="F"><code>warnings-on-multiple-match="yes"</code></phrase>.
                     </p>
                  </note>
                  <issue id="issue-define-warning-codes" status="open"><p>Should we define warning codes in the same way as we define error codes?</p></issue>
               </item>
            </olist>

         </div2>
         <div2 id="default-priority">
            <head>Default Priority for Template Rules</head>
            <p><termdef id="dt-default-priority" term="default priority">If no <code>priority</code>
                  attribute is specified on an <elcode>xsl:template</elcode> element, a
                     <term>default priority</term> is computed, based on the syntax of the <termref def="dt-pattern">pattern</termref> supplied in the <code>match</code>
                  attribute.</termdef> The rules are as follows. </p>
            <olist>
               <item diff="add" at="C">
                  <p>If the top-level pattern consists of multiple alternatives separated by
                        <code>|</code> , then the template rule is treated equivalently to a set of
                     template rules, one for each alternative. However, it is not an error if an
                        <phrase diff="chg" at="C">item</phrase> matches more than one of the
                     alternatives. </p>
               </item>
               <item diff="add" at="C">
                  <p>If the top-level pattern is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PatternTerm" xlink:type="simple">PatternTerm</nt>
                     containing two or more <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-BasicPattern" xlink:type="simple">BasicPatterns</nt> separated
                     by <code>intersect</code> or <code>except</code> operators, then the priority
                     of the pattern is that of the first <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-BasicPattern" xlink:type="simple">BasicPattern</nt>. </p>
               </item>
               <item diff="add" at="C">
                  <p>If the pattern (in its entirety) is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-TypePattern" xlink:type="simple">TypePattern</nt>
                     with an empty <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-PredicateList" xlink:type="simple">PredicateList</xnt>, then:</p>
                  <olist>
                     <item>
                        <p>If the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-ItemType" xlink:type="simple">ItemType</xnt> is
                              <code>item()</code>, the priority is 2 (minus two).</p>
                     </item>
                     <item>
                        <p>If the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-ItemType" xlink:type="simple">ItemType</xnt> is
                              <code>node()</code>, <code>function()</code>, or
                              <code>xs:anyAtomicType</code>, the priority is 1 (minus
                           one).</p>
                     </item>
                     <item>
                        <p>If the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-ItemType" xlink:type="simple">ItemType</xnt> is any
                           other atomic type, the priority is the priority associated with its base
                           type plus 1. This means for example that the priority of
                              <code>~xs:decimal</code> is 0 (zero), and the priority of
                              <code>~xs:integer</code> is +1 (plus one).</p>
                     </item>
                     <item>
                        <p>If the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-ItemType" xlink:type="simple">ItemType</xnt> is any
                           other <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-NodeTest" xlink:type="simple">NodeTest</xnt>, the
                           priority is the same as when that NodeTest appears as a pattern in its
                           own right (see below). For example, the priority of
                              <code>~element()</code> is 0.5 (minus 0.5), while that of
                              <code>~element(E)</code> is 0 (zero).</p>
                     </item>
                     <item>
                        <p>If the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-ItemType" xlink:type="simple">ItemType</xnt> is a
                              <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-TypedFunctionTest" xlink:type="simple">TypedFunctionTest</xnt>, the priority is 0 (zero).</p>
                     </item>
                  </olist>
               </item>
               <item diff="add" at="C">
                  <p>If the pattern (in its entirety) is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-TypePattern" xlink:type="simple">TypePattern</nt>
                     with a non-empty <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-PredicateList" xlink:type="simple">PredicateList</xnt>, then the priority is that of the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-ItemType" xlink:type="simple">ItemType</xnt> in the absence of the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-PredicateList" xlink:type="simple">PredicateList</xnt>, as given
                     above, plus 0.5. So, for example, the priority of the pattern
                        <code>~xs:integer[. gt 0]</code> is +1.5.</p>
               </item>


               <item>
                  <p>If the pattern is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PathPattern" xlink:type="simple">PathPattern</nt> taking the form
                        <code>/</code>, then the priority is 0.5 (minus 0.5).</p>
               </item>
               <item>
                  <p>If the pattern is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PathPattern" xlink:type="simple">PathPattern</nt> taking the form
                     of a <termref def="dt-qname">QName</termref> optionally preceded by a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PatternAxis" xlink:type="simple">PatternAxis</nt> or has the form
                        <code>processing-instruction(</code>
                     <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-StringLiteral" xlink:type="simple">StringLiteral</xnt>
                     <code>)</code> or <code>processing-instruction(</code>
                     <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names" ref="NT-NCName" xlink:type="simple">NCName</xnt>
                     <code>)</code> optionally preceded by a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PatternAxis" xlink:type="simple">PatternAxis</nt>, then the priority is 0 (zero).</p>
               </item>
               <item>
                  <p>If the pattern is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PathPattern" xlink:type="simple">PathPattern</nt> taking the form
                     of an <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-ElementTest" xlink:type="simple">ElementTest</xnt> or <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-AttributeTest" xlink:type="simple">AttributeTest</xnt>, optionally
                     preceded by a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PatternAxis" xlink:type="simple">PatternAxis</nt>, then the priority is
                     as shown in the table below. In this table, the symbols <var>E</var>,
                        <var>A</var>, and <var>T</var> represent an arbitrary element name,
                     attribute name, and type name respectively, while the symbol <code>*</code>
                     represents itself. The presence or absence of the symbol <code>?</code>
                     following a type name does not affect the priority.</p>
                  <table border="1" cellpadding="5">
                     <thead>
                        <tr>
                           <th align="left" rowspan="1" colspan="1">Format</th>
                           <th align="left" rowspan="1" colspan="1">Priority</th>
                           <th align="left" rowspan="1" colspan="1">Notes</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>element()</code>
                           </td>
                           <td rowspan="1" colspan="1">0.5</td>
                           <td rowspan="1" colspan="1">(equivalent to <code>*</code>)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>element(*)</code>
                           </td>
                           <td rowspan="1" colspan="1">0.5</td>
                           <td rowspan="1" colspan="1">(equivalent to <code>*</code>)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>attribute()</code>
                           </td>
                           <td rowspan="1" colspan="1">0.5</td>
                           <td rowspan="1" colspan="1">(equivalent to <code>@*</code>)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>attribute(*)</code>
                           </td>
                           <td rowspan="1" colspan="1">0.5</td>
                           <td rowspan="1" colspan="1">(equivalent to <code>@*</code>)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>element(<var>E</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0</td>
                           <td rowspan="1" colspan="1">(equivalent to E)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>element(*,<var>T</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0</td>
                           <td rowspan="1" colspan="1">(matches by type only)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>attribute(<var>A</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0</td>
                           <td rowspan="1" colspan="1">(equivalent to <code>@A</code>)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>attribute(*,<var>T</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0</td>
                           <td rowspan="1" colspan="1">(matches by type only)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>element(<var>E</var>,<var>T</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0.25</td>
                           <td rowspan="1" colspan="1">(matches by name and type)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>schema-element(<var>E</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0.25</td>
                           <td rowspan="1" colspan="1">(matches by substitution group and type)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>attribute(<var>A</var>,<var>T</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0.25</td>
                           <td rowspan="1" colspan="1">(matches by name and type)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>schema-attribute(<var>A</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0.25</td>
                           <td rowspan="1" colspan="1">(matches by name and type)</td>
                        </tr>
                     </tbody>
                  </table>
               </item>
               <item>
                  <p>If the pattern is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PathPattern" xlink:type="simple">PathPattern</nt> taking the form
                     of a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-DocumentTest" xlink:type="simple">DocumentTest</xnt>, then
                     if it includes no <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-ElementTest" xlink:type="simple">ElementTest</xnt> or <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-SchemaElementTest" xlink:type="simple">SchemaElementTest</xnt> the priority is 0.5. If it does include an
                        <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-ElementTest" xlink:type="simple">ElementTest</xnt> or <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-SchemaElementTest" xlink:type="simple">SchemaElementTest</xnt>,
                     then the priority is the same as the priority of that <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-ElementTest" xlink:type="simple">ElementTest</xnt> or <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-SchemaElementTest" xlink:type="simple">SchemaElementTest</xnt>, computed
                     according to the table above.</p>
               </item>
               <item>
                  <p>If the pattern is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PathPattern" xlink:type="simple">PathPattern</nt> taking the form
                     of an <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names" ref="NT-NCName" xlink:type="simple">NCName</xnt><code>:*</code> or
                        <code>*:</code><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names" ref="NT-NCName" xlink:type="simple">NCName</xnt>, optionally
                     preceded by a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PatternAxis" xlink:type="simple">PatternAxis</nt>, then the priority is
                     0.25.</p>
               </item>
               <item>
                  <p>If the pattern is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PathPattern" xlink:type="simple">PathPattern</nt> taking the form
                     of any other <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-NodeTest" xlink:type="simple">NodeTest</xnt>,
                     optionally preceded by a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PatternAxis" xlink:type="simple">PatternAxis</nt>, then the
                     priority is 0.5.</p>
               </item>
               <item>
                  <p>In all other cases, the priority is +0.5.</p>
               </item>
            </olist>
            <note>
               <p>In many cases this means that highly selective patterns have higher priority than
                  less selective patterns. The most common kind of pattern (a pattern that tests for
                  a node of a particular kind, with a particular <termref def="dt-expanded-qname">expanded-QName</termref> or a particular type) has priority 0. The next less
                  specific kind of pattern (a pattern that tests for a node of a particular kind and
                  an <termref def="dt-expanded-qname">expanded-QName</termref> with a particular
                  namespace URI) has priority 0.25. Patterns less specific than this
                  (patterns that just test for nodes of a given kind) have priority 0.5.
                  Patterns that specify both the name and the required type have a priority of
                  +0.25, putting them above patterns that only specify the name <emph>or</emph> the
                  type. Patterns more specific than this, for example patterns that include
                  predicates or that specify the ancestry of the required node, have priority
                  0.5.</p>
               <p diff="add" at="C">In the case of a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-TypePattern" xlink:type="simple">TypePattern</nt>, the
                  default priority reflects the position of the type in the type hierarchy.</p>
               <p>However, it is not invariably true that a more selective pattern has higher
                  priority than a less selective pattern. For example, the priority of the pattern
                     <code>node()[self::*]</code> is higher than that of the pattern
                     <code>salary</code>. Similarly, the patterns <code>attribute(*,
                     xs:decimal)</code> and <code>attribute(*, xs:short)</code> have the same
                  priority, despite the fact that the latter pattern matches a subset of the nodes
                  matched by the former. Therefore, to achieve clarity in a <termref def="dt-stylesheet">stylesheet</termref> it is good practice to allocate
                  explicit priorities.</p>
            </note>

         </div2>
         <div2 id="modes">
            <head>Modes</head>
            <p>
               <termdef id="dt-mode" term="mode">
                  <term>Modes</term> allow a node in a <termref def="dt-source-tree">source
                     tree</termref> to be processed multiple times, each time producing a different
                  result. They also allow different sets of <termref def="dt-template-rule">template
                     rules</termref> to be active when processing different trees, for example when
                  processing documents loaded using the <function>document</function> function (see
                     <specref ref="document"/>) or when processing <termref def="dt-temporary-tree">temporary trees</termref>.</termdef>
            </p>
            <p diff="add" at="A">Modes are identified by a <termref def="dt-qname">QName</termref>;
               in addition to any named modes, there is always one unnamed mode available. Whether a
               mode is named or unnamed, its properties <rfc2119>may</rfc2119> be defined in an
                  <elcode>xsl:mode</elcode> declaration. If a mode name is used (for example in an
                  <elcode>xsl:template</elcode> declaration or an
                  <elcode>xsl:apply-templates</elcode> instruction) and no declaration of that mode
               appears in the stylesheet, the mode is implicitly declared with default
               properties.</p>
            <div3 diff="add" at="A" id="declaring-modes">
               <head>Declaring Modes</head>
               <p diff="chg" at="C">
                  <e:element-syntax name="mode">
                     <e:in-category name="declaration"/>
                     <e:attribute name="name">
                        <e:data-type name="qname"/>
                     </e:attribute>
                     <e:attribute name="streamable">
                        <e:constant value="yes"/>
                        <e:constant value="no"/>
                     </e:attribute>
                     <e:attribute name="initial">
                        <e:constant value="yes"/>
                        <e:constant value="no"/>
                     </e:attribute>
                     <e:attribute name="on-no-match">
                        <e:constant value="stringify"/>
                        <e:constant value="discard"/>
                        <e:constant value="copy"/>
                        <e:constant value="fail"/>
                     </e:attribute>
                     <e:attribute name="on-multiple-match">
                        <e:constant value="use-last"/>
                        <e:constant value="fail"/>
                     </e:attribute>
                     <e:attribute name="warning-on-no-match">
                        <e:constant value="yes"/>
                        <e:constant value="no"/>
                     </e:attribute>
                     <e:attribute name="warning-on-multiple-match">
                        <e:constant value="yes"/>
                        <e:constant value="no"/>
                     </e:attribute>
                     <e:sequence>
                        <e:element repeat="zero-or-one" name="context-item"/>
                     </e:sequence>
                     <e:allowed-parents>
                        <e:parent name="stylesheet"/>
                        <e:parent name="transform"/>
                     </e:allowed-parents>
                  </e:element-syntax>
               </p>
               <p>
                  <termdef id="dt-unnamed-mode" term="unnamed mode">There is always an <term>unnamed
                        mode</term> available. The unnamed mode is the default mode used when no
                        <code>mode</code> attribute is specified on an
                        <elcode>xsl:apply-templates</elcode> instruction or
                        <elcode>xsl:template</elcode> declaration, unless a different default mode
                     has been specified using the <code>default-mode</code> attribute of the
                     containing <elcode>xsl:stylesheet</elcode> element.</termdef>
               </p>
               <p>Every <termref def="dt-mode">mode</termref> other than the <termref def="dt-unnamed-mode">unnamed mode</termref> is identified by a <termref def="dt-qname">QName</termref>.</p>
               <p>A <termref def="dt-stylesheet">stylesheet</termref> may contain multiple
                     <elcode>xsl:mode</elcode> declarations and may include or import <termref def="dt-stylesheet-module">stylesheet modules</termref> that also contain
                     <elcode>xsl:mode</elcode> declarations. The name of an
                     <elcode>xsl:mode</elcode> declaration is the value of its <code>name</code>
                  attribute, if any.</p>
               <p>
                  <termdef id="dt-mode-definition" term="mode definition">All the
                        <elcode>xsl:mode</elcode> declarations in a stylesheet that share the same
                     name are grouped into a named <term>mode definition</term>; those that have no
                     name are grouped into a single unnamed mode definition.</termdef>
               </p>
               <p>If a <termref def="dt-stylesheet">stylesheet</termref> does not contain a
                  declaration of the unnamed mode, a declaration is implied equivalent to an
                     <elcode>xsl:mode</elcode> element with the single attribute
                     <code>initial="yes"</code>. Similarly, if there is a mode that is named in an
                     <elcode>xsl:template</elcode> or <elcode>xsl:apply-templates</elcode> element,
                  or in the <code>default-mode</code> attribute of an
                     <elcode>xsl:stylesheet</elcode> element, and the <termref def="dt-stylesheet">stylesheet</termref> does not contain a declaration of that mode, then a
                  declaration is implied comprising an <elcode>xsl:mode</elcode> element with a
                     <code>name</code> attribute plus the attribute <code>initial="yes"</code>. </p>
               <p>The contained <elcode>xsl:context-item</elcode> element, if present, is used to
                  declare requirements for the <termref def="dt-initial-context-item"/> when this
                  mode is used as the <termref def="dt-initial-mode"/>. Therefore, there must be no
                     <elcode>xsl:context-item</elcode> child if <code>initial="no"</code> is
                  specified.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0542">
                     <p>It is a <termref def="dt-static-error">static error</termref> if an
                           <elcode>xsl:mode</elcode> declaration specifying
                           <code>initial="no"</code> contains an <elcode>xsl:context-item</elcode>
                        element.</p>
                  </error>
               </p>
               <p>The attributes of the <elcode>xsl:mode</elcode> declaration establish values for a
                  number of properties of a mode. The allowed values and meanings of the attributes
                  are given in the following table.</p>
               <ednote>
                  <edtext>Need to make the formatting of tables more consistent. Also consider
                     whether a tabular style could be more generally used for describing the
                     attributes of particular elements (and consider custom markup for generating
                     the table).</edtext>
               </ednote>

               <table diff="chg" at="C" cellpadding="5" width="100%">
                  <thead>
                     <tr>
                        <th rowspan="1" colspan="1">Attribute</th>
                        <th rowspan="1" colspan="1">Values</th>
                        <th rowspan="1" colspan="1">Meaning</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">name</td>
                        <td valign="top" rowspan="1" colspan="1">A <termref def="dt-lexical-qname">lexical
                           QName</termref></td>
                        <td valign="top" rowspan="1" colspan="1">Specifies the name of the mode. If omitted, this
                              <elcode>xsl:mode</elcode> declaration provides properties of the
                              <termref def="dt-unnamed-mode">unnamed mode</termref></td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">streamable</td>
                        <td valign="top" rowspan="1" colspan="1"><code>yes</code> or <code>no</code> (default
                              <code>no</code>)</td>
                        <td valign="top" rowspan="1" colspan="1">Determines whether template rules in this mode are to be
                           capable of being processed using <termref def="dt-streaming"/>. If the value
                              <code>yes</code> is specified, then the body of any <termref def="dt-template-rule">template rule</termref> that uses this mode
                              <rfc2119>must</rfc2119> conform to the rules for streamable templates
                           given in <specref ref="streamable-templates"/>. </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">initial</td>
                        <td valign="top" rowspan="1" colspan="1"><code>yes</code> or <code>no</code> (default
                              <code>yes</code>)</td>
                        <td valign="top" rowspan="1" colspan="1">Determines whether this mode can be used as the <termref def="dt-initial-mode"/> when the transformation is invoked. If the
                           value <code>yes</code> is specified, or if the attribute is omitted, then
                           the mode is eligible to be used as the <termref def="dt-initial-mode"/>;
                           if the value <code>no</code> is specified then processing in the mode can
                           only be achieved by means of an <elcode>xsl:apply-templates</elcode>
                           instruction within the stylesheet that names this mode.</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">on-no-match</td>
                        <td valign="top" rowspan="1" colspan="1">One of <code>stringify</code>, <code>discard</code>,
                              <code>copy</code>, or <code>fail</code> (default
                              <code>stringify</code>)</td>
                        <td valign="top" rowspan="1" colspan="1">Determines selection of the built-in <termref def="dt-template-rule">template rules</termref> that are used to
                           process a node when an <elcode>xsl:apply-templates</elcode> instruction
                           selects a node that does not match any user-written <termref def="dt-template-rule">template rule</termref> in the <termref def="dt-stylesheet">stylesheet</termref>. For details, see <specref ref="built-in-rule"/>.</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">on-multiple-match</td>
                        <td valign="top" rowspan="1" colspan="1">One of <code>fail</code> or <code>use-last</code> (default
                              <code>use-last</code>)</td>
                        <td valign="top" rowspan="1" colspan="1">Defines the action to be taken when
                              <elcode>xsl:apply-templates</elcode> is used in this mode and more
                           than one user-written <termref def="dt-template-rule">template
                              rule</termref> is available to process the node, having the same
                              <termref def="dt-import-precedence">import precedence</termref> and
                              <termref def="dt-priority">priority</termref>. The value
                              <code>fail</code> indicates that it is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>
                           if more than one template rule matches the node. The value
                              <code>use-last</code> indicates that the situation is not to be
                           treated as an error (the last template in <termref def="dt-declaration-order">declaration order</termref> is the one that
                           is used). </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">warning-on-no-match</td>
                        <td valign="top" rowspan="1" colspan="1">One of <code>yes</code> or <code>no</code>. The default is
                              <termref def="dt-implementation-defined"/></td>
                        <td valign="top" rowspan="1" colspan="1">Requests the <termref def="dt-processor">processor</termref> to output (or not to output) a warning message in
                           the case where an <elcode>xsl:apply-templates</elcode> instruction
                           selects a node that matches no template rule. The form and destination of
                           such warnings is <termref def="dt-implementation-defined">implementation-defined</termref>. The processor
                              <rfc2119>may</rfc2119> ignore this attribute, for example if the
                           environment provides no suitable means of communicating with the
                           user.</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">warning-on-multiple-match</td>
                        <td valign="top" rowspan="1" colspan="1">One of <code>yes</code> or <code>no</code>. The default is
                              <termref def="dt-implementation-defined"/></td>
                        <td valign="top" rowspan="1" colspan="1">Requests the <termref def="dt-processor">processor</termref> to output a warning message in the case where an
                              <elcode>xsl:apply-templates</elcode> instruction selects a node that
                           matches multiple template rules having the same <termref def="dt-import-precedence">import precedence</termref> and <termref def="dt-priority">priority</termref>. The form and destination of such
                           warnings is <termref def="dt-implementation-defined">implementation-defined</termref>. The processor
                              <rfc2119>may</rfc2119> ignore this attribute, for example if the
                           environment provides no suitable means of communicating with the
                           user.</td>
                     </tr>

                  </tbody>

               </table>

               <imp-def-feature>The default values for the <code>warning-on-no-match</code> and
                     <code>warning-on-multiple-match</code> attributes of <elcode>xsl:mode</elcode>
                  are <termref def="dt-implementation-defined"/>.</imp-def-feature>

               <p>
                  <termdef id="dt-streamable-mode" term="streamable mode">A <term>streamable
                        mode</term> is a <termref def="dt-mode">mode</termref> that is declared in
                     an <elcode>xsl:mode</elcode> declaration with the attribute
                        <code>streamable="yes"</code>.</termdef>
               </p>
               <p>For any named <termref def="dt-mode">mode</termref>, the effective value of each
                  attribute is taken from an <elcode>xsl:mode</elcode> declaration that has a
                  matching name in its <code>name</code> attribute, and that specifies an explicit
                  value for the required attribute. If there is more than one such declaration, the
                  one with highest <termref def="dt-import-precedence">import precedence</termref>
                  is used.</p>
               <p>For the <termref def="dt-unnamed-mode">unnamed mode</termref>, the effective value
                  of each attribute is taken from an <elcode>xsl:mode</elcode> declaration that has
                  no <code>name</code> attribute, and that specifies an explicit value for the
                  required attribute. If there is no such declaration, the default value of the
                  attribute is used. If there is more than one such declaration, the one with
                  highest <termref def="dt-import-precedence">import precedence</termref> is
                  used.</p>
               <p>The above rules apply both to the attributes (other than <code>name</code>) of the
                     <elcode>xsl:mode</elcode> element itself, and to the attributes of the
                  contained <elcode>xsl:context-item</elcode> element if present.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0545">
                     <p>It is a <termref def="dt-static-error">static error</termref> if a named or
                        unnamed <termref def="dt-mode">mode</termref> contains two conflicting
                        values for the same attribute in different <elcode>xsl:mode</elcode>
                        declarations having the same <termref def="dt-import-precedence">import
                           precedence</termref>, unless there is another definition of the same
                        attribute with higher import precedence. The attributes in question are the
                        attributes other than <code>name</code> on the <elcode>xsl:mode</elcode>
                        element, and the <code>as</code> attribute on the contained
                           <elcode>xsl:context-item</elcode> element if present.</p>
                  </error>
               </p>
               <p diff="add" at="E">If the <termref def="dt-initial-context-item"/> supplied to a
                  stylesheet is a streamed document node, then it is not permitted for the values of
                  global variables to be dependent on the context item in a way that requires
                  reading of the input stream. This constraint is enforced by the following static
                  rule:</p>

               <p diff="add" at="E"><error spec="XT" type="static" class="SE" code="0548">
                     <p>It is a <termref def="dt-static-error">static error</termref> if there is
                        both (a) a <termref def="dt-mode-definition"/> in the <termref def="dt-stylesheet"/> that has the effective attribute values
                           <code>streamable="yes"</code> and <code>initial="yes"</code>, and (b) a
                           <termref def="dt-global-variable"/> in the <termref def="dt-stylesheet"/>
                        whose initializing expression is not <termref def="dt-motionless"/> with
                        respect to its context item, as defined in <specref ref="streamability"/>.</p>

                  </error></p>
            </div3>
            <div3 diff="chg" at="E" id="initial-context-for-mode">
               <head>Declaring the initial context item for a mode</head>

               <p>Given a <termref def="dt-mode"/> that is used as the <termref def="dt-initial-mode"/>, the <elcode>xsl:context-item</elcode> element may be
                  used to constrain the type of the <phrase diff="chg" at="E"><termref def="dt-initial-context-item"/></phrase> that is supplied by the calling
                  application.</p>
  
               <e:element-syntax name="context-item">
                  <!--<e:attribute name="select">
                     <e:data-type name="expression"/>
                  </e:attribute>-->
                  <e:attribute name="as">
                     <e:data-type name="ItemType"/>
                  </e:attribute>
                  <!--<e:attribute name="use">
                     <e:constant value="required"/>
                     <e:constant value="optional"/>
                     <e:constant value="prohibited"/>
                  </e:attribute>
                  <e:model name="sequence-constructor"/>-->
                  <e:empty/>
                  <e:allowed-parents>
                     <e:parent name="mode"/>
                  </e:allowed-parents>
               </e:element-syntax>


               <!--<p>The <code>use</code> attribute specifies whether an <termref def="dt-initial-context-item"/>
                  may be supplied externally when a transformation is initiated using the mode named in the parent
                  <elcode>xsl:mode</elcode> declaration as the <termref def="dt-initial-mode"/>. 
                  The way in which it is supplied is 
                  <termref def="dt-implementation-defined">implementation-defined</termref>. 
                  The value <code>required</code> indicates that an initial context item <rfc2119>must</rfc2119> 
                  be supplied; the value <code>optional</code>
                  indicates that it <rfc2119>may</rfc2119> be supplied; and the value 
                  <code>prohibited</code> indicates that it <rfc2119>must not</rfc2119> be supplied.</p>
               
               <imp-def-feature>The way in which the <termref def="dt-initial-context-item"/> is supplied is 
                  <termref def="dt-implementation-defined">implementation-defined</termref>.</imp-def-feature>-->

               <p>If the <code>as</code> attribute is present then its value must be an <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-KindTest" xlink:type="simple">ItemType</xnt>. When this mode (the
                  mode defined in the containing <elcode>xsl:mode</elcode> declaration) is used as
                  the <termref def="dt-initial-mode"/>, then an <termref def="dt-initial-context-item"/> must be supplied externally, and its value will
                  be converted to this type using the <termref def="dt-function-conversion-rules"/>;
                  this may result in a <termref def="dt-type-error"/> if the conversion is not
                  possible.</p>

               <p>If the <code>as</code> attribute is omitted this is equivalent to specifying
                     <code>as="item()"</code>.</p>

               <!--<p>If no <termref def="dt-initial-context-item"/> is supplied externally, then the <code>select</code> attribute
                  or the contained <termref def="dt-sequence-constructor"/> is evaluated to determine an initial context item. The value
                  is obtained in the same way as for a <termref def="dt-stylesheet-parameter">stylesheet parameter</termref>, as described in 
                  <specref ref="variable-values"/>. However, if the value is an empty sequence then (regardless of the value of the <code>as</code> attribute),
                  the initial context item is undefined, which means that any reference to the initial context item results in an error.</p>
               
               <p>The <termref def="dt-focus"/> for evaluating the <code>select</code> attribute or <termref def="dt-sequence-constructor"/>
                  is the same as for the equivalent
                  constructs appearing in a <termref def="dt-stylesheet-parameter"/> declaration. 
                  However, as a consequence of the rules in <specref ref="circularity"/>,
                  an error arises if the context item is defined in terms of itself <errorref spec="XT" class="DE" code="0640"/>.</p>
               
               <p>
                  <error spec="XT" type="static" class="SE" code="xxxx">
                     <p>It is a
                        <termref def="dt-static-error">static error</termref> if an
                        <elcode>xsl:context-item</elcode> specifies <code>use="required"</code> and includes
                        a <code>select</code> attribute or a non-empty <termref def="dt-sequence-constructor"/>.</p>
                  </error>
               </p>-->




               <note>
                  <p>If the <code>ItemType</code> is one that can only be satisfied by a
                     schema-validated input document, for example
                        <code>as="schema-element(invoice)"</code>, the <termref def="dt-processor">processor</termref>
                     <rfc2119>may</rfc2119> interpret this as a request to apply schema validation
                     to the input. Similarly, if the <code>KindTest</code> indicates that an element
                     node is required, the processor <rfc2119>may</rfc2119> interpret this as a
                     request to supply the document element rather than the document node of a
                     supplied input document.</p>
               </note>


               <p>If there is no <elcode>xsl:context-item</elcode> element for an
                     <elcode>xsl:mode</elcode> that specifies <code>initial="yes"</code>, this is
                  equivalent to specifying <code>&lt;xsl:context-item as="item()"/&gt;</code></p>

               <!--
               
               <p>
                  <error spec="XT" type="static" class="SE" code="0300">
                     <p>It is a
                        <termref def="dt-static-error">static error</termref> if a
                        <termref def="dt-stylesheet">stylesheet</termref> contains more than one <elcode>xsl:context-item</elcode> declaration with the same
                        <termref def="dt-import-precedence">import precedence</termref>,
                        unless it also contains another <elcode>xsl:context-item</elcode> declaration with higher import precedence.</p>
                  </error>
               </p>-->

               <p diff="add" at="D">A <termref def="dt-type-error"/> is signalled if the supplied
                  context item does not match its required type. The error codes is the same as for
                     <elcode>xsl:param</elcode>
                  <errorref spec="XT" class="TE" code="0590"/>.</p>


               <example>
                  <head>Declaring the Required Context Item</head>
                  <p>The following example declares two modes, both of which have
                        <code>initial="yes"</code> meaning that they can be used as entry points to
                     the stylesheet. In the first mode, named <code>invoice</code>, the required
                     context item is a schema-validated <code>invoice</code> element. In the second
                     mode, named <code>po</code>, the required context item is a schema-validated
                        <code>purchase-order</code> element. A third mode,
                        <code>format-address</code> is declared with <code>initial="no"</code> so it
                     cannot be used as an initial entry point; this mode might be used when
                     processing content that is common to invoices and purchase orders.</p>

                  <eg xml:space="preserve">&lt;xsl:mode name="invoice" initial="yes" on-no-match="copy"&gt;
  &lt;xsl:context-item as="schema-element(invoice)"&gt;
&lt;/xsl:mode&gt;
&lt;xsl:mode name="po" initial="yes" on-no-match="copy"&gt;
  &lt;xsl:context-item as="schema-element(purchase-order)"&gt;
&lt;/xsl:mode&gt;
&lt;xsl:mode name="format-address" initial="no"/&gt;</eg>

               </example>

               <issue id="issue-declaring-context-item-for-initial-template" status="open">
                  <p>It would also be useful to be able to declare the required type of the context
                     item (or to say that there is none) when starting the transformation with an
                        <termref def="dt-initial-template">initial named template</termref></p>
               </issue>

            </div3>
            <div3 id="using-modes">
               <head>Using Modes</head>
               <p>A <termref def="dt-template-rule">template rule</termref> is applicable to one or
                  more modes. The modes to which it is applicable are defined by the
                     <code>mode</code> attribute of the <elcode>xsl:template</elcode> element. If
                  the attribute is omitted, then the template rule is applicable to the <phrase diff="chg" at="A">default mode specified in the <code>default-mode</code>
                     attribute of the containing <elcode>xsl:stylesheet</elcode> element, which in
                     turn defaults to the <termref def="dt-unnamed-mode">unnamed
                     mode</termref>.</phrase> If the <code>mode</code> attribute is present, then
                  its value <rfc2119>must</rfc2119> be a non-empty whitespace-separated list of
                  tokens, each of which defines a mode to which the template rule is applicable.
                  Each token <rfc2119>must</rfc2119> be one of the following:</p>
               <ulist>
                  <item>
                     <p>a <termref def="dt-qname">QName</termref>, which is expanded as described in
                           <specref ref="qname"/> to define the name of the mode</p>
                  </item>
                  <item>
                     <p>the token <code>#default</code>, to indicate that the template rule is
                        applicable to the <phrase diff="chg" at="A">default mode for the stylesheet
                           module</phrase>
                     </p>
                  </item>
                  <item>
                     <p diff="add" at="A">the token <code>#unnamed</code>, to indicate that the
                        template rule is applicable to the <termref def="dt-unnamed-mode">unnamed
                           mode</termref>
                     </p>
                  </item>
                  <item>
                     <p>the token <code>#all</code>, to indicate that the template rule is
                        applicable to all modes (specifically, to the <phrase diff="chg" at="D">unnamed</phrase> mode and to every mode that is named <phrase diff="add" at="D">explicitly or implicitly</phrase> in an
                           <elcode>xsl:apply-templates</elcode> instruction <phrase diff="del">or
                              <elcode>xsl:template</elcode> declaration</phrase> anywhere in the
                        stylesheet).</p>
                  </item>
               </ulist>
               <p>
                  <error spec="XT" type="static" class="SE" code="0550">
                     <p>It is a <termref def="dt-static-error">static error</termref> if the list
                           <error.extra>of modes in the <code>mode</code> attribute of
                              <elcode>xsl:template</elcode>
                        </error.extra> is empty, if the same token is included more than once in the
                        list, if the list contains an invalid token, or if the token
                           <code>#all</code> appears together with any other value.</p>
                  </error>
               </p>
               <p>The <elcode>xsl:apply-templates</elcode> element also has an optional
                     <code>mode</code> attribute. The value of this attribute
                     <rfc2119>must</rfc2119> be one of the following:</p>
               <ulist>
                  <item>
                     <p>a <termref def="dt-qname">QName</termref>, which is expanded as described in
                           <specref ref="qname"/> to define the name of a mode</p>
                  </item>
                  <item>
                     <p>the token <code>#default</code>, to indicate that the default mode <phrase diff="add" at="A">for the <termref def="dt-stylesheet-module">stylesheet
                              module</termref>
                        </phrase> is to be used</p>
                  </item>
                  <item>
                     <p diff="add" at="A">the token <code>#unnamed</code>, to indicate that the
                           <termref def="dt-unnamed-mode">unnamed mode</termref> is to be used</p>
                  </item>
                  <item>
                     <p>the token <code>#current</code>, to indicate that the <termref def="dt-current-mode">current mode</termref> is to be used</p>
                  </item>
               </ulist>

               <p>If the attribute is omitted, the default mode <phrase diff="add" at="A">for the
                        <termref def="dt-stylesheet-module">stylesheet module</termref>
                  </phrase> is used.</p>
               <p>When searching for a template rule to process each <phrase diff="chg" at="C">item</phrase> selected by the <elcode>xsl:apply-templates</elcode>
                  instruction, only those template rules that are applicable to the selected mode
                  are considered.</p>
               <!--Text replaced by erratum E19 change 2"-->
               <p>
                  <termdef id="dt-current-mode" term="current mode">At any point in the processing
                     of a stylesheet, there is a <term>current mode</term>. When the transformation
                     is initiated, the current mode is the <phrase diff="chg" at="E"><termref def="dt-initial-mode"/></phrase>, as described in <specref ref="initiating"/>. Whenever an <elcode>xsl:apply-templates</elcode>
                     instruction is evaluated, the current mode becomes the mode selected by this
                     instruction.</termdef> When a stylesheet function is called, the current mode
                  is set to the <termref def="dt-unnamed-mode">unnamed mode</termref>. While
                  evaluating global variables and parameters, and the sequence constructor contained
                  in <elcode>xsl:key</elcode> or <elcode>xsl:sort</elcode>, the current mode is set
                  to the unnamed mode. No other instruction changes the current mode. The current
                  mode while evaluating an <termref def="dt-attribute-set">attribute set</termref>
                  is the same as the current mode of the caller. On completion of the
                     <elcode>xsl:apply-templates</elcode> instruction, or on return from a
                  stylesheet function call, the current mode reverts to its previous value. The
                  current mode is used when an <elcode>xsl:apply-templates</elcode> instruction uses
                  the syntax <code>mode="#current"</code>; it is also used by the
                     <elcode>xsl:apply-imports</elcode> and <elcode>xsl:next-match</elcode>
                  instructions (see <specref ref="apply-imports"/>).</p>
            </div3>
            <!--End of text replaced by erratum E19-->
         </div2>
         <div2 id="built-in-rule">
            <head>Built-in Template Rules</head>
            <p diff="chg" at="C">When a node is selected by <elcode>xsl:apply-templates</elcode> and
               there is no user-specified <termref def="dt-template-rule">template rule</termref> in
               the <termref def="dt-stylesheet">stylesheet</termref> that can be used to process
               that node, then a built-in template rule is evaluated instead. </p>
            <p>The built-in <termref def="dt-template-rule">template rules</termref> have lower
                  <termref def="dt-import-precedence">import precedence</termref> than all other
               template rules. Thus, the stylesheet author can override a built-in template rule by
               including an explicit template rule.</p>
            <p diff="chg" at="C">There are four sets of built-in template rules available. The set
               that is chosen is a property of the <termref def="dt-mode">mode</termref> selected by
               the <elcode>xsl:apply-templates</elcode> instruction. This property is set using the
                  <code>on-no-match</code> attribute of the <elcode>xsl:mode</elcode> declaration,
               which takes one of the four values <code>stringify</code>, <code>copy</code>,
                  <code>discard</code>, or <code>fail</code>, the default being
                  <code>stringify</code>. The effect of these four sets of built-in template rules
               is explained in the following subsections.</p>
            <div3 id="built-in-templates-stringify">
               <head>Built-in Templates: stringify</head>
               <p diff="chg" at="C">The general effect of choosing
                     <code>on-no-match="stringify"</code> for a <termref def="dt-mode">mode</termref> is to retain the textual content of the source document while
                  losing the markup. When an element is encountered for which there is no explicit
                     <termref def="dt-template-rule">template rule</termref>, the processing
                  continues with the children of that element. Text nodes are copied to the
                  output.</p>
               <p>The built-in rule for document nodes and element nodes is equivalent to calling
                     <elcode>xsl:apply-templates</elcode> with no <code>select</code> attribute, and
                  with the <code>mode</code> attribute set to <code>#current</code>. If the built-in
                  rule was invoked with parameters, those parameters are passed on in the implicit
                     <elcode>xsl:apply-templates</elcode> instruction.</p>

               <p>The built-in <termref def="dt-template-rule">template rule</termref> for text and
                  attribute nodes <phrase diff="add" at="C">and atomic values</phrase> returns a
                  text node containing the <termref def="dt-string-value">string value</termref> of
                  the context node. It is effectively:</p>
               <eg xml:space="preserve">&lt;xsl:template match="text()|@*|xs:anyAtomicType" mode="M"&gt;
  &lt;xsl:value-of select="string(.)"/&gt;
&lt;/xsl:template&gt;</eg>
               <note>
                  <p>This text node may have a string value that is zero-length.</p>
               </note>
               <p diff="chg" at="C">The built-in <termref def="dt-template-rule">template
                     rule</termref> for processing instructions, comments, namespace nodes, and
                  function items does nothing (it returns the empty sequence).</p>
               <eg xml:space="preserve">&lt;xsl:template 
   match="processing-instruction()|comment()|namespace-node()|function()" 
   mode="M"/&gt;</eg>
               <p diff="del" at="C">The built-in <termref def="dt-template-rule">template
                     rule</termref> for namespace nodes is also to do nothing. There is no pattern
                  that can match a namespace node, so the built-in template rule is always used when
                     <elcode>xsl:apply-templates</elcode> selects a namespace node.</p>
               <example>
                  <head>Using a Built-In Template Rule</head>
                  <p>Suppose the stylesheet contains the following instruction:</p>
                  <eg xml:space="preserve">&lt;xsl:apply-templates select="title" mode="M"&gt;
  &lt;xsl:with-param name="init" select="10"/&gt;
&lt;/xsl:apply-templates&gt;</eg>
                  <p>If there is no explicit template rule that matches the <code>title</code>
                     element, then the following implicit rule is used:</p>
                  <eg xml:space="preserve">&lt;xsl:template match="title" mode="M"&gt;
  &lt;xsl:param name="init"/&gt;
  &lt;xsl:apply-templates mode="#current"&gt;
    &lt;xsl:with-param name="init" select="$init"/&gt;
  &lt;/xsl:apply-templates&gt;
&lt;/xsl:template&gt;</eg>
               </example>
            </div3>
            <div3 id="built-in-templates-discard" diff="add" at="C">
               <head>Built-in Templates: discard</head>
               <p diff="add" at="E">The general effect of choosing
                     <code>on-no-match="discard"</code> for a <termref def="dt-mode">mode</termref>
                  is to omit both the text and the markup from the result document, except in the
                  case of items that are matched by explicit user-written <termref def="dt-template-rule">template rules</termref>.</p>

               <p>The built-in rule for document nodes and element nodes is the same as for
                     <code>on-no-match="stringify"</code>: that is, it is equivalent to calling
                     <elcode>xsl:apply-templates</elcode> with no <code>select</code> attribute, and
                  with the <code>mode</code> attribute set to <code>#current</code>. If the built-in
                  rule was invoked with parameters, those parameters are passed on in the implicit
                     <elcode>xsl:apply-templates</elcode> instruction.</p>

               <p>The built-in template rule for all other kinds of node, and for atomic values and
                  function items, is empty: that is, when the item is matched, the built-in template
                  rule returns an empty sequence.</p>



            </div3>
            <div3 id="built-in-templates-copy" diff="add" at="C">
               <head>Built-in Templates: copy</head>
               <p>The general effect of choosing <code>on-no-match="copy"</code> for a <termref def="dt-mode">mode</termref> is that the source tree is copied unchanged to the
                  output, except for nodes where different processing is specified using an explicit
                     <termref def="dt-template-rule">template rule</termref>.</p>
               <p>When this default action is selected for a mode <var>M</var>, all items are
                  processed using a template rule that is equivalent to the following, except that
                  all parameters supplied in <elcode>xsl:with-param</elcode> elements are passed on
                  implicitly to the called templates:</p>
               <eg xml:space="preserve">&lt;xsl:template match="~item()" mode="M"&gt;
  &lt;xsl:copy validation="preserve"&gt;
    &lt;xsl:apply-templates select="@*" mode="M"/&gt;
    &lt;xsl:apply-templates select="node()" mode="M"/&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;</eg>
               <p>This rule is often referred to as the <emph>identity template</emph>, though it
                  should be noted that it does not preserve node identity.</p>
               <note>
                  <p>This rule differs from the "traditional" identity template rule by using two
                        <elcode>xsl:apply-templates</elcode> instructions, one to process the
                     attributes and one to process the children. The only observable difference is
                     that with two separate instructions, the value of <code>position()</code> in
                     the called templates forms one sequence starting at 1 for the attributes, and a
                     new sequence starting at 1 for the children.</p>
               </note>
               <example>
                  <head>Modified Identity Transformation</head>
                  <p>The following stylesheet transforms an input document by deleting all elements
                     named <code>note</code>, together with their attributes and descendants:</p>
                  <eg xml:space="preserve">&lt;xsl:stylesheet version="2.1"
     xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
				  
&lt;xsl:mode on-no-match="copy" streamable="yes"/&gt;

&lt;xsl:template match="note"&gt;
  &lt;!-- no action --&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg>
               </example>

            </div3>
            <div3 id="built-in-templates-fail" diff="add" at="E">
               <head>Built-in Templates: fail</head>
               <p diff="add" at="E">The general effect of choosing <code>on-no-match="fail"</code>
                  for a <termref def="dt-mode">mode</termref> is that every node selected in an
                     <elcode>xsl:apply-templates</elcode> instruction must be matched by an explicit
                  user-written <termref def="dt-template-rule">template rules</termref>.</p>
               <p>The built-in template rule is effectively: </p>
               <eg xml:space="preserve">&lt;xsl:template match="~item()" mode="M"&gt;
  &lt;xsl:message error-code="err:XTDE0555"/&gt;
&lt;/xsl:template&gt;</eg>
               <p>with an <termref def="dt-implementation-dependent"/> message body.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="0555">
                     <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                           error</termref> if <elcode>xsl:apply-templates</elcode>,
                           <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode> is
                        used to process a node using a mode whose declaration specifies
                           <code>on-no-match="fail"</code> when there is no <termref def="dt-template-rule"/> in the <termref def="dt-stylesheet"/> whose
                        match pattern matches that node. </p>
                  </error>
               </p>
            </div3>
         </div2>
         <div2 id="apply-imports">
            <head>Overriding Template Rules</head>
            <e:element-syntax name="apply-imports">
               <e:in-category name="instruction"/>
               <e:element name="with-param" repeat="zero-or-more"/>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <e:element-syntax name="next-match">
               <e:in-category name="instruction"/>
               <e:choice repeat="zero-or-more">
                  <e:element name="with-param"/>
                  <e:element name="fallback"/>
               </e:choice>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>A <termref def="dt-template-rule">template rule</termref> that is being used to
               override another template rule (see <specref ref="conflict"/>) can use the
                  <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode> instruction
               to invoke the overridden template rule. The <elcode>xsl:apply-imports</elcode>
               instruction only considers template rules in imported stylesheet modules; the
                  <elcode>xsl:next-match</elcode> instruction considers all other template rules of
               lower <termref def="dt-import-precedence">import precedence</termref> and/or
               priority. Both instructions will invoke the built-in template rule for the <phrase diff="chg" at="C">context item</phrase> (see <specref ref="built-in-rule"/>) if no
               other template rule is found.</p>
            <p>
               <termdef id="dt-current-template-rule" term="current template rule">At any point in
                  the processing of a <termref def="dt-stylesheet">stylesheet</termref>, there may
                  be a <term>current template rule</term>. Whenever a <termref def="dt-template-rule">template rule</termref> is chosen as a result of
                  evaluating <elcode>xsl:apply-templates</elcode>,
                     <elcode>xsl:apply-imports</elcode>, or <elcode>xsl:next-match</elcode>, the
                  template rule becomes the current template rule for the evaluation of the rule's
                  sequence constructor. When an <elcode>xsl:for-each</elcode>,
                     <elcode>xsl:for-each-group</elcode>, <elcode>xsl:analyze-string</elcode>,
                  <phrase diff="add" at="F"><elcode>xsl:iterate</elcode>, <elcode>xsl:stream</elcode>,
                  <elcode>xsl:merge</elcode>, or <elcode>xsl:evaluate</elcode></phrase>
                  instruction is evaluated, or when evaluating a sequence constructor contained in
                  an <elcode>xsl:sort</elcode> or <elcode>xsl:key</elcode> element, or when a
                     <termref def="dt-stylesheet-function">stylesheet function</termref> is called
                  (see <specref ref="stylesheet-functions"/>), the current template rule becomes
                  null for the evaluation of that instruction or function.</termdef>
            </p>
            <p>The current template rule is not affected by invoking named templates (see <specref ref="named-templates"/>) or named attribute sets (see <specref ref="attribute-sets"/>). While evaluating a <termref def="dt-global-variable">global variable</termref> or the default value of a <termref def="dt-stylesheet-parameter">stylesheet parameter</termref> (see <specref ref="global-variables"/>) the current template rule is null.</p>
            <note>
               <p>These rules ensure that when <elcode>xsl:apply-imports</elcode> or
                     <elcode>xsl:next-match</elcode> is called, the <termref def="dt-context-item">context item</termref> is the same as when the current template rule was
                     invoked<phrase diff="del" at="C">, and is always a node</phrase>.</p>
            </note>
            <p> Both <elcode>xsl:apply-imports</elcode> and <elcode>xsl:next-match</elcode> search
               for a <termref def="dt-template-rule">template rule</termref> that matches the
                  <phrase diff="chg" at="C"><termref def="dt-context-item">context
                  item</termref></phrase>, and that is applicable to the <termref def="dt-current-mode">current mode</termref> (see <specref ref="modes"/>). In
               choosing a template rule, they use the usual criteria such as the priority and
                  <termref def="dt-import-precedence">import precedence</termref> of the template
               rules, but they consider as candidates only a subset of the template rules in the
                  <termref def="dt-stylesheet">stylesheet</termref>. This subset differs between the
               two instructions:</p>
            <ulist>
               <item>
                  <p>The <elcode>xsl:apply-imports</elcode> instruction considers as candidates only
                     those template rules contained in <termref def="dt-stylesheet-level">stylesheet
                        levels</termref> that are descendants in the <termref def="dt-import-tree">import tree</termref> of the <termref def="dt-stylesheet-level">stylesheet
                        level</termref> that contains the <termref def="dt-current-template-rule">current template rule</termref>.</p>
                  <note>
                     <p>This is <emph>not</emph> the same as saying that the search considers all
                        template rules whose import precedence is lower than that of the current
                        template rule.</p>
                  </note>
               </item>
               <item>
                  <p>The <elcode>xsl:next-match</elcode> instruction considers as candidates all
                     those template rules that come after the <termref def="dt-current-template-rule">current template rule</termref> in the
                     ordering of template rules implied by the conflict resolution rules given in
                        <specref ref="conflict"/>. That is, it considers all template rules with
                     lower <termref def="dt-import-precedence">import precedence</termref> than the
                        <termref def="dt-current-template-rule">current template rule</termref>,
                     plus the template rules that are at the same import precedence that have lower
                     priority than the current template rule, <phrase diff="chg" at="D">plus
                        the</phrase> template rules with the same import precedence and priority
                     that occur before the current template rule in <termref def="dt-declaration-order">declaration order</termref>.</p>
                  <note>
                     <p>As explained in <specref ref="conflict"/>, a template rule whose match
                        pattern contains multiple alternatives separated by <code>|</code> is
                        treated equivalently to a set of template rules, one for each alternative.
                        This means that where the same <phrase diff="chg" at="C">item</phrase>
                        matches more than one alternative, and the alternatives have different
                        priority, it is possible for an <elcode>xsl:next-match</elcode> instruction
                        to cause the current template rule to be invoked recursively. This situation
                        does not occur when the alternatives have the same priority.</p>
                  </note>
               </item>
            </ulist>
            <p>If no matching template rule is found that satisfies these criteria, the built-in
               template rule for the <phrase diff="chg" at="C">context item</phrase> is used (see
                  <specref ref="built-in-rule"/>).</p>
            <p>An <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode> instruction
               may use <elcode>xsl:with-param</elcode> child elements to pass parameters to the
               chosen <termref def="dt-template-rule">template rule</termref> (see <specref ref="with-param"/>). It also passes on any <termref def="dt-tunnel-parameter">tunnel parameters</termref> as described in <specref ref="tunnel-params"/>.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0560">
                  <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if <elcode>xsl:apply-imports</elcode> or
                        <elcode>xsl:next-match</elcode> is evaluated when the <termref def="dt-current-template-rule">current template rule</termref> is null.</p>
               </error>
            </p>
            <example>
               <head>Using <code>xsl:apply-imports</code>
               </head>
               <p>For example, suppose the stylesheet <code>doc.xsl</code> contains a <termref def="dt-template-rule">template rule</termref> for <code>example</code>
                  elements:</p>
               <eg xml:space="preserve">&lt;xsl:template match="example"&gt;
  &lt;pre&gt;&lt;xsl:apply-templates/&gt;&lt;/pre&gt;
&lt;/xsl:template&gt;</eg>
               <p>Another stylesheet could import <code>doc.xsl</code> and modify the treatment of
                     <code>example</code> elements as follows:</p>
               <eg xml:space="preserve">&lt;xsl:import href="doc.xsl"/&gt;

&lt;xsl:template match="example"&gt;
  &lt;div style="border: solid red"&gt;
     &lt;xsl:apply-imports/&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;</eg>
               <p>The combined effect would be to transform an <code>example</code> into an element
                  of the form:</p>
               <eg xml:space="preserve">&lt;div style="border: solid red"&gt;&lt;pre&gt;...&lt;/pre&gt;&lt;/div&gt;</eg>
            </example>
            <p>An <elcode>xsl:fallback</elcode> instruction appearing as a child of an
                  <elcode>xsl:next-match</elcode> instruction is ignored by an XSLT 2.0 <phrase diff="chg" at="A">or 2.1</phrase> processor, but can be used to define fallback
               behavior when the stylesheet is processed by an XSLT 1.0 processor with
               forwards compatible behavior.</p>
         </div2>
         <div2 id="parameters-to-template-rules" diff="add" at="D">
            <head>Passing Parameters to Template Rules</head>
            <p>A template rule may have parameters. The parameters are declared in the body of the
               template using <elcode>xsl:param</elcode> elements, as described in <specref ref="parameters"/>.</p>

            <p>Values for these parameters may be supplied in the calling
                  <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>, or
                  <elcode>xsl:next-match</elcode> instruction by means of
                  <elcode>xsl:with-param</elcode> elements appearing as children of the calling
               instruction. The <termref def="dt-expanded-qname">expanded QName</termref>
               represented by the <code>name</code> attribute of the <elcode>xsl:with-param</elcode>
               element must match the <termref def="dt-expanded-qname">expanded QName</termref>
               represented by the <code>name</code> attribute of the corresponding
                  <elcode>xsl:param</elcode> element. </p>

            <p>
               <error spec="XT" type="dynamic" class="DE" code="0700">
                  <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if a template that is invoked using
                        <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>, or
                        <elcode>xsl:next-match</elcode> declares a <termref def="dt-template-parameter">template parameter</termref> with
                        <code>required="yes"</code> and no value for this parameter is supplied by
                     the calling instruction. </p>
                  <p>The same error is reported in the case of a <termref def="dt-tunnel-parameter">tunnel parameter</termref> whether invoked using one of these three
                     instructions or by <elcode>xsl:call-template</elcode>, as explained in <specref ref="tunnel-params"/>.</p>
               </error>
            </p>

            <p>It is not an error for these instructions to supply a parameter that does not match
               any parameter declared in the template rule that is invoked; unneeded parameter
               values are simply ignored.</p>

            <p>A parameter may be declared as a <termref def="dt-tunnel-parameter">tunnel
                  parameter</termref> by specifying <code>tunnel="yes"</code> in the
                  <elcode>xsl:param</elcode> declaration; in this case the caller must supply the
               value as a tunnel parameter by specifying <code>tunnel="yes"</code> in the
               corresponding <elcode>xsl:with-param</elcode> element. Tunnel parameters differ from
               ordinary template parameters in that they are passed transparently through multiple
               template invocations. They are fully described in <specref ref="tunnel-params"/>.</p>

         </div2>
      </div1>
      <div1 id="repetition">
         <head>Repetition</head>
         <p diff="add" at="A">XSLT offers two constructs for processing each item of a sequence:
               <elcode>xsl:for-each</elcode> and <elcode>xsl:iterate</elcode>.</p>
         <p diff="add" at="A">The main difference between the two constructs is that with
               <elcode>xsl:for-each</elcode>, the processing applied to each item in the sequence is
            independent of the processing applied to any other item; this means that the items may
            be processed in any order or in parallel, though the order of the output sequence is
            well defined and corresponds to the order of the input (sorted if so requested). By
            contrast, with <elcode>xsl:iterate</elcode>, the processing is explicitly sequential:
            while one item is being processed, values may be computed which are then available for
            use while the next item is being processed. This makes <elcode>xsl:iterate</elcode>
            suitable for tasks such as creating a running total over a sequence of financial
            transactions.</p>
         <p diff="add" at="A">A further difference is that <elcode>xsl:for-each</elcode> permits
            sorting of the input sequence, while <elcode>xsl:iterate</elcode> does not.</p>
         <div2 id="for-each">
            <head>The <code>xsl:for-each</code> instruction</head>
            <e:element-syntax name="for-each">
               <e:in-category name="instruction"/>
               <e:attribute name="select" required="yes">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:sequence>
                  <e:element repeat="zero-or-more" name="sort"/>
                  <e:model name="sequence-constructor"/>
               </e:sequence>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:for-each</elcode> instruction processes each item in a sequence of
               items, evaluating the <termref def="dt-sequence-constructor">sequence
                  constructor</termref> within the <elcode>xsl:for-each</elcode> instruction once
               for each item in that sequence.</p>
            <p> The <code>select</code> attribute is <rfc2119>required</rfc2119>; it contains an
                  <termref def="dt-expression">expression</termref> which is evaluated to produce a
               sequence, called the input sequence. If there is an <elcode>xsl:sort</elcode> element
               present (see <specref ref="sorting"/>) the input sequence is sorted to produce a
               sorted sequence. Otherwise, the sorted sequence is the same as the input
               sequence.</p>
            <p>The <elcode>xsl:for-each</elcode> instruction contains a <termref def="dt-sequence-constructor">sequence constructor</termref>. The <termref def="dt-sequence-constructor">sequence constructor</termref> is evaluated once for
               each item in the sorted sequence, with the <termref def="dt-focus">focus</termref>
               set as follows:</p>
            <ulist>
               <item>
                  <p>The <termref def="dt-context-item">context item</termref> is the item being
                     processed. <phrase diff="del" at="D">If this is a node, it will also be the
                           <termref def="dt-context-node">context node</termref>. If it is not a
                        node, there will be no context node: that is, any attempt to reference the
                        context node will result in a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>.</phrase>
                  </p>
               </item>
               <item>
                  <p>The <termref def="dt-context-position">context position</termref> is the
                     position of this item in the sorted sequence.</p>
               </item>
               <item>
                  <p>The <termref def="dt-context-size">context size</termref> is the size of the
                     sorted sequence (which is the same as the size of the input sequence).</p>
               </item>
            </ulist>
            <p> For each item in the input sequence, evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref> produces a sequence
               of items (see <specref ref="sequence-constructors"/>). These output sequences are
               concatenated; if item <var>Q</var> follows item <var>P</var> in the sorted sequence,
               then the result of evaluating the sequence constructor with <var>Q</var> as the
               context item is concatenated after the result of evaluating the sequence constructor
               with <var>P</var> as the context item. The result of the
                  <elcode>xsl:for-each</elcode> instruction is the concatenated sequence of
               items.</p>
            <example>
               <head>Using <code>xsl:for-each</code>
               </head>
               <p>For example, given an XML document with this structure</p>
               <eg xml:space="preserve">&lt;customers&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
&lt;/customers&gt;</eg>
               <p>the following would create an HTML document containing a table with a row for each
                     <code>customer</code> element</p>
               <eg xml:space="preserve">&lt;xsl:template match="/"&gt;
  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;Customers&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;table&gt;
	&lt;tbody&gt;
	  &lt;xsl:for-each select="customers/customer"&gt;
	    &lt;tr&gt;
	      &lt;th&gt;
		&lt;xsl:apply-templates select="name"/&gt;
	      &lt;/th&gt;
	      &lt;xsl:for-each select="order"&gt;
		&lt;td&gt;
		  &lt;xsl:apply-templates/&gt;
		&lt;/td&gt;
	      &lt;/xsl:for-each&gt;
	    &lt;/tr&gt;
	  &lt;/xsl:for-each&gt;
	&lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;</eg>
            </example>
         </div2>
         <div2 id="iterate" diff="add" at="A">
            <head>The <code>xsl:iterate</code> instruction</head>
            <e:element-syntax name="iterate">
               <e:in-category name="instruction"/>
               <e:attribute name="select" required="yes">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:sequence>
                  <e:element repeat="zero-or-more" name="param"/>
                  <e:model name="sequence-constructor"/>
                  <e:element repeat="zero-or-one" name="on-completion"/>
               </e:sequence>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <e:element-syntax name="next-iteration">
               <e:in-category name="instruction"/>
               <e:sequence>
                  <e:element repeat="zero-or-more" name="with-param"/>
               </e:sequence>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <e:element-syntax name="break">
               <e:in-category name="instruction"/>
               <e:sequence>
                  <e:model name="sequence-constructor"/>
               </e:sequence>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <e:element-syntax name="on-completion">
               <e:sequence>
                  <e:model name="sequence-constructor"/>
               </e:sequence>
               <e:allowed-parents>
                  <e:parent name="iterate"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <code>select</code> attribute is <rfc2119>required</rfc2119>; it contains an
                  <termref def="dt-expression">expression</termref> which is evaluated to produce a
               sequence, called the input sequence.</p>
            <p>The <termref def="dt-sequence-constructor">sequence constructor</termref> contained
               in the <elcode>xsl:iterate</elcode> instruction is evaluated once for each item in
               the input sequence, in order, or until the loop exits by evaluating an
                  <elcode>xsl:break</elcode> instruction, whichever is earlier. Within the <termref def="dt-sequence-constructor">sequence constructor</termref> that forms the body
               of the <elcode>xsl:iterate</elcode> instruction, the <termref def="dt-context-item">context item</termref> is set to each item from the value of the
                  <code>select</code> expression in turn; the <termref def="dt-context-position">context position</termref> reflects the position of this item in the input
               sequence, and the <termref def="dt-context-size">context size</termref> is the number
               of items in the input sequence (which may be greater than the number of iterations,
               if the loop exits prematurely using <elcode>xsl:break</elcode>).</p>
            <note>
               <p>If <elcode>xsl:iterate</elcode> is used in conjunction with
                     <elcode>xsl:stream</elcode> to achieve streaming, calls on the
                  function <xfunction>last</xfunction> will be disallowed.
                  <!--However, the function <function>is-last</function>
               can be used to test whether the current item is the last in the sequence.--></p>
            </note>

            <p>The effect of <elcode>xsl:next-iteration</elcode> is to cause the iteration to
               continue by processing the next item in the input sequence, potentially with
               different values for the iteration parameters. The effect of
                  <elcode>xsl:break</elcode> is to cause the iteration to finish, whether or not all
               the items in the input sequence have been processed. In both cases the affected
               iteration is the one controlled by the innermost ancestor
                  <elcode>xsl:iterate</elcode> element.</p>
            <p>The instructions <elcode>xsl:next-iteration</elcode> and <elcode>xsl:break</elcode>
               are allowed only as descendants of an <elcode>xsl:iterate</elcode> instruction, and
               only in a <termref def="dt-tail-position">tail position</termref> within the <termref def="dt-sequence-constructor">sequence constructor</termref> forming the body of
               the <elcode>xsl:iterate</elcode> instruction. </p>

            <p>
               <termdef id="dt-tail-position" term="tail position">An <termref def="dt-instruction">instruction</termref>
                  <var>J</var> is in a <term>tail position</term> within a <termref def="dt-sequence-constructor">sequence constructor</termref>
                  <var>SC</var> if it satisfies one of the following conditions:</termdef></p>

            <ulist>
               <item>
                  <p><var>J</var> is the last instruction in <var>SC</var>, ignoring any
                        <elcode>xsl:fallback</elcode> instructions.</p>
               </item>
               <item>
                  <p><var>J</var> is in a <termref def="dt-tail-position">tail position</termref>
                     within the sequence constructor that forms the body of an
                        <elcode>xsl:if</elcode> instruction that is itself in a <termref def="dt-tail-position">tail position</termref> within <var>SC</var>.</p>
               </item>
               <item>
                  <p><var>J</var> is in a <termref def="dt-tail-position">tail position</termref>
                     within the sequence constructor that forms the body of an
                        <elcode>xsl:when</elcode> or <elcode>xsl:otherwise</elcode> branch of an
                        <elcode>xsl:choose</elcode> instruction that is itself in a <termref def="dt-tail-position">tail position</termref> within <var>SC</var>.</p>
               </item>

               <item>
                  <p><var>J</var> is in a <termref def="dt-tail-position">tail position</termref>
                     within the sequence constructor that forms the body of an
                        <elcode>xsl:try</elcode> instruction that is itself in a <termref def="dt-tail-position">tail position</termref> within <var>SC</var> (that
                     is, it is immediately followed by an <elcode>xsl:catch</elcode> element,
                     ignoring any <elcode>xsl:fallback</elcode> elements).</p>
               </item>
               <item>
                  <p><var>J</var> is in a <termref def="dt-tail-position">tail position</termref>
                     within the sequence constructor that forms the body of an
                        <elcode>xsl:catch</elcode> element within an <elcode>xsl:try</elcode>
                     instruction that is itself in a <termref def="dt-tail-position">tail
                        position</termref> within <var>SC</var>.</p>
               </item>
            </ulist>

            <p>
               <error spec="XT" type="static" class="SE" code="2110">
                  <p>It is a <termref def="dt-static-error">static error</termref> if an
                        <elcode>xsl:break</elcode> or <elcode>xsl:next-iteration</elcode> element
                     appears other than in a <termref def="dt-tail-position">tail position</termref>
                     within the <termref def="dt-sequence-constructor">sequence
                        constructor</termref> forming the body of an <elcode>xsl:iterate</elcode>
                     instruction.</p>
               </error>
            </p>

            <p>
               <error spec="XT" type="static" class="SE" code="2120">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the
                        <code>name</code> attribute of an <elcode>xsl:with-param</elcode> child of
                     an <elcode>xsl:next-iteration</elcode> element does not match the
                        <code>name</code> attribute of an <elcode>xsl:param</elcode> child of the
                        <phrase diff="add" at="F">innermost</phrase> containing
                        <elcode>xsl:iterate</elcode> instruction.</p>
               </error>
            </p>

            <p>Parameter names in <elcode>xsl:with-param</elcode> must be unique: <errorref spec="XT" class="SE" code="0670"/>.</p>

            <p>The result of the <elcode>xsl:iterate</elcode> instruction is the concatenation of
               the sequences that result from the repeated evaluation of the contained <termref def="dt-sequence-constructor">sequence constructor</termref>, followed by the
               sequence that results from evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref> contained within the <elcode>xsl:break</elcode> or
                  <elcode>xsl:on-completion</elcode> element if any.</p>
            <p>Any <elcode>xsl:param</elcode> element that appears as a child of
                  <elcode>xsl:iterate</elcode> declares a parameter whose value may vary from one
               iteration to the next. The initial value of the parameter is the value obtained
               according to the rules given in <specref ref="variable-values"/>. The dynamic context
               for evaluating the initial value of an <elcode>xsl:param</elcode> element is the same
               as the dynamic context for evaluating the <code>select</code> expression of the
                  <elcode>xsl:iterate</elcode> instruction (the context item is thus
                  <emph>not</emph> the first item in the input sequence).</p>
            <p>On the first iteration a parameter always takes its initial value (which may depend
               on variables or other aspects of the dynamic context). Subsequently:</p>
            <ulist diff="chg" at="F">
               <item>
                  <p>If an <elcode>xsl:next-iteration</elcode> instruction is evaluated, then
                     parameter values for processing the next item in the input sequence can be set
                     in the <elcode>xsl:with-param</elcode> children of that instruction; in the
                     absence of an <elcode>xsl:with-param</elcode> element that names a particular
                     parameter, that parameter will retain its value from the previous
                     iteration.</p>
               </item>
               <item>
                  <p>If an <elcode>xsl:break</elcode> instruction is evaluated, no further items in
                     the input sequence are processed.</p>
               </item>
               <item>
                  <p>If neither an <elcode>xsl:next-iteration</elcode> nor an
                        <elcode>xsl:break</elcode> instruction is evaluated, then the next item in
                     the input sequence is processed using parameter values that are unchanged from
                     the previous iteration.</p>
               </item>
            </ulist>


            <p>The <elcode>xsl:next-iteration</elcode> instruction contributes nothing to the result
               sequence (technically, it returns an empty sequence). The instruction supplies
               parameter values for the next iteration, which are evaluated according to the rules
               given in <specref ref="with-param"/>; if there are no further items in the input
               sequence then it supplies parameter values for use while evaluating the body of the
                  <elcode>xsl:on-completion</elcode> element if any.</p>
            <p>The <elcode>xsl:break</elcode> instruction indicates that the iteration should
               terminate without processing any remaining items from the input sequence. The
               contained sequence constructor is evaluated using the same context item, position,
               and size as the <elcode>xsl:break</elcode> instruction itself, and the result is
               appended to the result of the <elcode>xsl:iterate</elcode> instruction as a
               whole.</p>
            <p>If neither an <elcode>xsl:next-iteration</elcode> nor an <elcode>xsl:break</elcode>
               instruction is evaluated, the next item in the input sequence is processed with
               parameter values unchanged from the previous iteration; if there are no further items
               in the input sequence, the iteration terminates.</p>
            <p>The optional <elcode>xsl:on-completion</elcode> element (which is not technically an
                  <termref def="dt-instruction">instruction</termref> and is not technically part of
               the <termref def="dt-sequence-constructor">sequence constructor</termref>) is
               evaluated when the input sequence is exhausted. It is not evaluated if the evaluation
               is terminated using <elcode>xsl:break</elcode>. During evaluation of this sequence
               constructor the context item, position, and size are undefined (that is, any
               reference to these values is an error). However, the values of the parameters to
                  <elcode>xsl:iterate</elcode> are available, and take the values supplied by the
                  <elcode>xsl:next-iteration</elcode> instruction evaluated while processing the
               last item in the sequence.</p>
            <p diff="add" at="D">If the input sequence is empty, then the result of the
                  <elcode>xsl:iterate</elcode> instruction is the result of evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref> forming the body of
               the <elcode>xsl:on-completion</elcode> element, using the initial values of the
                  <elcode>xsl:param</elcode> elements. If there is no
                  <elcode>xsl:on-completion</elcode> element, the result is an empty sequence.</p>

            <note>
               <p>Conceptually, <elcode>xsl:iterate</elcode> behaves like a tail-recursive function.
                  The <elcode>xsl:next-iteration</elcode> instruction then represents the recursive
                  call, supplying the tail of the input sequence as an implicit parameter. There are
                  two main reasons for providing the <elcode>xsl:iterate</elcode> instruction. One
                  is that many XSLT users find writing recursive functions to be a difficult skill,
                  and this construct promises to be easier to learn. The other is that recursive
                  function calls are difficult for an optimizer to analyze. Because
                     <elcode>xsl:iterate</elcode> is more constrained than a general-purpose
                  head-tail recursive function, it should be more amenable to optimization. In
                  particular, when the instruction is used in conjunction with
                     <elcode>xsl:stream</elcode>, it is designed to make it easy for the
                  implementation to use streaming techniques, processing the nodes in an input
                  document sequentially as they are read, without building the entire
                  document tree in memory.</p>
            </note>
            <issue id="issue-iterate-empty" status="open">
               <p>The Working Group is considering whether more control is needed over how an empty
                  sequence is processed. Currently, whether a sequence is processed using
                     <elcode>xsl:for-each</elcode>, <elcode>xsl:apply-templates</elcode>, or
                     <elcode>xsl:iterate</elcode>, there is no easy way to define special code for
                  handling an empty sequence in a way that satisfies the rules for streamability,
                  because one downward selection is needed to test for emptiness, another to perform
                  iteration when non-empty. One possible solution is the proposed 
                  <function>has-children</function> function.</p>
            </issue>
            <p>The examples below use <elcode>xsl:iterate</elcode> in conjunction with the
                  <elcode>xsl:stream</elcode> instruction. This is not the only way of using
                  <elcode>xsl:iterate</elcode>, but it illustrates the way in which the two features
               can be combined to achieve streaming of a large input document.</p>



            <example>
               <head>Using <code>xsl:iterate</code> to compute cumulative totals</head>
               <p>Suppose that the input XML document has this structure</p>
               <eg xml:space="preserve">&lt;transactions&gt;
  &lt;transaction date="2008-09-01" value="12.00"/&gt;
  &lt;transaction date="2008-09-01" value="8.00"/&gt;
  &lt;transaction date="2008-09-02" value="-2.00"/&gt;
  &lt;transaction date="2008-09-02" value="5.00"/&gt;
&lt;/transactions&gt;</eg>
               <p>and that the requirement is to transform this to:</p>
               <eg xml:space="preserve">&lt;account&gt;
  &lt;balance date="2008-09-01" value="12.00"/&gt;
  &lt;balance date="2008-09-01" value="20.00"/&gt;
  &lt;balance date="2008-09-02" value="18.00"/&gt;
  &lt;balance date="2008-09-02" value="23.00"/&gt;
&lt;/account&gt;</eg>
               <p>This can be achieved using the following code, which is designed to process the
                  transaction file using streaming:</p>
               <eg xml:space="preserve">&lt;account&gt;
  &lt;xsl:stream href="transactions.xml"&gt;
    &lt;xsl:iterate select="transactions/transaction"&gt;
      &lt;xsl:param name="balance" select="0.00" as="xs:decimal"/&gt;
      &lt;xsl:variable name="newBalance" 
                    select="$balance + xs:decimal(@value)"/&gt;
      &lt;balance date="{@date}" value="{$newBalance}"/&gt;
      &lt;xsl:next-iteration&gt;
        &lt;xsl:with-param name="balance" select="$newBalance"/&gt;
      &lt;/xsl:next-iteration&gt;
    &lt;/xsl:iterate&gt;
  &lt;/xsl:stream&gt;
&lt;/account&gt;</eg>
               <p>The following example modifies this by only outputting the information for the
                  first day's transactions:</p>
               <eg xml:space="preserve">&lt;account&gt;
  &lt;xsl:stream href="'transactions.xml"&gt;
    &lt;xsl:iterate select="transactions/transaction"&gt;
      &lt;xsl:param name="balance" select="0.00" as="xs:decimal"/&gt;
      &lt;xsl:param name="prevDate" select="()" as="xs:date?"/&gt;
      &lt;xsl:variable name="newBalance" 
                    select="$balance + xs:decimal(@value)"/&gt;
      &lt;xsl:variable name="thisDate" 
                    select="xs:date(@date)"/&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="empty($prevDate) or $thisDate eq $prevDate"&gt;
          &lt;balance date="{$thisDate}" 
                   value="{format-number($newBalance, '0.00')}"/&gt;
          &lt;xsl:next-iteration&gt;
            &lt;xsl:with-param name="balance" select="$newBalance"/&gt;
            &lt;xsl:with-param name="prevDate" select="$thisDate"/&gt;
          &lt;/xsl:next-iteration&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:break/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/xsl:iterate&gt;
  &lt;/xsl:stream&gt;
&lt;/account&gt;</eg>
               <p>The following code outputs the balance only at the end of each day, together with
                  the final balance:</p>
               <eg xml:space="preserve">&lt;account&gt;
  &lt;xsl:stream href="transactions.xml"&gt;
    &lt;xsl:iterate select="transactions/transaction"&gt;
      &lt;xsl:param name="balance" select="0.00" as="xs:decimal"/&gt;
      &lt;xsl:param name="prevDate" select="()" as="xs:date?"/&gt;
      &lt;xsl:variable name="newBalance" 
                    select="$balance + xs:decimal(@value)"/&gt;
      &lt;xsl:variable name="thisDate" select="xs:date(@date)"/&gt;
      &lt;xsl:if test="exists($prevDate) and $thisDate ne $prevDate"&gt;
        &lt;balance date="{$prevDate}" 
                 value="{format-number($balance, '0.00')}"/&gt;
      &lt;/xsl:if&gt;
      &lt;xsl:next-iteration&gt;
        &lt;xsl:with-param name="balance" select="$newBalance"/&gt;
        &lt;xsl:with-param name="prevDate" select="$thisDate"/&gt;
      &lt;/xsl:next-iteration&gt;
      &lt;xsl:on-completion&gt;
        &lt;balance date="{$prevDate}" 
                 value="{format-number($balance, '0.00')}"/&gt;
      &lt;/xsl:on-completion&gt;
    &lt;/xsl:iterate&gt;
  &lt;/xsl:stream&gt;
&lt;/account&gt;</eg>
               <p>If the sequence of transactions is empty, this code outputs a single element:
                     <code>&lt;balance date="" value="0.00"/&gt;</code>.</p>
            </example>
            <example>
               <head>Collecting multiple values in a single pass</head>
               <p>Problem: Given a sequence of <code>employee</code> elements, find the employees
                  having the highest and lowest salary, while processing each employee only
                  once.</p>
               <p>Solution:</p>
               <eg xml:space="preserve">&lt;xsl:stream href="employees.xml"&gt;
  &lt;xsl:iterate select="employees/employee"&gt;
    &lt;xsl:param name="highest" as="element(employee)*"/&gt;
    &lt;xsl:param name="lowest" as="element(employee)*"/&gt;
    &lt;xsl:variable name="is-new-highest" as=xs:boolean"
                  select="empty($highest[@salary ge current()/@salary])"/&gt;
    &lt;xsl:variable name="is-equal-highest" as=xs:boolean" 
                  select="exists($highest[@salary eq current()/@salary])"/&gt; 
    &lt;xsl:variable name="is-new-lowest" as=xs:boolean" 
                  select="empty($lowest[@salary le current()/@salary])"/&gt;
    &lt;xsl:variable name="is-equal-lowest" as=xs:boolean" 
                  select="exists($lowest[@salary eq current()/@salary])"/&gt; 
    &lt;xsl:variable name="new-highest-set" as=element(employee)*"
                  select="if ($is-new-highest) then .
                          else if ($is-equal-highest) then ($highest, .)
                          else $highest"/&gt;
    &lt;xsl:variable name="new-lowest-set" as=element(employee)*"
                  select="if ($is-new-lowest) then .
                          else if ($is-equal-lowest) then ($lowest, .)
                          else $lowest"/&gt;
    &lt;xsl:next-iteration&gt;
      &lt;xsl:with-param name="highest" select="$new-highest-set"/&gt;
      &lt;xsl:with-param name="lowest" select="$new-lowest-set"/&gt;
    &lt;/xsl:next-iteration&gt;
    &lt;xsl:on-completion&gt;
      &lt;highest-paid-employees&gt;
        &lt;xsl:value-of select="$highest/name"/&gt;
      &lt;/highest-paid-employees&gt;
      &lt;lowest-paid-employees&gt;
        &lt;xsl:value-of select="$lowest/name"/&gt;
      &lt;/lowest-paid-employees&gt;  
    &lt;/xsl:on-completion&gt;
   &lt;/xsl:iterate&gt;
 &lt;/xsl:stream&gt;</eg>
               <p>If the input sequence is empty, this code outputs an empty
                     <code>highest-paid-employees</code> element and an empty
                     <code>lowest-paid-employees</code> element.</p> 
            </example>
            <example diff="add" at="E">
               <head>Processing the last item in a sequence specially</head>
               <p>When streaming, some limited look-ahead is needed to determine whether the item
                  being processed is the last in a sequence. The <xfunction>last</xfunction>
                  function cannot be used in <termref def="dt-guaranteed-streamable"/> code. The <elcode>xsl:iterate</elcode>
                  instruction provides a solution to this problem.</p>
               <p>Problem: render the last paragraph in a section in some special way, for example
                  by using bold face. (The actual rendition is achieved by processing the paragraph
                  with mode <code>last-para</code>.)</p>
               <p>The solution uses <elcode>xsl:iterate</elcode> to maintain a one-element lookahead
                  by explicit coding:</p>
               <eg xml:space="preserve">&lt;xsl:template match="section" mode="streaming"&gt;
   &lt;xsl:iterate select="para"&gt;
     &lt;xsl:param name="prev" select="()" as="element(para)?"/&gt;
     &lt;xsl:if test="$prev"&gt;
       &lt;xsl:apply-templates select="$prev"/&gt;
     &lt;/xsl:if&gt;
     &lt;xsl:next-iteration&gt;
       &lt;xsl:param name="prev" select="."/&gt;
     &lt;/xsl:next-iteration&gt;
     &lt;xsl:on-completion&gt;
       &lt;xsl:apply-templates select="$prev" mode="last-para"/&gt;      
     &lt;/xsl:on-completion&gt;
   &lt;/xsl:iterate&gt;
 &lt;/xsl:template&gt;</eg>

            </example>
         </div2>
      </div1>
      <div1 id="conditionals">
         <head>Conditional Processing</head>
         <p>There are two instructions in XSLT that support conditional processing:
               <elcode>xsl:if</elcode> and <elcode>xsl:choose</elcode>. The <elcode>xsl:if</elcode>
            instruction provides simple if-then conditionality; the <elcode>xsl:choose</elcode>
            instruction supports selection of one choice when there are several possibilities.</p>
         <p diff="add" at="B">XSLT 2.1 also supports <elcode>xsl:try</elcode> and
               <elcode>xsl:catch</elcode> which define conditional processing to handle <termref def="dt-dynamic-error">dynamic errors</termref>.</p>
         <div2 id="xsl-if">
            <head>Conditional Processing with <elcode>xsl:if</elcode>
            </head>
            <e:element-syntax name="if">
               <e:in-category name="instruction"/>
               <e:attribute name="test" required="yes">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:if</elcode> element has a mandatory <code>test</code> attribute,
               which specifies an <termref def="dt-expression">expression</termref>. The content is
               a <termref def="dt-sequence-constructor">sequence constructor</termref>.</p>
            <p>The result of the <elcode>xsl:if</elcode> instruction depends on the <xtermref spec="XP21" ref="dt-ebv">effective boolean value</xtermref> of the expression in
               the <code>test</code> attribute. The rules for determining the effective boolean
               value of an expression are given in <bibref ref="xpath-21"/>: they are the same as
               the rules used for XPath conditional expressions.</p>
            <p>If the effective boolean value of the <termref def="dt-expression">expression</termref> is true, then the <termref def="dt-sequence-constructor">sequence constructor</termref> is evaluated (see <specref ref="sequence-constructors"/>), and the resulting node sequence is returned as the
               result of the <elcode>xsl:if</elcode> instruction; otherwise, the sequence
               constructor is not evaluated, and the empty sequence is returned.</p>
            <example>
               <head>Using <code>xsl:if</code>
               </head>
               <p>In the following example, the names in a group of names are formatted as a comma
                  separated list:</p>
               <eg xml:space="preserve">&lt;xsl:template match="namelist/name"&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:if test="not(position()=last())"&gt;, &lt;/xsl:if&gt;
&lt;/xsl:template&gt;</eg>
               <p>The following colors every other table row yellow:</p>
               <eg xml:space="preserve">&lt;xsl:template match="item"&gt;
  &lt;tr&gt;
    &lt;xsl:if test="position() mod 2 = 0"&gt;
       &lt;xsl:attribute name="bgcolor"&gt;yellow&lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;</eg>
            </example>
         </div2>
         <div2 id="xsl-choose">
            <head>Conditional Processing with <elcode>xsl:choose</elcode>
            </head>
            <e:element-syntax name="choose">
               <e:in-category name="instruction"/>
               <e:sequence>
                  <e:element repeat="one-or-more" name="when"/>
                  <e:element repeat="zero-or-one" name="otherwise"/>
               </e:sequence>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <e:element-syntax name="when">
               <e:attribute name="test" required="yes">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent name="choose"/>
               </e:allowed-parents>
            </e:element-syntax>
            <e:element-syntax name="otherwise">
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent name="choose"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:choose</elcode> element selects one among a number of possible
               alternatives. It consists of a sequence of one or more <elcode>xsl:when</elcode>
               elements followed by an optional <elcode>xsl:otherwise</elcode> element. Each
                  <elcode>xsl:when</elcode> element has a single attribute, <code>test</code>, which
               specifies an <termref def="dt-expression">expression</termref>. The content of the
                  <elcode>xsl:when</elcode> and <elcode>xsl:otherwise</elcode> elements is a
                  <termref def="dt-sequence-constructor">sequence constructor</termref>.</p>
            <p>When an <elcode>xsl:choose</elcode> element is processed, each of the
                  <elcode>xsl:when</elcode> elements is tested in turn (that is, in the order that
               the elements appear in the stylesheet), until one of the <elcode>xsl:when</elcode>
               elements is satisfied. If none of the <elcode>xsl:when</elcode> elements is
               satisfied, then the <elcode>xsl:otherwise</elcode> element is considered, as
               described below.</p>
            <p>An <elcode>xsl:when</elcode> element is satisfied if the <xtermref spec="XP21" ref="dt-ebv">effective boolean value</xtermref> of the <termref def="dt-expression">expression</termref> in its <code>test</code> attribute is
                  <code>true</code>. The rules for determining the effective boolean value of an
               expression are given in <bibref ref="xpath-21"/>: they are the same as the rules used
               for XPath conditional expressions.</p>
            <p>The content of the first, and only the first, <elcode>xsl:when</elcode> element that
               is satisfied is evaluated, and the resulting sequence is returned as the result of
               the <elcode>xsl:choose</elcode> instruction. If no <elcode>xsl:when</elcode> element
               is satisfied, the content of the <elcode>xsl:otherwise</elcode> element is evaluated,
               and the resulting sequence is returned as the result of the
                  <elcode>xsl:choose</elcode> instruction. If no <elcode>xsl:when</elcode> element
               is satisfied, and no <elcode>xsl:otherwise</elcode> element is present, the result of
               the <elcode>xsl:choose</elcode> instruction is an empty sequence.</p>
            <p>Only the sequence constructor of the selected <elcode>xsl:when</elcode> or
                  <elcode>xsl:otherwise</elcode> instruction is evaluated. The <code>test</code>
               expressions for <elcode>xsl:when</elcode> instructions after the selected one are not
               evaluated.</p>
            <example>
               <head>Using <code>xsl:choose</code>
               </head>
               <p>The following example enumerates items in an ordered list using arabic numerals,
                  letters, or roman numerals depending on the depth to which the ordered lists are
                  nested.</p>
               <eg xml:space="preserve">&lt;xsl:template match="orderedlist/listitem"&gt;
  &lt;fo:list-item indent-start='2pi'&gt;
    &lt;fo:list-item-label&gt;
      &lt;xsl:variable name="level"
                    select="count(ancestor::orderedlist) mod 3"/&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test='$level=1'&gt;
          &lt;xsl:number format="i"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:when test='$level=2'&gt;
          &lt;xsl:number format="a"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:number format="1"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
      &lt;xsl:text&gt;. &lt;/xsl:text&gt;
    &lt;/fo:list-item-label&gt;
    &lt;fo:list-item-body&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/fo:list-item-body&gt;
  &lt;/fo:list-item&gt;
&lt;/xsl:template&gt;</eg>
            </example>
         </div2>


         <div2 diff="add" at="B" id="try-catch">
            <head>Try/Catch</head>

            <p diff="add" at="C">The <elcode>xsl:try</elcode> instruction can be used to trap
               dynamic errors occurring within the expression it wraps; the recovery action if such
               errors occur is defined using a child <elcode>xsl:catch</elcode> element.</p> 

            <e:element-syntax name="try" diff="chg" at="F">
               <e:in-category name="instruction"/>
               <e:attribute name="select" required="no">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:sequence>
                  <e:model name="sequence-constructor"/>
                  <e:element name="catch"/>
                  <e:choice repeat="zero-or-more">
                     <e:element name="catch"/>
                     <e:element name="fallback"/>
                  </e:choice>
               </e:sequence>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <note>
               <p>Because a sequence constructor may contain an <elcode>xsl:fallback</elcode>
                  element, the effect of this content model is that an <elcode>xsl:fallback</elcode>
                  instruction may appear as a child of <elcode>xsl:try</elcode> in any position.</p>
            </note>
            <e:element-syntax name="catch">
               <e:attribute name="errors" required="no">
                  <e:data-type name="tokens"/>
               </e:attribute>
               <e:attribute name="select" required="no">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent name="try"/>
               </e:allowed-parents>
            </e:element-syntax>

            <p>An <elcode>xsl:try</elcode> instruction evaluates either the expression contained in
               its <code>select</code> attribute, or its contained <termref def="dt-sequence-constructor">sequence constructor</termref>, and returns the
               result of that evaluation if it succeeds without error. If a <termref def="dt-dynamic-error">dynamic error</termref> occurs during the evaluation, the
               processor evaluates the first <elcode>xsl:catch</elcode> child element applicable to
               the error, and returns that result instead.</p>

            <p>If the <elcode>xsl:try</elcode> element has a <code>select</code> attribute, then it
               must have no children other than <elcode>xsl:catch</elcode> and
                  <elcode>xsl:fallback</elcode>. That is, the <code>select</code> attribute and the
               contained sequence constructor are mutually exclusive. If neither is present, the
               result of the <elcode>xsl:try</elcode> is an empty sequence (no dynamic error can
               occur in this case).</p>

            <p>
               <error spec="XT" type="static" class="SE" code="2130">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the
                        <code>select</code> attribute of the <elcode>xsl:try</elcode> element is
                     present and the element has children other than <elcode>xsl:catch</elcode> and
                        <elcode>xsl:fallback</elcode> elements.</p>
               </error>
            </p>

            <p>Any <elcode>xsl:fallback</elcode> children of the <elcode>xsl:try</elcode> element
               are ignored by an XSLT 2.1 processor, but can be used to define the recovery action
               taken by an XSLT 1.0 or XSLT 2.0 processor operating with <termref def="dt-forwards-compatible-behavior"/>.</p>

            <p>The <elcode>xsl:catch</elcode> element has an optional <code>errors</code> attribute,
               which lists the error conditions that the <elcode>xsl:catch</elcode> element is
               designed to intercept. The default value is <code>errors="*"</code>, which catches
               all errors. The value is a whitespace-separated list of <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-NameTest" xlink:type="simple">NameTests</xnt>; an <elcode>xsl:catch</elcode> element
               catches an error condition if this list includes a <code>NameTest</code> that matches
               the error code associated with that error condition.</p>

            <note>
               <p>Error codes are QNames. Those defined in this specification and in related
                  specifications are all in the <termref def="dt-standard-error-namespace">standard
                     error namespace</termref>, and may therefore be caught using an
                     <elcode>xsl:catch</elcode> element such as <code>&lt;xsl:catch
                     errors="err:FODC0001 err:FODC0005"&gt;</code> where the namespace prefix
                     <code>err</code> is bound to this namespace. Errors defined by implementors,
                  and errors raised by an explicit call of the <xfunction>error</xfunction> function
                  or by use of the <elcode>xsl:message</elcode> instruction, <rfc2119>may</rfc2119>
                  use error codes in other namespaces.</p>
            </note>

            <p>If more than one <elcode>xsl:catch</elcode> element matches an error, the error is
               processed using the first one that matches, in document order. If no
                  <elcode>xsl:catch</elcode> matches the error, then the error is not caught (that
               is, evaluation of the <elcode>xsl:try</elcode> element fails with the dynamic
               error).</p>

            <p>An <elcode>xsl:catch</elcode> element may have either a <code>select</code>
               attribute, or a contained <termref def="dt-sequence-constructor">sequence
                  constructor</termref>.</p>

            <p>
               <error spec="XT" type="static" class="SE" code="2140">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the
                        <code>select</code> attribute of the <elcode>xsl:catch</elcode> element is
                     present unless the element has empty content.</p>
               </error>
            </p>


            <p>The result of evaluating the <elcode>xsl:catch</elcode> element is the result of
               evaluating the XPath expression in its <code>select</code> attribute or the result of
               evaluating the contained sequence constructor; if neither is present, the result is
               an empty sequence. This result is delivered as the result of the <code>xsl:try</code>
               instruction.</p>

            <p>If a dynamic error occurs during the evaluation of <elcode>xsl:catch</elcode>, it
               causes the containing <elcode>xsl:try</elcode> to fail with this error. The error is
               not caught by other sibling <elcode>xsl:catch</elcode> elements within the same
                  <elcode>xsl:try</elcode> instruction, but it may be caught by an
                  <elcode>xsl:try</elcode> instruction at an outer level, or by an
                  <elcode>xsl:try</elcode> instruction nested within the
               <elcode>xsl:catch</elcode>.</p>

            <p>Within the <code>select</code> expression, or within the sequence constructor
               contained by the <elcode>xsl:catch</elcode> element, a number of variables are
               implicitly declared, giving information about the error that occurred. These are
               lexically scoped to the <code>xsl:catch</code> element. These variables are all in
               the <termref def="dt-standard-error-namespace">standard error namespace</termref>,
               and they are initialized as described in the following table:</p>

            <table border="1" cellpadding="5">
               <thead>
                  <tr>
                     <th align="left" rowspan="1" colspan="1">Variable</th>
                     <th align="left" rowspan="1" colspan="1">Type</th>
                     <th align="left" rowspan="1" colspan="1">Value</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">err:code</td>
                     <td valign="top" rowspan="1" colspan="1">xs:QName</td>
                     <td valign="top" rowspan="1" colspan="1">The error code</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">err:description</td>
                     <td valign="top" rowspan="1" colspan="1">xs:string</td>
                     <td valign="top" rowspan="1" colspan="1">A description of the error condition</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">err:value</td>
                     <td valign="top" rowspan="1" colspan="1">item()*</td>
                     <td valign="top" rowspan="1" colspan="1">Value associated with the error. For an error raised by
                        calling the <xfunction>error</xfunction> function, this is the value of the
                        third argument (if supplied). For an error raised by evaluating
                           <elcode>xsl:message</elcode> with <code>terminate="yes"</code>, this is
                        the document node at the root of the tree containing the XML message
                        body.</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">err:module</td>
                     <td valign="top" rowspan="1" colspan="1">xs:string?</td>
                     <td valign="top" rowspan="1" colspan="1">The URI (or system ID) of the stylesheet module containing the
                        instruction where the error occurred; an empty sequence if the information
                        is not available.</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">err:line-number</td>
                     <td valign="top" rowspan="1" colspan="1">xs:integer?</td>
                     <td valign="top" rowspan="1" colspan="1">The line number within the stylesheet module of the
                        instruction where the error occurred; an empty sequence if the information
                        is not available. The value <rfc2119>may</rfc2119> be approximate.</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">err:column-number</td>
                     <td valign="top" rowspan="1" colspan="1">xs:integer?</td>
                     <td valign="top" rowspan="1" colspan="1">The column number within the stylesheet module of the
                        instruction where the error occurred; an empty sequence if the information
                        is not available. The value <rfc2119>may</rfc2119> be approximate.</td>
                  </tr>
               </tbody>
            </table>

            <p>Variables declared within the sequence constructor of the <elcode>xsl:try</elcode>
               element (and not within an <elcode>xsl:catch</elcode>) are not visible within the
                  <elcode>xsl:catch</elcode> element.</p>

            <note>
               <p>Within an <elcode>xsl:catch</elcode> it is possible to re-throw the error using
                  the function call <code>error($err:code, $err:description, $err:value)</code>.</p>
            </note>

            <p>The following additional rules apply to the catching of errors:</p>

            <olist>
               <item>
                  <p>All dynamic errors occurring during the evaluation of the
                        <elcode>xsl:try</elcode> sequence constructor or <code>select</code>
                     expression are caught (provided they match one of the
                        <elcode>xsl:catch</elcode> elements). </p>
                  <ulist>
                     <item>
                        <p>This includes errors occurring in functions or templates invoked in the
                           course of this evaluation, unless already caught by a nested
                              <elcode>xsl:try</elcode>.</p>
                     </item>
                     <item>
                        <p>It also includes errors caused by calling the
                              <xfunction>error</xfunction> function or the
                              <elcode>xsl:message</elcode> instruction with
                              <code>terminate="yes"</code>. </p>
                     </item>
                     <item>
                        <p>It does not include errors that occur while evaluating references to
                           variables whose declaration and initialization is outside the
                              <elcode>xsl:try</elcode>.</p>
                     </item>
                  </ulist>
               </item>
               <item>
                  <p>The existence of an <elcode>xsl:try</elcode> instruction does not affect the
                     right of the processor to recover, or not recover, from errors classified as
                        <termref def="dt-recoverable-error">recoverable dynamic errors</termref>. An
                        <elcode>xsl:catch</elcode> element will be activated only if the processor
                     chooses to signal the error rather than taking the defined recovery action.</p>
               </item>
               <item>
                  <p>The existence of an <elcode>xsl:try</elcode> instruction does not affect the
                     obligation of the processor to signal certain errors as static errors, or its
                     right to choose whether to signal some errors (such as type errors) statically
                     or dynamically. Static errors are never caught.</p>
               </item>
               <item>
                  <p>Some fatal errors arising in the processing environment, such as running out of
                     memory, may cause termination of the transformation despite the presence of an
                        <elcode>xsl:try</elcode> instruction. This is <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p>
               </item>

               <item>
                  <p>If the sequence constructor or <code>select</code> expression of the
                        <elcode>xsl:try</elcode> causes execution of
                        <elcode>xsl:result-document</elcode> or <elcode>xsl:message</elcode>
                     instructions and fails with a dynamic error that is caught, it is
                     implementation-dependent whether these instructions have any externally visible
                     effect. The processor is <rfc2119>not required</rfc2119> to do a "rollback" of
                     any changes made by these instructions. The same applies to any side effects
                     caused by extension functions or extension instructions.</p>
               </item>
               <item>
                  <p>If the <elcode>xsl:try</elcode> element appears in a context where it is
                     required to deliver a value of a specified type (for example, if it appears as
                     the body of a stylesheet function), then any error that occurs because it
                     delivers a value of the wrong type, or an error that occurs during conversion
                     to the required type (for example, during atomization), is treated as occurring
                     within the scope of the <elcode>xsl:try</elcode> instruction.</p>
               </item>
               <item>
                  <p>When an instruction <var>J</var> computes a value that will inevitably cause
                     some outer-level instruction <var>O</var> to fail with a dynamic error, then
                     the failure <rfc2119>may</rfc2119> be treated as occurring in <var>J</var>, in
                     which case it will be caught by an <elcode>xsl:try</elcode> instruction whose
                     scope includes <var>J</var> but does not include <var>O</var>. For example,
                     creating an element may fail because the element is not allowed by the content
                     model of a containing element; although the specification describes this as a
                     failure associated with the construction of the containing element, a processor
                     is allowed to detect the error as soon as it becomes inevitable.</p>
                  <note>
                     <p>The effect of this rule is that when stylesheet output is streamed to a
                        schema validator or to a serializer, errors detected by the validation or
                        serialization process may be treated if they occurred in the instruction
                        that generated the offending output; however, stylesheet authors cannot rely
                        on this. In fact, where serialization is applied to a <termref def="dt-final-result-tree"/>, there is no guarantee that it will be
                        possible to catch the error at all, since serialization is outside the scope
                        of the transformation process proper.</p>
                  </note>
               </item>
               <item>
                  <p>The fact that the application tries to catch errors does not prevent the
                     processor from organizing the evaluation in such a way as to prevent errors
                     occurring. For example <code>exists(//a[10 div . gt 5])</code> may still do an
                     "early exit", rather than examining every item in the sequence just to see if
                     it triggers a divide-by-zero error.</p>
               </item>
               <item>
                  <p>A failure occurring while evaluating the match pattern of a template rule, if
                     not treated as a recoverable error, is treated as occurring during the
                     evaluation of the calling <elcode>xsl:apply-templates</elcode> instruction (or
                        <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode> if
                     appropriate).</p>
               </item>
               <item>
                  <p>Except as specified above, the optimizer must not rearrange the evaluation (at
                     compile time or at run time) so that expressions written to be subject to to
                     the try/catch are evaluated outside its scope, or expressions written to be
                     external to the try/catch are evaluated within its scope. This does not prevent
                     expressions being rearranged, but any expression that is so rearranged must
                     carry its try/catch context with it.</p>
               </item>
            </olist>

            <note>
               <p>If an error occurs while evaluating an instruction within
                  <elcode>xsl:try</elcode>, then no instruction within the <elcode>xsl:try</elcode>
                  has any effect on the result returned by the <elcode>xsl:try</elcode> instruction.
                  This means that if a processor is streaming the output to a serializer, it needs
                  to adopt a strategy such as buffering the output in memory so that nothing is
                  written until successful completion of the <elcode>xsl:try</elcode> instruction,
                  or checkpointing the output so it can be rolled back when an error occurs.</p>
            </note>
            
            <issue id="issue-try-catch-output-buffering" status="open"><p>
               The rules appear inconsistent: if the processor is obliged to buffer "immediate" output
               from the xsl:try element before sending it the serializer, should not the same requirement
               apply also to xsl:result-document (rule 5)? And if output has to be buffered, is rule 7
               appropriate, allowing serialization errors to be detected "on the fly"?
            </p></issue>

            <div3 id="try-catch-examples">
               <head>Try/Catch Examples</head>

               <example>
                  <head>Catching a divide-by-zero error</head>

                  <p>The following example divides an employee's salary by the number of years they
                     have served, catching the error if the latter is zero.</p>
                  <eg xml:space="preserve">&lt;xsl:try select="salary div length-of-service"&gt;
  &lt;xsl:catch errors="err:FAOR0001" select="()"/&gt;
&lt;/xsl:try&gt;</eg>
               </example>

               <example>
                  <head>Catching an error during result-tree validation</head>

                  <p>The following example generates a result tree and performs schema validation,
                     outputting a warning message and serializing the invalid tree if validation
                     fails.</p>

                  <eg xml:space="preserve">&lt;xsl:result-document href="out.xml"&gt;
  &lt;xsl:variable name="result"&gt;
    &lt;xsl:call-template name="construct-output"/&gt;
  &lt;/xsl:variable&gt;
  &lt;xsl:try&gt;
    &lt;xsl:copy-of select="$result" validation="strict"/&gt;
    &lt;xsl:catch&gt;
      &lt;xsl:message&gt;Warning: validation of result document failed:
          Error code: &lt;xsl:value-of select="$err:code"/&gt;
          Reason: &lt;xsl:value-of select="$err:description"/&gt;
      &lt;/xsl:message&gt;
      &lt;xsl:sequence select="$result"/&gt;
    &lt;/xsl:catch&gt;
  &lt;/xsl:try&gt;
&lt;/xsl:result-document&gt;
</eg>
              
               <p>The reason that the result tree is constructed in a variable in this example is so
                  that the unvalidated tree is available to be used within the
                     <elcode>xsl:catch</elcode> element. An alternative approach would be to repeat
                  the logic for constructing the tree:</p>
               <eg xml:space="preserve">&lt;xsl:try&gt;
  &lt;xsl:result-document href="out.xml" validation="strict"&gt;  
    &lt;xsl:call-template name="construct-output"/&gt;
  &lt;/xsl:result-document&gt;
  &lt;xsl:catch&gt;
    &lt;xsl:message&gt;Warning: validation of result document failed:
          Error code: &lt;xsl:value-of select="$err:code"/&gt;
          Reason: &lt;xsl:value-of select="$err:description"/&gt;
    &lt;/xsl:message&gt;
    &lt;xsl:call-template name="construct-output"/&gt;
  &lt;/xsl:catch&gt;
  &lt;/xsl:try&gt;</eg>
               </example>
            </div3>

         </div2>
      </div1>


      <div1 id="variables-and-parameters">
         <head>Variables and Parameters</head>
         <p>
            <termdef id="dt-variable-binding-element" term="variable-binding element">The two
               elements <elcode>xsl:variable</elcode> and <elcode>xsl:param</elcode> are referred to
               as <term>variable-binding elements</term>
            </termdef>.</p>
         <p>
            <termdef id="dt-variable" term="variable">The <elcode>xsl:variable</elcode> element
               declares a <term>variable</term>, which may be a <termref def="dt-global-variable">global variable</termref> or a <termref def="dt-local-variable">local
                  variable</termref>.</termdef>
         </p>
         <p>
            <termdef id="dt-parameter" term="parameter">The <elcode>xsl:param</elcode> element
               declares a <term>parameter</term>, which may be a <termref def="dt-stylesheet-parameter">stylesheet parameter</termref>, a <termref def="dt-template-parameter">template parameter</termref>, a <termref def="dt-function-parameter">function parameter</termref><phrase diff="add" at="D">, or an <elcode>xsl:iterate</elcode> parameter</phrase>. A parameter is a
                  <termref def="dt-variable">variable</termref> with the additional property that
               its value can be set by the caller.</termdef>
         </p>
         <p>
            <termdef id="dt-value" term="value">A variable is a binding between a name and a value.
               The <term>value</term> of a variable is any sequence (of nodes, atomic values,
                  <phrase diff="add" at="C">and/or function items</phrase>), as defined in <bibref ref="xpath-datamodel-11"/>.</termdef>
         </p>

         <div2 id="variables">
            <head>Variables</head>
            <e:element-syntax name="variable">
               <e:in-category name="declaration"/>
               <e:in-category name="instruction"/>
               <e:attribute name="name" required="yes">
                  <e:data-type name="qname"/>
               </e:attribute>
               <e:attribute name="select">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="as">
                  <e:data-type name="sequence-type"/>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent name="stylesheet"/>
                  <e:parent name="transform"/>
                  <e:parent name="function"/>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:variable</elcode> element has a <rfc2119>required</rfc2119>
               <code>name</code> attribute, which specifies the name of the variable. The value of
               the <code>name</code> attribute is a <termref def="dt-qname">QName</termref>, which
               is expanded as described in <specref ref="qname"/>.</p>
            <p>The <elcode>xsl:variable</elcode> element has an optional <code>as</code> attribute,
               which specifies the <termref def="dt-required-type">required type</termref> of the
               variable. The value of the <code>as</code> attribute is a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-SequenceType" xlink:type="simple">SequenceType</xnt>, as defined in <bibref ref="xpath-21"/>.</p>
            <p>
               <termdef id="dt-supplied-value" term="supplied value">The value of the variable is
                  computed using the <termref def="dt-expression">expression</termref> given in the
                     <code>select</code> attribute or the contained <termref def="dt-sequence-constructor">sequence constructor</termref>, as described in
                     <specref ref="variable-values"/>. This value is referred to as the
                     <term>supplied value</term> of the variable.</termdef> If the
                  <elcode>xsl:variable</elcode> element has a <code>select</code> attribute, then
               the sequence constructor <rfc2119>must</rfc2119> be empty.</p>
            <p>If the <code>as</code> attribute is specified, then the <termref def="dt-supplied-value">supplied value</termref> of the variable is converted to
               the required type, using the <termref def="dt-function-conversion-rules">function
                  conversion rules</termref>.</p>
            <p>
               <error spec="XT" type="type" class="TE" code="0570">
                  <p>It is a <termref def="dt-type-error">type error</termref> if the <termref def="dt-supplied-value">supplied value</termref> of a variable cannot be
                     converted to the required type.</p>
               </error>
            </p>
            <p>If the <code>as</code> attribute is omitted, the <termref def="dt-supplied-value">supplied value</termref> of the variable is used directly, and no conversion
               takes place.</p>
         </div2>
         <div2 id="parameters">
            <head>Parameters</head>
            <e:element-syntax name="param">
               <e:in-category name="declaration"/>
               <e:attribute name="name" required="yes">
                  <e:data-type name="qname"/>
               </e:attribute>
               <e:attribute name="select">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="as">
                  <e:data-type name="sequence-type"/>
               </e:attribute>
               <e:attribute name="required">
                  <e:constant value="yes"/>
                  <e:constant value="no"/>
               </e:attribute>
               <e:attribute name="tunnel">
                  <e:constant value="yes"/>
                  <e:constant value="no"/>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent name="stylesheet"/>
                  <e:parent name="transform"/>
                  <e:parent name="function"/>
                  <e:parent name="template"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:param</elcode> element may be used:</p>
            <ulist>
               <item>
                  <p>as a child of <elcode>xsl:stylesheet</elcode>, to define a parameter to the
                     transformation</p>
               </item>
               <item>
                  <p>as a child of <elcode>xsl:template</elcode> to define a parameter to a
                     template, which may be supplied when the template is invoked using
                        <elcode>xsl:call-template</elcode>, <elcode>xsl:apply-templates</elcode>,
                        <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode>;</p>
               </item>
               <item>
                  <p>as a child of <elcode>xsl:function</elcode> to define a parameter to a
                     stylesheet function, which may be supplied when the function is called from an
                     XPath <termref def="dt-expression">expression</termref>
                  </p>
               </item>
               <item diff="add" at="A">
                  <p>as a child of <elcode>xsl:iterate</elcode> to define a parameter that can vary
                     from one iteration to the next.</p>
               </item>
            </ulist>
            <p>The <elcode>xsl:param</elcode> element has a <rfc2119>required</rfc2119>
               <code>name</code> attribute, which specifies the name of the parameter. The value of
               the <code>name</code> attribute is a <termref def="dt-qname">QName</termref>, which
               is expanded as described in <specref ref="qname"/>.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0580">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the values of
                     the <code>name</code> attribute of two <phrase diff="chg" at="A">sibling
                           <elcode>xsl:param</elcode> elements represent the same expanded <termref def="dt-qname">QName</termref></phrase>.</p>
               </error>
            </p>
            <note>
               <p>For rules concerning stylesheet parameters, see <specref ref="global-variables"/>.
                  Local variables may <termref def="dt-shadows">shadow</termref> template parameters
                  and function parameters: see <specref ref="scope-of-variables"/>.</p>
            </note>
            <p>The <termref def="dt-supplied-value">supplied value</termref> of the parameter is the
               value supplied by the caller. If no value was supplied by the caller, and if the
               parameter is not mandatory, then the supplied value is computed using the <termref def="dt-expression">expression</termref> given in the <code>select</code>
               attribute or the contained <termref def="dt-sequence-constructor">sequence
                  constructor</termref>, as described in <specref ref="variable-values"/>. If the
                  <elcode>xsl:param</elcode> element has a <code>select</code> attribute, then the
               sequence constructor <rfc2119>must</rfc2119> be empty.</p>
            <note>
               <p>This specification does not dictate whether and when the default value of a
                  parameter is evaluated. For example, if the default is specified as
                     <code>&lt;xsl:param name="p"&gt;&lt;foo/&gt;&lt;/xsl:param&gt;</code>, then it
                  is not specified whether a distinct <code>foo</code> element node will be created
                  on each invocation of the template, or whether the same <code>foo</code> element
                  node will be used for each invocation. However, it is permissible for the default
                  value to depend on the values of other parameters, or on the evaluation context,
                  in which case the default must effectively be evaluated on each invocation.</p>
            </note>
            <p>The <elcode>xsl:param</elcode> element has an optional <code>as</code> attribute,
               which specifies the <termref def="dt-required-type">required type</termref> of the
               parameter. The value of the <code>as</code> attribute is a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-SequenceType" xlink:type="simple">SequenceType</xnt>, as defined in <bibref ref="xpath-21"/>.</p>
            <p>If the <code>as</code> attribute is specified, then the <termref def="dt-supplied-value">supplied value</termref> of the parameter is converted to
               the required type, using the <termref def="dt-function-conversion-rules">function
                  conversion rules</termref>.</p>
            <p>
               <error spec="XT" type="type" class="TE" code="0590">
                  <p>It is a <termref def="dt-type-error">type error</termref> if the conversion of
                     the <termref def="dt-supplied-value">supplied value</termref> of a parameter to
                     its required type fails.</p>
               </error>
            </p>
            <p>If the <code>as</code> attribute is omitted, the <termref def="dt-supplied-value">supplied value</termref> of the parameter is used directly, and no conversion
               takes place.</p>
            <p>The optional <code>required</code> attribute may be used to indicate that a parameter
               is mandatory. This attribute may be specified for <termref def="dt-stylesheet-parameter">stylesheet parameters</termref> and for <termref def="dt-template-parameter">template parameters</termref>; it <rfc2119>must
                  not</rfc2119> be specified for <termref def="dt-function-parameter">function
                  parameters</termref>, which are always mandatory, <phrase diff="add" at="A"> or
                  for parameters to <elcode>xsl:iterate</elcode>, which are always initialized to a
                  default value</phrase>. A parameter is mandatory if it is a <termref def="dt-function-parameter">function parameter</termref> or if the
                  <code>required</code> attribute is present and has the value <code>yes</code>.
               Otherwise, the parameter is optional. If the parameter is mandatory, then the
                  <elcode>xsl:param</elcode> element <rfc2119>must</rfc2119> be empty and
                  <rfc2119>must not</rfc2119> have a <code>select</code> attribute.</p>
            <p>
               <error spec="XT" type="type" class="TE" code="0600">
                  <p>If a default value is given explicitly, that is, if there is either a
                        <code>select</code> attribute or a non-empty <termref def="dt-sequence-constructor">sequence constructor</termref>, then it is a
                        <termref def="dt-type-error">type error</termref> if the default value
                     cannot be converted to the required type, using the <termref def="dt-function-conversion-rules">function conversion rules</termref>.</p>
               </error>
            </p>
            <p>If an optional parameter has no <code>select</code> attribute and has an empty
                  <termref def="dt-sequence-constructor">sequence constructor</termref>, and if
               there is no <code>as</code> attribute, then the default value of the parameter is a
               zero length string.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0610">
                  <p>If an optional parameter has no <code>select</code> attribute and has an empty
                        <termref def="dt-sequence-constructor">sequence constructor</termref>, and
                     if there is an <code>as</code> attribute, then the default value of the
                     parameter is an empty sequence. If the empty sequence is not a valid instance
                     of the required type defined in the <code>as</code> attribute, then the
                     parameter is treated as a required parameter, which means that it is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if the
                     caller supplies no value for the parameter.</p>
               </error>
            </p>
            <note>
               <p>The effect of these rules is that specifying <code>&lt;xsl:param name="p"
                     as="xs:date" select="2"/&gt;</code> is an error, but if the default value of
                  the parameter is never used, then the processor has discretion whether or not to
                  report the error. By contrast, <code>&lt;xsl:param name="p"
                     as="xs:date"/&gt;</code> is treated as if <code>required="yes"</code> had been
                  specified: the empty sequence is not a valid instance of <code>xs:date</code>, so
                  in effect there is no default value and the parameter is therefore treated as
                  being mandatory.</p>
            </note>
            <p>The optional <code>tunnel</code> attribute may be used to indicate that a parameter
               is a <termref def="dt-tunnel-parameter">tunnel parameter</termref>. The default is
                  <code>no</code>; the value <code>yes</code> may be specified only for <termref def="dt-template-parameter">template parameters</termref>. Tunnel parameters are
               described in <specref ref="tunnel-params"/>
            </p>
            <issue id="fixed-value-attributes" status="open">
               <p>The treatment of <code>tunnel</code> and <code>required</code> is inconsistent in
                  the case where the attribute makes no sense. In one case we allow the parameter to
                  be present so long as it has its "fixed" value, in the other case we require it to
                  be omitted. The WG has decided in principle that where only one value makes sense
                  for an attribute, it should be legal to specify the attribute and give it that
                  value. However, where an attribute makes no sense in a particular context, it will
                  still be an error to include it: for example the <code>from</code> attribute of
                     <elcode>xsl:number</elcode> must be omitted if the <code>value</code> attribute
                  is present.</p>
               <resolution>
                  <p>Editor to implement WG decision.</p>
               </resolution>
            </issue>

         </div2>
         <div2 id="variable-values">
            <head>Values of Variables and Parameters</head>
            <p>A <termref def="dt-variable-binding-element">variable-binding element</termref> may
               specify the <termref def="dt-supplied-value">supplied value</termref> of a <termref def="dt-variable">variable</termref>
               <phrase diff="add" at="D">or the default value of a</phrase>
               <termref def="dt-parameter">parameter</termref> in four different ways.</p>
            <ulist>
               <item>
                  <p>If the <termref def="dt-variable-binding-element">variable-binding
                        element</termref> has a <code>select</code> attribute, then the value of the
                     attribute <rfc2119>must</rfc2119> be an <termref def="dt-expression">expression</termref> and the <termref def="dt-supplied-value">supplied
                        value</termref> of the variable is the value that results from evaluating
                     the expression. In this case, the content of the variable-binding element
                        <rfc2119>must</rfc2119> be empty.</p>
               </item>
               <item>
                  <p>If the <termref def="dt-variable-binding-element">variable-binding
                        element</termref> has empty content and has neither a <code>select</code>
                     attribute nor an <code>as</code> attribute, then the <termref def="dt-supplied-value">supplied value</termref> of the variable is a
                     zero-length string. Thus</p>
                  <eg xml:space="preserve">&lt;xsl:variable name="x"/&gt;</eg>
                  <p>is equivalent to</p>
                  <eg xml:space="preserve">&lt;xsl:variable name="x" select="''"/&gt;</eg>
               </item>
               <item>
                  <p>If a <termref def="dt-variable-binding-element">variable-binding
                        element</termref> has no <code>select</code> attribute and has non-empty
                     content (that is, the variable-binding element has one or more child nodes),
                     and has no <code>as</code> attribute, then the content of the variable-binding
                     element specifies the <termref def="dt-supplied-value">supplied
                     value</termref>. The content of the variable-binding element is a <termref def="dt-sequence-constructor">sequence constructor</termref>; a new document
                     is constructed with a document node having as its children the sequence of
                     nodes that results from evaluating the sequence constructor and then applying
                     the rules given in <specref ref="constructing-complex-content"/>. The value of
                     the variable is then a singleton sequence containing this document node. For
                     further information, see <specref ref="temporary-trees"/>. </p>
               </item>
               <item>
                  <p>If a <termref def="dt-variable-binding-element">variable-binding
                        element</termref> has an <code>as</code> attribute but no
                        <code>select</code> attribute, then the <termref def="dt-supplied-value">supplied value</termref> is the sequence that results from evaluating the
                     (possibly empty) <termref def="dt-sequence-constructor">sequence
                        constructor</termref> contained within the variable-binding element (see
                        <specref ref="sequence-constructors"/>). </p>
               </item>
            </ulist>
            <p>These combinations are summarized in the table below.</p>
            <table border="1" cellpadding="5">
               <col width="12%" span="1"/>
               <col width="12%" span="1"/>
               <col width="12%" span="1"/>
               <col span="1"/>
               <thead>
                  <tr>
                     <th align="left" rowspan="1" colspan="1">select attribute</th>
                     <th align="left" rowspan="1" colspan="1">as attribute</th>
                     <th align="left" rowspan="1" colspan="1">content</th>
                     <th align="left" rowspan="1" colspan="1">Effect</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">present</td>
                     <td valign="top" rowspan="1" colspan="1">absent</td>
                     <td valign="top" rowspan="1" colspan="1">empty</td>
                     <td valign="top" rowspan="1" colspan="1">Value is obtained by evaluating the
                           <code>select</code> attribute</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">present</td>
                     <td valign="top" rowspan="1" colspan="1">present</td>
                     <td valign="top" rowspan="1" colspan="1">empty</td>
                     <td valign="top" rowspan="1" colspan="1">Value is obtained by evaluating the
                           <code>select</code> attribute, adjusted to the type required by the
                           <code>as</code> attribute</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">present</td>
                     <td valign="top" rowspan="1" colspan="1">absent</td>
                     <td valign="top" rowspan="1" colspan="1">present</td>
                     <td valign="top" rowspan="1" colspan="1">Static error</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">present</td>
                     <td valign="top" rowspan="1" colspan="1">present</td>
                     <td valign="top" rowspan="1" colspan="1">present</td>
                     <td valign="top" rowspan="1" colspan="1">Static error</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">absent</td>
                     <td valign="top" rowspan="1" colspan="1">absent</td>
                     <td valign="top" rowspan="1" colspan="1">empty</td>
                     <td valign="top" rowspan="1" colspan="1">Value is a zero-length string</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">absent</td>
                     <td valign="top" rowspan="1" colspan="1">present</td>
                     <td valign="top" rowspan="1" colspan="1">empty</td>
                     <td valign="top" rowspan="1" colspan="1">Value is an empty sequence, provided
                        the <code>as</code> attribute permits an empty sequence</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">absent</td>
                     <td valign="top" rowspan="1" colspan="1">absent</td>
                     <td valign="top" rowspan="1" colspan="1">present</td>
                     <td valign="top" rowspan="1" colspan="1">Value is a document node whose content
                        is obtained by evaluating the sequence constructor</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">absent</td>
                     <td valign="top" rowspan="1" colspan="1">present</td>
                     <td valign="top" rowspan="1" colspan="1">present</td>
                     <td valign="top" rowspan="1" colspan="1">Value is obtained by evaluating the
                        sequence constructor, adjusted to the type required by the <code>as</code>
                        attribute</td>
                  </tr>
               </tbody>
            </table>
            <p>
               <error spec="XT" type="static" class="SE" code="0620">
                  <p>It is a <termref def="dt-static-error">static error</termref> if a <termref def="dt-variable-binding-element">variable-binding element</termref> has a
                        <code>select</code> attribute and has non-empty content.</p>
               </error>
            </p>
            <example>
               <head>Values of Variables</head>
               <p>The value of the following variable is the sequence of integers (1, 2, 3):</p>
               <eg xml:space="preserve">&lt;xsl:variable name="i" as="xs:integer*" select="1 to 3"/&gt;</eg>
               <p>The value of the following variable is an integer, assuming that the attribute
                     <code>@size</code> exists, and is annotated either as an integer, or as
                     <code>xs:untypedAtomic</code>:</p>
               <eg xml:space="preserve">&lt;xsl:variable name="i" as="xs:integer" select="@size"/&gt;</eg>
               <p>The value of the following variable is a zero-length string:</p>
               <eg xml:space="preserve">&lt;xsl:variable name="z"/&gt;</eg>
               <p>The value of the following variable is a document node containing an empty element
                  as a child:</p>
               <eg xml:space="preserve">&lt;xsl:variable name="doc"&gt;&lt;c/&gt;&lt;/xsl:variable&gt;</eg>
               <p>The value of the following variable is a sequence of integers (2, 4, 6):</p>
               <eg xml:space="preserve">&lt;xsl:variable name="seq" as="xs:integer*"&gt;
  &lt;xsl:for-each select="1 to 3"&gt;
    &lt;xsl:sequence select=".*2"/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:variable&gt;</eg>
               <p>The value of the following variable is a sequence of parentless attribute nodes:</p>
               <eg xml:space="preserve">&lt;xsl:variable name="attset" as="attribute()+"&gt;
  &lt;xsl:attribute name="x"&gt;2&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="y"&gt;3&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="z"&gt;4&lt;/xsl:attribute&gt;    
&lt;/xsl:variable&gt;</eg>
               <p>The value of the following variable is an empty sequence:</p>
               <eg xml:space="preserve">&lt;xsl:variable name="empty" as="empty-sequence()"/&gt;</eg>
            </example>
            <p>The actual value of the variable depends on the <termref def="dt-supplied-value">supplied value</termref>, as described above, and the required type, which is
               determined by the value of the <code>as</code> attribute.</p>
            <example>
               <head>Pitfalls with Numeric Predicates</head>
               <p>When a variable is used to select nodes by position, be careful not to do:</p>
               <eg xml:space="preserve">&lt;xsl:variable name="n"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;</eg>
               <p>This will output the values of all the <code>td</code> elements, space-separated
                  (or <phrase diff="chg" at="D">with <termref def="dt-xslt-10-behavior">XSLT 1.0
                        behavior</termref></phrase>, the value of the first <code>td</code>
                  element), because the variable <code>n</code> will be bound to a node, not a
                  number. Instead, do one of the following:</p>
               <eg xml:space="preserve">&lt;xsl:variable name="n" select="2"/&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;</eg>
               <p>or</p>
               <eg xml:space="preserve">&lt;xsl:variable name="n"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[position()=$n]"/&gt;</eg>
               <p>or</p>
               <eg xml:space="preserve">&lt;xsl:variable name="n" as="xs:integer"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;</eg>
            </example>
         </div2>
         <div2 id="temporary-trees">
            <head>Creating implicit document nodes</head>
            <p>A document node is created implicitly when evaluating an
                  <elcode>xsl:variable</elcode>, <elcode>xsl:param</elcode>, or
                  <elcode>xsl:with-param</elcode> element that has non-empty content and that has no
                  <code>as</code> attribute. The value of the <termref def="dt-variable">variable</termref> is a single node, the document node of a <termref def="dt-temporary-tree">temporary tree</termref>. The content of the document node
               is formed from the result of evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref> contained within the variable-binding element, as
               described in <specref ref="constructing-complex-content"/>. </p>
            <note>
               <p>The construct:</p>
               <eg xml:space="preserve">&lt;xsl:variable name="tree"&gt;
  &lt;a/&gt;
&lt;/xsl:variable&gt;</eg>
               <p>can be regarded as a shorthand for:</p>
               <eg xml:space="preserve">&lt;xsl:variable name="tree" as="document-node()"&gt;
  &lt;xsl:document validation="preserve"&gt;
    &lt;a/&gt;
  &lt;/xsl:document&gt;  
&lt;/xsl:variable&gt;</eg>
            </note>
            <p>The base URI of the document node is taken from the base URI of the variable binding
               element in the stylesheet. (See <xspecref spec="DM11" ref="dm-base-uri"/> in <bibref ref="xpath-datamodel-11"/>)</p>
            <p>No document-level validation takes place (which means, for example, that there is no
               checking that ID values are unique). However, type annotations on nodes within the
               new tree are copied unchanged.</p>
            <note>
               <p>The base URI of other nodes in the tree is determined by the rules for
                  constructing complex content. The effect of these rules is that the base URI of a
                  node in the temporary tree is determined as if all the nodes in the temporary tree
                  came from a single entity whose URI was the base URI of the <termref def="dt-variable-binding-element">variable-binding element</termref>. Thus, the
                  base URI of the document node will be equal to the base URI of the
                  variable-binding element, while an <code>xml:base</code> attribute within the
                  temporary tree will change the base URI for its parent element and that element's
                  descendants, just as it would within a document constructed by parsing.</p>
            </note>
            <p>The <code>document-uri</code> and <code>unparsed-entities</code> properties of the
               new document node are set to empty.</p>
            <p>A <termref def="dt-temporary-tree">temporary tree</termref> is available for
               processing in exactly the same way as any source document. For example, its nodes are
               accessible using path expressions, and they can be processed using instructions such
               as <elcode>xsl:apply-templates</elcode> and <elcode>xsl:for-each</elcode>. Also, the
                  <function>key</function> and <xfunction>id</xfunction> functions can be used to
               find nodes within a temporary tree, <phrase diff="chg" at="D">by supplying the
                  document node at the root of the tree as an argument to the function or by making
                  it the context node</phrase>.</p>
            <example>
               <head>Two-Phase Transformation</head>
               <p>For example, the following stylesheet uses a temporary tree as the intermediate
                  result of a two-phase transformation, using different <termref def="dt-mode">modes</termref> for the two phases (see <specref ref="modes"/>). Typically,
                  the template rules in module <code>phase1.xsl</code> will be declared with
                     <code>mode="phase1"</code>, while those in module <code>phase2.xsl</code> will
                  be declared with <code>mode="phase2"</code>: </p>
               <eg xml:space="preserve">&lt;xsl:stylesheet
  version="2.1"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:import href="phase1.xsl"/&gt;
&lt;xsl:import href="phase2.xsl"/&gt;

&lt;xsl:variable name="intermediate"&gt;
  &lt;xsl:apply-templates select="/" mode="phase1"/&gt;
&lt;/xsl:variable&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:apply-templates select="$intermediate" mode="phase2"/&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg>
            </example>
            <note>
               <p>The algorithm for matching nodes against template rules is exactly the same
                  regardless which tree the nodes come from. If different template rules are to be
                  used when processing different trees, then unless nodes from different trees can
                  be distinguished by means of <termref def="dt-pattern">patterns</termref>, it is a
                  good idea to use <termref def="dt-mode">modes</termref> to ensure that each tree
                  is processed using the appropriate set of template rules.</p>
            </note>
         </div2>
         <div2 id="global-variables">
            <head>Global Variables and Parameters</head>
            <p>Both <elcode>xsl:variable</elcode> and <elcode>xsl:param</elcode> are allowed as
                  <termref def="dt-declaration">declaration</termref> elements: that is, they may
               appear as children of the <elcode>xsl:stylesheet</elcode> element.</p>
            <p>
               <termdef id="dt-global-variable" term="global variable">A top-level <termref def="dt-variable-binding-element">variable-binding element</termref> declares a
                     <term>global variable</term> that is visible everywhere (except where it is
                     <termref def="dt-shadows">shadowed</termref> by another binding).</termdef>
            </p>
            <p>
               <termdef id="dt-stylesheet-parameter" term="stylesheet parameter">A top-level
                     <elcode>xsl:param</elcode> element declares a <term>stylesheet
                  parameter</term>. A stylesheet parameter is a global variable with the additional
                  property that its value can be supplied by the caller when a transformation is
                  initiated.</termdef> As described in <specref ref="parameters"/>, a stylesheet
               parameter may be declared as being mandatory, or may have a default value specified
               for use when no value is supplied by the caller. The mechanism by which the caller
               supplies a value for a stylesheet parameter is <termref def="dt-implementation-defined">implementation-defined</termref>. An XSLT <termref def="dt-processor">processor</termref>
               <rfc2119>must</rfc2119> provide such a mechanism.</p>
            <imp-def-feature>The mechanism by which the caller supplies a value for a <termref def="dt-stylesheet-parameter"/> is <termref def="dt-implementation-defined">implementation-defined</termref>.</imp-def-feature>
            <p>It is an error if no value is supplied for a mandatory stylesheet parameter <errorref spec="XT" class="DE" code="0050"/>.</p>
            <p>If a <termref def="dt-stylesheet">stylesheet</termref> contains more than one binding
               for a global variable of a particular name, then the binding with the highest
                  <termref def="dt-import-precedence">import precedence</termref> is used.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0630">
                  <p>It is a <termref def="dt-static-error">static error</termref> if a <termref def="dt-stylesheet">stylesheet</termref> contains more than one binding of a
                     global variable with the same name and same <termref def="dt-import-precedence">import precedence</termref>, unless it also contains another binding with
                     the same name and higher import precedence.</p>
               </error>
            </p>
            <p>For a global variable or the default value of a stylesheet parameter, the <termref def="dt-expression">expression</termref> or <termref def="dt-sequence-constructor">sequence constructor</termref> specifying the variable value is evaluated with a
                  <termref def="dt-singleton-focus">singleton focus</termref> based on the root node
               of the tree containing the <phrase diff="chg" at="E"><termref def="dt-initial-context-item"/></phrase>. An XPath error will be reported if
               the evaluation of a global variable or parameter references the context item, context
               position, or context size when no initial context item is supplied. The values of
               other components of the dynamic context are the initial values as defined in <specref ref="xpath-dynamic-context"/> and <specref ref="additional-dynamic-context"/>.</p>
            <example>
               <head>A Stylesheet Parameter</head>
               <p>The following example declares a global parameter <code>para-font-size</code>,
                  which is referenced in an <termref def="dt-attribute-value-template">attribute
                     value template</termref>.</p>
               <eg xml:space="preserve">&lt;xsl:param name="para-font-size" as="xs:string"&gt;12pt&lt;/xsl:param&gt;

&lt;xsl:template match="para"&gt;
 &lt;fo:block font-size="{$para-font-size}"&gt;
   &lt;xsl:apply-templates/&gt;
 &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</eg>
               <p>The implementation must provide a mechanism allowing the user to supply a value
                  for the parameter <code>para-font-size</code> when invoking the stylesheet; the
                  value <code>12pt</code> acts as a default.</p>
            </example>
         </div2>
         <div2 id="local-variables">
            <head>Local Variables and Parameters</head>
            <p>
               <termdef id="dt-local-variable" term="local variable">As well as being allowed as a
                     <termref def="dt-declaration">declaration</termref>, the
                     <elcode>xsl:variable</elcode> element is also allowed in <termref def="dt-sequence-constructor">sequence constructors</termref>. Such a variable
                  is known as a <term>local variable</term>.</termdef>
            </p>
            <p>An <elcode>xsl:param</elcode> element may also be used to create a variable binding
               with local scope:</p>
            <ulist>
               <item>
                  <p>
                     <termdef id="dt-template-parameter" term="template parameter"> An
                           <elcode>xsl:param</elcode> element may appear as a child of an
                           <elcode>xsl:template</elcode> element, before any
                           non-<elcode>xsl:param</elcode> children of that element. Such a parameter
                        is known as a <term>template parameter</term>. A template parameter is a
                           <termref def="dt-local-variable">local variable</termref> with the
                        additional property that its value can be set when the template is called,
                        using any of the instructions <elcode>xsl:call-template</elcode>,
                           <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>,
                        or <elcode>xsl:next-match</elcode>.</termdef>
                  </p>
               </item>
               <item>
                  <p>
                     <termdef id="dt-function-parameter" term="function parameter"> An
                           <elcode>xsl:param</elcode> element may appear as a child of an
                           <elcode>xsl:function</elcode> element, before any
                           non-<elcode>xsl:param</elcode> children of that element. Such a parameter
                        is known as a <term>function parameter</term>. A function parameter is a
                           <termref def="dt-local-variable">local variable</termref> with the
                        additional property that its value can be set when the function is called,
                        using a function call in an XPath <termref def="dt-expression">expression</termref>.</termdef>
                  </p>
               </item>
               <item>
                  <p diff="add" at="D">An <elcode>xsl:param</elcode> element may appear as a child
                     of an <elcode>xsl:iterate</elcode> instruction, before any
                        non-<elcode>xsl:param</elcode> children of that element. This defines a
                     parameter whose value may be initialized on entry to the iteration, and which
                     may be varied each time round the iteration by use of an
                        <elcode>xsl:with-param</elcode> element in the
                        <elcode>xsl:next-iteration</elcode> instruction. </p>
               </item>
            </ulist>
            <p>The result of evaluating a local <elcode>xsl:variable</elcode> or
                  <elcode>xsl:param</elcode> element (that is, the contribution it makes to the
               result of the <termref def="dt-sequence-constructor">sequence constructor</termref>
               it is part of) is an empty sequence.</p>
         </div2>
         <div2 id="scope-of-variables">
            <head>Scope of Variables</head>
            <p>For any <termref def="dt-variable-binding-element">variable-binding
               element</termref>, there is a region (more specifically, a set of element nodes) of
               the <termref def="dt-stylesheet">stylesheet</termref> within which the binding is
               visible. The set of variable bindings in scope for an XPath <termref def="dt-expression">expression</termref> consists of those bindings that are
               visible at the point in the stylesheet where the expression occurs.</p>
            <p>A global <termref def="dt-variable-binding-element">variable binding
                  element</termref> is visible everywhere in the <termref def="dt-stylesheet">stylesheet</termref> (including other <termref def="dt-stylesheet-module">stylesheet modules</termref>) except within the <elcode>xsl:variable</elcode> or
                  <elcode>xsl:param</elcode> element itself and any region where it is <termref def="dt-shadows">shadowed</termref> by another variable binding.</p>
            <p>A local <termref def="dt-variable-binding-element">variable binding element</termref>
               is visible for all following siblings and their descendants, with <phrase diff="chg" at="B">the following</phrase> exceptions:</p>
            <olist>
               <item>
                  <p>It is not visible in any region where it is <termref def="dt-shadows">shadowed</termref> by another variable binding.</p>
               </item>
               <item>
                  <p>It is not visible within the subtree rooted at an <elcode>xsl:fallback</elcode>
                     instruction that is a sibling of the variable binding element.</p>
               </item>
               <item>
                  <p diff="add" at="B">It is not visible within the subtree rooted at an
                        <elcode>xsl:catch</elcode> instruction that is a sibling of the variable
                     binding element.</p>
               </item>
            </olist>
            <p>The binding is not visible for the <elcode>xsl:variable</elcode> or
                  <elcode>xsl:param</elcode> element itself.</p>
            <p>
               <termdef id="dt-shadows" term="shadows">A binding <term>shadows</term> another
                  binding if the binding occurs at a point where the other binding is visible, and
                  the bindings have the same name. </termdef> It is not an error if a binding
               established by a local <elcode>xsl:variable</elcode> or <elcode>xsl:param</elcode>
               <termref def="dt-shadows">shadows</termref> a global binding. In this case, the
               global binding will not be visible in the region of the <termref def="dt-stylesheet">stylesheet</termref> where it is shadowed by the other binding.</p>
            <example>
               <head>Local Variable Shadowing a Global Variable</head>
               <p>The following is allowed:</p>
               <eg xml:space="preserve">&lt;xsl:param name="x" select="1"/&gt;
&lt;xsl:template name="foo"&gt;
  &lt;xsl:variable name="x" select="2"/&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <p>It is also not an error if a binding established by a local
                  <elcode>xsl:variable</elcode> element <termref def="dt-shadows">shadows</termref>
               a binding established by another local <elcode>xsl:variable</elcode> or
                  <elcode>xsl:param</elcode>.</p>
            <example>
               <head>Misuse of Variable Shadowing</head>
               <p>The following is not an error, but the effect is probably not what was intended.
                  The template outputs <code>&lt;x value="1"/&gt;</code>, because the declaration of
                  the inner variable named <code>$x</code> has no effect on the value of the outer
                  variable named <code>$x</code>.</p>
               <eg xml:space="preserve">&lt;xsl:variable name="x" select="1"/&gt;
&lt;xsl:template name="foo"&gt;
  &lt;xsl:for-each select="1 to 5"&gt;
    &lt;xsl:variable name="x" select="$x+1"/&gt;
  &lt;/xsl:for-each&gt;
  &lt;x value="{$x}"/&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <note>
               <p>Once a variable has been given a value, the value cannot subsequently be changed.
                  XSLT does not provide an equivalent to the assignment operator available in many
                  procedural programming languages. </p>
               <p>This is because an assignment operator would make it harder to create an
                  implementation that processes a document other than in a batch-like way, starting
                  at the beginning and continuing through to the end.</p>
            </note>
            <p>As well as global variables and local variables, an XPath <termref def="dt-expression">expression</termref> may also declare range variables for use
               locally within an expression. For details, see <bibref ref="xpath-21"/>.</p>
            <p>Where a reference to a variable occurs in an XPath expression, it is resolved first
               by reference to range variables that are in scope, then by reference to local
               variables and parameters, and finally by reference to global variables and
               parameters. A range variable may shadow a local variable or a global variable. XPath
               also allows a range variable to shadow another range variable.</p>
         </div2>
         <div2 id="with-param">
            <head>Setting Parameter Values</head>
            <e:element-syntax name="with-param">
               <e:attribute name="name" required="yes">
                  <e:data-type name="qname"/>
               </e:attribute>
               <e:attribute name="select">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="as">
                  <e:data-type name="sequence-type"/>
               </e:attribute>
               <e:attribute name="tunnel">
                  <e:constant value="yes"/>
                  <e:constant value="no"/>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent name="apply-templates"/>
                  <e:parent name="apply-imports"/>
                  <e:parent name="call-template"/>
                  <e:parent name="next-match"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>Parameters are passed to templates using the <elcode>xsl:with-param</elcode> element.
               The <rfc2119>required</rfc2119>
               <code>name</code> attribute specifies the name of the <termref def="dt-template-parameter">template parameter</termref> (the variable the value
               of whose binding is to be replaced). The value of the <code>name</code> attribute is
               a <termref def="dt-qname">QName</termref>, which is expanded as described in <specref ref="qname"/>.</p>
            <p><phrase diff="add" at="D">The <elcode>xsl:with-param</elcode> element is also used
                  when passing parameters to an iteration of the <elcode>xsl:iterate</elcode>
                  instruction, or to a dynamic invocation of an XPath expression using
                     <elcode>xsl:evaluate</elcode>. In consequence, </phrase>
               <elcode>xsl:with-param</elcode> may appear within 
                  <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>, 
               <elcode>xsl:call-template</elcode>, <phrase diff="add" at="B"><elcode>xsl:evaluate</elcode>,
                     <elcode>xsl:next-iteration</elcode>, </phrase> and
                  <elcode>xsl:next-match</elcode>. (Arguments to <termref def="dt-stylesheet-function">stylesheet functions</termref>, however, are supplied
               as part of an XPath function call: see <specref ref="stylesheet-functions"/>.) </p>
            <p>
               <error spec="XT" type="static" class="SE" code="0670">
                  <p diff="chg" at="B">It is a <termref def="dt-static-error">static error</termref>
                     if two or more sibling <elcode>xsl:with-param</elcode> elements have
                        <code>name</code> attributes that represent the same <termref def="dt-expanded-qname">expanded QName</termref>.</p>
               </error>
            </p>
            <p>The value of the parameter is specified in the same way as for
                  <elcode>xsl:variable</elcode> and <elcode>xsl:param</elcode> (see <specref ref="variable-values"/>), taking account of the values of the <code>select</code>
               and <code>as</code> attributes and the content of the <elcode>xsl:with-param</elcode>
               element, if any.</p>
            <note>
               <p>It is possible to have an <code>as</code> attribute on the
                     <elcode>xsl:with-param</elcode> element that differs from the <code>as</code>
                  attribute on the corresponding <elcode>xsl:param</elcode> element<phrase diff="del" at="D"> describing the formal parameters of the called
                     template</phrase>.</p>
               <p>In this situation, the supplied value of the parameter will first be processed
                  according to the rules of the <code>as</code> attribute on the
                     <elcode>xsl:with-param</elcode> element, and the resulting value will then be
                  further processed according to the rules of the <code>as</code> attribute on the
                     <elcode>xsl:param</elcode> element.</p>
               <p>For example, suppose the supplied value is a node with <termref def="dt-annotation">type annotation</termref>
                  <code>xs:untypedAtomic</code>, and the <elcode>xsl:with-param</elcode> element
                  specifies <code>as="xs:integer"</code>, while the <elcode>xsl:param</elcode>
                  element specifies <code>as="xs:double"</code>. Then the node will first be
                  atomized and the resulting untyped atomic value will be cast to
                     <code>xs:integer</code>. If this succeeds, the <code>xs:integer</code> will
                  then be promoted to an <code>xs:double</code>.</p>
            </note>
            <p>The <termref def="dt-focus">focus</termref> used for computing the value specified by
               the <elcode>xsl:with-param</elcode> element is the same as that used for <phrase diff="chg" at="B">its parent <termref def="dt-instruction">instruction</termref></phrase>.</p>

            <p>The optional <code>tunnel</code> attribute may be used to indicate that a parameter
               is a <termref def="dt-tunnel-parameter">tunnel parameter</termref>. The default is
                  <code>no</code>. Tunnel parameters are described in <specref ref="tunnel-params"/>. They are used only when passing parameters to templates: for an
                  <elcode>xsl:with-param</elcode> element that is a child of
                  <elcode>xsl:evaluate</elcode> or <elcode>xsl:next-iteration</elcode> the
                  <code>tunnel</code> attribute <rfc2119>must</rfc2119> either be omitted or take
               the value <code>no</code>. </p>

            <p>
               
                  In other cases it is a <termref def="dt-nonrec-dynamic-error">non-recoverable
                        dynamic error</termref> if the template that is invoked declares a <termref def="dt-template-parameter">template parameter</termref> with
                        <code>required="yes"</code> and no value for this parameter is supplied by
               the calling instruction. <errorref spec="XT" class="DE" code="0700"/> 
               
            </p>

         </div2>
         <div2 id="circularity">
            <head>Circular Definitions</head>
            <p>
               <termdef id="dt-circularity" term="circularity">A <term>circularity</term> is said to
                  exist if a construct such as a <termref def="dt-global-variable">global
                     variable</termref>, an <termref def="dt-attribute-set">attribute set</termref>,
                  or a <termref def="dt-key">key</termref>,
                  
                  is defined in terms of itself. For example, if the <termref def="dt-expression">expression</termref> or <termref def="dt-sequence-constructor">sequence
                     constructor</termref> specifying the value of a <termref def="dt-global-variable">global variable</termref>
                  <var>X</var> references a global variable <var>Y</var>, then the value for
                     <var>Y</var>
                  <rfc2119>must</rfc2119> be computed before the value of <var>X</var>. A
                  circularity exists if it is impossible to do this for all global variable
                  definitions.</termdef>
            </p>
            <example>
               <head>Circular Variable Definitions</head>
               <p>The following two declarations create a circularity:</p>
               <eg role="error" xml:space="preserve">&lt;xsl:variable name="x" select="$y+1"/&gt;
&lt;xsl:variable name="y" select="$x+1"/&gt;</eg>
            </example>
            <example>
               <head>Circularity involving Variables and Functions</head>
               <p>The definition of a global variable can be circular even if no other variable is
                  involved. For example the following two declarations (see <specref ref="stylesheet-functions"/> for an explanation of the
                     <elcode>xsl:function</elcode> element) also create a circularity:</p>
               <eg role="error" xml:space="preserve">&lt;xsl:variable name="x" select="my:f()"/&gt;

&lt;xsl:function name="my:f"&gt;
  &lt;xsl:sequence select="$x"/&gt;
&lt;/xsl:function&gt;
</eg>
            </example>
            <example>
               <head>Circularity involving Variables and Templates</head>
               <p>The definition of a variable is also circular if the evaluation of the variable
                  invokes an <elcode>xsl:apply-templates</elcode> instruction and the variable is
                  referenced in the pattern used in the <code>match</code> attribute of any template
                  rule in the <termref def="dt-stylesheet">stylesheet</termref>. For example the
                  following definition is circular:</p>
               <eg role="error" xml:space="preserve">&lt;xsl:variable name="x"&gt;
  &lt;xsl:apply-templates select="//param[1]"/&gt;
&lt;/xsl:variable&gt;

&lt;xsl:template match="param[$x]"&gt;1&lt;/xsl:template&gt;
</eg>
            </example>
            <example>
               <head>Circularity involving Variables and Keys</head>
               <p>Similarly, a variable definition is circular if it causes a call on the
                     <function>key</function> function, and the definition of that <termref def="key">key</termref> refers to that variable in its <code>match</code> or
                     <code>use</code> attributes. So the following definition is circular:</p>
               <eg role="error" xml:space="preserve">&lt;xsl:variable name="x" select="my:f(10)"/&gt;

&lt;xsl:function name="my:f"&gt;
  &lt;xsl:param name="arg1"/&gt;
  &lt;xsl:sequence select="key('k', $arg1)"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:key name="k" match="item[@code=$x]" use="@desc"/&gt;
</eg>
            </example>
            
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0640">
                  <p>In general, a <termref def="dt-circularity">circularity</termref> in a <termref def="dt-stylesheet">stylesheet</termref> is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>.</p>
               </error> However, as with all other dynamic errors, an implementation will signal the
               error only if it actually executes the instructions and expressions that participate
               in the circularity. Because different implementations may optimize the execution of a
               stylesheet in different ways, it is <termref def="dt-implementation-dependent">implementation-dependent</termref> whether a particular circularity will actually
               be signaled.</p>
            <p>For example, in the following declarations, the function declares a local variable
                  <code>$b</code>, but it returns a result that does not require the variable to be
               evaluated. It is <termref def="dt-implementation-dependent">implementation-dependent</termref> whether the value is actually evaluated, and
               it is therefore implementation-dependent whether the circularity is signaled as an
               error:</p>
            <eg role="error" xml:space="preserve">&lt;xsl:variable name="x" select="my:f(1)/&gt;

&lt;xsl:function name="my:f"&gt;
  &lt;xsl:param name="a"/&gt;
  &lt;xsl:variable name="b" select="$x"/&gt;  
  &lt;xsl:sequence select="$a + 2"/&gt;
&lt;/xsl:function&gt;
</eg>
            <p>Circularities usually involve global variables or parameters, but they can also exist
               between <termref def="key">key</termref> definitions (see <specref ref="key"/>),
               between named <termref def="dt-attribute-set">attribute sets</termref> (see <specref ref="attribute-sets"/>), or between any combination of these constructs. For
               example, a circularity exists if a key definition invokes a function that references
               an attribute set that calls the <function>key</function> function, supplying the name
               of the original key definition as an argument.</p>
            <p>Circularity is not the same as recursion. Stylesheet functions (see <specref ref="stylesheet-functions"/>) and named templates (see <specref ref="named-templates"/>) may call other functions and named templates without
               restriction. With careless coding, recursion may be non-terminating. Implementations
               are <rfc2119>required</rfc2119> to signal circularity as a <termref def="dt-dynamic-error">dynamic error</termref>, but they are not
                  <rfc2119>required</rfc2119> to detect non-terminating recursion.</p>
         </div2>
      </div1>
      <div1 id="callable-components">
         <head>Callable Components</head>
         <p>This section describes three constructs that can be used to provide subroutine-like
            functionality that can be invoked from anywhere in the stylesheet: named templates (see
               <specref ref="named-templates"/>), named attribute sets (see <specref ref="attribute-sets"/>), and <termref def="dt-stylesheet-function">stylesheet
               functions</termref> (see <specref ref="stylesheet-functions"/>).</p>
         <div2 id="named-templates">
            <head>Named Templates</head>
            <e:element-syntax name="call-template">
               <e:in-category name="instruction"/>
               <e:attribute name="name" required="yes">
                  <e:data-type name="qname"/>
               </e:attribute>
               <e:element repeat="zero-or-more" name="with-param"/>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>
               <termdef id="dt-named-template" term="named template">Templates can be invoked by
                  name. An <elcode>xsl:template</elcode> element with a <code>name</code> attribute
                  defines a <term>named template</term>.</termdef> The value of the
                  <code>name</code> attribute is a <termref def="dt-qname">QName</termref>, which is
               expanded as described in <specref ref="qname"/>. If an <elcode>xsl:template</elcode>
               element has a <code>name</code> attribute, it may, but need not, also have a
                  <code>match</code> attribute. An <elcode>xsl:call-template</elcode> instruction
               invokes a template by name; it has a <rfc2119>required</rfc2119>
               <code>name</code> attribute that identifies the template to be invoked. Unlike
                  <elcode>xsl:apply-templates</elcode>, the <elcode>xsl:call-template</elcode>
               instruction does not change the <termref def="dt-focus">focus</termref>.</p>
            <p>The <code>match</code>, <code>mode</code> and <code>priority</code> attributes on an
                  <elcode>xsl:template</elcode> element have no effect when the <termref def="dt-template">template</termref> is invoked by an
                  <elcode>xsl:call-template</elcode> instruction. Similarly, the <code>name</code>
               attribute on an <elcode>xsl:template</elcode> element has no effect when the template
               is invoked by an <elcode>xsl:apply-templates</elcode> instruction.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0650">
                  <p>It is a <termref def="dt-static-error">static error</termref> if a <termref def="dt-stylesheet">stylesheet</termref> contains an
                        <elcode>xsl:call-template</elcode> instruction whose <code>name</code>
                     attribute does not match the <code>name</code> attribute of any
                        <elcode>xsl:template</elcode> in the <termref def="dt-stylesheet">stylesheet</termref>.</p>
               </error>
            </p>
            <p>
               <error spec="XT" type="static" class="SE" code="0660">
                  <p>It is a <termref def="dt-static-error">static error</termref> if a <termref def="dt-stylesheet">stylesheet</termref> contains more than one <termref def="dt-template">template</termref> with the same name and the same
                        <termref def="dt-import-precedence">import precedence</termref>, unless it
                     also contains a <termref def="dt-template">template</termref> with the same
                     name and higher <termref def="dt-import-precedence">import
                     precedence</termref>.</p>
               </error>
            </p>
            <p>The target <termref def="dt-template">template</termref> for an
                  <elcode>xsl:call-template</elcode> instruction is the template whose
                  <code>name</code> attribute matches the <code>name</code> attribute of the
                  <elcode>xsl:call-template</elcode> instruction and that has higher <termref def="dt-import-precedence">import precedence</termref> than any other template
               with this name. The result of evaluating an <elcode>xsl:call-template</elcode>
               instruction is the sequence produced by evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref> contained in its
               target <termref def="dt-template">template</termref> (see <specref ref="sequence-constructors"/>).</p>
            <div3 id="call-template-params">
               <head>Passing Parameters to Named Templates</head>

               <p>Parameters are passed to named templates using the <elcode>xsl:with-param</elcode>
                  element as a child of the <elcode>xsl:call-template</elcode> instruction.</p>

               <p>
                  <error spec="XT" type="static" class="SE" code="0680">
                     <p>In the case of <elcode>xsl:call-template</elcode>, it is a <termref def="dt-static-error">static error</termref> to pass a non-tunnel
                        parameter named <var>x</var> to a template that does not have a <termref def="dt-template-parameter">template parameter</termref> named
                           <var>x</var>, unless <phrase diff="chg" at="D">the
                              <elcode>xsl:call-template</elcode> instruction is processed with
                              <termref def="dt-xslt-10-behavior">XSLT 1.0
                           behavior</termref></phrase>.</p>
                  </error> This is not an error in the case of <elcode>xsl:apply-templates</elcode>,
                     <elcode>xsl:apply-imports</elcode>, and <elcode>xsl:next-match</elcode>; in
                  these cases the parameter is simply ignored.</p>
               <p>The optional <code>tunnel</code> attribute may be used to indicate that a
                  parameter is a <termref def="dt-tunnel-parameter">tunnel parameter</termref>. The
                  default is <code>no</code>. Tunnel parameters are described in <specref ref="tunnel-params"/>
               </p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0690">
                     <p>It is a <termref def="dt-static-error">static error</termref> if a template
                        that is invoked using <elcode>xsl:call-template</elcode> declares a <termref def="dt-template-parameter">template parameter</termref> specifying
                           <code>required="yes"</code> and not specifying <code>tunnel="yes"</code>,
                        if no value for this parameter is supplied by the calling
                           <elcode>xsl:call-template</elcode> instruction.</p>
                  </error>
               </p>


               <example>
                  <head>Calling a Named Template with a Parameter</head>
                  <p>This example defines a named template for a <code>numbered-block</code> with a
                     parameter to control the format of the number.</p>
                  <eg xml:space="preserve">&lt;xsl:template name="numbered-block"&gt;
  &lt;xsl:param name="format"&gt;1. &lt;/xsl:param&gt;
  &lt;fo:block&gt;
    &lt;xsl:number format="{$format}"/&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="ol//ol/li"&gt;
  &lt;xsl:call-template name="numbered-block"&gt;
    &lt;xsl:with-param name="format"&gt;a. &lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;</eg>
               </example>

            </div3>
            <div3 id="tunnel-params">
               <head>Tunnel Parameters</head>
               <p>
                  <termdef id="dt-tunnel-parameter" term="tunnel parameter">A parameter passed to a
                     template may be defined as a <term>tunnel parameter</term>. Tunnel parameters
                     have the property that they are automatically passed on by the called template
                     to any further templates that it calls, and so on recursively.</termdef> Tunnel
                  parameters thus allow values to be set that are accessible during an entire phase
                  of stylesheet processing, without the need for each template that is used during
                  that phase to be aware of the parameter.</p>
               <note>
                  <p>Tunnel parameters are conceptually similar to dynamically scoped variables in
                     some functional programming languages.</p>
               </note>
               <p>A <termref def="dt-tunnel-parameter">tunnel parameter</termref> is created by
                  using an <elcode>xsl:with-param</elcode> element that specifies
                     <code>tunnel="yes"</code>. A template that requires access to the value of a
                  tunnel parameter must declare it using an <elcode>xsl:param</elcode> element that
                  also specifies <code>tunnel="yes"</code>.</p>
               <p>On any template call using an <elcode>xsl:apply-templates</elcode>,
                     <elcode>xsl:call-template</elcode>, <elcode>xsl:apply-imports</elcode> or
                     <elcode>xsl:next-match</elcode> instruction, a set of <termref def="dt-tunnel-parameter">tunnel parameters</termref> is passed from the
                  calling template to the called template. This set consists of any parameters
                  explicitly created using <code>&lt;xsl:with-param tunnel="yes"&gt;</code>,
                  overlaid on a base set of tunnel parameters. If the
                     <elcode>xsl:apply-templates</elcode>, <elcode>xsl:call-template</elcode>,
                     <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode>
                  instruction has an <elcode>xsl:template</elcode> declaration as an ancestor
                  element in the stylesheet, then the base set consists of the tunnel parameters
                  that were passed to that template; otherwise (for example, if the instruction is
                  within a global variable declaration, an <termref def="dt-attribute-set">attribute
                     set</termref> declaration, or a <termref def="dt-stylesheet-function">stylesheet function</termref>), the base set is empty. If a parameter created
                  using <code>&lt;xsl:with-param tunnel="yes"&gt;</code> has the same <termref def="dt-expanded-qname">expanded-QName</termref> as a parameter in the base
                  set, then the parameter created using <elcode>xsl:with-param</elcode> overrides
                  the parameter in the base set; otherwise, the parameter created using
                     <elcode>xsl:with-param</elcode> is added to the base set.</p>
               <p>When a template accesses the value of a <termref def="dt-tunnel-parameter">tunnel
                     parameter</termref> by declaring it with <code>xsl:param tunnel="yes"</code>,
                  this does not remove the parameter from the base set of tunnel parameters that is
                  passed on to any templates called by this template.</p>
               <p>Two sibling <elcode>xsl:with-param</elcode> elements <rfc2119>must</rfc2119> have
                  distinct parameter names, even if one is a <termref def="dt-tunnel-parameter">tunnel parameter</termref> and the other is not. Equally, two sibling
                     <elcode>xsl:param</elcode> elements representing <termref def="dt-template-parameter">template parameters</termref>
                  <rfc2119>must</rfc2119> have distinct parameter names, even if one is a <termref def="dt-tunnel-parameter">tunnel parameter</termref> and the other is not.
                  However, the tunnel parameters that are implicitly passed in a template call
                     <rfc2119>may</rfc2119> have names that duplicate the names of non-tunnel
                  parameters that are explicitly passed on the same call.</p>
               <p>
                  <termref def="dt-tunnel-parameter">Tunnel parameters</termref> are not passed in
                  calls to <termref def="dt-stylesheet-function">stylesheet functions</termref>.</p>
               <p>All other options of <elcode>xsl:with-param</elcode> and
                     <elcode>xsl:param</elcode> are available with <termref def="dt-tunnel-parameter">tunnel parameters</termref> just as with non-tunnel
                  parameters. For example, parameters may be declared as mandatory or optional, a
                  default value may be specified, and a required type may be specified. If any
                  conversion is required from the supplied value of a tunnel parameter to the
                  required type specified in <elcode>xsl:param</elcode>, then the converted value is
                  used within the receiving template, but the value that is passed on in any further
                  template calls is the original supplied value before conversion. Equally, any
                  default value is local to the template: specifying a default value for a tunnel
                  parameter does not change the set of tunnel parameters that is passed on in
                  further template calls.</p>
               <p>The set of <termref def="dt-tunnel-parameter">tunnel parameters</termref> that is
                  passed to the <termref def="dt-initial-template">initial template</termref> is
                  empty.</p>
               <p>
                  <termref def="dt-tunnel-parameter">Tunnel parameters</termref> are passed
                  unchanged through a built-in template rule (see <specref ref="built-in-rule"/>).</p>
               <p diff="add" at="D">If a tunnel parameter is declared in an
                     <elcode>xsl:param</elcode> element with the attribute
                  <code>tunnel="yes"</code>, then a non-recoverable dynamic error occurs <errorref spec="XT" class="DE" code="0700"/> if the set of tunnel parameters passed to
                  the template does not include a parameter with a matching <termref def="dt-expanded-qname">expanded QName</termref>.</p>
               <example>
                  <head>Using Tunnel Parameters</head>
                  <p>Suppose that the equations in a scientific paper are to be sequentially
                     numbered, but that the format of the number depends on the context in which the
                     equations appear. It is possible to reflect this using a rule of the form:</p>
                  <eg xml:space="preserve">&lt;xsl:template match="equation"&gt;
  &lt;xsl:param name="equation-format" select="'(1)'" tunnel="yes"/&gt;
  &lt;xsl:number level="any" format="{$equation-format}"/&gt;
&lt;/xsl:template&gt;</eg>
                  <p>At any level of processing above this level, it is possible to determine how
                     the equations will be numbered, for example:</p>
                  <eg xml:space="preserve">&lt;xsl:template match="appendix"&gt;
  ...
  &lt;xsl:apply-templates&gt;
    &lt;xsl:with-param name="equation-format" select="'[i]'" tunnel="yes"/&gt;
  &lt;/xsl:apply-templates&gt;
  ...
&lt;/xsl:template&gt;</eg>
                  <p>The parameter value is passed transparently through all the intermediate layers
                     of template rules until it reaches the rule with <code>match="equation"</code>.
                     The effect is similar to using a global variable, except that the parameter can
                     take different values during different phases of the transformation.</p>
               </example>
            </div3>
         </div2>
         <div2 id="attribute-sets">
            <head>Named Attribute Sets</head>
            <e:element-syntax name="attribute-set">
               <e:in-category name="declaration"/>
               <e:attribute name="name" required="yes">
                  <e:data-type name="qname"/>
               </e:attribute>
               <e:attribute name="use-attribute-sets">
                  <e:data-type name="qnames"/>
               </e:attribute>
               <e:element repeat="zero-or-more" name="attribute"/>
               <e:allowed-parents>
                  <e:parent name="stylesheet"/>
                  <e:parent name="transform"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>
               <termdef id="dt-attribute-set" term="attribute set">The
                     <elcode>xsl:attribute-set</elcode> element defines a named <term>attribute
                     set</term>: that is, a collection of attribute definitions that can be used
                  repeatedly on different constructed elements.</termdef>
            </p>
            <p>The <rfc2119>required</rfc2119>
               <code>name</code> attribute specifies the name of the attribute set. The value of the
                  <code>name</code> attribute is a <termref def="dt-qname">QName</termref>, which is
               expanded as described in <specref ref="qname"/>. The content of the
                  <elcode>xsl:attribute-set</elcode> element consists of zero or more
                  <elcode>xsl:attribute</elcode> instructions that are evaluated to produce the
               attributes in the set.</p>
            <p>The result of evaluating an attribute set is a sequence of attribute nodes.
               Evaluating the same attribute set more than once can produce different results,
               because although an attribute set does not have parameters, it may contain
               expressions or instructions whose value depends on the evaluation context.</p>
            <p>
               <termref def="dt-attribute-set">Attribute sets</termref> are used by specifying a
                  <code>use-attribute-sets</code> attribute on the <elcode>xsl:element</elcode> or
                  <elcode>xsl:copy</elcode> instruction, or by specifying an
                  <code>xsl:use-attribute-sets</code> attribute on a literal result element. An
               attribute set may be defined in terms of other attribute sets by using the
                  <code>use-attribute-sets</code> attribute on the
                  <elcode>xsl:attribute-set</elcode> element itself. The value of the
                  <code>[xsl:]use-attribute-sets</code> attribute is in each case a
               whitespace-separated list of names of attribute sets. Each name is specified as a
                  <termref def="dt-qname">QName</termref>, which is expanded as described in
                  <specref ref="qname"/>.</p>
            <p>Specifying a <code>use-attribute-sets</code> attribute is broadly equivalent to
               adding <elcode>xsl:attribute</elcode> instructions for each of the attributes in each
               of the named attribute sets to the beginning of the content of the instruction with
               the <code>[xsl:]use-attribute-sets</code> attribute, in the same order in which the
               names of the attribute sets are specified in the <code>use-attribute-sets</code>
               attribute.</p>
            <p>More formally, an <code>xsl:use-attribute-sets</code> attribute is expanded using the
               following recursive algorithm, or any algorithm that produces the same results:</p>
            <ulist>
               <item>
                  <p>The value of the attribute is tokenized as a list of QNames.</p>
               </item>
               <item>
                  <p>Each QName in the list is processed, in order, as follows:</p>
                  <ulist>
                     <item>
                        <p>The QName must match the <code>name</code> attribute of one or more
                              <elcode>xsl:attribute-set</elcode> declarations in the stylesheet.</p>
                     </item>
                     <item>
                        <p>Each <elcode>xsl:attribute-set</elcode> declaration whose name matches is
                           processed as follows. Where two such declarations have different <termref def="dt-import-precedence">import precedence</termref>, the one with
                           lower import precedence is processed first. Where two declarations have
                           the same import precedence, they are processed in <termref def="dt-declaration-order">declaration order</termref>.</p>
                        <ulist>
                           <item>
                              <p>If the <elcode>xsl:attribute-set</elcode> declaration has a
                                    <code>use-attribute-sets</code> attribute, the attribute is
                                 expanded by applying this algorithm recursively.</p>
                           </item>
                           <item>
                              <p>If the <elcode>xsl:attribute-set</elcode> declaration contains one
                                 or more <elcode>xsl:attribute</elcode> instructions, these
                                 instructions are evaluated (following the rules for evaluating a
                                    <termref def="dt-sequence-constructor">sequence
                                    constructor</termref>: see <specref ref="sequence-constructors"/>) to produce a sequence of attribute nodes. These attribute nodes
                                 are appended to the result sequence.</p>
                           </item>
                        </ulist>
                     </item>
                  </ulist>
               </item>
            </ulist>
            <p>The <elcode>xsl:attribute</elcode> instructions are evaluated using the same <termref def="dt-focus">focus</termref> as is used for evaluating the element that is the
               parent of the <code>[xsl:]use-attribute-sets</code> attribute forming the initial
               input to the algorithm. However, the static context for the evaluation depends on the
               position of the <elcode>xsl:attribute</elcode> instruction in the stylesheet: thus,
               only local variables declared within an <elcode>xsl:attribute</elcode> instruction,
               and global variables, are visible.</p>
            <p>The set of attribute nodes produced by expanding <code>xsl:use-attribute-sets</code>
               may include several attributes with the same name. When the attributes are added to
               an element node, only the last of the duplicates will take effect.</p>
            <p>The way in which each instruction uses the results of expanding the
                  <code>[xsl:]use-attribute-sets</code> attribute is described in the specification
               for the relevant instruction: see <specref ref="literal-result-element"/>, <specref ref="xsl-element"/>, and <specref ref="copying"/>.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0710">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the value of
                     the <code>use-attribute-sets</code> attribute of an <elcode>xsl:copy</elcode>,
                        <elcode>xsl:element</elcode>, or <elcode>xsl:attribute-set</elcode> element,
                     or the <code>xsl:use-attribute-sets</code> attribute of a <termref def="dt-literal-result-element">literal result element</termref>, is not a
                     whitespace-separated sequence of <termref def="dt-qname">QNames</termref>, or
                     if it contains a QName that does not match the <code>name</code> attribute of
                     any <elcode>xsl:attribute-set</elcode> declaration in the stylesheet.</p>
               </error>
            </p>
            <p>
               <error spec="XT" type="static" class="SE" code="0720">
                  <p>It is a <termref def="dt-static-error">static error</termref> if an
                        <elcode>xsl:attribute-set</elcode> element directly or indirectly references
                     itself via the names contained in the <code>use-attribute-sets</code>
                     attribute.</p>
               </error>
            </p>
            <p>Each attribute node produced by expanding an attribute set has a <termref def="dt-annotation">type annotation</termref> determined by the rules for the
                  <elcode>xsl:attribute</elcode> instruction that created the attribute node: see
                  <specref ref="annotation-for-constructed-attribute"/>. These type annotations may
               be preserved, stripped, or replaced as determined by the rules for the instruction
               that creates the element in which the attributes are used.</p>
            <p>Attribute sets are used as follows:</p>
            <ulist>
               <item>
                  <p>The <elcode>xsl:copy</elcode> and <elcode>xsl:element</elcode> instructions
                     have an <code>use-attribute-sets</code> attribute. The sequence of attribute
                     nodes produced by evaluating this attribute is prepended to the sequence
                     produced by evaluating the <termref def="dt-sequence-constructor">sequence
                        constructor</termref> contained within the instruction.</p>
               </item>
               <item>
                  <p>
                     <termref def="dt-literal-result-element">Literal result elements</termref>
                     allow an <code>xsl:use-attribute-sets</code> attribute, which is evaluated in
                     the same way as the <code>use-attribute-sets</code> attribute of
                        <elcode>xsl:element</elcode> and <elcode>xsl:copy</elcode>. The sequence of
                     attribute nodes produced by evaluating this attribute is prepended to the
                     sequence of attribute nodes produced by evaluating the attributes of the
                     literal result element, which in turn is prepended to the sequence produced by
                     evaluating the <termref def="dt-sequence-constructor">sequence
                        constructor</termref> contained with the literal result element.</p>
               </item>
            </ulist>
            <example>
               <head>Using Attribute Sets</head>
               <p>The following example creates a named <termref def="dt-attribute-set">attribute
                     set</termref>
                  <code>title-style</code> and uses it in a <termref def="dt-template-rule">template
                     rule</termref>.</p>
               <eg xml:space="preserve">&lt;xsl:template match="chapter/heading"&gt;
  &lt;fo:block font-stretch="condensed" xsl:use-attribute-sets="title-style"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:attribute-set name="title-style"&gt;
  &lt;xsl:attribute name="font-size"&gt;12pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-weight"&gt;bold&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;</eg>
            </example>
            <example>
               <head>Overriding Attributes in an Attribute Set</head>
               <p>The following example creates a named attribute set <code>base-style</code> and
                  uses it in a template rule with multiple specifications of the attributes:</p>
               <glist>
                  <gitem>
                     <label>font-family</label>
                     <def>
                        <p>is specified only in the attribute set</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>font-size</label>
                     <def>
                        <p>is specified in the attribute set, is specified on the literal result
                           element, and in an <elcode>xsl:attribute</elcode> instruction</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>font-style</label>
                     <def>
                        <p>is specified in the attribute set, and on the literal result element</p>
                     </def>
                  </gitem>
                  <gitem>
                     <label>font-weight</label>
                     <def>
                        <p>is specified in the attribute set, and in an
                              <elcode>xsl:attribute</elcode> instruction</p>
                     </def>
                  </gitem>
               </glist>
               <!--
<table cellspacing="5">
<tbody>
<tr><td valign="top"><code>font-family</code></td>is specified only in the attribute set<td></td></tr>
 <tr><td valign="top"><code>font-size</code></td><td>is specified in the attribute set, is specified
             on the literal result element, and in an
             <elcode>xsl:attribute</elcode> element</td></tr>
 <tr><td valign="top"><code>font-style</code></td><td>is specified in the attribute set, and on
             the literal result element</td></tr>
 <tr><td valign="top"><code>font-weight</code></td><td>is specified in the attribute set, and in an
             <elcode>xsl:attribute</elcode> element</td></tr>
</tbody>             
</table>-->
               <p>Stylesheet fragment:</p>
               <eg xml:space="preserve">&lt;xsl:attribute-set name="base-style"&gt;
  &lt;xsl:attribute name="font-family"&gt;Univers&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-size"&gt;10pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-style"&gt;normal&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-weight"&gt;normal&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;

&lt;xsl:template match="o"&gt;
  &lt;fo:block xsl:use-attribute-sets="base-style"
            font-size="12pt"
            font-style="italic"&gt;
    &lt;xsl:attribute name="font-size"&gt;14pt&lt;/xsl:attribute&gt;
    &lt;xsl:attribute name="font-weight"&gt;bold&lt;/xsl:attribute&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</eg>
               <p>Result:</p>
               <eg xml:space="preserve">&lt;fo:block font-family="Univers"
          font-size="14pt"
          font-style="italic"
          font-weight="bold"&gt;
...
&lt;/fo:block&gt;
</eg>
            </example>
         </div2>
         <div2 id="stylesheet-functions">
            <head>Stylesheet Functions</head>
            <p>
               <termdef id="dt-stylesheet-function" term="stylesheet function">An
                     <elcode>xsl:function</elcode> declaration declares the name, parameters, and
                  implementation of a <term>stylesheet function</term> that can be called from any
                  XPath <termref def="dt-expression">expression</termref> within the <termref def="dt-stylesheet">stylesheet</termref>.</termdef>
            </p>
            <e:element-syntax name="function">
               <e:in-category name="declaration"/>
               <e:attribute name="name" required="yes">
                  <e:data-type name="qname"/>
               </e:attribute>
               <e:attribute name="as" required="no">
                  <e:data-type name="sequence-type"/>
               </e:attribute>
               <e:attribute name="override" required="no">
                  <e:constant value="yes"/>
                  <e:constant value="no"/>
               </e:attribute>
               <e:sequence>
                  <e:element repeat="zero-or-more" name="param"/>
                  <e:model name="sequence-constructor"/>
               </e:sequence>
               <e:allowed-parents>
                  <e:parent name="stylesheet"/>
                  <e:parent name="transform"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:function</elcode> declaration defines a <termref def="dt-stylesheet-function">stylesheet function</termref> that can be called from
               any XPath <termref def="dt-expression">expression</termref> used in the <termref def="dt-stylesheet">stylesheet</termref> (including an XPath expression used
               within a predicate in a <termref def="dt-pattern">pattern</termref>). The
                  <code>name</code> attribute specifies the name of the function. The value of the
                  <code>name</code> attribute is a <termref def="dt-qname">QName</termref>, which is
               expanded as described in <specref ref="qname"/>.</p>
            <p>An <elcode>xsl:function</elcode> declaration can only appear as a top-level element
               in a stylesheet module.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0740">
                  <p>A <termref def="dt-stylesheet-function">stylesheet function</termref>
                     <rfc2119>must</rfc2119> have a prefixed name, to remove any risk of a clash
                     with a function in the default function namespace. It is a <termref def="dt-static-error">static error</termref> if the name has no prefix.</p>
               </error>.</p>
            <note>
               <p>To prevent the namespace declaration used for the function name appearing in the
                  result document, use the <code>exclude-result-prefixes</code> attribute on the
                     <elcode>xsl:stylesheet</elcode> element: see <specref ref="lre-namespaces"/>.</p>
               <p>The prefix <rfc2119>must not</rfc2119> refer to a <termref def="dt-reserved-namespace">reserved namespace</termref>: <errorref spec="XT" class="SE" code="0080"/>
               </p>
            </note>
            <p>The content of the <elcode>xsl:function</elcode> element consists of zero or more
                  <elcode>xsl:param</elcode> elements that specify the formal arguments of the
               function, followed by a <termref def="dt-sequence-constructor">sequence
                  constructor</termref> that defines the value to be returned by the function.</p>
            <p>
               <termdef id="dt-arity" term="arity">The <term>arity</term> of a stylesheet function
                  is the number of <elcode>xsl:param</elcode> elements in the function
                  definition.</termdef> Optional arguments are not allowed.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0760">
                  <p>Because arguments to a stylesheet function call <rfc2119>must</rfc2119> all be
                     specified, the <elcode>xsl:param</elcode> elements within an
                        <elcode>xsl:function</elcode> element <rfc2119>must not</rfc2119> specify a
                     default value: this means they <rfc2119>must</rfc2119> be empty, and
                        <rfc2119>must not</rfc2119> have a <code>select</code> attribute.</p>
               </error>
            </p>
            <p>A <termref def="dt-stylesheet-function">stylesheet function</termref> is included in
               the <emph>in-scope functions</emph> of the static context for all XPath expressions
               used in the <termref def="dt-stylesheet">stylesheet</termref>, unless </p>
            <ulist>
               <item>
                  <p>there is another <termref def="dt-stylesheet-function">stylesheet
                        function</termref> with the same name and <termref def="dt-arity">arity</termref>, and higher <termref def="dt-import-precedence">import
                        precedence</termref>, or</p>
               </item>
               <item>
                  <p>the <code>override</code> attribute has the value <code>no</code> and there is
                     already a function with the same name and <termref def="dt-arity">arity</termref> in the in-scope functions.</p>
               </item>
            </ulist>
            <p>The optional <code>override</code> attribute defines what happens if this function
               has the same name and <termref def="dt-arity">arity</termref> as a function provided
               by the implementer or made available in the static context using an
               implementation-defined mechanism. If the <code>override</code> attribute has the
               value <code>yes</code>, then this function is used in preference; if it has the value
                  <code>no</code>, then the other function is used in preference. The default value
               is <code>yes</code>.</p>
            <note>
               <p>Specifying <code>override="yes"</code> ensures interoperable behavior: the same
                  code will execute with all processors. Specifying <code>override="no"</code> is
                  useful when writing a fallback implementation of a function that is available with
                  some processors but not others: it allows the vendor's implementation of the
                  function (or a user's implementation written as an extension function) to be used
                  in preference to the stylesheet implementation, which is useful when the extension
                  function is more efficient.</p>
               <p>The <code>override</code> attribute does <emph>not</emph> affect the rules for
                  deciding which of several <termref def="dt-stylesheet-function">stylesheet
                     functions</termref> with the same name and <termref def="dt-arity">arity</termref> takes precedence.</p>
            </note>
            <p>
               <error spec="XT" type="static" class="SE" code="0770">
                  <p>It is a <termref def="dt-static-error">static error</termref> for a <termref def="dt-stylesheet">stylesheet</termref> to contain two or more functions
                     with the same <termref def="dt-expanded-qname">expanded-QName</termref>, the
                     same <termref def="dt-arity">arity</termref>, and the same <termref def="dt-import-precedence">import precedence</termref>, unless there is
                     another function with the same <termref def="dt-expanded-qname">expanded-QName</termref> and arity, and a higher import precedence.</p>
               </error>
            </p>
            <p>As defined in XPath, the function that is executed as the result of a function call
               is identified by looking in the in-scope functions of the static context for a
               function whose name and <termref def="dt-arity">arity</termref> matches the name and
               number of arguments in the function call. </p>
            <note>
               <p>Functions are not polymorphic. Although the XPath function call mechanism allows
                  two functions to have the same name and different <termref def="dt-arity">arity</termref>, it does not allow them to be distinguished by the types of
                  their arguments.</p>
            </note>
            <p>The optional <code>as</code> attribute indicates the <termref def="dt-required-type">required type</termref> of the result of the function. The value of the
                  <code>as</code> attribute is a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-SequenceType" xlink:type="simple">SequenceType</xnt>, as defined in <bibref ref="xpath-21"/>.</p>
            <p>
               <error spec="XT" type="type" class="TE" code="0780">
                  <p>If the <code>as</code> attribute <error.extra>of <elcode>xsl:function</elcode>
                     </error.extra> is specified, then the result evaluated by the <termref def="dt-sequence-constructor">sequence constructor</termref> (see <specref ref="sequence-constructors"/>) is converted to the required type, using the
                        <termref def="dt-function-conversion-rules">function conversion
                        rules</termref>. It is a <termref def="dt-type-error">type error</termref>
                     if this conversion fails.</p>
               </error> If the <code>as</code> attribute is omitted, the calculated result is used
               as supplied, and no conversion takes place.</p>
            <p>If a <termref def="dt-stylesheet-function">stylesheet function</termref> has been
               defined with a particular <termref def="dt-expanded-qname">expanded-QName</termref>,
               then a call on <function>function-available</function> will return true when called
               with an argument that is a <termref def="dt-lexical-qname">lexical QName</termref>
               that expands to this same <termref def="dt-expanded-qname">expanded-QName</termref>.</p>
            <p>The <elcode>xsl:param</elcode> elements define the formal arguments to the function.
               These are interpreted positionally. When the function is called using a function-call
               in an XPath <termref def="dt-expression">expression</termref>, the first argument
               supplied is assigned to the first <elcode>xsl:param</elcode> element, the second
               argument supplied is assigned to the second <elcode>xsl:param</elcode> element, and
               so on.</p>
            <p>The <code>as</code> attribute of the <elcode>xsl:param</elcode> element defines the
               required type of the parameter. The rules for converting the values of the actual
               arguments supplied in the function call to the types required by each
                  <elcode>xsl:param</elcode> element are defined in <bibref ref="xpath-21"/>. The
               rules that apply are those for the case where <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> is set to <code>false</code>.</p>
            <p>
               <error spec="XT" type="type" class="TE" code="0790">
                  <p>If the value of a parameter to a <termref def="dt-stylesheet-function">stylesheet function</termref> cannot be converted to the required type, a
                        <termref def="dt-type-error">type error</termref> is signaled.</p>
               </error>
            </p>
            <p>If the <code>as</code> attribute is omitted, no conversion takes place and any value
               is accepted.</p>
            <p>Within the body of a stylesheet function, the <termref def="dt-focus">focus</termref>
               is initially undefined; this means that any attempt to reference the context item,
               context position, or context size is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>.
               <!--<xerrorref spec="XP21" class="DY" code="0002"/>-->[XPDY0002]</p>
            <p>It is not possible within the body of the <termref def="dt-stylesheet-function">stylesheet function</termref> to access the values of local variables that were
               in scope in the place where the function call was written. Global variables, however,
               remain available.</p>
            <example>
               <head>A Stylesheet Function</head>
               <p>The following example creates a recursive <termref def="dt-stylesheet-function">stylesheet function</termref> named <code>str:reverse</code> that reverses the
                  words in a supplied sentence, and then invokes this function from within a
                     <termref def="dt-template-rule">template rule</termref>. </p>
               <eg xml:space="preserve">&lt;xsl:transform 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:str="http://example.com/namespace"
  version="2.1"
  exclude-result-prefixes="str"&gt;

&lt;xsl:function name="str:reverse" as="xs:string"&gt;
  &lt;xsl:param name="sentence" as="xs:string"/&gt;
  &lt;xsl:sequence  
     select="if (contains($sentence, ' '))
             then concat(str:reverse(substring-after($sentence, ' ')),
                         ' ',
                         substring-before($sentence, ' '))
             else $sentence"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:template match="/"&gt;
&lt;output&gt;
  &lt;xsl:value-of select="str:reverse('DOG BITES MAN')"/&gt;
&lt;/output&gt;
&lt;/xsl:template&gt;

&lt;/xsl:transform&gt;</eg>
               <p>An alternative way of writing the same function is to implement the conditional
                  logic at the XSLT level, thus:</p>
               <eg xml:space="preserve">&lt;xsl:function name="str:reverse" as="xs:string"&gt;
  &lt;xsl:param name="sentence" as="xs:string"/&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="contains($sentence, ' ')"&gt;  
      &lt;xsl:sequence 
           select="concat(str:reverse(substring-after($sentence, ' ')),
                                ' ',
                                substring-before($sentence, ' '))"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:sequence select="$sentence"/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:function&gt;</eg>
            </example>
            <example>
               <head>Declaring the Return Type of a Function</head>
               <p>The following example illustrates the use of the <code>as</code> attribute in a
                  function definition. It returns a string containing the representation of its
                  integer argument, expressed as a roman numeral. For example, the function call
                     <code>num:roman(7)</code> will return the string <code>"vii"</code>. This
                  example uses the <elcode>xsl:number</elcode> instruction, described in <specref ref="number"/>. The <elcode>xsl:number</elcode> instruction returns a text
                  node, and the <termref def="dt-function-conversion-rules">function conversion
                     rules</termref> are invoked to convert this text node to the type declared in
                  the <elcode>xsl:function</elcode> element, namely <code>xs:string</code>. So the
                  text node is <termref def="dt-atomization">atomized</termref> to a string.</p>
               <eg xml:space="preserve">&lt;xsl:function name="num:roman" as="xs:string"&gt;
  &lt;xsl:param name="value" as="xs:integer"/&gt;
  &lt;xsl:number value="$value" format="i"/&gt;
&lt;/xsl:function&gt;</eg>
            </example>
            <example diff="add" at="D">
               <head>A Higher-Order Function</head>
               <p>XPath 2.1 introduces the ability to pass function items as argument to a function.
                  A function that takes function items as arguments is known as a higher-order
                  function.</p>
               <p>The following example is a higher-order function that operates on any
                  tree-structured data, for example an organization chart. Given as input a function
                  that finds the direct subordinates of a node in this tree structure (for example,
                  the direct reports of a manager, or the geographical subdivisions of an
                  administrative area), it determines whether one object is present in the subtree
                  rooted at another object (for example, whether one person is among the staff
                  managed directly or indirectly by a manager, or whether one parcel of land is
                  contained directly or indirectly within another parcel. The function does not
                  check for cycles in the data.</p>
               <eg xml:space="preserve">&lt;xsl:function name="f:is-subordinate" as="xs:boolean"&gt;
    &lt;xsl:param name="superior" 
               as="node()"/&gt;
    &lt;xsl:param name="subordinate" 
               as="node()"/&gt;
    &lt;xsl:param name="get-direct-children" 
               as="function(node()) as node()*"/&gt;
    &lt;xsl:sequence select="
               some $sub in $get-direct-children($superior) satisfies
                 ($sub is $subordinate or
                  f:is-subordinate($sub, $subordinate, 
                                      $get-direct-children))"/&gt;
&lt;/xsl:function&gt;</eg>
               <p>Given source data representing an organization chart in the form of elements such
                  as:</p>
               <eg xml:space="preserve">&lt;employee id="P57832" manager="P68951"/&gt;</eg>
               <p>the following function can be defined to get the direct reports of a manager:</p>
               <eg xml:space="preserve">&lt;xsl:function name="f:direct-reports" 
               as="element(employee)*"&gt;
    &lt;xsl:param name="manager" as="element(employee)"/&gt;
    &lt;xsl:sequence select="$manager/../employee
                               [@manager = current()/@id]"/&gt;
    &lt;/xsl:function&gt;</eg>
               <p>It is then possible to test whether one employee $E reports directly or indirectly
                  to another employee $M by means of the function call:</p>
               <eg xml:space="preserve">f:is-subordinate($M, $E, f:direct-reports#1)</eg>
            </example>
         </div2>
         <div2 id="dynamic-xpath" diff="add" at="B">
            <head>Dynamic XPath Evaluation</head>

            <e:element-syntax name="evaluate">
               <e:in-category name="instruction"/>
               <e:attribute name="xpath" required="yes">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="as" required="no">
                  <e:data-type name="sequence-type"/>
               </e:attribute>
               <e:attribute name="base-uri" required="no">
                  <e:attribute-value-template>
                     <e:data-type name="URI"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="namespace-context" required="no">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="schema-aware" required="no">
                  <e:attribute-value-template>
                     <e:constant value="yes"/>
                     <e:constant value="no"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:choice repeat="zero-or-more">
                  <e:element name="with-param"/>
                  <e:element name="fallback"/>
               </e:choice>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:evaluate</elcode> instruction constructs an XPath expression in the
               form of a string, evaluates the expression in a specified context, and returns the
               result of the evaluation.</p>
            <p>The expression given as the value of the <code>xpath</code> attribute is evaluated
               and the result is converted to a string using the <termref def="dt-function-conversion-rules">function conversion rules</termref>.</p>

            <p><termdef id="dt-target-expression" term="target expression">The string that results
                  from evaluating the expression in the <code>xpath</code> attribute is referred to
                  as the <term>target expression</term>.</termdef></p>

            <p><error spec="XT" type="dynamic" class="DE" code="2150">
                  <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the <termref def="dt-target-expression">target
                        expression</termref>
                     <error.extra>of an <elcode>xsl:evaluate</elcode> instruction</error.extra> is
                     not a legal XPath 2.1 expression (that is, if a static error occurs when
                     analyzing the string according to the rules of the XPath 2.1
                     specification).</p>
               </error></p>

            <p>The <code>as</code> attribute, if present, indicates the required type of the result.
               If the attribute is absent, the required type is <code>item()*</code>, which allows
               any result. The result of evaluating the <termref def="dt-target-expression">target
                  expression</termref> is converted to the required type using the <termref def="dt-function-conversion-rules">function conversion rules</termref>. This may
               cause a <termref def="dt-type-error">type error</termref> if conversion is not
               possible. The result after conversion is returned as the result of the
                  <elcode>xsl:evaluate</elcode> instruction.</p>

            <p>The <xtermref spec="XP21" ref="dt-static-context">static context</xtermref> for the
                  <termref def="dt-target-expression">target expression</termref> is as follows:</p>
            <ulist>
               <item>
                  <p>XPath 1.0 compatibility mode is <code>false</code>.</p>
               </item>
               <item>
                  <p>Statically known namespaces and default element/type namespace:</p>
                  <ulist>
                     <item>
                        <p>if the <code>namespace-context</code> attribute is present, then its
                           value is an <termref def="dt-expression">expression</termref> whose
                           required type is a single node. The expression is evaluated, and the
                           in-scope namespaces of the resulting node are used as the statically
                           known namespaces for the target expression. The binding for the default
                           namespace in the in-scope namespaces is used as the default namespace for
                           elements and types in the target expression.</p>
                        <p>
                           <error spec="XT" type="type" class="TE" code="2160">
                              <p>It is a <termref def="dt-type-error">type error</termref> if the
                                 result of evaluating the <code>namespace-context</code> attribute
                                 of the <elcode>xsl:evaluate</elcode> instruction is anything other
                                 than a single node.</p>
                           </error>
                        </p>
                     </item>
                     <item>
                        <p>if the <code>namespace-context</code> attribute is absent, then the
                           in-scope namespaces of the <elcode>xsl:evaluate</elcode> instruction
                           (with the exception of any binding for the default namespace) are used as
                           the statically known namespaces for the target expression, and the value
                           of the innermost <code>[xsl:]xpath-default-namespace</code> attribute, if
                           any, is used as the default namespace for elements and types in the
                           target expression.</p>
                     </item>
                  </ulist>
                  <note>
                     <p>XPath 2.1 allows expanded names to be written in a context-independent way
                        using the syntax <code>"namespace-uri":local-name</code></p>
                  </note>
               </item>
               <item>
                  <p>Default function namespace: the <termref def="dt-standard-function-namespace">standard function namespace</termref>.</p>
               </item>
               <item>
                  <p>In-scope schema definitions: if the <code>schema-aware</code> attribute is
                     present and has the <termref def="dt-effective-value">effective value</termref>
                     <code>yes</code>, then the in-scope schema definitions from the stylesheet
                     context (that is, the schema definitions imported using
                        <elcode>xsl:import-schema</elcode>). Otherwise, the built-in types (see
                        <specref ref="built-in-types"/>).</p>
               </item>
               <item>
                  <p>In-scope variables: the variables defined in the contained
                        <elcode>xsl:with-param</elcode> elements.</p>
                  <note>
                     <p>Variables declared in the stylesheet in <elcode>xsl:variable</elcode> or
                           <elcode>xsl:param</elcode> elements are <emph>not</emph> in-scope within
                        the target expression.</p>
                  </note>
               </item>
               <item>
                  <p>Function signatures: All <termref def="dt-core-function">core
                        functions</termref>; constructor functions for atomic types included in the
                     in-scope schema definitions; user-defined functions declared using
                        <elcode>xsl:function</elcode>; and an <termref def="dt-implementation-defined">implementation-defined</termref> set of
                        <termref def="dt-extension-function">extension functions</termref>.</p>
                  <p>Note that this set deliberately excludes XSLT-defined functions in the <termref def="dt-standard-function-namespace">standard function namespace</termref>
                     including for example, <function>key</function>,
                        <function>current-group</function>, and <function>system-property</function>
                     A list of these functions is in <specref ref="XSLT-defined-functions"/>.</p>
                  <imp-def-feature>The set of extension functions available in the static context
                     for the target expression of <elcode>xsl:evaluate</elcode> is <termref def="dt-implementation-defined"/>.</imp-def-feature>

               </item>
               <item>
                  <p>Statically known collections: the same as the collations available at this
                     point in the stylesheet.</p>
               </item>
               <item>
                  <p>Default collation: the same as the default collation defined at this point in
                     the stylesheet (for example, by use of the <code>[xsl:]default-collation</code>
                     attribute)</p>
               </item>
               <item>
                  <p>Base URI: if the <code>base-uri</code> attribute is present, then its <termref def="dt-effective-value">effective value</termref>; otherwise, the base URI
                     of the <elcode>xsl:evaluate</elcode> instruction.</p>
               </item>
               <item>
                  <p>Statically known documents: the empty set</p>
               </item>
               <item>
                  <p>Statically known collections: the empty set</p>
               </item>
               <item>
                  <p>Statically known default collection type: <code>node()*</code></p>
               </item>
            </ulist>
            <p>The dynamic context for evaluation of the target expression is the same as the
               dynamic context for the <elcode>xsl:evaluate</elcode> instruction (in particular, the
                  <termref def="dt-focus">focus</termref> is the same), except for the variable
               values: this consists of the values bound to parameters defined in the contained
                  <elcode>xsl:with-param</elcode> elements, which are evaluated as described in
                  <specref ref="variable-values"/>.</p>
            <p>An XSLT 2.1 <termref def="dt-processor">processor</termref> will ignore any
                  <elcode>xsl:fallback</elcode> children of the <elcode>xsl:evaluate</elcode>
               instruction; they can be used to define the behavior of an XSLT 1.0 or XSLT 2.0
               processor when this instruction is encountered.</p>
            <p>The XPath expression is evaluated in the same <xtermref ref="execution-scope" spec="FO">execution scope</xtermref> as the calling XSLT transformation; this
               means that the results of <xtermref spec="FO" ref="stable">stable</xtermref>
               functions such as <xfunction>doc</xfunction> or
                  <xfunction>current-dateTime</xfunction> will be consistent between the calling
               stylesheet and the called XPath expression.</p>
            <p diff="add" at="E">It is a <termref def="dt-nonrec-dynamic-error"/> if evaluation of
               the XPath expression fails with a dynamic error. The XPath-defined error code is used
               unchanged.</p>
            <note>
               <p>Implementations wanting to avoid the cost of repeated compilation of the same
                  XPath expression should cache the compiled form internally.</p>
            </note>
            <example>
               <head>Using a dynamic sort key</head>
               <p>A common requirement is to sort a table on the value of an expression which is
                  selected at run-time, perhaps by supplying the expression as a string-valued
                  parameter to the stylesheet. Suppose that such an expression is supplied to the
                  parameter:</p>
               <eg xml:space="preserve">&lt;xsl:param name="sortkey" as="xs:string" select="'@name'"/&gt;</eg>
               <p>Then the data may be sorted as follows:</p>
               <eg xml:space="preserve">&lt;xsl:sort&gt;
   &lt;xsl:evaluate xpath="$sortkey" as="xs:string"/&gt;
&lt;/xsl:sort&gt;</eg>
               <p>Note the importance in this use case of caching the compiled expression, since it
                  is evaluated repeatedly, once for each item in the list being sorted.</p>
            </example>


            <issue id="issue-evaluate-optional-feature" status="open">
               <p>The Working Group has not yet decided whether <elcode>xsl:evaluate</elcode> will
                  be an optional feature of the language, or whether all implementations will be
                  required to provide it.</p>
            </issue>
         </div2>
      </div1>
      <div1 id="creating-new-nodes">
         <head>Creating Nodes and Sequences</head>
         <p>This section describes instructions that directly create new nodes, or sequences of
            nodes, atomic values, <phrase diff="add" at="C">and/or function items</phrase>.</p>
         <div2 id="literal-result-element">
            <head>Literal Result Elements</head>
            <p>
               <termdef id="dt-literal-result-element" term="literal result element">In a <termref def="dt-sequence-constructor">sequence constructor</termref>, an element in the
                     <termref def="dt-stylesheet">stylesheet</termref> that does not belong to the
                     <termref def="dt-xslt-namespace">XSLT namespace</termref> and that is not an
                     <termref def="dt-extension-instruction">extension instruction</termref> (see
                     <specref ref="extension-instruction"/>) is classified as a <term>literal result
                     element</term>.</termdef> A literal result element is evaluated to construct a
               new element node with the same <termref def="dt-expanded-qname">expanded-QName</termref> (that is, the same namespace URI, local name, and
               namespace prefix). The result of evaluating a literal result element is a node
               sequence containing one element, the newly constructed element node.</p>
            <p>The content of the element is a <termref def="dt-sequence-constructor">sequence
                  constructor</termref> (see <specref ref="sequence-constructors"/>). The sequence
               obtained by evaluating this sequence constructor, after prepending any attribute
               nodes produced as described in <specref ref="attributes-for-lres"/> and namespace
               nodes produced as described in <specref ref="lre-namespaces"/>, is used to construct
               the content of the element, following the rules in <specref ref="constructing-complex-content"/>
            </p>
            <p>The base URI of the new element is copied from the base URI of the literal result
               element in the stylesheet, unless the content of the new element includes an
                  <code>xml:base</code> attribute, in which case the base URI of the new element is
               the value of that attribute, resolved (if it is a relative URI <phrase diff="add" at="F">reference</phrase>) against the base URI
               of the literal result element in the stylesheet. (Note, however, that this is only
               relevant when creating a parentless element. When the literal result element is
               copied to form a child of an element or document node, the base URI of the new copy
               is taken from that of its new parent.)</p>
            <div3 id="setting-annotation-for-lre">
               <head>Setting the Type Annotation for Literal Result Elements</head>
               <p>The attributes <code>xsl:type</code> and <code>xsl:validation</code> may be used
                  on a literal result element to invoke validation of the contents of the element
                  against a type definition or element declaration in a schema, and to determine the
                     <termref def="dt-annotation">type annotation</termref> that the new element
                  node will carry. These attributes also affect the type annotation carried by any
                  elements and attributes that have the new element node as an ancestor. These two
                  attributes are both optional, and if one is specified then the other
                     <rfc2119>must</rfc2119> be omitted.</p>
               <p>The value of the <code>xsl:validation</code> attribute, if present, must be one of
                  the values <code>strict</code>, <code>lax</code>, <code>preserve</code>, or
                     <code>strip</code>. The value of the <code>xsl:type</code> attribute, if
                  present, must be a <termref def="dt-qname">QName</termref> identifying a type
                  definition that is present in the <termref def="dt-in-scope-schema-component">in-scope schema components</termref> for the stylesheet. Neither attribute may
                  be specified as an <termref def="dt-attribute-value-template">attribute value
                     template.</termref> The effect of these attributes is described in <specref ref="validation"/>.</p>
            </div3>
            <div3 id="attributes-for-lres">
               <head>Attribute Nodes for Literal Result Elements</head>
               <p>Attribute nodes for a literal result element may be created by including
                     <elcode>xsl:attribute</elcode> instructions within the <termref def="dt-sequence-constructor">sequence constructor</termref>. Additionally,
                  attribute nodes are created corresponding to the attributes of the literal result
                  element in the stylesheet, and as a result of expanding the
                     <code>xsl:use-attribute-sets</code> attribute of the literal result element, if
                  present.</p>
               <p>The sequence that is used to construct the content of the literal result element
                  (as described in <specref ref="constructing-complex-content"/>) is the
                  concatenation of the following four sequences, in order:</p>
               <olist>
                  <item>
                     <p>The sequence of namespace nodes produced as described in <specref ref="lre-namespaces"/>.</p>
                  </item>
                  <item>
                     <p>The sequence of attribute nodes produced by expanding the
                           <code>xsl:use-attribute-sets</code> attribute (if present) following the
                        rules given in <specref ref="attribute-sets"/>
                     </p>
                  </item>
                  <item>
                     <p>The attributes produced by processing the attributes of the literal result
                        element itself, other than attributes in the <termref def="xslt-namespace">XSLT namespace</termref>. The way these are processed is described
                        below.</p>
                  </item>
                  <item>
                     <p>The sequence produced by evaluating the contained <termref def="dt-sequence-constructor">sequence constructor</termref>, if the
                        element is not empty.</p>
                  </item>
               </olist>
               <note>
                  <p>The significance of this order is that an attribute produced by an
                        <code>xsl:attribute</code>, <elcode>xsl:copy</elcode>, or
                        <elcode>xsl:copy-of</elcode> instruction in the content of the literal
                     result element takes precedence over an attribute produced by expanding an
                     attribute of the literal result element itself, which in turn takes precedence
                     over an attribute produced by expanding the <code>xsl:use-attribute-sets</code>
                     attribute. This is because of the rules in <specref ref="constructing-complex-content"/>, which specify that when two or more
                     attributes in the sequence have the same name, all but the last of the
                     duplicates are discarded.</p>
                  <p>Although the above rules place namespace nodes before attributes, this is not
                     strictly necessary, because the rules in <specref ref="constructing-complex-content"/> allow the namespaces and attributes to
                     appear in any order so long as both come before other kinds of node. The order
                     of namespace nodes and attribute nodes in the sequence has no effect on the
                     relative position of the nodes in document order once they are added to a
                     tree.</p>
               </note>
               <p>Each attribute of the literal result element, other than an attribute in the
                     <termref def="dt-xslt-namespace">XSLT namespace</termref>, is processed to
                  produce an attribute for the element in the <termref def="dt-result-tree">result
                     tree</termref>.</p>
               <p>The value of such an attribute is interpreted as an <termref def="dt-attribute-value-template">attribute value template</termref>: it can
                  therefore contain <termref def="dt-expression">expressions</termref> contained in
                  curly brackets (<code>{}</code>). The new attribute node will have the same
                     <termref def="dt-expanded-qname">expanded-QName</termref> (that is, the same
                  namespace URI, local name, and namespace prefix) as the attribute in the
                  stylesheet tree, and its <termref def="dt-string-value">string value</termref>
                  will be the same as the <termref def="dt-effective-value">effective
                     value</termref> of the attribute in the stylesheet tree. The <termref def="dt-annotation">type annotation</termref> on the attribute will initially
                  be <code>xs:untypedAtomic</code>, and the <termref def="dt-typed-value">typed
                     value</termref> of the attribute node will be the same as its <termref def="dt-string-value">string value</termref>.</p>
               <note>
                  <p>The eventual <termref def="dt-annotation">type annotation</termref> of the
                     attribute in the <termref def="dt-result-tree">result tree</termref> depends on
                     the <code>xsl:validation</code> and <code>xsl:type</code> attributes of the
                     parent literal result element, and on the instructions used to create its
                     ancestor elements. If the <code>xsl:validation</code> attribute is set to
                        <code>preserve</code> or <code>strip</code>, the type annotation will be
                        <code>xs:untypedAtomic</code>, and the <termref def="dt-typed-value">typed
                        value</termref> of the attribute node will be the same as its <termref def="dt-string-value">string value</termref>. If the
                        <code>xsl:validation</code> attribute is set to <code>strict</code> or
                        <code>lax</code>, or if the <code>xsl:type</code> attribute is used, the
                     type annotation on the attribute will be set as a result of the schema
                     validation process applied to the parent element. If neither attribute is
                     present, the type annotation on the attribute will be
                        <code>xs:untypedAtomic</code>.</p>
               </note>
               <p>If the name of a constructed attribute is <code>xml:id</code>, the processor must
                  perform attribute value normalization by effectively applying the
                     <xfunction>normalize-space</xfunction> function to the value of the attribute,
                  and the resulting attribute node must be given the <code>is-id</code>
                  property.</p>
               <p>
                  <error spec="XT" type="dynamic" class="RE" code="0795">
                     <p>It is a <termref def="dt-recoverable-error">recoverable dynamic
                           error</termref> if the name of a constructed attribute is
                           <code>xml:space</code> and the value is not either <code>default</code>
                        or <code>preserve</code>. <error.action>The <termref def="dt-optional-recovery-action">optional recovery action</termref>
                           is to construct the attribute with the value as requested.</error.action>
                     </p>
                  </error>. This applies whether the attribute is constructed using a literal result
                  element, or by using the <elcode>xsl:attribute</elcode>,
                  <elcode>xsl:copy</elcode>, or <elcode>xsl:copy-of</elcode> instructions.</p>
               <note>
                  <p>The <code>xml:base</code>, <code>xml:lang</code>, <code>xml:space</code>, and
                        <code>xml:id</code> attributes have two effects in XSLT. They behave as
                     standard XSLT attributes, which means for example that if they appear on a
                     literal result element, they will be copied to the <termref def="dt-result-tree">result tree</termref> in the same way as any other
                     attribute. In addition, they have their standard meaning as defined in the core
                     XML specifications. Thus, an <code>xml:base</code> attribute in the stylesheet
                     affects the base URI of the element on which it appears, and an
                        <code>xml:space</code> attribute affects the interpretation of <termref def="dt-whitespace-text-node">whitespace text nodes</termref> within that
                     element. One consequence of this is that it is inadvisable to write these
                     attributes as attribute value templates: although an XSLT processor will
                     understand this notation, the XML parser will not. See also <specref ref="namespace-aliasing"/> which describes how to use
                        <elcode>xsl:namespace-alias</elcode> with these attributes.</p>
                  <p>The same is true of the schema-defined attributes <code>xsi:type</code>,
                        <code>xsi:nil</code>, <code>xsi:noNamespaceSchemaLocation</code>, and
                        <code>xsi:schemaLocation</code>. If the stylesheet is processed by a schema
                     processor, these attributes will be recognized and interpreted by the schema
                     processor, but in addition the XSLT processor treats them like any other
                     attribute on a literal result element: that is, their <termref def="dt-effective-value">effective value</termref> (after expanding <termref def="dt-attribute-value-template">attribute value templates</termref>) is
                     copied to the result tree in the same way as any other attribute. If the
                        <termref def="dt-result-tree">result tree</termref> is validated, the copied
                     attributes will again be recognized and interpreted by the schema
                     processor.</p>
                  <p>None of these attributes will be generated in the <termref def="dt-result-tree">result tree</termref> unless the stylesheet writes them to the result tree
                     explicitly, in the same way as any other attribute.</p>
               </note>
               <p>
                  <error spec="XT" type="static" class="SE" code="0805">
                     <p>It is a <termref def="dt-static-error">static error</termref> if an
                        attribute on a literal result element is in the <termref def="dt-xslt-namespace">XSLT namespace</termref>, unless it is one of the
                        attributes explicitly defined in this specification.</p>
                  </error>
               </p>
               <note>
                  <p>If there is a need to create attributes in the XSLT namespace, this can be
                     achieved using <elcode>xsl:attribute</elcode>, or by means of the
                        <elcode>xsl:namespace-alias</elcode> declaration.</p>
               </note>
            </div3>
            <div3 id="lre-namespaces">
               <head>Namespace Nodes for Literal Result Elements</head>
               <p>The created element node will have a copy of the namespace nodes that were present
                  on the element node in the stylesheet tree with the exception of any namespace
                  node whose <termref def="dt-string-value">string value</termref> is designated as
                  an <term>excluded namespace</term>. Special considerations apply to aliased
                  namespaces: see <specref ref="namespace-aliasing"/>
               </p>
               <p>The following namespaces are designated as excluded namespaces:</p>
               <ulist>
                  <item>
                     <p>The <termref def="dt-xslt-namespace">XSLT namespace</termref> URI
                           (<code>http://www.w3.org/1999/XSL/Transform</code>)</p>
                  </item>
                  <item>
                     <p>A namespace URI declared as an extension namespace (see <specref ref="extension-instruction"/>)</p>
                  </item>
                  <item>
                     <p>A namespace URI designated by using an
                           <code>[xsl:]exclude-result-prefixes</code> attribute either on the
                        literal result element itself or on an ancestor element. The attribute
                           <rfc2119>must</rfc2119> be in the XSLT namespace only if its parent
                        element is <emph>not</emph> in the XSLT namespace.</p>
                     <p>The value of the attribute is either <code>#all</code>, or a
                        whitespace-separated list of tokens, each of which is either a namespace
                        prefix or <code>#default</code>. The namespace bound to each of the prefixes
                        is designated as an excluded namespace.</p>
                     <p>
                        <error class="SE" type="static" spec="XT" code="0808">
                           <p>It is a <termref def="dt-static-error">static error</termref> if a
                              namespace prefix is used within the
                                 <code>[xsl:]exclude-result-prefixes</code> attribute and there is
                              no namespace binding in scope for that prefix.</p>
                        </error>
                     </p>
                     <p>The default namespace of the parent element of the
                           <code>[xsl:]exclude-result-prefixes</code> attribute (see <xspecref spec="DM11" ref="ElementNode"/>) may be designated as an excluded
                        namespace by including <code>#default</code> in the list of namespace
                        prefixes.</p>
                     <p>
                        <error class="SE" type="static" spec="XT" code="0809">
                           <p>It is a <termref def="dt-static-error">static error</termref> if the
                              value <code>#default</code> is used within the
                                 <code>[xsl:]exclude-result-prefixes</code> attribute and the parent
                              element of the <code>[xsl:]exclude-result-prefixes</code> attribute
                              has no default namespace.</p>
                        </error>
                     </p>
                     <p>The value <code>#all</code> indicates that all namespaces that are in scope
                        for the stylesheet element that is the parent of the
                           <code>[xsl:]exclude-result-prefixes</code> attribute are designated as
                        excluded namespaces.</p>
                     <p>The designation of a namespace as an excluded namespace is effective within
                        the subtree of the stylesheet module rooted at the element bearing the
                           <code>[xsl:]exclude-result-prefixes</code> attribute; a subtree rooted at
                        an <elcode>xsl:stylesheet</elcode> element does not include any stylesheet
                        modules imported or included by children of that
                           <elcode>xsl:stylesheet</elcode> element.</p>
                  </item>
               </ulist>
               <p>The excluded namespaces, as described above, <emph>only</emph> affect namespace
                  nodes copied from the stylesheet when processing a literal result element. There
                  is no guarantee that an excluded namespace will not appear on the <termref def="dt-result-tree">result tree</termref> for some other reason. Namespace
                  nodes are also written to the result tree as part of the process of namespace
                  fixup (see <specref ref="namespace-fixup"/>), or as the result of instructions
                  such as <elcode>xsl:copy</elcode> and <elcode>xsl:element</elcode>.</p>
               <note>
                  <p>When a stylesheet uses a namespace declaration only for the purposes of
                     addressing a <termref def="dt-source-tree">source tree</termref>, specifying
                     the prefix in the <code>[xsl:]exclude-result-prefixes</code> attribute will
                     avoid superfluous namespace declarations in the serialized <termref def="dt-result-tree">result tree</termref>. The attribute is also useful to
                     prevent namespaces used solely for the naming of stylesheet functions or
                     extension functions from appearing in the serialized result tree.</p>
               </note>
               <example>
                  <head>Excluding Namespaces from the Result Tree</head>
                  <p>For example, consider the following stylesheet:</p>
                  <eg xml:space="preserve">&lt;xsl:stylesheet xsl:version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:a="a.uri"
  xmlns:b="b.uri"&gt;
  exclude-result-prefixes="#all"&gt;
  
&lt;xsl:template match="/"&gt;
  &lt;foo xmlns:c="c.uri" xmlns:d="d.uri" xmlns:a2="a.uri" 
       xsl:exclude-result-prefixes="c"/&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg>
                  <p>The result of this stylesheet will be:</p>
                  <eg xml:space="preserve">&lt;foo xmlns:d="d.uri"/&gt;</eg>
                  <p>The namespaces <code>a.uri</code> and <code>b.uri</code> are excluded by virtue
                     of the <code>exclude-result-prefixes</code> attribute on the
                        <elcode>xsl:stylesheet</elcode> element, and the namespace
                        <code>c.uri</code> is excluded by virtue of the
                        <code>xsl:exclude-result-prefixes</code> attribute on the <code>foo</code>
                     element. The setting <code>#all</code> does not affect the namespace
                        <code>d.uri</code> because <code>d.uri</code> is not an in-scope namespace
                     for the <elcode>xsl:stylesheet</elcode> element. The element in the <termref def="dt-result-tree">result tree</termref> does not have a namespace node
                     corresponding to <code>xmlns:a2="a.uri"</code> because the effect of
                        <code>exclude-result-prefixes</code> is to designate the namespace URI
                        <code>a.uri</code> as an excluded namespace, irrespective of how many
                     prefixes are bound to this namespace URI.</p>
                  <p>If the stylesheet is changed so that the literal result element has an
                     attribute <code>b:bar="3"</code>, then the element in the <termref def="dt-result-tree">result tree</termref> will typically have a namespace
                     declaration <code>xmlns:b="b.uri"</code> (the processor may choose a different
                     namespace prefix if this is necessary to avoid conflicts). The
                        <code>exclude-result-prefixes</code> attribute makes <code>b.uri</code> an
                     excluded namespace, so the namespace node is not automatically copied from the
                     stylesheet, but the presence of an attribute whose name is in the namespace
                        <code>b.uri</code> forces the namespace fixup process (see <specref ref="namespace-fixup"/>) to introduce a namespace node for this
                     namespace.</p>
               </example>
               <p>A literal result element may have an optional <code>xsl:inherit-namespaces</code>
                  attribute, with the value <code>yes</code> or <code>no</code>. The default value
                  is <code>yes</code>. If the value is set to <code>yes</code>, or is omitted, then
                  the namespace nodes created for the newly constructed element are copied to the
                  children and descendants of the newly constructed element, as described in
                     <specref ref="constructing-complex-content"/>. If the value is set to
                     <code>no</code>, then these namespace nodes are not automatically copied to the
                  children. This may result in namespace undeclarations (such as
                     <code>xmlns=""</code> or, in the case of XML 1.1, <code>xmlns:p=""</code>)
                  appearing on the child elements when a <termref def="dt-final-result-tree">final
                     result tree</termref> is serialized.</p>
            </div3>
            <div3 id="namespace-aliasing">
               <head>Namespace Aliasing</head>
               <p>When a stylesheet is used to define a transformation whose output is itself a
                  stylesheet module, or in certain other cases where the result document uses
                  namespaces that it would be inconvenient to use in the stylesheet, namespace
                  aliasing can be used to declare a mapping between a namespace URI used in the
                  stylesheet and the corresponding namespace URI to be used in the result
                  document.</p>
               <p>
                  <termdef id="dt-literal-namespace-uri" term="literal namespace URI">A namespace
                     URI in the stylesheet tree that is being used to specify a namespace URI in the
                        <termref def="dt-result-tree">result tree</termref> is called a
                        <term>literal namespace URI</term>.</termdef>
               </p>
               <p>
                  <termdef id="dt-target-namespace-uri" term="target namespace URI">The namespace
                     URI that is to be used in the <termref def="dt-result-tree">result
                        tree</termref> as a substitute for a <termref def="dt-literal-namespace-uri">literal namespace URI</termref> is called the <term>target namespace
                        URI</term>.</termdef>
               </p>
               <p>Either of the <termref def="dt-literal-namespace-uri">literal namespace
                     URI</termref> or the <termref def="dt-target-namespace-uri">target namespace
                     URI</termref> can be <emph>null</emph>: this is treated as a reference to the
                  set of names that are in no namespace.</p>
               <e:element-syntax name="namespace-alias">
                  <e:in-category name="declaration"/>
                  <e:attribute name="stylesheet-prefix" required="yes">
                     <e:data-type name="prefix"/>
                     <e:constant value="#default"/>
                  </e:attribute>
                  <e:attribute name="result-prefix" required="yes">
                     <e:data-type name="prefix"/>
                     <e:constant value="#default"/>
                  </e:attribute>
                  <e:empty/>
                  <e:allowed-parents>
                     <e:parent name="stylesheet"/>
                     <e:parent name="transform"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p>
                  <termdef id="dt-alias" term="alias">A stylesheet can use the
                        <elcode>xsl:namespace-alias</elcode> element to declare that a <termref def="dt-literal-namespace-uri">literal namespace URI</termref> is being used
                     as an <term>alias</term> for a <termref def="dt-target-namespace-uri">target
                        namespace URI</termref>.</termdef>
               </p>
               <p>The effect is that when names in the namespace identified by the <termref def="dt-literal-namespace-uri">literal namespace URI</termref> are copied to
                  the <termref def="dt-result-tree">result tree</termref>, the namespace URI in the
                  result tree will be the <termref def="dt-target-namespace-uri">target namespace
                     URI</termref>, instead of the literal namespace URI. This applies to:</p>
               <ulist>
                  <item>
                     <p>the namespace URI in the <termref def="dt-expanded-qname">expanded-QName</termref> of a literal result element in the
                        stylesheet</p>
                  </item>
                  <item>
                     <p>the namespace URI in the <termref def="dt-expanded-qname">expanded-QName</termref> of an attribute specified on a literal result
                        element in the stylesheet</p>
                  </item>
               </ulist>
               <p>Where namespace aliasing changes the namespace URI part of the <termref def="dt-expanded-qname">expanded-QName</termref> containing the name of an
                  element or attribute node, the namespace prefix in that expanded-QName is replaced
                  by the prefix indicated by the <code>result-prefix</code> attribute of the
                     <elcode>xsl:namespace-alias</elcode> declaration.</p>
               <p>The <elcode>xsl:namespace-alias</elcode> element declares that the namespace URI
                  bound to the prefix specified by the <code>stylesheet-prefix</code> is the
                     <termref def="dt-literal-namespace-uri">literal namespace URI</termref>, and
                  the namespace URI bound to the prefix specified by the <code>result-prefix</code>
                  attribute is the <termref def="dt-target-namespace-uri">target namespace
                     URI</termref>. Thus, the <code>stylesheet-prefix</code> attribute specifies the
                  namespace URI that will appear in the stylesheet, and the
                     <code>result-prefix</code> attribute specifies the corresponding namespace URI
                  that will appear in the <termref def="dt-result-tree">result tree</termref>. </p>
               <p>The default namespace (as declared by <code>xmlns</code>) may be specified by
                  using <code>#default</code> instead of a prefix. If no default namespace is in
                  force, specifying <code>#default</code> denotes the null namespace URI. This
                  allows elements that are in no namespace in the stylesheet to acquire a namespace
                  in the result document, or vice versa.</p>
               <p>If a <termref def="dt-literal-namespace-uri">literal namespace URI</termref> is
                  declared to be an alias for multiple different <termref def="dt-literal-namespace-uri">target namespace URIs</termref>, then the
                  declaration with the highest <termref def="dt-import-precedence">import
                     precedence</termref> is used.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0810">
                     <p>It is a <termref def="dt-static-error">static error</termref> if there is
                        more than one such declaration <error.extra>more than one
                              <elcode>xsl:namespace-alias</elcode> declaration</error.extra> with
                        the same <termref def="dt-literal-namespace-uri">literal namespace
                           URI</termref> and the same <termref def="dt-import-precedence">import
                           precedence</termref> and different values for the <termref def="dt-target-namespace-uri">target namespace URI</termref>, unless
                        there is also an <elcode>xsl:namespace-alias</elcode> declaration with the
                        same <termref def="dt-literal-namespace-uri">literal namespace URI</termref>
                        and a higher import precedence. </p>
                  </error>
               </p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0812">
                     <p>It is a <termref def="dt-static-error">static error</termref> if a value
                        other than <code>#default</code> is specified for either the
                           <code>stylesheet-prefix</code> or the <code>result-prefix</code>
                        attributes of the <elcode>xsl:namespace-alias</elcode> element when there is
                        no in-scope binding for that namespace prefix.</p>
                  </error>
               </p>
               <p>When a literal result element is processed, its namespace nodes are handled as
                  follows:</p>
               <ulist>
                  <item>
                     <p>A namespace node whose string value is a <termref def="dt-literal-namespace-uri">literal namespace URI</termref> is not
                        copied to the <termref def="dt-result-tree">result tree</termref>.</p>
                  </item>
                  <item>
                     <p>A namespace node whose string value is a <termref def="dt-target-namespace-uri">target namespace URI</termref> is copied to
                        the <termref def="dt-result-tree">result tree</termref>, whether or not the
                        URI identifies an excluded namespace.</p>
                  </item>
               </ulist>
               <p>In the event that the same URI is used as a <termref def="dt-literal-namespace-uri">literal namespace URI</termref> and a <termref def="dt-target-namespace-uri">target namespace URI</termref>, the second of
                  these rules takes precedence.</p>
               <note>
                  <p>These rules achieve the effect that the element generated from the literal
                     result element will have an in-scope namespace node that binds the
                        <code>result-prefix</code> to the <termref def="dt-target-namespace-uri">target namespace URI</termref>, provided that the namespace declaration
                     associating this prefix with this URI is in scope for both the
                        <elcode>xsl:namespace-alias</elcode> instruction and for the literal result
                     element. Conversely, the <code>stylesheet-prefix</code> and the <termref def="dt-literal-namespace-uri">literal namespace URI</termref> will not
                     normally appear in the <termref def="dt-result-tree">result tree</termref>.</p>
               </note>
               <example>
                  <head>Using <code>xsl:namespace-alias</code> to Generate a Stylesheet</head>
                  <p>When literal result elements are being used to create element, attribute, or
                     namespace nodes that use the <termref def="dt-xslt-namespace">XSLT
                        namespace</termref> URI, the stylesheet may use an alias. </p>
                  <p>For example, the stylesheet</p>
                  <eg xml:space="preserve">&lt;xsl:stylesheet
  version="2.1"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:fo="http://www.w3.org/1999/XSL/Format"
  xmlns:axsl="file://namespace.alias"&gt;

&lt;xsl:namespace-alias stylesheet-prefix="axsl" result-prefix="xsl"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;axsl:stylesheet version="2.1"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/axsl:stylesheet&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="elements"&gt;
  &lt;axsl:template match="/"&gt;
     &lt;axsl:comment select="system-property('xsl:version')"/&gt;
     &lt;axsl:apply-templates/&gt;
  &lt;/axsl:template&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="block"&gt;
  &lt;axsl:template match="{.}"&gt;
     &lt;fo:block&gt;&lt;axsl:apply-templates/&gt;&lt;/fo:block&gt;
  &lt;/axsl:template&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg>
                  <p>will generate an XSLT stylesheet from a document of the form:</p>
                  <eg xml:space="preserve">&lt;elements&gt;
&lt;block&gt;p&lt;/block&gt;
&lt;block&gt;h1&lt;/block&gt;
&lt;block&gt;h2&lt;/block&gt;
&lt;block&gt;h3&lt;/block&gt;
&lt;block&gt;h4&lt;/block&gt;
&lt;/elements&gt;</eg>
                  <p>The output of the transformation will be a stylesheet such as the following.
                     Whitespace has been added for clarity. Note that an implementation may output
                     different namespace prefixes from those appearing in this example; however, the
                     rules guarantee that there will be a namespace node that binds the prefix
                        <code>xsl</code> to the URI
                        <code>http://www.w3.org/1999/XSL/Transform</code>, which makes it safe to
                     use the QName <code>xsl:version</code> in the content of the generated
                     stylesheet.</p>
                  <eg xml:space="preserve">&lt;xsl:stylesheet
  version="2.1"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:comment select="system-property('xsl:version')"/&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;
  
&lt;xsl:template match="p"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h1"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h2"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h3"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h4"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg>
               </example>
               <note>
                  <p>It may be necessary also to use aliases for namespaces other than the XSLT
                     namespace URI. For example, it can be useful to define an alias for the
                     namespace <code>http://www.w3.org/2001/XMLSchema-instance</code>, so that the
                     stylesheet can use the attributes <code>xsi:type</code>, <code>xsi:nil</code>,
                     and <code>xsi:schemaLocation</code> on a literal result element, without
                     running the risk that a schema processor will interpret these as applying to
                     the stylesheet itself. Equally, literal result elements belonging to a
                     namespace dealing with digital signatures might cause XSLT stylesheets to be
                     mishandled by general-purpose security software; using an alias for the
                     namespace would avoid the possibility of such mishandling.</p>
               </note>
               <example>
                  <head>Aliasing the XML Namespace</head>
                  <p>It is possible to define an alias for the XML namespace.</p>
                  <eg xml:space="preserve">
&lt;xsl:stylesheet xmlns:axml="http://www.example.com/alias-xml"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="2.1"&gt;

&lt;xsl:namespace-alias stylesheet-prefix="axml" result-prefix="xml"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;name axml:space="preserve"&gt;
    &lt;first&gt;James&lt;/first&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;last&gt;Clark&lt;/last&gt;
  &lt;/name&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg>
                  <p>produces the output:</p>
                  <eg xml:space="preserve">&lt;name xml:space="preserve"&gt;&lt;first&gt;James&lt;/first&gt; &lt;last&gt;Clark&lt;/last&gt;&lt;/name&gt;</eg>
                  <p>This allows an <code>xml:space</code> attribute to be generated in the output
                     without affecting the way the stylesheet is parsed. The same technique can be
                     used for other attributes such as <code>xml:lang</code>, <code>xml:base</code>,
                     and <code>xml:id</code>.</p>
               </example>
               <note>
                  <p>Namespace aliasing is only necessary when literal result elements are used. The
                     problem of reserved namespaces does not arise when using
                        <elcode>xsl:element</elcode> and <elcode>xsl:attribute</elcode> to construct
                     the <termref def="dt-result-tree">result tree</termref>. Therefore, as an
                     alternative to using <elcode>xsl:namespace-alias</elcode>, it is always
                     possible to achieve the desired effect by replacing literal result elements
                     with <elcode>xsl:element</elcode> and <elcode>xsl:attribute</elcode>
                     instructions.</p>
               </note>
            </div3>
         </div2>
         <div2 id="xsl-element">
            <head>Creating Element Nodes Using <code>xsl:element</code>
            </head>
            <e:element-syntax name="element">
               <e:in-category name="instruction"/>
               <e:attribute name="name" required="yes">
                  <e:attribute-value-template>
                     <e:data-type name="qname"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="namespace">
                  <e:attribute-value-template>
                     <e:data-type name="uri-reference"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="inherit-namespaces">
                  <e:constant value="yes"/>
                  <e:constant value="no"/>
               </e:attribute>
               <e:attribute name="use-attribute-sets">
                  <e:data-type name="qnames"/>
               </e:attribute>
               <e:attribute name="type">
                  <e:data-type name="qname"/>
               </e:attribute>
               <e:attribute name="validation">
                  <e:constant value="strict"/>
                  <e:constant value="lax"/>
                  <e:constant value="preserve"/>
                  <e:constant value="strip"/>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:element</elcode> instruction allows an element to be created with a
               computed name. The <termref def="dt-expanded-qname">expanded-QName</termref> of the
               element to be created is specified by a <rfc2119>required</rfc2119>
               <code>name</code> attribute and an optional <code>namespace</code> attribute.</p>
            <p>The content of the <elcode>xsl:element</elcode> instruction is a <termref def="dt-sequence-constructor">sequence constructor</termref> for the children,
               attributes, and namespaces of the created element. The sequence obtained by
               evaluating this sequence constructor (see <specref ref="sequence-constructors"/>) is
               used to construct the content of the element, as described in <specref ref="constructing-complex-content"/>.</p>
            <p>The <elcode>xsl:element</elcode> element may have a <code>use-attribute-sets</code>
               attribute, whose value is a whitespace-separated list of QNames that identify
                  <elcode>xsl:attribute-set</elcode> declarations. If this attribute is present, it
               is expanded as described in <specref ref="attribute-sets"/> to produce a sequence of
               attribute nodes. This sequence is prepended to the sequence produced as a result of
               evaluating the <!--<code>select</code> attribute or-->
               <termref def="dt-sequence-constructor">sequence constructor</termref>, as described
               in <specref ref="constructing-complex-content"/>.</p>
            <p>The result of evaluating the <elcode>xsl:element</elcode> instruction, except in
               error cases, is the newly constructed element node.</p>
            <p>The <code>name</code> attribute is interpreted as an <termref def="dt-attribute-value-template">attribute value template</termref>, whose
                  <termref def="dt-effective-value">effective value</termref>
               <rfc2119>must</rfc2119> be a <termref def="dt-lexical-qname">lexical
               QName</termref>.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0820">
                  <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the <termref def="dt-effective-value">effective
                        value</termref> of the <code>name</code> attribute <error.extra>of the
                           <elcode>xsl:element</elcode> instruction</error.extra> is not a <termref def="dt-lexical-qname">lexical QName</termref>. </p>
               </error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0830">
                  <p>In the case of an <elcode>xsl:element</elcode> instruction with no
                        <code>namespace</code> attribute, it is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if the
                        <termref def="dt-effective-value">effective value</termref> of the
                        <code>name</code> attribute is a <termref def="dt-qname">QName</termref>
                     whose prefix is not declared in an in-scope namespace declaration for the
                        <elcode>xsl:element</elcode> instruction.</p>
               </error>
            </p>
            <p>If the <code>namespace</code> attribute is not present then the <termref def="dt-qname">QName</termref> is expanded into an <termref def="dt-expanded-qname">expanded-QName</termref> using the namespace declarations
               in effect for the <elcode>xsl:element</elcode> element, including any default
               namespace declaration.</p>
            <p>If the <code>namespace</code> attribute is present, then it too is interpreted as an
                  <termref def="dt-attribute-value-template">attribute value template</termref>. The
                  <termref def="dt-effective-value">effective value</termref>
               <rfc2119>must</rfc2119> be in the lexical space of the <code>xs:anyURI</code> type.
               If the string is zero-length, then the <termref def="dt-expanded-qname">expanded-QName</termref> of the element has a null namespace URI. Otherwise, the
               string is used as the namespace URI of the <termref def="dt-expanded-qname">expanded-QName</termref> of the element to be created. The local part of the
                  <termref def="dt-lexical-qname">lexical QName</termref> specified by the
                  <code>name</code> attribute is used as the local part of the <termref def="dt-expanded-qname">expanded-QName</termref> of the element to be created.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0835">
                  <!--Text replaced by erratum E6 change 2"-->
                  <p> It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the <termref def="dt-effective-value">effective
                        value</termref> of the <code>namespace</code> attribute <error.extra>of the
                           <elcode>xsl:element</elcode> instruction</error.extra> is not in the
                     lexical space of the <code>xs:anyURI</code> data type or if it is the string
                        <code>http://www.w3.org/2000/xmlns/</code>.</p>
                  <!--End of text replaced by erratum E6-->
               </error>
            </p>
            <note>
               <p>The XDM data model requires the name of a node to be an instance of
                     <code>xs:QName</code>, and XML Schema defines the namespace part of an
                     <code>xs:QName</code> to be an instance of <code>xs:anyURI</code>. However, the
                  schema specification, and the specifications that it refers to, give
                  implementations some flexibility in how strictly they enforce these
                  constraints.</p>
            </note>
            <p>The prefix of the <termref def="dt-lexical-qname">lexical QName</termref> specified
               in the <code>name</code> attribute (or the absence of a prefix) is copied to the
               prefix part of the <termref def="dt-expanded-qname">expanded-QName</termref>
               representing the name of the new element node. In the event of a conflict a prefix
               may subsequently be added, changed, or removed during the namespace fixup process
               (see <specref ref="namespace-fixup"/>).<!--Text inserted by erratum E6 change 3"-->
               The term <emph>conflict</emph> here means any violation of the constraints defined in
                  <bibref ref="xpath-datamodel-11"/>, for example the use of the same prefix to refer
               to two different namespaces in the element and in one of its attributes, the use of
               the prefix <code>xml</code> to refer to a namespace other than the XML namespace, or
               any use of the prefix
               <code>xmlns</code>.<!--End of text inserted by erratum E6--></p>
            <p>The <elcode>xsl:element</elcode> instruction has an optional
                  <code>inherit-namespaces</code> attribute, with the value <code>yes</code> or
                  <code>no</code>. The default value is <code>yes</code>. If the value is set to
                  <code>yes</code>, or is omitted, then the namespace nodes created for the newly
               constructed element (whether these were copied from those of the source node, or
               generated as a result of namespace fixup) are copied to the children and descendants
               of the newly constructed element, as described in <specref ref="constructing-complex-content"/>. If the value is set to <code>no</code>, then
               these namespace nodes are not automatically copied to the children. This may result
               in namespace undeclarations (such as <code>xmlns=""</code> or, in the case of XML
               Namespaces 1.1, <code>xmlns:p=""</code>) appearing on the child elements when a
                  <termref def="dt-final-result-tree">final result tree</termref> is serialized.</p>
            <p>The base URI of the new element is copied from the base URI of the
                  <elcode>xsl:element</elcode> instruction in the stylesheet, unless the content of
               the new element includes an <code>xml:base</code> attribute, in which case the base
               URI of the new element is the value of that attribute, resolved (if it is a relative
               URI) against the base URI of the <elcode>xsl:element</elcode> instruction in the
               stylesheet. (Note, however, that this is only relevant when creating parentless
               elements. When the new element is copied to form a child of an element or document
               node, the base URI of the new copy is taken from that of its new parent.)</p>
            <div3 id="annotation-for-constructed-element">
               <head>Setting the Type Annotation for a Constructed Element Node</head>
               <p>The optional attributes <code>type</code> and <code>validation</code> may be used
                  on the <elcode>xsl:element</elcode> instruction to invoke validation of the
                  contents of the element against a type definition or element declaration in a
                  schema, and to determine the <termref def="dt-annotation">type
                     annotation</termref> that the new element node will carry. These attributes
                  also affect the type annotation carried by any elements and attributes that have
                  the new element node as an ancestor. These two attributes are both optional, and
                  if one is specified then the other <rfc2119>must</rfc2119> be omitted. The
                  permitted values of these attributes and their semantics are described in <specref ref="validation"/>.</p>
               <note>
                  <p>The final type annotation of the element in the <termref def="dt-result-tree">result tree</termref> also depends on the <code>type</code> and
                        <code>validation</code> attributes of the instructions used to create the
                     ancestors of the element.</p>
               </note>
            </div3>
         </div2>
         <div2 id="creating-attributes">
            <head>Creating Attribute Nodes Using <code>xsl:attribute</code>
            </head>
            <e:element-syntax name="attribute">
               <e:in-category name="instruction"/>
               <e:attribute name="name" required="yes">
                  <e:attribute-value-template>
                     <e:data-type name="qname"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="namespace">
                  <e:attribute-value-template>
                     <e:data-type name="uri-reference"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="select">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="separator">
                  <e:attribute-value-template>
                     <e:data-type name="string"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="type">
                  <e:data-type name="qname"/>
               </e:attribute>
               <e:attribute name="validation">
                  <e:constant value="strict"/>
                  <e:constant value="lax"/>
                  <e:constant value="preserve"/>
                  <e:constant value="strip"/>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent name="attribute-set"/>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:attribute</elcode> element can be used to add attributes to result
               elements whether created by literal result elements in the stylesheet or by
               instructions such as <elcode>xsl:element</elcode> or <elcode>xsl:copy</elcode>. The
                  <termref def="dt-expanded-qname">expanded-QName</termref> of the attribute to be
               created is specified by a <rfc2119>required</rfc2119>
               <code>name</code> attribute and an optional <code>namespace</code> attribute. Except
               in error cases, the result of evaluating an <elcode>xsl:attribute</elcode>
               instruction is the newly constructed attribute node.</p>
            <p>The string value of the new attribute node may be defined either by using the
                  <code>select</code> attribute, or by the <termref def="dt-sequence-constructor">sequence constructor</termref> that forms the content of the
                  <elcode>xsl:attribute</elcode> element. These are mutually exclusive. If neither
               is present, the value of the new attribute node will be a zero-length string. The way
               in which the value is constructed is specified in <specref ref="constructing-simple-content"/>.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0840">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the
                        <code>select</code> attribute of the <elcode>xsl:attribute</elcode> element
                     is present unless the element has empty content.</p>
               </error>
            </p>
            <p>If the <code>separator</code> attribute is present, then the <termref def="dt-effective-value">effective value</termref> of this attribute is used to
               separate adjacent items in the result sequence, as described in <specref ref="constructing-simple-content"/>. In the absence of this attribute, the default
               separator is a single space (#x20) when the content is specified using the
                  <code>select</code> attribute, or a zero-length string when the content is
               specified using a <termref def="dt-sequence-constructor">sequence
                  constructor</termref>.</p>
            <p>The <code>name</code> attribute is interpreted as an <termref def="dt-attribute-value-template">attribute value template</termref>, whose
                  <termref def="dt-effective-value">effective value</termref>
               <rfc2119>must</rfc2119> be a <termref def="dt-lexical-qname">lexical
               QName</termref>.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0850">
                  <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the <termref def="dt-effective-value">effective
                        value</termref> of the <code>name</code> attribute <error.extra>of an
                           <elcode>xsl:attribute</elcode> instruction</error.extra> is not a
                        <termref def="dt-lexical-qname">lexical QName</termref>.</p>
               </error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0855">
                  <p>In the case of an <elcode>xsl:attribute</elcode> instruction with no
                        <code>namespace</code> attribute, it is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if the
                        <termref def="dt-effective-value">effective value</termref> of the
                        <code>name</code> attribute is the string <code>xmlns</code>.</p>
               </error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0860">
                  <p>In the case of an <elcode>xsl:attribute</elcode> instruction with no
                        <code>namespace</code> attribute, it is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if the
                        <termref def="dt-effective-value">effective value</termref> of the
                        <code>name</code> attribute is a <termref def="dt-lexical-qname">lexical
                        QName</termref> whose prefix is not declared in an in-scope namespace
                     declaration for the <elcode>xsl:attribute</elcode> instruction.</p>
               </error>
            </p>
            <p>If the <code>namespace</code> attribute is not present, then the <termref def="dt-lexical-qname">lexical QName</termref> is expanded into an <termref def="dt-expanded-qname">expanded-QName</termref> using the namespace declarations
               in effect for the <elcode>xsl:attribute</elcode> element, <emph>not</emph> including
               any default namespace declaration.</p>
            <p>If the <code>namespace</code> attribute is present, then it too is interpreted as an
                  <termref def="dt-attribute-value-template">attribute value template</termref>. The
                  <termref def="dt-effective-value">effective value</termref>
               <rfc2119>must</rfc2119> be in the lexical space of the <code>xs:anyURI</code> type.
               If the string is zero-length, then the <termref def="dt-expanded-qname">expanded-QName</termref> of the attribute has a null namespace URI. Otherwise,
               the string is used as the namespace URI of the <termref def="dt-expanded-qname">expanded-QName</termref> of the attribute to be created. The local part of the
                  <termref def="dt-lexical-qname">lexical QName</termref> specified by the
                  <code>name</code> attribute is used as the local part of the <termref def="dt-expanded-qname">expanded-QName</termref> of the attribute to be
               created.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0865">
                  <!--Text replaced by erratum E6 change 4"-->
                  <p> It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the <termref def="dt-effective-value">effective
                        value</termref> of the <code>namespace</code> attribute <error.extra>of the
                           <elcode>xsl:attribute</elcode> instruction</error.extra> is not in the
                     lexical space of the <code>xs:anyURI</code> data type or if it is the string
                        <code>http://www.w3.org/2000/xmlns/</code>.</p>
                  <!--End of text replaced by erratum E6-->
               </error>
            </p>
            <note>
               <p>The same considerations apply as for elements: <errorref spec="XT" class="DE" code="0835"/> in <specref ref="xsl-element"/>.</p>
            </note>
            <!--Text replaced by erratum E18 change 1"-->
            <p>The prefix of the <termref def="dt-lexical-qname">lexical QName</termref> specified
               in the <code>name</code> attribute (or the absence of a prefix) is copied to the
               prefix part of the <termref def="dt-expanded-qname">expanded-QName</termref>
               representing the name of the new attribute node. In the event of a conflict this
               prefix may subsequently be added, changed, or removed during the namespace fixup
               process (see <specref ref="namespace-fixup"/>). If the attribute is in a non-null
               namespace and no prefix is specified, then the namespace fixup process will invent a
               prefix. The term <emph>conflict</emph> here means any violation of the constraints
               defined in <bibref ref="xpath-datamodel-11"/>, for example the use of the same prefix to
               refer to two different namespaces in the element and in one of its attributes, the
               use of the prefix <code>xml</code> to refer to a namespace other than the XML
               namespace, or any use of the prefix <code>xmlns</code>.</p>
            <!--End of text replaced by erratum E18-->
            <p>If the name of a constructed attribute is <code>xml:id</code>, the processor must
               perform attribute value normalization by effectively applying the
                  <xfunction>normalize-space</xfunction> function to the value of the attribute, and
               the resulting attribute node must be given the <code>is-id</code> property. This
               applies whether the attribute is constructed using the <elcode>xsl:attribute</elcode>
               instruction or whether it is constructed using an attribute of a literal result
               element. This does not imply any constraints on the value of the attribute, or on its
               uniqueness, and it does not affect the <termref def="dt-annotation">type
                  annotation</termref> of the attribute, unless the containing document is
               validated.</p>
            <note>
               <p>The effect of setting the <code>is-id</code> property is that the parent element
                  can be located within the containing document by use of the
                     <xfunction>id</xfunction> function. In effect, XSLT when constructing a
                  document performs some of the functions of an <code>xml:id</code> processor, as
                  defined in <bibref ref="xml-id"/>; the other aspects of <code>xml:id</code>
                  processing are performed during validation.</p>
            </note>
            <example>
               <head>Creating a List-Valued Attribute</head>
               <p>The following instruction creates the attribute <code>colors="red green
                     blue"</code>:</p>
               <eg xml:space="preserve">&lt;xsl:attribute name="colors" select="'red', 'green', 'blue'"/&gt;</eg>
            </example>
            <example>
               <head>Namespaces are not Attributes</head>
               <p>It is not an error to write:</p>
               <eg xml:space="preserve">&lt;xsl:attribute name="xmlns:xsl" 
   namespace="file://some.namespace"
   select="'http://www.w3.org/1999/XSL/Transform'"/&gt;</eg>
               <p>However, this will not result in the namespace declaration
                     <code>xmlns:xsl="http://www.w3.org/1999/XSL/Transform"</code> being output.
                  Instead, it will produce an attribute node with local name <code>xsl</code>, and
                  with a system-allocated namespace prefix mapped to the namespace URI
                     <code>file://some.namespace</code>. This is because the namespace fixup process
                  is not allowed to use <code>xmlns</code> as the name of a namespace node.</p>
            </example>
            <p>As described in <specref ref="constructing-complex-content"/>, in a sequence that is
               used to construct the content of an element, any attribute nodes
                  <rfc2119>must</rfc2119> appear in the sequence before any element, text, comment,
               or processing instruction nodes. Where the sequence contains two or more attribute
               nodes with the same <termref def="dt-expanded-qname">expanded-QName</termref>, the
               one that comes last is the only one that takes effect.</p>
            <note>
               <p>If a collection of attributes is generated repeatedly, this can be done
                  conveniently by using named attribute sets: see <specref ref="attribute-sets"/>
               </p>
            </note>
            <div3 id="annotation-for-constructed-attribute">
               <head>Setting the Type Annotation for a Constructed Attribute Node</head>
               <p>The optional attributes <code>type</code> and <code>validation</code> may be used
                  on the <elcode>xsl:attribute</elcode> instruction to invoke validation of the
                  contents of the attribute against a type definition or attribute declaration in a
                  schema, and to determine the <termref def="dt-annotation">type
                     annotation</termref> that the new attribute node will carry. These two
                  attributes are both optional, and if one is specified then the other
                     <rfc2119>must</rfc2119> be omitted. The permitted values of these attributes
                  and their semantics are described in <specref ref="validation"/>.</p>
               <note>
                  <p>The final <termref def="dt-annotation">type annotation</termref> of the
                     attribute in the <termref def="dt-result-tree">result tree</termref> also
                     depends on the <code>type</code> and <code>validation</code> attributes of the
                     instructions used to create the ancestors of the attribute.</p>
               </note>
            </div3>
         </div2>
         <div2 id="creating-text-nodes">
            <head>Creating Text Nodes</head>
            <p>This section describes three different ways of creating text nodes: by means of
               literal text nodes in the stylesheet, or by using the <elcode>xsl:text</elcode> and
                  <elcode>xsl:value-of</elcode> instructions. It is also possible to create text
               nodes using the <elcode>xsl:number</elcode> instruction described in <specref ref="number"/>.</p>
            <p>If and when the sequence that results from evaluating a <termref def="dt-sequence-constructor">sequence constructor</termref> is used to form the
               content of a node, as described in <specref ref="constructing-simple-content"/> and
                  <specref ref="constructing-complex-content"/>, adjacent text nodes in the sequence
               are merged. Within the sequence itself, however, they exist as distinct nodes.</p>
            <example>
               <head>A sequence of text nodes</head>
               <p>The following function returns a sequence of three text nodes:</p>
               <eg xml:space="preserve">&lt;xsl:function name="f:wrap"&gt;
  &lt;xsl:param name="s"/&gt;
  &lt;xsl:text&gt;(&lt;/xsl:text&gt;
  &lt;xsl:value-of select="$s"/&gt;
  &lt;xsl:text&gt;)&lt;/xsl:text&gt;
&lt;/xsl:function&gt;</eg>
               <p>When this function is called as follows:</p>
               <eg xml:space="preserve">&lt;xsl:value-of select="f:wrap('---')"/&gt;</eg>
               <p>the result is:</p>
               <eg xml:space="preserve">(---)</eg>
               <p>No additional spaces are inserted, because the calling
                     <elcode>xsl:value-of</elcode> instruction merges adjacent text nodes before
                  atomizing the sequence. However, the result of the instruction:</p>
               <eg xml:space="preserve">&lt;xsl:value-of select="data(f:wrap('---'))"/&gt;</eg>
               <p>is:</p>
               <eg xml:space="preserve">( --- )</eg>
               <p>because in this case the three text nodes are atomized to form three strings, and
                  spaces are inserted between adjacent strings.</p>
            </example>
            <p>It is possible to construct text nodes whose string value is zero-length. A
               zero-length text node, when atomized, produces a zero-length string. However,
               zero-length text nodes are ignored when they appear in a sequence that is used to
               form the content of a node, as described in <specref ref="constructing-complex-content"/> and <specref ref="constructing-simple-content"/>.</p>
            <div3 id="literal-text-nodes">
               <head>Literal Text Nodes</head>
               <p>A <termref def="dt-sequence-constructor">sequence constructor</termref> can
                  contain text nodes. Each text node in a sequence constructor remaining after
                     <termref def="dt-whitespace-text-node">whitespace text nodes</termref> have
                  been stripped as specified in <specref ref="stylesheet-stripping"/> will construct
                  a new text node with the same <termref def="dt-string-value">string
                     value</termref>. The resulting text node is added to the result of the
                  containing sequence constructor.</p>
               <p>Text is processed at the tree level. Thus, markup of <code>&amp;lt;</code> in a
                  template will be represented in the stylesheet tree by a text node that includes
                  the character <code>&lt;</code>. This will create a text node in the <termref def="dt-result-tree">result tree</termref> that contains a <code>&lt;</code>
                  character, which will be represented by the markup <code>&amp;lt;</code> (or an
                  equivalent character reference) when the result tree is serialized as an XML
                  document, unless otherwise specified using <termref def="dt-character-map">character maps</termref> (see <specref ref="character-maps"/>) or
                     <code>disable-output-escaping</code> (see <specref ref="disable-output-escaping"/>).</p>
            </div3>
            <div3 id="xsl-text">
               <head>Creating Text Nodes Using <code>xsl:text</code>
               </head>
               <e:element-syntax name="text">
                  <e:in-category name="instruction"/>
                  <e:attribute name="disable-output-escaping" deprecated="yes">
                     <e:constant value="yes"/>
                     <e:constant value="no"/>
                  </e:attribute>
                  <e:text/>
                  <e:allowed-parents>
                     <e:parent-category name="sequence-constructor"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p>The <elcode>xsl:text</elcode> element is evaluated to construct a new text node.
                  The content of the <elcode>xsl:text</elcode> element is a single text node whose
                  value forms the <termref def="dt-string-value">string value</termref> of the new
                  text node. An <elcode>xsl:text</elcode> element may be empty, in which case the
                  result of evaluating the instruction is a text node whose string value is the
                  zero-length string.</p>
               <p>The result of evaluating an <elcode>xsl:text</elcode> instruction is the newly
                  constructed text node.</p>
               <p>A text node that is an immediate child of an <elcode>xsl:text</elcode> instruction
                  will not be stripped from the stylesheet tree, even if it consists entirely of
                  whitespace (see <specref ref="strip"/>).</p>
               <p>For the effect of the <termref def="dt-deprecated">deprecated</termref>
                  <code>disable-output-escaping</code> attribute, see <specref ref="disable-output-escaping"/>
               </p>
               <note>
                  <p>It is not always necessary to use the <elcode>xsl:text</elcode> instruction to
                     write text nodes to the <termref def="dt-result-tree">result tree</termref>.
                     Literal text can be written to the result tree by including it anywhere in a
                        <termref def="dt-sequence-constructor">sequence constructor</termref>, while
                     computed text can be output using the <elcode>xsl:value-of</elcode>
                     instruction. The principal reason for using <elcode>xsl:text</elcode> is that
                     it offers improved control over whitespace handling.</p>
               </note>
            </div3>
            <div3 id="value-of">
               <head>Generating Text with <elcode>xsl:value-of</elcode>
               </head>
               <p>Within a <termref def="dt-sequence-constructor">sequence constructor</termref>,
                  the <elcode>xsl:value-of</elcode> instruction can be used to generate computed
                  text nodes. The <elcode>xsl:value-of</elcode> instruction computes the text using
                  an <termref def="dt-expression">expression</termref> that is specified as the
                  value of the <code>select</code> attribute, or by means of contained instructions.
                  This might, for example, extract text from a <termref def="dt-source-tree">source
                     tree</termref> or insert the value of a variable. </p>
               <e:element-syntax name="value-of">
                  <e:in-category name="instruction"/>
                  <e:attribute name="select">
                     <e:data-type name="expression"/>
                  </e:attribute>
                  <e:attribute name="separator">
                     <e:attribute-value-template>
                        <e:data-type name="string"/>
                     </e:attribute-value-template>
                  </e:attribute>
                  <e:attribute name="disable-output-escaping" deprecated="yes">
                     <e:constant value="yes"/>
                     <e:constant value="no"/>
                  </e:attribute>
                  <e:model name="sequence-constructor"/>
                  <e:allowed-parents>
                     <e:parent-category name="sequence-constructor"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p>The <elcode>xsl:value-of</elcode> instruction is evaluated to construct a new text
                  node; the result of the instruction is the newly constructed text node.</p>
               <p>The string value of the new text node may be defined either by using the
                     <code>select</code> attribute, or by the <termref def="dt-sequence-constructor">sequence constructor</termref> (see <specref ref="sequence-constructors"/>)
                  that forms the content of the <elcode>xsl:value-of</elcode> element. These are
                  mutually exclusive, and one of them must be present. The way in which the value is
                  constructed is specified in <specref ref="constructing-simple-content"/>.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0870">
                     <p>It is a <termref def="dt-static-error">static error</termref> if the
                           <code>select</code> attribute of the <elcode>xsl:value-of</elcode>
                        element is present when the content of the element is non-empty, or if the
                           <code>select</code> attribute is absent when the content is empty.</p>
                  </error>
               </p>
               <p>If the <code>separator</code> attribute is present, then the <termref def="dt-effective-value">effective value</termref> of this attribute is used to
                  separate adjacent items in the result sequence, as described in <specref ref="constructing-simple-content"/>. In the absence of this attribute, the
                  default separator is a single space (#x20) when the content is specified using the
                     <code>select</code> attribute, or a zero-length string when the content is
                  specified using a <termref def="dt-sequence-constructor">sequence
                     constructor</termref>.</p>
               <p><phrase diff="chg" at="D">Special rules apply when the instruction is processed
                     with <termref def="dt-xslt-10-behavior">XSLT 1.0 behavior</termref>.</phrase>
                  If no <code>separator</code> attribute is present, and if the <code>select</code>
                  attribute is present, then all items in the <termref def="dt-atomization">atomized</termref> result sequence other than the first are ignored.</p>
               <example>
                  <head>Generating a List with Separators</head>
                  <p>The instruction:</p>
                  <eg xml:space="preserve">&lt;x&gt;&lt;xsl:value-of select="1 to 4" separator="|"/&gt;&lt;/x&gt;</eg>
                  <p>produces the output:</p>
                  <eg xml:space="preserve">&lt;x&gt;1|2|3|4&lt;/x&gt;</eg>
               </example>
               <note>
                  <p>The <elcode>xsl:copy-of</elcode> element can be used to copy a sequence of
                     nodes to the <termref def="dt-result-tree">result tree</termref> without
                        <termref def="dt-atomization">atomization</termref>. See <specref ref="copy-of"/>.</p>
               </note>
               <p>For the effect of the <termref def="dt-deprecated">deprecated</termref>
                  <code>disable-output-escaping</code> attribute, see <specref ref="disable-output-escaping"/>
               </p>
            </div3>
         </div2>
         <div2 id="creating-document-nodes">
            <head>Creating Document Nodes</head>
            <e:element-syntax name="document">
               <e:in-category name="instruction"/>
               <e:attribute name="validation">
                  <e:constant value="strict"/>
                  <e:constant value="lax"/>
                  <e:constant value="preserve"/>
                  <e:constant value="strip"/>
               </e:attribute>
               <e:attribute name="type">
                  <e:data-type name="qname"/>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:document</elcode> instruction is used to create a new document node.
               The content of the <elcode>xsl:document</elcode> element is a <termref def="dt-sequence-constructor">sequence constructor</termref> for the children of
               the new document node. A document node is created, and the sequence obtained by
               evaluating the sequence constructor is used to construct the content of the document,
               as described in <specref ref="constructing-complex-content"/>. The <termref def="dt-temporary-tree">temporary tree</termref> rooted at this document node
               forms the <termref def="dt-result-tree">result tree</termref>.</p>
            <p>Except in error situations, the result of evaluating the
                  <elcode>xsl:document</elcode> instruction is a single node, the newly constructed
               document node.</p>
            <note>
               <p>The new document is not serialized. To construct a document that is to form a
                  final result rather than an intermediate result, use the
                     <elcode>xsl:result-document</elcode> instruction described in <specref ref="creating-result-trees"/>.</p>
            </note>
            <p>The optional attributes <code>type</code> and <code>validation</code> may be used on
               the <elcode>xsl:document</elcode> instruction to validate the contents of the new
               document, and to determine the <termref def="dt-annotation">type annotation</termref>
               that elements and attributes within the <termref def="dt-result-tree">result
                  tree</termref> will carry. The permitted values and their semantics are described
               in <specref ref="validating-document-nodes"/>.</p>
            <p>The base URI of the new document node is taken from the base URI of the
                  <elcode>xsl:document</elcode> instruction.</p>
            <p>The <code>document-uri</code> and <code>unparsed-entities</code> properties of the
               new document node are set to empty.</p>
            <example>
               <head>Checking Uniqueness Constraints in a Temporary Tree</head>
               <p>The following example creates a temporary tree held in a variable. The use of an
                  enclosed <elcode>xsl:document</elcode> instruction ensures that uniqueness
                  constraints defined in the schema for the relevant elements are checked.</p>
               <eg xml:space="preserve">&lt;xsl:variable name="tree" as="document-node()"&gt;
  &lt;xsl:document validation="strict"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:document&gt;
&lt;/xsl:variable&gt;</eg>
            </example>
         </div2>
         <div2 id="creating-processing-instructions">
            <head>Creating Processing Instructions</head>
            <e:element-syntax name="processing-instruction">
               <e:in-category name="instruction"/>
               <e:attribute name="name" required="yes">
                  <e:attribute-value-template>
                     <e:data-type name="ncname"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="select">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:processing-instruction</elcode> element is evaluated to create a
               processing instruction node.</p>
            <p>The <elcode>xsl:processing-instruction</elcode> element has a
                  <rfc2119>required</rfc2119>
               <code>name</code> attribute that specifies the name of the processing instruction
               node. The value of the <code>name</code> attribute is interpreted as an <termref def="dt-attribute-value-template">attribute value template</termref>.</p>
            <p>The string value of the new processing-instruction node may be defined either by
               using the <code>select</code> attribute, or by the <termref def="dt-sequence-constructor">sequence constructor</termref> that forms the
               content of the <elcode>xsl:processing-instruction</elcode> element. These are
               mutually exclusive. If neither is present, the string value of the new
               processing-instruction node will be a zero-length string. The way in which the value
               is constructed is specified in <specref ref="constructing-simple-content"/>.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0880">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the
                        <code>select</code> attribute of the
                        <elcode>xsl:processing-instruction</elcode> element is present unless the
                     element has empty content.</p>
               </error>
            </p>
            <p>Except in error situations, the result of evaluating the
                  <elcode>xsl:processing-instruction</elcode> instruction is a single node, the
               newly constructed processing instruction node.</p>
            <example>
               <head>Creating a Processing Instruction</head>
               <p>This instruction:</p>
               <eg xml:space="preserve">&lt;xsl:processing-instruction name="xml-stylesheet"
  select="('href=&amp;quot;book.css&amp;quot;', 'type=&amp;quot;text/css&amp;quot;)"/&gt;</eg>
               <p>creates the processing instruction</p>
               <eg xml:space="preserve">&lt;?xml-stylesheet href="book.css" type="text/css"?&gt;</eg>
               <p>Note that the <code>xml-stylesheet</code> processing instruction contains
                     <emph>pseudo-attributes</emph> in the form <code>name="value"</code>. Although
                  these have the same textual form as attributes in an element start tag, they are
                  not represented as XDM attribute nodes, and cannot therefore be constructed using
                     <elcode>xsl:attribute</elcode> instructions.</p>
            </example>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0890">
                  <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the <termref def="dt-effective-value">effective
                        value</termref> of the <code>name</code> attribute <error.extra>of the
                           <elcode>xsl:processing-instruction</elcode> instruction</error.extra> is
                     not both an <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names" ref="NT-NCName" xlink:type="simple">NCName</xnt> and a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XML" ref="PITarget" xlink:type="simple">PITarget</xnt>.</p>
               </error>
            </p>
            <note>
               <p>Because these rules disallow the name <code>xml</code>, the
                     <elcode>xsl:processing-instruction</elcode> cannot be used to output an XML
                  declaration. The <elcode>xsl:output</elcode> declaration should be used to control
                  this instead (see <specref ref="serialization"/>).</p>
            </note>
            <p>If the result of evaluating the content of the
                  <elcode>xsl:processing-instruction</elcode> contains the string
               <code>?&gt;</code>, this string is modified by inserting a space between the
                  <code>?</code> and <code>&gt;</code> characters.</p>
            <p>The base URI of the new processing-instruction is copied from the base URI of the
                  <elcode>xsl:processing-instruction</elcode> element in the stylesheet. (Note,
               however, that this is only relevant when creating a parentless processing
               instruction. When the new processing instruction is copied to form a child of an
               element or document node, the base URI of the new copy is taken from that of its new
               parent.)</p>
         </div2>
         <div2 id="creating-namespace-nodes">
            <head>Creating Namespace Nodes</head>
            <e:element-syntax name="namespace">
               <e:in-category name="instruction"/>
               <e:attribute name="name" required="yes">
                  <e:attribute-value-template>
                     <e:data-type name="ncname"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="select">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:namespace</elcode> element is evaluated to create a namespace node.
               Except in error situations, the result of evaluating the
                  <elcode>xsl:namespace</elcode> instruction is a single node, the newly constructed
               namespace node.</p>
            <p>The <elcode>xsl:namespace</elcode> element has a <rfc2119>required</rfc2119>
               <code>name</code> attribute that specifies the name of the namespace node (that is,
               the namespace prefix). The value of the <code>name</code> attribute is interpreted as
               an <termref def="dt-attribute-value-template">attribute value template</termref>. If
               the <termref def="dt-effective-value">effective value</termref> of the
                  <code>name</code> attribute is a zero-length string, a namespace node is added for
               the default namespace.</p>
            <p>The string value of the new namespace node (that is, the namespace URI) may be
               defined either by using the <code>select</code> attribute, or by the <termref def="dt-sequence-constructor">sequence constructor</termref> that forms the
               content of the <elcode>xsl:namespace</elcode> element. These are mutually exclusive.
               Since the string value of a namespace node cannot be a zero-length string, one of
               them must be present. The way in which the value is constructed is specified in
                  <specref ref="constructing-simple-content"/>.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0905">
                  <!--Text replaced by erratum E6 change 6"-->
                  <p>It is a non-recoverable dynamic error if the string value of the new namespace
                     node is not valid in the lexical space of the data type <code>xs:anyURI</code>,
                     or if it is the string <code>http://www.w3.org/2000/xmlns/</code>.</p>
                  <!--End of text replaced by erratum E6-->
               </error>
            </p>
            <p>
               <error spec="XT" type="static" class="SE" code="0910">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the
                        <code>select</code> attribute of the <elcode>xsl:namespace</elcode> element
                     is present when the element has content other than one or more
                        <elcode>xsl:fallback</elcode> instructions, or if the <code>select</code>
                     attribute is absent when the element has empty content.</p>
               </error>
            </p>
            <p>Note the restrictions described in <specref ref="constructing-complex-content"/> for
               the position of a namespace node relative to other nodes in the node sequence
               returned by a sequence constructor.</p>
            <example>
               <head>Constructing a QName-Valued Attribute</head>
               <p>This literal result element:</p>
               <eg xml:space="preserve">&lt;data xsi:type="xs:integer" 
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
  &lt;xsl:namespace name="xs" 
                 select="'http://www.w3.org/2001/XMLSchema'"/&gt;
  &lt;xsl:text&gt;42&lt;/xsl:text&gt;
&lt;/data&gt;</eg>
               <p>would typically cause the output document to contain the element:</p>
               <eg xml:space="preserve">&lt;data xsi:type="xs:integer"
     xmlns:xs="http://www.w3.org/2001/XMLSchema"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;42&lt;/data&gt;</eg>
               <p>In this case, the element is constructed using a literal result element, and the
                  namespace <code>xmlns:xs="http://www.w3.org/2001/XMLSchema"</code> could therefore
                  have been added to the <termref def="dt-result-tree">result tree</termref> simply
                  by declaring it as one of the in-scope namespaces in the stylesheet. In practice,
                  the <elcode>xsl:namespace</elcode> instruction is more likely to be useful in
                  situations where the element is constructed using an <elcode>xsl:element</elcode>
                  instruction, which does not copy all the in-scope namespaces from the
                  stylesheet.</p>
            </example>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0920">
                  <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the <termref def="dt-effective-value">effective
                        value</termref> of the <code>name</code> attribute <error.extra>of the
                           <elcode>xsl:namespace</elcode> instruction</error.extra> is neither a
                     zero-length string nor an <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names" ref="NT-NCName" xlink:type="simple">NCName</xnt>, or if
                     it is <code>xmlns</code>. </p>
               </error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0925">
                  <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the <elcode>xsl:namespace</elcode> instruction generates
                     a namespace node whose name is <code>xml</code> and whose string value is not
                        <code>http://www.w3.org/XML/1998/namespace</code>, or a namespace node whose
                     string value is <code>http://www.w3.org/XML/1998/namespace</code> and whose
                     name is not <code>xml</code>.</p>
               </error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0930">
                  <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if evaluating the <code>select</code> attribute or the
                     contained <termref def="dt-sequence-constructor">sequence constructor</termref>
                     of an <elcode>xsl:namespace</elcode> instruction results in a zero-length
                     string. </p>
               </error>
            </p>
            <p>For details of other error conditions that may arise, see <specref ref="sequence-constructors"/>.</p>
            <note>
               <p>It is rarely necessary to use <elcode>xsl:namespace</elcode> to create a namespace
                  node in the <termref def="dt-result-tree">result tree</termref>; in most
                  circumstances, the required namespace nodes will be created automatically, as a
                  side-effect of writing elements or attributes that use the namespace. An example
                  where <elcode>xsl:namespace</elcode> is needed is a situation where the required
                  namespace is used only within attribute values in the result document, not in
                  element or attribute names; especially where the required namespace prefix or
                  namespace URI is computed at run-time and is not present in either the source
                  document or the stylesheet.</p>
               <p>Adding a namespace node to the <termref def="dt-result-tree">result tree</termref>
                  will never change the <termref def="dt-expanded-qname">expanded-QName</termref> of
                  any element or attribute node in the result tree: that is, it will never change
                  the namespace URI of an element or attribute. It might, however, constrain the
                  choice of prefixes when namespace fixup is performed.</p>
               <!--Text replaced by erratum E7 change 1"-->
               <p>Namespace prefixes for element and attribute names are initially established by
                  the rules of the instruction that creates the element or attribute node, and in
                  the event of conflicts, they may be changed by the namespace fixup process
                  described in <specref ref="namespace-fixup"/>. The fixup process ensures that an
                  element has in-scope namespace nodes for the namespace URIs used in the element
                  name and in its attribute names, and the serializer will typically use these
                  namespace nodes to determine the prefix to use in the serialized output. The fixup
                  process cannot generate namespace nodes that are inconsistent with those already
                  present in the tree. This means that it is not possible for the processor to
                  decide the prefix to use for an element or for any of its attributes until all the
                  namespace nodes for the element have been added.</p>
               <!--End of text replaced by erratum E7-->
               <p>If a namespace prefix is mapped to a particular namespace URI using the
                     <elcode>xsl:namespace</elcode> instruction, or by using
                     <elcode>xsl:copy</elcode> or <elcode>xsl:copy-of</elcode> to copy a namespace
                  node, this prevents the namespace fixup process (and hence the serializer) from
                  using the same prefix for a different namespace URI on the same element.</p>
            </note>
            <example>
               <head>Conflicting Namespace Prefixes</head>
               <p>Given the instruction:</p>
               <eg xml:space="preserve">&lt;xsl:element name="p:item" 
                 xmlns:p="http://www.example.com/p"&gt;
  &lt;xsl:namespace name="p"&gt;http://www.example.com/q&lt;/xsl:namespace&gt;
&lt;/xsl:element&gt;</eg>
               <p>a possible serialization of the <termref def="dt-result-tree">result
                     tree</termref> is:</p>
               <eg xml:space="preserve">&lt;ns0:item 
    xmlns:ns0="http://www.example.com/p" 
    xmlns:p="http://www.example.com/q"/&gt;</eg>
               <p>The processor must invent a namespace prefix for the URI <code>p.uri</code>; it
                  cannot use the prefix <code>p</code> because that prefix has been explicitly
                  associated with a different URI.</p>
            </example>
            <note>
               <p>The <elcode>xsl:namespace</elcode> instruction cannot be used to generate a
                     <term>namespace undeclaration</term> of the form <code>xmlns=""</code> (nor the
                  new forms of namespace undeclaration permitted in <bibref ref="xml-names11"/>).
                  Namespace undeclarations are generated automatically by the serializer if
                     <code>undeclare-prefixes="yes"</code> is specified on
                     <elcode>xsl:output</elcode>, whenever a parent element has a namespace node for
                  the default namespace prefix, and a child element has no namespace node for that
                  prefix.</p>
            </note>
         </div2>
         <div2 id="creating-comments">
            <head>Creating Comments</head>
            <e:element-syntax name="comment">
               <e:in-category name="instruction"/>
               <e:attribute name="select">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:comment</elcode> element is evaluated to construct a new comment
               node. Except in error cases, the result of evaluating the
                  <elcode>xsl:comment</elcode> instruction is a single node, the newly constructed
               comment node.</p>
            <p>The string value of the new comment node may be defined either by using the
                  <code>select</code> attribute, or by the <termref def="dt-sequence-constructor">sequence constructor</termref> that forms the content of the
                  <elcode>xsl:comment</elcode> element. These are mutually exclusive. If neither is
               present, the value of the new comment node will be a zero-length string. The way in
               which the value is constructed is specified in <specref ref="constructing-simple-content"/>.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0940">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the
                        <code>select</code> attribute of the <elcode>xsl:comment</elcode> element is
                     present unless the element has empty content.</p>
               </error>
            </p>
            <example>
               <head>Generating a Comment Node</head>
               <p>For example, this</p>
               <eg xml:space="preserve">&lt;xsl:comment&gt;This file is automatically generated. Do not edit!&lt;/xsl:comment&gt;</eg>
               <p>would create the comment</p>
               <eg xml:space="preserve">&lt;!--This file is automatically generated. Do not edit!--&gt;</eg>
            </example>
            <p>In the generated comment node, the processor <rfc2119>must</rfc2119> insert a space
               after any occurrence of <code>-</code> that is followed by another <code>-</code> or
               that ends the comment.</p>
         </div2>
         <div2 id="copying">
            <head>Copying Nodes</head>
            <div3 id="shallow-copy">
               <head>Shallow Copy</head>

               <e:element-syntax name="copy" diff="chg" at="C">
                  <e:in-category name="instruction"/>
                  <e:attribute name="select">
                     <e:data-type name="expression"/>
                  </e:attribute>
                  <e:attribute name="copy-namespaces">
                     <e:constant value="yes"/>
                     <e:constant value="no"/>
                  </e:attribute>
                  <e:attribute name="inherit-namespaces">
                     <e:constant value="yes"/>
                     <e:constant value="no"/>
                  </e:attribute>
                  <e:attribute name="use-attribute-sets">
                     <e:data-type name="qnames"/>
                  </e:attribute>
                  <e:attribute name="type">
                     <e:data-type name="qname"/>
                  </e:attribute>
                  <e:attribute name="validation">
                     <e:constant value="strict"/>
                     <e:constant value="lax"/>
                     <e:constant value="preserve"/>
                     <e:constant value="strip"/>
                  </e:attribute>
                  <e:model name="sequence-constructor"/>
                  <e:allowed-parents>
                     <e:parent-category name="sequence-constructor"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p>The <elcode>xsl:copy</elcode> instruction provides a way of copying <phrase diff="chg">a selected item. The selected item is the item selected by
                     evaluating the expression in the <code>select</code> attribute if present, or
                     the <termref def="dt-context-item">context item</termref> otherwise</phrase>.
                  If the selected item is a node, evaluating the <elcode>xsl:copy</elcode>
                  instruction constructs a copy of the selected node, and the result of the
                     <elcode>xsl:copy</elcode> instruction is this newly constructed node. By
                  default, the namespace nodes of the context node are automatically copied as well,
                  but the attributes and children of the node are not automatically copied.</p>
               <p>When the <phrase diff="chg" at="C">selected item</phrase> is an atomic value
                     <phrase diff="add" at="C">or function item</phrase>, the
                     <elcode>xsl:copy</elcode> instruction returns this value. The <termref def="dt-sequence-constructor">sequence constructor</termref>, if present, is
                  not evaluated, <phrase diff="add" at="C">and <rfc2119>must not</rfc2119> generate
                     any <termref def="dt-type-error">type errors</termref>.</phrase></p>
               <p>When the <phrase diff="chg" at="C">selected item</phrase> is an attribute node,
                  text node, comment node, processing instruction node, or namespace node, the
                     <elcode>xsl:copy</elcode> instruction returns a new node that is a copy of the
                  context node. The new node will have the same node kind, name, and string value as
                  the context node. In the case of an attribute node, it will also have the same
                  values for the <code>is-id</code> and <code>is-idrefs</code> properties. The
                     <termref def="dt-sequence-constructor">sequence constructor</termref>, if
                  present, is not evaluated, <phrase diff="add" at="C">and <rfc2119>must
                        not</rfc2119> generate any <termref def="dt-type-error">type
                        errors</termref>.</phrase>.</p>

               <p>When the <phrase diff="chg" at="C">selected item</phrase> is a document node or
                  element node, the <elcode>xsl:copy</elcode> instruction returns a new node that
                  has the same node kind and name as the <phrase diff="chg" at="C">selected</phrase>
                  node. The content of the new node is formed by evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref> contained in the
                     <elcode>xsl:copy</elcode> instruction. The sequence obtained by evaluating this
                  sequence constructor is used (after prepending any attribute nodes or namespace
                  nodes as described in the following paragraphs) to construct the content of the
                  document or element node, as described in <specref ref="constructing-complex-content"/>.</p>
               <p diff="add" at="C">If the <code>select</code> expression returns an empty sequence,
                  the <elcode>xsl:copy</elcode> instruction returns an empty sequence, and the
                  contained <termref def="dt-sequence-constructor">sequence constructor</termref> is
                  not evaluated.</p>
               <p diff="add" at="C"><error spec="XT" type="type" class="TE" code="2170">
                     <p>It is a <termref def="dt-type-error">type error</termref> if the result of
                        evaluating the <code>select</code> expression <error.extra>of the
                              <elcode>xsl:copy</elcode> element</error.extra> is a sequence of more
                        than one item.</p>
                  </error></p>
               <note diff="del" at="C">
                  <p>The <elcode>xsl:copy</elcode> instruction is most useful when copying element
                     nodes. In other cases, the <elcode>xsl:copy-of</elcode> instruction is more
                     flexible, because it has a <code>select</code> attribute allowing selection of
                     the nodes or values to be copied.</p>
               </note>
               <p>The <elcode>xsl:copy</elcode> instruction has an optional
                     <code>use-attribute-sets</code> attribute, whose value is a
                  whitespace-separated list of QNames that identify
                     <elcode>xsl:attribute-set</elcode> declarations. This attribute is used only
                  when copying element nodes. This list is expanded as described in <specref ref="attribute-sets"/> to produce a sequence of attribute nodes. This sequence
                  is prepended to the sequence produced as a result of evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref>.</p>
               <p>The <elcode>xsl:copy</elcode> instruction has an optional
                     <code>copy-namespaces</code> attribute, with the value <code>yes</code> or
                     <code>no</code>. The default value is <code>yes</code>. The attribute is used
                  only when copying element nodes. If the value is set to <code>yes</code>, or is
                  omitted, then all the namespace nodes of the source element are copied as
                  namespace nodes for the result element. These copied namespace nodes are prepended
                  to the sequence produced as a result of evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref> (it is immaterial
                  whether they come before or after any attribute nodes produced by expanding the
                     <code>use-attribute-sets</code> attribute). If the value is set to
                     <code>no</code>, then the namespace nodes are not copied. However, namespace
                  nodes will still be added to the result element as <rfc2119>required</rfc2119> by
                  the namespace fixup process: see <specref ref="namespace-fixup"/>.</p>
               <p>The <elcode>xsl:copy</elcode> instruction has an optional
                     <code>inherit-namespaces</code> attribute, with the value <code>yes</code> or
                     <code>no</code>. The default value is <code>yes</code>. The attribute is used
                  only when copying element nodes. If the value is set to <code>yes</code>, or is
                  omitted, then the namespace nodes created for the newly constructed element
                  (whether these were copied from those of the source node, or generated as a result
                  of namespace fixup) are copied to the children and descendants of the newly
                  constructed element, as described in <specref ref="constructing-complex-content"/>. If the value is set to <code>no</code>, then these namespace nodes are not
                  automatically copied to the children. This may result in namespace undeclarations
                  (such as <code>xmlns=""</code> or, in the case of XML Namespaces 1.1,
                     <code>xmlns:p=""</code>) appearing on the child elements when a <termref def="dt-final-result-tree">final result tree</termref> is serialized.</p>
               <p>
                  <error spec="XT" type="static" class="TE" code="0950">
                     <p>It is a <termref def="dt-type-error">type error</termref> to use the
                           <elcode>xsl:copy</elcode> or <elcode>xsl:copy-of</elcode> instruction to
                        copy a node that has namespace-sensitive content if the
                           <code>copy-namespaces</code> attribute has the value <code>no</code> and
                        its explicit or implicit <code>validation</code> attribute has the value
                           <code>preserve</code>. It is also a type error if either of these
                        instructions (with <code>validation="preserve"</code>) is used to copy an
                        attribute having namespace-sensitive content, unless the parent element is
                        also copied. A node has namespace-sensitive content if its typed value
                        contains an item of type <code>xs:QName</code> or <code>xs:NOTATION</code>
                        or a type derived therefrom. The reason this is an error is because the
                        validity of the content depends on the namespace context being
                        preserved.</p>
                  </error>
               </p>
               <note>
                  <p>When attribute nodes are copied, whether with <elcode>xsl:copy</elcode> or with
                        <elcode>xsl:copy-of</elcode>, the processor does not automatically copy any
                     associated namespace information. The namespace used in the attribute name
                     itself will be declared by virtue of the namespace fixup process (see <specref ref="namespace-fixup"/>) when the attribute is added to an element in the
                        <termref def="dt-result-tree">result tree</termref>, but if namespace
                     prefixes are used in the content of the attribute (for example, if the value of
                     the attribute is an XPath expression) then it is the responsibility of the
                     stylesheet author to ensure that suitable namespace nodes are added to the
                        <termref def="dt-result-tree">result tree</termref>. This can be achieved by
                     copying the namespace nodes using <elcode>xsl:copy</elcode>, or by generating
                     them using <elcode>xsl:namespace</elcode>.</p>
               </note>
               <p>The optional attributes <code>type</code> and <code>validation</code> may be used
                  on the <elcode>xsl:copy</elcode> instruction to validate the contents of an
                  element, attribute or document node against a type definition, element
                  declaration, or attribute declaration in a schema, and thus to determine the
                     <termref def="dt-annotation">type annotation</termref> that the new copy of an
                  element or attribute node will carry. These attributes are ignored when copying an
                  item that is not an element, attribute or document node. When the node being
                  copied is an element or document node, these attributes also affect the type
                  annotation carried by any elements and attributes that have the copied element or
                  document node as an ancestor. These two attributes are both optional, and if one
                  is specified then the other <rfc2119>must</rfc2119> be omitted. The permitted
                  values of these attributes and their semantics are described in <specref ref="validation"/>.</p>
               <note>
                  <p>The final <termref def="dt-annotation">type annotation</termref> of the node in
                     the <termref def="dt-result-tree">result tree</termref> also depends on the
                        <code>type</code> and <code>validation</code> attributes of the instructions
                     used to create the ancestors of the node.</p>
               </note>
               <p>The base URI of a node is copied, except in the case of an element node having an
                     <code>xml:base</code> attribute, in which case the base URI of the new node is
                  taken as the value of the <code>xml:base</code> attribute, resolved if it is
                  relative against the base URI of the <elcode>xsl:copy</elcode> instruction. If the
                  copied node is subsequently attached as a child to a new element or document node,
                  the final copy of the node inherits its base URI from its parent node, unless this
                  is overridden using an <code>xml:base</code> attribute.</p>
               <p>When an <code>xml:id</code> attribute is copied, using either the
                     <elcode>xsl:copy</elcode> or <elcode>xsl:copy-of</elcode> instruction, it is
                     <termref def="dt-implementation-defined">implementation-defined</termref>
                  whether the value of the attribute is subjected to attribute value normalization
                  (that is, effectively applying the <xfunction>normalize-space</xfunction>
                  function).</p>
               <note>
                  <p>In most cases the value will already have been subjected to attribute value
                     normalization on the source tree, but if this processing has not been performed
                     on the source tree, it is not an error for it to be performed on the result
                     tree.</p>
               </note>
               <imp-def-feature>If an <code>xml:id</code> attribute that has not been subjected to
                  attribute value normalization is copied from a source tree to a result tree, it is
                  implementation-defined whether attribute value normalization will be applied
                  during the copy process.</imp-def-feature>
               <issue id="issue-context-in-shallow-copy" status="open">
                  <p>Should the contained sequence constructor be evaluated with the selected node
                     as the context item? Use cases such as use in <elcode>xsl:function</elcode>
                     probably would suggest yes.</p>
               </issue>
            </div3>
            <div3 id="copy-of">
               <head>Deep Copy</head>
               <e:element-syntax name="copy-of">
                  <e:in-category name="instruction"/>
                  <e:attribute name="select" required="yes">
                     <e:data-type name="expression"/>
                  </e:attribute>
                  <e:attribute name="copy-namespaces">
                     <e:constant value="yes"/>
                     <e:constant value="no"/>
                  </e:attribute>
                  <e:attribute name="type">
                     <e:data-type name="qname"/>
                  </e:attribute>
                  <e:attribute name="validation">
                     <e:constant value="strict"/>
                     <e:constant value="lax"/>
                     <e:constant value="preserve"/>
                     <e:constant value="strip"/>
                  </e:attribute>
                  <e:empty/>
                  <e:allowed-parents>
                     <e:parent-category name="sequence-constructor"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p>The <elcode>xsl:copy-of</elcode> instruction can be used to construct a copy of a
                  sequence of nodes, atomic values, <phrase diff="add" at="C">and/or function
                     items</phrase> with each new node containing copies of all the children,
                  attributes, and (by default) namespaces of the original node, recursively. The
                  result of evaluating the instruction is a sequence of items corresponding
                  one-to-one with the supplied sequence, and retaining its order.</p>
               <p>The <rfc2119>required</rfc2119>
                  <code>select</code> attribute contains an <termref def="dt-expression">expression</termref>, whose value may be any sequence of nodes, atomic values,
                     <phrase diff="add" at="C">and/or function items</phrase>. The items in this
                  sequence are processed as follows:</p>
               <ulist>
                  <item>
                     <p>If the item is an element node, a new element is constructed and appended to
                        the result sequence. The new element will have the same <termref def="dt-expanded-qname">expanded-QName</termref> as the original, and it
                        will have deep copies of the attribute nodes and children of the element
                        node.</p>
                     <p>The new element will also have namespace nodes copied from the original
                        element node, unless they are excluded by specifying
                           <code>copy-namespaces="no"</code>. If this attribute is omitted, or takes
                        the value <code>yes</code>, then all the namespace nodes of the original
                        element are copied to the new element. If it takes the value
                        <code>no</code>, then none of the namespace nodes are copied: however,
                        namespace nodes will still be created in the <termref def="dt-result-tree">result tree</termref> as <rfc2119>required</rfc2119> by the namespace
                        fixup process: see <specref ref="namespace-fixup"/>. This attribute affects
                        all elements copied by this instruction: both elements selected directly by
                        the <code>select</code>
                        <termref def="dt-expression">expression</termref>, and elements that are
                        descendants of nodes selected by the <code>select</code> expression. </p>
                     <p>The new element will have the same values of the <code>is-id</code>,
                           <code>is-idrefs</code>, and <code>nilled</code> properties as the
                        original element.</p>
                  </item>
                  <item>
                     <p>If the item is a document node, the instruction adds a new document node to
                        the result sequence; the children of this document node will be one-to-one
                        copies of the children of the original document node (each copied according
                        to the rules for its own node kind).</p>
                  </item>
                  <item>
                     <p>If the item is an attribute or namespace node, or a text node, a comment, or
                        a processing instruction, the same rules apply as with
                           <elcode>xsl:copy</elcode> (see <specref ref="shallow-copy"/>).</p>
                  </item>
                  <item>
                     <p>If the item is an atomic value <phrase diff="add" at="C">or a function
                           item</phrase>, the value is appended to the result sequence, as with
                           <elcode>xsl:sequence</elcode>.</p>
                  </item>
               </ulist>
               <p>The optional attributes <code>type</code> and <code>validation</code> may be used
                  on the <elcode>xsl:copy-of</elcode> instruction to validate the contents of an
                  element, attribute or document node against a type definition, element
                  declaration, or attribute declaration in a schema and thus to determine the
                     <termref def="dt-annotation">type annotation</termref> that the new copy of an
                  element or attribute node will carry. These attributes are applied individually to
                  each element, attribute, and document node that is selected by the expression in
                  the <code>select</code> attribute. These attributes are ignored when copying an
                  item that is not an element, attribute or document node.</p>
               <p>The specified <code>type</code> and <code>validation</code> apply directly only to
                  elements, attributes and document nodes created as copies of nodes actually
                  selected by the <code>select</code> expression, they do not apply to nodes that
                  are implicitly copied because they have selected nodes as an ancestor. However,
                  these attributes do indirectly affect the <termref def="dt-annotation">type
                     annotation</termref> carried by such implicitly copied nodes, as a consequence
                  of the validation process.</p>
               <p>These two attributes are both optional, and if one is specified then the other
                     <rfc2119>must</rfc2119> be omitted. The permitted values of these attributes
                  and their semantics are described in <specref ref="validation"/>.</p>
               <p>Errors may occur when copying namespace-sensitive elements or attributes using
                     <code>validation="preserve"</code>. <errorref class="TE" code="0950"/>.</p>
               <p>The base URI of a node is copied, except in the case of an element node having an
                     <code>xml:base</code> attribute, in which case the base URI of the new node is
                  taken as the value of the <code>xml:base</code> attribute, resolved if it is
                  relative against the base URI of the <elcode>xsl:copy-of</elcode> instruction. If
                  the copied node is subsequently attached as a child to a new element or document
                  node, the final copy of the node inherits its base URI from its parent node,
                  unless this is overridden using an <code>xml:base</code> attribute.</p>
            </div3>
         </div2>
         <div2 id="constructing-sequences">
            <head>Constructing Sequences</head>
            <e:element-syntax name="sequence">
               <e:in-category name="instruction"/>
               <e:attribute name="select" required="yes">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:sequence</elcode> instruction may be used within a <termref def="dt-sequence-constructor">sequence constructor</termref> to construct a
               sequence of nodes, atomic values, <phrase diff="add" at="C">and/or function
                  items</phrase>. This sequence is returned as the result of the instruction. Unlike
               most other instructions, <elcode>xsl:sequence</elcode> can return a sequence
               containing existing nodes, rather than constructing new nodes. When
                  <elcode>xsl:sequence</elcode> is used to add atomic values <phrase diff="add" at="C">or function items</phrase> to a sequence, the effect is very similar to the
                  <elcode>xsl:copy-of</elcode> instruction.</p>
            <p diff="chg" at="E">The items comprising the result sequence are evaluated either using
               the <code>select</code> attribute, or using the contained <termref def="dt-sequence-constructor"/>. These are mutually exclusive; if the instruction
               has a <code>select</code> attribute, then it <rfc2119>must</rfc2119> have no children
               other than <elcode>xsl:fallback</elcode> instructions. If there is no
               <code>select</code> attribute and no contained <termref def="dt-sequence-constructor"/>, the result is
               an empty sequence.</p>
            <p>Any contained <elcode>xsl:fallback</elcode> instructions are ignored by an XSLT 2.0
                  <phrase diff="add" at="A">or 2.1</phrase> processor, but can be used to define
               fallback behavior for an XSLT 1.0 processor running in forwards compatibility
               mode.</p>
            <example>
               <head>Constructing a Sequence of Integers</head>
               <p>For example, the following code:</p>
               <eg xml:space="preserve">&lt;xsl:variable name="values" as="xs:integer*"&gt;
    &lt;xsl:sequence select="(1,2,3,4)"/&gt;
    &lt;xsl:sequence select="(8,9,10)"/&gt;
&lt;/xsl:variable&gt;
&lt;xsl:value-of select="sum($values)"/&gt;</eg>
               <p>produces the output: <code>37</code>
               </p>
            </example>
            <example>
               <head>Using <code>xsl:for-each</code> to Construct a Sequence</head>
               <p>The following code constructs a sequence containing the value of the
                     <code>@price</code> attribute for selected elements (which we assume to be
                  typed as <code>xs:decimal</code>), or a computed price for those elements that
                  have no <code>@price</code> attribute. It then returns the average price:</p>
               <eg xml:space="preserve">&lt;xsl:variable name="prices" as="xs:decimal*"&gt;
  &lt;xsl:for-each select="//product"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="@price"&gt;
        &lt;xsl:sequence select="@price"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:sequence select="@cost * 1.5"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:variable&gt;
&lt;xsl:value-of select="avg($prices)"/&gt;</eg>
               <p>Note that the existing <code>@price</code> attributes could equally have been
                  added to the <code>$prices</code> sequence using <elcode>xsl:copy-of</elcode> or
                     <elcode>xsl:value-of</elcode>. However, <elcode>xsl:copy-of</elcode> would
                  create a copy of the attribute node, which is not needed in this situation, while
                     <elcode>xsl:value-of</elcode> would create a new text node, which then has to
                  be converted to an <code>xs:decimal</code>. Using <elcode>xsl:sequence</elcode>,
                  which in this case atomizes the existing attribute node and adds an
                     <code>xs:decimal</code> atomic value to the result sequence, is a more direct
                  way of achieving the same result.</p>
               <p>This example could alternatively be solved at the XPath level:</p>
               <eg xml:space="preserve">&lt;xsl:value-of select="avg(//product/(+@price, @cost*1.5)[1])"/&gt;</eg>
               <p>The apparently redundant <code>+</code> operator is there to atomize the attribute
                  value: the expression on the right hand side of the <code>/</code> operator must
                  not return a <phrase diff="chg" at="C"> sequence containing both nodes and
                     non-nodes (atomic values or function items).</phrase></p>
            </example>
            <note diff="add" at="E">
               <p>The main use case for allowing <elcode>xsl:sequence</elcode> to contain a sequence
                  constructor is to allow the instructions within an <elcode>xsl:fork</elcode>
                  element to be divided into groups.</p>
            </note>
         </div2>
      </div1>
      <div1 id="number">
         <head>Numbering</head>
         <e:element-syntax name="number">
            <e:in-category name="instruction"/>
            <e:attribute name="value">
               <e:data-type name="expression"/>
            </e:attribute>
            <e:attribute name="select">
               <e:data-type name="expression"/>
            </e:attribute>
            <e:attribute name="level">
               <e:constant value="single"/>
               <e:constant value="multiple"/>
               <e:constant value="any"/>
            </e:attribute>
            <e:attribute name="count">
               <e:data-type name="pattern"/>
            </e:attribute>
            <e:attribute name="from">
               <e:data-type name="pattern"/>
            </e:attribute>
            <e:attribute name="format">
               <e:attribute-value-template>
                  <e:data-type name="string"/>
               </e:attribute-value-template>
            </e:attribute>
            <e:attribute name="lang">
               <e:attribute-value-template>
                  <e:data-type name="nmtoken"/>
               </e:attribute-value-template>
            </e:attribute>
            <e:attribute name="letter-value">
               <e:attribute-value-template>
                  <e:constant value="alphabetic"/>
                  <e:constant value="traditional"/>
               </e:attribute-value-template>
            </e:attribute>
            <e:attribute name="ordinal">
               <e:attribute-value-template>
                  <e:data-type name="string"/>
               </e:attribute-value-template>
            </e:attribute>
            <e:attribute name="grouping-separator">
               <e:attribute-value-template>
                  <e:data-type name="char"/>
               </e:attribute-value-template>
            </e:attribute>
            <e:attribute name="grouping-size">
               <e:attribute-value-template>
                  <e:data-type name="number"/>
               </e:attribute-value-template>
            </e:attribute>
            <e:empty/>
            <e:allowed-parents>
               <e:parent-category name="sequence-constructor"/>
            </e:allowed-parents>
         </e:element-syntax>
         <p>The <elcode>xsl:number</elcode> instruction is used to create a formatted number. The
            result of the instruction is a newly constructed text node containing the formatted
            number as its <termref def="dt-string-value">string value</termref>.</p>
         <p>
            <termdef id="dt-place-marker" term="place marker">The <elcode>xsl:number</elcode>
               instruction performs two tasks: firstly, determining a <term>place marker</term>
               (this is a sequence of integers, to allow for hierarchic numbering schemes such as
                  <code>1.12.2</code> or <code>3(c)ii</code>), and secondly, formatting the place
               marker for output as a text node in the result sequence.</termdef> The place marker
            to be formatted can either be supplied directly, in the <code>value</code> attribute, or
            it can be computed based on the position of a selected node within the tree that
            contains it.</p>
         <p>
            <error spec="XT" type="static" class="SE" code="0975">
               <p>It is a <termref def="dt-static-error">static error</termref> if the
                     <code>value</code> attribute of <elcode>xsl:number</elcode> is present unless
                  the <code>select</code>, <code>level</code>, <code>count</code>, and
                     <code>from</code> attributes are all absent.</p>
            </error>
         </p>
         <note>
            <p>The facilities described in this section are specifically designed to enable the
               calculation and formatting of section numbers, paragraph numbers, and the like. For
               formatting of other numeric quantities, the <xfunction>format-number</xfunction>
               function may be more suitable: see <xspecref spec="FO11" ref="func-format-number"/>.</p>
            <p>Furthermore, formatting of integers where there is no requirement to calculate the
               position of a node in the document can now be accomplished using the
                  <xfunction>format-number</xfunction> function, which borrows many concepts from
               the <elcode>xsl:number</elcode> specification.</p>
         </note>
         <note diff="add" at="E">
            <p>See <specref ref="expanding-xsl-number"/> for analysis of the effect of the
                  <elcode>xsl:number</elcode> instruction on streamability.</p>
         </note>
         <div2 id="formatting-supplied-number">
            <head>Formatting a Supplied Number</head>
            <p>The <termref def="dt-place-marker">place marker</termref> to be formatted may be
               specified by an expression. The <code>value</code> attribute contains the <termref def="dt-expression">expression</termref>. The value of this expression is <termref def="dt-atomization">atomized</termref> using the procedure defined in <bibref ref="xpath-21"/>, and each value <var>$V</var> in the atomized sequence is then
               converted to the integer value returned by the XPath expression
                  <code>xs:integer(round(number($V)))</code>. The resulting sequence of integers is
               used as the place marker to be formatted.</p>
            <p diff="chg" at="D">If the instruction is processed with <termref def="dt-xslt-10-behavior">XSLT 1.0 behavior</termref>, then:</p>
            <ulist>
               <item>
                  <p>all items in the <termref def="dt-atomization">atomized</termref> sequence
                     after the first are discarded;</p>
               </item>
               <item>
                  <p>If the atomized sequence is empty, it is replaced by a sequence containing the
                        <code>xs:double</code> value <code>NaN</code> as its only item;</p>
               </item>
               <item>
                  <p>If any value in the sequence cannot be converted to an integer (this includes
                     the case where the sequence contains a <code>NaN</code> value) then the string
                        <code>NaN</code> is inserted into the formatted result string in its proper
                     position. The error described in the following paragraph does not apply in this
                     case.</p>
               </item>
            </ulist>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0980">
                  <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if any undiscarded item in the atomized sequence supplied as
                     the value of the <code>value</code> attribute of <elcode>xsl:number</elcode>
                     cannot be converted to an integer, or if the resulting integer is less than 0
                     (zero). </p>
               </error>
            </p>
            <note>
               <p>The value zero does not arise when numbering nodes in a source document, but it
                  can arise in other numbering sequences. It is permitted specifically because the
                  rules of the <elcode>xsl:number</elcode> instruction are also invoked by functions
                  such as <xfunction>format-time</xfunction>: the minutes and seconds component of a
                  time value can legitimately be zero.</p>
            </note>
            <p>The resulting sequence is formatted as a string using the <termref def="dt-effective-value">effective values</termref> of the attributes specified in
                  <specref ref="convert"/>; each of these attributes is interpreted as an <termref def="dt-attribute-value-template">attribute value template</termref>. After
               conversion, the <elcode>xsl:number</elcode> element constructs a new text node
               containing the resulting string, and returns this node.</p>
            <example>
               <head>Numbering a Sorted List</head>
               <p>The following example numbers a sorted list:</p>
               <eg xml:space="preserve">&lt;xsl:template match="items"&gt;
  &lt;xsl:for-each select="item"&gt;
    &lt;xsl:sort select="."/&gt;
    &lt;p&gt;
      &lt;xsl:number value="position()" format="1. "/&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/p&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;</eg>
            </example>
         </div2>
         <div2 id="numbering-based-on-position">
            <head>Numbering based on Position in a Document </head>
            <p>If no <code>value</code> attribute is specified, then the <elcode>xsl:number</elcode>
               instruction returns a new text node containing a formatted <termref def="dt-place-marker">place marker</termref> that is based on the position of a
               selected node within its containing document. If the <code>select</code> attribute is
               present, then the expression contained in the <code>select</code> attribute is
               evaluated to determine the selected node. If the <code>select</code> attribute is
               omitted, then the selected node is the <termref def="dt-context-node">context
                  node</termref>.</p>
            <p>
               <error spec="XT" type="type" class="TE" code="0990">
                  <p>It is a <termref def="dt-type-error">type error</termref> if the
                        <elcode>xsl:number</elcode> instruction is evaluated, with no
                        <code>value</code> or <code>select</code> attribute, when the <termref def="dt-context-item">context item</termref> is not a node. </p>
               </error>
            </p>
            <p>
               <error spec="XT" type="type" class="TE" code="1000">
                  <p>It is a <termref def="dt-type-error">type error</termref> if the result of
                     evaluating the <code>select</code> attribute of the <elcode>xsl:number</elcode>
                     instruction is anything other than a single node.</p>
               </error>
            </p>
            <p> The following attributes control how the selected node is to be numbered:</p>
            <ulist>
               <item>
                  <p>The <code>level</code> attribute specifies rules for selecting the nodes that
                     are taken into account in allocating a number; it has the values
                        <code>single</code>, <code>multiple</code> or <code>any</code>. The default
                     is <code>single</code>.</p>
               </item>
               <item>
                  <p>The <code>count</code> attribute is a <termref def="dt-pattern">pattern</termref> that specifies which nodes are to be counted at those
                     levels. If <code>count</code> attribute is not specified, then it defaults to
                     the pattern that matches any node with the same node kind as the selected node
                     and, if the selected node has an <termref def="dt-expanded-qname">expanded-QName</termref>, with the same <termref def="dt-expanded-qname">expanded-QName</termref> as the selected node.</p>
               </item>
               <item>
                  <p>The <code>from</code> attribute is a <termref def="dt-pattern">pattern</termref> that specifies where counting starts.</p>
               </item>
            </ulist>
            <p>In addition, the attributes specified in <specref ref="convert"/> are used for number
               to string conversion, as in the case when the <code>value</code> attribute is
               specified.</p>
            <p>The <elcode>xsl:number</elcode> element first constructs a sequence of positive
               integers using the <code>level</code>, <code>count</code> and <code>from</code>
               attributes. Where <code>level</code> is <code>single</code> or <code>any</code>, this
               sequence will either be empty or contain a single number; where <code>level</code> is
                  <code>multiple</code>, the sequence may be of any length. The sequence is
               constructed as follows:</p>
            <p>Let <code>matches-count($node)</code> be a function that returns true if and only if
               the given node <code>$node</code> matches the pattern given in the <code>count</code>
               attribute, or the implied pattern (according to the rules given above) if the
                  <code>count</code> attribute is omitted.</p>
            <p>Let <code>matches-from($node)</code> be a function that returns true if and only if
               the given node <code>$node</code> matches the pattern given in the <code>from</code>
               attribute, or if <code>$node</code> is the root node of a tree. If the
                  <code>from</code> attribute is omitted, then the function returns true if and only
               if <code>$node</code> is the root node of a tree.</p>
            <p>Let <code>$S</code> be the selected node.</p>
            <p>When <code>level="single"</code>: </p>
            <ulist>
               <item>
                  <p>Let <code>$A</code> be the node sequence selected by the following
                     expression:</p>
                  <p>
                     <code>$S/ancestor-or-self::node()[matches-count(.)][1]</code>
                  </p>
                  <p>(this selects the innermost ancestor-or-self node that matches the
                        <code>count</code> pattern)</p>
               </item>
               <item>
                  <p>Let <code>$F</code> be the node sequence selected by the expression</p>
                  <p>
                     <code>$S/ancestor-or-self::node()[matches-from(.)][1]</code>
                  </p>
                  <p>(this selects the innermost ancestor-or-self node that matches the
                        <code>from</code> pattern):</p>
               </item>
               <item>
                  <p>Let <code>$AF</code> be the value of:</p>
                  <p>
                     <code>$A[ancestor-or-self::node()[. is $F]]</code>
                  </p>
                  <p>(this selects $A if it is in the subtree rooted at $F, or the empty sequence
                     otherwise)</p>
               </item>
               <item>
                  <p>If <code>$AF</code> is empty, return the empty sequence, <code>()</code>
                  </p>
               </item>
               <item>
                  <p>Otherwise return the value of:</p>
                  <p>
                     <code>1 + count($AF/preceding-sibling::node()[matches-count(.)])</code>
                  </p>
                  <p>(the number of preceding siblings of the counted node that match the
                        <code>count</code> pattern, plus one).</p>
               </item>
            </ulist>
            <p>When <code>level="multiple"</code>: </p>
            <ulist>
               <item>
                  <p>Let <code>$A</code> be the node sequence selected by the expression</p>
                  <p>
                     <code>$S/ancestor-or-self::node()[matches-count(.)]</code>
                  </p>
                  <p>(the set of ancestor-or-self nodes that match the <code>count</code>
                     pattern)</p>
               </item>
               <item>
                  <p>Let <code>$F</code> be the node sequence selected by the expression</p>
                  <p>
                     <code>$S/ancestor-or-self::node()[matches-from(.)][1]</code>
                  </p>
                  <p>(the innermost ancestor-or-self node that matches the <code>from</code>
                     pattern)</p>
               </item>
               <item>
                  <p>Let <code>$AF</code> be the value of</p>
                  <p>
                     <code>$A[ancestor-or-self::node()[. is $F]]</code>
                  </p>
                  <p>(the nodes selected in the first step that are in the subtree rooted at the
                     node selected in the second step)</p>
               </item>
               <item>
                  <p>Return the result of the expression </p>
                  <p>
                     <code>for $af in $AF return
                        1+count($af/preceding-sibling::node()[matches-count(.)])</code>
                  </p>
                  <p>(a sequence of integers containing, for each of these nodes, one plus the
                     number of preceding siblings that match the <code>count</code> pattern)</p>
               </item>
            </ulist>
            <p>When <code>level="any"</code>: </p>
            <ulist>
               <item>
                  <p>Let <code>$A</code> be the node sequence selected by the expression</p>
                  <p>
                     <code>$S/(preceding::node()|ancestor-or-self::node())[matches-count(.)]</code>
                  </p>
                  <p>(the set of nodes consisting of the selected node together with all nodes,
                     other than attributes and namespaces, that precede the selected node in
                     document order, provided that they match the <code>count</code> pattern)</p>
               </item>
               <item>
                  <p>Let <code>$F</code> be the node sequence selected by the expression</p>
                  <p>
                     <code>$S/(preceding::node()|ancestor::node())[matches-from(.)][last()]</code>
                  </p>
                  <p>(the last node in document order that matches the <code>from</code> pattern and
                     that precedes the selected node, using the same definition)</p>
               </item>
               <item>
                  <p>Let <code>$AF</code> be the node sequence <code>$A[. is $F or . &gt;&gt;
                        $F]</code>.</p>
                  <p>(the nodes selected in the first step, excluding those that precede the node
                     selected in the second step)</p>
               </item>
               <item>
                  <p>If <code>$AF</code> is empty, return the empty sequence, <code>()</code>
                  </p>
               </item>
               <item>
                  <p>Otherwise return the value of the expression <code>count($AF)</code>
                  </p>
               </item>
            </ulist>
            <p>The sequence of numbers (the <termref def="dt-place-marker">place marker</termref>)
               is then converted into a string using the <termref def="dt-effective-value">effective
                  values</termref> of the attributes specified in <specref ref="convert"/>; each of
               these attributes is interpreted as an <termref def="dt-attribute-value-template">attribute value template</termref>. After conversion, the resulting string is
               used to create a text node, which forms the result of the <elcode>xsl:number</elcode>
               instruction.</p>
            <example>
               <head>Numbering the Items in an Ordered List</head>
               <p>The following will number the items in an ordered list:</p>
               <eg xml:space="preserve">&lt;xsl:template match="ol/item"&gt;
  &lt;fo:block&gt;
    &lt;xsl:number/&gt;
    &lt;xsl:text&gt;. &lt;/xsl:text&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <example>
               <head>Multi-Level Numbering</head>
               <p>The following two rules will number <code>title</code> elements. This is intended
                  for a document that contains a sequence of chapters followed by a sequence of
                  appendices, where both chapters and appendices contain sections, which in turn
                  contain subsections. Chapters are numbered 1, 2, 3; appendices are numbered A, B,
                  C; sections in chapters are numbered 1.1, 1.2, 1.3; sections in appendices are
                  numbered A.1, A.2, A.3. Subsections within a chapter are numbered 1.1.1, 1.1.2,
                  1.1.3; subsections within an appendix are numbered A.1.1, A.1.2, A.1.3.</p>
               <eg xml:space="preserve">&lt;xsl:template match="title"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="multiple"
                 count="chapter|section|subsection"
                 format="1.1 "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="appendix//title" priority="1"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="multiple"
                 count="appendix|section|subsection"
                 format="A.1 "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <example>
               <head>Numbering Notes within a Chapter</head>
               <p>This example numbers notes sequentially within a chapter:</p>
               <eg xml:space="preserve">&lt;xsl:template match="note"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="any" from="chapter" format="(1) "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</eg>
            </example>
         </div2>
         <div2 id="convert">
            <head>Number to String Conversion Attributes</head>
            <issue id="issue-refactor-format-integer" status="open">
               <p>The functionality described here has been encapsulated in a new function,
                     <xfunction>format-integer</xfunction>. The specification can be simplified by
                  referring to the specification of that function.</p>
            </issue>
            <p>The following attributes are used to control conversion of a sequence of numbers into
               a string. The numbers are integers greater than or equal to 0 (zero). The attributes
               are all optional.</p>
            <p>The main attribute is <code>format</code>. The default value for the
                  <code>format</code> attribute is <code>1</code>. The <code>format</code> attribute
               is split into a sequence of tokens where each token is a maximal sequence of
               alphanumeric characters or a maximal sequence of non-alphanumeric characters.
                  <emph>Alphanumeric</emph> means any character that has a Unicode category of Nd,
               Nl, No, Lu, Ll, Lt, Lm or Lo. The alphanumeric tokens (<emph>format tokens</emph>)
               indicate the format to be used for each number in the sequence; in most cases the
               format token is the same as the required representation of the number 1 (one).</p>
            <p>Each non-alphanumeric token is either a prefix, a separator, or a suffix. If there is
               a non-alphanumeric token but no format token, then the single non-alphanumeric token
               is used as both the prefix and the suffix. The prefix, if it exists, is the
               non-alphanumeric token that precedes the first format token: the prefix always
               appears exactly once in the constructed string, at the start. The suffix, if it
               exists, is the non-alphanumeric token that follows the last format token: the suffix
               always appears exactly once in the constructed string, at the end. All other
               non-alphanumeric tokens (those that occur between two format tokens) are
                  <emph>separator tokens</emph> and are used to separate numbers in the
               sequence.</p>
            <p>The <var>n</var>th format token is used to format the <var>n</var>th number in the
               sequence. If there are more numbers than format tokens, then the last format token is
               used to format remaining numbers. If there are no format tokens, then a format token
               of <code>1</code> is used to format all numbers. Each number after the first is
               separated from the preceding number by the separator token preceding the format token
               used to format that number, or, if that is the first format token, then by
                  <code>.</code> (dot).</p>
            <example>
               <head>Formatting a List of Numbers</head>
               <p>Given the sequence of numbers <code>5, 13, 7</code> and the format token
                     <code>A-001(i)</code>, the output will be the string <code>E-013(vii)</code>
               </p>
            </example>
            <p>Format tokens are interpreted as follows:</p>
            <ulist>
               <item>
                  <p>Any token where the last character has a decimal digit value of 1 (as specified
                     in the Unicode character property database), and the Unicode value of preceding
                     characters is one less than the Unicode value of the last character generates a
                     decimal representation of the number where each number is at least as long as
                     the format token. The digits used in the decimal representation are the set of
                     digits containing the digit character used in the format token. Thus, a format
                     token <code>1</code> generates the sequence <code>0 1 2 ... 10 11 12
                     ...</code>, and a format token <code>01</code> generates the sequence <code>00
                        01 02 ... 09 10 11 12 ... 99 100 101</code>. A format token of
                        <code>&amp;#x661;</code> (Arabic-Indic digit one) generates the sequence
                        <code></code> then <code></code> then <code></code>
                     ...</p>
               </item>
               <item>
                  <p>A format token <code>A</code> generates the sequence <code>A B C ... Z AA AB
                        AC...</code>.</p>
               </item>
               <item>
                  <p>A format token <code>a</code> generates the sequence <code>a b c ... z aa ab
                        ac...</code>.</p>
               </item>
               <item>
                  <p>A format token <code>i</code> generates the sequence <code>i ii iii iv v vi vii
                        viii ix x ...</code>.</p>
               </item>
               <item>
                  <p>A format token <code>I</code> generates the sequence <code>I II III IV V VI VII
                        VIII IX X ...</code>.</p>
               </item>
               <item>
                  <p>A format token <code>w</code> generates numbers written as lower-case words,
                     for example in English, <code>one two three four ...</code>
                  </p>
               </item>
               <item>
                  <p>A format token <code>W</code> generates numbers written as upper-case words,
                     for example in English, <code>ONE TWO THREE FOUR ...</code>
                  </p>
               </item>
               <item>
                  <p>A format token <code>Ww</code> generates numbers written as title-case words,
                     for example in English, <code>One Two Three Four ...</code>
                  </p>
               </item>
               <item>
                  <p>Any other format token indicates a numbering sequence in which that token
                     represents the number 1 (one) (but see the note below).
                     <!-- Where possible (given the constraint that format tokens
						must be alphanumeric, and that they must be distinct) the format token
						used to represent a numbering sequence should be the same as the representation
						of the number 1 (one) in that sequence.-->
                     It is <termref def="dt-implementation-defined">implementation-defined</termref>
                     which numbering sequences, additional to those listed above, are supported. If
                     an implementation does not support a numbering sequence represented by the
                     given token, it <rfc2119>must</rfc2119> use a format token of
                     <code>1</code>.</p>
                  <note>
                     <p>In some traditional numbering sequences additional signs are added to denote
                        that the letters should be interpreted as numbers; these are not included in
                        the format token. An example, see also the example below, is classical Greek
                        where a <emph>dexia keraia</emph> and sometimes an <emph>aristeri
                           keraia</emph> is added.</p>
                  </note>
               </item>
            </ulist>
            <imp-def-feature>The numbering sequences supported by the <elcode>xsl:number</elcode>
               instructions, beyond those defined in this specification, are
               implementation-defined.</imp-def-feature>
            <p>For all format tokens other than the first kind above (one that consists of decimal
               digits), there <rfc2119>may</rfc2119> be <termref def="dt-implementation-defined">implementation-defined</termref> lower and upper bounds on the range of numbers
               that can be formatted using this format token; indeed, for some numbering sequences
               there may be intrinsic limits. For example, the formatting token
                  <code>&amp;#x2460;</code> (circled digit one) has a range of 1 to 20 imposed by
               the Unicode character repertoire. For the numbering sequences described above any
               upper bound imposed by the implementation <rfc2119>must not</rfc2119> be less than
               1000 (one thousand) and any lower bound must not be greater than 1. Numbers that fall
               outside this range <rfc2119>must</rfc2119> be formatted using the format token
                  <code>1</code>. The numbering sequence associated with the format token
                  <code>1</code> has a lower bound of 0 (zero).</p>
            <imp-def-feature>There <rfc2119>may</rfc2119> be implementation-defined upper bounds on
               the numbers that can be formatted by <elcode>xsl:number</elcode> using any particular
               numbering sequence.</imp-def-feature>
            <p>The above expansions of numbering sequences for format tokens such as <code>a</code>
               and <code>i</code> are indicative but not prescriptive. There are various conventions
               in use for how alphabetic sequences continue when the alphabet is exhausted, and
               differing conventions for how roman numerals are written (for example,
                  <code>IV</code> versus <code>IIII</code> as the representation of the number 4).
               Sometimes alphabetic sequences are used that omit letters such as <code>i</code> and
                  <code>o</code>. This specification does not prescribe the detail of any sequence
               other than those sequences consisting entirely of decimal digits.</p>
            <p>Many numbering sequences are language-sensitive. This applies especially to the
               sequence selected by the tokens <code>w</code>, <code>W</code> and <code>Ww</code>.
               It also applies to other sequences, for example different languages using the
               Cyrillic alphabet use different sequences of characters, each starting with the
               letter #x410 (Cyrillic capital letter A). In such cases, the <code>lang</code>
               attribute specifies which language's conventions are to be used; it has the same
               range of values as <code>xml:lang</code> (see <bibref ref="REC-xml"/>). If no
                  <code>lang</code> value is specified, the language that is used is <termref def="dt-implementation-defined">implementation-defined</termref>. The set of
               languages for which numbering is supported is <termref def="dt-implementation-defined">implementation-defined</termref>. If a language is
               requested that is not supported, the processor uses the language that it would use if
               the <code>lang</code> attribute were omitted.</p>
            <imp-def-feature>The set of languages for which numbering is supported by
                  <elcode>xsl:number</elcode>, and the method of choosing a default language, are
               implementation-defined.</imp-def-feature>
            <p>If the optional <code>ordinal</code> attribute is present, and if its value is not a
               zero-length string, this indicates a request to output ordinal numbers rather than
               cardinal numbers. For example, in English, the value <code>ordinal="yes"</code> when
               used with the format token <code>1</code> outputs the sequence <code>1st 2nd 3rd 4th
                  ...</code>, and when used with the format token <code>w</code> outputs the
               sequence <code>first second third fourth ...</code>. In some languages, ordinal
               numbers vary depending on the grammatical context, for example they may have
               different genders and may decline with the noun that they qualify. In such cases the
               value of the <code>ordinal</code> attribute may be used to indicate the variation of
               the ordinal number required. The way in which the variation is indicated will depend
               on the conventions of the language. For inflected languages that vary the ending of
               the word, the preferred approach is to indicate the required ending, preceded by a
               hyphen: for example in German, appropriate values are <code>-e, -er, -es, -en</code>.
               It is <termref def="dt-implementation-defined">implementation-defined</termref> what
               combinations of values of the format token, the language, and the
                  <code>ordinal</code> attribute are supported. If ordinal numbering is not
               supported for the combination of the format token, the language, and the actual value
               of the <code>ordinal</code> attribute, the request is ignored and cardinal numbers
               are generated instead.</p>
            <imp-def-feature>With <elcode>xsl:number</elcode>, it is <termref def="dt-implementation-defined">implementation-defined</termref> what combinations
               of values of the format token, the language, and the <code>ordinal</code> attribute
               are supported. </imp-def-feature>
            <example>
               <head>Ordinal Numbering in Italian</head>
               <p>The specification <code>format="1" ordinal="-" lang="it"</code>, if supported,
                  should produce the sequence:</p>
               <eg xml:space="preserve">1 2 3 4 ...</eg>
               <p>The specification <code>format="Ww" ordinal="-o" lang="it"</code>, if supported,
                  should produce the sequence:</p>
               <eg xml:space="preserve">Primo Secondo Terzo Quarto Quinto ...</eg>
            </example>
            <p>The <code>letter-value</code> attribute disambiguates between numbering sequences
               that use letters. In many languages there are two commonly used numbering sequences
               that use letters. One numbering sequence assigns numeric values to letters in
               alphabetic sequence, and the other assigns numeric values to each letter in some
               other manner traditional in that language. In English, these would correspond to the
               numbering sequences specified by the format tokens <code>a</code> and <code>i</code>.
               In some languages, the first member of each sequence is the same, and so the format
               token alone would be ambiguous. A value of <code>alphabetic</code> specifies the
               alphabetic sequence; a value of <code>traditional</code> specifies the other
               sequence. If the <code>letter-value</code> attribute is not specified, then it is
                  <termref def="dt-implementation-dependent">implementation-dependent</termref> how
               any ambiguity is resolved.</p>
            <note>
               <p>Implementations may use <termref def="dt-extension-attribute">extension
                     attributes</termref> on <elcode>xsl:number</elcode> to provide additional
                  control over the way in which numbers are formatted.</p>
            </note>
            <p>The <code>grouping-separator</code> attribute gives the separator used as a grouping
               (for example, thousands) separator in decimal numbering sequences, and the optional
                  <code>grouping-size</code> specifies the size (normally 3) of the grouping. For
               example, <code>grouping-separator=","</code> and <code>grouping-size="3"</code> would
               produce numbers of the form <code>1,000,000</code> while
                  <code>grouping-separator="."</code> and <code>grouping-size="2"</code> would
               produce numbers of the form <code>1.00.00.00</code>. If only one of the
                  <code>grouping-separator</code> and <code>grouping-size</code> attributes is
               specified, then it is ignored.</p>
            <example>
               <head>Format Tokens and the Resulting Sequences</head>
               <p>These examples use non-Latin characters which might not display correctly in all
                  browsers, depending on the system configuration.</p>
               <table border="1" cellpadding="5">
                  <thead>
                     <tr>
                        <th align="left" rowspan="1" colspan="1">Description</th>
                        <th align="left" rowspan="1" colspan="1">Format Token</th>
                        <th align="left" rowspan="1" colspan="1">Sequence</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td rowspan="1" colspan="1">French cardinal words</td>
                        <td rowspan="1" colspan="1">
                           <code>format="Ww" lang="fr"</code>
                        </td>
                        <td rowspan="1" colspan="1">Un, Deux, Trois, Quatre</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">German ordinal words</td>
                        <td rowspan="1" colspan="1">
                           <code>format="w" ordinal="-e" lang="de"</code>
                        </td>
                        <td rowspan="1" colspan="1">erste, zweite, dritte, vierte</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">Katakana numbering</td>
                        <td rowspan="1" colspan="1">
                           <code>format="&amp;#x30A2;"</code>
                        </td>
                        <td rowspan="1" colspan="1">, , , ,
                           , , , , , , ,
                           , , , , , , ,
                           , , , , , , ,
                           , , , , , , ,
                           , , , , , , ,
                           , , , , , , ,
                           , </td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">Katakana numbering in iroha order</td>
                        <td rowspan="1" colspan="1">
                           <code>format="&amp;#x30A4;"</code>
                        </td>
                        <td rowspan="1" colspan="1">, , , ,
                           , , , , , , ,
                           , , , , , , ,
                           , , , , , , ,
                           , , , , , , ,
                           , , , , , , ,
                           , , , , , , ,
                           </td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">Thai numbering</td>
                        <td rowspan="1" colspan="1">
                           <code>format="&amp;#x0E51;"</code>
                        </td>
                        <td rowspan="1" colspan="1">, , , , ,
                           , , , , , ,
                           , , , ,
                           , , , ,
                           </td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">Traditional Hebrew numbering</td>
                        <td rowspan="1" colspan="1">
                           <code>format="&amp;#x05D0;" letter-value="traditional"</code>
                        </td>
                        <td rowspan="1" colspan="1">, , , , ,
                           , , , , , ,
                           , , , ,
                           , , , ,
                           </td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">Traditional Georgian numbering</td>
                        <td rowspan="1" colspan="1">
                           <code>format="&amp;#x10D0;" letter-value="traditional"</code>
                        </td>
                        <td rowspan="1" colspan="1">, , , ,
                           , , , , , ,
                           , , , ,
                           , , , ,
                           ,  </td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">Classical Greek numbering (see note)</td>
                        <td rowspan="1" colspan="1">
                           <code>format="&amp;#x03B1;" letter-value="traditional"</code>
                        </td>
                        <td rowspan="1" colspan="1"> , , ,
                           , , , ,
                           , , , ,
                           , , ,
                           , , ,
                           , , </td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">Old Slavic numbering</td>
                        <td rowspan="1" colspan="1">
                           <code>format="&amp;#x0430;" letter-value="traditional"</code>
                        </td>
                        <td rowspan="1" colspan="1">, , , , ,
                           , , , , , ,
                           , , , ,
                           , , , ,
                           </td>
                     </tr>
                  </tbody>
               </table>
               <p>Note that Classical Greek is an example where the format token is not the same as
                  the representation of the number 1.</p>
            </example>
         </div2>
      </div1>
      <div1 id="sorting">
         <head>Sorting</head>
         <p>
            <termdef id="dt-sort-key-specification" term="sort key specification">A <term>sort key
                  specification</term> is a sequence of one or more adjacent
                  <elcode>xsl:sort</elcode> elements which together define rules for sorting the
               items in an input sequence to form a sorted sequence.</termdef>
         </p>
         <p>
            <termdef id="dt-sort-key-component" term="sort key component">Within a <termref def="dt-sort-key-specification">sort key specification</termref>, each
                  <elcode>xsl:sort</elcode> element defines one <term>sort key
               component</term>.</termdef> The first <elcode>xsl:sort</elcode> element specifies the
            primary component of the sort key specification, the second <elcode>xsl:sort</elcode>
            element specifies the secondary component of the sort key specification, and so on.</p>
         <p>A sort key specification may occur immediately within an
               <elcode>xsl:apply-templates</elcode>, <elcode>xsl:for-each</elcode>,
               <elcode>xsl:perform-sort</elcode>, or <elcode>xsl:for-each-group</elcode>
            element.</p>
         <note>
            <p>When used within <elcode>xsl:for-each</elcode>, <elcode>xsl:for-each-group</elcode>,
               or <elcode>xsl:perform-sort</elcode>, <elcode>xsl:sort</elcode> elements must occur
               before any other children.</p>
         </note>
         <div2 id="xsl-sort">
            <head>The <elcode>xsl:sort</elcode> Element</head>
            <e:element-syntax name="sort">
               <e:attribute name="select">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="lang">
                  <e:attribute-value-template>
                     <e:data-type name="nmtoken"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="order">
                  <e:attribute-value-template>
                     <e:constant value="ascending"/>
                     <e:constant value="descending"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="collation">
                  <e:attribute-value-template>
                     <e:data-type name="uri"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="stable">
                  <e:attribute-value-template>
                     <e:constant value="yes"/>
                     <e:constant value="no"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="case-order">
                  <e:attribute-value-template>
                     <e:constant value="upper-first"/>
                     <e:constant value="lower-first"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="data-type">
                  <e:attribute-value-template>
                     <e:constant value="text"/>
                     <e:constant value="number"/>
                     <e:data-type name="qname-but-not-ncname"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent name="apply-templates"/>
                  <e:parent name="for-each"/>
                  <e:parent name="for-each-group"/>
                  <e:parent name="perform-sort"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:sort</elcode> element defines a <termref def="dt-sort-key-component">sort key component</termref>. A sort key component specifies how a <termref def="dt-sort-key-value">sort key value</termref> is to be computed for each item
               in the sequence being sorted, and also how two sort key values are to be
               compared.</p>
            <p>The value of a <termref def="dt-sort-key-component">sort key component</termref> is
               determined either by its <code>select</code> attribute or by the contained <termref def="dt-sequence-constructor">sequence constructor</termref>. If neither is
               present, the default is <code>select="."</code>, which has the effect of sorting on
               the actual value of the item if it is an atomic value, or on the typed-value of the
               item if it is a node. If a <code>select</code> attribute is present, its value
                  <rfc2119>must</rfc2119> be an XPath <termref def="dt-expression">expression</termref>.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="1015">
                  <p>It is a <termref def="dt-static-error">static error</termref> if an
                        <elcode>xsl:sort</elcode> element with a <code>select</code> attribute has
                     non-empty content.</p>
               </error>
            </p>
            <p>Those attributes of the <elcode>xsl:sort</elcode> elements whose values are <termref def="dt-attribute-value-template">attribute value templates</termref> are
               evaluated using the same <termref def="dt-focus">focus</termref> as is used to
               evaluate the <code>select</code> attribute of the containing instruction
               (specifically, <elcode>xsl:apply-templates</elcode>, <elcode>xsl:for-each</elcode>,
                  <elcode>xsl:for-each-group</elcode>, or <elcode>xsl:perform-sort</elcode>).</p>
            <p>The <code>stable</code> attribute is permitted only on the first
                  <elcode>xsl:sort</elcode> element within a <termref def="dt-sort-key-specification">sort key specification</termref>
            </p>
            <p>
               <error spec="XT" type="static" class="SE" code="1017">
                  <p>It is a <termref def="dt-static-error">static error</termref> if an
                        <elcode>xsl:sort</elcode> element other than the first in a sequence of
                     sibling <elcode>xsl:sort</elcode> elements has a <code>stable</code>
                     attribute.</p>
               </error>
            </p>
            <p>
               <termdef id="dt-stable" term="stable">A <termref def="dt-sort-key-specification">sort
                     key specification</termref> is said to be <term>stable</term> if its first
                     <elcode>xsl:sort</elcode> element has no <code>stable</code> attribute, or has
                  a <code>stable</code> attribute whose <termref def="dt-effective-value">effective
                     value</termref> is <code>yes</code>.</termdef>
            </p>
            <div3 id="sorting-process">
               <head>The Sorting Process</head>
               <p>
                  <termdef id="dt-initial-sequence" term="initial sequence">The sequence to be
                     sorted is referred to as the <term>initial sequence</term>.</termdef>
               </p>
               <p>
                  <termdef id="dt-sorted-sequence" term="sorted sequence">The sequence after sorting
                     as defined by the <elcode>xsl:sort</elcode> elements is referred to as the
                        <term>sorted sequence</term>.</termdef>
               </p>
               <p>
                  <termdef id="dt-sort-key-value" term="sort key value"> For each item in the
                        <termref def="dt-initial-sequence">initial sequence</termref>, a value is
                     computed for each <termref def="dt-sort-key-component">sort key
                        component</termref> within the <termref def="dt-sort-key-specification">sort
                        key specification</termref>. The value computed for an item by using the
                        <var>N</var>th sort key component is referred to as the <var>N</var>th
                        <term>sort key value</term> of that item.</termdef>
               </p>
               <p>The items in the <termref def="dt-initial-sequence">initial sequence</termref> are
                  ordered into a <termref def="dt-sorted-sequence">sorted sequence</termref> by
                  comparing their <termref def="dt-sort-key-value">sort key values</termref>. The
                  relative position of two items <var>A</var> and <var>B</var> in the sorted
                  sequence is determined as follows. The first sort key value of <var>A</var> is
                  compared with the first sort key value of <var>B</var>, according to the rules of
                  the first <termref def="dt-sort-key-component">sort key component</termref>. If,
                  under these rules, <var>A</var> is less than <var>B</var>, then <var>A</var> will
                  precede <var>B</var> in the sorted sequence, unless the <code>order</code>
                  attribute of this <termref def="dt-sort-key-component">sort key
                     component</termref> specifies <code>descending</code>, in which case
                     <var>B</var> will precede <var>A</var> in the sorted sequence. If, however, the
                  relevant sort key values compare equal, then the second sort key value of
                     <var>A</var> is compared with the second sort key value of <var>B</var>,
                  according to the rules of the second <termref def="dt-sort-key-component">sort key
                     component</termref>. This continues until two sort key values are found that
                  compare unequal. If all the sort key values compare equal, and the <termref def="dt-sort-key-specification">sort key specification</termref> is <termref def="dt-stable">stable</termref>, then <var>A</var> will precede <var>B</var>
                  in the <termref def="dt-sorted-sequence">sorted sequence</termref> if and only if
                     <var>A</var> preceded <var>B</var> in the <termref def="dt-initial-sequence">initial sequence</termref>. If all the sort key values compare equal, and the
                     <termref def="dt-sort-key-specification">sort key specification</termref> is
                  not <termref def="dt-stable">stable</termref>, then the relative order of
                     <var>A</var> and <var>B</var> in the <termref def="dt-sorted-sequence">sorted
                     sequence</termref> is <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p>
               <note>
                  <p>If two items have equal <termref def="dt-sort-key-value">sort key
                        values</termref>, and the sort is <termref def="dt-stable">stable</termref>,
                     then their order in the <termref def="dt-sorted-sequence">sorted
                        sequence</termref> will be the same as their order in the <termref def="dt-initial-sequence">initial sequence</termref>, regardless of whether
                        <code>order="descending"</code> was specified on any or all of the <termref def="dt-sort-key-component">sort key components</termref>.</p>
               </note>
               <p>The <var>N</var>th sort key value is computed by evaluating either the
                     <code>select</code> attribute or the contained <termref def="dt-sequence-constructor">sequence constructor</termref> of the
                     <var>N</var>th <elcode>xsl:sort</elcode> element, or the expression
                     <code>.</code> (dot) if neither is present. This evaluation is done with the
                     <termref def="dt-focus">focus</termref> set as follows:</p>
               <ulist>
                  <item>
                     <p>The <termref def="dt-context-item">context item</termref> is the item in the
                           <termref def="dt-initial-sequence">initial sequence</termref> whose
                           <termref def="dt-sort-key-value">sort key value</termref> is being
                        computed.</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-context-position">context position</termref> is the
                        position of that item in the initial sequence.</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-context-size">context size</termref> is the size of the
                        initial sequence.</p>
                  </item>
               </ulist>
               <note>
                  <p>As in any other XPath expression, the <function>current</function> function may
                     be used within the <code>select</code> expression of <elcode>xsl:sort</elcode>
                     to refer to the item that is the context item for the expression as a whole;
                     that is, the item whose <termref def="dt-sort-key-value">sort key
                        value</termref> is being computed.</p>
               </note>
               <p>The <termref def="dt-sort-key-value">sort key values</termref> are <termref def="dt-atomization">atomized</termref>, and are then compared. The way they
                  are compared depends on their data type, as described in the next section.</p>
            </div3>
            <div3 id="comparing-sort-keys">
               <head>Comparing Sort Key Values</head>
               <p>It is possible to force the system to compare <termref def="dt-sort-key-value">sort key values</termref> using the rules for a particular data type by
                  including a cast as part of the <termref def="dt-sort-key-component">sort key
                     component</termref>. For example, <code>&lt;xsl:sort
                     select="xs:date(@dob)"/&gt;</code> will force the attributes to be compared as
                  dates. In the absence of such a cast, the sort key values are compared using the
                  rules appropriate to their data type. Any values of type
                     <code>xs:untypedAtomic</code> are cast to <code>xs:string</code>.</p>
               <p>For backwards compatibility with XSLT 1.0, the <code>data-type</code> attribute
                  remains available. If this has the <termref def="dt-effective-value">effective
                     value</termref>
                  <code>text</code>, the atomized <termref def="dt-sort-key-value">sort key
                     values</termref> are converted to strings before being compared. If it has the
                  effective value <code>number</code>, the atomized sort key values are converted to
                  doubles before being compared. The conversion is done by using the
                     <xfunction>string</xfunction> or <xfunction>number</xfunction> function as
                  appropriate. If the <code>data-type</code> attribute has any other <termref def="dt-effective-value">effective value</termref>, then the value
                     <rfc2119>must</rfc2119> be a <termref def="dt-lexical-qname">lexical
                     QName</termref> with a non-empty prefix, and the effect of the attribute is
                     <termref def="dt-implementation-defined">implementation-defined</termref>.</p>
               <imp-def-feature>If the <code>data-type</code> attribute of the
                     <elcode>xsl:sort</elcode> element has a value other than <code>text</code> or
                     <code>number</code>, the effect is implementation-defined.</imp-def-feature>
               <p>
                  <error spec="XT" type="type" class="TE" code="1020">
                     <p>If any <termref def="dt-sort-key-value">sort key value</termref>, after
                           <termref def="dt-atomization">atomization</termref> and any type
                        conversion <rfc2119>required</rfc2119> by the <code>data-type</code>
                        attribute, is a sequence containing more than one item, then the effect
                        depends on whether the <elcode>xsl:sort</elcode> element <phrase diff="chg" at="D">is processed with <termref def="dt-xslt-10-behavior">XSLT 1.0
                              behavior</termref>. With XSLT 1.0 behavior,</phrase> the effective
                        sort key value is the first item in the sequence. In other cases, this is a
                           <termref def="dt-type-error">type error</termref>.</p>
                  </error>
               </p>
               <p>The set of <termref def="dt-sort-key-value">sort key values</termref> (after any
                  conversion) is first divided into two categories: empty values, and ordinary
                  values. The empty sort key values represent those items where the sort key value
                  is an empty sequence. These values are considered for sorting purposes to be equal
                  to each other, but less than any other value. The remaining values are classified
                  as ordinary values.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1030">
                     <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                           error</termref> if, for any <termref def="dt-sort-key-component">sort key
                           component</termref>, the set of <termref def="dt-sort-key-value">sort key
                           values</termref> evaluated for all the items in the <termref def="dt-initial-sequence">initial sequence</termref>, after any type
                        conversion requested, contains a pair of ordinary values for which the
                        result of the XPath <code>lt</code> operator is an error.</p>
                  </error>
               </p>
               <note>
                  <p>The above error condition may occur if the values to be sorted are of a type
                     that does not support ordering (for example, <code>xs:QName</code>) or if the
                     sequence is heterogeneous (for example, if it contains both strings and
                     numbers). The error can generally be prevented by invoking a cast or
                     constructor function within the sort key component.</p>
                  <p>The error condition is subject to the usual caveat that a processor is not
                     required to evaluate any expression solely in order to determine whether it
                     raises an error. For example, if there are several sort key components, then a
                     processor is not required to evaluate or compare minor sort key values unless
                     the corresponding major sort key values are equal.</p>
               </note>
               <!--Text replaced by erratum E13 change 1"-->
               <p>In general, comparison of two ordinary values is performed according to the rules
                  of the XPath <code>lt</code> operator. To ensure a total ordering, the same
                  implementation of the <code>lt</code> operator <rfc2119>must</rfc2119> be used for
                  all the comparisons: the one that is chosen is the one appropriate to the most
                  specific type to which all the values can be converted by subtype substitution
                  and/or type promotion. For example, if the sequence contains both
                     <code>xs:decimal</code> and <code>xs:double</code> values, then the values are
                  compared using <code>xs:double</code> comparison, even when comparing two
                     <code>xs:decimal</code> values. NaN values, for sorting purposes, are
                  considered to be equal to each other, and less than any other numeric value.
                  Special rules also apply to the <code>xs:string</code> and <code>xs:anyURI</code>
                  types, and types derived by restriction therefrom, as described in the next
                  section.</p>
               <!--End of text replaced by erratum E13-->
            </div3>
            <div3 id="collating-sequences">
               <head>Sorting Using Collations</head>
               <p>The rules given in this section apply when comparing values whose type is
                     <code>xs:string</code> or a type derived by restriction from
                     <code>xs:string</code>, or whose type is <code>xs:anyURI</code> or a type
                  derived by restriction from <code>xs:anyURI</code>.</p>
               <p>
                  <termdef id="dt-collation" term="collation">Facilities in XSLT <phrase diff="chg" at="A">2.1</phrase> and XPath <phrase diff="chg" at="C">2.1</phrase> that
                     require strings to be ordered rely on the concept of a named
                        <term>collation</term>. A collation is a set of rules that determine whether
                     two strings are equal, and if not, which of them is to be sorted before the
                     other.</termdef> A collation is identified by a URI, but the manner in which
                  this URI is associated with an actual rule or algorithm is <termref def="dt-implementation-defined">implementation-defined</termref>.</p>
               <imp-def-feature>The facilities for defining collations and allocating URIs to
                  identify them are implementation-defined.</imp-def-feature>
               <p>The one collation URI that <rfc2119>must</rfc2119> be recognized by every implementation is
                     <code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>, which
                  provides the ability to compare strings based on the Unicode codepoint values of
                  the characters in the string.</p>
               <p>For more information about collations, see <xspecref spec="FO" ref="string-compare"/> in <bibref ref="xpath-functions-11"/>. Some specifications,
                  for example <bibref ref="UNICODE-TR10"/>, use the term "collation" to describe
                  rules that can be tailored or parameterized for various purposes. In this
                  specification, a collation URI refers to a collation in which all such parameters
                  have already been fixed. Therefore, if a collation URI is specified, other
                  attributes such as <code>case-order</code> and <code>lang</code> are ignored. </p>
               <note>
                  <p>The reason XSLT does not provide detailed mechanisms for defining collating
                     sequences is that many implementations will re-use collating mechanisms
                     available from the underlying implementation platform (for example, from the
                     operating system or from the run-time library of a chosen programming
                     language). These will inevitably differ from one XSLT implementation to
                     another.</p>
               </note>
               <p>If the <elcode>xsl:sort</elcode> element has a <code>collation</code> attribute,
                  then the strings are compared according to the rules for the named <termref def="dt-collation">collation</termref>: that is, they are compared using the
                  XPath function call <code>compare($a, $b, $collation)</code>.</p>
               <p>If the <termref def="dt-effective-value">effective value</termref> of the
                     <code>collation</code> attribute of <elcode>xsl:sort</elcode> is a relative
                  URI, then it is resolved against the base URI of the <elcode>xsl:sort</elcode>
                  element.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1035">
                     <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                           error</termref> if the <code>collation</code> attribute of
                           <elcode>xsl:sort</elcode> (after resolving against the base URI) is not a
                        URI that is recognized by the implementation as referring to a
                        collation.</p>
                  </error>
               </p>
               <note>
                  <p>It is entirely for the implementation to determine whether it recognizes a
                     particular collation URI. For example, if the implementation allows collation
                     URIs to contain parameters in the query part of the URI, it is the
                     implementation that determines whether a URI containing an unknown or invalid
                     parameter is or is not a recognized collation URI. The fact that this error is
                     described as non-recoverable thus does not prevent an implementation applying a
                     fallback collation if it chooses to do so.</p>
               </note>
               <p>The <code>lang</code> and <code>case-order</code> attributes are ignored if a
                     <code>collation</code> attribute is present. But in the absence of a
                     <code>collation</code> attribute, these attributes provide input to an <termref def="dt-implementation-defined">implementation-defined</termref> algorithm to
                  locate a suitable collation:</p>
               <imp-def-feature>The algorithm used by <elcode>xsl:sort</elcode> to locate a
                  collation, given the values of the <code>lang</code> and <code>case-order</code>
                  attributes, is implementation-defined.</imp-def-feature>
               <ulist>
                  <item>
                     <p>The <code>lang</code> attribute indicates that a collation suitable for a
                        particular natural language <rfc2119>should</rfc2119> be used. The <termref def="dt-effective-value">effective value</termref> of the attribute
                           <rfc2119>must</rfc2119> be a value that would be valid for the
                           <code>xml:lang</code> attribute (see <bibref ref="REC-xml"/>).</p>
                  </item>
                  <item>
                     <p>The <code>case-order</code> attribute indicates whether the desired
                        collation <rfc2119>should</rfc2119> sort upper-case letters before
                        lower-case or vice versa. The <termref def="dt-effective-value">effective
                           value</termref> of the attribute <rfc2119>must</rfc2119> be either
                           <code>lower-first</code> (indicating that lower-case letters precede
                        upper-case letters in the collating sequence) or <code>upper-first</code>
                        (indicating that upper-case letters precede lower-case).</p>
                     <!--Text inserted by erratum E26 change 1"-->
                     <p>When <code>lower-first</code> is requested, the returned collation
                           <rfc2119>should</rfc2119> have the property that when two strings differ
                        only in the case of one or more characters, then a string in which the first
                        differing character is lower-case should precede a string in which the
                        corresponding character is title-case, which should in turn precede a string
                        in which the corresponding character is upper-case. When upper-first is
                        requested, the returned collation <rfc2119>should</rfc2119> have the
                        property that when two strings differ only in the case of one or more
                        characters, then a string in which the first differing character is
                        upper-case should precede a string in which the corresponding character is
                        title-case, which should in turn precede a string in which the corresponding
                        character is lower-case.</p>
                     <p>So, for example, if <code>lang="en"</code>, then <code>A a B b</code> are
                        sorted with <code>case-order="upper-first"</code> and <code>a A b B</code>
                        are sorted with <code>case-order="lower-first"</code>.</p>
                     <p>As a further example, if lower-first is requested, then a sorted sequence
                        might be "MacAndrew, macintosh, macIntosh, Macintosh, MacIntosh,
                        macintoshes, Macintoshes, McIntosh". If upper-first is requested, the same
                        sequence would sort as "MacAndrew, MacIntosh, Macintosh, macIntosh,
                        macintosh, MacIntoshes, macintoshes, McIntosh".</p>
                     <!--End of text inserted by erratum E26-->
                  </item>
               </ulist>
               <p>If none of the <code>collation</code>, <code>lang</code>, or
                     <code>case-order</code> attributes is present, the collation is chosen in an
                     <termref def="dt-implementation-defined">implementation-defined</termref> way.
                  It is not <rfc2119>required</rfc2119> that the default collation for sorting
                  should be the same as the <termref def="dt-default-collation">default
                     collation</termref> used when evaluating XPath expressions, as described in
                     <specref ref="static-context"/> and <specref ref="default-collation-attribute"/>.</p>
               <note>
                  <p>It is usually appropriate, when sorting, to use a strong collation, that is,
                     one that takes account of secondary differences (accents) and tertiary
                     differences (case) between strings that are otherwise equal. A weak collation,
                     which ignores such differences, may be more suitable when comparing strings for
                     equality.</p>
                  <p>Useful background information on international sorting is provided in <bibref ref="UNICODE-TR10"/>. The <code>case-order</code> attribute may be
                     interpreted as described in section 6.6 of <bibref ref="UNICODE-TR10"/>.</p>
               </note>
            </div3>
         </div2>
         <div2 id="creating-sorted-sequence">
            <head>Creating a Sorted Sequence</head>
            <e:element-syntax name="perform-sort">
               <e:in-category name="instruction"/>
               <e:attribute name="select" required="no">
                  <e:data-type name="expression"/>
               </e:attribute>
               <!--<e:attribute name="as">
        					<e:data-type name="sequence-type"/>
        				</e:attribute>-->
               <e:sequence>
                  <e:element repeat="one-or-more" name="sort"/>
                  <e:model name="sequence-constructor"/>
               </e:sequence>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:perform-sort</elcode> instruction is used to return a <termref def="dt-sorted-sequence">sorted sequence</termref>.</p>
            <p>The <termref def="dt-initial-sequence">initial sequence</termref> is obtained either
               by evaluating the <code>select</code> attribute or by evaluating the contained
               sequence constructor (but not both). If there is no <code>select</code> attribute and
               no sequence constructor then the <termref def="dt-initial-sequence">initial
                  sequence</termref> (and therefore, the <termref def="dt-sorted-sequence">sorted
                  sequence</termref>) is an empty sequence.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="1040">
                  <p>It is a <termref def="dt-static-error">static error</termref> if an
                        <elcode>xsl:perform-sort</elcode> instruction with a <code>select</code>
                     attribute has any content other than <elcode>xsl:sort</elcode> and
                        <elcode>xsl:fallback</elcode> instructions.</p>
               </error>
            </p>
            <p>The result of the <elcode>xsl:perform-sort</elcode> instruction is the result of
               sorting its <termref def="dt-initial-sequence">initial sequence</termref> using its
               contained <termref def="dt-sort-key-specification">sort key
               specification</termref>.</p>
            <example>
               <head>Sorting a Sequence of Atomic Values</head>
               <p>The following stylesheet function sorts a sequence of atomic values using the
                  value itself as the sort key.</p>
               <eg xml:space="preserve">&lt;xsl:function name="local:sort" 
          as="xs:anyAtomicType*"&gt;
  &lt;xsl:param name="in" as="xs:anyAtomicType*"/&gt;
  &lt;xsl:perform-sort select="$in"&gt;
    &lt;xsl:sort select="."/&gt;
  &lt;/xsl:perform-sort&gt;
&lt;/xsl:function&gt;</eg>
            </example>
            <example>
               <head>Writing a Function to Perform a Sort</head>
               <p>The following example defines a function that sorts books by price, and uses this
                  function to output the five books that have the lowest prices:</p>
               <eg xml:space="preserve">&lt;xsl:function name="bib:books-by-price" 
          as="schema-element(bib:book)*"&gt;
  &lt;xsl:param name="in" as="schema-element(bib:book)*"/&gt;
  &lt;xsl:perform-sort select="$in"&gt;
    &lt;xsl:sort select="xs:decimal(bib:price)"/&gt;
  &lt;/xsl:perform-sort&gt;
&lt;/xsl:function&gt;
   ...
   &lt;xsl:copy-of select="bib:books-by-price(//bib:book)
                             [position() = 1 to 5]"/&gt;

 </eg>
            </example>
         </div2>
         <div2 id="sorted-iteration">
            <head>Processing a Sequence in Sorted Order</head>
            <p>When used within <elcode>xsl:for-each</elcode> or
                  <elcode>xsl:apply-templates</elcode>, a <termref def="dt-sort-key-specification">sort key specification</termref> indicates that the sequence of items selected by
               that instruction is to be processed in sorted order, not in the order of the supplied
               sequence.</p>
            <example>
               <head>Processing Elements in Sorted Order</head>
               <p>For example, suppose an employee database has the form</p>
               <eg xml:space="preserve">&lt;employees&gt;
  &lt;employee&gt;
    &lt;name&gt;
      &lt;given&gt;James&lt;/given&gt;
      &lt;family&gt;Clark&lt;/family&gt;
    &lt;/name&gt;
    ...
  &lt;/employee&gt;
&lt;/employees&gt;
</eg>
               <p>Then a list of employees sorted by name could be generated using:</p>
               <eg xml:space="preserve">&lt;xsl:template match="employees"&gt;
  &lt;ul&gt;
    &lt;xsl:apply-templates select="employee"&gt;
      &lt;xsl:sort select="name/family"/&gt;
      &lt;xsl:sort select="name/given"/&gt;
    &lt;/xsl:apply-templates&gt;
  &lt;/ul&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="employee"&gt;
  &lt;li&gt;
    &lt;xsl:value-of select="name/given"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:value-of select="name/family"/&gt;
  &lt;/li&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <p>When used within <elcode>xsl:for-each-group</elcode>, a <termref def="dt-sort-key-specification">sort key specification</termref> indicates the
               order in which the groups are to be processed. For the effect of
                  <elcode>xsl:for-each-group</elcode>, see <specref ref="grouping"/>. </p>
         </div2>
      </div1>
      <div1 id="grouping">
         <head>Grouping</head>
         <p>The facilities described in this section are designed to allow items in a sequence to be
            grouped based on common values; for example it allows grouping of elements having the
            same value for a particular attribute, or elements with the same name, or elements with
            common values for any other <termref def="dt-expression">expression</termref>. Since
            grouping identifies items with duplicate values, the same facilities also allow
            selection of the distinct values in a sequence of items, that is, the elimination of
            duplicates.</p>
         <note>
            <p>Simple elimination of duplicates can also be achieved using the function
                  <xfunction>distinct-values</xfunction> in the <termref def="dt-core-function">core
                  function</termref> library: see <bibref ref="xpath-functions-11"/>.</p>
         </note>
         <p>In addition these facilities allow grouping based on sequential position, for example
            selecting groups of adjacent <code>para</code> elements. The facilities also provide an
            easy way to do fixed-size grouping, for example identifying groups of three adjacent
            nodes, which is useful when arranging data in multiple columns.</p>
         <p>For each group of items identified, it is possible to evaluate a <termref def="dt-sequence-constructor">sequence constructor</termref> for the group. Grouping
            is nestable to multiple levels so that groups of distinct items can be identified, then
            from among the distinct groups selected, further sub-grouping of distinct items in the
            current group can be done. </p>
         <p>It is also possible for one item to participate in more than one group.</p>
         <div2 id="current-group">
            <head>The Current Group</head>
            <proto class="xslt" name="current-group" return-type="item()" returnSeq="yes"/>
            <!--<proto class="xslt" name="current-group" return-type="item()" returnSeq="yes">
               <arg name="source-name" type="xs:string"/>
            </proto>-->
            <p>
               <termdef id="dt-current-group" term="current group">The evaluation context for XPath
                     <termref def="dt-expression">expressions</termref> includes a component called
                  the <term>current group</term>, which is a sequence.
                  <!--<phrase diff="add" at="C">Furthermore, items within the current group
may be labeled with a source name, to allow selection of a subset of items within the current group. The source name is supplied
in the second form of the function as a lexical QName.</phrase>--></termdef>
            </p>

            <p diff="add" at="C">The current group is bound during evaluation of the
                  <elcode>xsl:for-each-group</elcode> instruction and during evaluation of the
                  <elcode>xsl:merge</elcode> instruction. If neither instruction is being evaluated,
               it will be an empty sequence.</p>

            <p diff="add" at="C">The scope of the current group is dynamic: its value is retained
               through calls on named templates, template rules, functions, and attribute sets.</p>

            <p diff="add" at="C"><!--When called with no arguments,--> The function
                  <function>current-group</function> returns the sequence of items making up the
               current group.</p>

            <!--<p diff="add" at="C">When called with a string argument, the argument is interpreted as a lexical QName, using the namespace
            bindings from the static context of the call. The function returns the subset of items from within the current group that are
            labeled with the specified source name, retaining their order. If there are no items labelled with this source name, the function
            returns an empty sequence.</p>-->

            <!--<note diff="add" at="C"><p>Source names are currently set by <elcode>xsl:merge</elcode> but not by <elcode>xsl:for-each-group</elcode>.</p></note>
            
            <issue id="issue-source-names-for-match-grouping"><p>There is a suggestion that we could use port names "matching" and "non-matching" with group-starting-with and group-ending-with
            to distinguish nodes that match the pattern from those that do not.</p></issue>-->
            <issue id="issue-current-group-source-argument" status="open">
               <p>The WG has considered a variant of <function>current-group</function> for use
                  within <elcode>xsl:merge-action</elcode> which would get the subset of the current
                  group applicable to one named merge source. This is superseded in this draft by
                  the <function>current-merge-inputs</function> function, which provides this
                  capability and more. However, the function call <code>current-group(sourcename)</code> could still be
                  useful because it is simpler. Also, allowing a parameter to <code>current-group</code> 
                  opens the way to do similar things in the context of
                  <elcode>xsl:for-each-group</elcode>,
                  such as using the source names "matching" and "non-matching" to distinguish nodes
                  that matched (or failed to match) the <code>group-starting-with</code> and
                     <code>group-ending-with</code> patterns.</p>
            </issue>

            <p><error spec="XT" type="static" class="SE" code="1060">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the
                        <function>current-group</function> function is used within a <termref def="dt-pattern">pattern</termref>.</p>
               </error></p>

            <!--<p diff="add" at="C">
               <error spec="XT" type="dynamic" class="DE" code="2180">
                  <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if the value 
                     of the first argument to the <function>current-group</function> function is
                     not a valid lexical QName, or if there is no namespace declaration in scope for the prefix of the QName.
                     If the processor is able to detect the error statically (for example, when the argument is
                     supplied as a string literal), then the processor <rfc2119>may</rfc2119> optionally signal this 
                     as a <termref def="dt-static-error">static error</termref>.</p>
               </error>
            </p>-->
         </div2>
         <div2 id="current-grouping-key">
            <head>The Current Grouping Key</head>
            <proto class="xslt" name="current-grouping-key" return-type="xs:anyAtomicType" returnSeq="no" returnEmptyOk="yes"/>
            <p>
               <termdef id="dt-current-grouping-key" term="current grouping key">The evaluation
                  context for XPath <termref def="dt-expression">expressions</termref> includes a
                  component called the <term>current grouping key</term>, which is <phrase diff="chg" at="C">a sequence of atomic values</phrase>. The current grouping key
                  is the <termref def="dt-grouping-key">grouping key</termref> shared in common by
                  all the items within the <termref def="dt-current-group">current
                  group</termref>.</termdef>
            </p>

            <p diff="add" at="C">The current grouping key is bound during evaluation of the
                  <elcode>xsl:for-each-group</elcode> instruction and during evaluation of the
                  <elcode>xsl:merge</elcode> instruction. If neither instruction is being evaluated,
               it will be an empty sequence.</p>

            <p>While an <elcode>xsl:for-each-group</elcode> instruction with a <code>group-by</code>
               or <code>group-adjacent</code> attribute is being evaluated, the <termref def="dt-current-grouping-key">current grouping key</termref> will be a single
               atomic value. </p>

            <p diff="add" at="C">While the <elcode>xsl:merge-action</elcode> part of an
                  <elcode>xsl:merge</elcode> instruction is being evaluated, the current grouping
               key will be a sequence of atomic values, one for each component of the grouping key,
               as defined by the <elcode>xsl:merge-key</elcode> elements.</p>

            <p>At other times, the current grouping key will be the empty sequence.</p>


            <p>The function <function>current-grouping-key</function> returns the <termref def="dt-current-grouping-key">current grouping key</termref>.</p>
            <p><phrase diff="chg" at="D">The <termref def="dt-grouping-key">grouping keys</termref>
                  of all items in a group are not necessarily identical. For example, one might be
                  an <code>xs:float</code> while another is a numerically equal
                     <code>xs:decimal</code></phrase>. The <function>current-grouping-key</function>
               function <phrase diff="chg" at="F">returns</phrase> the grouping key of the <termref def="dt-initial-item">initial item</termref> in the group, after atomization and casting of
                  <code>xs:untypedAtomic</code> values to <code>xs:string</code>.</p>

            <p>The function takes no arguments.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="1070">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the
                        <function>current-grouping-key</function> function is used within a <termref def="dt-pattern">pattern</termref>.</p>
               </error>
            </p>
         </div2>
         <div2 id="xsl-for-each-group">
            <head>The <code>xsl:for-each-group</code> Element</head>
            <e:element-syntax name="for-each-group">
               <e:in-category name="instruction"/>
               <e:attribute name="select" required="yes">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="group-by" required="no">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="group-adjacent" required="no">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="group-starting-with" required="no">
                  <e:data-type name="pattern"/>
               </e:attribute>
               <e:attribute name="group-ending-with" required="no">
                  <e:data-type name="pattern"/>
               </e:attribute>
               <e:attribute name="collation">
                  <e:attribute-value-template>
                     <e:data-type name="uri"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:sequence>
                  <e:element repeat="zero-or-more" name="sort"/>
                  <e:model name="sequence-constructor"/>
               </e:sequence>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>This element is an <termref def="dt-instruction">instruction</termref> that may be
               used anywhere within a <termref def="dt-sequence-constructor">sequence
                  constructor</termref>.</p>
            <p>
               <termdef id="dt-group" term="group">The <elcode>xsl:for-each-group</elcode>
                  instruction allocates the items in an input sequence into <term>groups</term> of
                  items (that is, it establishes a collection of sequences) based either on common
                  values of a grouping key, or on a <termref def="dt-pattern">pattern</termref> that
                  the initial or final <phrase diff="chg" at="C">item</phrase> in a group must
                  match.</termdef> The <termref def="dt-sequence-constructor">sequence
                  constructor</termref> that forms the content of the
                  <elcode>xsl:for-each-group</elcode> instruction is evaluated once for each of
               these groups.</p>
            <p>
               <termdef id="dt-population" term="population">The sequence of items to be grouped,
                  which is referred to as the <term>population</term>, is determined by evaluating
                  the XPath <termref def="dt-expression">expression</termref> contained in the
                     <code>select</code> attribute.</termdef>
            </p>
            <p>
               <termdef id="dt-population-order" term="population order">The population is treated
                  as a sequence; the order of items in this sequence is referred to as
                     <term>population order</term>
               </termdef>.</p>
            <p>A group is never empty. If the population is empty, the number of groups will be
            zero.</p>
            <p>The assignment of items to groups depends on the <code>group-by</code>,
                  <code>group-adjacent</code>, <code>group-starting-with</code>, and
                  <code>group-ending-with</code> attributes. </p>
            <p>
               <error spec="XT" type="static" class="SE" code="1080">
                  <p>These four attributes <error.extra>the <code>group-by</code>,
                           <code>group-adjacent</code>, <code>group-starting-with</code>, and
                           <code>group-ending-with</code> attributes of
                           <elcode>xsl:for-each-group</elcode>
                     </error.extra> are mutually exclusive: it is a <termref def="dt-static-error">static error</termref> if none of these four attributes is present or if
                     more than one of them is present.</p>
               </error>
            </p>
            <p>
               <error spec="XT" type="static" class="SE" code="1090">
                  <p>It is an error to specify the <code>collation</code> attribute if neither the
                        <code>group-by</code> attribute nor <code>group-adjacent</code> attribute is
                     specified.</p>
               </error>
            </p>
 
            <p diff="chg" at="F">
               <termdef id="dt-grouping-key" term="grouping key">If either of the
                  <code>group-by</code> or <code>group-adjacent</code> attributes is
                  present, then for each item in the
                     <termref def="dt-population">population</termref> 
                     a set of <term>grouping keys</term> is calculated, as follows: the expression contained
                     in the <code>group-by</code> or <code>group-adjacent</code> attribute is evaluated;
                     the result is atomized; and any <code>xs:untypedAtomic</code> values are cast to
                     <code>xs:string</code>. The grouping keys are the distinct atomic values present in the result
                     sequence.
                     </termdef>
            </p>
            <p>When calculating grouping keys for an item in the population, the <termref def="dt-expression">expression</termref> contained in the <code>group-by</code> or
                  <code>group-adjacent</code> attribute is evaluated with that item as the <termref def="dt-context-item">context item</termref>, with its position in <termref def="dt-population-order">population order</termref> as the <termref def="dt-context-position">context position</termref>, and with the size of the
               population as the <termref def="dt-context-size">context size</termref>.<phrase diff="del" at="F"> The
               resulting sequence is <termref def="dt-atomization">atomized</termref>, and each
               atomic value in the atomized sequence acts as a <termref def="dt-grouping-key">grouping key</termref> for that item in the population.</phrase></p>
            <p>If the <code>group-by</code> attribute is present, then an item in the population <rfc2119>may</rfc2119>
               have multiple grouping keys: that is, the <code>group-by</code> expression evaluates
               to a sequence. The item is included in as many groups as there are distinct grouping
               keys (which may be zero). If the <code>group-adjacent</code> attribute is used, then
               each item in the population <rfc2119>must</rfc2119> have exactly one grouping key
               value.</p>
            <p>
               <error spec="XT" type="type" class="TE" code="1100" diff="chg" at="F">
                  <p>It is a <termref def="dt-type-error">type error</termref> if the result of
                     evaluating the <code>group-adjacent</code> expression is an empty sequence
                     or a sequence containing more than one item. </p>
               </error>
            </p>
            <p>
               <termref def="dt-grouping-key">Grouping keys</termref> are compared using the rules
               for the <code>eq</code> operator appropriate to their dynamic type. Values of type
                  <code>xs:untypedAtomic</code> are cast to <code>xs:string</code> before the
               comparison. Two items that are not comparable using the <code>eq</code> operator are
               considered to be not equal, that is, they are allocated to different groups. If the
               values are strings, or untyped atomic values, then if there is a
                  <code>collation</code> attribute the values are compared using the collation
               specified as the <termref def="dt-effective-value">effective value</termref> of the
                  <code>collation</code> attribute, resolved if relative against the base URI of the
                  <elcode>xsl:for-each-group</elcode> element. If there is no <code>collation</code>
               attribute then the <termref def="dt-default-collation">default collation</termref> is
               used.</p>
            <p>For the purposes of grouping, the value <code>NaN</code> is considered equal to
               itself.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="1110">
                  <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the collation URI specified to
                        <elcode>xsl:for-each-group</elcode> (after resolving against the base URI)
                     is a collation that is not recognized by the implementation. (For notes,
                        <errorref class="DE" code="1035"/>.)</p>
               </error>
            </p>
            <p>For more information on collations, see <specref ref="collating-sequences"/>.</p>
            <p diff="del" at="C">
               <error spec="XT" type="type" class="TE" code="1120">
                  <p>When the <code>group-starting-with</code> or <code>group-ending-with</code>
                     attribute <error.extra>of the <elcode>xsl:for-each-group</elcode>
                        instruction</error.extra> is used, it is a <termref def="dt-type-error">type
                        error</termref> if the result of evaluating the <code>select</code>
                     expression contains an item that is not a node.</p>
               </error>
            </p>
            <p diff="add" at="F">The way in which an <elcode>xsl:for-each-group</elcode> element is evaluated
               depends on which of the four group-defining attributes is present:</p>
            <ulist>
               <item>
                  <p>If the <code>group-by</code> attribute is present, the items in the <termref def="dt-population">population</termref> are examined, in population order.
                     For each item <var>J</var>, the expression in the <code>group-by</code>
                     attribute is evaluated to produce a sequence of zero or more <termref def="dt-grouping-key">grouping key</termref> values. For each one of these
                        <termref def="dt-grouping-key">grouping keys</termref>, if there is already
                     a group created to hold items having that grouping key value, <var>J</var> is
                        <phrase diff="chg" at="D">appended</phrase> to that group; otherwise a new
                     group is created for items with that grouping key value, and <var>J</var>
                     becomes its first member.</p>
                  <!--</p>					
						<p>If the <code>group-by</code> attribute is present, then  
all items that have the same <termref def="dt-grouping-key">grouping key</termref> are assigned to 
the same group, and the-->
                  <p>An item in the population may thus be <phrase diff="chg" at="D">appended</phrase> to zero, one, or many groups. An item will never be
                        <phrase diff="chg" at="D">appended</phrase> more than once to the same
                     group; if two or more grouping keys for the same item are equal, then the
                     duplicates are ignored. An <emph>item</emph> here means the item at a
                     particular position within the population<!--em dash-->if the
                     population contains the same node at several different positions in the
                     sequence then a group may indeed contain duplicate nodes.</p>
                  <p>The number of groups will be the same as the number of distinct grouping key
                     values present in the <termref def="dt-population">population</termref>. </p>
                  <!--Text inserted by erratum E25 change 2"-->
                  <p>If the population contains values of different numeric types that differ from
                     each other by small amounts, then the <code>eq</code> operator is not
                     transitive, because of rounding effects occurring during type promotion. The
                     effect of this is described in <specref ref="non-transitivity"/>.</p>
                  <!--End of text inserted by erratum E25-->
               </item>
               <item>
                  <p>If the <code>group-adjacent</code> attribute is present, the items in the
                        <termref def="dt-population">population</termref> are examined, in
                     population order. If an item has the same value for the <termref def="dt-grouping-key">grouping key</termref> as its preceding item within
                     the <termref def="dt-population">population</termref> (in <termref def="dt-population-order">population order</termref>), then it is <phrase diff="chg" at="D">appended</phrase> to the same group as its preceding item;
                     otherwise a new group is created and the item becomes its first member.</p>
               </item>
               <item>
                  <p>If the <code>group-starting-with</code> attribute is present, then its value
                        <rfc2119>must</rfc2119> be a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-Pattern" xlink:type="simple">pattern</nt>. <phrase diff="del" at="C">In this case, the items in the population
                           <rfc2119>must</rfc2119> all be nodes.</phrase></p>
                  <p>The <phrase diff="chg" at="C">items</phrase> in the <termref def="dt-population">population</termref> are examined in <termref def="dt-population-order">population order</termref>. If an <phrase diff="chg" at="C">item</phrase> matches the pattern, or is the first <phrase diff="chg" at="C">item</phrase> in the population, then a new group is
                     created and the <phrase diff="chg" at="C">item</phrase> becomes its first
                     member. Otherwise, the <phrase diff="chg" at="C">item</phrase> is <phrase diff="chg" at="D">appended</phrase> to the same group as its preceding
                        <phrase diff="chg" at="C">item</phrase> within the population.</p>
               </item>
               <item>
                  <p>If the <code>group-ending-with</code> attribute is present, then its value
                        <rfc2119>must</rfc2119> be a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-Pattern" xlink:type="simple">pattern</nt>. <phrase diff="del" at="C">In this case, the items in the population
                           <rfc2119>must</rfc2119> all be nodes.</phrase></p>
                  <p>The <phrase diff="chg" at="C">items</phrase> in the <termref def="dt-population">population</termref> are examined in <termref def="dt-population-order">population order</termref>. If an <phrase diff="chg" at="C">item</phrase> is the first <phrase diff="chg" at="C">item</phrase> in the population, or if the previous <phrase diff="chg" at="C">item</phrase> in the population matches the pattern, then a new group
                     is created and the <phrase diff="chg" at="C">item</phrase> becomes its first
                     member. Otherwise, the <phrase diff="chg" at="C">item</phrase> is <phrase diff="chg" at="D">appended</phrase> to the same group as its preceding
                        <phrase diff="chg" at="C">item</phrase> within the population.</p>
               </item>
            </ulist>
            <p diff="add" at="D">In all cases the order of items within each group is predictable,
               and reflects the original <termref def="dt-population-order">population
                  order</termref>, in that the items are processed in population order and each item
               is appended at the end of zero or more groups.</p>
            <note diff="add" at="D">
               <p>As always, a different algorithm may be used if it achieves the same effect.</p>
            </note>
            <p>
               <termdef id="dt-initial-item" term="initial item">For each <termref def="dt-group">group</termref>, the item within the group that is first in <termref def="dt-population-order">population order</termref> is known as the
                     <term>initial item</term> of the group.</termdef>
            </p>
            <p>
               <termdef id="dt-first-appearance" term="order of first appearance">There is a
                  <phrase diff="add" at="F">total</phrase> ordering among <termref def="dt-group">groups</termref> referred to as the
                     <term>order of first appearance</term>. A group <var>G</var> is defined to
                  precede a group <var>H</var> in order of first appearance if the <termref def="dt-initial-item">initial item</termref> of <var>G</var> precedes the
                  initial item of <var>H</var> in population order. If two groups <var>G</var> and
                     <var>H</var> have the same initial item (because the item is in both groups)
                  then <var>G</var> precedes <var>H</var> if the <termref def="dt-grouping-key">grouping key</termref> of <var>G</var> precedes the grouping key of
                     <var>H</var> in the sequence that results from evaluating the
                     <code>group-by</code> expression of this initial item.</termdef>
            </p>
            <p>
               <termdef id="dt-processing-order" term="processing order">There is another 
                  <phrase diff="add" at="F">total</phrase> ordering
                  among groups referred to as <term>processing order</term>. If group <var>R</var>
                  precedes group <var>S</var> in processing order, then in the result sequence
                  returned by the <elcode>xsl:for-each-group</elcode> instruction the items
                  generated by processing group <var>R</var> will precede the items generated by
                  processing group <var>S</var>.</termdef>
            </p>
            <p>If there are no <elcode>xsl:sort</elcode> elements immediately within the
                  <elcode>xsl:for-each-group</elcode> element, the <termref def="dt-processing-order">processing order</termref> of the <termref def="dt-group">groups</termref> is the <termref def="dt-first-appearance">order of
                  first appearance</termref>.</p>
            <!--Text replaced by erratum E8 change 1"-->
            <p>Otherwise, the <elcode>xsl:sort</elcode> elements immediately within the
                  <elcode>xsl:for-each-group</elcode> element define the processing order of the
                  <termref def="dt-group">groups</termref> (see <specref ref="sorting"/>). They do
               not affect the order of items within each group. Multiple <termref def="dt-sort-key-component">sort key components</termref> are allowed, and are
               evaluated in major-to-minor order. If two groups have the same values for all their
               sort key components, they are processed in <termref def="dt-first-appearance"/> if the <termref def="dt-sort-key-specification">sort key specification</termref> is <termref def="dt-stable">stable</termref>, otherwise in an <termref def="dt-implementation-dependent">implementation-dependent</termref> order.</p>
            <!--End of text replaced by erratum E8-->
            <p>The <code>select</code>
               <termref def="dt-expression">expression</termref> of an <elcode>xsl:sort</elcode>
               element is evaluated once for each <termref def="dt-group">group</termref>. During
               this evaluation, the <termref def="dt-context-item">context item</termref> is the
                  <termref def="dt-initial-item">initial item</termref> of the group, the <termref def="dt-context-position">context position</termref> is the position of this item
               within the set of initial items (that is, one item for each group in the <termref def="dt-population">population</termref>) in <termref def="dt-population-order">population order</termref>, the <termref def="dt-context-size">context
                  size</termref> is the number of groups, the <termref def="dt-current-group">current group</termref> is the group whose <termref def="dt-sort-key-value">sort
                  key value</termref> is being determined, and the <termref def="dt-current-grouping-key">current grouping key</termref> is the grouping key
               for that group. If the <elcode>xsl:for-each-group</elcode> instruction uses the
                  <code>group-starting-with</code> or <code>group-ending-with</code> attributes,
               then the current grouping key is the empty sequence.</p>
            <example>
               <head>Sorting Groups</head>
               <p>For example, this means that if the <termref def="dt-grouping-key">grouping
                     key</termref> is <code>@category</code>, you can sort the groups in order of
                  their grouping key by writing <code>&lt;xsl:sort
                     select="current-grouping-key()"/&gt;</code>; or you can sort the groups in
                  order of size by writing <code>&lt;xsl:sort
                     select="count(current-group())"/&gt;</code>
               </p>
            </example>
            <p>The <termref def="dt-sequence-constructor">sequence constructor</termref> contained
               in the <elcode>xsl:for-each-group</elcode> element is evaluated once for each of the
                  <termref def="dt-group">groups</termref>, in <termref def="dt-processing-order">processing order</termref>. The sequences that result are concatenated, in
                  <termref def="dt-processing-order">processing order</termref>, to form the result
               of the <elcode>xsl:for-each-group</elcode> element. Within the <termref def="dt-sequence-constructor">sequence constructor</termref>, the <termref def="dt-context-item">context item</termref> is the <termref def="dt-initial-item">initial item</termref> of the relevant group, the <termref def="dt-context-position">context position</termref> is the position of this <phrase diff="chg" at="F">group
                in the <termref def="dt-processing-order">processing order</termref> of the groups</phrase>, the <termref def="dt-context-size">context size</termref> is the number of groups, the <termref def="dt-current-group">current group</termref> is the <termref def="dt-group">group</termref> being processed, and the <termref def="dt-current-grouping-key">current grouping key</termref> is the grouping key for that group. If the
                  <elcode>xsl:for-each-group</elcode> instruction uses the
                  <code>group-starting-with</code> or <code>group-ending-with</code> attributes,
               then the current grouping key is the empty sequence. This has the effect that within
               the <termref def="dt-sequence-constructor">sequence constructor</termref>, a call on
                  <code>position()</code> takes successive values <code>1, 2, ... last()</code>.</p>
            <p>During the evaluation of a <termref def="dt-stylesheet-function">stylesheet
                  function</termref>, the <termref def="dt-current-group">current group</termref>
               and <termref def="dt-current-grouping-key">current grouping key</termref> are set to
               the empty sequence, and revert to their previous values on completion of evaluation
               of the stylesheet function.</p>
            <p>On completion of the evaluation of the <elcode>xsl:for-each-group</elcode>
               instruction, the <termref def="dt-current-group">current group</termref> and <termref def="dt-current-grouping-key">current grouping key</termref> revert to their
               previous value.</p>
         </div2>
         <div2 id="grouping-examples">
            <head>Examples of Grouping</head>
            <example>
               <head>Grouping Nodes based on Common Values</head>
               <p>The following example groups a list of nodes based on common values. The resulting
                  groups are numbered but unsorted, and a total is calculated for each group. </p>
               <p>Source XML document:</p>
               <eg xml:space="preserve">&lt;cities&gt;
  &lt;city name="Milano"  country="Italia"      pop="5"/&gt;
  &lt;city name="Paris"   country="France"      pop="7"/&gt;
  &lt;city name="Mnchen" country="Deutschland" pop="4"/&gt;
  &lt;city name="Lyon"    country="France"      pop="2"/&gt;
  &lt;city name="Venezia" country="Italia"      pop="1"/&gt;
&lt;/cities&gt;</eg>
               <p>More specifically, the aim is to produce a four-column table, containing one row
                  for each distinct country. The four columns are to contain first, a sequence
                  number giving the number of the row; second, the name of the country, third, a
                  comma-separated alphabetical list of the city names within that country, and
                  fourth, the sum of the <code>pop</code> attribute for the cities in that
                  country.</p>
               <p>Desired output:</p>
               <eg xml:space="preserve">&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Position&lt;/th&gt;
    &lt;th&gt;Country&lt;/th&gt;
    &lt;th&gt;List of Cities&lt;/th&gt;
    &lt;th&gt;Population&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;1&lt;/td&gt;
    &lt;td&gt;Italia&lt;/td&gt;
    &lt;td&gt;Milano, Venezia&lt;/td&gt;
    &lt;td&gt;6&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;2&lt;/td&gt;
    &lt;td&gt;France&lt;/td&gt;
    &lt;td&gt;Lyon, Paris&lt;/td&gt;
    &lt;td&gt;9&lt;/td&gt;
  &lt;/tr&gt;  
  &lt;tr&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;Deutschland&lt;/td&gt;
    &lt;td&gt;Mnchen&lt;/td&gt;
    &lt;td&gt;4&lt;/td&gt;
  &lt;/tr&gt;  
&lt;/table&gt;</eg>
               <p>Solution:</p>
               <eg xml:space="preserve">&lt;table xsl:version="2.1" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;tr&gt;
    &lt;th&gt;Position&lt;/th&gt;
    &lt;th&gt;Country&lt;/th&gt;
    &lt;th&gt;City List&lt;/th&gt;
    &lt;th&gt;Population&lt;/th&gt;
  &lt;/tr&gt;
  &lt;xsl:for-each-group select="cities/city" group-by="@country"&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;xsl:value-of select="position()"/&gt;&lt;/td&gt;
      &lt;td&gt;&lt;xsl:value-of select="@country"/&gt;&lt;/td&gt;
      &lt;td&gt;
        &lt;xsl:value-of select="current-group()/@name" separator=", "/&gt;
      &lt;/td&gt;
      &lt;td&gt;&lt;xsl:value-of select="sum(current-group()/@pop)"/&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/table&gt;</eg>
            </example>
            <!--
				<example>
					<p>The following example uses the same source document, this time
	 grouping the cities according to the initial letter of the city name. The groups
	 are sorted, and the result includes a count of the nodes within the group.
	 The heading contains a count of the number of groups:</p>
					<p>Desired output:</p>
					<eg><![CDATA[<html>
  <body>
    <h2>L (1)</h2><p>Lyon</p>
    <h2>M (2)</h2><p>Milano</p><p>Mnchen</p>
    <h2>P (1)</h2><p>Paris</p>
    <h2>V (1)</h2><p>Venezia</p>
  </body>
    </html>]]></eg>
					<p>Solution:</p>
					<eg><![CDATA[<html xsl:version="2.1" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <body>
    <xsl:for-each-group select="cities/city" group-by="substring(@name,1,1)">
      <xsl:sort select="current-grouping-key()"/>
      <h2>
        <xsl:value-of select="upper-case(current-grouping-key())"/>
        <xsl:text> (</xsl:text>
        <xsl:value-of select="count(current-group())"/>
        <xsl:text>)</xsl:text>
      </h2>
      <xsl:for-each select="current-group()">
        <p><xsl:value-of select="@name"/></p>
      </xsl:for-each>
    </xsl:for-each-group>
  </body>
</html>]]></eg>
				</example>
-->
            <example>
               <head>A Composite Grouping Key</head>
               <p>Sometimes it is necessary to use a composite grouping key: for example, suppose
                  the source document is similar to the one used in the previous examples, but
                  allows multiple entries for the same country and city, such as:</p>
               <eg xml:space="preserve">&lt;cities&gt;
  &lt;city name="Milano"  country="Italia"  year="1950"   pop="5.23"/&gt;
  &lt;city name="Milano"  country="Italia"  year="1960"   pop="5.29"/&gt;  
  &lt;city name="Padova"  country="Italia"  year="1950"   pop="0.69"/&gt;
  &lt;city name="Padova"  country="Italia"  year="1960"   pop="0.93"/&gt;    
  &lt;city name="Paris"   country="France"  year="1951"   pop="7.2"/&gt;
  &lt;city name="Paris"   country="France"  year="1961"   pop="7.6"/&gt;
&lt;/cities&gt;</eg>
               <p>Now suppose we want to list the average value of <code>@pop</code> for each
                  (country, name) combination. One way to handle this is to concatenate the parts of
                  the key, for example <code>&lt;xsl:for-each-group select="concat(@country, '/',
                     @name)"&gt;</code>. A more flexible solution is to nest one
                     <elcode>xsl:for-each-group</elcode> element directly inside another:</p>
               <eg xml:space="preserve">&lt;xsl:for-each-group select="cities/city" group-by="@country"&gt;
  &lt;xsl:for-each-group select="current-group()" group-by="@name"&gt;
    &lt;p&gt;&lt;xsl:value-of select="@name"/&gt;, &lt;xsl:value-of select="@country"/&gt;:
        &lt;xsl:value-of select="avg(current-group()/@pop)"/&gt;&lt;/p&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/xsl:for-each-group&gt;</eg>
               <p>The two approaches are not precisely equivalent. If the code were changed to
                  output the value of <code>position()</code> alongside <code>@name</code> then the
                  first approach (a single <elcode>xsl:for-each-group</elcode> element with a
                  compound key) would number the groups (1, 2, 3), while the second approach (two
                  nested <elcode>xsl:for-each-group</elcode> elements) would number them (1, 2,
                  1).</p>
            </example>
            <example>
               <head>Identifying a Group by its Initial Element</head>
               <p>The next example identifies a group not by the presence of a common value, but
                  rather by adjacency in document order. A group consists of an <code>h2</code>
                  element, followed by all the <code>p</code> elements up to the next
                     <code>h2</code> element.</p>
               <p>Source XML document:</p>
               <eg xml:space="preserve">&lt;body&gt;
  &lt;h2&gt;Introduction&lt;/h2&gt;
  &lt;p&gt;XSLT is used to write stylesheets.&lt;/p&gt;
  &lt;p&gt;XQuery is used to query XML databases.&lt;/p&gt;
  &lt;h2&gt;What is a stylesheet?&lt;/h2&gt;
  &lt;p&gt;A stylesheet is an XML document used to define a transformation.&lt;/p&gt;
  &lt;p&gt;Stylesheets may be written in XSLT.&lt;/p&gt;
  &lt;p&gt;XSLT 2.0 introduces new grouping constructs.&lt;/p&gt;
&lt;/body&gt;</eg>
               <p>Desired output:</p>
               <eg xml:space="preserve">&lt;chapter&gt;
  &lt;section title="Introduction"&gt;
    &lt;para&gt;XSLT is used to write stylesheets.&lt;/para&gt;
    &lt;para&gt;XQuery is used to query XML databases.&lt;/para&gt;
  &lt;/section&gt; 
  &lt;section title="What is a stylesheet?"&gt;
    &lt;para&gt;A stylesheet is used to define a transformation.&lt;/para&gt;
    &lt;para&gt;Stylesheets may be written in XSLT.&lt;/para&gt;
    &lt;para&gt;XSLT 2.0 introduces new grouping constructs.&lt;/para&gt;
  &lt;/section&gt;
&lt;/chapter&gt;</eg>
               <p>Solution:</p>
               <eg xml:space="preserve">&lt;xsl:template match="body"&gt;
  &lt;chapter&gt;
	&lt;xsl:for-each-group select="*" group-starting-with="h2"	&gt;
	  &lt;section title="{self::h2}"&gt;
	    &lt;xsl:for-each select="current-group()[self::p]"&gt;
	      &lt;para&gt;&lt;xsl:value-of select="."/&gt;&lt;/para&gt;
	    &lt;/xsl:for-each&gt; 
	  &lt;/section&gt;
	&lt;/xsl:for-each-group&gt;
  &lt;/chapter&gt;
&lt;/xsl:template&gt;</eg>
               <p>The use of <code>title="{self::h2}"</code> rather than <code>title="{.}"</code> is
                  to handle the case where the first element is not an <code>h2</code> element.</p>
            </example>
            <example>
               <head>Identifying a Group by its Final Element</head>
               <p>The next example illustrates how a group of related elements can be identified by
                  the last element in the group, rather than the first. Here the absence of the
                  attribute <code>continued="yes"</code> indicates the end of the group.</p>
               <p>Source XML document:</p>
               <eg xml:space="preserve">&lt;doc&gt;
  &lt;page continued="yes"&gt;Some text&lt;/page&gt;
  &lt;page continued="yes"&gt;More text&lt;/page&gt;    
  &lt;page&gt;Yet more text&lt;/page&gt;
  &lt;page continued="yes"&gt;Some words&lt;/page&gt;
  &lt;page continued="yes"&gt;More words&lt;/page&gt;    
  &lt;page&gt;Yet more words&lt;/page&gt;        
&lt;/doc&gt;</eg>
               <p>Desired output:</p>
               <eg xml:space="preserve">&lt;doc&gt;
  &lt;pageset&gt;
    &lt;page&gt;Some text&lt;/page&gt;
    &lt;page&gt;More text&lt;/page&gt;    
    &lt;page&gt;Yet more text&lt;/page&gt;
  &lt;/pageset&gt;
  &lt;pageset&gt;
    &lt;page&gt;Some words&lt;/page&gt;
    &lt;page&gt;More words&lt;/page&gt;    
    &lt;page&gt;Yet more words&lt;/page&gt;
  &lt;/pageset&gt;
&lt;/doc&gt;</eg>
               <p>Solution:</p>
               <eg xml:space="preserve">&lt;xsl:template match="doc"&gt;
&lt;doc&gt;
  &lt;xsl:for-each-group select="*" 
                      group-ending-with="page[not(@continued='yes')]"&gt;
    &lt;pageset&gt;
      &lt;xsl:for-each select="current-group()"&gt;
        &lt;page&gt;&lt;xsl:value-of select="."/&gt;&lt;/page&gt;
      &lt;/xsl:for-each&gt; 
    &lt;/pageset&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/doc&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <example>
               <head>Adding an Element to Several Groups</head>
               <p>The next example shows how an item can be added to multiple groups. Book titles
                  will be added to one group for each indexing term marked up within the title.</p>
               <p>Source XML document:</p>
               <eg xml:space="preserve">&lt;titles&gt;
    &lt;title&gt;A Beginner's Guide to &lt;ix&gt;Java&lt;/ix&gt;&lt;/title&gt;
    &lt;title&gt;Learning &lt;ix&gt;XML&lt;/ix&gt;&lt;/title&gt;
    &lt;title&gt;Using &lt;ix&gt;XML&lt;/ix&gt; with &lt;ix&gt;Java&lt;/ix&gt;&lt;/title&gt;
&lt;/titles&gt;</eg>
               <p>Desired output:</p>
               <eg xml:space="preserve">&lt;h2&gt;Java&lt;/h2&gt;
    &lt;p&gt;A Beginner's Guide to Java&lt;/p&gt;
    &lt;p&gt;Using XML with Java&lt;/p&gt;
&lt;h2&gt;XML&lt;/h2&gt;
    &lt;p&gt;Learning XML&lt;/p&gt;
    &lt;p&gt;Using XML with Java&lt;/p&gt;</eg>
               <p>Solution:</p>
               <eg xml:space="preserve">&lt;xsl:template match="titles"&gt;
    &lt;xsl:for-each-group select="title" group-by="ix"&gt;
      &lt;h2&gt;&lt;xsl:value-of select="current-grouping-key()"/&gt;&lt;/h2&gt;
      &lt;xsl:for-each select="current-group()"&gt;
        &lt;p&gt;&lt;xsl:value-of select="."/&gt;&lt;/p&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <example>
               <head>Grouping Alternating Sequences of Elements</head>
               <p>In the final example, the membership of a node within a group is based both on
                  adjacency of the nodes in document order, and on common values. In this case, the
                  grouping key is a boolean condition, true or false, so the effect is that a
                  grouping establishes a maximal sequence of nodes for which the condition is true,
                  followed by a maximal sequence for which it is false, and so on.</p>
               <p>Source XML document:</p>
               <eg xml:space="preserve">&lt;p&gt;Do &lt;em&gt;not&lt;/em&gt;:
    &lt;ul&gt;
    &lt;li&gt;talk,&lt;/li&gt;
    &lt;li&gt;eat, or&lt;/li&gt;
    &lt;li&gt;use your mobile telephone&lt;/li&gt;
    &lt;/ul&gt;
    while you are in the cinema.&lt;/p&gt;</eg>
               <p>Desired output:</p>
               <eg xml:space="preserve">&lt;p&gt;Do &lt;em&gt;not&lt;/em&gt;:&lt;/p&gt;
    &lt;ul&gt;
    &lt;li&gt;talk,&lt;/li&gt;
    &lt;li&gt;eat, or&lt;/li&gt;
    &lt;li&gt;use your mobile telephone&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;while you are in the cinema.&lt;/p&gt;</eg>
               <p>Solution:</p>
               <p>This requires creating a <code>p</code> element around the maximal sequence of
                  sibling nodes that does not include a <code>ul</code> or <code>ol</code>
                  element.</p>
               <p>This can be done by using <code>group-adjacent</code>, with a grouping key that is
                  true if the element is a <code>ul</code> or <code>ol</code> element, and false
                  otherwise:</p>
               <eg xml:space="preserve">&lt;xsl:template match="p"&gt;
    &lt;xsl:for-each-group select="node()" 
            group-adjacent="self::ul or self::ol"&gt;
        &lt;xsl:choose&gt;
            &lt;xsl:when test="current-grouping-key()"&gt;
                &lt;xsl:copy-of select="current-group()"/&gt;  
            &lt;/xsl:when&gt;
            &lt;xsl:otherwise&gt;
                &lt;p&gt;
                    &lt;xsl:copy-of select="current-group()"/&gt;
                &lt;/p&gt;
            &lt;/xsl:otherwise&gt;  
        &lt;/xsl:choose&gt;
    &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;</eg>
            </example>
         </div2>
         <!--Text inserted by erratum E25 change 3"-->
         <div2 id="non-transitivity">
            <head>Non-Transitivity</head>
            <p>If the population contains values of different numeric types that differ from each
               other by small amounts, then the <code>eq</code> operator is not transitive, because
               of rounding effects occurring during type promotion. It is thus possible to have
               three values <var>A</var>, <var>B</var>, and <var>C</var> among the grouping keys of
               the population such that <code>A eq B</code>, <code>B eq C</code>, but <code>A ne
                  C</code>.</p>
            <p>For example, this arises when computing</p>
            <eg xml:space="preserve">
      &lt;xsl:for-each-group group-by="." select="
             xs:float('1.0'),
             xs:decimal('1.0000000000100000000001',
             xs:double( '1.00000000001')"&gt;</eg>
            <p>because the values of type <code>xs:float</code> and <code>xs:double</code> both
               compare equal to the value of type <code>xs:decimal</code> but not equal to each
               other.</p>
            <p>In this situation the results <rfc2119>must</rfc2119> be equivalent to the results
               obtained by the following algorithm:</p>
            <ulist>
               <item>
                  <p>For each item <var>J</var> in the <termref def="dt-population">population</termref> in <termref def="dt-population-order">population
                        order</termref>, for each of the <termref def="dt-grouping-key">grouping
                        keys</termref>
                     <var>K</var> for that item in sequence, the processor identifies those existing
                     groups <var>G</var> such that the grouping key of the <termref def="dt-initial-item">initial item</termref> of <var>G</var> is equal to
                        <var>K</var>.</p>
               </item>
               <item>
                  <p>If there is exactly one group <var>G</var>, then <var>J</var> is added to this
                     group, unless <var>J</var> is already a member of this group.</p>
               </item>
               <item>
                  <p>If there is no group <var>G</var>, then a new group is created with
                        <var>J</var> as its first item.</p>
               </item>
               <item>
                  <p>If there is more than one group <var>G</var> (which can only happen in
                     exceptional circumstances involving non-transitivity), then one of these groups
                     is selected in an implementation-dependent way, and <var>J</var> is added to
                     this group, unless <var>J</var> is already a member of this group.</p>
               </item>
            </ulist>
            <p>The effect of these rules is that (a) every item in a non-singleton group has a
               grouping key that is equal to that of at least one other item in that group, (b) for
               any two distinct groups, there is at least one pair of items (one from each group)
               whose grouping keys are not equal to each other.</p>
         </div2>
         <!--End of text inserted by erratum E25-->
      </div1>
      <div1 id="merging" diff="chg" at="C">
         <head>Merging</head>
         <p>The <elcode>xsl:merge</elcode> instruction allows a sorted sequence of items to be
            constructed by merging several input sequences, each of which is already sorted. Each
            input sequence <rfc2119 diff="chg" at="F">must</rfc2119> have a merge key (one or more
            atomic values that can be computed as a function of the items in the sequence); the
            input sequence <rfc2119 diff="chg" at="F">must</rfc2119> be pre-sorted on the value of its merge
            keys; and the merge keys for the different input sequences <rfc2119 diff="chg" at="F">must</rfc2119> be compatible in the sense that <phrase diff="chg" at="F">key values from
               an item in one sequence are always comparable with key values from an item in a
               different sequence</phrase>.</p>

         <p>For example, if two log files contain details of events sorted by date and time, then
            the <elcode>xsl:merge</elcode> instruction can be used to combine these into a single
            sequence that is also sorted by date and time.</p>

         <p>The data written to the output sequence can be computed in an arbitrary way from the
            data in the input sequences.</p>

         <p>The <elcode>xsl:merge</elcode> instruction checks that the input sequences are correctly
            sorted and signals a dynamic error if they are not. It does not actually perform the
            sorting.</p>

         <p>The <elcode>xsl:merge</elcode> instruction can be used to merge several sequences of
            items that all have the same structure (more precisely, sequences whose merge keys are
            computed in the same way): for example, log files created by the same application
            running on different machines in a server farm. Alternatively,
               <elcode>xsl:merge</elcode> can be used to merge sequences that have different
            structure (sequences whose merge keys are computed in different ways), provided that the
            computed merge keys are compatible: an example might be two log files created by
            different applications, using different XML vocabularies, that both contain timestamped
            events but represent the timestamp in different ways. The
               <elcode>xsl:merge-source</elcode> element represents a <phrase diff="chg" at="F">set
               of input sequences that follow common rules</phrase>, including the rules for
            computing the merge key. The <elcode>xsl:merge</elcode> operation may take any number of
               <elcode>xsl:merge-source</elcode> elements representing different <phrase diff="chg" at="F">rules for</phrase> input sequences, and each <elcode>xsl:merge-source</elcode>
            element may describe any number (zero or more) of input sequences. The number of input
            sequences to the merging operation is thus <phrase diff="chg" at="F">fixed only at the
               time the <elcode>xsl:merge</elcode> instruction is evaluated, and
                  <rfc2119>may</rfc2119> vary from one evaluation to another</phrase>.</p>

         <p>The following examples illustrate some of the possibilities. The detailed explanation of
            the constructs used follows later in this section.</p>

         <example>
            <head>Merging all the files in a collection</head>
            <p>This example takes as input a homogeneous collection of XML log files each of which
               contains a sorted sequence of <code>event</code> elements with a
                  <code>timestamp</code> attribute validated as an instance of
                  <code>xs:dateTime</code>. It merges the events from the input files into a single
               sorted output file.</p>
            <eg xml:space="preserve">
&lt;xsl:result-document href="merged-events.xml"&gt;
  &lt;events&gt;
    &lt;xsl:merge&gt;
      &lt;xsl:merge-source select="collection('log-files')"&gt;
        &lt;xsl:merge-input select="events/event"&gt;
          &lt;xsl:merge-key select="@timestamp"/&gt;
        &lt;/xsl:merge-input&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-action&gt;
        &lt;xsl:copy-of select="current-group()"/&gt;
      &lt;/xsl:merge-action&gt;
    &lt;/xsl:merge&gt;
  &lt;/events&gt;
&lt;/xsl:result-document&gt;
</eg>
            <p>The example assumes that there are <phrase diff="chg" at="F">several input files each of which has</phrase> a structure similar to the
               following, in which the <code>timestamp</code> attribute has a typed value that is an instance of
                  <code>xs:dateTime</code>:</p>
            <eg xml:space="preserve">
&lt;events&gt;
   &lt;event timestamp="2009-08-20T12:01:01Z"&gt;Transaction T1234 started&lt;/event&gt;
   &lt;event timestamp="2009-08-20T12:01:08Z"&gt;Transaction T1235 started&lt;/event&gt;
   &lt;event timestamp="2009-08-20T12:01:12Z"&gt;Transaction T1235 ended&lt;/event&gt;
   &lt;event timestamp="2009-08-20T12:01:15Z"&gt;Transaction T1234 ended&lt;/event&gt;
&lt;/events&gt;</eg>
            <p>The output file will have the same structure, and will contain copies of all the
                  <code>event</code> elements from all of the input files, in sorted order. <phrase diff="chg" at="F">Note that
               multiple events with the same timestamp can occur either within a single file or
               across multiple files: the order of appearance of these events in the output file corresponds
               to the order of the log files within the collection (which might or might not be predictable,
               depending on the implementation).</phrase></p>
         </example>

         <example>
            <head>Merging two heterogeneous files</head>
            <p>This example takes as input two log files with different structure, producing a
               single merged output in which the entries have a common structure:</p>
            <eg xml:space="preserve">
&lt;xsl:result-document href="merged-events.xml"&gt;
  &lt;events&gt;
    &lt;xsl:merge&gt;
      &lt;xsl:merge-source select="doc('log-file-1.xml')"&gt;
        &lt;xsl:merge-input select="events/event"&gt;
          &lt;xsl:merge-key select="@timestamp"/&gt;
        &lt;/xsl:merge-input&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-source select="doc('log-files-2.xml')"&gt;
        &lt;xsl:merge-input select="log/day/record"&gt;
          &lt;xsl:merge-key select="dateTime(../@date, time)"/&gt;
        &lt;/xsl:merge-input&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-action&gt;
        &lt;xsl:apply-templates select="current-group()" 
                             mode="standardize-log-entry"&gt;
      &lt;/xsl:merge-action&gt;
    &lt;/xsl:merge&gt;
  &lt;/events&gt;
&lt;/xsl:result-document&gt;
</eg>
            <p>Here the first input file has a structure similar to that shown in the previous
               example, while the second input has a different structure, of the form: <eg xml:space="preserve">
&lt;log&gt;
  &lt;day date="2009-08-20"&gt;
    &lt;record&gt;
      &lt;time&gt;12:01:09-05:00&lt;/time&gt;
      &lt;message&gt;Temperature 15.4C&lt;/message&gt;
    &lt;/record&gt;
    &lt;record&gt;
      &lt;time&gt;12:03:00-05:00&lt;/time&gt;
      &lt;message&gt;Temperature 18.2C&lt;/message&gt;
    &lt;/record&gt;
  &lt;/day&gt;
&lt;/log&gt;</eg></p>
            <p>The templates in mode <code>standardize-log-entry</code> convert the log entries to a
               common output format, for example:</p>
            <eg xml:space="preserve">
&lt;xsl:template match="event" mode="standardize-log-entry" 
                            as="schema-element(event)"&gt;
  &lt;xsl:copy-of select-"." validation="preserve"/&gt;
&lt;/xsl:template&gt;
  
&lt;xsl:template match="record" mode="standardize-log-entry" 
                             as="schema-element(event)"&gt;
  &lt;event timestamp="{dateTime(../@date, time)}" xsl:validation="strict"&gt;
    &lt;xsl:value-of select="message"/&gt;
  &lt;/event&gt;
&lt;/xsl:template&gt;</eg>
         </example>

         <note>
            <p>The <elcode>xsl:merge</elcode> instruction is designed to enable streaming
               of data, so that there is no need to allocate memory to hold the input sequences.
               However, there is no requirement that an implementation should actually use streaming to perform the
               processing.</p>
         </note>
         
         <issue id="issue-streamability-of-merge" status="open"><p>
            The <elcode>xsl:merge</elcode> instruction is designed to achieve streamability in the case
            where the anchor nodes are the document nodes of distinct documents and the merge keys
            are <termref def="dt-motionless"/> expressions. However, unlike other constructs, there
            is no provision for users to indicate that streaming is required, and no analysis of the
            conditions under which it is guaranteed.            
         </p></issue>

         <div2 id="merge-terminology">
            <head>Terminology for merging</head>
            <p><termdef id="dt-merge-source-definition" term="merge source definition">A <term>merge
                     source definition</term> is the definition of one kind of input to the merge
                  operation. It selects zero or more <termref def="dt-merge-input-sequence">merge
                     input sequences</termref>, and it includes a <termref def="dt-merge-key-specification">merge key specification</termref> to define
                  how the <phrase diff="chg" at="F"><termref def="dt-merge-key-value">merge key values</termref></phrase> 
               are computed for each such merge input sequence.</termdef> A
               merge source definition corresponds to an <elcode>xsl:merge-source</elcode> element
               in the stylesheet.</p>

            <p><termdef id="dt-merge-input-sequence" term="merge input sequence">A <term>merge input
                     sequence</term> is an arbitrary <xtermref spec="DM11" ref="dt-sequence">sequence</xtermref> of items which is already sorted according to the <termref def="dt-merge-key-specification">merge key specification</termref> for the
                  corresponding <termref def="dt-merge-source-definition">merge source
                     definition</termref>.</termdef></p>

            <p><termdef id="dt-merge-key-specification" term="merge key specification">A <term>merge
                     key specification</term> consists of one or more adjacent
                     <elcode>xsl:merge-key</elcode> elements which together define how the <termref def="dt-merge-input-sequence">merge input sequences</termref> selected by a
                     <termref def="dt-merge-source-definition">merge source definition</termref> are
                  sorted. Each <elcode>xsl:merge-key</elcode> element defines one <termref def="dt-merge-key-component">merge key component</termref>.</termdef> For
               example, a merge key specification for a log file might specify two merge key
               components, <code>date</code> and <code>time</code>.</p>

            <p><termdef id="dt-merge-key-component" term="merge key component">A <term>merge key
                     component</term> specifies one component of a <termref def="dt-merge-key-specification">merge key specification</termref>; it
                  corresponds to a single <elcode>xsl:merge-key</elcode> element in the
                  stylesheet.</termdef></p>

            <p><termdef id="dt-merge-key-value" term="merge key value"> For each item in a <termref def="dt-merge-input-sequence">merge input sequence</termref>, a value is
                  computed for each <termref def="dt-merge-key-component">merge key
                     component</termref> within the <termref def="dt-merge-key-specification">merge
                     key specification</termref>. The value computed for an item by using the
                     <var>N</var>th <termref def="dt-merge-key-component"/> is referred to as the <var>N</var>th
                     <term>merge key value</term> of that item.</termdef></p>

            <p><termdef id="dt-composite-merge-key-value" term="composite merge key value"> The
                  ordered collection of <termref def="dt-merge-key-value">merge key values</termref>
                  computed for one item in a <termref def="dt-merge-input-sequence">merge input
                     sequence</termref> (one for each <termref def="dt-merge-key-component">merge
                     key component</termref> within the <termref def="dt-merge-key-specification">merge key specification</termref>) is referred to as a <term>composite merge
                     key value</term>.</termdef></p>

         </div2>

         <div2 id="merge-instruction">
            <head>The <elcode>xsl:merge</elcode> instruction</head>
            <e:element-syntax name="merge" diff="chg" at="C">
               <e:in-category name="instruction"/>
               <e:sequence>
                  <e:element repeat="one-or-more" name="merge-source"/>
                  <e:element name="merge-action"/>
                  <e:element repeat="zero-or-more" name="fallback"/>
               </e:sequence>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The effect of the <elcode>xsl:merge</elcode> instruction is to produce a sorted
               result sequence from a number of pre-sorted input sequences.</p>

            <p>The input sequences to the merge operation are defined by the
                  <elcode>xsl:merge-source</elcode> child elements, as described in the next
               section.</p>

            <p diff="chg" at="C">The sequence constructor contained in the
                  <elcode>xsl:merge-action</elcode> element is evaluated once for each distinct
               <termref def="dt-composite-merge-key-value"/> to form a partial result sequence. 
               The result of the <elcode>xsl:merge</elcode> instruction is the concatenation
               of these partial result sequences. For example,
               the action might be to copy the items from all the input sequences to the result
               sequence without change; or it might be to select the items from one input sequence
               in preference to the others. In the general case, the items in the partial result
               sequence are produced by an arbitrary computation that has access to the items (from
               the various input sequences) that share the same value for the composite merge key.</p>

            <p diff="chg" at="C">The <elcode>xsl:merge-source</elcode> and
                  <elcode>xsl:merge-action</elcode> elements are described in the following
               sections.</p>

            <p>Any <elcode>xsl:fallback</elcode> children of the <elcode>xsl:merge</elcode>
               instruction are ignored by an XSLT 2.1 processor, but are used by an XSLT 1.0 or XSLT
               2.0 processor to <phrase diff="chg" at="F">perform fallback processing</phrase>.</p>

            <note>
               <p>An <elcode>xsl:merge</elcode> instruction that has no input sequences returns an
                  empty sequence. An <elcode>xsl:merge</elcode> instruction with a single input
                  sequence performs processing that is very similar in concept to
                     <elcode>xsl:for-each-group</elcode> with the <code>group-adjacent</code>
                  attribute, except that it requires the input to be sorted on the grouping key.</p>
            </note>
         </div2>
         <div2 id="merge-input-sequences">
            <head>Selecting the sequences to be merged</head>
            <e:element-syntax name="merge-source">
               <e:attribute name="select" required="no">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="name" required="no">
                  <e:data-type name="QName"/>
               </e:attribute>
               <e:element name="merge-input"/>
               <e:allowed-parents>
                  <e:parent name="merge"/>
               </e:allowed-parents>
            </e:element-syntax>

            <e:element-syntax name="merge-input">
               <e:attribute name="select" required="no">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:sequence>
                  <e:model name="sequence-constructor"/>
                  <e:element repeat="one-or-more" name="merge-key"/>
               </e:sequence>
               <e:allowed-parents>
                  <e:parent name="merge-source"/>
               </e:allowed-parents>
            </e:element-syntax>

            <p>Each <elcode>xsl:merge-source</elcode> element defines a collection of <termref def="dt-merge-input-sequence">merge input sequences</termref>. The selection of
               items in these input sequences is a two-stage process: the <code>select</code>
               attribute of the <elcode>xsl:merge-source</elcode> element is an expression that
               selects a sequence of <emph>anchor items</emph>, and for each anchor item, the
                  <code>select</code> attribute or <termref def="dt-sequence-constructor">sequence
                  constructor</termref> of the <elcode>xsl:merge-input</elcode> element is evaluated
               to select the items that make up one merge input sequence.</p>

            <p>The <code>select</code> attribute of the <elcode>xsl:merge-source</elcode> element is
               evaluated with the dynamic context of the containing <elcode>xsl:merge</elcode>
               instruction. If the <code>select</code> attribute is omitted, the default value is
                  <code>.</code>, which selects the context item.</p>

            <p>The <code>select</code> attribute of <elcode>xsl:merge-input</elcode> and the
               contained <termref def="dt-sequence-constructor">sequence constructor</termref> are
               mutually exclusive: if the <code>select</code> attribute is present, the sequence
               constructor must be empty, and if the sequence constructor is non-empty, the
                  <code>select</code> attribute must be absent. </p>

            <p>The <code>select</code> expression or the contained sequence constructor of the
                  <elcode>xsl:merge-input</elcode> instruction is evaluated once for each anchor
               item selected by the containing <elcode>xsl:merge-source</elcode> element. Each
               evaluation produces a sequence, which acts as one of the input sequences for the
               merge operation. The <termref def="dt-focus">focus</termref> for the evaluation is as
               follows:</p>

            <ulist>
               <item>
                  <p>The <termref def="dt-context-item">context item</termref> is the anchor
                     item</p>
               </item>
               <item>
                  <p>The <termref def="dt-context-position">context position</termref> is the
                     position of the anchor item within the sequence of anchor items</p>
               </item>
               <item>
                  <p>The <termref def="dt-context-size">context size</termref> is the number of
                     anchor items.</p>
               </item>
            </ulist>

            <note>
               <p>The <elcode>xsl:merge-key</elcode> element appears at the end of the sequence
                  constructor because the computation of the merge key takes the result of the
                  sequence constructor as its input.</p>
            </note>

            <example>
               <head>Merging several documents with the same structure</head>
               <p>The following <elcode>xsl:merge-source</elcode> element selects two anchor items
                  (the root nodes of two documents), and for each of these it selects an input
                  sequence consisting of selected <code>event</code> elements within the relevant
                  document.</p>

               <eg xml:space="preserve">
&lt;xsl:merge-source select="doc('log-A.xml'), doc('log-B.xml')"&gt;
  &lt;xsl:merge-input select="events/event"&gt;
    &lt;xsl:merge-key select="@timestamp" order="ascending"/&gt;
  &lt;/xsl:merge-input&gt;
&lt;/xsl:merge-source&gt;</eg>

               <p>This example can be extended to merge any number of input documents with the same
                  structure:</p>
               <eg xml:space="preserve">
&lt;xsl:merge-source select="collection('log-collection')"&gt;
  &lt;xsl:merge-input select="*/event"&gt;
    &lt;xsl:merge-key select="@time" order="ascending"/&gt;
  &lt;/xsl:merge-input&gt;
&lt;/xsl:merge-source&gt;</eg>
               <p>In both the above examples the anchor items are document nodes, and the items in
                  the input sequence are elements within the document that is rooted at this node.
                  This is a common usage pattern, but by no means the only way in which the
                  construct can be used.</p>
            </example>

            <p>The number of anchor items selected by an <elcode>xsl:merge-source</elcode> element,
               and therefore the number of input sequences, is variable, but the input sequences
               selected by one <elcode>xsl:merge-source</elcode> element must all use the same
               expressions to select the items in the input sequence and to compute their merge
               keys. If different expressions are needed for different input sequences, then
               multiple <elcode>xsl:merge-source</elcode> elements can be used.</p>

            <example>
               <head>Merging two documents with different structure</head>
               <p>The following code merges two log files having different internal structure:</p>

               <eg xml:space="preserve">
&lt;xsl:merge-source&gt;
  &lt;xsl:merge-input select="doc('event-log.xml')/*/event"&gt;
    &lt;xsl:merge-key select="@timestamp"/&gt;
  &lt;/xsl:merge-input&gt;
&lt;/xsl:merge-source&gt;
&lt;xsl:merge-source&gt;
  &lt;xsl:merge-input select="doc('error-log.xml')//error"&gt;
    &lt;xsl:merge-key select="dateTime(@date, @time)"/&gt;
  &lt;/xsl:merge-input&gt;
&lt;/xsl:merge-source&gt;</eg>

               <p>Although the merge keys are computed in different ways for the two input
                  sequences, the keys must be compatible across the two sequences: in this case they
                  are both atomic values of type <code>xs:dateTime</code>.</p>
            </example>

            <p>In the common case where there is only one input sequence of a particular kind, the
                  <code>select</code> attribute of <elcode>xsl:merge-source</elcode> may be omitted;
               its default value is <code>.</code> (dot), which has the effect that the
                  <code>select</code> expression of the <elcode>xsl:merge-input</elcode> element is
               evaluated relative to the <termref def="dt-focus">focus</termref> of the
                  <elcode>xsl:merge</elcode> instruction itself.</p>
            <example>
               <head>Sorting before merging</head>
               <p>Where one or more of the inputs to the merging process is not pre-sorted, an
                     <elcode>xsl:perform-sort</elcode> instruction can be used as a child of
                     <elcode>xsl:merge-input</elcode>. For example:</p>
               <eg xml:space="preserve">
&lt;xsl:merge-source&gt;
  &lt;xsl:merge-input select="doc('event-log.xml')/*/event"&gt;
    &lt;xsl:merge-key select="@timestamp"/&gt;
  &lt;/xsl:merge-input&gt;
&lt;/xsl:merge-source&gt;
&lt;xsl:merge-source&gt;
  &lt;xsl:merge-input&gt;
    &lt;xsl:perform-sort select="doc('error-log.xml')//error"&gt;
      &lt;xsl:sort select="@time"/&gt;
    &lt;/xsl:perform-sort&gt;
    &lt;xsl:merge-key select="dateTime(current-date(), @time)"/&gt;
  &lt;/xsl:merge-input&gt;
&lt;/xsl:merge-source&gt;</eg>
            </example>

            <p diff="chg" at="E">An <elcode>xsl:merge-source</elcode> element has an optional
                  <code>name</code> attribute, whose value is a <termref def="dt-expanded-qname">QName</termref>. This name, if specified, may be used while evaluating the
                  <elcode>xsl:merge-action</elcode> to identify from which source a particular item
               was read. For details, see <specref ref="selective-processing-of-merge-inputs"/></p>

            <p diff="add" at="E">
               <error spec="XT" type="static" class="SE" code="2185">
                  <p>It is a <termref def="dt-static-error">static error</termref> if two sibling
                        <elcode>xsl:merge-source</elcode> elements have <code>name</code> attributes
                     whose value is the same expanded QName.</p>
               </error>
            </p>

            

         </div2>
         <div2 id="merge-keys">
            <head>Defining the merge keys</head>

            <p>All the input sequences to the merge operation must be already sorted: the sorting
               will not be performed by the merge operation. The keys on which the input sequences
               are sorted are referred to as merge keys.</p>

            <p>The merge key for each type of input sequence (that is, for each
                  <elcode>xsl:merge-source</elcode> element) is defined by a sequence of
                  <elcode>xsl:merge-key</elcode> element children of the
                  <elcode>xsl:merge-input</elcode> element. Each <elcode>xsl:merge-key</elcode>
               element defines one merge key component. The syntax and semantics of an
                  <elcode>xsl:merge-key</elcode> element are closely based on the rules for the
                  <elcode>xsl:sort</elcode> element (the only exception being the absence of the
                  <code>stable</code> attribute); the difference is that
                  <elcode>xsl:merge-key</elcode> elements do not cause a sort to take place, they
               merely declare the existing sort order of the input sequence.</p>

            <e:element-syntax name="merge-key">
               <e:attribute name="select">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="lang">
                  <e:attribute-value-template>
                     <e:data-type name="nmtoken"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="order">
                  <e:attribute-value-template>
                     <e:constant value="ascending"/>
                     <e:constant value="descending"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="collation">
                  <e:attribute-value-template>
                     <e:data-type name="uri"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="case-order">
                  <e:attribute-value-template>
                     <e:constant value="upper-first"/>
                     <e:constant value="lower-first"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="data-type">
                  <e:attribute-value-template>
                     <e:constant value="text"/>
                     <e:constant value="number"/>
                     <e:data-type name="qname-but-not-ncname"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent name="merge-input"/>
               </e:allowed-parents>
            </e:element-syntax>

            <p>The <code>select</code> attrbute and the contained <termref def="dt-sequence-constructor">sequence constructor</termref> are mutually
               exclusive:</p>

            <p>
               <error spec="XT" type="static" class="SE" code="2190">
                  <p>It is a <termref def="dt-static-error">static error</termref> if an
                        <elcode>xsl:merge-key</elcode> element with a <code>select</code> attribute
                     has non-empty content.</p>
               </error>
            </p>

            <p>The effect of the <elcode>xsl:merge-key</elcode> elements is defined in terms of the
               rules for an equivalent sequence of <elcode>xsl:sort</elcode> elements: if the rules
               for sorting (see <specref ref="sorting-process"/>) with <code>stable="yes"</code>
               would place an item <var>A</var> before an item <var>B</var> in the <termref def="dt-sorted-sequence">sorted sequence</termref> produced by the sorting
               process, then <var>A</var> must precede <var>B</var> in the input sequence to the
               merging process.</p>

            <p>The merge keys of the various input sequences to a merge operation must be compatible
               with each other, since the merge operation will decide the ordering of the result
               sequence by comparing merge key values across input sequences. This means that across
               all the <elcode>xsl:merge-source</elcode> children of an <elcode>xsl:merge</elcode>
               instruction:</p>

            <ulist>
               <item>
                  <p>Each <elcode>xsl:merge-source</elcode> element <rfc2119>must</rfc2119> have the
                     same number of <elcode>xsl:merge-key</elcode> grandchild elements; let this
                     number be <var>N</var></p>
               </item>
               <item>
                  <p>For each integer <var>J</var> in 1..<var>N</var>, consider the set of
                        <elcode>xsl:merge-key</elcode> elements that are in position <var>J</var>
                     among the <elcode>xsl:merge-key</elcode> children of their parent
                        <elcode>xsl:merge-input</elcode> element. All the
                        <elcode>xsl:merge-key</elcode> elements in this set <rfc2119>must</rfc2119>
                     have the same <termref def="dt-effective-value">effective value</termref> for
                     their <code>lang</code>, <code>order</code>, <code>collation</code>,
                        <code>case-order</code>, and <code>data-type</code> attributes, where having
                     the same effective value in this case means that either both attributes must be
                     absent, or both must be present and evaluate to the same value; and in addition
                     in the case of <code>collation</code> the absolute URI must be the same after
                     resolving against the base URI. </p>
               </item>
            </ulist>

            <p>If any of the attributes <code>lang</code>, <code>order</code>,
                  <code>collation</code>, <code>case-order</code>, or <code>data-type</code> are
                  <termref def="dt-attribute-value-template">attribute value templates</termref>,
               then their <termref def="dt-effective-value">effective values</termref> are evaluated
               using the <termref def="dt-focus">focus</termref> of the containing
                  <elcode>xsl:merge</elcode> instruction.</p>



            <p>
               <error spec="XT" type="static" class="SE" code="2200">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the number of
                        <elcode>xsl:merge-key</elcode> grandchildren of a
                        <elcode>xsl:merge-source</elcode> element is not equal to the number of
                        <elcode>xsl:merge-key</elcode> grandchildren of another
                        <elcode>xsl:merge-source</elcode> child of the same
                        <elcode>xsl:merge</elcode> instruction.</p>
               </error>
            </p>
            <p>
               <error spec="XT" type="static" class="SE" code="2210">
                  <p>It is a <termref def="dt-static-error">static error</termref> if there are two
                        <elcode>xsl:merge-key</elcode> grandchildren of an
                        <elcode>xsl:merge</elcode> instruction that occupy corresponding positions
                     among the <elcode>xsl:merge-key</elcode> children of two different
                        <elcode>xsl:merge-input</elcode> elements and that have differing <termref def="dt-effective-value">effective values</termref> for any of the
                     attributes <code>lang</code>, <code>order</code>, <code>collation</code>,
                        <code>case-order</code>, or <code>data-type</code>. Values are considered to differ
                     if the attribute is present on one element and not on the other, or if
                     it is present on both elements with <termref def="dt-effective-value">effective
                        values</termref> that are not equal to each other. In the case of the
                        <code>collation</code> attribute, the values are compared as absolute URIs
                        after resolving against the base URI.</p>
               </error>
            </p>
            <p>
               <error spec="XT" type="static" class="DE" code="2220">
                  <p>It is a <termref def="dt-dynamic-error">dynamic error</termref> if any input
                     sequence to an <elcode>xsl:merge</elcode> instruction contains two items that
                     are not correctly sorted according to the merge key values defined on the
                        <elcode>xsl:merge-key</elcode> children of the corresponding
                        <elcode>xsl:merge-input</elcode> element, when compared using the collation
                     rules defined by the attributes of the corresponding
                        <elcode>xsl:merge-key</elcode> children of the <elcode>xsl:merge</elcode>
                     instruction.</p>
               </error>
            </p>
            <p>
               <error spec="XT" type="static" class="TE" code="2230">
                  <p>It is a <termref def="dt-type-error">type error</termref> if some item selected
                     by a particular merge key in one input sequence is not comparable using the
                     XPath <code>le</code> operator with some item selected by the corresponding
                     sort key in another input sequence.</p>
               </error>
            </p>

         </div2>
         <div2 id="merge-action">
            <head>The <elcode>xsl:merge-action</elcode> element</head>
            <p>The <elcode>xsl:merge-action</elcode> child of an <elcode>xsl:merge</elcode>
               instruction defines the processing to be applied for each distinct set of merge key
               values found in the input sequences to the <elcode>xsl:merge</elcode>
               instruction.</p>
            <e:element-syntax name="merge-action">
               <e:sequence>
                  <e:model name="sequence-constructor"/>
               </e:sequence>
               <e:allowed-parents>
                  <e:parent name="merge"/>
               </e:allowed-parents>
            </e:element-syntax>

            <p>The merge key values for each item in an input sequence are calculated based on the
               corresponding <elcode>xsl:merge-key</elcode> elements, in the same way as <termref def="dt-sort-key-value">sort key values</termref> are calculated using a sequence
               of <elcode>xsl:sort</elcode> elements (see <specref ref="sorting-process"/>). If
               several items from the same or from different input sequences have the same values
               for all their merge keys (comparing pairwise), then they are considered to form a
               group. The sequence constructor contained in the <elcode>xsl:merge-action</elcode>
               element is evaluated once for each such group of items, and the result of the
                  <elcode>xsl:merge</elcode> instruction is the concatenation of the results
               obtained by processing each group in turn.</p>

            <p><phrase diff="chg" at="F">The groups are processed one by one, based on the values of the merge keys for
               the group.</phrase> If group <var>G</var> has a set of merge key values <var>M</var>,
               while group <var>H</var> has a set of merge key values <var>N</var>, then in the
               result of the <elcode>xsl:merge</elcode> instruction, the result of processing group
                  <var>G</var> will precede the result of processing <var>H</var> if and only if
                  <var>M</var> precedes <var>N</var> in the sort order defined by the
                  <code>lang</code>, <code>order</code>, <code>collation</code>,
                  <code>case-order</code>, and <code>data-type</code> attributes of the merge key
               definitions.</p>

            <p>Generally, two sets of sort key values are distinct if any corresponding items in the
               two sets of values do not compare equal under the rules for the XPath <code>eq</code>
               operator, under the collating rules for the corresponding merge key definition. In
               rare cases, when considering more than two sets of sort key values, ambiguities may
               arise because of the non-transitivity of the <code>eq</code> operator when applied
               across different numeric types. In this situation, the partitioning of items into
               sets having distinct key values is handled in the same way as for
                  <elcode>xsl:for-each-group</elcode> (see <specref ref="non-transitivity"/>), and
               is to some extent <termref def="dt-implementation-dependent">implementation-dependent</termref>. </p>

            <p>While evaluating the sequence constructor contained within the
                  <elcode>xsl:merge-action</elcode> element, the expression
                  <code>current-grouping-key()[N]</code> returns the value of the <var>Nth</var>
               merge key. There may be several input items having merge keys that are equal but
               distinguishable (for example the number 1.0 as a float and as a double, or the strings "A"
               and "a" under a case-blind collation); in this case the result of the
                  <function>current-grouping-key</function> is the value of the grouping key
               computed for the first item in the current group, after atomization and casting of
                  <code>xs:untypedAtomic</code> to <code>xs:string</code>.</p>

            <p>While evaluating the sequence constructor contained within the
                  <elcode>xsl:merge-action</elcode> element, the function
                  <code>current-group()</code> (with no arguments) returns the set of items (zero or
               more from each input sequence) that have this set of values as their merge key value.
               It is possible to distinguish which items came from which merge source: see <specref ref="selective-processing-of-merge-inputs"/>.</p>

            <p>Within the result of the <function>current-group</function> function, the ordering of
               items from the input sequences is as follows, in major-to-minor order:</p>

            <ulist>
               <item>
                  <p>Items are first ordered by the <elcode>xsl:merge-source</elcode> element that
                     defined the input sequence from which the item was taken; items from
                        <elcode>xsl:merge-source</elcode>
                     <var>A</var> precede items from <elcode>xsl:merge-source</elcode>
                     <var>B</var> if <var>A</var> precedes <var>B</var> in document order within the
                     stylesheet.</p>
               </item>
               <item>
                  <p>Items from different input sequences selected by the same
                        <elcode>xsl:merge-source</elcode> element are then ordered based on the
                     order of the anchor items in the sequence selected by evaluating the
                        <code>select</code> attribute of the <elcode>xsl:merge-source</elcode>
                     element.</p>
               </item>
               <item>
                  <p>Finally, duplicate items from the same input sequence retain their order from
                     the input sequence.</p>
               </item>
            </ulist>

            <p>The <termref def="dt-focus">focus</termref> for evaluation of the sequence
               constructor contained in the <elcode>xsl:merge-source</elcode> element is as
               follows:</p>

            <ulist>
               <item>
                  <p>The <termref def="dt-context-item">context item</termref> is the first item in
                     the current group, that is <code>current-group()[1]</code></p>
               </item>
               <item>
                  <p>The <termref def="dt-context-position">context position</termref> is the
                     position of the current group within the sequence of groups (so the first
                     evaluation of <elcode>xsl:merge-action</elcode> has <code>position()=1</code>,
                     the second has <code>position()=2</code>, and so on).</p>
               </item>
               <item>
                  <p>The <termref def="dt-context-size">context size</termref> is the number of
                     groups, that is, the number of distinct sets of merge key values.</p>
               </item>
            </ulist>



         </div2>
         <div2 id="selective-processing-of-merge-inputs" diff="add" at="E">
            <head>Selective processing of merge inputs</head>
            <p>During the processing of <elcode>xsl:merge-action</elcode>, there will in general be
               one or more items with the same values for their merge keys, together forming the
               current group. Within the current group, each item originates from one merge input,
               which in turn is associated with one merge source. A merge source may be identified
               by a QName (the value of the <code>name</code> attribute on the
                  <elcode>xsl:merge-source</elcode> element). For each merge source, there are zero
               or more merge inputs, which are identified by positive integers representing the
               position of the anchor item for the merge input within the sequence of anchor items
               selected by the <code>select</code> attribute of the
                  <elcode>xsl:merge-source</elcode> element. Since duplicate merge keys are allowed
               within a single input, each merge input contributes zero or more items to the current
               group.</p>

            <p>The function <function>current-merge-inputs</function> may be used to obtain the
               items within the current group that are associated with each named merge source, and
               with each merge input within that source. The function takes as input the name of the
               merge source (as a lexical QName, expanded using the in-scope namespaces from the
               static context), and it returns a sequence of accessors, one accessor for each merge
               input within the merge source, corresponding one-to-one with the sequence of anchor
               items selected by the <code>select</code> attribute of the
                  <elcode>xsl:merge-source</elcode> element. Each accessor is a zero-argument
               anonymous function which when invoked returns the sequence of zero or more items
               (each a member of the current group) that derive from the corresponding merge
               input.</p>

            <example>
               <head>Selective processing of merge inputs</head>
               <p>Consider a situation where there are two merge sources, named "master" and
                  "update"; the master source identifies a single merge input file (the master
                  file), while the update source identifies a set of <var>N</var> update files, perhaps one for
                  each day of the week. The required logic is that if a merge key is present only in
                  the master file, then the corresponding item should be copied to the output; if it
                  is present in a single update file then that item replaces the corresponding item
                  from the master file; if it is present in several update files, then an error is
                  raised. This can be achieved as follows:</p>
               <eg xml:space="preserve">&lt;xsl:merge&gt;
  &lt;xsl:merge-source name="master" select="doc('master.xml')"&gt;
    &lt;xsl:merge-input select="/*/*"&gt;
      &lt;xsl:merge-key select="@key"/&gt;
    &lt;/xsl:merge-input&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-source name="update" select="collection('updates')"&gt;
    &lt;xsl:merge-input select="/*/*"&gt;
      &lt;xsl:merge-key select="@affected-key"/&gt;
    &lt;/xsl:merge-input&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:variable name="update-accessors" 
                  select="current-merge-inputs('update')"
                  as="(function() as item()*)*"/&gt;
    &lt;xsl:variable name="number-of-updates" 
                  select="count($update-accessors[exists(.())])"
                  as="xs:integer"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="$number-of-updates = 0"&gt;
        &lt;xsl:copy-of select="current-merge-inputs('master')()"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="$number-of-updates = 1"&gt;
        &lt;xsl:copy-of select="for $a in $update-accessors return $a()"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:message&gt;
           Multiple updates for the same master record!
        &lt;/xsl:message&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:merge-action&gt;
&lt;/xsl:merge&gt;
            </eg>
               <p>Some words of explanation:</p>
               <ulist>
                  <item>
                     <p>The variable <code>$number-of-updates</code> is computed as the number of
                        accessors for the update source, filtered to select only those for which the
                        accessor returns a non-empty sequence. The expression <code>.()</code>
                        invokes the accessor that is the current item.</p>
                  </item>
                  <item>
                     <p>The expression <code>current-merge-inputs('master')</code> obtains a
                        sequence of accessors for all the merge inputs associated with the master
                        source. There is only one, so it returns a single accessor, which is invoked
                        directly (using <code>()</code>) to obtain the item in the master file.</p>
                  </item>
                  <item>
                     <p>The expression <code>for $a in $update-accessors return $a()</code> invokes
                        all the accessors associated with the update source, and concatenates their
                        results; although all but one of the accessors will return an empty
                        sequence, this is <phrase diff="chg" at="F">a convenient way of 
                        obtaining the one sequence that is non-empty.</phrase></p>
                  </item>
               </ulist>
            </example>
            <p>The function <function>current-merge-inputs</function> is defined as follows:</p>

            <proto class="xslt" name="current-merge-inputs" return-type="(function() as item()*)">
               <arg name="source-name" type="xs:string"/>
            </proto>

            <p>The function takes as input the name of a merge source, expressed as a <termref def="dt-lexical-qname">lexical QName</termref></p>

            <p>
               <error spec="XT" type="dynamic" class="DE" code="2240">
                  <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the value <error.extra>of the first argument to the
                           <function>current-merge-inputs</function> function</error.extra> is not a
                     valid QName, or if there is no namespace declaration in scope for the prefix of
                     the QName, or if the name obtained by expanding the QName is not the same as
                     the expanded name of any <elcode>xsl:merge-source</elcode> element in the
                     <termref def="dt-current-merge-activation"/>, <phrase diff="add" at="F">or if there is no
                     <termref def="dt-current-merge-activation"/></phrase>. If the processor is able to
                     detect the error statically (for example, when the argument is supplied as a
                     string literal), then the processor <rfc2119>may</rfc2119> optionally signal
                     this as a <termref def="dt-static-error">static error</termref>.</p>
               </error>
            </p>
            
            <p diff="chg" at="F"><termdef id="dt-current-merge-activation" term="current merge activation">During each
            evaluation of the <termref def="dt-sequence-constructor"/> contained in an
            <elcode>xsl:merge-action</elcode> element, there is a <term>current merge activation</term>.</termdef></p>
            
            <p diff="chg" at="F">The <termref def="dt-current-merge-activation"/> has the following properties:</p>
            
            <ulist diff="chg" at="F">
               <item><p>The <elcode>xsl:merge</elcode> element <var>M</var> that is the parent of the 
               <elcode>xsl:merge-action</elcode> element being evaluated</p></item>
               <item><p>A mapping <var>SA</var> from each 
                  <elcode>xsl:merge-source</elcode> child of <var>M</var> 
                  to the sequence of anchor items selected by
                  evaluating the (implicit or explicit) <code>select</code> expression on that
                  <elcode>xsl:merge-source</elcode> element</p></item>
               <item><p>A current <termref def="dt-composite-merge-key-value"/></p></item>
               <item><p/></item>
            </ulist>

            <issue id="issue-current-merge-activation" status="open">
               <p>The concept of the <term>current-merge-activation</term> needs to be 
                  and incorporated into the dynamic context.</p>
            </issue>
            
            <p diff="chg" at="F">For each anchor item <var>A</var> in the mapping <var>SA</var>, there is an
               associated <termref def="dt-merge-input-sequence"/> obtained by evaluating the
               <code>select</code> expression of the <elcode>xsl:merge-input</elcode>
               child of the corresponding <elcode>xsl:merge-source</elcode> element with 
               <var>A</var> as the context item.</p> 
               
            <p diff="chg" at="F">The <function>current-merge-inputs</function> function returns 
               a sequence of function items, referred to as accessors. Each
               accessor is an anonymous function with an arity of zero.
               The sequence of accessors corresponds one-to-one with the sequence of
               anchor items defined by the mapping <var>SA</var> 
               for the selected <elcode>xsl:merge-source</elcode> in the 
               <termref def="dt-current-merge-activation"/>.                           
               Invoking the <var>N</var>th accessor function returns selected items from 
               the <termref def="dt-merge-input-sequence"/> associated with the <var>N</var>th
               anchor item in this sequence. The selected items are those whose
               whose <termref def="dt-composite-merge-key-value"/> is equal to the 
               composite merge key value of the <termref def="dt-current-merge-activation"/>.
               The selected items are returned retaining their order from the
               <termref def="dt-merge-input-sequence"/>.</p>
               


         </div2>
         <div2 id="merging-streamed-inputs">
            <head>Merging streamed input documents</head>
            <p>An important reason for introducing the <elcode>xsl:merge</elcode> instruction is to
               allow elements from several input documents to be merged without constructing the
               entire tree representation of the input documents in memory. This can be achieved by
               using <elcode>xsl:merge</elcode> in conjunction with the <elcode>xsl:stream</elcode>
               instruction defined in <specref ref="streaming"/>.</p>

            <example>
               <head>Merging two streamed documents with different structure</head>
               <p>The following code merges two log files having different internal structure:</p>

               <eg xml:space="preserve">
&lt;xsl:merge&gt;
  &lt;xsl:merge-source&gt;
    &lt;xsl:merge-input&gt;
      &lt;xsl:merge-key select="@timestamp"/&gt;
      &lt;xsl:stream href="event-log.xml"&gt;
        &lt;xsl:copy-of select="*/event"/&gt;
      &lt;/xsl:stream&gt;
    &lt;/xsl:merge-input&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-source&gt;
    &lt;xsl:merge-input&gt;
      &lt;xsl:merge-key select="dateTime(@date, @time)"/&gt;
      &lt;xsl:stream href="error-log.xml"&gt;
        &lt;xsl:copy-of select="*/event"/&gt;
      &lt;/xsl:stream&gt;
    &lt;/xsl:merge-input&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:sequence select="current-group()"/&gt;
  &lt;/xsl:merge-action&gt;
&lt;/xsl:merge&gt;</eg>

               <p>Within the <elcode>xsl:stream</elcode> instructions, it is necessary to use
                     <elcode>xsl:copy-of</elcode> rather than <elcode>xsl:sequence</elcode> because
                  the <elcode>xsl:stream</elcode> instruction is not allowed to return streamed
                  nodes. An intelligent optimizer might be able to use streaming to execute this code, 
                  avoiding the need to copy the <code>event</code> elements to
                  temporary trees held in memory.</p>
            </example>

            <example>
               <head>Merging a collection of streamed documents</head>
               <p>The following code merges the top-level elements (that is, the children of the
                  outermost element) of a collection of input documents into a single result
                  document. </p>

               <eg xml:space="preserve">
&lt;xsl:merge&gt;
  &lt;xsl:merge-source select="uri-collection('log-collection')"&gt;
    &lt;xsl:merge-input&gt;
      &lt;xsl:merge-key select="@timestamp" order="ascending"/&gt;
      &lt;xsl:stream href="{.}"&gt;
        &lt;xsl:copy-of select="events/event"/&gt;
      &lt;/xsl:stream&gt;
    &lt;/xsl:merge-input&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:sequence select="current-group()"/&gt;
  &lt;/xsl:merge-action&gt;
&lt;/xsl:merge&gt;</eg>
               <p>In this example the <function>uri-collection</function> function is used to
                  retrieve the document URIs of the documents in a collection, without retrieving
                  the <phrase diff="chg" at="F">documents themselves</phrase>. These URIs are used as the anchor items of the
                     <elcode>xsl:merge-source</elcode>, and the individual input sequences are
                  selected from these URIs by using the <elcode>xsl:stream</elcode> instruction. As
                  with the previous example, an intelligent optimizer might avoid building each
                     <code>event</code> element as a tree in memory.</p>
            </example>


         </div2>
         <div2 id="merge-examples">
            <head>Examples of xsl:merge</head>
            <p>Previous sections introduced examples designed to illustrate some specific features
               of the <elcode>xsl:merge</elcode> instruction. This section provides some further
               examples to illustrate different ways in which the instruction can be used.</p>


            <example>
               <head>Applying transactions to a master file</head>
               <p>This example applies transactions from a transaction file to a master file.
                  Records in the master file for which there is no corresponding transaction are
                  copied unchanged. The transaction file contains instructions to delete, replace,
                  or insert records identified by an ID value. The master file is known to be sorted
                  on the ID value; the transaction file is unsorted.</p>
               <p>Master file document structure:</p>
               <eg xml:space="preserve">&lt;data&gt;
  &lt;record ID="A0001"&gt;&lt;...&gt;&lt;/record&gt;
  &lt;record ID="A0002"&gt;&lt;...&gt;&lt;/record&gt;
  &lt;record ID="A0003"&gt;&lt;...&gt;&lt;/record&gt;
&lt;/data&gt;</eg>
               <p>Transaction file document structure:</p>
               <eg xml:space="preserve">&lt;transactions&gt;
  &lt;update record="A0004" action="insert"&gt;&lt;...&gt;&lt;/update&gt;
  &lt;update record="A0002" action="delete"/&gt;
  &lt;update record="A0003" action="replace"&gt;&lt;...&gt;&lt;/update&gt;
&lt;/transactions&gt;</eg>
               <p>Solution:</p>
               <eg xml:space="preserve">&lt;xsl:merge&gt;
  &lt;xsl:merge-source select="doc('master.xml')" name="master"&gt;
    &lt;xsl:merge-input select="data/record"&gt;
      &lt;xsl:merge-key select="@ID"/&gt;
    &lt;/xsl:merge-input&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-source name="updates"&gt;
    &lt;xsl:merge-input&gt;      
      &lt;xsl:perform-sort select="
              doc('transactions.xml')/transactions/update"&gt;
        &lt;xsl:sort select="@record" order="ascending"/&gt;
      &lt;/xsl:perform-sort&gt;
      &lt;xsl:merge-key select="@record"/&gt;
    &lt;/xsl:merge-input&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:variable name="master" select="current-group('master')"/&gt;
    &lt;xsl:variable name="update" select="current-group('updates')"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="empty($update)"&gt;
        &lt;xsl:copy-of select="$master"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="$update/@action=('insert', 'replace')"&gt;
        &lt;record ID="{current-grouping-key()}"&gt;
          &lt;xsl:copy-of select="$update/*"/&gt;
        &lt;/record&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="$update/@action='delete'"/&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:merge-action&gt;
  &lt;/xsl:merge&gt;</eg>

               <p diff="chg" at="F">If there are multiple transaction files, represented say by the contents of a collection named
               <code>transaction-files.collection</code>, they can be handled by replacing the second
               <elcode>xsl:merge-source</elcode> in the above example with the following code:</p>
               <eg diff="add" at="F" xml:space="preserve">  &lt;xsl:merge-source name="updates" 
         select="collection('transaction-files.collection')"&gt;
    &lt;xsl:merge-input&gt;
      &lt;xsl:perform-sort select="/transactions/update"&gt;
        &lt;xsl:sort select="@record" order="ascending"/&gt;
      &lt;/xsl:perform-sort&gt;
      &lt;xsl:merge-key select="@record"/&gt;
    &lt;/xsl:merge-input&gt;
  &lt;/xsl:merge-source&gt;</eg>


            </example>
            <example>
               <head>Merging two sequences of numbers</head>
               <p>The <elcode>xsl:merge</elcode> instruction can be used to determine the union,
                  intersection, or difference of two sequences of numbers (or other atomic values).
                  This code gives the union:</p>
               <eg xml:space="preserve">&lt;xsl:merge&gt;
  &lt;xsl:merge-source&gt;                  
    &lt;xsl:merge-input select="1 to 30"&gt;
      &lt;xsl:merge-key select="."/&gt;
    &lt;/xsl:merge-input&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-source&gt;                  
    &lt;xsl:merge-input select="20 to 40"&gt;
      &lt;xsl:merge-key select="."/&gt;
    &lt;/xsl:merge-input&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:value-of select="current-grouping-key()"/&gt;
  &lt;/xsl:merge-action&gt;
&lt;/xsl:merge&gt;
               </eg>
               <p>While this gives the intersection:</p>
               <eg xml:space="preserve">&lt;xsl:merge&gt;
  &lt;xsl:merge-source&gt;                  
    &lt;xsl:merge-input select="1 to 30"&gt;
      &lt;xsl:merge-key select="."/&gt;
    &lt;/xsl:merge-input&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-source&gt;                  
    &lt;xsl:merge-input select="20 to 40"&gt;
      &lt;xsl:merge-key select="."/&gt;
    &lt;/xsl:merge-input&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:if test="count(current-group()) eq 2"
      &lt;xsl:value-of select="current-grouping-key()"/&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:merge-action&gt;
&lt;/xsl:merge&gt;
               </eg>
            </example>
         </div2>
      </div1>
      <div1 id="splitting" diff="add" at="B">
         <head>Splitting</head>

         <div2 id="splitting-introduction">
            <head>Introduction</head>

            <p>Sometimes it is convenient to be able to compute multiple results during a single
               scan of the input data. For example, a transformation may wish to rename selected
               elements, and also to output a count of how many elements have been renamed.
               Traditionally in a functional language this means computing two separate functions of
               the input sequence, which (in the absence of sophisticated optimization) will result
               in the input being scanned twice. This is inconsistent with streaming, where the
               input is only available to be scanned once, and it can also lead to poor performance
               in non-streaming applications.</p>

            <p>To meet this requirement, XSLT 2.1 introduces the instruction
                  <elcode>xsl:fork</elcode>. The content of this instruction is a <termref def="dt-sequence-constructor">sequence constructor</termref>, and in a formal
               sense the effect of the instruction is simply to return the result of evaluating the
               sequence constructor. However, the presence of the instruction affects the analysis
               of streamability (see <specref ref="streamability"/>). In particular, when
                  <elcode>xsl:fork</elcode> is used in a context where streaming is required, each
               independent instruction within the sequence constructor must be streamable, but the
               analysis assumes that these instructions can all be evaluated during a single pass of
               the streamed input document.</p>

            <note>
               <p>The semantics of the instruction require a number of result sequences to be
                  computed during a single pass of the input. A processor <rfc2119>may</rfc2119>
                  interpret this as a request to use multiple threads. However, implementations
                  using a single thread are feasible, and this instruction is not intended primarily
                  as a means for stylesheet authors to express their intentions with regard to
                  multi-threaded execution.</p>
            </note>

            <note>
               <p>Because multiple results are computed during a single pass of the input, and then
                  concatenated into a single sequence, this instruction will generally involve some
                  buffering of results. The amount of memory used <rfc2119>should not</rfc2119>
                  exceed that needed to hold the results of the instruction. However, within this
                  principle, implementations may adopt a variety of strategies for evaluation; for
                  example, there may be cases where buffering of the input is more efficient than
                  buffering of output.</p>
               <p>Generally, stylesheet authors indicate that buffering of input is the preferred
                  strategy by using the <function>copy-of</function> or <function>snapshot</function>
                  functions, and indicate that buffering of output is preferred by using
                     <elcode>xsl:fork</elcode>. However, conformant processors are not constrained
                  in their choice of evaluation strategies.</p>
            </note>



            <example>
               <head>Splitting a transaction file</head>
               <p>Consider a transaction file that contains a sequence of debits and credits:</p>
               <eg xml:space="preserve">&lt;transactions&gt;
  &lt;transaction value="5.60"/&gt;
  &lt;transaction value="11.20"/&gt;
  &lt;transaction value="-3.40"/&gt;
  &lt;transaction value="8.90"/&gt;
  &lt;transaction value="-1.99"/&gt;
&lt;/transactions&gt;</eg>
               <p>where the requirement is to split this into two separate files containing credits
                  and debits respectively.</p>
               <p>This can be achieved in <termref def="dt-guaranteed-streamable"/> code as follows:</p>
               <eg xml:space="preserve">
&lt;xsl:stream href="transactions.xml"&gt;
  &lt;xsl:fork&gt;
    &lt;xsl:result-document name="credits.xml"&gt;
      &lt;credits&gt;
        &lt;xsl:copy-of select="transactions/transaction[@value ge 0]"/&gt;
      &lt;/credits&gt;
    &lt;/xsl:result-document&gt;
    &lt;xsl:result-document name="debits.xml"&gt;
      &lt;debits&gt;
        &lt;xsl:copy-of select="transactions/transaction[@value lt 0]"/&gt;
      &lt;/debits&gt;
    &lt;/xsl:result-document&gt;
  &lt;/xsl:fork&gt;
&lt;/xsl:stream&gt;
            </eg>
               <p>In the absence of the <elcode>xsl:fork</elcode> instruction, this would not be
                  streamable, because the construct includes two downwards selections in the input
                  document (represented by the path expressions
                     <code>transactions/transaction[@value ge 0]</code> and
                     <code>transactions/transaction[@value lt 0]</code>). With the addition of the
                     <elcode>xsl:fork</elcode> instruction, however, each
                     <elcode>xsl:result-document</elcode> instruction is allowed to make a downwards
                  selection. </p>
               <p>One possible implementation model for this is as follows: a single thread reads
                  the source document, and sends parsing events such as start-element and
                  end-element to two other threads, each of which is writing one of the two result
                  documents. Each of these implements the downwards-selecting path expression using
                  a process that waits until the next <code>transaction</code> start-element event
                  is received; when this event is received, the process examines the
                     <code>@value</code> attribute to determine whether or not this transaction is
                  to be copied; if it is, then all events until the matching
                     <code>transaction</code> end-element event are copied to the serializer for the
                  result document; otherwise, these events are discarded.</p>
            </example>

            <p diff="add" at="E">The <elcode>xsl:sequence</elcode> instruction may be used as a
               child of <elcode>xsl:fork</elcode> to break the instructions within
                  <elcode>xsl:fork</elcode> into a number of separate groups, each of which is
               considered as (and indeed is) a separate instruction operating in a single pass over
               the data.</p>

            <p>The following section describes the <elcode>xsl:fork</elcode> instruction more
               formally.</p>

         </div2>

         <div2 id="fork-instruction">
            <head>The <code>xsl:fork</code> instruction</head>
            <e:element-syntax name="fork">
               <e:in-category name="instruction"/>
               <e:sequence>
                  <e:model name="sequence-constructor"/>
               </e:sequence>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>


            <p>The result of the <elcode>xsl:fork</elcode> instruction is the result of evaluating
               its contained <termref def="dt-sequence-constructor">sequence
               constructor</termref>.</p>

            <p><termdef id="dt-dependent-instruction" term="dependent (instruction)">Among the
                     <termref def="dt-instruction">instructions</termref> directly contained in a
                     <termref def="dt-sequence-constructor">sequence constructor</termref>, an
                  instruction <var>I</var> is defined to be <term>dependent</term> on an instruction
                     <var>J</var> if <var>J</var> is a <termref def="dt-variable-binding-element">variable binding</termref> and <var>I</var> contains a reference to that
                  variable, or if there is an instruction <var>K</var> such that <var>I</var>
                  depends on <var>K</var> and <var>K</var> depends on <var>J</var>.</termdef></p>
            <p><termdef id="dt-independent-instruction" term="independent (instruction)">Two
                     <termref def="dt-instruction">instructions</termref> with a <termref def="dt-sequence-constructor">sequence constructor</termref> are defined to be
                     <term>independent</term> if neither <termref def="dt-dependent-instruction">depends</termref> on the other.</termdef></p>
            <p>By using the <elcode>xsl:fork</elcode> instruction, the stylesheet author is
               suggesting to the <termref def="dt-processor">processor</termref> that it would be
               beneficial to evaluate <termref def="dt-independent-instruction">independent
                  instructions</termref> during a single pass of a streamed input document. The
               processor is not <rfc2119>required</rfc2119> to take any notice of this
               suggestion.</p>
            <p>The presence of an <elcode>xsl:fork</elcode> instruction affects the analysis of
               streamability, as described in <specref ref="streamability"/>.</p>





         </div2>


         <div2 id="splitting-examples">
            <head>Examples of splitting with streamed data</head>
            <p>This section gives examples of how splitting using <elcode>xsl:fork</elcode> can be
               used to enable streaming of input documents in cases where several results
               need to be computed during a single pass over the input data.</p>
            <example>
               <head>Deleting elements, and counting deletions</head>
               <p>In this example the input is a narrative document containing <code>note</code>
                  elements at any level of nesting. The requirement is to output a copy of the input
                  document in which (a) the <code>note</code> elements have been removed, and (b) a
                     <code>footnote</code> is added at the end indicating how many <code>note</code>
                  elements have been deleted.</p>
               <eg xml:space="preserve">&lt;xsl:mode on-no-match="copy" streamable="yes"/&gt;

&lt;xsl:template match="note"/&gt;

&lt;xsl:template match="/*"&gt;
  &lt;xsl:fork&gt;
    &lt;xsl:apply-templates/&gt;
    &lt;footnote&gt;
      &lt;p&gt;Removed &lt;xsl:value-of select="count(.//note)"/&gt; 
                 note elements.&lt;/p&gt;
    &lt;/footnote&gt;
  &lt;/xsl:fork&gt;
&lt;/xsl:template&gt;
               </eg>
               <p>The <elcode>xsl:fork</elcode> instruction contains two independent instructions in
                  its sequence constructor. These can therefore be evaluated in the same pass over
                  the input data. The first instruction (the <elcode>xsl:apply-templates</elcode>
                  instruction) causes everything except the <code>note</code> elements to be copied
                  to the result; the second instruction (the literal result element
                     <code>footnote</code>) outputs a count of the number of descendant
                     <code>note</code> elements.</p>
               <p>Note that although the processing makes a single pass over the input stream, there
                  is some buffering of results required, because the results of the instructions
                  within the <elcode>xsl:fork</elcode> instruction need to be concatenated. In this
                  case an intelligent implementation might be able to restrict the buffered data to
                  a single integer.</p>
               <p>In a formal sense, however, the result is exactly the same as if the
                     <elcode>xsl:fork</elcode> element were not there.</p>
            </example>
            <example>
               <head>Statistical analysis of a document</head>
               <p>This example computes the proportion of the words in a document that are contained
                  in headings and in footnotes. It does this in a single streaming pass of the input
                  document.</p>
               <eg xml:space="preserve">&lt;xsl:template match="doc"&gt;
  &lt;xsl:fork&gt;
    &lt;xsl:variable name="wordCount" 
            select="count(.//text()/tokenize(., '\s+'))"/&gt;
    &lt;xsl:variable name="footnoteWordCount" 
            select="count(.//footnote/text()/tokenize(., '\s+'))"/&gt;
    &lt;xsl:variable name="headingWordCount" 
            select="count(.//heading/text()/tokenize(., '\s+'))"/&gt;
    &lt;result metric="proportion of words in footnotes" 
            value="{$footnoteWordCount div $wordCount}"/&gt;
    &lt;result metric="proportion of words in headings" 
            value="{$headingWordCount div $wordCount}"/&gt;
  &lt;/xsl:fork&gt;
&lt;/xsl:template&gt;</eg>
               <p>In this example, there are five instructions within the <elcode>xsl:fork</elcode>
                  instruction. The three variable bindings are independent of each other, and can
                  therefore be evaluated in a single pass through the streamed input document. The
                  two literal result elements cannot be evaluated until the values of the relevant
                  variables are available; but they do not access the source document, and therefore
                  do not place any constraints on streamability.</p>
            </example>


         </div2>


      </div1>
      <div1 id="regular-expressions">
         <head>Regular Expressions</head>
         <p>The <termref def="dt-core-function">core function</termref> library for XPath 2.1
            defines three <phrase diff="add" at="D">basic</phrase> functions that make use of
            regular expressions:</p>
         <ulist>
            <item>
               <p>
                  <xfunction>matches</xfunction> returns a boolean result that indicates whether or
                  not a string matches a given regular expression.</p>
            </item>
            <item>
               <p>
                  <xfunction>replace</xfunction> takes a string as input and returns a string
                  obtained by replacing all substrings that match a given regular expression with a
                  replacement string.</p>
            </item>
            <item>
               <p>
                  <xfunction>tokenize</xfunction> returns a sequence of strings formed by breaking a
                  supplied input string at any separator that matches a given regular
                  expression.</p>
            </item>
         </ulist>

         <p>These functions are described in <bibref ref="xpath-functions-11"/>.</p>
         <p>For more complex string processing than is possible using these functions, XSLT provides
            an instruction <elcode>xsl:analyze-string</elcode>, which is defined in this
            section.</p>
         <p>The regular expressions used by this instruction, and the flags that control the
            interpretation of these regular expressions, <rfc2119>must</rfc2119> conform to the
            syntax defined in <bibref ref="xpath-functions-11"/> (see <xspecref spec="FO" ref="regex-syntax"/>), which is itself based on the syntax defined in <bibref ref="xmlschema-2"/>.</p>

         <note diff="add" at="C">
            <p>XPath 2.1 adds a fourth function, <xfunction>analyze-string</xfunction>, whose
               functionality is closely modeled on the <elcode>xsl:analyze-string</elcode>
               instruction described in this section, repackaging the facilities in the form of a
               function.</p>
         </note>


         <div2 id="analyze-string">
            <head>The <code>xsl:analyze-string</code> instruction</head>
            <e:element-syntax name="analyze-string">
               <e:in-category name="instruction"/>
               <e:attribute name="select" required="yes">
                  <e:data-type name="expression"/>
               </e:attribute>
               <e:attribute name="regex" required="yes">
                  <e:attribute-value-template>
                     <e:data-type name="string"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="flags" required="no">
                  <e:attribute-value-template>
                     <e:data-type name="string"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:sequence>
                  <e:element repeat="zero-or-one" name="matching-substring"/>
                  <e:element repeat="zero-or-one" name="non-matching-substring"/>
                  <e:element repeat="zero-or-more" name="fallback"/>
               </e:sequence>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <e:element-syntax name="matching-substring">
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent name="analyze-string"/>
               </e:allowed-parents>
            </e:element-syntax>
            <e:element-syntax name="non-matching-substring">
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent name="analyze-string"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:analyze-string</elcode> instruction takes as input a string (the
               result of evaluating the expression in the <code>select</code> attribute) and a
               regular expression (the effective value of the <code>regex</code> attribute).</p>
            <p>If the result of evaluating the <code>select</code> expression is not a string, it is
               converted to a string by applying the <termref def="dt-function-conversion-rules">function conversion rules</termref>.</p>
            <p>The <code>flags</code> attribute may be used to control the interpretation of the
               regular expression. If the attribute is omitted, the effect is the same as supplying
               a zero-length string. This is interpreted in the same way as the <code>$flags</code>
               attribute of the functions <xfunction>matches</xfunction>,
                  <xfunction>replace</xfunction>, and <xfunction>tokenize</xfunction>. Specifically,
               if it contains the letter <code>m</code>, the match operates in multiline mode. If it
               contains the letter <code>s</code>, it operates in dot-all mode. If it contains the
               letter <code>i</code>, it operates in case-insensitive mode. If it contains the
               letter <code>x</code>, then whitespace within the regular expression is ignored. For
               more detailed specifications of these modes, see <bibref ref="xpath-functions-11"/>
                  (<xspecref ref="flags" spec="FO"/>).</p>
            <note>
               <p>Because the <code>regex</code> attribute is an attribute value template, curly
                  brackets within the regular expression must be doubled. For example, to match a
                  sequence of one to five characters, write <code>regex=".{{1,5}}"</code>. For
                  regular expressions containing many curly brackets it may be more convenient to
                  use a notation such as <code>regex="{'[0-9]{1,5}[a-z]{3}[0-9]{1,2}'}"</code>, or
                  to use a variable.</p>
            </note>
            <p>The <elcode>xsl:analyze-string</elcode> instruction may have two child elements:
                  <elcode>xsl:matching-substring</elcode> and
                  <elcode>xsl:non-matching-substring</elcode>. Both elements are optional, and
               neither may appear more than once. At least one of them must be present. If both are
               present, the <elcode>xsl:matching-substring</elcode> element must come first.</p>
            <p>The content of the <elcode>xsl:analyze-string</elcode> instruction must take one of
               the following forms:</p>
            <olist>
               <item>
                  <p>A single <elcode>xsl:matching-substring</elcode> instruction, followed by zero
                     or more <elcode>xsl:fallback</elcode> instructions</p>
               </item>
               <item>
                  <p>A single <elcode>xsl:non-matching-substring</elcode> instruction, followed by
                     zero or more <elcode>xsl:fallback</elcode> instructions</p>
               </item>
               <item>
                  <p>A single <elcode>xsl:matching-substring</elcode> instruction, followed by a
                     single <elcode>xsl:non-matching-substring</elcode> instruction, followed by
                     zero or more <elcode>xsl:fallback</elcode> instructions</p>
               </item>
            </olist>
            <p>
               <error spec="XT" type="static" class="SE" code="1130">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the
                        <elcode>xsl:analyze-string</elcode> instruction contains neither an
                        <elcode>xsl:matching-substring</elcode> nor an
                        <elcode>xsl:non-matching-substring</elcode> element.</p>
               </error>
            </p>
            <p>Any <elcode>xsl:fallback</elcode> elements among the children of the
                  <elcode>xsl:analyze-string</elcode> instruction are ignored by an XSLT 2.0 <phrase diff="add" at="A">or 2.1</phrase> processor, but allow fallback behavior to be
               defined when the stylesheet is used with an XSLT 1.0 processor operating with
               forwards-compatible behavior.</p>
            <p>This instruction is designed to process all the non-overlapping substrings of the
               input string that match the regular expression supplied.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="1140">
                  <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the <termref def="dt-effective-value">effective
                        value</termref> of the <code>regex</code> attribute <error.extra>of the
                           <elcode>xsl:analyze-string</elcode> instruction</error.extra> does not
                     conform to the <rfc2119>required</rfc2119> syntax for regular expressions, as
                     specified in <bibref ref="xpath-functions-11"/>. If the regular expression is
                     known statically (for example, if the attribute does not contain any <termref def="dt-expression">expressions</termref> enclosed in curly brackets) then
                     the processor <rfc2119>may</rfc2119> signal the error as a <termref def="dt-static-error">static error</termref>. </p>
               </error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="1145">
                  <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the <termref def="dt-effective-value">effective
                        value</termref> of the <code>flags</code> attribute <error.extra>of the
                           <elcode>xsl:analyze-string</elcode> instruction</error.extra> has a value
                     other than the values defined in <bibref ref="xpath-functions-11"/>. If the value
                     of the attribute is known statically (for example, if the attribute does not
                     contain any <termref def="dt-expression">expressions</termref> enclosed in
                     curly brackets) then the processor <rfc2119>may</rfc2119> signal the error as a
                        <termref def="dt-static-error">static error</termref>. </p>
               </error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="1150">
                  <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the <termref def="dt-effective-value">effective
                        value</termref> of the <code>regex</code> attribute <error.extra>of the
                           <elcode>xsl:analyze-string</elcode> instruction</error.extra> is a
                     regular expression that matches a zero-length string: or more specifically, if
                     the regular expression <code>$r</code> and flags <code>$f</code> are such that
                        <code>matches("", $r, $f)</code> returns true. If the regular expression is
                     known statically (for example, if the attribute does not contain any <termref def="dt-expression">expressions</termref> enclosed in curly brackets) then
                     the processor <rfc2119>may</rfc2119> signal the error as a <termref def="dt-static-error">static error</termref>. </p>
               </error>
            </p>
            <p>The <elcode>xsl:analyze-string</elcode> instruction starts at the beginning of the
               input string and attempts to find the first substring that matches the regular
               expression. If there are several matches, the first match is defined to be the one
               whose starting position comes first in the string. If several alternatives within the
               regular expression both match at the same position in the input string, then the
               match that is chosen is the first alternative that matches. For example, if the input
               string is <code>The quick brown fox jumps</code> and the regular expression is
                  <code>jump|jumps</code>, then the match that is chosen is <code>jump</code>. </p>
            <p>Having found the first match, the instruction proceeds to find the second and
               subsequent matches by repeating the search, starting at the first character that was
               not included in the previous match.</p>
            <p>The input string is thus partitioned into a sequence of substrings, some of which
               match the regular expression, others which do not match it. Each substring will
               contain at least one character. This sequence of substrings is processed using the
               <phrase diff="chg" at="F">instructions within the contained <elcode>xsl:matching-substring</elcode> and
                  <elcode>xsl:non-matching-substring</elcode> elements</phrase>. A matching
               substring is processed using the <elcode>xsl:matching-substring</elcode> element, a
               non-matching substring using the <elcode>xsl:non-matching-substring</elcode> element.
               Each of these elements takes a <termref def="dt-sequence-constructor"/> as its content. If the element is
               absent, the effect is the same as if it were present with empty content. In
               processing each substring, the contents of the substring will be the <termref def="dt-context-item">context item</termref> (as a value of type
                  <code>xs:string</code>); the position of the substring within the sequence of
               matching and non-matching substrings will be the <termref def="dt-context-position">context position</termref>; and the number of matching and non-matching
               substrings will be the <termref def="dt-context-size">context size</termref>.</p>
            <p>If the input is a zero-length string, the number of substrings will be zero, so
               neither the <elcode>xsl:matching-substring</elcode> nor
                  <elcode>xsl:non-matching-substring</elcode> elements will be evaluated.</p>
         </div2>
         <div2 id="regex-group">
            <head>Captured Substrings</head>
            <proto class="xslt" name="regex-group" return-type="xs:string">
               <arg name="group-number" type="xs:integer"/>
            </proto>
            <p>
               <termdef id="dt-current-captured-substrings" term="current captured substrings">While
                  the <elcode>xsl:matching-substring</elcode> instruction is active, a set of
                     <term>current captured substrings</term> is available, corresponding to the
                  parenthesized sub-expressions of the regular expression.</termdef> These captured
               substrings are accessible using the function <function>regex-group</function>. This
               function takes an integer argument to identify the group, and returns a string
               representing the captured substring.</p>
            <p>The <var>N</var>th captured substring (where <var>N</var> &gt; 0) is the string
               matched by the subexpression contained by the <var>N</var>th left parenthesis in the
               regex, <phrase diff="add" at="C">excluding any non-capturing groups, which are
                  written as <code>(?:xxx)</code></phrase>. The zeroeth captured substring is the
               string that matches the entire regex. This means that the value of
                  <code>regex-group(0)</code> is initially the same as the value of <code>.</code>
               (dot).</p>
            <p>The function returns the zero-length string if there is no captured substring with
               the relevant number. This can occur for a number of reasons:</p>
            <olist>
               <item>
                  <p>The number is negative.</p>
               </item>
               <item>
                  <p>The regular expression does not contain a parenthesized sub-expression with the
                     given number.</p>
               </item>
               <item>
                  <p>The parenthesized sub-expression exists, and did not match any part of the
                     input string.</p>
               </item>
               <item>
                  <p>The parenthesized sub-expression exists, and matched a zero-length substring of
                     the input string.</p>
               </item>
            </olist>
            <p>The set of captured substrings is a context variable with dynamic scope. It is
               initially an empty sequence. During the evaluation of an
                  <elcode>xsl:matching-substring</elcode> instruction it is set to the sequence of
               matched substrings for that regex match. During the evaluation of an
                  <elcode>xsl:non-matching-substring</elcode> instruction or a <termref def="dt-pattern">pattern</termref> or a <termref def="dt-stylesheet-function">stylesheet function</termref> it is set to an empty sequence. On completion of an
               instruction that changes the value, the variable reverts to its previous value.</p>
            <p>The value of the <termref def="dt-current-captured-substrings">current captured
                  substrings</termref> is unaffected through calls of
                  <elcode>xsl:apply-templates</elcode>, <elcode>xsl:call-template</elcode>,
                  <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode>, or by
               expansion of named <termref def="dt-attribute-set">attribute sets</termref>.</p>
         </div2>
         <div2 id="regex-examples">
            <head>Examples of Regular Expression Matching</head>
            <example>
               <head>Replacing Characters by Elements</head>
               <p>Problem: replace all newline characters in the <code>abstract</code> element by
                  empty <code>br</code> elements:</p>
               <p>Solution:</p>
               <eg xml:space="preserve">&lt;xsl:analyze-string select="abstract" regex="\n"&gt;
  &lt;xsl:matching-substring&gt;
    &lt;br/&gt;
  &lt;/xsl:matching-substring&gt;
  &lt;xsl:non-matching-substring&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:non-matching-substring&gt;
&lt;/xsl:analyze-string&gt;</eg>
            </example>
            <example>
               <head>Recognizing non-XML Markup Structure</head>
               <p>Problem: replace all occurrences of <code>[...]</code> in the <code>body</code> by
                     <code>cite</code> elements, retaining the content between the square brackets
                  as the content of the new element.</p>
               <p>Solution:</p>
               <eg xml:space="preserve">&lt;xsl:analyze-string select="body" regex="\[(.*?)\]"&gt;
  &lt;xsl:matching-substring&gt;
    &lt;cite&gt;&lt;xsl:value-of select="regex-group(1)"/&gt;&lt;/cite&gt;
  &lt;/xsl:matching-substring&gt;
  &lt;xsl:non-matching-substring&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:non-matching-substring&gt;
&lt;/xsl:analyze-string&gt;</eg>
               <p>Note that this simple approach fails if the <code>body</code> element contains
                  markup that needs to be retained. In this case it is necessary to apply the
                  regular expression processing to each text node individually. If the
                     <code>[...]</code> constructs span multiple text nodes (for example, because
                  there are elements within the square brackets) then it probably becomes necessary
                  to make two or more passes over the data.</p>
            </example>
            <example>
               <head>Parsing a Date</head>
               <p>Problem: the input string contains a date such as <code>23 March 2002</code>.
                  Convert it to the form <code>2002-03-23</code>.</p>
               <p>Solution (with no error handling if the input format is incorrect):</p>
               <eg xml:space="preserve">&lt;xsl:variable name="months" 
        select="'January', 'February', 'March', ..."/&gt;

&lt;xsl:analyze-string select="normalize-space($input)" 
    regex="([0-9]{{1,2}})\s([A-Z][a-z]+)\s([0-9]{{4}})"&gt;
    &lt;xsl:matching-substring&gt;
        &lt;xsl:number value="regex-group(3)" format="0001"/&gt;          
        &lt;xsl:text&gt;-&lt;/xsl:text&gt;
        &lt;xsl:number value="index-of($months, regex-group(2))" format="01"/&gt;
        &lt;xsl:text&gt;-&lt;/xsl:text&gt;
        &lt;xsl:number value="regex-group(1)" format="01"/&gt;
    &lt;/xsl:matching-substring&gt;
&lt;/xsl:analyze-string&gt;</eg>
               <p>Note the use of <code>normalize-space</code> to simplify the work done by the
                  regular expression, and the use of doubled curly brackets because the
                     <code>regex</code> attribute is an attribute value template.</p>
            </example>
         </div2>
      </div1>
      <div1 id="streaming" diff="add" at="A">
         <head>Streaming</head>
         <p>This specification provides a number of facilities designed to enable <termref def="dt-streaming">streaming</termref>: that is, transformation of a source
            document on-the-fly, as it is parsed, without constructing a complete tree
            representation of the document in memory.</p>

         <p>These facilities include:</p>
         <ulist>
            <item>
               <p>The <elcode>xsl:stream</elcode> instruction, which reads an external document
                  (identified by URI) and initiates streaming of that document.</p>
            </item>
            <item>
               <p>Streaming templates, which allow rule-based invocation of template rules applied
                  to the nodes in a <termref def="dt-streamed-document">streamed
                  document</termref>.</p>
            </item>
         </ulist>

         <p>These facilities impose constraints on the stylesheet code to ensure that a streamable
            evaluation is possible. Much of this section is concerned with the definition of the
            rules for streamability.</p>

         <p><termdef id="dt-guaranteed-streamable" term="guaranteed-streamable">A 
            <term>guaranteed-streamable</term> construct is a <termref def="dt-construct">construct</termref>
               that follows the rules given in <specref ref="streamability"/>. Every <termref def="dt-processor">processor</termref> that claims conformance as a <termref def="dt-streaming-feature">streaming processor</termref>
               <rfc2119 at="F" diff="chg">must</rfc2119> be able to process such a construct using
               streaming, that is, by processing the contents of the source document on the fly 
               as it is read, without the need to buffer the entire document or any
               entire element in memory. </termdef>
         </p>
         <!--<p><termdef id="dt-actually-streamable" term="dt-actually-streamable">An 
            <term>actually streamable</term> construct is a <termref def="dt-construct">construct</termref> that a particular 
            <termref def="dt-processor">processor</termref> can process in a streaming manner.</termdef> If a construct is 
            <termref def="dt-guaranteed-streamable">guaranteed streamable</termref> then
            it will be actually streamable using any streaming processor; but for a given processor, some constructs 
            that are not guaranteed streamable may nevertheless be actually streamable.</p>-->

         <p>In certain contexts, in particular the <elcode>xsl:stream</elcode> instruction and a
               <termref def="dt-template-rule">template rule</termref> whose <termref def="dt-mode">mode</termref> is declared with <code>streamable="yes"</code>, the stylesheet author
            has the opportunity to request that evaluation should using streaming. In this case the rules are as
            follows:</p>

         <p>For a streaming processor:</p>

         <ulist>
            <item>
               <p>If the construct conforms to the rules for being <termref def="dt-guaranteed-streamable"/> then it <rfc2119 at="F" diff="chg">must</rfc2119> be processed using streaming.</p>
            </item>
            <item>
               <p>If the construct is not <termref def="dt-guaranteed-streamable"/> then it <rfc2119 at="F" diff="chg">must</rfc2119> still be
                  processed: the specification imposes no rules on how it is processed (it might or
                  might not use streaming). </p>
            </item>
            <item>
               <p>If the evaluation does not use streaming (which will only happen if the construct is not
                     <termref def="dt-guaranteed-streamable"/>) then
                  the processor <rfc2119>should</rfc2119> signal a warning indicating that streaming
                  was not possible; the processor <rfc2119>may</rfc2119> provide a user
                  option to abandon processing in this case.</p>
            </item>

         </ulist>

         <p>For a non-streaming processor, the processor <rfc2119 at="F" diff="chg">must</rfc2119>
            evaluate the <phrase diff="chg" at="F">construct</phrase> delivering the same results as if execution used streaming, but
            with no constraints on the evaluation strategy. (Processing <rfc2119 at="F" diff="chg">may</rfc2119>, of course, fail due to insufficient memory being available, or for
            other reasons.)</p>

         <note>
            <p>This specification does not attempt to legislate precisely what constitutes
               evaluation "using streaming". The most important test is that the amount of
               memory needed should be for practical purposes independent of the size of the source
               document, and in particular that the finite size of memory available should not
               impose a limit on the size of source document that can be processed.</p>
            <p>The rules are designed to ensure that streaming processors can analyze streamability
               using rules different from those in this specification, provided that all constructs
               that are <termref def="dt-guaranteed-streamable"/> according to this specification are actually
               streamable by the implementation. Furthermore, non-streaming processors are not
               required to analyze streamability at all.</p>
         </note>



         <div2 id="stream-instruction">
            <head>The <code>xsl:stream</code> instruction</head>
            <e:element-syntax name="stream">
               <e:in-category name="instruction"/>
               <e:attribute name="href" required="yes">
                  <e:attribute-value-template>
                     <e:data-type name="uri-reference"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:stream</elcode> instruction reads a source document whose URI is
               supplied, and processes the content of the document using streaming by evaluating the
               contained <termref def="dt-sequence-constructor">sequence constructor</termref>.</p>

            

            <p>For example, if a document represents a book holding a sequence of chapters, then the
               following code can be used to split the book into multiple XML files, one per
               chapter, without allocating memory to hold the entire book in memory at one time:</p>
            <eg xml:space="preserve">&lt;xsl:stream href="book.xml"&gt;
  &lt;xsl:for-each select="book/chapter"&gt;
    &lt;xsl:result-document href="chapter{position()}.xml"&gt;
      &lt;xsl:copy-of select="."/&gt;
    &lt;/xsl:result-document&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:stream&gt;</eg>
            <p>The document to be read is determined by the <termref def="dt-effective-value">effective value</termref> of the <code>href</code> attribute (which is defined as
               an <termref def="dt-attribute-value-template">attribute value template</termref>).
               <phrase diff="chg" at="F">This <rfc2119>must</rfc2119> be a valid URI reference. If it is an absolute URI reference,
               it is used as is; if it is a relative URI reference, it is
               made absolute by resolving it against the base URI of the <elcode>xsl:stream</elcode> element</phrase>. The process
               of obtaining a document node given a URI is the same as for the
                  <xfunction>doc</xfunction> function. However, unlike the
                  <xfunction>doc</xfunction> function, the <elcode>xsl:stream</elcode> instruction
               offers no guarantee that the resulting document will be stable (that is, that
               multiple calls specifying the same URI will return the same document).</p>
            <p>Specifically, if the <elcode>xsl:stream</elcode> instruction is evaluated several
               times (or if different <elcode>xsl:stream</elcode> instructions are evaluated) with
               the same URI (<phrase diff="chg" at="F">after making it absolute</phrase>) as the value of the <code>href</code> attribute,
               it is <termref def="dt-implementation-dependent">implementation-dependent</termref>
               whether the same nodes or different nodes are returned on each occasion; it is also
               possible that the actual document content will be different.</p>

            <p>The result of the <elcode>xsl:stream</elcode> instruction is the same as the result
               of the following (non-streaming) process:</p>
            <olist>
               <item>
                  <p>The source document is read from the supplied URI and parsed to form an
                     instance of the XDM data model. This is the <termref def="dt-streamed-document">streamed document</termref>.</p>
               </item>
               <item>
                  <p>The contained sequence constructor is evaluated with the <phrase diff="chg" at="F">document</phrase> node of the
                        <termref def="dt-streamed-document">streamed document</termref> as the
                     context item, and with the context position and context size set to one, and
                     the resulting sequence is returned as the result of the
                        <elcode>xsl:stream</elcode> instruction.</p>
               </item>
            </olist>
            <note>
               <p>The rules for streamability ensure that the sequence constructor (and therefore
                  the <elcode>xsl:stream</elcode> instruction) cannot return any nodes from the
                     <termref def="dt-streamed-document">streamed document</termref>. For example,
                  it cannot contain the instruction <code>&lt;xsl:sequence
                     select="//chapter"/&gt;</code>. If nodes from this document are to be returned,
                  they must first be copied, for example by <phrase diff="add" at="F">using the
                        <elcode>xsl:copy-of</elcode> instruction or by </phrase>calling the
                     <function>copy-of</function> or <function>snapshot</function> functions.</p>

               <p>Because the <elcode>xsl:stream</elcode> instruction cannot return nodes from the
                  streamed document, any nodes it does return will be conventional (unstreamed)
                  nodes that can be processed without restriction. For example, if
                     <elcode>xsl:stream</elcode> is invoked within a <termref def="dt-stylesheet-function">stylesheet function</termref>
                  <code>f:firstChapter</code>, and the sequence constructor consists of the
                  instruction <code>&lt;xsl:copy-of select="//chapter"/&gt;</code>, then the calling
                  code can manipulate the resulting <code>chapter</code> elements as ordinary trees
                  rooted at parentless element nodes.</p>

            </note>



            <div3 id="stream-examples">
               <head>Examples of <code>xsl:stream</code>
               </head>
               <p>The <elcode>xsl:stream</elcode> instruction can be used to initiate processing of
                  a document using streaming with a variety of coding styles, illustrated in
                  the examples below.</p>
               <example>
                  <head>Using <elcode>xsl:stream</elcode> with aggregate functions</head>
                  <p>The following example computes the number of transactions in a transaction
                     file</p>
                  <p>Input:</p>
                  <eg xml:space="preserve">
&lt;transactions&gt;
  &lt;transaction value="12.51"/&gt;
  &lt;transaction value="3.99"/&gt;
&lt;/transactions&gt;</eg>
                  <p>Stylesheet code:</p>
                  <eg xml:space="preserve">&lt;xsl:stream href="transactions.xml"&gt;
  &lt;count&gt;
    &lt;xsl:value-of select="count(transactions/transaction)"/&gt;
  &lt;/count&gt;
&lt;/xsl:stream&gt;</eg>
                  <p>Result:</p>
                  <eg xml:space="preserve">&lt;count&gt;2&lt;/count&gt;</eg>
                  <p>The following example computes the highest-value transaction in the same input
                     file:</p>
                  <eg xml:space="preserve">&lt;xsl:stream href="transactions.xml"&gt;
  &lt;maxValue&gt;
    &lt;xsl:value-of select="max(transactions/transaction/@value)"/&gt;
  &lt;/maxValue&gt;
&lt;/xsl:stream&gt;</eg>
                  <p>Result:</p>
                  <eg xml:space="preserve">&lt;maxValue&gt;12.51&lt;/maxValue&gt;</eg>
                  <p>To compute both the count and the maximum value in a single pass over the
                     input, it is necessary to use <elcode>xsl:fork</elcode>:</p>
                  <eg xml:space="preserve">&lt;xsl:stream href="transactions.xml"&gt;
  &lt;xsl:fork&gt;
    &lt;count&gt;
      &lt;xsl:value-of select="count(transactions/transaction)"/&gt;
    &lt;/count&gt;
    &lt;maxValue&gt;
      &lt;xsl:value-of select="max(transactions/transaction/@value)"/&gt;
    &lt;/maxValue&gt;
  &lt;/xsl:fork&gt;
&lt;/xsl:stream&gt;</eg>
               </example>
               <example>
                  <head>Using <elcode>xsl:stream</elcode> with <elcode>xsl:for-each</elcode> to
                     process a collection of input documents </head>
                  <p>This example displays a list of the chapter titles extracted from each book in
                     a collection of books.</p>
                  <p>Each input document is assumed to have a structure such as:</p>
                  <eg xml:space="preserve">&lt;book&gt;
  &lt;chapter number-of-pages="18"&gt;
    &lt;title&gt;The first chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
  &lt;chapter number-of-pages="15"&gt;
    &lt;title&gt;The second chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
  &lt;chapter number-of-pages="12"&gt;
    &lt;title&gt;The third chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
&lt;/book&gt;</eg>
                  <p>Stylesheet code:</p>
                  <eg xml:space="preserve">&lt;chapter-titles&gt;
  &lt;xsl:for-each select="uri-collection('books')"&gt;
    &lt;xsl:stream href="{.}"&gt;
      &lt;xsl:for-each select="book/chapter"&gt;
        &lt;title&gt;&lt;xsl:value-of select="title"/&gt;&lt;/title&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:stream&gt;
  &lt;/xsl:for-each&gt;
&lt;/chapter-titles&gt;</eg>
                  <p>Output:</p>
                  <eg xml:space="preserve">&lt;chapter-titles&gt;
  &lt;title&gt;The first chapter of book A&lt;/title&gt;
  &lt;title&gt;The second chapter of book A&lt;/title&gt;
  ...
  &lt;title&gt;The first chapter of book B&lt;/title&gt;
  ...
&lt;/chapter-titles&gt;</eg>
                  <note>
                     <p>This example uses the function <function>uri-collection</function> to obtain
                        the document URIs of all the documents in a collection, so that each one can
                        be processed in turn using <elcode>xsl:stream</elcode>.</p>
                  </note>
               </example>
               <example>
                  <head>Using <elcode>xsl:stream</elcode> with <elcode>xsl:iterate</elcode>
                  </head>
                  <p>This example assumes that the input is a book with multiple chapters, as shown
                     in the previous example, with the page count for each chapter given as an
                     attribute of the chapter. The transformation determines the starting page
                     number for each chapter by accumulating the page counts for previous chapters,
                     and rounding up to an odd number if necessary.</p>
                  <eg xml:space="preserve">&lt;chapter-start-page&gt;
   &lt;xsl:stream href="book.xml"&gt;
      &lt;xsl:iterate select="book/chapter"&gt;
         &lt;xsl:param name="start-page" select="1"/&gt;
         &lt;chapter title="{title}" start-page="{$start-page}"/&gt;
         &lt;xsl:next-iteration&gt;
            &lt;xsl:with-param name="start-page" 
                            select="$start-page + @number-of-pages + 
                                      (@number-of-pages mod 2)"/&gt;
         &lt;/xsl:next-iteration&gt;
      &lt;/xsl:iterate&gt;
   &lt;/xsl:stream&gt;
&lt;/chapter-start-page&gt;
</eg>
                  <p>Output:</p>
                  <eg xml:space="preserve">&lt;chapter-start-page&gt;
  &lt;chapter title="The first chapter of book A" start-page="1"/&gt;
  &lt;chapter title="The second chapter of book A" start-page="19"/&gt;
  &lt;chapter title="The third chapter of book A" start-page="35"/&gt;
  ...
&lt;/chapter-start-page&gt;
                     </eg>
               </example>
               <example>
                  <head>Using <elcode>xsl:stream</elcode> with <elcode>xsl:for-each-group</elcode>
                  </head>
                  <p>This example assumes that the input is a book with multiple chapters, and that
                     each chapter belongs to a part, which is present as an attribute of the chapter
                     (for example, chapters 1-4 might constitute Part 1, the next three chapters
                     forming Part 2, and so on):</p>
                  <eg xml:space="preserve">&lt;book&gt;
  &lt;chapter part="1"&gt;
    &lt;title&gt;The first chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
  &lt;chapter part="1"&gt;
    &lt;title&gt;The second chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
  ...
  &lt;chapter part="2"&gt;
    &lt;title&gt;The fifth chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
&lt;/book&gt;</eg>
                  <p>The transformation copies the full text of the chapters, creating an extra
                     level of hierarchy for the parts.</p>
                  <eg xml:space="preserve">&lt;book&gt;
   &lt;xsl:stream href="book.xml"&gt;
      &lt;xsl:for-each-group select="book/chapter" group-adjacent="@part"&gt;
         &lt;part number="{current-grouping-key()}"&gt;
            &lt;xsl:copy-of select="current-group()"/&gt;
         &lt;/part&gt;
      &lt;/xsl:for-each-group&gt;
   &lt;/xsl:stream&gt;
&lt;/book&gt;
</eg>
                  <p>Output:</p>
                  <eg xml:space="preserve">&lt;book&gt;
  &lt;part number="1"&gt;
    &lt;chapter title="The first chapter of book A" part="1"&gt;
      ...
    &lt;/chapter&gt;
    &lt;chapter title="The second chapter of book A" part="1"&gt;
      ...
    &lt;/chapter&gt;
    ...
  &lt;/part&gt;
  &lt;part number="2"&gt;
    &lt;chapter title="The fifth chapter of book A" part="2"&gt;
    ...
    &lt;/chapter&gt;
    ...
  &lt;/part&gt;
&lt;/book&gt;
    </eg>
               </example>
               <example>
                  <head>Using <elcode>xsl:stream</elcode> with <elcode>xsl:apply-templates</elcode>
                  </head>
                  <p>This example copies an XML document while deleting all the <code>ednote</code>
                     elements at any level of the tree, together with their descendants. This
                     example is a complete stylesheet, which is intended to be evaluated by
                     nominating <code>main</code> as the <termref def="dt-initial-template">initial
                        template</termref>. The use of <code diff="chg" at="F">on-no-match="copy"</code> in the <elcode>xsl:mode</elcode> declaration
                     means that the built-in template rule copies nodes unchanged, except where
                     overridden by a user-defined template rule.</p>
                  <eg xml:space="preserve">&lt;xsl:transform version="2.1" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:mode name="delete-ednotes" streaming="yes" on-no-match="copy"/&gt;

&lt;xsl:template name="main"&gt;
   &lt;xsl:stream href="book.xml"&gt;
      &lt;xsl:apply-templates mode="delete-ednotes"/&gt;
   &lt;/xsl:stream&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="ednote" mode="delete-ednotes"/&gt;

&lt;/xsl:transform&gt;</eg>
                  <p>Additional template rules could be added to process other elements and
                     attributes in the same pass through the data: for example, to modify the value
                     of a <code>last-updated</code> attribute (wherever it appears) to the current
                     date and time, the following rule suffices:</p>
                  <eg xml:space="preserve">
&lt;xsl:template match="@last-updated"&gt;
  &lt;xsl:attribute name="last-updated" select="current-dateTime()"/&gt;
&lt;/xsl:template&gt;</eg>
               </example>

               <example>
                  <head>Using <elcode>xsl:stream</elcode> with <elcode>xsl:merge</elcode>
                  </head>
                  <p>This example builds a file representing the index of a book from files
                     containing the index for each chapter. The chapter-level index files contain
                     entries of the form <code>&lt;entry term="XML" page="27"/&gt;</code> sorted first
                     alphabetically by term and then numerically by page number; the sort order for
                     the combined index is the same.</p>
                  <eg xml:space="preserve">&lt;index&gt;
   &lt;xsl:merge&gt;
     &lt;xsl:merge-source select="uri-collection('chapter-indexes')"&gt;
       &lt;xsl:merge-input&gt;
         &lt;xsl:stream href="{.}"&gt;
           &lt;xsl:copy-of select="index/entry"/&gt;
         &lt;/xsl:stream&gt;
         &lt;xsl:merge-key select="string(@term)"/&gt;
         &lt;xsl:merge-key select="xs:integer(@page)"/&gt;
      &lt;/xsl:merge-input&gt;
    &lt;/xsl:merge-source&gt;
    &lt;xsl:merge-action&gt;
       &lt;xsl:copy-of select="current-group()[1]"/&gt;
    &lt;/xsl:merge-action&gt;
  &lt;/xsl:merge&gt;
&lt;/index&gt;</eg>

                  <p>In cases where two chapter indexes contain entries for the same term, they will
                     normally have different page numbers, and will therefore go in separate groups.
                     Their order in the output is based on the ordering of the merge keys, which
                     means entries with the same term appear in page number order. In the unlikely
                     case that two files contain entries where both the term and the page number are
                     the same (or, perhaps more plausibly, where such duplicates occur within a
                     single input file), the <elcode>xsl:merge-action</elcode> ensures that only the
                     first of the duplicates will be copied. </p>
               </example>
            </div3>
         </div2>
         <div2 id="streamable-templates">
            <head>Streamable Templates</head>
            <p><termdef id="dt-streamable-template" term="streamable template">If any of the
                     <termref def="dt-mode">modes</termref> to which a <termref def="dt-template-rule">template rule</termref> is applicable is a <termref def="dt-streamable-mode">streamable mode</termref>, then the template rule
                     <rfc2119>must</rfc2119> satisfy certain rules to ensure that it can be
                  evaluated using streaming. A template that satisfies these rules is referred
                  to as a <term>streamable template</term>.</termdef> Specifically:</p>
            <ulist>
               <item>
                  <p>The <termref def="dt-pattern">pattern</termref> defined in the
                        <code>match</code> attribute of the <elcode>xsl:template</elcode> element
                     must be a <termref def="dt-streamable-pattern"/> as defined in <specref ref="streamable-patterns"/>.</p>
               </item>
               <item>
                  <p>The <termref def="dt-sequence-constructor">sequence constructor</termref>
                     contained in the body of the <elcode>xsl:template</elcode> element
                        <rfc2119>must</rfc2119> be a <termref def="dt-guaranteed-streamable">guaranteed streamable</termref> sequence constructor, as defined in
                        <specref ref="streamability"/>.</p>
               </item>

            </ulist>
            
            <issue id="issue-streamable-template-terminology" status="open">
               <p>It might be more consistent to use "guaranteed-streamable template" rather than
               "streamable template".</p>
            </issue>

         </div2>
         <div2 id="streamable-patterns">
            <head>Streamable patterns</head>

            <p><termref def="dt-pattern">Patterns</termref> appear in XSLT in a number of contexts:
               most notably as match patterns in <termref def="dt-template-rule">template
                  rules</termref>, but also in <termref def="dt-key">key</termref> definitions and
               in attributes of the <elcode>xsl:number</elcode> and
                  <elcode>xsl:for-each-group</elcode> instructions.</p>

            <p diff="chg" at="F">In general, it is difficult to predict how often a pattern will be evaluated, or
               which nodes it will be evaluated against. The rules for matching nodes against a
               pattern are therefore designed to make it possible to test the
               pattern against a node in a streamed input document without changing the current
               position of the stream. In particular, if the node is an element, the rules make it
               possible to test whether the node matches the pattern while the stream is positioned
               at the element's start tag.</p>

            <p><termdef id="dt-streamable-pattern" term="streamable pattern">A <termref def="dt-pattern">pattern</termref> is a <term>streamable pattern</term> if it
                  can be tested against a node in a <termref def="dt-streamed-document">streamed
                     document</termref> without access to the descendants of the node.</termdef>
               Specifically, a pattern is streamable if it satisfies all the following
               conditions:</p>

            <olist>
               <item>
                  <p diff="chg" at="E">It <rfc2119>must not</rfc2119> contain any of the constructs
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-VarRefRoot" xlink:type="simple">VarRefRoot</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-IdCall" xlink:type="simple">IdCall</nt>,
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-ElementWithIdCall" xlink:type="simple">ElementWithIdCall</nt>, or <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-KeyCall" xlink:type="simple">KeyCall</nt></p>
                  <issue id="issue-prohibit-doc-in-patterns" status="open">
                     <p>Given that <elcode>xsl:stream</elcode> might not yield stable results, it might make sense to 
                        prohibit <code>DocCall</code> here as well - it's highly implementation dependent whether 
                        the same node from the streamed document would occur in the document returned by the 
                        <code>doc</code> function call. </p>
                  </issue>
               </item>
               <item>
                  <p>In any <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-PatternStep" xlink:type="simple">PatternStep</nt> within the pattern, the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" ref="prod-xpath21-PredicateList" spec="XP21" xlink:type="simple">PredicateList</xnt>
                     <rfc2119 diff="chg" at="F">must</rfc2119> contain at most one <xnt xmlns:xlink="http://www.w3.org/1999/xlink" ref="prod-xpath21-Predicate" spec="XP21" xlink:type="simple">Predicate</xnt>.</p>
               </item>
               <item>
                  <p>In any <xnt xmlns:xlink="http://www.w3.org/1999/xlink" ref="prod-xpath21-Predicate" spec="XP21" xlink:type="simple">Predicate</xnt> within the
                     pattern, the expression within the predicate <rfc2119 diff="chg" at="F">must</rfc2119> be <termref def="dt-motionless">motionless</termref> with
                     respect to its context item, as defined in <specref ref="streamability-conditions"/>. </p>
               </item>
            </olist>

            <note>
               <p>Informally, the expression in a predicate is <termref def="dt-motionless">motionless</termref> if it can be evaluated without reading the children or
                  descendants of the context node. The term "motionless" is chosen to convey the
                  idea that the pattern can be evaluated without repositioning the input stream.</p>
               <p>The effect of these rules is that it is always possible to determine whether an
                  element matches the pattern while processing the start tag of the element, and
                  without advancing the stream beyond the start tag of the element. </p>
               <p>The use of <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-VarRefRoot" xlink:type="simple">VarRefRoot</nt> is prohibited because the test
                  would never be satisfied: a variable reference outside a predicate would
                  necessarily be a reference to a global variable, and no global variable can ever
                  be bound to a node in a streamed input document.</p>
               <p>The use of <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-IdCall" xlink:type="simple">IdCall</nt> and <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-ElementWithIdCall" xlink:type="simple">ElementWithIdCall</nt> is prohibited because (in the case of an ID-valued
                  element, as distinct from an ID-valued attribute) the ID value is not known until
                  the element content has been read.</p>
               <p>The use of <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-KeyCall" xlink:type="simple">KeyCall</nt> is prohibited because keys, in
                  general, cannot be evaluated without access to the content of an element, and the
                  use case is not important enough to justify isolating those cases where streaming
                  evaluation would actually be feasible.</p>
               <p>The reason for the restriction to a single predicate is to disallow pattern steps
                  such as <code>match="p[@a=2 and @b=3][5]"</code>, where the first predicate
                  applies some complex boolean filter, and the second is positional. This would
                  potentially require maintaining a complex set of counting variables. In principle
                  one could allow multiple predicates provided that only the first one depends on
                  the context position; but it is not always possible to identify positional
                  predicates by static analysis, and in any case such analysis is outside the scope
                  of this specification. Patterns such as <code>match="p[1]"</code> are permitted,
                  however: to evaluate such a pattern, a streaming processor must typically maintain
                  a count of how many nodes of each unique combination of (node-kind, node-name,
                  type-annotation) have been encountered at each level of the XML hierarchy.</p>
               <p>The analysis depends on the fact that in both XML Schema 1.0 and XML Schema 1.1,
                  the type of an element is known as soon as its start tag has been processed,
                  before examining its content. This principle has been preserved in the design of
                  new features such <emph>conditional type assignment</emph> in XML Schema 1.1.
                  Clearly the validity of the element against this type is not established until the
                  content has been read; but if the element is found to be invalid, the XSLT
                  processing will always fail, so assuming the type makes no difference to the
                  outcome.</p>

            </note>

         </div2>
         <div2 id="streamability">
            <head>Streamability Analysis</head>

            <p>The rules for streamable templates, and also the rules for the
                  <elcode>xsl:stream</elcode> instruction, require that the contained <termref def="dt-sequence-constructor">sequence constructor</termref> <rfc2119 diff="chg" at="F">must</rfc2119> be <termref def="dt-guaranteed-streamable"/>. For generality, we
               define streamability as a property of any <termref def="dt-construct">construct</termref>, of which a sequence constructor is but one kind. The term
                  <termref def="dt-construct">construct</termref> is defined in <specref ref="building-expression-tree"/>.</p>


            <p>The assessment of a <termref def="dt-construct">construct</termref> to determine
               whether it is a <termref def="dt-guaranteed-streamable"/> construct is done as described in the following rules:</p>

             <olist>
               <item>
                  <p>Optionally, the construct <rfc2119>may</rfc2119> be rewritten by the <termref def="dt-processor">processor</termref> in an <termref def="dt-implementation-dependent">implementation-dependent</termref> way,
                     replacing it by an optimized equivalent. This optimization
                        <rfc2119>may</rfc2119> cause a construct that would otherwise be
                     non-streamable to become streamable, but it <rfc2119>must
                        not</rfc2119> cause a streamable construct to become non-streamable (for
                        example, the inverse of either of the above).</p>
                  <note><p>For example, the expression <code>A[B or C]</code> might
                     be rewritten as <code>A[*[self::B or self::C]]</code>: the expression as written
                  is not streamable because it makes two downward selections, but the rewritten expression is
                  streamable because it only has one. Similarly, the expression <code>//A/B</code>
                     might be rewritten as <code>//B[parent::A]</code></p></note>
               </item>
               <item>
                  <p>An expression tree is constructed representing the structure of the <termref def="dt-construct">construct</termref>, in terms of its contained
                     instructions, XPath expressions, and other constructs.</p>
               </item>
               <item>
                  <p>The expression tree is expanded to make all navigation within the 
                     <phrase diff="chg" at="F"><termref def="dt-streamed-document"/></phrase> explicit; for
                     example, a construct that atomizes a node is expanded to include a path
                     expression that makes access to all the text node descendants of that node.</p>
               </item>
               <item>
                  <p>A path map is constructed defining the navigation routes followed by the
                     <phrase diff="chg" at="F"><termref def="dt-construct"/></phrase>, starting at the context node.</p>
               </item>
               <item>
                  <p>This path map is examined to determine whether it contains any paths, or
                     combinations of paths, that are inconsistent with streaming.</p>
               </item>
            </olist>
            <p>These steps are explained in more detail in the following subsections. The section
               ends with some worked examples: see <specref ref="streamability-examples"/>.</p>

            <note><p>Streamability analysis is done on the stylesheet as it exists after
               processing of <code>[xsl:]use-when</code> attributes as described in <specref ref="conditional-inclusion"/>. An expression that appears in an
                  <code>[xsl:]use-when</code> attribute itself cannot access any source document,
               and therefore cannot affect streamability.</p></note>

            <div3 id="building-expression-tree">
               <head>Building an Expression Tree</head>
               <p>The first stage in analyzing a <termref def="dt-construct">construct</termref>
                  (typically the content of an <elcode>xsl:stream</elcode> instruction or a <termref def="dt-template-rule">template rule</termref>) to determine whether it is
                  streamable is to create a representation of the construct in the form of an
                  expression tree. The expression tree represents the syntactic structure of the
                  construct.</p>
               <p><termdef id="dt-e-node" term="e-node">To distinguish nodes in an expression tree
                     from other kinds of node in other kinds of tree, we refer to them as
                        <term>e-nodes</term>.</termdef></p>

               <p><termdef id="dt-construct" term="construct">An <termref def="dt-e-node">e-node</termref> (a node in the expression tree) represents a
                        <term>construct</term>. A <term>construct</term> is a <phrase diff="chg" at="F">fragment of</phrase>
                  a stylesheet that can be evaluated <phrase diff="chg" at="F">or invoked</phrase> to produce a value.</termdef>. Specifically,
                  it is one of the following:</p>

               <ulist>
                  <item>
                     <p>an <termref def="dt-instruction">instruction</termref></p>
                  </item>
                  <item>
                     <p>an <termref def="dt-expression">expression</termref></p>
                  </item>
                  <item>
                     <p>a <termref def="dt-pattern">pattern</termref></p>
                  </item>
                  <item>
                     <p>a <termref def="dt-sequence-constructor">sequence constructor</termref></p>
                  </item>
                  <item>
                     <p>an <termref def="dt-attribute-value-template">attribute value
                           template</termref></p>
                  </item>
                  <item>
                     <p>a <termref def="dt-stylesheet-function">stylesheet function</termref></p>
                  </item>
                  <item>
                     <p>a <termref def="dt-template">template</termref></p>
                  </item>
                  <item>
                     <p>an <termref def="dt-attribute-set">attribute set</termref></p>
                  </item>
                  <item>
                     <p>an <code>[xsl:]use-attribute-sets</code> attribute</p>
                  </item>
                  <item>
                     <p>an <elcode>xsl:when</elcode>, <elcode>xsl:otherwise</elcode>,
                           <elcode>xsl:matching-substring</elcode>,
                           <elcode>xsl:non-matching-substring</elcode>,
                           <elcode>xsl:with-param</elcode>, <elcode>xsl:catch</elcode> or
                           <elcode>xsl:on-completion</elcode> element (these elements have a
                        structural role within an <termref def="dt-instruction">instruction</termref>, but they are not themselves instructions)</p>
                  </item>

               </ulist>

               <p>Some <phrase diff="chg" at="F"><termref def="dt-construct">constructs</termref></phrase> perform navigation that cannot be statically
                  analyzed and that can potentially visit all parts of the tree containing the
                  context node. An example is an <elcode>xsl:evaluate</elcode> instruction. This is
                  fatal to streaming only if the context node is a node in the streamed input
                  document. The expression <code>preceding::*</code> is used as a convenient
                  surrogate for an expression that can navigate anywhere in the tree, and the
                  presence of this expression in the data flow graph will ensure that the
                  streamability analysis produces the correct result.</p>


               <note>
                  <p>Many processors will build some kind of expression tree for purposes unrelated
                     to streamability analysis. In practice the same tree is likely to be used for
                     other operations such as type analysis and optimization.</p>
                  <p>Because static type inferencing is not prescribed by this specification, the
                     algorithms described in this section do not rely on type inferencing. In
                     practice, where the static type of an expression has already been determined,
                     the processor will be able to recognize that some of the steps described in
                     these rules are not always necessary.</p>
               </note>


               <p>In principle an expression tree can be constructed for each <termref def="dt-stylesheet-function">stylesheet function</termref>, <termref def="dt-template">template</termref>, and <termref def="dt-attribute-set">attribute set</termref>: its root e-node represents the function, template, or
                  attribute set. In practice, however, expressions trees are only needed for
                  constructs that are subject to streamability analysis: this includes the content
                  of <elcode>xsl:stream</elcode> instructions, <termref def="dt-template-rule">template rules</termref> that use a streamable <termref def="dt-mode">mode</termref>, and the templates, functions, and attribute sets that these
                  call, to any depth.</p>



               <p>The children of an <termref def="dt-e-node">e-node</termref> are determined as
                  described in the table below.</p>

               <table border="1" cellpadding="5">
                  <thead>
                     <tr>
                        <th align="left" rowspan="1" colspan="1">Parent e-node</th>
                        <th align="left" rowspan="1" colspan="1">Child e-nodes</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1"><termref def="dt-template">Template</termref></td>
                        <td valign="top" rowspan="1" colspan="1">The <termref def="dt-pattern">pattern</termref> in the
                              <code>match</code> attribute if present; the
                              <elcode>xsl:param</elcode> elements used to bind default values to the
                           template's parameters; and the <termref def="dt-sequence-constructor">sequence constructor</termref> that forms the body of the template.
                        </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1"><termref def="dt-stylesheet-function">Stylesheet
                              function</termref></td>
                        <td valign="top" rowspan="1" colspan="1">The <termref def="dt-sequence-constructor">sequence
                              constructor</termref> that forms the body of the function.</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1"><termref def="dt-attribute-set">Attribute
                           set</termref></td>
                        <td valign="top" rowspan="1" colspan="1">The sequence of <elcode>xsl:attribute</elcode> elements
                           that forms the body of the attribute set, treated as a <termref def="dt-sequence-constructor">sequence constructor</termref>; plus the
                              <code>use-attribute-sets</code> attribute if present.</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">Variable binding element (<elcode>xsl:variable</elcode>,
                              <elcode>xsl:param</elcode>, <elcode>xsl:with-param</elcode>)</td>
                        <td valign="top" rowspan="1" colspan="1">The <termref def="dt-expression">expression</termref> in
                           the <code>select</code> attribute, or the contained <termref def="dt-sequence-constructor">sequence constructor</termref>.</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1"><termref def="dt-sequence-constructor">Sequence
                              constructor</termref></td>
                        <td valign="top" rowspan="1" colspan="1">The <termref def="dt-instruction">instructions</termref>
                           within the sequence constructor, including any <termref def="dt-literal-result-element">literal result elements</termref>. It
                           is not necessary to include literal text nodes on the tree, since they
                           never affect streamability. A sequence constructor comprising a single
                           instruction can safely be elided from the tree (that is, replaced by its
                           children).</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1"><termref def="dt-literal-result-element">Literal result
                              element</termref></td>
                        <td valign="top" rowspan="1" colspan="1">The <termref def="dt-sequence-constructor">sequence
                              constructor</termref> used to construct the content of the new
                           element, plus any <termref def="dt-attribute-value-template">attribute
                              value templates</termref> and <code>xsl:use-attribute-sets</code>
                           attributes used to construct its attributes. An attribute whose value is
                           known statically can be omitted from the tree, since it does not affect
                           the streamability of the construct.</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1"><termref def="dt-attribute-value-template">Attribute value
                              template</termref></td>
                        <td valign="top" rowspan="1" colspan="1">The XPath expressions contained within curly brackets in
                           the attribute value. Any fixed text outside the curly brackets can be
                           omitted from the tree, since it does not affect the streamability of the
                           construct.</td>
                     </tr>
                     <tr>
                        <td valign="top" diff="add" at="F" rowspan="1" colspan="1"><elcode>xsl:if</elcode> instruction</td>
                        <td valign="top" diff="add" at="F" rowspan="1" colspan="1">An <elcode>xsl:if</elcode> instruction is rewritten
                           as if it were an XPath <code>if .. then .. else ()</code> expression,
                           so that the subsequent analysis can treat all conditionals in the same way.
                           The corresponding e-node will therefore have three children, one representing
                           the <code>test</code> condition, one representing the <termref def="dt-sequence-constructor"/>
                           contained within the <elcode>xsl:if</elcode> instruction, and one representing
                           the empty sequence.
                        </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1"><elcode>xsl:choose</elcode> instruction</td>
                        <td valign="top" rowspan="1" colspan="1">An <elcode>xsl:choose</elcode> instruction is rewritten as
                           a tree of <code>if .. then .. else ..</code> conditional expressions: a
                           second <elcode>xsl:when</elcode> thus becomes a nested conditional within
                           the <code>else</code> branch of the first, and so on. The e-node that
                           results will always have three children, representing the test condition,
                           the <code>then</code> branch, and the <code>else</code> branch. This
                           rewrite is done because it makes the subsequent analysis easier, in
                           particular, the determination of which subexpressions are mutually
                           exclusive.</td>
                     </tr>
                     <tr>
                        <td valign="top" diff="add" at="F" rowspan="1" colspan="1"><elcode>xsl:try</elcode> instruction</td>
                        <td valign="top" diff="add" at="F" rowspan="1" colspan="1">The e-node corresponding to an <elcode>xsl:try</elcode> 
                           instruction has two children, one for the <termref def="dt-sequence-constructor"/> or
                           <code>select</code> expression defining the non-error result of the instruction, and one for the
                           set of <elcode>xsl:catch</elcode> elements. If there are multiple <elcode>xsl:catch</elcode>
                           elements, these are rewritten as if there were a single <elcode>xsl:catch</elcode> containing
                           a conditional expression (or set of nested conditionals) performing tests on the value of the
                           error code.</td>
                     </tr>

                     <tr>
                        <td valign="top" rowspan="1" colspan="1"><elcode>xsl:for-each</elcode> instruction</td>
            
                        <td valign="top" rowspan="1" colspan="1">The <code>select</code> expression, plus the <termref def="dt-sequence-constructor">sequence constructor</termref>
                           representing the body of the instruction. If there are any
                              <elcode>xsl:sort</elcode> children, then a <code>sort</code> e-node is
                           inserted into the tree to represent the sorting operation. This e-node
                           has the <elcode>xsl:for-each</elcode> instruction as its parent, and the
                              <code>select</code> expression of the <elcode>xsl:for-each</elcode>
                           instruction as its child; in addition, it has as children 
                           <phrase diff="add" at="F">the <code>select</code> expression of the <elcode>xsl:sort</elcode> element, plus </phrase>any expressions
                           that appear in <termref def="dt-attribute-value-template">attribute value
                              templates</termref> among the attributes of the
                              <elcode>xsl:sort</elcode> elements (used, for example, to compute the
                           collation URI). </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1"><elcode>xsl:apply-templates</elcode> instruction</td>
                        <td valign="top" rowspan="1" colspan="1">The <code>select</code> expression, or an e-node
                           representing the expression <code>child::node()</code> if the
                              <code>select</code> attribute is omitted; plus variable binding
                           elements representing the <elcode>xsl:with-param</elcode> children. If
                           there are any <elcode>xsl:sort</elcode> children, then a
                              <code>sort</code> e-node is inserted into the tree to represent the
                           sorting operation: <phrase diff="add" at="F">for an illustration of this, 
                              see <specref ref="expr-tree-sorting"/></phrase>. This e-node has the
                              <elcode>xsl:apply-templates</elcode> instruction as its parent, and
                           the <code>select</code> expression of the
                              <elcode>xsl:apply-templates</elcode> instruction as its child; in
                           addition, it has as children any expressions that appear in <termref def="dt-attribute-value-template">attribute value templates</termref>
                           among the attributes of the <elcode>xsl:sort</elcode> elements (used, for
                           example, to compute the collation URI). </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1"><elcode>xsl:perform-sort</elcode> instruction</td>
                        <td valign="top" rowspan="1" colspan="1">The <code>select</code> expression <phrase diff="add" at="F">or contained 
                        <termref def="dt-sequence-constructor"/></phrase>, together with any
                           expressions that appear in <termref def="dt-attribute-value-template">attribute value templates</termref> among the attributes of the
                              <elcode>xsl:sort</elcode> elements (used, for example, to compute the
                           collation URI). </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1"><elcode>xsl:for-each-group</elcode> instruction</td>
                        <td valign="top" rowspan="1" colspan="1">The contained <termref def="dt-sequence-constructor">sequence constructor</termref>, plus a <code>group</code> e-node
                           whose children are the <code>select</code> expression, the expressions
                           appearing in the attributes <code>group-by</code>,
                              <code>group-adjacent</code>, and any expression appearing in an
                              <termref def="dt-attribute-value-template">attribute value
                              template</termref> in the <code>collation</code> attribute. If the
                           instruction has <elcode>xsl:sort</elcode> children, then a
                              <code>sort</code> e-node is inserted into the tree with the
                              <code>xsl:for-each-group</code> instruction as its parent and the
                              <code>group</code> e-node as its child; in addition, it has as
                           children any expressions that appear in <termref def="dt-attribute-value-template">attribute value templates</termref>
                           among the attributes of the <elcode>xsl:sort</elcode> elements (used, for
                           example, to compute the collation URI). The <termref def="dt-pattern">pattern</termref> appearing in the <code>group-starting-with</code>
                           or <code>group-ending-with</code> attributes (if present) is analyzed to
                           determine whether it is a <termref def="dt-streamable-pattern">streamable
                              pattern</termref>: if it is, then it does not need to be represented
                           on the expression tree; if it is not, then a child e-node representing
                           the expression <code>preceding::*</code> is added to the tree, indicating
                           non-streamable navigation. </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1"><elcode>xsl:iterate</elcode> instruction</td>
                        <td valign="top" rowspan="1" colspan="1">The <code>select</code> expression; the contained <termref def="dt-sequence-constructor">sequence constructor</termref>; the
                              <code>select</code> expressions of all contained
                              <code>xsl:param</code> elements; the
                              <elcode>xsl:on-completion</elcode> element if present. </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1"><elcode>xsl:analyze-string</elcode> instruction</td>
                        <td valign="top" rowspan="1" colspan="1">The <code>select</code> expression; any expression
                           appearing in an <termref def="dt-attribute-value-template">attribute
                              value template</termref> in the <code>regex</code> or
                              <code>flags</code> attributes; the <code>xsl:matching-substring</code>
                           and <code>xsl:non-matching-substring</code> elements. </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1"><elcode>xsl:merge</elcode> instruction</td>
                        <td valign="top" rowspan="1" colspan="1">See <specref ref="expanding-xsl-merge"/>.</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1"><elcode>xsl:number</elcode> instruction</td>
                        <td valign="top" rowspan="1" colspan="1">See <specref ref="expanding-xsl-number"/>. </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1"><elcode>xsl:evaluate</elcode> instruction</td>
                        <td valign="top" rowspan="1" colspan="1">The expressions in the <code>xpath</code> and
                              <code>namespace-context</code> attributes; any expression appearing in
                           an <termref def="dt-attribute-value-template">attribute value
                              template</termref> in the <code>base-uri</code> attribute; any child
                              <elcode>xsl:with-param</elcode> elements; plus an e-node representing
                           the expression <code>preceding::*</code> (because the navigation
                           performed by the dynamic XPath expression is statically unpredictable).
                              <issue id="issue-streamable-dynamic-evaluate" status="open">
                              <p>This might be a case where deferring decisions on streamability
                                 until execution time might be appropriate. There might be scope to
                                 provide an attribute on <elcode>xsl:evaluate</elcode> that asserts
                                 streamability (perhaps <termref def="dt-motionless"/>
                                 streamability), with this assertion being checked at execution time
                                 when the actual XPath expression is known.</p>
                           </issue>
                        </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1"><elcode>xsl:sequence</elcode> instruction</td>
                        <td valign="top" rowspan="1" colspan="1">The <elcode>xsl:sequence</elcode> instruction does not need
                           to be represented by an e-node on the expression tree; it can be replaced
                           by the e-node representing its <code>select</code> expression. </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">Other XSLT instructions</td>
                        <td valign="top" rowspan="1" colspan="1">An e-node representing each XPath expression appearing in
                           an attribute of the instruction (including <termref def="dt-attribute-value-template">attribute value
                           templates</termref>), any <code>use-attribute-sets</code> attribute, plus
                           the <termref def="dt-sequence-constructor">sequence constructor</termref>
                           forming the body of the instruction, if any. </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1"><elcode>xsl:when</elcode>, <elcode>xsl:otherwise</elcode>,
                              <elcode>xsl:matching-substring</elcode>,
                              <elcode>xsl:non-matching-substring</elcode>,
                              <elcode>xsl:catch</elcode>, <elcode>xsl:on-completion</elcode>
                           element</td>
                        <td valign="top" rowspan="1" colspan="1">The contained <termref def="dt-sequence-constructor">sequence constructor</termref>.</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">XPath expressions</td>
                        <td valign="top" rowspan="1" colspan="1"><ulist>
                              <item>
                                 <p>Every XPath <termref def="dt-expression">expression</termref> is
                                    represented by an e-node whose subtree corresponds to the
                                    syntactic structure of the expression when parsed according to
                                    the XPath grammar.</p>
                              </item>
                              <item>
                                 <p>An expression that matches productions at several levels in the
                                    grammar only needs to be represented by a single e-node in the
                                    tree: for example <code>3</code> will be represented as an
                                       <code>IntegerLiteral</code>, despite being also a
                                       <code>PrimaryExpr</code>, a <code>FilterExpr</code>, a
                                       <code>StepExpr</code>, a <code>PathExpr</code>, and so
                                    on.</p>
                              </item>
                              <item>
                                 <p>Grammar productions that are not themselves expressions are not
                                    represented by further child e-nodes. For example, the
                                    expression <code>@price + 2</code> will be represented by an
                                    e-node corresponding to the <code>+</code> operator, with two
                                    children, representing the axis step
                                       <code>attribute::price</code> and the numeric literal
                                       <code>2</code> respectively. The expression <code diff="chg" at="F">@price instance of xs:decimal</code> is represented by
                                    an e-node corresponding to the operator <code>instance of
                                       xs:decimal</code>, with a single child representing the axis
                                    step <code>attribute::price</code>. This is because the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-SequenceType" xlink:type="simple">SequenceType</xnt>
                                    <code>xs:decimal</code> is not itself an <termref def="dt-expression">expression</termref> and plays no role in
                                    the streamability analysis.</p>
                              </item>
                              <item>
                                 <p>A parenthesized expression is not represented explicitly as an
                                    e-node, since the tree structure directly captures all the
                                    information conveyed by the parentheses. For example, the
                                    expression <code>$a*($b+2)</code> is represented by a tree
                                    consisting of an e-node representing the <code>*</code> operator
                                    with two children, one representing the variable reference
                                       <code>$a</code>, the other representing the <code>+</code>
                                    operator, which in turn has two children representing the
                                    operands <code>$b</code> and <code>2</code> respectively.</p>
                              </item>

                           </ulist>
                        </td>
                     </tr>
                  </tbody>
               </table>


               <example>
                  <head>An expression tree</head>
                  <p>Consider the instruction:</p>
                  <eg xml:space="preserve">&lt;xsl:stream href="books.xml"&gt;
  &lt;inventory date="{format-date(current-date(), '[D] [MNn] [Y]')}"&gt;
    &lt;xsl:value-of select="count(descendant::book)"/&gt;
  &lt;/inventory&gt;
&lt;/xsl:stream&gt;</eg>
                  <p>The expression tree for the <elcode>xsl:stream</elcode> instruction is shown
                     below:</p>
                  <note>
                     <p>Below this paragraph is an SVG diagram. To view it, you need a browser that
                        is capable of displaying SVG graphics.</p>
                  </note>


                  <g:graph>
                     <g:node label="xsl:stream">
                        <g:node label="&lt;inventory&gt;">
                           <g:node label="format-date()">
                              <g:node label="current-date()"/>
                              <g:node label="'[D] [MNn] [Y]'"/>
                           </g:node>
                           <g:node label="xsl:value-of">
                              <g:node label="count()">
                                 <g:node label="descendant::book"/>
                              </g:node>
                           </g:node>
                        </g:node>
                     </g:node>
                  </g:graph>


                  <note>
                     <p>This tree has been simplified slightly: as suggested in the rules above, the
                        e-nodes representing sequence constructors comprising a single instruction
                        have been elided. </p>
                     <p>In practice an implementation can simplify the tree further without
                        affecting the subsequent analysis. For example, leaf e-nodes representing
                        literal values can be stripped, and in many cases intermediate e-nodes
                        representing functions or operators can be elided.</p>
                  </note>
               </example>


            </div3>

            <div3 id="expanding-expr-tree">
               <head>Expanding the Expression Tree</head>
               <p>After the expression tree has been built as described in the preceding section, it
                  <rfc2119 diff="chg" at="F">must</rfc2119> be expanded to reflect the implicit navigation carried out by certain
                  instructions and expressions. The general rule here is that wherever an expression
                  appears on the tree whose evaluation might access one or more nodes, the
                  expression is rewritten as a path expression that explicitly accesses all
                  the nodes that will be required to evaluate the containing expression. Since the
                  expression tree is used only to analyze the navigation performed by the
                  stylesheet, and not actually to perform any evaluation, it is not necessary that
                  the replacement expression be semantically equivalent to the original; the
                  only requirement is that it perform equivalent navigation in the source
                  tree. For example, the expression <code>string(x)</code> can be replaced by
                     <phrase diff="chg" at="F"><code>x/descendant-or-self::text()</code></phrase>, since evaluation of the string value
                  of a node involves access to the node itself and to all its descendant text
                  nodes.</p>

               <p>The operation of expanding the tree is described here in terms of
                     source-level rewrites to certain constructs. For example, <code>data(x)</code>
                     is said to be rewritten as <code>x/descendant-or-self::text()</code>. This is
                     shorthand for saying that the part of the expression tree representing the
                     first construct is replaced by the expression tree of the second
                     construct.</p>

               <p>The most common rewrite operation is <termref def="dt-atomization">atomization</termref>. The function <xfunction>data</xfunction>, and many
                  other functions, perform atomization on the nodes supplied to their arguments.
                  Many operators, such as arithmetic and comparison operators, do the same, as also
                  do XSLT instructions like <elcode>xsl:value-of</elcode> and
                     <elcode>xsl:comment</elcode>, and <termref def="dt-attribute-value-template">attribute value templates</termref>. Atomization also occurs when a value is
                  bound to a variable declared with an atomic type, and when the result of a
                  function or template declared with an atomic type is computed. To atomize a node
                  it is necessary to access all its descendant text nodes. Any function call,
                  operator, or instruction that atomizes one or more of its operands is first 
                  rewritten to add a call on <xfunction>data</xfunction> around each such operand, and
                  this is then processed as described in the table below. For example, the
                  expression <code>item[x = 3]</code> is rewritten <code>item[data(x) = 3]</code>,
                  which is then rewritten as <code>item[child::x/descendant-or-self::text() =
                     3]</code>. </p>

               <p>In principle any expression X that appears in an atomizing context should be
                  replaced by the fragment <code>X/descendant-or-self::text()</code>. This expansion
                  is clearly unnecessary where X returns an atomic value, or indeed where it returns
                  a node other than an element or document node; and if type inferencing has shown
                  this to be the case then the expansion can be avoided. However, it does not affect
                  the streamability analysis if it is done unconditionally.</p>


               <p>The same expansion applies to expressions (such as the
                     <xfunction>string</xfunction> and <xfunction>string-length</xfunction>
                  functions) that compute the string value of the supplied node, and to the
                     <elcode>xsl:copy-of</elcode> instruction which accesses all descendant nodes.
                  It also applies to the <function>copy-of</function> and
                     <function>snapshot</function> functions, and to any instruction that invokes
                  the rules in <specref ref="constructing-complex-content"/> or <specref ref="constructing-simple-content"/>, which both implicitly copy or atomize the
                  results of instructions in a contained <termref def="dt-sequence-constructor">sequence constructor</termref>.</p>

               <p>The following table gives the expansion needed for other constructs that need
                  expanding. Some more complex constructs are discussed in the following sections.
                  Others not explicitly described <rfc2119 diff="chg" at="F">should</rfc2119> be handled by applying the same general
                  principles. Remember that in each case the rewritten expression does not need to
                  deliver the same result; its purpose is to identify the implicit navigation
                  performed by each operation and describe it in terms of axis steps.</p>
               
               <p diff="add" at="F">The expansion continues recursively until no further expansion is defined: for example
               <code>string()</code> is expanded first to <code>string(.)</code>, and then to
               <code>./descendant-or-self::text()</code>.</p>
               <table border="1" cellpadding="5">
                  <thead>
                     <tr>
                        <th rowspan="1" colspan="1">Expression</th>
                        <th rowspan="1" colspan="1">Rewrite</th>
                        <th rowspan="1" colspan="1">Notes</th>
                     </tr>
                  </thead>
                  <tbody>
                    
                     <tr>
                        <td rowspan="1" colspan="1"><code>data(X)</code></td>
                        <td rowspan="1" colspan="1"><code>X/descendant-or-self::text()</code></td>
                        <td rowspan="1" colspan="1"></td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1"><code>string(X)</code></td>
                        <td rowspan="1" colspan="1"><code>X/descendant-or-self::text()</code></td>
                        <td rowspan="1" colspan="1"></td>
                     </tr>
                     <tr diff="add" at="F">
                        <td rowspan="1" colspan="1"><code>base-uri()</code>, <code>document-uri()</code>, <code>generate-id()</code>, 
                           <code>local-name()</code>, <code>name()</code>, <code>namespace-uri()</code>, 
                        <code>normalize-space()</code>, <code>number()</code>, <code>root()</code>, 
                           <code>string()</code>, <code>string-length()</code></td>
                        <td rowspan="1" colspan="1"><code>base-uri(.)</code>, <code>document-uri(.)</code>, <code>generate-id(.)</code>, 
                           <code>local-name(.)</code>, <code>name(.)</code>, <code>namespace-uri(.)</code>, 
                           <code>normalize-space(.)</code>, <code>number(.)</code>, <code>root(.)</code>, 
                           <code>string(.)</code>, <code>string-length(.)</code></td>
                        <td rowspan="1" colspan="1">These functions take the context item as an implicit argument when called
                        with zero arguments. The expansion makes the dependency on the context item explicit.</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1"><code>copy-of(X)</code></td>
                        <td rowspan="1" colspan="1"><code>X/descendant-or-self::node()</code></td>
                        <td rowspan="1" colspan="1"></td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1"><code>snapshot(X)</code></td>
                        <td rowspan="1" colspan="1"><code>X/descendant-or-self::node()</code></td>
                        <td rowspan="1" colspan="1">The fact that the <function>snapshot</function> function also accesses
                           ancestors and their attributes can be ignored, as it does not affect the
                           subsequent analysis.</td>
                     </tr>
                     <!--<tr>
                        <td>axis step <code>axis::nodetest</code></td>
                        <td><code>./axis::nodetest</code></td>
                        <td>This rewrite ensures that all dependencies on the context item are explicit,
                           which the analysis later relies on (see <specref ref="tracing-context-path"/>).
                           The expansion is superfluous (and is not performed
                           For a free-standing axis step (one that does not appear on the
                           right-hand-side of a <code>/</code> operator) it is useful to make the
                           dependency on the context item explicit. For example <code>@price</code>
                           is rewritten as <code>./@price</code>.</td>
                     </tr>-->
                     <tr>
                        <td rowspan="1" colspan="1"><code>/</code></td>
                        <td rowspan="1" colspan="1"><code>ancestor-or-self::document-node()</code></td>
                        <td rowspan="1" colspan="1">It is useful to rewrite this as <code>self::node()</code> if it is known
                           that the context node is a document node.</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1"><code>/X</code></td>
                        <td rowspan="1" colspan="1"><code>ancestor-or-self::document-node()/X</code></td>
                        <td rowspan="1" colspan="1">It is useful to rewrite this as <code>child::X</code> if it is known
                           that the context node is a document node.</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1"><code>root(X)</code></td>
                        <td rowspan="1" colspan="1"><code>X/ancestor-or-self::node()</code></td>
                        <td rowspan="1" colspan="1">While an implementation might not need to visit all the ancestors in
                           order to find the root, the effect on streamability is the same as if it
                           did. Specifically, access to ancestor nodes is permitted in a streamable
                           expression, but access to descendants of the ancestors is not.</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1"><code>key(K, V)</code>, <code>key(K, V, R)</code></td>
                        <td rowspan="1" colspan="1"><code>(K, V, ancestor::node()/preceding::*)</code>, <code>(K, V,
                              R/preceding::*)</code></td>
                        <td rowspan="1" colspan="1">Although there are some cases where the <function>key</function>
                           function could theoretically be evaluated in streaming mode, the analysis
                           is complex and offers few benefits; the function can be viewed as a hint
                           to the processor to perform a search by building indexes or hash tables,
                           and this strategy is inconsistent with streaming. However, use of the
                           function is consistent with streaming if it is used to search a document
                           other than the streamed input document. The two-argument function
                              <code>key(K, V)</code> can be expanded to <code>key(K, V,
                              ancestor::node())</code>; the third argument <code>R</code> can then
                           be expanded to <code>R/preceding::*</code>.</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1"><code>id(V)</code> and <code>id(V, R)</code></td>
                        <td rowspan="1" colspan="1"><code>(V, ancestor::node()/preceding::*)</code>, <code>(V,
                              R/preceding::*)</code></td>
                        <td rowspan="1" colspan="1">Although the <xfunction>id</xfunction> function could in many cases be
                           evaluated in streaming mode, doing so is unlikely to be useful in
                           practice. This is because detecting that an element has the required ID
                           value in the case of ID-valued element content (as distinct from
                           attribute content) requires reading the descendants of the element, and
                           this leaves little scope for the application to do anything useful with
                           the element once it has been found. Therefore, the
                              <xfunction>id</xfunction> is considered non-streamable if applied to the
                           streamed input document. This is reflected in the expression tree by
                           first expanding the second argument of the function (defaulting it to
                              <code>ancestor::node()</code>), and then </td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1"><code>element-with-id(V)</code> and <code>element-with-id(V,
                           R)</code></td>
                        <td rowspan="1" colspan="1"><code>(V, ancestor::node()/preceding::*)</code>, <code>(V,
                              R/preceding::*)</code></td>
                        <td rowspan="1" colspan="1">See <xfunction>id</xfunction> function above.</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1"><code>lang(L)</code></td>
                        <td rowspan="1" colspan="1"><code>ancestor-or-self::*/@xml:lang = L</code></td>
                        <td rowspan="1" colspan="1">This will generally be streamable, assuming <code>L</code> does not
                           navigate within the streamed input document.</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1"><code>lang(L, N)</code></td>
                        <td rowspan="1" colspan="1"><code>N/ancestor-or-self::*/@xml:lang = L</code></td>
                        <td rowspan="1" colspan="1"></td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1"><code>unparsed-entity-uri(N), unparsed-entity-public-id(N)</code></td>
                        <td rowspan="1" colspan="1"><code>ancestor-or-self::document-node()</code></td>
                        <td rowspan="1" colspan="1">This will generally be streamable. A streaming processor is expected to
                           retain the unparsed entities declared on the streamed input document.
                              <issue id="issue-unparsed-entities-not-at-start" status="open">
                              <p>There is an edge-case problem here: comments and processing
                                 instructions can precede the <code>DOCTYPE</code> declaration, and
                                 while processing such comments and processing instructions, the
                                 unparsed entities referenced in the DTD are not yet known. A
                                 possible solution would be to require buffering of such comments
                                 and processing instructions until the DTD has been read. Note that
                                 the path analysis can establish that a stylesheet makes reference
                                 to unparsed entities in the streamed document, so it might be
                                 possible to provide this capability without imposing any costs on
                                 users who don't use it.</p>
                              <p>Another problem with similar consequences is that an expression
                                 such as <code>/ instance of document-node(element(A))</code> cannot
                                 be evaluated until the first element start tag has been
                                 processed.</p>
                           </issue></td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1"><code>xsl:copy-of select="N"</code></td>
                        <td rowspan="1" colspan="1"><code>N/descendant-or-self::node()</code></td>
                        <td rowspan="1" colspan="1"></td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1"><code>xsl:copy</code> with no <code>select</code> attribute</td>
                        <td rowspan="1" colspan="1"><code>&lt;xsl:copy select="."/&gt;</code></td>
                        <td rowspan="1" colspan="1"></td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1"><code>xsl:merge-source</code> with no <code>select</code> attribute</td>
                        <td rowspan="1" colspan="1"><code>&lt;xsl:merge-source select="."/&gt;</code></td>
                        <td rowspan="1" colspan="1"></td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1"><code>xsl:number</code></td>
                        <td rowspan="1" colspan="1">See <specref ref="expanding-xsl-number"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1"><code>xsl:evaluate xpath="EXP"</code></td>
                        <td rowspan="1" colspan="1"><code>EXP, preceding::*</code></td>
                        <td rowspan="1" colspan="1">As well as any navigation needed to evaluate the expression given in the
                              <code>xpath</code> attribute, the instruction evaluates the
                           expression, which may perform unpredictable navigation from the context
                           item. This is reflected by adding an e-node representing the
                           non-streamable <code>preceding::*</code> step to the expression tree.
                        </td>
                     </tr>
                  </tbody>

               </table>



               <div4 id="expanding-xsl-number">
                  <head>Expanding the <code>xsl:number</code> instruction</head>

                  <p>In general, the <code>xsl:number</code> instruction is not 
                     <termref def="dt-guaranteed-streamable"/> because
                     it computes a number by navigating backwards through the document to count
                     preceding nodes. However, there are several common cases where streamed
                     evaluation of <elcode>xsl:number</elcode> is possible.</p>

                  <olist>
                     <item>
                        <p>When the <elcode>xsl:number</elcode> instruction has a <code>value</code>
                           attribute, it can be expanded in the expression tree in the same way as
                           any other construct. Its children in the tree are the <code>value</code>
                           expression, plus any expressions that appear within <termref def="dt-attribute-value-template">attribute value templates</termref>
                           in other attributes of the instruction.</p>
                     </item>

                     <item>
                        <p>When <elcode>xsl:number</elcode> has no <code>value</code> attribute,
                           streamed evaluation is possible if the node selected by the
                              <code>select</code> expression (or its default, <code>.</code> (dot))
                           is in a document other than the streamed input document</p>
                     </item>

                     <item>
                        <p>When the selected node is in the streamed input document and
                              <code>level="single"</code> or <code>level="multiple"</code> is
                           specified, streaming is possible if the following conditions are
                           true:</p>
                        <olist>
                           <item>
                              <p>The <code>count</code> attribute is either omitted, or is a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-NodeTest" xlink:type="simple">NodeTest</xnt>.</p>
                           </item>
                           <item>
                              <p>The <code>from</code> attribute is either omitted, or is a <termref def="dt-streamable-pattern">streamable pattern</termref></p>
                           </item>
                           <item>
                              <p>The instruction satisfies the general constraints on streamability
                                 that apply to every <termref def="dt-construct">construct</termref>: for example, the XPath expressions appearing
                                 in the instruction (<phrase diff="chg" at="F">the <code>select</code> expression</phrase> and
                                 any <termref def="dt-attribute-value-template">attribute value
                                    templates</termref>) do not make multiple downward
                                 selections.</p>
                           </item>
                        </olist>
                        <p>The reason that the <code>count</code> pattern is restricted to be a
                           simple <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-NodeTest" xlink:type="simple">NodeTest</xnt> is
                           that it is applied to preceding-siblings of the node that is being
                           numbered. The processing model assumes that the processor will maintain
                           limited information about the number of preceding-siblings of the current
                           node and all its ancestors, specifically, the number of preceding
                           siblings for every combination of node-kind, node-name, and
                           type-annotation. This information is sufficient to establish how many
                           preceding siblings match any given <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-NodeTest" xlink:type="simple">NodeTest</xnt>, but it is not sufficient
                           to do the same for an arbitrary <termref def="dt-pattern">pattern</termref>, even a <termref def="dt-streamable-pattern">streamable pattern</termref>.</p>

                        <p>By contrast, the <code>from</code> pattern is applied only to the node
                           being numbered and its ancestors, and for these nodes there is sufficient
                           information to test any <termref def="dt-streamable-pattern">streamable
                              pattern</termref>.</p>
                     </item>
                     <item>
                        <p>When the selected node is in the <termref def="dt-streamed-document">streamed document</termref> and
                              <code>level="any"</code> is specified, streaming can be
                           achieved by tallying the counted nodes as they are encountered in the
                           input stream, so that the count is already available when the selected
                           node comes to be read. This requires analysis of the stylesheet to
                           determine all <code>xsl:number level="any"</code> instructions that could
                           possibly be evaluated on nodes in the streamed document. The relevant
                           instructions are those that appear in the data flow graph (see <specref ref="analyzing-navigation"/>) on paths emanating from the construct
                           whose streamability is being analyzed.</p>
                        <p>These <elcode>xsl:number</elcode> instructions <rfc2119>must</rfc2119> satisfy the following
                           conditions for streaming to be possible:</p>
                        <olist>
                           <item>
                              <p>The <code>count</code> attribute is present, and is a <termref def="dt-streamable-pattern">streamable pattern</termref>. (An
                                 implementation might be able to relax this condition by allowing
                                 the <code>count</code> attribute to be omitted in cases where the
                                 node-kind and node-name of the context node can be determined by
                                 static analysis. However, this analysis is outside the scope of
                                 this specification, so such instructions are not <termref def="dt-guaranteed-streamable"/>.)</p>
                           </item>
                           <item>
                              <p>The <code>from</code> attribute is either omitted, or is a <termref def="dt-streamable-pattern">streamable pattern</termref>.</p>
                           </item>
                           <item>
                              <p>The <code>select</code> attribute takes its default value of
                                    <code>.</code> (dot).</p>
                           </item>
                           <item>
                              <p>The instruction satisfies the general constraints on streamability
                                 that apply to every <termref def="dt-construct">construct</termref>: for example, the <termref def="dt-attribute-value-template">attribute value
                                    templates</termref> used in the instruction do not make
                                 multiple downward selections.</p>
                           </item>
                        </olist>
                        <p>A possible implementation strategy is then for the processor, while
                           reading nodes from the input stream, to test every node against the
                              <code>from</code> and <code>count</code> patterns of each reachable
                              <code>xsl:number level="any"</code> instruction. For each such
                           instruction, a counter is maintained. When a node matches the
                              <code>from</code> pattern, the counter is reset to zero. When it
                           matches the <code>count</code> pattern, the counter is incremented. When
                           the <elcode>xsl:number</elcode> instruction is then evaluated against the
                           context node, the relevant counter already contains the required
                           number.</p>
                     </item>
                  </olist>



                  <p>Although <code>xsl:number</code> is specified in terms of XPath expressions
                     that navigate to nodes that precede the context node in document order, this
                     navigation does not need to be represented in the expression tree, because a
                     streaming implementation is expected to maintain counters as the stream is read
                     to make such navigation unnecessary.</p>

                  <p>So the effect on the expression tree is as follows:</p>

                  <olist>
                     <item>
                        <p>The <elcode>xsl:number</elcode> e-node is given children corresponding to
                           the <code>select</code> and <code>value</code> expressions, and to any
                           expressions contained in attribute value templates, in the normal
                           way.</p>
                     </item>
                     <item>
                        <p diff="chg" at="F">If the instruction is not streamable according to the rules given above, then the
                              <elcode>xsl:number</elcode> expression <code>N</code> is expanded to <code>N/preceding::*</code> to
                           indicate non-streamable navigation.</p>
                     </item>
                  </olist>


               </div4>

               <div4 id="expanding-xsl-merge">
                  <head>Expanding the <code>xsl:merge</code> instruction</head>

                  <p>If <elcode>xsl:merge</elcode> instruction takes its input by navigating from
                     the <termref def="dt-context-node"/>, then the streamability rules are the same
                     as for any other instruction. For example, the following construct is not
                     <termref def="dt-guaranteed-streamable"/>
                     because it makes two downwards selections from the context item (to
                     the elements <code>credits</code> and <code>debits</code>):</p>

                  <eg xml:space="preserve">&lt;xsl:merge&gt;
  &lt;xsl:merge-source select="credits, debits"&gt;
    &lt;xsl:merge-input select="transaction"&gt;
      &lt;xsl:merge-key select="timestamp"/&gt;
    &lt;/xsl:merge-input
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:copy-of select="current-group()"/&gt;
  &lt;/xsl:merge-action&gt;
&lt;/xsl:merge</eg>

                  <p>Similarly, the following is not streamable, for the same reason:</p>

                  <eg xml:space="preserve">&lt;xsl:merge&gt;
  &lt;xsl:merge-source select="credits"&gt;
    &lt;xsl:merge-input select="transaction"&gt;
      &lt;xsl:merge-key select="timestamp"/&gt;
    &lt;/xsl:merge-input&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-source select="debits"&gt;
    &lt;xsl:merge-input select="transaction"/&gt;
    &lt;xsl:merge-key select="timestamp"/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:copy-of select="current-group()"/&gt;
  &lt;/xsl:merge-action&gt;
&lt;/xsl:merge</eg>

                  <p>If <elcode>xsl:merge</elcode> is to operate on streamed input, this is achieved
                     by using <elcode>xsl:stream</elcode> within the
                        <elcode>xsl:merge-input</elcode> instruction. The streamability then depends
                     on analysis of the <elcode>xsl:stream</elcode> instruction alone.</p>

                  <p>For the purposes of this analysis, therefore, <elcode>xsl:merge</elcode> is not
                     essentially different from any other instruction. The structure in the
                     expression tree matches the syntactic structure:</p>

                  <ulist>
                     <item>
                        <p>The e-node representing the <elcode>xsl:merge</elcode> element has one
                           child for each <elcode>xsl:merge-source</elcode> element, and one for the
                              <elcode>xsl:merge-action</elcode>.</p>
                     </item>
                     <item>
                        <p>The e-node representing the <elcode>xsl:merge-source</elcode> element has
                           one child for the <code>select</code> expression and one for the
                              <elcode>xsl:merge-input</elcode> element.</p>
                     </item>
                     <item>
                        <p>The e-node representing the <elcode>xsl:merge-input</elcode> element has
                           one child for its <code>select</code> attribute or contained sequence
                           constructor, plus additional children for the expressions contained in
                           any <elcode>xsl:merge-key</elcode> children.</p>
                     </item>
                  </ulist>

                  <p>In the subsequent analysis, as explained in later sections, it is necessary to
                     take account of the fact that (a) the <code>select</code> expressions of both
                        <elcode>xsl:merge-source</elcode> and <elcode>xsl:merge-input</elcode>
                     change the <termref def="dt-focus">focus</termref>, and (b) some of the
                     contained expressions are evaluated repeatedly, meaning that
                        <elcode>xsl:merge</elcode> <phrase diff="chg" at="F">is
                     treated as a looping construct (see <specref ref="expr-tree-loops"/>)</phrase> .</p>
               </div4>
            </div3>

            <div3 id="analyzing-navigation">
               <head>Analyzing Navigation</head>

               <p>Having built the expression tree, the next step is to analyze where <termref def="dt-construct">constructs</termref> derive their input. The objective here
                  is twofold:</p>

               <ulist>
                  <item>
                     <p>Firstly, it is necessary to determine which <termref def="dt-construct">constructs</termref> operate on data that comes from the 
                        <phrase diff="chg" at="F"><termref def="dt-streamed-document"/></phrase>. If a
                        construct is actually operating on other (non-streamed) input documents,
                        then it is able to access that data without constraints.</p>
                  </item>
                  <item>
                     <p>Secondly, where constructs operate on the streamed document, it is
                        necessary to determine whether they do so in a way that permits streaming.
                        This requires analysis of the navigation paths through the
                        streamed document.</p>
                  </item>
               </ulist>

               <p>This analysis creates a new graph, <phrase diff="add" at="F">known as the <term>data flow graph</term>,</phrase> 
                  showing a different kind of relationship between
                  the <termref def="dt-e-node">e-nodes</termref> of the expression tree: the arcs in
                  this graph show where nodes returned by one construct are used as input to another
                  construct. These data flows can arise in a number of ways:</p>

               <ulist>
                  <item>
                     <p>A child construct can return nodes that participate directly in the result
                        of its parent construct. For example, when the <code>union</code> operator
                        is used, the result of the union expression includes the nodes returned by
                        both its operand expressions.</p>
                  </item>
                  <item>
                     <p>When a variable is bound to a node or nodes, there is a data flow from the
                        construct used to initialize the variable to every variable reference that
                        refers to this variable binding.</p>
                  </item>
                  <item>
                     <p>When a construct sets the context item, there is a data flow from the child
                        construct that sets the context item to every context-dependent construct
                        that uses this new context.</p>
                  </item>
                  <item>
                     <p>When a construct calls a <termref def="dt-stylesheet-function">stylesheet
                           function</termref> or a <termref def="dt-named-template">named
                           template</termref>, there is a data flow from the construct that sets the
                        value of a parameter to the function or template to the variable binding in
                        the called function or template.</p>
                  </item>
                  <item>
                     <p>When parameters are supplied from one iteration of
                           <elcode>xsl:iterate</elcode> to the next using
                           <elcode>xsl:with-param</elcode> elements within
                           <elcode>xsl:next-iteration</elcode>, there is a data flow from the
                           <elcode>xsl:with-param</elcode> element that sets the parameter value to
                        the <elcode>xsl:param</elcode> element that receives it.</p>
                  </item>
               </ulist>

               <p>The following sections describe in more detail how these data flows are modeled.
                  In all cases they result in arcs being added to the data flow graph.</p>

               <div4 id="marking-contributing-expr">
                  <head>Marking contributing child constructs</head>

                  <p>An arc is created in the data flow graph from any <termref def="dt-e-node">e-node</termref> to its parent in the expression tree if the child <termref def="dt-construct">construct</termref> returns <xtermref spec="DM11" ref="dt-node">nodes</xtermref> that form part of the result of the parent
                     construct.</p>

                  <p>The following table lists constructs that return nodes contributed by one of
                     their child constructs, referred to as a <term>contributing
                     construct</term>.</p>

                  <table border="1">
                     <thead>
                        <tr>
                           <th rowspan="1" colspan="1">Construct</th>
                           <th rowspan="1" colspan="1">Contribution</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td rowspan="1" colspan="1">Path expression <code>A/B</code></td>
                           <td rowspan="1" colspan="1"><code>B</code> is a contributing construct.</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">Filter expression <code>S[P]</code></td>
                           <td rowspan="1" colspan="1"><code>S</code> is a contributing construct.</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">Union expression <code>P|Q</code></td>
                           <td rowspan="1" colspan="1"><code>P</code> and <code>Q</code> are both contributing
                              constructs.</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">Difference expression <code>P except Q</code></td>
                           <td rowspan="1" colspan="1"><code>P</code> is a contributing construct.</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">Intersection expression <code>P intersect Q</code></td>
                           <td rowspan="1" colspan="1"><code>P</code> and <code>Q</code> are both contributing constructs.
                                 <issue id="issue-intersect" status="open">
                                 <p>It might be safe to treat one of the operands as
                                    non-contributing, but the Working Group has not been able to
                                    demonstrate this to its satisfaction. Note that if one of the
                                    operands selects nodes from the streamed input and the other
                                    does not, then the intersection will not contain any nodes from
                                    the streamed input.</p>
                              </issue></td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">Comma expression <code>P, Q</code></td>
                           <td rowspan="1" colspan="1"><code>P</code> and <code>Q</code> are both contributing
                              constructs.</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><termref def="dt-sequence-constructor">Sequence
                              constructor</termref></td>
                           <td rowspan="1" colspan="1">The <termref def="dt-instruction">instructions</termref> within the
                              sequence constructor are all contributing constructs. </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">XSLT variable binding (<elcode>xsl:variable</elcode>,
                                 <elcode>xsl:param</elcode>, <elcode>xsl:with-param</elcode>)</td>
                           <td rowspan="1" colspan="1">The initializer of the variable binding (that is, the
                                 <code>select</code> expression or the contained sequence
                              constructor) is a contributing construct. However, in the case where
                              there is no <code>as</code> attribute, so a new document node is
                              created, the sequence constructor is not a contributing construct.
                              Also, the initializer is not a contributing construct in the case
                              where the variable is declared with an atomic type, as any nodes
                              delivered by the initializer will then be atomized. The implicit
                              navigation required to perform this atomization must be made explicit
                              on the expression tree.</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">XPath variable binding (<code>for</code>, <code>let</code>)</td>
                           <td rowspan="1" colspan="1">In the case of <code>for</code> and <code>let</code> expressions, the
                              expression in the <code>return</code> clause is a contributing
                              expression to the result of the <code>for</code> or <code>let</code>
                              expression. In the case of <code>some</code> and <code>every</code>
                              expressions, the result is a boolean, so there is no contributing
                              subexpression. </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">Conditional <code>if (C) then T else E</code></td>
                           <td rowspan="1" colspan="1"><code>T</code> and <code>E</code> are both contributing constructs
                                 (<code>C</code> is not). This applies whether the conditional
                              originated as an XPath <code>if</code> expression, or as an
                                 <elcode>xsl:if</elcode> or <elcode>xsl:choose</elcode>
                              instruction.</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">Instructions <elcode>xsl:for-each</elcode>,
                                 <elcode>xsl:for-each-group</elcode>, <phrase diff="add" at="F"><elcode>xsl:stream</elcode></phrase></td>
                           <td rowspan="1" colspan="1">The contained <termref def="dt-sequence-constructor">sequence
                                 constructor</termref> is a contributing construct.</td>
                        </tr>
                        <tr diff="add" at="F">
                           <td rowspan="1" colspan="1">Instruction <elcode>xsl:iterate</elcode></td>
                           <td rowspan="1" colspan="1">The contained <termref def="dt-sequence-constructor">sequence
                           constructor</termref> and the <elcode>xsl:on-completion</elcode>
                              child are contributing constructs.</td>
                        </tr>
                        <tr diff="add" at="F">
                           <td rowspan="1" colspan="1">Instruction <elcode>xsl:perform-sort</elcode></td>
                           <td rowspan="1" colspan="1">The <code>select</code> expression and the contained <termref def="dt-sequence-constructor">sequence
                              constructor</termref> are contributing constructs.</td>
                        </tr>
                        <tr diff="add" at="F">
                           <td rowspan="1" colspan="1">Instruction <elcode>xsl:analyze-string</elcode></td>
                           <td rowspan="1" colspan="1">The <elcode>xsl:matching-substring</elcode> and <elcode>xsl:non-matching-substring</elcode>
                              children are contributing constructs.</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">Instruction <elcode>xsl:merge</elcode></td>
                           <td rowspan="1" colspan="1">The contained <elcode>xsl:merge-action</elcode> element is a
                              contributing construct.</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">Instruction <elcode>xsl:try</elcode></td>
                           <td rowspan="1" colspan="1">The contained <termref def="dt-sequence-constructor">sequence
                                 constructor</termref> and each contained <elcode>xsl:catch</elcode>
                              element is a contributing construct.</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">Elements <elcode>xsl:when</elcode>, <elcode>xsl:otherwise</elcode>,
                                 <elcode>xsl:matching-substring</elcode>,
                                 <elcode>xsl:non-matching-substring</elcode>,
                                 <elcode>xsl:catch</elcode>, <elcode>xsl:on-completion</elcode>,
                                 <elcode>xsl:merge-action</elcode></td>
                           <td rowspan="1" colspan="1">The contained <termref def="dt-sequence-constructor">sequence
                                 constructor</termref> is a contributing construct.</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">Functions <xfunction>remove</xfunction>,
                                 <xfunction>subsequence</xfunction>, <xfunction>reverse</xfunction>,
                                 <xfunction>trace</xfunction>, <xfunction>unordered</xfunction>,
                                 <xfunction>one-or-more</xfunction>,
                                 <xfunction>exactly-one</xfunction>,
                                 <xfunction>zero-or-one</xfunction>, <function>innermost</function>,
                                 <function>outermost</function></td>
                           <td rowspan="1" colspan="1">The first argument is a contributing construct.</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">Function <xfunction>insert-before</xfunction></td>
                           <td rowspan="1" colspan="1">The first and third arguments are contributing constructs.</td>
                        </tr>

                        <tr>
                           <td rowspan="1" colspan="1">Operation <code>sort</code> (the e-node that is added to the tree by
                              operations that perform sorting)</td>
                           <td rowspan="1" colspan="1">The subexpression representing the <code>select</code> expression
                              (the sequence being sorted) is a contributing construct.</td>
                        </tr>
                     </tbody>
                  </table>

               </div4>
               <div4 id="tracing-variable-references">
                  <head>Analyzing variable references</head>
                  <p>In the data flow graph, an arc is created from a variable binding construct to
                     every variable reference that refers to that variable.</p>
                  <example>
                     <head>Data flow with variables</head>
                     <p>Consider the construct:</p>
                     <eg xml:space="preserve">
&lt;xsl:template name="example"&gt;
  &lt;xsl:variable name="doc-A" select="doc('a.xml')"/&gt;
  &lt;xsl:stream href="b.xml"&gt;
    &lt;xsl:sequence 
         select="count($doc-A/descendant::*) + count(descendant::*)"/&gt;
  &lt;/xsl:stream&gt;
&lt;/xsl:template&gt;</eg>

                     <p>The expression tree for this template is as follows (note that sequence
                        constructors containing a single instruction have again been elided):</p>
                     <g:graph>
                        <g:node label="xsl:template">
                           <g:node id="sequence_constructor" label="sequence constructor">
                              <g:node id="var_decl" label="xsl:variable doc-A">
                                 <g:node id="var_init" label="doc()">
                                    <g:node label="'a.xml'"/>
                                 </g:node>
                              </g:node>
                              <g:node label="xsl:stream">
                                 <g:node label="'b.xml'"/>
                                 <g:node label="plus">
                                    <g:node label="count()">
                                       <g:node id="path2" label="path">
                                          <g:node id="var_ref" label="$doc-A"/>
                                          <g:node id="desc2" label="descendant::*"/>
                                       </g:node>
                                    </g:node>
                                    <g:node label="count()">
                                       <g:node id="path1" label="path">
                                          <g:node label="."/>
                                          <g:node id="desc1" label="descendant::*"/>
                                       </g:node>
                                    </g:node>

                                 </g:node>
                              </g:node>
                           </g:node>
                        </g:node>
                     </g:graph>
                     <p>After adding the links from contributing subexpressions to their parent
                        expression, and from the variable declaration to its reference, the data
                        flow graph is like this:</p>
                     <g:graph>
                        <g:node label="xsl:template">
                           <g:node id="sequence_constructor" label="sequence constructor">
                              <g:node id="var_decl" label="xsl:variable doc-A">
                                 <g:node id="var_init" label="doc()">
                                    <g:node label="'a.xml'"/>
                                 </g:node>
                              </g:node>
                              <g:node label="xsl:stream">
                                 <g:node label="'b.xml'"/>
                                 <g:node label="plus">
                                    <g:node label="count()">
                                       <g:node id="path2" label="path">
                                          <g:node id="var_ref" label="$doc-A"/>
                                          <g:node id="desc2" label="descendant::*"/>
                                       </g:node>
                                    </g:node>
                                    <g:node label="count()">
                                       <g:node id="path1" label="path">
                                          <g:node label="."/>
                                          <g:node id="desc1" label="descendant::*"/>
                                       </g:node>
                                    </g:node>

                                 </g:node>
                              </g:node>
                           </g:node>
                        </g:node>
                        <g:edge from="var_init" to="var_decl" color="red" constraint="false"/>
                        <g:edge from="var_decl" to="var_ref" color="red" constraint="false"/>
                        <g:edge from="desc1" to="path1" color="red" constraint="false"/>
                        <g:edge from="desc2" to="path2" color="red" constraint="false"/>
                     </g:graph>
                  </example>

               </div4>

               <div4 id="tracing-context-path">
                  <head>Tracing the Context of an Expression</head>

                  <p diff="chg" at="F">In the same way as the previous step created arcs in the data flow graph from
                     an <termref def="dt-e-node">e-node</termref> representing a variable
                     declaration to an e-node representing a variable reference, this step creates
                     an arc from an e-node representing a <termref def="dt-construct">construct</termref> that sets the context item to an e-node representing a
                     reference to the context item. This creates one arc pointing to each e-node
                  representing any of the following:</p>
 

                  <ulist>
                     <item>
                        <p>The context item expression <code>.</code></p>
                     </item>
                     <item>
                        <p>An axis step, for example <code>@status</code></p>
                     </item>
                     <item>
                        <p diff="add" at="F">The expression <code>last()</code> (but not <code>position()</code>,
                           since calls on the <xfunction>position</xfunction> function never affect
                           the streamability analysis).</p>
                     </item>
                  </ulist>
                  
                  <note diff="chg" at="F"><p>Other expressions that might appear to be
                     dependent on the context item have already been rewritten to make the dependency explicit:
                     for example <code>name()</code> has been rewritten as <code>name(.)</code>, while
                     <code>/</code> has been rewritten as <code>ancestor-or-self::document-node()</code>, 
                     as described in <specref ref="expanding-expr-tree"/></p>
                     <p>It would be possible to handle axis steps in the same way, by rewriting
                     <code>@status</code> as <code>./@status</code>. However, if applied repeatedly,
                     the resulting expression would be expanded again, leading to infinite recursion.</p></note>

                  <p>The instructions <elcode>xsl:apply-templates</elcode>,
                        <elcode>xsl:apply-imports</elcode>, and <elcode>xsl:next-match</elcode> are
                     not considered to depend on the context item: they are considered separately:
                     see <specref ref="streamability-of-dynamic-invocation"/></p>

                  <p diff="chg" at="F">The origin of the arc is the construct that sets the context item for this
                     expression. This is found by searching for the nearest ancestor e-node 
                     that represents a construct that changes the focus. 
                     An example of such an construct is a path expression
                        <code>A/B</code>. This has two subexpressions: <code>A</code>, which sets
                     the focus, and <code>B</code>, which is evaluated with the new focus. Other context-changing
                     constructs similarly have a child construct that acts as focus setter and
                     another (or several) that are evaluated using the new focus. These are shown in the table
                     below:</p>

                  <table border="1" cellpadding="5">
                     <thead>
                        <tr>
                           <th align="left" rowspan="1" colspan="1">Construct</th>
                           <th align="left" rowspan="1" colspan="1">Context-setting construct</th>
                           <th align="left" rowspan="1" colspan="1">Construct(s) evaluated with the new focus</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td rowspan="1" colspan="1">Path expression A/B</td>
                           <td rowspan="1" colspan="1">A</td>
                           <td rowspan="1" colspan="1">B</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">Filter expression A[B]</td>
                           <td rowspan="1" colspan="1">A</td>
                           <td rowspan="1" colspan="1">B</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><elcode>xsl:for-each</elcode></td>
                           <td rowspan="1" colspan="1"><code>select</code> expression</td>
                           <td rowspan="1" colspan="1">the contained sequence constructor, and the <code>select</code>
                              attributes of any <elcode>xsl:sort</elcode> keys</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><elcode>xsl:for-each-group</elcode></td>
                           <td rowspan="1" colspan="1"><code>select</code> expression</td>
                           <td rowspan="1" colspan="1">the contained sequence constructor, and the <code>select</code>
                              attributes of any <elcode>xsl:sort</elcode> keys</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><elcode>xsl:iterate</elcode></td>
                           <td rowspan="1" colspan="1"><code>select</code> expression</td>
                           <td rowspan="1" colspan="1">the contained sequence constructor <phrase diff="add" at="F">and 
                           any <elcode>xsl:on-completion</elcode> child</phrase></td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><elcode>xsl:analyze-string</elcode></td>
                           <td rowspan="1" colspan="1"><code>select</code> expression</td>
                           <td rowspan="1" colspan="1">the sequence constructors within the
                                 <elcode>xsl:matching-substring</elcode> and
                                 <elcode>xsl:non-matching-substring</elcode> children</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><elcode>xsl:stream</elcode></td>
                           <td rowspan="1" colspan="1">the <code>xsl:stream</code> instruction itself</td>
                           <td rowspan="1" colspan="1">the contained sequence constructor</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><elcode>xsl:perform-sort</elcode></td>
                           <td rowspan="1" colspan="1"><code>select</code> expression <phrase diff="add" at="F">or the contained <termref def="dt-sequence-constructor">sequence constructor</termref></phrase></td>
                           <td rowspan="1" colspan="1">the <code>select</code> expressions of the <elcode>xsl:sort</elcode>
                              keys</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><elcode>xsl:merge-source</elcode></td>
                           <td rowspan="1" colspan="1"><code>select</code> expression</td>
                           <td rowspan="1" colspan="1">the <code>select</code> expression or the contained <termref def="dt-sequence-constructor">sequence constructor</termref> of the
                                 <elcode>xsl:merge-input</elcode> children</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><elcode>xsl:merge-input</elcode></td>
                           <td rowspan="1" colspan="1"><code>select</code> expression or the contained <termref def="dt-sequence-constructor">sequence constructor</termref></td>
                           <td rowspan="1" colspan="1">the <code>select</code> expressions of the
                                 <elcode>xsl:merge-key</elcode> children, and the
                                 <elcode>xsl:merge-action</elcode> element. Note that context for
                              the <elcode>xsl:merge-action</elcode> element is set by each of the
                                 <elcode>xsl:merge-input</elcode> elements, so in general there will
                              be multiple arcs to the <elcode>xsl:merge-action</elcode> e-node.
                           </td>
                        </tr>
                     </tbody>
                  </table>

                  <p>Having found an <termref def="dt-e-node">e-node</termref>
                     <var>E</var> that represents a context-dependent construct, the relevant
                     context-setting construct can be found by searching the ancestors of the e-node
                     until a context-changing construct <var>C</var> is found, provided that
                        <var>E</var> is within the subexpression that uses the new context. The
                     context-setting construct is then the subexpression of <var>C</var> that sets
                     the context item, shown in the table above.</p>

                  <p>If the search for ancestor e-nodes finds no context-changing construct, then
                     the context-setting construct is deemed to be the e-node at the root of the
                     tree, for example an e-node representing an <elcode>xsl:template</elcode>
                     declaration.</p>

                  <example>
                     <head>Adding context arcs to the data flow graph</head>
                     <p>This example builds on the example in the previous section. After adding the
                        links from context-setting constructs to context-using constructs, the data
                        flow graph is like this:</p>
                     <g:graph>
                        <g:node label="xsl:template">
                           <g:node id="var_decl" label="xsl:variable doc-A">
                              <g:node id="var_init" label="doc()">
                                 <g:node label="'a.xml'"/>
                              </g:node>
                           </g:node>
                           <g:node id="stream" label="xsl:stream">
                              <g:node label="'b.xml'"/>
                              <g:node label="plus">
                                 <g:node label="count()">
                                    <g:node id="path2" label="path">
                                       <g:node id="var_ref" label="$doc-A"/>
                                       <g:node id="desc2" label="descendant::*"/>
                                    </g:node>
                                 </g:node>
                                 <g:node label="count()">
                                    <g:node id="path1" label="path">
                                       <g:node id="dot" label="."/>
                                       <g:node id="desc1" label="descendant::*"/>
                                    </g:node>
                                 </g:node>
                              </g:node>
                           </g:node>
                        </g:node>
                        <g:edge from="var_init" to="var_decl" color="red" constraint="false"/>
                        <g:edge from="var_decl" to="var_ref" color="red" constraint="false"/>
                        <g:edge from="desc1" to="path1" color="red" constraint="false"/>
                        <g:edge from="desc2" to="path2" color="red" constraint="false"/>
                        <g:edge from="dot" to="desc1" color="red" constraint="false"/>
                        <g:edge from="var_ref" to="desc2" color="red" constraint="false"/>
                        <g:edge from="stream" to="dot" color="red" constraint="false"/>
                     </g:graph>
                     <p>It can now be clearly seen that there are two navigation paths performed by
                        this template, from document <code>a.xml</code> to its descendant elements,
                        and from <code>b.xml</code> to its descendant elements. The streamability
                        analysis will in due course examine the paths in the data flow graph
                        emanating from the e-node representing the <elcode>xsl:stream</elcode>
                        instruction to determine whether they conform to the rules for streamable
                        navigation (which they do).</p>
                     <p>The navigation paths relating to <code>a.xml</code> do not need to be
                        streamable, because this document is being accessed using non-streaming
                        interfaces; however, it is necessary to construct the paths before it can be
                        determined which document is being accessed by which expressions.</p>
                  </example>

                  <p>There are some special cases:</p>
                  <olist>
                     <item>
                        <p>If <var>E</var> represents a call on the function
                              <function>current</function>, then the search for a context-changing
                           ancestor e-node skips all e-nodes that represent containing XPath
                           expressions (that is, the search only considers XSLT constructs that set
                           the context).</p>
                     </item>
                     <item>
                        <p>If <var>E</var> represents a call on the function
                              <function>current-group</function>, that appears nested within an
                              <elcode>xsl:for-each-group</elcode> instruction that is itself within
                           the expression tree, is treated as if it were the axis step
                              <code>child::node()</code>. Although this bears no relationship to the
                           actual navigation path in the source tree, it has the correct result in
                           the context of streamability analysis. This is because grouping
                           essentially performs two nested iterations over the items in an input
                           sequence (one over the groups, one over the items of each group) and this
                           processing structure is the same as if there were an extra level of nodes
                           in the source tree. If there is no enclosing
                              <elcode>xsl:for-each-group</elcode> instruction within the expression
                           tree (which is possible because the <termref def="dt-current-group">current group</termref> has dynamic scope) then the call on
                              <function>current-group</function> can be treated as if it were a
                           reference to a global variable; it has no bearing on the path
                           analysis.</p>

                     </item>
                  </olist>
                  
                  <issue id="issue-streamability-of-grouping" status="open">
                     <p>The analysis of the streamability of grouping needs a more thorough exposition; although
                     the rules given might well be correct, they are not convincingly explained.</p>                     
                  </issue>

                  <p>At this stage it is possible to detect some conditions that will render an
                     expression non-streamable, without the need to do further analysis. If we are
                     testing an <elcode>xsl:stream</elcode> or <elcode>xsl:template</elcode>
                     construct for streamability, then if any of the following e-nodes are present
                     on a path in the data flow graph starting at that construct, the construct is
                     not streamable:</p>

                  <ulist>
                     <item>
                        <p>An axis step using any of the axes <code>following-sibling</code>,
                              <code>preceding-sibling</code>, <code>following</code>, or
                              <code>preceding</code></p>
                     </item>
                     <item>
                        <p>A call on the <xfunction>last</xfunction> function</p>
                     </item>
                     <item>
                        <p>A <code>sort</code> node</p>
                     </item>
                     <item>
                        <p>A call on the <xfunction>reverse</xfunction> function</p>
                     </item>
                     <item>
                        <p diff="add" at="F">An <elcode>xsl:for-each-group</elcode> instruction with a <code>group-by</code> attribute.</p>
                     </item>
                  </ulist>

                  <example id="avoiding-last">
                     <head>Avoiding the use of <code>last()</code></head>
                     <p>Use of the <xfunction>last</xfunction> function can often cause code to become
                        non-streamable. In some cases the problem is easily avoided by rearranging
                        the code. For example, the following template inserts a
                           <code>&lt;br/&gt;</code> element after every line of a poem except the
                        last:</p>

                     <eg xml:space="preserve">
&lt;xsl:for-each select="poem/lines"&gt;
  &lt;xsl:value-of select="."/&gt;
  &lt;xsl:if test="position() ne last()"&gt;&lt;br/&gt;&lt;/xsl:if&gt;
&lt;/xsl:for-each&gt;
</eg>
                     <p>This code is not streamable, but it can easily be rewritten to make it
                        streamable by instead inserting the <code>&lt;br/&gt;</code> element before
                        every line except the first:</p>

                     <eg xml:space="preserve">
&lt;xsl:for-each select="poem/lines"&gt;
  &lt;xsl:if test="position() ne 1"&gt;&lt;br/&gt;&lt;/xsl:if&gt;
  &lt;xsl:value-of select="."/&gt;  
&lt;/xsl:for-each&gt;
</eg>
                  </example>
               </div4>
            </div3>
            <div3 id="streamability-choice-and-repetition">
               <head>Analyzing choices, repetition, and calls</head>

               <p>The previous section established a data flow graph sufficient to identify the
                  navigation routes through a document used within an individual function or
                  template. This is not yet sufficient to establish whether the navigation is
                  <termref def="dt-guaranteed-streamable"/>:</p>

               <ulist>
                  <item>
                     <p>Conditional branches in the logic can make a construct streamable based on
                        knowledge that two navigation paths are mutually exclusive at run-time (the
                        logic will only follow one of them). Conditional branches arise most
                        obviously from use of an <elcode>xsl:choose</elcode> instruction or an XPath
                           <code>if</code> expression; however they also arise with
                           <elcode>xsl:catch</elcode>, and the same analysis is used with
                           <elcode>xsl:fork</elcode>.</p>
                  </item>
                  <item>
                     <p>Iteration in the logic, on the other hand, can make a construct
                        non-streamable, because it is in the nature of streaming that descendant
                        nodes can only be visited once.</p>
                  </item>
                  <item>
                     <p>To get a complete picture of the navigation routes followed, it is necessary
                        to trace paths through function and template calls and invocations of
                           <termref def="dt-attribute-set">attribute sets</termref>.</p>
                  </item>
               </ulist>

               <p>These factors are considered in the sections that follow.</p>



               <div4 id="expr-tree-choices">
                  <head>Analyzing conditional constructs</head>
                  <p>It is necessary to identify <termref def="dt-construct">constructs</termref>
                     that are mutually exclusive, in the sense that when one construct is evaluated
                     the other will not be evaluated. This is because a <termref def="dt-guaranteed-streamable"/> construct is
                     only allowed to traverse the children of a node once, but performing two
                     traversals in mutually exclusive branches of a conditional does not violate
                     this condition. For example, the expression <code>if (@a) then child::title
                        else child::subtitle</code> is potentially streamable even though it
                     contains two downward selections.</p>

                  <p>Recall that when building the expression tree, <phrase diff="add" at="F">an
                  <elcode>xsl:if</elcode> instruction was converted to an (if-then-else) expression, in
                     which the else branch is always an empty sequence, and </phrase>
                     an <elcode>xsl:choose</elcode>stream
                     instruction was decomposed into a set of binary (if-then-else) tests
                     <phrase diff="del" at="F">Similarly, it is convenient to consider an <elcode>xsl:if</elcode> instruction
                     as having an implicit <code>else</code> branch that always returns an empty
                        sequence. </phrase><phrase diff="chg" at="F">Furthermore, a sequence of <elcode>xsl:catch</elcode> clauses was reduced to a
                     single <elcode>xsl:catch</elcode> construct containing internal
                        <code>if-then-else</code> constructs to test the error code. Thus all
                     conditional expressions have been reduced to a common form.</phrase></p>

                  <p><termdef id="dt-mutually-exclusive" term="mutually exclusive">Two <termref def="dt-e-node">e-nodes</termref> in the expression tree are defined to
                        be <term>mutually exclusive</term> if they have a common ancestor
                           <code>if</code> e-node, and if one is a descendant of the
                           <code>then</code> child of that <code>if</code>, while the other is a
                        descendant of the <code>else</code> child. Two e-nodes are also
                           <term>mutually exclusive</term> if they are <termref def="dt-mutually-independent">mutually independent</termref> as defined
                        in <specref ref="expr-parallel-branches"/>.</termdef></p>

                  <example>
                     <head>Conditional branches</head>
                     <p>Consider the template</p>
                     <eg xml:space="preserve">
&lt;xsl:template name="t"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="@code=23&gt;
       &lt;xsl:sequence select="firstName"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:when test="@code=24&gt;
       &lt;xsl:sequence select="lastName"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:when test="@code=if (@married) then 31 else 32"&gt;
       &lt;xsl:sequence select="formerName"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
       &lt;xsl:sequence select="concat(firstName, lastName)"/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;
                  </eg>
                     <p>The combined expression tree and data flow graph for this template is shown below.
                        (To avoid complicating the diagram unnecessarily, data flows from the <elcode>xsl:sequence</elcode>
                        instructions back via the if/then/else expressions to the root e-node labeled
                        <elcode>xsl:template</elcode> are not shown.)</p>
                     <g:graph width="800" height="800">
                        <g:node id="root" label="xsl:template">
                           <g:node label="if">
                              <g:node label="test">
                                 <g:node label="=">
                                    <g:node id="a0" label="@code"/>
                                    <g:node label="23"/>
                                 </g:node>
                              </g:node>
                              <g:node label="then">
                                 <g:node id="c0" label="child::firstName"/>
                              </g:node>
                              <g:node label="else">
                                 <g:node label="if">
                                    <g:node label="test">
                                       <g:node label="=">
                                          <g:node id="a1" label="@code"/>
                                          <g:node label="24"/>
                                       </g:node>
                                    </g:node>
                                    <g:node label="then">
                                       <g:node id="c1" label="child::lastName"/>
                                    </g:node>
                                    <g:node label="else">
                                       <g:node label="if">
                                          <g:node label="test">
                                             <g:node label="=">
                                                <g:node id="a2" label="@code"/>
                                                <g:node label="if">
                                                  <g:node label="test">
                                                  <g:node label="boolean">
                                                  <g:node id="a3" label="@married"/>
                                                  </g:node>
                                                  </g:node>
                                                  <g:node label="then">
                                                  <g:node label="31"/>
                                                  </g:node>
                                                  <g:node label="else">
                                                  <g:node label="32"/>
                                                  </g:node>
                                                </g:node>
                                             </g:node>
                                          </g:node>
                                          <g:node label="then">
                                             <g:node id="c2" label="child::formerName"/>
                                          </g:node>
                                          <g:node label="else">
                                             <g:node label="concat()">
                                                <g:node id="c3" label="child::firstName"/>
                                                <g:node id="c4" label="child::lastName"/>
                                             </g:node>
                                          </g:node>
                                       </g:node>
                                    </g:node>
                                 </g:node>
                              </g:node>
                           </g:node>
                        </g:node>
                        <g:edge from="root" to="a0" color="red" constraint="false"/>
                        <g:edge from="root" to="a1" color="red" constraint="false"/>
                        <g:edge from="root" to="a2" color="red" constraint="false"/>
                        <g:edge from="root" to="a3" color="red" constraint="false"/>
                        <g:edge from="root" to="c0" color="red" constraint="false"/>
                        <g:edge from="root" to="c1" color="red" constraint="false"/>
                        <g:edge from="root" to="c2" color="red" constraint="false"/>
                        <g:edge from="root" to="c3" color="red" constraint="false"/>
                        <g:edge from="root" to="c4" color="red" constraint="false"/>
                     </g:graph>

                     <p>Later, the streamability analysis will test whether there are two paths
                        starting at the <elcode>xsl:template</elcode> that both contain downward
                        selections and are not mutually exclusive. In fact there are five paths here
                        that contain a downward selection (all those to e-nodes that use the child
                        axis), and they are all mutually exclusive except those that include the two
                        subexpressions of the <code>concat()</code> node. In consequence, this
                        template is not <termref def="dt-guaranteed-streamable"/>.</p>
                  </example>


               </div4>
               <div4 id="expr-parallel-branches">
                  <head>Analyzing parallel branches</head>
                  <p>When the <elcode>xsl:fork</elcode> instruction is used, instructions within its
                     sequence constructor can be evaluated in parallel, during a single pass of the
                     streamed input document.</p>
                  <p>Recall that two instructions directly contained within an
                        <elcode>xsl:fork</elcode> instruction are defined to be
                        <term>independent</term> if neither is dependent on the other (that is, in
                     all cases except where one instruction binds a variable that is used by the
                     other). Extending this concept:</p>
                  <p><termdef id="dt-mutually-independent" term="mutually independent">Two e-nodes
                        are <term>mutually independent</term> if they share an e-node representing
                        an <elcode>xsl:fork</elcode> instruction as a common ancestor, and if they
                        occur in separate subtrees rooted at different children of the
                           <elcode>xsl:fork</elcode> instruction, such that neither subtree is
                        dependent (directly or indirectly) on the value of a variable bound by the
                        other subtree.</termdef></p>
                  <note>
                     <p>From the point of view of streamability analysis, e-nodes that are <termref def="dt-mutually-independent">mutually independent</termref> are treated
                        in the same way as those that are <termref def="dt-mutually-exclusive">mutually exclusive</termref> because they occur in different branches of
                        a conditional.</p>
                  </note>
               </div4>

               <div4 id="expr-tree-loops">
                  <head>Analyzing looping constructs</head>
                  <p>It is necessary to identify constructs that are evaluated repeatedly, in the
                     sense that when their parent construct is evaluated, the child construct is
                     evaluated more than once. This is because a streamable construct is only
                     allowed to traverse the children of a node once. For example, the expression
                        <code>for $a in 1 to 5 return child::*</code> is not streamable: it performs
                     multiple traversals of the children of the context node even though there is
                     only a single subexpression that does downwards navigation.</p>
                  <p>A number of constructs are recognized as looping constructs, in that they cause
                     one of their sub-constructs to be evaluated more than once, with differences in
                     the dynamic context (either a different focus, or different variable values).
                     In each case the construct has one child construct whose evaluation returns a
                     sequence, which is evaluated once, and another child construct that is
                     evaluated repeatedly: we will refer to the first subconstruct as the
                        <emph>controlling expression</emph> and the second as the <emph>controlled
                        expression</emph>.</p>
                  <p>To analyze this situation, it is necessary to examine arcs in the data flow
                     graph that start on an e-node <var>S</var> representing a construct that is
                     outside a loop, and end on an e-node <var>E</var> that is inside the loop. This
                     is consistent with streaming only where <var>S</var> is the controlling
                     expression for the loop.</p>
                  <example>
                     <head>A streamable loop</head>
                     <p>Consider the construct</p>
                     <eg xml:space="preserve">
&lt;xsl:template match="department"&gt;
  &lt;xsl:for-each select="employee"&gt;
    &lt;a&gt;&lt;xsl:value-of select="salary"/&gt;&lt;/a&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;
</eg>
                     <p>The expression tree and data flow graph for this construct are shown below.
                        (Again, the expansion of axis steps such as <code>child::employee</code> to
                           <code>./child::employee</code> has been omitted.)</p>
                     <g:graph>
                        <g:node id="T" label="xsl:template">
                           <g:node id="A" label="xsl:for-each">
                              <g:node id="B" label="child::employee"/>
                              <g:node id="LRE" label="&lt;a&gt;">
                                 <g:node label="xsl:value-of">
                                    <g:node id="path" label="path">
                                       <g:node id="C" label="child::salary"/>
                                       <g:node id="text" label="descendant-or-self::text()"/>
                                    </g:node>
                                 </g:node>
                              </g:node>
                           </g:node>
                        </g:node>
                        <g:edge from="T" to="B" color="red" constraint="false"/>
                        <g:edge from="B" to="C" color="red" constraint="false"/>
                        <g:edge from="C" to="text" color="red" constraint="false"/>
                        <g:edge from="text" to="path" color="red" constraint="false"/>
                        <g:edge from="LRE" to="A" color="red" constraint="false"/>
                        <g:edge from="A" to="T" color="red" constraint="false"/>
                     </g:graph>

                     <p>This is streamable because the arcs from the <elcode>xsl:template</elcode>
                        e-node to the e-node representing the <code>select</code> expression, and
                        that from the <code>select</code> expression into the body of the loop, are
                        both permitted under the rules below.</p>
                  </example>

                  <example>
                     <head>A non-streamable loop</head>
                     <p>Consider the construct</p>
                     <eg xml:space="preserve">
&lt;xsl:template match="department"&gt;
  &lt;xsl:param name="required" select="()"/&gt;                    
  &lt;a&gt;
    &lt;xsl:value-of select="for $i in $required 
                          return employee[@id=$i]/name"/&gt;
  &lt;/a&gt;
&lt;/xsl:template&gt;
</eg>
                     <p>The expression tree and data flow graph for this construct are shown
                        below.</p>
                     <g:graph>
                        <g:node id="A" label="xsl:template">
                           <g:node id="B" label="xsl:param"/>
                           <g:node id="BB" label="&lt;a&gt;">
                              <g:node label="xsl:value-of">
                                 <g:node id="path" label="path">
                                    <g:node id="F" label="for">
                                       <g:node id="ii" label="$i"/>
                                       <g:node id="R" label="$required"/>
                                       <g:node id="P" label="path">
                                          <g:node id="C" label="filter">
                                             <g:node id="E" label="child::employee"/>
                                             <g:node label="=">
                                                <g:node id="id" label="@id"/>
                                                <g:node id="I" label="$i"/>
                                             </g:node>
                                          </g:node>
                                          <g:node id="N" label="child::name"/>
                                       </g:node>
                                    </g:node>
                                    <g:node id="text" label="descendant-or-self::text()"/>
                                 </g:node>
                              </g:node>
                           </g:node>
                        </g:node>
                        <g:edge from="A" to="E" color="red" constraint="false"/>
                        <g:edge from="R" to="ii" color="red" constraint="false"/>
                        <g:edge from="ii" to="I" color="red" constraint="false"/>
                        <g:edge from="B" to="R" color="red" constraint="false"/>
                        <g:edge from="E" to="C" color="red" constraint="false"/>
                        <g:edge from="N" to="P" color="red" constraint="false"/>
                        <g:edge from="P" to="F" color="red" constraint="false"/>
                        <g:edge from="F" to="text" color="red" constraint="false"/>
                        <g:edge from="text" to="path" color="red" constraint="false"/>
                        <g:edge from="C" to="N" color="red" constraint="false"/>
                        <g:edge from="E" to="id" color="red" constraint="false"/>
                        <g:edge from="BB" to="A" color="red" constraint="false"/>
                     </g:graph>

                     <p>This is not streamable because the arc from the e-node representing the
                           <elcode>xsl:template</elcode> to the e-node representing the step
                           <code>child::employee</code> crosses into the loop in a way that is not
                        allowed.</p>
                  </example>

                  <p>The looping constructs are listed in the table below. </p>

                  <table border="1" cellpadding="5">
                     <thead>
                        <tr>
                           <th rowspan="1" colspan="1">Looping construct</th>
                           <th rowspan="1" colspan="1">Controlling expression</th>
                           <th rowspan="1" colspan="1">Controlled expression</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td rowspan="1" colspan="1"><elcode>xsl:for-each</elcode></td>
                           <td rowspan="1" colspan="1">the <code>select</code> expression</td>
                           <td rowspan="1" colspan="1">the contained sequence constructor; plus the <code>select</code>
                              expression of any child <code>xsl:sort</code> elements</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><elcode>xsl:for-each-group</elcode></td>
                           <td rowspan="1" colspan="1">the <code>select</code> expression</td>
                           <td rowspan="1" colspan="1">the contained sequence constructor; plus the <code>group-by</code>
                              and <code>group-adjacent</code> expressions, and the
                                 <code>select</code> expression of any child <code>xsl:sort</code>
                              elements</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><elcode>xsl:iterate</elcode></td>
                           <td rowspan="1" colspan="1">the <code>select</code> expression</td>
                           <td rowspan="1" colspan="1">the contained sequence constructor</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><elcode>xsl:analyze-string</elcode></td>
                           <td rowspan="1" colspan="1">the <code>select</code> expression</td>
                           <td rowspan="1" colspan="1">the sequence constructors contained in the
                                 <elcode>xsl:matching-substring</elcode> and
                                 <elcode>xsl:non-matching-substring</elcode> children</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><elcode>xsl:merge-source</elcode></td>
                           <td rowspan="1" colspan="1">the <code>select</code> expression of the
                                 <code>xsl:merge-source</code> element</td>
                           <td rowspan="1" colspan="1">the <code>select</code> expression of its
                                 <elcode>xsl:merge-input</elcode> child</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><elcode>xsl:merge</elcode></td>
                           <td rowspan="1" colspan="1">the <code>select</code> expressions of the
                                 <code>xsl:merge-input</code> elements</td>
                           <td rowspan="1" colspan="1">the sequence constructor contained in the
                                 <elcode>xsl:merge-action</elcode> child; plus the
                                 <code>select</code> expression of any child
                                 <code>xsl:merge-key</code> elements</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">XPath <code>for</code> expression</td>
                           <td rowspan="1" colspan="1">the <code>in</code> expression</td>
                           <td rowspan="1" colspan="1">the <code>return</code> expression</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">XPath <code>some/every</code> expression</td>
                           <td rowspan="1" colspan="1">the <code>in</code> expression</td>
                           <td rowspan="1" colspan="1">the <code>satisfies</code> expression</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">Path expression (<code>A/B</code>)</td>
                           <td rowspan="1" colspan="1">the first operand, <code>A</code></td>
                           <td rowspan="1" colspan="1">the second operand, <code>B</code></td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">Filter expression (<code>A[B]</code>)</td>
                           <td rowspan="1" colspan="1">the sequence being filtered, <code>A</code></td>
                           <td rowspan="1" colspan="1">the predicate, <code>B</code></td>
                        </tr>
                     </tbody>
                  </table>

                  <p><termdef id="dt-repeating-arc" term="repeating arc">An arc in the data flow
                        graph is a <term>repeating arc</term> if it ends at an
                           <termref def="dt-e-node">e-node</termref> that is 
                     <phrase diff="chg" at="F">within the subtree rooted at</phrase>
                        the e-node representing a <emph>controlled expression</emph>, and starts at
                        an e-node that is outside the tree rooted at the corresponding <emph>looping
                           construct</emph>.</termdef></p>

                  <p>When such an arc forms part of a path starting at a construct whose
                     streamability is being tested, it will cause the construct to be deemed
                     non-streamable. However, an arc from outside the looping construct to the
                     controlling expression, and an arc from the controlling expression to the
                     controlled expression, do not cause non-streamability.</p>
                  
                  <issue id="issue-data-flow-into-a-loop" status="open"><p>The rules prohibiting data flows into the body of a loop
                  may be stricter than is necessary: they are designed to prevent repeated evaluation of a downward selection,
                  but as written, they also disallow motionless expressions such as <code>$var/@name</code> or <code>name($var)</code></p></issue>


               </div4>
               <div4 id="expr-tree-sorting">
                  <head>Analyzing sorting constructs</head>

                  <p>Where an expression sorts nodes from a streamed input document into some order
                     other than document order, the effect is to make the code non-streamable. An
                     example is an <elcode>xsl:for-each</elcode> instruction containing an
                        <elcode>xsl:sort</elcode> child element. </p>
                  <p>In building the expression tree 
                     <phrase diff="add" at="F">according to the rules in <specref ref="building-expression-tree"/></phrase>, 
                     a construct of the form:</p>
                  <eg xml:space="preserve">
&lt;xsl:for-each select="IN"&gt;
  &lt;xsl:sort select="KEY"/&gt;
  &lt;xsl:sequence select="OUT"/&gt;
&lt;/xsl:for-each&gt;                   
                  </eg>
                  <p diff="chg" at="F">was rewritten to make the expression <code>IN</code> a subexpression of 
                     an e-node representing the sorting operation, so the expression tree
                     is:</p>
                  <g:graph>
                     <g:node label="xsl:for-each">
                        <g:node label="sort">
                           <g:node label="IN"/>
                           <g:node label="KEY"/>
                        </g:node>
                        <g:node label="OUT"/>
                     </g:node>
                  </g:graph>

                  <p>If the subsequent analysis of the data flow graph reveals that the expression
                        <code>IN</code> contains nodes from the streamed input, the presence of the
                        <code>sort</code> e-node will result in the entire construct being deemed
                     non-streamable, because a sort operation (in the worst case) needs to read all
                     its input into memory before it can produce any output. (If the sort operation
                     is sorting data from another source then this is not incompatible with
                     streaming: it may involve allocating memory, but the requirement to stream the
                     input document has been satisfied.)</p>

                  <example>
                     <head>Non-streamable sorting</head>
                     <p>Consider the template rule</p>
                     <eg xml:space="preserve">
&lt;xsl:template match="department"&gt;
  &lt;xsl:for-each select="employee"&gt;
     &lt;xsl:sort select="@empNr"/&gt;
     &lt;xsl:copy-of select="."/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;
</eg>

                     <p>The expression tree and data flow graph for this template are shown
                        below:</p>

                     <g:graph>
                        <g:node id="A" label="xsl:template">
                           <g:node id="B" label="xsl:for-each">
                              <g:node id="C" label="sort">
                                 <g:node id="D" label="child::employee"/>
                              </g:node>
                              <g:node id="E" label="attribute::empNr"/>
                              <g:node id="CC" label="copy-of">
                                 <g:node id="F" label="path">
                                    <g:node id="G" label="."/>
                                    <g:node id="H" label="descendant-or-self::node()"/>
                                 </g:node>
                              </g:node>
                           </g:node>
                        </g:node>
                        <g:edge from="A" to="D" color="red" constraint="false"/>
                        <g:edge from="D" to="C" color="red" constraint="false"/>
                        <g:edge from="C" to="E" color="red" constraint="false"/>
                        <g:edge from="C" to="G" color="red" constraint="false"/>
                        <g:edge from="G" to="H" color="red" constraint="false"/>
                        <g:edge from="H" to="F" color="red" constraint="false"/>
                        <g:edge from="CC" to="B" color="red" constraint="false"/>
                        <g:edge from="B" to="A" color="red" constraint="false"/>
                     </g:graph>

                     <p>This template is not streamable, because the data flow graph contains a
                           <code>sort</code> construct on a path reachable from the
                           <elcode>xsl:template</elcode> construct.</p>
                  </example>

                  <p><termdef id="dt-reordering-construct" term="reordering construct">Sorting is just
                        one example of an operation on a sequence whose output is not streamable
                        with respect to its input. In general we refer to any <termref def="dt-construct">construct</termref> that requires to hold its entire
                        input sequence in memory in order to compute its result as a
                           <term>reordering construct</term>.</termdef></p>


                  <p>The following is a complete list of constructs that are classified as <termref def="dt-reordering-construct">reordering constructs</termref>:</p>

                  <ulist>
                     <item>
                        <p>The <code>sort</code> e-node created on the expression tree for any
                              <termref def="dt-instruction">instruction</termref> having an
                              <elcode>xsl:sort</elcode> element as a child.</p>
                     </item>
                     <item>
                        <p>The function <xfunction>reverse</xfunction></p>
                     </item>
                     <item>
                        <p>The function <xfunction>last</xfunction> (see below)</p>
                     </item>
                     <item>
                        <p>the <code>xsl:for-each-group</code> instruction when used with a
                              <code>group-by</code> attribute</p>
                     </item>
                  </ulist>

                  <example>
                     <head>The <code>last</code> function</head>

                     <p>This example shows how the analysis is done for the
                           <xfunction>last</xfunction> function. As described in <specref ref="tracing-context-path"/>, this expression is considered to depend on
                        the context item, and therefore has an inward arc in the data flow graph
                        from the expression that sets the context item.</p>

                     <p>Consider the template rule</p>
                     <eg xml:space="preserve">
&lt;xsl:template match="department"&gt;
  &lt;xsl:for-each select="employee"&gt;
     &lt;xsl:if test="position() = last()"&gt;
        &lt;xsl:value-of select="surname"/&gt;
     &lt;/xsl:if&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;
</eg>

                     <p>The expression tree and data flow graph for this template are shown
                        below:</p>

                     <g:graph>
                        <g:node id="A" label="xsl:template">
                           <g:node id="B" label="xsl:for-each">
                              <g:node id="D" label="child::employee"/>
                              <g:node id="E" label="if">
                                 <g:node id="F" label="test">
                                    <g:node id="G" label="equals">
                                       <g:node id="H" label="position()"/>
                                       <g:node id="I" label="last()"/>
                                    </g:node>
                                 </g:node>
                                 <g:node id="N" label="then">
                                    <g:node id="M" label="xsl:value-of">
                                       <g:node id="J" label="path">
                                          <g:node id="K" label="child::surname"/>
                                          <g:node id="L" label="descendant-or-self::text()"/>
                                       </g:node>
                                    </g:node>
                                 </g:node>
                              </g:node>
                           </g:node>
                        </g:node>
                        <g:edge from="A" to="D" color="red" constraint="false"/>
                        <g:edge from="D" to="I" color="red" constraint="false"/>
                        <g:edge from="D" to="K" color="red" constraint="false"/>
                        <g:edge from="K" to="L" color="red" constraint="false"/>
                        <g:edge from="L" to="J" color="red" constraint="false"/>
                        <g:edge from="M" to="N" color="red" constraint="false"/>
                        <g:edge from="N" to="E" color="red" constraint="false"/>
                        <g:edge from="E" to="B" color="red" constraint="false"/>
                        <g:edge from="B" to="A" color="red" constraint="false"/>
                     </g:graph>

                     <p>This example is not streamable, because the reordering construct
                           <code>last()</code> is present on a data flow path starting at the
                           <elcode>xsl:template</elcode> construct.</p>
                  </example>



                  <note>
                     <p>Any expressions appearing in attribute value templates of the
                           <elcode>xsl:sort</elcode> element (for example, the
                           <code>collation</code> attribute) must be analyzed in the usual way: the
                        focus for these expressions is the same as the focus for the
                           <code>select</code> expression of the containing instruction (for
                        example, <elcode>xsl:for-each</elcode>). Even if the <code>select</code>
                        expression does not force a streamability problem by reordering the nodes in
                        the streamed input, there is potential for these additional attributes to
                        disrupt streamability by making downwards selections from a streamed input
                        node.</p>
                  </note>

               </div4>
               <div4 id="streamability-of-dynamic-invocation">
                  <head>Analyzing dynamic invocation</head>

                  <p>A number of constructs cause invocation of a function, template, or expression
                     that cannot be identified statically. These constructs include
                        <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>,
                     <elcode>xsl:next-match</elcode>, <elcode>xsl:evaluate</elcode>, and dynamic
                     function invocations in XPath.</p>


                  <p>The instructions <elcode>xsl:apply-templates</elcode>,
                        <elcode>xsl:apply-imports</elcode>, and <elcode>xsl:next-match</elcode>
                     cause a template to be invoked dynamically. There are two cases to
                     consider:</p>

                  <ulist>
                     <item>
                        <p>If the invocation is in a streamable mode, then the called template is
                           guaranteed to be streamable, which means the caller can reliably assume
                           that the called template will only navigate within the subtrees of the
                           selected nodes. The effect of the called template can therefore be
                           simulated by adding the navigation step
                              <code>descendant-or-self::node()</code> to the nodes selected by the
                              <code>select</code> expression (in the case of
                              <elcode>xsl:apply-templates</elcode>) or the context item (in the case
                           of <elcode>xsl:apply-imports</elcode> and
                           <elcode>xsl:next-match</elcode>)</p>
                     </item>

                     <item>
                        <p>If the invocation is in a non-streamable mode, then the caller cannot
                           make any assumptions about the navigation performed by the called
                           template. <phrase diff="chg" at="F">This can be simulated by adding the navigation step
                           <code>X/preceding::*</code> to the nodes selected by the
                           <code>select</code> expression (in the case of
                           <elcode>xsl:apply-templates</elcode>) or the context item (in the case
                           of <elcode>xsl:apply-imports</elcode> and
                           <elcode>xsl:next-match</elcode>).</phrase> If the
                           selected nodes are in the <termref def="dt-streamed-document"/> this will inevitably
                           cause the construct to be deemed non-streamable.</p>
                     </item>
                  </ulist>

                  <p>Any <code>xsl:with-param</code> elements used within an
                        <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>,
                        <elcode>xsl:next-match</elcode>, or <elcode>xsl:evaluate</elcode>
                     instruction, as well as the arguments to a dynamic function invocation, are
                     handled as follows: the initializing expression <code>X</code> (the expression
                     that evaluates the argument to be passed) is replaced by
                        <code>X/preceding::*</code>, reflecting the ability of the called component
                     to navigate anywhere within a tree that contains nodes passed as parameter
                     values, as well as the <termref def="dt-atomization">atomization</termref> that
                     may be performed in the course of parameter passing.</p>
                  <note>
                     <p>This expansion isn't needed if the type of the parameter value is always
                        atomic. However, this specification does not assume that the processor is
                        able to perform static type inferencing. If the parameter value is atomic,
                        this expansion will do no harm as it does not affect the path analysis.</p>
                     <p>The effect of this rule is that nodes within a streamed document cannot be
                        passed as parameters to a called template. This disallows some cases that
                        might be completely innocent, for example passing an attribute node which
                        the called template then atomizes. In effect it is a pessimistic strategy:
                        it disallows things that cannot be determined statically to be safe. An
                        alternative might be to allow a more optimistic approach, in which it is
                        permitted to pass such a parameter, and a dynamic error is then signalled if
                        the called template uses it in an inappropriate way, for example by
                        navigating outside the subtree that is available when streaming.</p>
                  </note>

                  <p>In the case of <elcode>xsl:evaluate</elcode>, the dynamically invoked XPath
                     expression can perform arbitrary navigation not only from any nodes passed
                     using <elcode>xsl:with-param</elcode>, but also from the context item. This is
                     represented by adding the expression <code>./preceding::*</code> as an
                     additional subexpression on the expression tree.</p>



               </div4>
               <div4 id="streamability-of-static-invocation">
                  <head>Analyzing calls to functions, templates, and attribute sets</head>

                  <p>Calls on <termref def="dt-stylesheet-function">stylesheet functions</termref>,
                        <termref def="dt-named-template">named templates</termref>, and <termref def="dt-attribute-set">attribute sets</termref> can be resolved at this
                     stage: a data flow graph is constructed that combines the navigation performed
                     by the calling template or function with that performed by its callee.</p>

                  <p>Parameters in a function call or in <elcode>xsl:call-template</elcode> are handled
                     by creating an arc in the data flow graph from the expression that sets the
                     parameter (in the caller) to the variable binding construct in the callee. The
                     return value is represented by an arc from the root e-node of the expression
                     tree representing the callee, to the e-node representing the function or
                     template invocation.</p>

                  <p>In the case of named templates and attribute sets, the context item is passed
                     implicitly, which is represented by (a) treating the calling construct as one
                     that has an intrinsic dependency on the context item, and (b) creating an arc
                     from the calling construct to the root e-node of the callee. This is
                     illustrated in the examples below.</p>

                  <p>If an argument or parameter has a declared type that is atomic, then the
                     parameter passing may invoke atomization, which may require navigation to
                     descendant nodes. In this case an e-node representing the step
                        <code>descendant::text()</code> must be inserted into the arc connecting the
                     caller to the callee. It is not necessary to represent atomization of the
                     returned result in the same way, because this operation will already be
                     reflected in the expression tree of the callee.</p>

                  <example>
                     <head>Analyzing a function call</head>
                     <p>Consider a calling template and a called function as follows:</p>
                     <eg xml:space="preserve">
&lt;xsl:template match="employee"&gt;
  &lt;e&gt;&lt;xsl:value-of select="f:salary(.)"/&gt;&lt;/e&gt;
&lt;/xsl:template&gt;
&lt;xsl:function name="f:salary" as="xs:decimal"&gt;
  &lt;xsl:param name="emp" as="element(employee)"/&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="$emp/hourly-pay"&gt;
       &lt;xsl:sequence select="$emp/hourly-pay * 1924"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
       &lt;xsl:sequence select="$emp/annual-salary"/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:function&gt;</eg>

                     <p>The two expression trees (one for the template, one for the called function)
                        are linked in the data flow graph as shown below.</p>

                     <g:graph width="800" height="380">
                        <g:node id="T" label="xsl:template">
                           <g:node label="&lt;e&gt;">
                              <g:node label="xsl:value-of">
                                 <g:node id="FC" label="f:salary()">
                                    <g:node id="dot" label="."/>
                                 </g:node>
                              </g:node>
                           </g:node>
                        </g:node>
                        <g:node id="F" label="xsl:function f:salary">
                           <g:node id="par" label="xsl:param emp"/>
                           <g:node label="if">
                              <g:node label="test">
                                 <g:node label="boolean()">
                                    <g:node id="p1" label="path">
                                       <g:node id="v1" label="$emp"/>
                                       <g:node id="c1" label="child::hourly-pay"/>
                                    </g:node>
                                 </g:node>
                              </g:node>
                              <g:node label="then">
                                 <g:node label="times">
                                    <g:node label="data">
                                       <g:node id="p2" label="path">
                                          <g:node id="v2" label="$emp"/>
                                          <g:node id="p22" label="path">
                                            <g:node id="c2" label="child::hourly-pay"/>
                                            <g:node id="p2dost" label="descendant-or-self::text()"/>
                                          </g:node>
                                       </g:node>
                                    </g:node>
                                    <g:node label="1924"/>
                                 </g:node>
                              </g:node>
                              <g:node label="else">
                                 <g:node label="data()">
                                    <g:node id="p3" label="path">
                                       <g:node id="v3" label="$emp"/>
                                       <g:node id="c3" label="child::annual-salary"/>
                                    </g:node>
                                 </g:node>
                              </g:node>
                           </g:node>
                        </g:node>
                        <g:edge from="F" to="FC" color="red" constraint="false"/>
                        <g:edge from="T" to="dot" color="red" constraint="false"/>
                        <g:edge from="dot" to="par" color="red" constraint="false"/>
                        <g:edge from="par" to="v1" color="red" constraint="false"/>
                        <g:edge from="par" to="v2" color="red" constraint="false"/>
                        <g:edge from="par" to="v3" color="red" constraint="false"/>
                        <g:edge from="v1" to="c1" color="red" constraint="false"/>
                        <g:edge from="v2" to="c2" color="red" constraint="false"/>
                        <g:edge from="v3" to="c3" color="red" constraint="false"/>
                        <g:edge from="c1" to="p1" color="red" constraint="false"/>
                        <g:edge from="c2" to="p2dost" color="red" constraint="false"/>
                        <g:edge from="p2dost" to="p22" color="red" constraint="false"/>
                        <g:edge from="p22" to="p2" color="red" constraint="false"/>
                        <g:edge from="c3" to="p3" color="red" constraint="false"/>

                     </g:graph>



                     <p>Analysis of the data flow graph will show that the template is not
                        streamable. There are three paths originating at the
                           <elcode>xsl:template</elcode> e-node that make downward selections and
                        are not mutually exclusive (two select <code>$emp/hourly-pay</code>, one
                        selects <code>$emp/annual-salary)</code>. Two of these are <termref def="dt-mutually-exclusive">mutually exclusive</termref>, but the third
                        is not. If the properties of the employee were held in attributes rather
                        than child elements, however, the template would be streamable.</p>
                  </example>
                  <p>Note that a data flow graph needs to be constructed independently for each
                     supposedly streamable template. Constructing a global data flow graph could
                     create spurious paths that affect the analysis.</p>

                  <p>Where there are several calls to the same function, the paths in the data flow
                     graph from the root <elcode>xsl:template</elcode> e-node will no longer form a
                     tree (paths may converge); and where a function or template is recursive, the
                     graph may contain cycles. This is not necessarily incompatible with the
                     template being streamable.</p>

                  <example>
                     <head>A streamable recursive template</head>
                     <p>This example shows a recursive function that counts how many immediate
                        ancestor <code>div</code> elements a given element has, and a streamable
                        template that calls this function.</p>

                     <eg xml:space="preserve">
&lt;xsl:template match="p" mode="streamable"&gt;
  &lt;out&gt;Nesting depth: &lt;xsl:value-of select="f:div-depth(.)"/&gt;&lt;/out&gt;
&lt;/xsl:template&gt;

&lt;xsl:function name="f:nesting-depth" as="xs:integer"&gt;
  &lt;xsl:param name="this" as="element()"/&gt;
  &lt;xsl:sequence select="if ($this/parent::div) 
                        then 1 + f:nesting-depth($this/parent::div) 
                        else 0"/&gt;
&lt;/xsl:function&gt;</eg>

                     <p>The two expression trees (for the template and the function) are shown in
                        the diagram below, together with the data flow graph.</p>

                     <g:graph>
                        <g:node id="T" label="xsl:template">
                           <g:node label="&lt;out&gt;">
                              <g:node label="xsl:value-of">
                                 <g:node id="FC1" label="f:div-depth()">
                                    <g:node id="dot" label="."/>
                                 </g:node>
                              </g:node>
                           </g:node>
                        </g:node>
                        <g:node id="F" label="xsl:function f:div-depth">
                           <g:node id="par" label="xsl:param this"/>
                           <g:node label="if">
                              <g:node label="test">
                                 <g:node label="boolean()">
                                    <g:node id="path1" label="path">
                                       <g:node id="vr1" label="$this"/>
                                       <g:node id="parent1" label="parent::div"/>
                                    </g:node>
                                 </g:node>
                              </g:node>
                              <g:node label="then">
                                 <g:node label="plus">
                                    <g:node label="1"/>
                                    <g:node id="FC2" label="f:nesting-depth()">
                                       <g:node id="path2" label="path">
                                          <g:node id="vr2" label="$this"/>
                                          <g:node id="parent2" label="parent::div"/>
                                       </g:node>
                                    </g:node>
                                 </g:node>
                              </g:node>
                              <g:node label="else">
                                 <g:node label="0"> </g:node>
                              </g:node>
                           </g:node>
                        </g:node>
                        <g:edge from="F" to="FC1" color="red" constraint="false"/>
                        <g:edge from="F" to="FC2" color="red" constraint="false"/>
                        <g:edge from="T" to="dot" color="red" constraint="false"/>
                        <g:edge from="dot" to="par" color="red" constraint="false"/>
                        <g:edge from="path2" to="par" color="red" constraint="false"/>
                        <g:edge from="parent1" to="path1" color="red" constraint="false"/>
                        <g:edge from="parent2" to="path2" color="red" constraint="false"/>
                        <g:edge from="par" to="vr1" color="red" constraint="false"/>
                        <g:edge from="par" to="vr2" color="red" constraint="false"/>
                        <g:edge from="vr1" to="parent1" color="red" constraint="false"/>
                        <g:edge from="vr2" to="parent2" color="red" constraint="false"/>
                     </g:graph>


                     <p>Note the cycle from the <elcode>xsl:param</elcode> element to the variable
                        reference <code>$this</code> used in the recursive function call, to the
                           <code>parent::div</code> step and then the containing path expression.
                        This cycle is not inconsistent with streamability, because streamable code
                        can make an indefinite number of upwards steps (the ancestors of a node are
                        always available). The fact that there is only one axis step on this cycle
                        reflects the fact that each recursive invocation of the function moves one
                        step up the ancestor axis.</p>
                  </example>

               </div4>
               <div4 id="streamability-iterate">
                  <head>Analyzing the streamability of <elcode>xsl:iterate</elcode></head>
                  
                  <p diff="add" at="F">The <elcode>xsl:iterate</elcode> instruction is
                  a looping construct, and as such its analysis is described in
                  <specref ref="expr-tree-loops"/>.</p>


                  <p>In addition, in <elcode>xsl:iterate</elcode> there is a data flow from an
                        <elcode>xsl:with-param</elcode> element within the
                        <elcode>xsl:next-iteration</elcode> element, to the corresponding
                        <elcode>xsl:param</elcode> element. As with a recursive function call, this
                     causes cycles in the data flow graph, but such cycles are not necessarily fatal
                     to streamability.</p>

               </div4>

            </div3>

            <div3 id="streamability-conditions">
               <head>Streamability Conditions</head>

               <p>The streamability of a construct <var>C</var> can be determined by examining the
                  paths in the data flow graph that emanate from the <termref def="dt-e-node">e-node</termref> representing <var>C</var> in the expression tree. A
                     <emph>path</emph> here is any sequence of arcs in the data flow graph. Note
                  that because the data flow graph may have cycles, a path can be infinite (and
                  there can also be an infinite number of paths). Paths that do not start from
                     <var>C</var> can be ignored.</p>

               <p>A construct <var>C</var> is <termref def="dt-guaranteed-streamable"/>
                  with respect to its context item if the set
                  of paths starting at <var>C</var> in the data flow graph satisfies all the
                  following conditions:</p>
               <olist>
                  <item>
                     <p>No path contains an <termref def="dt-e-node">e-node</termref> representing a
                        sideways axis step (following, preceding, following-sibling, or
                        preceding-sibling).</p>
                     <note>
                        <p>Although there might be streaming techniques that allow such axes to be
                           used, perhaps with the help of buffering, such techniques are out of
                           scope for this specification and code that uses them is therefore not
                           <termref def="dt-guaranteed-streamable"/>.</p>
                     </note>
                  </item>
                  <item>
                     <p>No path contains an <termref def="dt-e-node">e-node</termref> representing
                        an upwards axis step (parent, ancestor, or ancestor-or-self) followed
                        immediately or otherwise by an <termref def="dt-e-node">e-node</termref>
                        representing a downward step (child, descendant, or descendant-or-self).</p>
                     <note>
                        <p>The processing model for streaming used in this specification assumes
                           that while passing through a streamed document, the processor will retain
                           information about the ancestors of the node at the current position of
                           the stream, together with their attributes. However, retaining
                           information about the descendants of these ancestors would be
                           inconsistent with streaming. Therefore, it is possible to navigate
                           upwards to ancestors, but not downwards from the ancestors to other parts
                           of the document.</p>
                     </note>
                  </item>
                  <item>
                     <p>No path contains an <termref def="dt-e-node">e-node</termref> representing a
                        descendant or descendant-or-self axis step followed immediately or otherwise
                        by an <termref def="dt-e-node">e-node</termref> representing a downward step
                        (child, descendant, or descendant-or-self).</p>
                     <note>
                        <p>For discussion of the reasons for this restriction and the possible ways
                           in which it might be relaxed, see <specref ref="notes-on-descendant-axis-streamability"/>.</p>
                     </note>
                     
                  </item>
                  <item>
                     <p>Given any pair of paths <var>P</var> and <var>Q</var>, excluding their
                        <termref def="dt-common-prefix"/> if any, every <termref def="dt-e-node">e-node</termref> in
                           <var>P</var> that represents a downward step (child, descendant, or
                        descendant-or-self) is <termref def="dt-mutually-exclusive">mutually
                           exclusive</termref> with every e-node representing a downward step in
                           <var>Q</var>. </p>
                     <p><termdef id="dt-common-prefix" term="common prefix">The <term>common prefix</term> of two paths 
                        in the data flow graph contains the arcs that are
                        present in both paths before the paths diverge.</termdef></p>
                     <note>
                        
                        <p>This rule is trivially satisfied if <var>P</var> and <var>Q</var> are the
                           same path, or if one is a prefix of the other, or if either <var>P</var>
                           or <var>Q</var> contains no downward selections.</p>

                        <p>So in practice it is only necessary to examine distinct paths that
                           contain one or more downward selections from the point at which the paths
                           diverge, and to check whether any downward selections in one arm are
                           mutually exclusive with the downward selections in the other arm (that
                           is, that they occur in different branches of a conditional such as
                              <elcode>xsl:choose</elcode>, or in independent instructions within an
                              <elcode>xsl:fork</elcode> instruction).</p>
                        <p>The rule reflects the fact that in streaming mode, the descendants of a
                           node can only be visited once. This rule therefore imposes a static
                           constraint on streamable constructs that they must not make more than one
                           downward selection, unless those downward selections are in mutually
                           exclusive branches of a conditional, so that only one of them will ever
                           be evaluated, or in independent branches of an <elcode>xsl:fork</elcode>
                           instruction, so that they are evaluated during a single pass of the input
                           document.</p>
                     </note>

                  </item>
                  <item>
                     <p>No path contains a <termref def="dt-repeating-arc">repeating arc</termref>.
                        (See <specref ref="expr-tree-loops"/>.)</p>
                     <note>
                        <p>This complements the previous rule, by stating that if there is a
                           downward selection to access descendants of a node, it must not occur in
                           a loop where it can be executed more than once.</p>
                     </note>
                  </item>
                  <item>
                     <p>No path contains an <termref def="dt-e-node">e-node</termref> representing a
                           <termref def="dt-reordering-construct">reordering construct</termref>.
                        (See <specref ref="expr-tree-sorting"/>.)</p>
                     <note>
                        <p>Examples of <termref def="dt-reordering-construct">reordering constructs</termref>
                           are the <code>sort</code> node added to
                           the expression tree in response to an <elcode>xsl:sort</elcode> child of
                              <elcode>xsl:for-each</elcode> or <elcode>xsl:apply-templates</elcode>,
                           or a call on the functions <xfunction>reverse</xfunction> or
                              <xfunction>last</xfunction>. These constructs have the characteristic
                           that they need to read their full input sequence before producing any
                           output, which is clearly incompatible with streaming.</p>
                     </note>
                  </item>
                  <item>
                     <p>No non-empty path returns to the <termref def="dt-e-node">e-node</termref>
                        representing the starting construct <var>C</var>.</p>
                     <note>
                        <p>Such a path would indicate that the supposedly streamable construct is
                           capable of returning (as all or part of its result) a node from the
                           streamed input document. In general this is not allowed, because there is
                           no way of analyzing what the caller attempts to do with the returned
                           node, and in particular, no way of determining that what it does is
                           compatible with streaming. This restriction is particularly necessary
                           when the construct being analyzed is a <termref def="dt-template-rule">template rule</termref>, because each template rule in a streamable
                           mode is analyzed independently of the others.</p>
                        <p>It might be possible to relax the rule in the case of the
                              <elcode>xsl:stream</elcode> instruction, where there is more scope to
                           pursue the analysis beyond the instruction itself.</p>
                     </note>
                  </item>
               </olist>

               <p>The above rules establish that a <termref def="dt-construct">construct</termref>
                  can be evaluated <phrase diff="add" at="F">using <termref def="dt-streaming"/></phrase> with respect to a given 
                  context node; in the case of an element node this
                  will typically involve reading the input stream from the start tag of the element
                  until the end tag of the same element. For some situations, notably evaluation of
                     <termref def="dt-pattern">patterns</termref>, a stronger test is required: the
                  construct must be evaluated while the stream is positioned at the start tag, and
                  without changing the position of the input stream. This is achieved by the
                  definition that follows.</p>

               <p><termdef id="dt-motionless" term="motionless">A construct <var>C</var> is
                        <term>motionless</term> with respect to its context item if (a) it is
                        <termref def="dt-guaranteed-streamable"/> with
                     respect to its context item (as defined above), and (b) in the set of paths
                     starting at <var>C</var> in the data flow graph, no path contains a downward
                     step (child, descendant, or descendant-or-self).</termdef></p>


            </div3>
            <div3 id="notes-on-descendant-axis-streamability">
               <head>Notes on the streamability of paths using the descendant axis</head>
               <p><emph>This section is a commentary describing future work; it will not form part
                     of the final specification.</emph></p>
               <issue id="issue-descendant-then-child" status="open">
                  <p>The restriction that a path such as <code>.//section/head</code> is
                     non-streamable is too severe; it needs to be relaxed.</p>
               </issue>
               <p>In the analysis given in the previous section, a path containing a descendant step
                  followed by a child step is deemed non-streamable. For example, this applies to
                  the path expression <code>.//section/head</code>. In fact, it even applies to the
                  path expression <code>.//employee</code>, because this is merely an abbreviation
                  for <code>./descendant-or-self::node()/child::employee</code></p>

               <p>This restriction is probably unacceptable. This section discusses how it can be
                  relaxed.</p>

               <p>The reason for the restriction is that a nested-loop evaluation of the expression
                  is not guaranteed to return results in document order. Consider for example the
                  perverse case of a document where the <code>head</code> element of a
                     <code>section</code> appears at the end:</p>

               <eg xml:space="preserve">&lt;section nr="1"&gt;
  &lt;section nr="1.1"&gt;
    &lt;head&gt;section 1.1&lt;/head&gt;
  &lt;/section&gt;
  &lt;section nr="1.2"&gt;
    &lt;head&gt;section 1.2&lt;/head&gt;
  &lt;/section&gt;
  &lt;head&gt;section 1&lt;/head&gt;
&lt;/section&gt;
</eg>

               <p>While the instruction <code>&lt;xsl:value-of select="//section/head"/&gt;</code>
                  will output the headings in document order as <code>"section 1.1 section 1.2
                     section 1"</code>, the <elcode>xsl:for-each</elcode> instruction</p>
               <eg xml:space="preserve">&lt;xsl:for-each select="//section"&gt;
  &lt;xsl:value-of select="head"/&gt;
&lt;/xsl:for-each&gt;</eg>

               <p>will output them in "logical order" as <code>"section 1 section 1.1 section
                     1.2"</code> (ignoring whitespace). Here the output is not in the same order as
                  the input, so by definition the construct is not fully streamable -- some kind of
                  buffering is needed, either of the input or the output.</p>

               <p>There are several possible ways one could relax the rules to make such expressions
                  streamable.</p>
               <olist>
                  <item>
                     <p>One could make a distinction between path expressions (which return results
                        in document order) and nested loops such as <elcode>xsl:for-each</elcode>
                        (which do not).</p>
                     <p>Currently the data flow graph makes no distinction between the two cases:
                        the data flow graph for the two cases is exactly the same. We could modify
                        the analysis so that the path <code>.//section/head</code> is treated
                        effectively as <code>./descendant::head[parent::section]</code>, which is
                        <termref def="dt-guaranteed-streamable"/> under the current rules. </p>
                  </item>
                  <item>
                     <p>One could go further and make all downwards paths <termref def="dt-guaranteed-streamable"/>,
                        even if they use nested-loop constructs such as
                           <elcode>xsl:for-each</elcode>. This has the advantage that it would
                        license the use of instructions such as this:</p>
                     <eg xml:space="preserve">&lt;xsl:for-each select=".//employee"&gt;
  &lt;xsl:value-of select="emp-nr"/&gt;
&lt;/xsl:for-each&gt;                     
                  </eg>
                     <p>which most users would expect to be streamable, and which in practice are
                        streamable in nearly all commonly encountered cases. There are then two ways
                        one could deal with the unusual cases that are not actually streamable (that
                        is, the cases where the order of the output is not the same as the order of
                        the input):</p>
                     <ulist>
                        <item>
                           <p>One could require the processor to perform buffering in this
                              situation, to achieve the necessary reordering of the output (note
                              that no buffering is needed unless the structure is actually
                              recursive, that is, the descendant axis actually selects a node that
                              is a descendant of another selected node)</p>
                           <p>An existing implementation has shown that this is a feasible approach;
                              but it does have the disadvantage that the worst-case memory
                              requirement is unpredictable.</p>
                        </item>
                        <item>
                           <p>One could require the processor to signal a dynamic error in this
                              case.</p>
                        </item>
                     </ulist>
                  </item>
                  <item>
                     <p>One could in principle make the rules schema-aware, so that the expression
                           <code>.//employee</code> becomes <termref def="dt-guaranteed-streamable"/> if the schema
                        indicates that an <code>employee</code> element cannot contain another
                           <code>employee</code> element. However, doing this in an interoperable
                        way would require a complete definition of the static type inferencing
                        rules, which is a major undertaking; it would also require users to write
                        schema-aware stylesheets, which for many would be a major change from
                        current practice.</p>
                  </item>
                  <item>
                     <p>One could make the <code>for</code> expression streamable only in the case
                        where the <xfunction>unordered</xfunction> function has been used to relax the
                        ordering rules, by writing <code>for $s in unordered(//section) return
                           $s/last-changed</code></p>
                  </item>
               </olist>
               <p>In the meantime, note that the <function>outermost</function> function is provided
                  to enable paths that are potentially recursive to be declared, in effect, as
                  selecting non-nested nodes, which guarantees the streamability of an expression
                  that uses this function (though this has not yet been factored into the
                  streamability rules).</p>



            </div3>
            <div3 id="streamability-examples">
               <head>Examples of streamability analysis</head>

               <example>
                  <head>Analysis of an <code>xsl:stream</code> instruction using
                        <code>xsl:iterate</code>
                  </head>
                  <p>Consider the following instruction:</p>
                  <eg xml:space="preserve"> &lt;xsl:stream href="transactions.xml"&gt;
   &lt;xsl:iterate select="account/transaction"&gt;
      &lt;xsl:param name="balance" select="0.00" as="xs:decimal"/&gt;
      &lt;xsl:variable name="newBalance" select="$balance + xs:decimal(@value)"/&gt;
      &lt;balance date="{@date}" value="{$newBalance}"/&gt;
      &lt;xsl:next-iteration&gt;
        &lt;xsl:with-param name="balance" select="$newBalance"/&gt;
      &lt;/xsl:next-iteration&gt;
    &lt;/xsl:iterate&gt;
  &lt;/xsl:stream&gt;</eg>
                  <p>The expression tree for this and data flow graph for this construct are shown
                     below.</p>

                  <p>Some simplifying assumptions have been made in creating this graph. No data
                     flow arcs are shown for values that are known to be atomic, such as the
                     variables <code>$balance</code> and <code>$newBalance</code>, because these can
                     never affect the streamability analysis. Equally, no
                        <code>descendant-or-self</code> steps have been added to reflect atomization
                     of nodes that are known to be attributes.</p>


                  <g:graph width="800" height="300">
                     <g:node id="stream" label="xsl:stream">
                        <g:node id="XI" label="xsl:iterate">
                           <g:node label="select">
                              <g:node id="p1" label="path">
                                 <g:node id="ca" label="child::account"/>
                                 <g:node id="ct" label="child::transaction"/>
                              </g:node>
                           </g:node>
                           <g:node label="xsl:param $balance :=">
                              <g:node label="0.0"/>
                           </g:node>
                           <g:node id="SC" label="sequence constructor">
                              <g:node label="$newBalance :=">
                                 <g:node label="plus">
                                    <g:node label="$balance"/>
                                    <g:node label="xs:decimal()">
                                       <g:node id="av" label="@value"/>
                                    </g:node>
                                 </g:node>
                              </g:node>
                              <g:node id="B" label="&lt;balance&gt;">
                                 <g:node label="attribute">
                                    <g:node id="ad" label="@date"/>
                                 </g:node>
                                 <g:node label="attribute">
                                    <g:node label="$newBalance"/>
                                 </g:node>
                              </g:node>
                              <g:node label="xsl:next-iteration">
                                 <g:node label="with-params">
                                    <g:node label="$newBalance"/>
                                 </g:node>
                              </g:node>
                           </g:node>
                        </g:node>
                     </g:node>
                     <g:edge from="stream" to="ca" color="red" constraint="false"/>
                     <g:edge from="ca" to="ct" color="red" constraint="false"/>
                     <g:edge from="ct" to="p1" color="red" constraint="false"/>
                     <g:edge from="p1" to="ad" color="red" constraint="false"/>
                     <g:edge from="p1" to="av" color="red" constraint="false"/>
                     <g:edge from="B" to="SC" color="red" constraint="false"/>
                     <g:edge from="SC" to="XI" color="red" constraint="false"/>
                     <g:edge from="XI" to="stream" color="red" constraint="false"/>

                  </g:graph>

                  <p diff="chg" at="F">The data flow graph can be seen more clearly by showing only the data flow paths
                     starting from the <elcode>xsl:stream</elcode> instruction 
                     and the e-nodes they connect (these arcs are shown in red on the previous
                     diagram):</p>

                  <g:graph>
                     <g:node label="xsl:stream">
                        <g:node label="child::account" edge-color="red">
                           <g:node label="child::transaction" edge-color="red">
                              <g:node label="path" edge-color="red">
                                 <g:node label="@date" edge-color="red"/>
                                 <g:node label="@value" edge-color="red"/>
                              </g:node>
                           </g:node>
                        </g:node>
                     </g:node>
                  </g:graph>

                  <p>There are thus two navigation paths emanating from the
                        <elcode>xsl:stream</elcode> instruction, both of the form
                        <code>child/child/attribute</code>. All the conditions for streamability are
                     satisfied, so the <elcode>xsl:stream</elcode> construct is <termref def="dt-guaranteed-streamable"/>.</p>



               </example>
               <example>
                  <head>Analysis of a template rule including a choice</head>
                  <p>In this example we assume that mode <code>M</code> has been declared to be a
                        <termref def="dt-streamable-mode">streamable mode</termref>, so we need to
                     check that the template rule is streamable.</p>
                  <eg xml:space="preserve">&lt;xsl:template match="para" mode="M"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="ancestor::para"&gt;
      &lt;span&gt;
        &lt;xsl:apply-templates mode="M"/&gt;
      &lt;/span&gt;
    &lt;/xsl:when&gt;	
    &lt;xsl:otherwise&gt;
      &lt;p&gt;
        &lt;xsl:apply-templates mode="M"/&gt;
      &lt;/p&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;</eg>
                  <p>The resulting expression tree and data flow graph are shown below.</p>
                  <p>The expression tree has been extended with <code>descendant-or-self</code>
                     steps in four places:</p>
                  <ulist>
                     <item>
                        <p>Both calls of <elcode>xsl:apply-templates</elcode> appear in the content
                           of <termref def="dt-literal-result-element">literal result
                              elements</termref>. This means that in constructing the parent
                           element, the value returned by the <elcode>xsl:apply-templates</elcode>
                           instruction will be copied. Copying navigates to all the descendant
                           nodes, so a <code>descendant-or-self</code> step is added to reflect
                           this.</p>
                     </item>
                     <item>
                        <p>Both calls of <elcode>xsl:apply-templates</elcode> are invoking a
                           template in a streamable mode, and can therefore assume that the template
                           being invoked follows the rules for streamable templates. Such templates
                           must be assumed to process the subtree under the selected nodes, which is
                           reflected by adding a <code>descendant-or-self</code> step to the
                              <code>select</code> expression. (The <code>child::node()</code> step
                           that represents the default value of the <code>select</code> attribute
                           has also been made explicit.)</p>
                     </item>
                  </ulist>
                  <g:graph width="800" height="430">
                     <g:node id="T" label="xsl:template">
                        <g:node label="if">
                           <g:node label="test">
                              <g:node label="boolean()">
                                 <g:node id="s0" label="ancestor::para"/>
                              </g:node>
                           </g:node>
                           <g:node label="then">
                              <g:node id="lre1" label="&lt;span&gt;">
                                 <g:node id="pp1" label="path">
                                    <g:node id="a1" label="xsl:apply-templates">
                                       <g:node id="p1" label="path">
                                          <g:node id="c1" label="child::node()"/>
                                          <g:node id="d1" label="descendant-or-self::node()"/>
                                       </g:node>
                                    </g:node>
                                    <g:node id="dd1" label="descendant-or-self::node()"/>
                                 </g:node>
                              </g:node>
                           </g:node>
                           <g:node label="else">
                              <g:node id="lre2" label="&lt;p&gt;">
                                 <g:node id="pp2" label="path">
                                    <g:node id="a2" label="xsl:apply-templates">
                                       <g:node id="p2" label="path">
                                          <g:node id="c2" label="child::node()"/>
                                          <g:node id="d2" label="descendant-or-self::node()"/>
                                       </g:node>
                                    </g:node>
                                 </g:node>
                                 <g:node id="dd2" label="descendant-or-self::node()"/>
                              </g:node>
                           </g:node>
                        </g:node>
                     </g:node>
                     <g:edge from="c1" to="d1" color="red" constraint="false"/>
                     <g:edge from="d1" to="p1" color="red" constraint="false"/>
                     <g:edge from="a1" to="dd1" color="red" constraint="false"/>
                     <g:edge from="dd1" to="pp1" color="red" constraint="false"/>
                     <g:edge from="c2" to="d2" color="red" constraint="false"/>
                     <g:edge from="d2" to="p2" color="red" constraint="false"/>
                     <g:edge from="a2" to="dd2" color="red" constraint="false"/>
                     <g:edge from="dd2" to="pp2" color="red" constraint="false"/>
                     <g:edge from="lre1" to="T" color="red" constraint="false"/>
                     <g:edge from="lre2" to="T" color="red" constraint="false"/>
                     <g:edge from="T" to="s0" color="red" constraint="false"/>
                     <g:edge from="T" to="c1" color="red" constraint="false"/>
                     <g:edge from="T" to="c2" color="red" constraint="false"/>
                  </g:graph>

                  <p>The data flow paths emanating from the <elcode>xsl:template</elcode> construct
                     can be seen more clearly if everything else is removed:</p>

                  <g:graph>
                     <g:node label="xsl:template">
                        <g:node label="ancestor::para" edge-color="red"/>
                        <g:node label="child::node()" edge-color="red">
                           <g:node label="descendant-or-self::node()" edge-color="red"/>
                        </g:node>
                        <g:node label="child::node()" edge-color="red">
                           <g:node label="descendant-or-self::node()" edge-color="red"/>
                        </g:node>
                     </g:node>
                  </g:graph>

                  <p>At first sight, this violates the rule that there must be only one path that
                     makes a downward selection. However, closer examination shows that the two
                     paths are mutually exclusive because they occur in different branches of a
                     conditional instruction. The template is therefore <termref def="dt-guaranteed-streamable"/>.</p>

               </example>
               <example>
                  <head>A non-streamable example using local variables</head>
                  <p>This example attempts to select all the transactions in a banking file where
                     the amount exceeds $1000 and the bank branch is Skipton.</p>
                  <eg xml:space="preserve">&lt;xsl:stream href="transactions.xml"&gt;
  &lt;xsl:for-each select="account/transaction"&gt;
    &lt;xsl:variable name="branch" 
         select="doc('branches.xml')/descendant::branch
                           [code = current()/branchCode]"/&gt;
    &lt;xsl:copy-of 
         select=".[amount gt 1000.00 and $branch/name eq 'Skipton']"/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:stream&gt;</eg>
                  <p>The raw expression tree for the <elcode>xsl:stream</elcode> instruction is like
                     this:</p>
                  <g:graph mclimit="3.0" width="800" height="420">
                     <g:node label="xsl:stream">
                        <g:node label="xsl:for-each">
                           <g:node label="path">
                              <g:node label="child::account"/>
                              <g:node label="child::transaction"/>
                           </g:node>
                           <g:node label="sequence">
                              <g:node label="$branch :=">
                                 <g:node label="filter">
                                    <g:node label="path">
                                       <g:node label="doc()">
                                          <g:node label="'branches.xml'"/>
                                       </g:node>
                                       <g:node label="descendant::branch"/>
                                    </g:node>
                                    <g:node label="=">
                                       <g:node label="child::code"/>
                                       <g:node label="path">
                                          <g:node label="current()"/>
                                          <g:node label="child::branch"/>
                                       </g:node>
                                    </g:node>
                                 </g:node>
                              </g:node>
                              <g:node label="xsl:copy-of">
                                 <g:node label="filter">
                                    <g:node label="."/>
                                    <g:node label="and">
                                       <g:node label="gt">
                                          <g:node label="child::amount"/>
                                          <g:node label="1000.00"/>
                                       </g:node>
                                       <g:node label="eq">
                                          <g:node label="path">
                                             <g:node label="$branch"/>
                                             <g:node label="child::name"/>
                                          </g:node>
                                          <g:node label="'Skipton'"/>
                                       </g:node>
                                    </g:node>
                                 </g:node>
                              </g:node>
                           </g:node>
                        </g:node>
                     </g:node>
                  </g:graph>

                  <p>This tree must first be expanded to include the effects of atomization. The
                     result of <code>child::code</code> is atomized, because it is an argument to a
                     comparison operator. The same applies to <code>child::branch</code>,
                        <code>child::amount</code>, and <code>child::name</code>. All these
                     expressions therefore have an implicit <code>descendant-or-self::node()</code>
                     added to them. In addition, the <elcode>xsl:copy-of</elcode> instruction also
                     accesses all the descendant nodes of the node being copied, so this results in
                     another implicit <code>descendant-or-self::node()</code> bing added to the
                     tree.</p>
                  <p>After adding these nodes, and tracing the use of variables and context, the
                     expression tree and its data flow graph look like this. For space reasons, the
                        <code>descendant-or-self::node()</code> e-nodes are labelled "//"</p>

                  <g:graph width="800" height="500">

                     <g:node id="T" label="xsl:stream">
                        <g:node label="xsl:for-each">
                           <g:node id="p0" label="path">
                              <g:node id="ca" label="child::account"/>
                              <g:node id="cc" label="child::transaction"/>
                           </g:node>
                           <g:node label="sequence">
                              <g:node id="vardecl" label="$branch :=">
                                 <g:node id="f1" label="filter">
                                    <g:node id="docpath" label="path">
                                       <g:node id="doc" label="doc()">
                                          <g:node label="'branches.xml'"/>
                                       </g:node>
                                       <g:node id="descbranch" label="descendant::branch"/>
                                    </g:node>
                                    <g:node label="=">
                                       <g:node id="p1" label="path">
                                          <g:node id="childcode" label="child::code"/>
                                          <g:node id="dd1" label="//"/>
                                       </g:node>
                                       <g:node id="p2" label="path">
                                          <g:node id="current" label="current()"/>
                                          <g:node id="p3" label="path">
                                             <g:node id="childbranch" label="child::branch"/>
                                             <g:node id="dd3" label="//"/>
                                          </g:node>
                                       </g:node>
                                    </g:node>
                                 </g:node>
                              </g:node>
                              <g:node label="xsl:copy-of">
                                 <g:node id="copypath" label="path">
                                    <g:node id="f2" label="filter">
                                       <g:node id="dot" label="."/>
                                       <g:node label="and">
                                          <g:node label="gt">
                                             <g:node id="p4" label="path">
                                                <g:node id="camt" label="child::amount"/>
                                                <g:node id="d4" label="//"/>
                                             </g:node>
                                             <g:node label="1000.00"/>
                                          </g:node>
                                          <g:node label="eq">
                                             <g:node id="p5" label="path">
                                                <g:node id="varref" label="$branch"/>
                                                <g:node id="p6" label="path">
                                                  <g:node id="childname" label="child::name"/>
                                                  <g:node id="dd5" label="//"/>
                                                </g:node>
                                             </g:node>
                                             <g:node label="'Skipton'"/>
                                          </g:node>
                                       </g:node>
                                    </g:node>
                                    <g:node id="copydesc" label="//"/>
                                 </g:node>
                              </g:node>
                           </g:node>
                        </g:node>
                     </g:node>
                     <g:node id="dummy0" label="" shape="circle" height="0.02" width="0.02" color="white" pos="100,400!"/>
                     <g:node id="dummy1" label="" shape="circle" height="0.02" width="0.02" color="white" pos="500,600!"/>
                     <g:edge from="T" to="ca" color="red" constraint="false"/>
                     <!--<g:edge from="dummy0" to="ca" color="red" constraint="false"/>-->
                     <g:edge from="ca" to="cc" color="red" constraint="false"/>
                     <g:edge from="cc" to="p0" color="red" constraint="false"/>
                     <g:edge from="p0" to="current" color="red" constraint="false"/>
                     <g:edge from="current" to="childbranch" color="red" constraint="false"/>
                     <g:edge from="childbranch" to="dd3" color="red" constraint="false"/>
                     <g:edge from="dd3" to="p3" color="red" constraint="false"/>
                     <g:edge from="p3" to="p2" color="red" constraint="false"/>
                     <g:edge from="p0" to="dummy1" color="red" constraint="false" arrowhead="none"/>
                     <g:edge from="dummy1" to="dot" color="red" constraint="false"/>
                     <g:edge from="dot" to="camt" color="red" constraint="false"/>
                     <g:edge from="dot" to="f2" color="red" constraint="false"/>
                     <g:edge from="f2" to="copydesc" color="red" constraint="false"/>
                     <g:edge from="copydesc" to="copypath" color="red" constraint="false"/>
                     <g:edge from="camt" to="d4" color="red" constraint="false"/>
                     <g:edge from="d4" to="p4" color="red" constraint="false"/>
                     <g:edge from="doc" to="descbranch" color="red" constraint="false"/>
                     <g:edge from="descbranch" to="docpath" color="red" constraint="false"/>
                     <g:edge from="docpath" to="childcode" color="red" constraint="false"/>
                     <g:edge from="childcode" to="dd1" color="red" constraint="false"/>
                     <g:edge from="dd1" to="p1" color="red" constraint="false"/>
                     <g:edge from="docpath" to="f1" color="red" constraint="false"/>
                     <g:edge from="f1" to="vardecl" color="red" constraint="false"/>
                     <g:edge from="vardecl" to="varref" color="red" constraint="false"/>
                     <g:edge from="varref" to="childname" color="red" constraint="false"/>
                     <g:edge from="childname" to="dd5" color="red" constraint="false"/>
                     <g:edge from="dd5" to="p6" color="red" constraint="false"/>
                     <g:edge from="p6" to="p5" color="red" constraint="false"/>
                  </g:graph>

                  <p>The paths emanating from the root e-node (the <elcode>xsl:stream</elcode>
                     instruction) can be seen on the simplified diagram:</p>

                  <g:graph>
                     <g:node label="xsl:stream">
                        <g:node label="child::account" edge-color="red">
                           <g:node label="child::transaction" edge-color="red">
                              <g:node label="path" edge-color="red">
                                 <g:node label="." edge-color="red">
                                    <g:node label="child::amount" edge-color="red">
                                       <g:node label="//" edge-color="red">
                                          <g:node label="path" edge-color="red"/>
                                       </g:node>
                                    </g:node>
                                    <g:node label="filter" edge-color="red">
                                       <g:node label="//" edge-color="red">
                                          <g:node label="path" edge-color="red"/>
                                       </g:node>
                                    </g:node>
                                 </g:node>
                              </g:node>
                              <g:node label="current()" edge-color="red">
                                 <g:node label="child::branch" edge-color="red">
                                    <g:node label="//" edge-color="red">
                                       <g:node label="path" edge-color="red">
                                          <g:node label="path" edge-color="red"/>
                                       </g:node>
                                    </g:node>
                                 </g:node>
                              </g:node>
                           </g:node>
                        </g:node>
                     </g:node>
                  </g:graph>


                  <p>In this tree there are three paths in which <code>child::transaction</code> is
                     followed by a downward selection. The construct is therefore not streamable,
                     and the processor must report a static error.</p>
                  <p>The code can be made streamable by including a call to the
                        <function>copy-of</function> function, thus:</p>
                  <eg xml:space="preserve">&lt;xsl:stream href="transactions.xml"&gt; 
  &lt;xsl:for-each select="account/transaction/copy-of()"&gt;
    &lt;xsl:variable name="branch" 
       select="doc('branches.xml')//branch[code = current()/branchCode]"/&gt;
    &lt;xsl:copy-of select=".[amount gt 1000.00 and $branch/name eq 'Skipton']"/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:stream&gt;</eg>
                  <p>The effect of this on the path analysis is that all the three selections that
                     previously depended on <code>child::transaction</code> now depend on the result
                     of the <code>copy-of()</code> call. This always returns newly constructed
                     nodes, so these dependencies no longer lead back to the
                        <elcode>xsl:stream</elcode> instruction, and can therefore be excluded from
                     the path map.</p>
               </example>
            </div3>
            <div3 id="streamability-analysis-notes">
               <head>Notes on the streamability algorithm</head>
               <p>The algorithm for creating a path map representing the axes of navigation through
                  a source document is inspired by the algorithms used for document projection in
                     <bibref ref="marian-simeon"/>.</p>

               <p>There are a number of differences, however:</p>
               <olist>
                  <item>
                     <p>The algorithm published by Marian and Simon is for XQuery rather than XSLT.
                        Moreover, it is for a core subset of XQuery, since the authors were able to
                        build on previous work showing that XQuery, already a smaller language than
                        XSLT, could be reduced to an even smaller core. The analysis for XSLT is
                        inevitably more complex because of the need to handle dynamic template
                        invocation. However, a practical implementation could simplify the
                        expression tree very substantially before analysis starts, since much of the
                        information on the tree makes no contribution to the analysis.</p>
                  </item>
                  <item>
                     <p>Marian and Simon analyze the paths followed by a query in order to
                        determine which parts of the input tree are reachable. This means, for
                        example, that duplicate paths can be eliminated, and that it makes no
                        difference whether two paths are mutually exclusive. For streamability
                        analysis, multiple instances of navigation to the same place are
                        significant, and it is also necessary to consider the paths as a tree, not
                        simply as a set of independent paths from the root to the leaves.</p>
                  </item>
               </olist>
            </div3>
         </div2>
         <div2 id="copy-of-function">
            <head>The copy-of function</head>
            <proto name="copy-of" class="xslt" return-type="node()"/>
            <proto name="copy-of" class="xslt" return-type="node()?">
               <arg name="node" type="node()" emptyOk="yes"/>
            </proto>
            <p>The zero-argument form of this function has the same effect as calling
                  <code>copy-of(.)</code>, that is, supplying the context item as an implicit
               argument.</p>
            <p>The function returns a deep copy of the node supplied as the argument
                  <code>$node</code>. If the argument is an empty sequence, the function returns an
               empty sequence. The effect is the same as that of the <elcode>xsl:copy-of</elcode>
               instruction with <code>copy-namespaces</code> set to <code>yes</code> and
                  <code>validation</code> set to <code>preserve</code>.</p>
            <p>If the function is called more than once with the same argument, it is <termref def="dt-implementation-dependent">implementation-dependent</termref> whether each
               call returns the same node, or whether multiple calls return different nodes. That
               is, the result of the expression <code>copy-of($X) is copy-of($X)</code> is <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p>
            <p>The <function>copy-of</function> function is available for use (and is primarily
               intended for use) when a source document is processed using streaming. It can also be
               used when not streaming. The effect is to take a copy of the subtree rooted at the
               current node, and to make this available as a normal tree, that can be processed
               without any of the restrictions that apply while streaming, for example only being
               able to process children once. The copy, of course, does not include siblings or
               ancestors of the context node, so any attempt to navigate to siblings or ancestors
               will result in an empty sequence being returned.</p>
            <example>
               <head>Using <code>copy-of()</code> while streaming</head>
               <p>This example copies from the source document all employees who work in marketing
                  and are based in Dubai. Because there are two accesses using the child axis, it is
                  not possible to do this without buffering each employee in memory, which can be
                  achieved using the <function>copy-of</function> function.</p>
               <eg xml:space="preserve">&lt;xsl:stream href="employees.xml"&gt;
  &lt;xsl:sequence select="employees/employee/copy-of()
                          [department='Marketing' and location='Dubai']"/&gt;
&lt;/xsl:stream&gt;</eg>
            </example>
         </div2>
         <div2 id="snapshot">
            <head>The snapshot function</head>
            <proto name="snapshot" class="xslt" return-type="node()"/>
            <proto name="snapshot" class="xslt" return-type="node()?">
               <arg name="node" type="node()" emptyOk="yes"/>
            </proto>
            <p>The zero-argument form of this function has the same effect as calling
                  <code>snapshot(.)</code>, that is, supplying the context item as an implicit
               argument.</p>
            <p>The function returns a <termref def="dt-snapshot">snapshot</termref> of the node
               supplied as the argument <code>$node</code>. If the argument is an empty sequence,
               the function returns an empty sequence.</p>
            <p>If the function is called more than once with the same argument, it is <termref def="dt-implementation-dependent">implementation-dependent</termref> whether each
               call returns the same node, or whether multiple calls return different nodes. That
               is, the result of the expression <code>snapshot($X) is snapshot($X)</code> is
                  <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p>
            <p>
               <termdef id="dt-snapshot" term="snapshot">A <term>snapshot</term> of a
                  node <var>N</var> is a deep copy of <var>N</var>, as produced by the
                     <elcode>xsl:copy-of</elcode> instruction with <code>copy-namespaces</code> set
                  to <code>yes</code> and <code>validation</code> set to <code>preserve</code>, with
                  the additional property that for every ancestor of <var>N</var>, the copy also has
                  a corresponding ancestor whose name, node-kind, and base URI are the same as the
                  corresponding ancestor of <var>N</var>, and that has copies of the attributes and
                  namespaces of the corresponding ancestor of <var>N</var>. But the ancestor has a
                  type annotation of <code>xs:anyType</code>, has the properties
                  <code>nilled</code>, <code>is-ID</code>, and <code>is-IDREF</code> set to false,
                  and has no children other than the child that is a copy of <var>N</var> or one of
                  its ancestors.</termdef>
            </p>
            <p>More formally, a <termref def="dt-snapshot">snapshot</termref> of a node is the
               result of the following function.</p>
            <eg xml:space="preserve">&lt;xsl:function name="fn:snapshot" as="node()?"&gt;
  &lt;xsl:param name="node" as="node()?"/&gt;
  &lt;xsl:sequence select="f:parent-copy($node, $node/ancestor::node(), 1)"/&gt;
&lt;/xsl:function&gt;
 
&lt;xsl:function name="f:parent-copy" as="node()?"&gt;
  &lt;xsl:param name="node" as="node()?"/&gt;
  &lt;xsl:param name="ancestors" as="node()*"/&gt;
  &lt;xsl:param name="level" as="xs:integer"/&gt;    
  &lt;xsl:choose&gt;
    &lt;xsl:when test="empty($node)"&gt;
      &lt;xsl:sequence select="()"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:when test="empty($ancestors)"&gt;
      &lt;xsl:sequence select="$node/descendant-or-self::node()[$level]"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:variable name="p" as="node()?"&gt;
        &lt;xsl:for-each select="$ancestors[last()]"&gt;
          &lt;xsl:copy validation="strip"&gt;
            &lt;xsl:copy-of select="@*" validation="preserve"/&gt;
            &lt;xsl:copy-of select="$node" validation="preserve"/&gt;
          &lt;/xsl:copy&gt;
        &lt;/xsl:for-each&gt;
      &lt;/xsl:variable&gt;
      &lt;xsl:sequence select="f:parent-copy($p, 
                      $ancestors[position() lt last()], $level+1)"/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
  &lt;/xsl:function&gt;</eg>
            <note>
               <p>The <code>&lt;xsl:when test="empty($ancestors)"&gt;</code> branch of this code is a
                  little obscure. At this stage <code>$node</code> represents the root of a
                  constructed tree that includes copies of all the ancestors of the original node
                  supplied to the <function>snapshot</function> function, together with that node
                  and all its descendants. The result of the <function>snapshot</function> function
                  is not <code>$node</code> (the root of this constructed tree), but rather the node
                  within the constructed tree that corresponds to the original node. This can be
                  found by searching the descendants of <code>$node</code>. In fact it is the node
                  that is found <code>$level</code> nodes below <code>$node</code>, which can be
                  selected as <code>$node/descendant-or-self::node()[$level]</code> because each
                  relevant node has exactly one child.</p>
            </note>
            <issue id="issue-snapshot-on-root-node" status="open"><p>The code given here is incorrect in the case
            where <code>snapshot</code> is applied to a parentless node: it should return a copy
            of the node, but actually returns the original.</p></issue>
            <p>The <function>snapshot</function> function is available for use (and is primarily
               intended for use) when a source document is processed using streaming. It can also be
               used when not streaming. The effect is to take a copy of the subtree rooted at the
               current node, along with copies of the ancestors and their attributes, and to make
               this available as a normal tree, that can be processed without any of the
               restrictions that apply while streaming, for example only being able to process
               children once. The copy, of course, does not include siblings of the context node or
               of its ancestors, so any attempt to navigate to these siblings will result in an
               empty sequence being returned.</p>
            <example>
               <head>Using <code>snapshot()</code> while streaming</head>
               <p>This example copies from the source document all employees who work in marketing
                  and are based in Dubai. It assumes that employees are grouped by location. Because
                  there are two accesses using the child axis (referencing <code>department</code>
                  and <code>salary</code>), it is not possible to do this without buffering each
                  employee in memory. The <function>snapshot</function> function is used in
                  preference to the simpler <function>copy-of</function> so that access to
                  attributes of the parent <code>location</code> element remains possible.</p>
               <eg xml:space="preserve">&lt;xsl:stream href="employees.xml"&gt;
  &lt;xsl:for-each select="locations/location[@name='Dubai']
                          /employee/snapshot()[department='Marketing']"&gt;
    &lt;employee&gt;
      &lt;location code="{../@code}"/&gt;
      &lt;salary value="{salary}"/&gt;
    &lt;/employee&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:stream&gt;</eg>
            </example>

         </div2>
         <div2 id="outermost">
            <head>The outermost function</head>
            <proto name="outermost" class="xslt" return-type="node()*">
               <arg name="nodes" type="node()*"/>
            </proto>
            <p>The <function>outermost</function> takes as input a sequence of nodes, and returns
               those nodes within the sequence that have no ancestor that is itself a member of the
               sequence; the nodes are returned in document order with duplicates eliminated.</p>
            <p>That is, the effect of the function is equivalent to the expression:</p>
            <eg xml:space="preserve" diff="chg" at="F">$nodes[not(ancestor::node() intersect $nodes)]</eg>
            <p>For example, the expression <code>outermost(//table)</code> selects every
                  <code>table</code> element that is not nested within another <code>table</code>
               element.</p>
            <note>
               <p>As noted in <specref ref="notes-on-descendant-axis-streamability"/>, path
                  expressions such as <code>.//section/head</code> cause a problem in streamability
                  analysis because there is no guarantee that a nested-loop evaluation of the
                  expression will deliver nodes in document order. This is caused by the fact that
                     <code>section</code> elements can potentially contain further
                     <code>section</code> elements.</p>
               <p>This is not the case for the expression <code>outermost(.//section)/head</code>:
                  for this expression, a nested-loop evaluation strategy will return the nodes in
                  document order.</p>

               <p>There are two situations in which the <function>outermost</function> function can
                  potentially be useful. Firstly, if it is known that <code>section</code> elements
                  will never be nested, the expression <code>outermost(.//section)</code> is
                  equivalent to <code>.//section</code>, but is more tractable in terms of its
                  streamability. Secondly, if the <code>section</code> elements are nested, there
                  may well be cases where only the outermost sections are to be processed.</p>

               <issue id="issue-streamability-of-outermost" status="open">
                  <p>Note however that the streamability analysis as currently written does not take
                     calls on the <code>outermost</code> function into account.</p>
               </issue>

            </note>
         </div2>
         <div2 id="innermost">
            <head>The innermost function</head>
            <proto name="innermost" class="xslt" return-type="node()*">
               <arg name="nodes" type="node()*"/>
            </proto>
            <p>The <function>innermost</function> takes as input a sequence of nodes, and returns
               every node within the sequence 
               <phrase diff="chg" at="F">that is not an ancestor of another node within</phrase>
               the sequence; the nodes are returned in document order with duplicates
               eliminated.</p>
            <p>That is, the effect of the function is equivalent to the expression:</p>
            <eg xml:space="preserve" diff="chg" at="F">$nodes except $nodes/ancestor::node()</eg>
            <p>For example, the expression <code>innermost(//table)</code> selects every
                  <code>table</code> element that does not contain a nested <code>table</code>
               element.</p>
            <note>
               <p>Unlike the <function>outermost</function> function, this function does not help in
                  making expressions streamable. It is provided purely for symmetry.</p>
            </note>
         </div2>
         <div2 id="has-children">
            <head>The has-children function</head>
            <proto name="has-children" class="xslt" return-type="xs:boolean"/>
            <p><emph>To be specified.</emph></p>
            <issue id="issue-has-children" status="open">
               <p>The Working Group is considering defining a function <code>has-children</code>
                  which returns true if the context item has one or more child nodes. This function
                  would be defined as <termref def="dt-motionless"/>, allowing it to be used for
                  example in the predicate of a pattern. Implementation requires a one-parser-event
                  lookahead. The primary use case is for creating lists or tables in streaming mode,
                  where the wrapper element (for example <code>ul</code> or <code>table</code>) is
                  to be generated only if the list is non-empty. Most current solutions to this
                  problem require two downward selections, one to test if the list is empty and one
                  to iterate over its contents. There is a solution using
                     <elcode>xsl:for-each-group</elcode> to generate a singleton group, but it
                  involves rather artificial coding.</p>
            </issue>
         </div2>
      </div1>
      <div1 id="add-func">
         <head>Additional Functions</head>
         <p>This section describes XSLT-specific additions to the <termref def="dt-core-function">core function</termref> library. Some of these additional functions also make use of
            information specified by <termref def="dt-declaration">declarations</termref> in the
            stylesheet; this section also describes these declarations.</p>
         <div2 id="multiple-source-documents">
            <head>Multiple Source Documents</head>

            <div3 id="document">
               <head>The <code>document</code> function</head>
               <proto class="xslt" name="document" return-type="node()" returnSeq="yes">
                  <arg name="uri-sequence" type="item()" seq="yes" emptyOk="yes"/>
               </proto>
               <proto class="xslt" name="document" return-type="node()" returnSeq="yes">
                  <arg name="uri-sequence" type="item()" seq="yes" emptyOk="yes"/>
                  <arg name="base-node" type="node()"/>
               </proto>
               <p>The <function>document</function> function allows access to XML documents
                  identified by a URI.</p>
               <p>The first argument contains a sequence of URI references. The second argument, if
                  present, is a node whose base URI is used to resolve any relative URI references
                  contained in the first argument.</p>
               <p>A sequence of absolute URI references is obtained as follows.</p>
               <ulist>
                  <item>
                     <p>For an item in <code>$uri-sequence</code> that is an instance of
                           <code>xs:string</code>, <code>xs:anyURI</code>, or
                           <code>xs:untypedAtomic</code>, the value is cast to
                           <code>xs:anyURI</code>. If the resulting URI reference is an absolute URI
                        reference then it is used <emph>as is</emph>. If it is a relative URI
                        reference, then it is resolved against the base URI of
                           <code>$base-node</code> if supplied, or against the base URI from the
                        static context otherwise (this will usually be the base URI of the
                        stylesheet module). A relative URI <phrase diff="add" at="F">reference</phrase> is resolved against a base URI using the
                        rules defined in <bibref ref="RFC3986"/>.</p>
                  </item>
                  <item>
                     <p>For an item in <code>$uri-sequence</code> that is a node, the node is
                           <termref def="dt-atomization">atomized</termref>. The result
                           <rfc2119>must</rfc2119> be a sequence whose items are all instances of
                           <code>xs:string</code>, <code>xs:anyURI</code>, or
                           <code>xs:untypedAtomic</code>. Each of these values is cast to
                           <code>xs:anyURI</code>, and if the resulting URI reference is an absolute
                        URI reference then it is used <emph>as is</emph>. If it is a relative URI
                        reference, then it is resolved against the base URI of
                           <code>$base-node</code> if supplied, or against the base URI of the node
                        that contained it otherwise.</p>
                  </item>
               </ulist>
               <note>
                  <p>The XPath rules for function calling ensure that it is a type error if the
                     supplied value of the second argument is anything other than a single node. If
                        <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref>
                     is enabled, then a sequence of nodes may be supplied, and the first node in the
                     sequence will be used.</p>
               </note>
               <p>Each of these absolute URI references is then processed as follows. Any fragment
                  identifier that is present in the URI reference is removed, and the resulting
                  absolute URI is cast to a string and then passed to the <xfunction>doc</xfunction>
                  function defined in <bibref ref="xpath-functions-11"/>. This returns a document node.
                  If an error occurs during evaluation of the <xfunction>doc</xfunction> function,
                  the processor <rfc2119>may</rfc2119> either signal this error in the normal way,
                  or <rfc2119>may</rfc2119> recover by ignoring the failure, in which case the
                  failing URI will not contribute any nodes to the result of the
                     <function>document</function> function.</p>
               <p>If the URI reference contained no fragment identifier, then this document node is
                  included in the sequence of nodes returned by the <function>document</function>
                  function.</p>
               <p>If the URI reference contained a fragment identifier, then the fragment identifier
                  is interpreted according to the rules for the media type of the resource
                  representation identified by the URI, and is used to select zero or more nodes
                  that are descendant-or-self nodes of the returned document node. As described in
                     <specref ref="initiating"/>, the media type is available as part of the
                  evaluation context for a transformation.</p>
               <p>
                  <error spec="XT" type="dynamic" class="RE" code="1160">
                     <p>When a URI reference <error.extra>supplied to the
                              <function>document</function> function</error.extra> contains a
                        fragment identifier, it is a <termref def="dt-recoverable-error">recoverable
                           dynamic error</termref> if the media type is not one that is recognized
                        by the processor, or if the fragment identifier does not conform to the
                        rules for fragment identifiers for that media type, or if the fragment
                        identifier selects something other than a sequence of nodes (for example, if
                        it selects a range of characters within a text node). <error.action>The
                              <termref def="dt-optional-recovery-action">optional recovery
                              action</termref> is to ignore the fragment identifier and return the
                           document node.</error.action>
                     </p>
                  </error> The set of media types recognized by a processor is <termref def="dt-implementation-defined">implementation-defined</termref>.</p>
               <imp-def-feature>The set of media types recognized by the processor, for the purpose
                  of interpreting fragment identifiers in URI references passed to the
                     <function>document</function> function, is
                  implementation-defined.</imp-def-feature>
               <note>
                  <p>The recovery action here is different from XSLT 1.0</p>
               </note>
               <p>The sequence of nodes returned by the function is in document order, with no
                  duplicates. This order has no necessary relationship to the order in which URIs
                  were supplied in the <code>$uri-sequence</code> argument.</p>
               <note>
                  <p>One effect of these rules is that unless XML entities or <code>xml:base</code>
                     are used, and provided that the base URI of the stylesheet module is known,
                        <code>document("")</code> refers to the document node of the containing
                     stylesheet module (the definitive rules are in <bibref ref="RFC3986"/>). The
                     XML resource containing the stylesheet module is processed exactly as if it
                     were any other XML document, for example there is no special recognition of
                        <elcode>xsl:text</elcode> elements, and no special treatment of comments and
                     processing instructions.</p>
               </note>
            </div3>
            <div3 id="uri-collection" at="C" diff="add">
               <head>The <code>uri-collection</code> function</head>
               <proto class="xslt" name="uri-collection" return-type="xs:string" returnSeq="yes"/>
               <proto class="xslt" name="uri-collection" return-type="xs:string" returnSeq="yes">
                  <arg name="href" type="xs:string" emptyOk="yes"/>
               </proto>
               <p>The <function>uri-collection</function> returns the document URIs of the documents
                  in a collection. Unlike the <xfunction>collection</xfunction> function, it does
                  not retrieve the documents themselves. </p>
               <p>The zero-argument form of the function returns the URIs of the documents in the
                  default collection. If the value of the default collection is undefined an error
                  is raised (<xerrorref spec="FO" class="DC" code="0002"/>).</p>

               <p>The single-argument form returns the URIs of the documents in the collection with
                  a given collection URI. If the value of the argument is an empty sequence, the
                  action is as for the zero-argument form of the function. If the argument is a
                  relative URI <phrase diff="add" at="F">reference</phrase>, it is resolved against the base URI property of the static context.
                  If the argument is not a valid <code>xs:anyURI</code>, or if the dynamic context
                  does not include a collection with this URI, then an error is raised (<xerrorref spec="FO" class="DC" code="0004"/>).</p>

               <p>The function is defined so that the expression <code>for $u in uri-collection(X)
                     return doc($u)</code>, if it succeeds, will always return the same result as
                  the expression <code>collection(X)</code>.</p>

               <note>
                  <p>There are several reasons it might be appropriate to retrieve the URIs of the
                     documents in a collection without retrieving the documents themselves. For
                     example:</p>
                  <ulist>
                     <item>
                        <p>It allows the documents to be processed in streaming mode using
                              <elcode>xsl:stream</elcode></p>
                     </item>
                     <item>
                        <p>It allows recovery from failures to read, parse, or validate individual
                           documents, by calling the <xfunction>doc</xfunction> function within the
                           scope of an <elcode>xsl:try</elcode> instruction</p>
                     </item>
                     <item>
                        <p>It allows access to non-XML documents within a collection using the
                              <function>unparsed-text</function> function</p>
                     </item>
                     <item>
                        <p>It allows selection of which documents to read based on their URI, for
                           example they can be filtered to select those whose URIs end in
                              <code>.xml</code></p>
                     </item>
                  </ulist>
                  <p>However, there may be collections that cannot be processed in this way:
                     specifically, those that contain nodes other than document nodes, and those
                     that contain document nodes having no document URI. Conversely, there may be
                     collections (such as those containing non-XML resources) that can be processed
                     using the <function>uri-collection</function> function but not the
                        <xfunction>collection</xfunction> function.</p>
               </note>
               <issue id="issue-transfer-uri-collection" status="open">
                  <p>A decision in principle has been reached for <code>uri-collection</code> to
                     become a standard XPath 2.1 function.</p>
               </issue>
            </div3>
         </div2>
         <div2 id="unparsed-text">
            <head>Reading Text Files</head>
            <div3 id="unparsed-text-function">
               <head>The <code>unparsed-text</code> function</head>
               <proto class="xslt" name="unparsed-text" return-type="xs:string" returnEmptyOk="yes">
                  <arg name="href" type="xs:string" emptyOk="yes"/>
               </proto>
               <proto class="xslt" name="unparsed-text" return-type="xs:string" returnEmptyOk="yes">
                  <arg name="href" type="xs:string" emptyOk="yes"/>
                  <arg name="encoding" type="xs:string"/>
               </proto>
               <issue id="issue-transfer-unparsed-text" status="open">
                  <p>A decision in principle has been reached for <code>unparsed-text</code> and
                        <code>unparsed-text-available</code> to become standard XPath 2.1
                     functions.</p>
               </issue>
               <p>The <function>unparsed-text</function> function reads an external resource (for
                  example, a file) and returns its contents as a string.</p>
               <p>The <code>$href</code> argument <rfc2119>must</rfc2119> be a string in the form of
                  a URI <phrase diff="add" at="F">reference, which</phrase> <rfc2119>must</rfc2119> contain no fragment identifier, and
                     <rfc2119>must</rfc2119> identify a resource that can be read as text. If the
                  URI is a relative URI <phrase diff="add" at="F">reference</phrase>, then it is resolved relative to the base URI from the
                  static context.</p>
               <p>If the value of the <code>$href</code> argument is an empty sequence, the function
                  returns an empty sequence.</p>
               <note>
                  <p>If a different base URI is appropriate (for example, when resolving a relative
                     URI <phrase diff="add" at="F">reference</phrase> read from a source document) 
                     <phrase diff="chg" at="F">then the stylesheet author should</phrase> resolve 
                     the relative URI <phrase diff="add" at="F">reference</phrase>  using
                     the <xfunction>resolve-uri</xfunction> function before passing it to the
                        <function>unparsed-text</function> function.</p>
               </note>
               <p>The <code>$encoding</code> argument, if present, is the name of an encoding. The
                  values for this attribute follow the same rules as for the <code>encoding</code>
                  attribute in an XML declaration. The only values which every <termref def="dt-implementation">implementation</termref> is <rfc2119>required</rfc2119>
                  to recognize are <code>utf-8</code> and <code>utf-16</code>.</p>
               <imp-def-feature>The set of encodings recognized by the
                     <function>unparsed-text</function> function, other than <code>utf-8</code> and
                     <code>utf-16</code>, is <termref def="dt-implementation-defined">implementation-defined</termref>.</imp-def-feature>
               <p>The encoding of the external resource is determined as follows:</p>
               <olist>
                  <item>
                     <p>external encoding information is used if available, otherwise</p>
                  </item>
                  <item>
                     <p>if the media type of the resource is <code>text/xml</code> or
                           <code>application/xml</code> (see <bibref ref="RFC2376"/>), or if it
                        matches the conventions <code>text/*+xml</code> or
                           <code>application/*+xml</code> (see <bibref ref="RFC3023"/> and/or its
                        successors), then the encoding is recognized as specified in <bibref ref="REC-xml"/>, otherwise</p>
                  </item>
                  <item>
                     <p>the value of the <code>$encoding</code> argument is used if present,
                        otherwise</p>
                  </item>
                  <item>
                     <p>the processor <rfc2119>may</rfc2119> use <termref def="dt-implementation-defined">implementation-defined</termref>
                        heuristics to determine the likely encoding, otherwise</p>
                  </item>
                  <item>
                     <p>UTF-8 is assumed.</p>
                  </item>
               </olist>
               <imp-def-feature>If no encoding is specified on a call to the
                     <function>unparsed-text</function> function, the processor
                     <rfc2119>may</rfc2119> use <termref def="dt-implementation-defined">implementation-defined</termref> heuristics to determine the likely
                  encoding.</imp-def-feature>
               <note>
                  <p>The above rules are chosen for consistency with <bibref ref="xinclude"/>. Files
                     with an XML media type are treated specially because there are use cases for
                     this function where the retrieved text is to be included as unparsed XML within
                     a CDATA section of a containing document, and because processors are likely to
                     be able to reuse the code that performs encoding detection for XML external
                     entities.</p>
               </note>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1170">
                     <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                           error</termref> if a URI <error.extra>supplied in the first argument to
                           the <function>unparsed-text</function> function</error.extra> contains a
                        fragment identifier, or if it cannot be used to retrieve a resource
                        containing text.</p>
                  </error>
               </p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1190">
                     <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                           error</termref> if a resource <error.extra>retrieved using the
                              <function>unparsed-text</function> function</error.extra> contains
                        octets that cannot be decoded into Unicode characters using the specified
                        encoding, or if the resulting characters are not permitted XML characters.
                        This includes the case where the <termref def="dt-processor">processor</termref> does not support the requested encoding.</p>
                  </error>
               </p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1200">
                     <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                           error</termref> if the second argument of the
                           <function>unparsed-text</function> function is omitted and the <termref def="dt-processor">processor</termref> cannot infer the encoding using
                        external information and the encoding is not UTF-8.</p>
                  </error>
               </p>
               <p>The result is a string containing the text of the resource retrieved using the
                  URI.</p>
               <note>
                  <p>If the text file contains characters such as <code>&lt;</code> and
                        <code>&amp;</code>, these will typically be output as <code>&amp;lt;</code>
                     and <code>&amp;amp;</code> when the string is written to a <termref def="dt-final-result-tree">final result tree</termref> and serialized as XML
                     or HTML. If these characters actually represent markup (for example, if the
                     text file contains HTML), then the stylesheet can attempt to write them as
                     markup to the output file using the <code>disable-output-escaping</code>
                     attribute of the <elcode>xsl:value-of</elcode> instruction (see <specref ref="disable-output-escaping"/>). Note, however, that implementations are
                     not required to support this feature.</p>
               </note>
               <example>
                  <head>Copying Unparsed HTML Boilerplate</head>
                  <p>This example attempts to read an HTML file and copy it, as HTML, to the
                     serialized output file:</p>
                  <eg xml:space="preserve">&lt;xsl:output method="html"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:value-of select="unparsed-text('header.html', 'iso-8859-1')"
                disable-output-escaping="yes"/&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:value-of select="unparsed-text('footer.html', 'iso-8859-1')"
                disable-output-escaping="yes"/&gt;
&lt;/xsl:template&gt;
</eg>
               </example>
               <example>
                  <head>Splitting an Input File into a Sequence of Lines</head>
                  <p>Often it is necessary to split a text file into a sequence of lines,
                     representing each line as a string. This can be achieved by using the
                        <function>unparsed-text</function> function in conjunction with the XPath
                        <xfunction>tokenize</xfunction> function. For example:</p>
                  <eg xml:space="preserve">&lt;xsl:for-each select="tokenize(unparsed-text($in), '\r?\n')"&gt;
 ...
&lt;/xsl:for-each&gt;</eg>
                  <p>Note that the <function>unparsed-text</function> function does not normalize
                     line endings. This example has been written to recognize both Unix and Windows
                     conventions for end-of-line, namely a single newline (#x0A) character or a
                     carriage return / line feed pair (#x0D #x0A). <phrase diff="add" at="C">It
                        differs from the <function>unparsed-text-lines</function> function, however,
                        in that it does not recognize a carriage return on its own as a line ending,
                        and it does not give special treatment to a newline appearing at the end of
                        the file.</phrase>
                  </p>
               </example>
            </div3>
            <div3 id="unparsed-text-lines" diff="add" at="A">
               <head>The <code>unparsed-text-lines</code> function</head>
               <proto class="xslt" name="unparsed-text-lines" return-type="xs:string" returnEmptyOk="yes" returnSeq="yes">
                  <arg name="href" type="xs:string" emptyOk="yes"/>
               </proto>
               <proto class="xslt" name="unparsed-text-lines" return-type="xs:string" returnEmptyOk="yes" returnSeq="yes">
                  <arg name="href" type="xs:string" emptyOk="yes"/>
                  <arg name="encoding" type="xs:string"/>
               </proto>
               <p>The <function>unparsed-text-lines</function> function reads an external resource
                  (for example, a file) and returns its contents as a sequence of strings, separated
                  at newline boundaries.</p>
               <p>The result of the single-argument function is the same as the result of the
                  expression <code>tokenize(unparsed-text($href),
                     '\r\n|\r|\n')[not(position()=last() and .='')]</code>. The result of the
                  two-argument function is the same as the result of the expression
                     <code>tokenize(unparsed-text($href, $encoding),
                     '\r\n|\r|\n'))[not(position()=last() and .='')]</code>.</p>
               <p>The result is a thus a sequence of strings containing the text of the resource
                  retrieved using the URI, each string representing one line of text. Lines are
                  separated by one of the sequences #x0A, #x0D, or #x0D #x0A. The characters
                  representing the newline are not included in the returned strings. If there are
                  two adjacent newline sequences, a zero-length string will be returned to represent
                  the empty line; but if the external resource ends with a newline sequence, no
                  zero-length string will be returned as the last item in the result.</p>
               <note>
                  <p>This function has been added in XSLT 2.1 for three reasons: to do the line
                     splitting in a way consistent with the rules applied during XML parsing; to do
                     it without recourse to regular expressions (which is likely to be more
                     efficient), and to make it easier for processors to read the input file line by
                     line, which is likely to use less memory.</p>
               </note>
            </div3>
            <div3 id="unparsed-text-available">
               <head>The unparsed-text-available function</head>
               <p>Because errors in evaluating the <function>unparsed-text</function>
                  <phrase diff="add" at="C">and <function>unparsed-text-lines</function></phrase>
                  functions are non-recoverable, two functions are provided to allow a stylesheet to
                  determine whether a call with particular arguments would succeed:</p>
               <proto class="xslt" name="unparsed-text-available" return-type="xs:boolean">
                  <arg name="href" type="xs:string" emptyOk="yes"/>
               </proto>
               <proto class="xslt" name="unparsed-text-available" return-type="xs:boolean">
                  <arg name="href" type="xs:string" emptyOk="yes"/>
                  <arg name="encoding" type="xs:string" emptyOk="yes"/>
               </proto>
               <p>The <function>unparsed-text-available</function> function determines whether a
                  call on the <function>unparsed-text</function> function with identical arguments
                  would return a string.</p>
               <p>If the first argument is an empty sequence, the function returns false. If the
                  second argument is an empty sequence, the function behaves as if the second
                  argument were omitted.</p>
               <p>In other cases, the function returns true if a call on
                     <function>unparsed-text</function> with the same arguments would succeed, and
                  false if a call on <function>unparsed-text</function> with the same arguments
                  would fail with a non-recoverable dynamic error.</p>
               <note>
                  <p>This requires that the <function>unparsed-text-available</function> function
                     should actually attempt to read the resource identified by the URI, and check
                     that it is correctly encoded and contains no characters that are invalid in
                     XML. Implementations may avoid the cost of repeating these checks for example
                     by caching the validated contents of the resource, to anticipate a subsequent
                     call on the <function>unparsed-text</function>
                     <phrase diff="add" at="A">or <function>unparsed-text-lines</function>
                     </phrase> function. Alternatively, implementations may be able to rewrite an
                     expression such as <code>if (unparsed-text-available(A)) then unparsed-text(A)
                        else ...</code> to generate a single call internally.</p>
               </note>
               <p>The functions <function>unparsed-text</function>, <phrase diff="add" at="A">
                     <function>unparsed-text-lines</function>
                  </phrase>, and <function>unparsed-text-available</function> have the same
                  requirement for <xtermref spec="FO" ref="stable">stability</xtermref> as the functions <xfunction>doc</xfunction> and
                     <xfunction>doc-available</xfunction> defined in <bibref ref="xpath-functions-11"/>. This means that unless the user has explicitly stated a requirement for a
                  reduced level of stability, either of these functions if called twice with the
                  same arguments during the course of a transformation <rfc2119>must</rfc2119>
                  return the same results each time; moreover, the results of a call on
                     <function>unparsed-text-available</function>
                  <rfc2119>must</rfc2119> be consistent with the results of a subsequent call on
                     <function>unparsed-text</function>
                  <phrase diff="add" at="A">or <function>unparsed-text-lines</function>
                  </phrase> with the same arguments.</p>
               <issue id="issue-function-stability" status="open">
                  <p>The functions in this specification need to be classified more clearly in terms of their
                  stability properties, along the lines being developed in Functions and Operators.</p>
               </issue>
            </div3>
         </div2>
         <div2 id="key">
            <head>Keys</head>
            <p>Keys provide a way to work with documents that contain an implicit cross-reference
               structure. They make it easier to locate the nodes within a document that have a
               given value for a given attribute or child element, and they provide a hint to the
               implementation that certain access paths in the document need to be efficient.</p>
            <div3 id="xsl-key">
               <head>The <elcode>xsl:key</elcode> Declaration</head>
               <e:element-syntax name="key">
                  <e:in-category name="declaration"/>
                  <e:attribute name="name" required="yes">
                     <e:data-type name="qname"/>
                  </e:attribute>
                  <e:attribute name="match" required="yes">
                     <e:data-type name="pattern"/>
                  </e:attribute>
                  <e:attribute name="use">
                     <e:data-type name="expression"/>
                  </e:attribute>
                  <e:attribute name="collation" required="no">
                     <e:data-type name="uri"/>
                  </e:attribute>
                  <e:model name="sequence-constructor"/>
                  <e:allowed-parents>
                     <e:parent name="stylesheet"/>
                     <e:parent name="transform"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p>The <elcode>xsl:key</elcode>
                  <termref def="dt-declaration">declaration</termref> is used to declare <termref def="dt-key">keys</termref>. The <code>name</code> attribute specifies the name
                  of the key. The value of the <code>name</code> attribute is a <termref def="dt-qname">QName</termref>, which is expanded as described in <specref ref="qname"/>. The <code>match</code> attribute is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="NT-Pattern" xlink:type="simple">Pattern</nt>; an <elcode>xsl:key</elcode> element applies to all nodes that
                  match the pattern specified in the <code>match</code> attribute.</p>
               <p>
                  <termdef id="dt-key" term="key">A <term>key</term> is defined as a set of
                        <elcode>xsl:key</elcode> declarations in the <termref def="dt-stylesheet">stylesheet</termref> that share the same name.</termdef>
               </p>
               <p>The value of the key may be specified either using the <code>use</code> attribute
                  or by means of the contained <termref def="dt-sequence-constructor">sequence
                     constructor</termref>.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="1205">
                     <p>It is a <termref def="dt-static-error">static error</termref> if an
                           <elcode>xsl:key</elcode> declaration has a <code>use</code> attribute and
                        has non-empty content, or if it has empty content and no <code>use</code>
                        attribute.</p>
                  </error>
               </p>
               <p>If the <code>use</code> attribute is present, its value is an <termref def="dt-expression">expression</termref> specifying the values of the key. The
                  expression will be evaluated with <phrase diff="chg" at="D">a <termref def="dt-singleton-focus">singleton focus</termref> based on the node that
                     matches the pattern</phrase>. The result of evaluating the expression is
                     <termref def="dt-atomization">atomized</termref>. </p>
               <p>Similarly, if a <termref def="dt-sequence-constructor">sequence
                     constructor</termref> is present, it is used to determine the values of the
                  key. The sequence constructor will be evaluated with the node that matches the
                  pattern as the context node. The result of evaluating the sequence constructor is
                     <termref def="dt-atomization">atomized</termref>.</p>
               <p>
                  <termdef id="dt-key-specifier" term="key specifier">The expression in the
                        <code>use</code> attribute and the <termref def="dt-sequence-constructor">sequence constructor</termref> within an <elcode>xsl:key</elcode>
                     declaration are referred to collectively as the <term>key specifier</term>. The
                     key specifier determines the values that may be used to find a node using this
                        <termref def="dt-key">key</termref>.</termdef>
               </p>
               <note>
                  <p>There is no requirement that all the values of a key should have the same
                     type.</p>
               </note>
               <p>The presence of an <elcode>xsl:key</elcode> declaration makes it easy to find a
                  node that matches the <code>match</code> pattern if any of the values of the
                     <termref def="dt-key-specifier">key specifier</termref> (when applied to that
                  node) are known. It also provides a hint to the implementation that access to the
                  nodes by means of these values needs to be efficient (many implementations are
                  likely to construct an index or hash table to achieve this). Note that the
                     <termref def="dt-key-specifier">key specifier</termref> in general returns a
                  sequence of values, and any one of these may be used to locate the node.</p>
               <note>
                  <p>An <elcode>xsl:key</elcode> declaration is not bound to a specific source
                     document. The source document to which it applies is determined only when the
                        <function>key</function> function is used to locate nodes using the key.
                     Keys can be used to locate nodes within any source document (including
                     temporary trees), but each use of the <function>key</function> function
                     searches one document only.</p>
               </note>
               <p>The optional <code>collation</code> attribute is used only when deciding whether
                  two strings are equal for the purposes of key matching. Specifically, two values
                     <code>$a</code> and <code>$b</code> are considered equal if the result of the
                  function call <code>compare($a, $b, $collation)</code> is zero. The effective
                  collation for an <elcode>xsl:key</elcode> declaration is the collation specified
                  in its <code>collation</code> attribute if present, resolved against the base URI
                  of the <elcode>xsl:key</elcode> element, or the <termref def="dt-default-collation">default collation</termref> that is in scope for the
                     <elcode>xsl:key</elcode> declaration otherwise; the effective collation must be
                  the same for all the <elcode>xsl:key</elcode> declarations making up a <termref def="dt-key">key</termref>.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="1210">
                     <p>It is a static error if the <elcode>xsl:key</elcode> declaration has a
                           <code>collation</code> attribute whose value (after resolving against the
                        base URI) is not a URI recognized by the implementation as referring to a
                        collation.</p>
                  </error>
               </p>
               <p>
                  <error spec="XT" type="static" class="SE" code="1220">
                     <p>It is a static error if there are several <elcode>xsl:key</elcode>
                        declarations in the <termref def="dt-stylesheet">stylesheet</termref> with
                        the same key name and different effective collations. Two collations are the
                        same if their URIs are equal under the rules for comparing
                           <code>xs:anyURI</code> values, or if the implementation can determine
                        that they are different URIs referring to the same collation.</p>
                  </error>
               </p>
               <p>It is possible to have:</p>
               <ulist>
                  <item>
                     <p>multiple <elcode>xsl:key</elcode> declarations with the same name;</p>
                  </item>
                  <item>
                     <p>a node that matches the <code>match</code> patterns of several different
                           <elcode>xsl:key</elcode> declarations, whether these have the same key
                        name or different key names;</p>
                  </item>
                  <item>
                     <p>a node that returns more than one value from its <termref def="dt-key-specifier">key specifier</termref>;</p>
                  </item>
                  <item>
                     <p>a key value that identifies more than one node (the key values for different
                        nodes do not need to be unique).</p>
                  </item>
               </ulist>
               <p>An <elcode>xsl:key</elcode> declaration with higher <termref def="dt-import-precedence">import precedence</termref> does not override
                  another of lower import precedence; all the <elcode>xsl:key</elcode> declarations
                  in the stylesheet are effective regardless of their import precedence.</p>
            </div3>
            <div3 id="keys">
               <head>The <function>key</function> Function</head>
               <proto class="xslt" name="key" return-type="node()" returnSeq="yes">
                  <arg name="key-name" type="xs:string"/>
                  <arg name="key-value" type="xs:anyAtomicType" seq="yes" emptyOk="yes"/>
               </proto>
               <proto class="xslt" name="key" return-type="node()" returnSeq="yes">
                  <arg name="key-name" type="xs:string"/>
                  <arg name="key-value" type="xs:anyAtomicType" seq="yes" emptyOk="yes"/>
                  <arg name="top" type="node()"/>
               </proto>
               <p>The <function>key</function> function does for keys what the <phrase diff="chg" at="D"><xfunction>element-with-id</xfunction></phrase> function does for
                  IDs.</p>
               <p>The <code>$key-name</code> argument specifies the name of the <termref def="dt-key">key</termref>. The value of the argument <rfc2119>must</rfc2119>
                  be a <termref def="dt-lexical-qname">lexical QName</termref>, which is expanded as
                  described in <specref ref="qname"/>.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1260">
                     <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                           error</termref> if the value <error.extra>of the first argument to the
                              <function>key</function> function</error.extra> is not a valid QName,
                        or if there is no namespace declaration in scope for the prefix of the
                        QName, or if the name obtained by expanding the QName is not the same as the
                        expanded name of any <elcode>xsl:key</elcode> declaration in the <termref def="dt-stylesheet">stylesheet</termref>. If the processor is able to
                        detect the error statically (for example, when the argument is supplied as a
                        string literal), then the processor <rfc2119>may</rfc2119> optionally signal
                        this as a <termref def="dt-static-error">static error</termref>.</p>
                  </error>
               </p>
               <p>The <code>$key-value</code> argument to the <function>key</function> function is
                  considered as a sequence. The set of requested key values is formed by atomizing
                  the supplied value of the argument, using the standard <termref def="dt-function-conversion-rules">function conversion rules</termref>. Each of
                  the resulting atomic values is considered as a requested key value. The result of
                  the function is a sequence of nodes, in document order and with duplicates
                  removed, comprising those nodes in the selected subtree (see below) that are
                  matched by an <elcode>xsl:key</elcode> declaration whose name is the same as the
                  supplied key name, where the result of evaluating the <termref def="dt-key-specifier">key specifier</termref> contains a value that is equal
                  to one of these requested key values, under the rules appropriate to the XPath
                     <code>eq</code> operator for the two values in question, using the
                     <code>collation</code> attributes of the <elcode>xsl:key</elcode> declaration
                  when comparing strings. No error is reported if two values are encountered that
                  are not comparable; they are regarded for the purposes of this function as being
                  not equal. </p>
               <note>
                  <p>Under the rules for the <code>eq</code> operator, untyped atomic values are
                     converted to strings, not to the type of the other operand. This means, for
                     example, that if the expression in the <code>use</code> attribute returns a
                     date, supplying an untyped atomic value in the call to the
                        <function>key</function> function will return an empty sequence.</p>
               </note>
               <p>If the second argument is an empty sequence, the result of the function will be an
                  empty sequence.</p>
               <p>Different rules apply when <phrase diff="chg" at="D"><termref def="dt-xslt-10-behavior">XSLT 1.0 compatible behavior</termref> is enabled.
                     Specifically, if any of the <elcode>xsl:key</elcode> elements in the definition
                     of the <termref def="dt-key">key</termref> is processed with XSLT 1.0
                     behavior</phrase>, then the value of the <termref def="dt-key-specifier">key
                     specifier</termref> and the value of the second argument of the
                     <function>key</function> function are both converted after atomization to a
                  sequence of strings, by applying a cast to each item in the sequence, before
                  performing the comparison.</p>
               <p>The third argument is used to identify the selected subtree. If the argument is
                  present, the selected subtree is the set of nodes that have <var>$top</var> as an
                  ancestor-or-self node. If the argument is omitted, the selected subtree is the
                  document containing the context node. This means that the third argument
                  effectively defaults to <code>/</code>.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1270">
                     <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                           error</termref> to call the <function>key</function> function with two
                        arguments if there is no <termref def="dt-context-node">context
                           node</termref>, or if the root of the tree containing the context node is
                        not a document node; or to call the function with three arguments if the
                        root of the tree containing the node supplied in the third argument is not a
                        document node.</p>
                  </error>
               </p>
               <p>The result of the <function>key</function> function can be described more
                  specifically as follows. The result is a sequence containing every node
                     <var>$N</var> that satisfies the following conditions:</p>
               <ulist>
                  <item>
                     <p>
                        <code>$N/ancestor-or-self::node() intersect $top</code> is non-empty. (If
                        the third argument is omitted, <code>$top</code> defaults to
                        <code>/</code>)</p>
                  </item>
                  <item>
                     <p>
                        <var>$N</var> matches the pattern specified in the <code>match</code>
                        attribute of an <elcode>xsl:key</elcode> declaration whose <code>name</code>
                        attribute matches the name specified in the <code>$key-name</code>
                        argument.</p>
                  </item>
                  <item>
                     <p>When the <termref def="dt-key-specifier">key specifier</termref> of that
                           <elcode>xsl:key</elcode> declaration is evaluated with a <termref def="dt-singleton-focus">singleton focus</termref> based on
                        <var>$N</var>, the <termref def="dt-atomization">atomized</termref> value of
                        the resulting sequence includes a value that compares equal to at least one
                        item in the atomized value of the sequence supplied as
                           <code>$key-value</code>, under the rules of the <code>eq</code> operator
                        with the collation selected as described above.</p>
                  </item>
               </ulist>
               <p>The sequence returned by the <function>key</function> function will be in document
                  order, with duplicates (that is, nodes having the same identity) removed. </p>
               <example>
                  <head>Using a Key to Follow Cross-References</head>
                  <p>For example, given a declaration</p>
                  <eg xml:space="preserve">&lt;xsl:key name="idkey" match="div" use="@id"/&gt;</eg>
                  <p>an expression <code>key("idkey",@ref)</code> will return the same nodes as
                        <code>id(@ref)</code>, assuming that the only ID attribute declared in the
                     XML source document is:</p>
                  <eg xml:space="preserve">&lt;!ATTLIST div id ID #IMPLIED&gt;</eg>
                  <p>and that the <code>ref</code> attribute of the context node contains no
                     whitespace.</p>
                  <p>Suppose a document describing a function library uses a <code>prototype</code>
                     element to define functions</p>
                  <eg xml:space="preserve">&lt;prototype name="sqrt" return-type="xs:double"&gt;
  &lt;arg type="xs:double"/&gt;
&lt;/prototype&gt;</eg>
                  <p>and a <code>function</code> element to refer to function names</p>
                  <eg xml:space="preserve">&lt;function&gt;sqrt&lt;/function&gt;</eg>
                  <p>Then the stylesheet could generate hyperlinks between the references and
                     definitions as follows:</p>
                  <eg xml:space="preserve">&lt;xsl:key name="func" match="prototype" use="@name"/&gt;

&lt;xsl:template match="function"&gt;
&lt;b&gt;
  &lt;a href="#{generate-id(key('func',.))}"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/a&gt;
&lt;/b&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="prototype"&gt;
  &lt;p&gt;
    &lt;a name="{generate-id()}"&gt;
      &lt;b&gt;Function: &lt;/b&gt;
      ...
    &lt;/a&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;</eg>
               </example>
               <p>When called with two arguments, the <function>key</function> function always
                  returns nodes that are in the same document as the context node. To retrieve a
                  node from any other document, it is necessary either to change the context node,
                  or to supply a third argument.</p>
               <example>
                  <head>Using Keys to Reference other Documents</head>
                  <p>For example, suppose a document contains bibliographic references in the form
                        <code>&lt;bibref&gt;XSLT&lt;/bibref&gt;</code>, and there is a separate XML
                     document <code>bib.xml</code> containing a bibliographic database with entries
                     in the form:</p>
                  <eg xml:space="preserve">&lt;entry name="XSLT"&gt;...&lt;/entry&gt;</eg>
                  <p>Then the stylesheet could use the following to transform the
                        <code>bibref</code> elements:</p>
                  <eg xml:space="preserve">&lt;xsl:key name="bib" match="entry" use="@name"/&gt;

&lt;xsl:template match="bibref"&gt;
  &lt;xsl:variable name="name" select="."/&gt;
  &lt;xsl:apply-templates select="document('bib.xml')/key('bib',$name)"/&gt;
&lt;/xsl:template&gt;</eg>
                  <note>
                     <p>This relies on the ability in XPath 2.0 to have a function call on the
                        right-hand side of the <code>/</code> operator in a path expression.</p>
                  </note>
                  <p>The following code would also work:</p>
                  <eg xml:space="preserve">&lt;xsl:key name="bib" match="entry" use="@name"/&gt;

&lt;xsl:template match="bibref"&gt;
  &lt;xsl:apply-templates select="key('bib', ., document('bib.xml'))"/&gt;
&lt;/xsl:template&gt;</eg>
               </example>
            </div3>
         </div2>
         <div2 id="defining-decimal-format">
            <head>Defining a Decimal Format</head>

            <change diff="del" at="D">
               <proto class="xslt" name="format-number" return-type="xs:string">
                  <arg name="value" type="numeric" emptyOk="yes"/>
                  <arg name="picture" type="xs:string"/>
               </proto>
               <proto class="xslt" name="format-number" return-type="xs:string">
                  <arg name="value" type="numeric" emptyOk="yes"/>
                  <arg name="picture" type="xs:string"/>
                  <arg name="decimal-format-name" type="xs:string"/>
               </proto>

               <p>The <xfunction>format-number</xfunction> function formats <code>$value</code> as a
                  string using the <term>picture string</term>
                  specified by the <code>$picture</code> argument and the decimal-format named by
                  the <code>$decimal-format-name</code> argument, or the default decimal-format, if
                  there is no <code>$decimal-format-name</code> argument. The syntax of the picture
                  string is described in <specref ref="processing-picture-string"/>.</p>
               <p>The <code>$value</code> argument may be of any numeric data type
                     (<code>xs:double</code>, <code>xs:float</code>, <code>xs:decimal</code>, or
                  their subtypes including <code>xs:integer</code>). Note that if an
                     <code>xs:decimal</code> is supplied, it is not automatically promoted to an
                     <code>xs:double</code>, as such promotion can involve a loss of precision.</p>
               <p>If the supplied value of the <code>$value</code> argument is an empty sequence,
                  the function behaves as if the supplied value were the <code>xs:double</code>
                  value <code>NaN</code>.</p>
               <p>The value of <code>$decimal-format-name</code>
                  <rfc2119>must</rfc2119> be a <termref def="dt-lexical-qname">lexical
                     QName</termref>, which is expanded as described in <specref ref="qname"/>. The
                  result of the function is the formatted string representation of the supplied
                  number.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1280">
                     <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                           error</termref> if the name specified as the
                           <code>$decimal-format-name</code> argument<error.extra> to the
                              <xfunction>format-number</xfunction> function</error.extra> is not a
                        valid <termref def="dt-qname">QName</termref>, or if its prefix has not been
                        declared in an in-scope namespace declaration, or if the <termref def="dt-stylesheet">stylesheet</termref> does not contain a declaration
                        of a decimal-format with a matching <termref def="dt-expanded-qname">expanded-QName</termref>. If the processor is able to detect the error
                        statically (for example, when the argument is supplied as a string literal),
                        then the processor <rfc2119>may</rfc2119> optionally signal this as a
                           <termref def="dt-static-error">static error</termref>. </p>
                  </error>
               </p>
            </change>

            <e:element-syntax name="decimal-format">
               <e:in-category name="declaration"/>
               <e:attribute name="name">
                  <e:data-type name="qname"/>
               </e:attribute>
               <e:attribute name="decimal-separator">
                  <e:data-type name="char"/>
               </e:attribute>
               <e:attribute name="grouping-separator">
                  <e:data-type name="char"/>
               </e:attribute>
               <e:attribute name="infinity">
                  <e:data-type name="string"/>
               </e:attribute>
               <e:attribute name="minus-sign">
                  <e:data-type name="char"/>
               </e:attribute>
               <e:attribute name="NaN">
                  <e:data-type name="string"/>
               </e:attribute>
               <e:attribute name="percent">
                  <e:data-type name="char"/>
               </e:attribute>
               <e:attribute name="per-mille">
                  <e:data-type name="char"/>
               </e:attribute>
               <e:attribute name="zero-digit">
                  <e:data-type name="char"/>
               </e:attribute>
               <e:attribute name="digit">
                  <e:data-type name="char"/>
               </e:attribute>
               <e:attribute name="pattern-separator">
                  <e:data-type name="char"/>
               </e:attribute>
               <e:empty/>
               <e:allowed-parents>
                  <e:parent name="stylesheet"/>
                  <e:parent name="transform"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:decimal-format</elcode> element controls the interpretation of a
                  <termref def="dt-picture-string">picture string</termref> used by the
                  <xfunction>format-number</xfunction> function.</p>
            <p><termdef id="dt-picture-string" term="picture string">The <term>picture string</term>
               is the string supplied as the second argument of the 
               <xfunction>format-number</xfunction> function.</termdef> </p>
            <note diff="add" at="D">
               <p>The <xfunction>format-number</xfunction> function, previously defined in this
                  specification, is now a core function defined in <bibref ref="xpath-functions-11"/>.
               </p>
            </note>
            <p>A <termref def="dt-stylesheet">stylesheet</termref> may contain multiple
                  <elcode>xsl:decimal-format</elcode> declarations and may include or import
                  <termref def="dt-stylesheet-module">stylesheet modules</termref> that also contain
                  <elcode>xsl:decimal-format</elcode> declarations. The name of an
                  <elcode>xsl:decimal-format</elcode> declaration is the value of its
                  <code>name</code> attribute, if any.</p>
            <p>
               <termdef id="dt-decimal-format" term="decimal format">All the
                     <elcode>xsl:decimal-format</elcode> declarations in a stylesheet that share the
                  same name are grouped into a named <term>decimal format</term>; those that have no
                  name are grouped into a single unnamed decimal format.</termdef>
            </p>
            <p>If a <termref def="dt-stylesheet">stylesheet</termref> does not contain a declaration
               of the unnamed decimal format, a declaration equivalent to an
                  <elcode>xsl:decimal-format</elcode> element with no attributes is implied.</p>
            <p>The attributes of the <elcode>xsl:decimal-format</elcode> declaration establish
               values for a number of variables used as input to the algorithm followed by the
                  <xfunction>format-number</xfunction> function. An outline of the purpose of each
               attribute is given below; however, the definitive explanations are given <phrase diff="chg" at="D">as part of the specification of
                     <xfunction>format-number</xfunction></phrase>.</p>
            <p>For any named <termref def="dt-decimal-format">decimal format</termref>, the
               effective value of each attribute is taken from an
                  <elcode>xsl:decimal-format</elcode> declaration that has that name, and that
               specifies an explicit value for the required attribute. If there is no such
               declaration, the default value of the attribute is used. If there is more than one
               such declaration, the one with highest <termref def="dt-import-precedence">import
                  precedence</termref> is used.</p>
            <p>For any unnamed <termref def="dt-decimal-format">decimal format</termref>, the
               effective value of each attribute is taken from an
                  <elcode>xsl:decimal-format</elcode> declaration that is unnamed, and that
               specifies an explicit value for the required attribute. If there is no such
               declaration, the default value of the attribute is used. If there is more than one
               such declaration, the one with highest <termref def="dt-import-precedence">import
                  precedence</termref> is used.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="1290">
                  <p>It is a <termref def="dt-static-error">static error</termref> if a named or
                     unnamed <termref def="dt-decimal-format">decimal format</termref> contains two
                     conflicting values for the same attribute in different
                        <elcode>xsl:decimal-format</elcode> declarations having the same <termref def="dt-import-precedence">import precedence</termref>, unless there is
                     another definition of the same attribute with higher import precedence.</p>
               </error>
            </p>
            <p>The following attributes control the interpretation of characters in the <termref def="dt-picture-string">picture string</termref> supplied to the
                  <xfunction>format-number</xfunction> function, and also specify characters that may
               appear in the result of formatting the number. In each case the value
                  <rfc2119>must</rfc2119> be a single character <errorref class="SE" code="0020"/>.</p>
            <ulist>
               <item>
                  <p>
                     <code>decimal-separator</code> specifies the character used for the
                        <var>decimal-separator-sign</var>; the default value is the period character
                        (<code>.</code>)</p>
               </item>
               <item>
                  <p>
                     <code>grouping-separator</code> specifies the character used for the
                        <var>grouping-sign</var>, which is typically used as a thousands separator;
                     the default value is the comma character (<code>,</code>)</p>
               </item>
               <item>
                  <p>
                     <code>percent</code> specifies the character used for the
                        <var>percent-sign</var>; the default value is the percent character
                        (<code>%</code>)</p>
               </item>
               <item>
                  <p>
                     <code>per-mille</code> specifies the character used for the
                        <var>per-mille-sign</var>; the default value is the Unicode per-mille
                     character (#x2030)</p>
               </item>
               <item>
                  <p>
                     <code>zero-digit</code> specifies the character used for the
                        <var>digit-zero-sign</var>; the default value is the digit zero
                        (<code>0</code>). This character <rfc2119>must</rfc2119> be a digit
                     (category Nd in the Unicode property database), and it <rfc2119>must</rfc2119>
                     have the numeric value zero. This attribute implicitly defines the Unicode
                     character that is used to represent each of the values 0 to 9 in the final
                     result string: Unicode is organized so that each set of decimal digits forms a
                     contiguous block of characters in numerical sequence.</p>
               </item>
            </ulist>
            <p>
               <error spec="XT" type="static" class="SE" code="1295">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the character
                     specified in the <code>zero-digit</code> attribute is not a digit or is a digit
                     that does not have the numeric value zero. </p>
               </error>
            </p>
            <p>The following attributes control the interpretation of characters in the <termref def="dt-picture-string">picture string</termref> supplied to the
                  <xfunction>format-number</xfunction> function. In each case the value
                  <rfc2119>must</rfc2119> be a single character <errorref class="SE" code="0020"/>.</p>
            <ulist>
               <item>
                  <p>
                     <code>digit</code> specifies the character used for the <var>digit-sign</var>
                     in the <termref def="dt-picture-string">picture string</termref>; the default
                     value is the number sign character (<code>#</code>)</p>
               </item>
               <item>
                  <p>
                     <code>pattern-separator</code> specifies the character used for the
                        <var>pattern-separator-sign</var>, which separates positive and negative
                     sub-pictures in a <termref def="dt-picture-string">picture string</termref>;
                     the default value is the semi-colon character (<code>;</code>)</p>
               </item>
            </ulist>
            <p>The following attributes specify characters or strings that may appear in the result
               of formatting the number:</p>
            <ulist>
               <item>
                  <p>
                     <code>infinity</code> specifies the string used for the
                        <var>infinity-symbol</var>; the default value is the string
                        <code>Infinity</code>
                  </p>
               </item>
               <item>
                  <p>
                     <code>NaN</code> specifies the string used for the <var>NaN-symbol</var>, which
                     is used to represent the value NaN (not-a-number); the default value is the
                     string <code>NaN</code>
                  </p>
               </item>
               <item>
                  <p>
                     <code>minus-sign</code> specifies the character used for the
                        <var>minus-symbol</var>; the default value is the hyphen-minus character
                        (<code>-</code>, #x2D). The value <rfc2119>must</rfc2119> be a single
                     character.</p>
               </item>
            </ulist>
            <p>
               <error spec="XT" type="static" class="SE" code="1300">
                  <p>It is a <termref def="dt-static-error">static error</termref> if, for any named
                     or unnamed decimal format, the variables representing characters used in a
                        <termref def="dt-picture-string">picture string</termref> do not each have
                     distinct values. These variables are <var>decimal-separator-sign</var>,
                        <var>grouping-sign</var>, <var>percent-sign</var>,
                     <var>per-mille-sign</var>, <var>digit-zero-sign</var>, <var>digit-sign</var>,
                     and <var>pattern-separator-sign</var>. </p>
               </error>
            </p>
            <p diff="add" at="D">Every (named or unnamed) decimal format defined in the <termref def="dt-stylesheet">stylesheet</termref> is added to the <xtermref spec="XP21" ref="dt-static-decimal-formats">statically known decimal formats</xtermref> in the
                  <xtermref spec="XP21" ref="dt-static-context">static context</xtermref> of every
               expression in the <termref def="dt-stylesheet">stylesheet</termref>, excluding
               expressions appearing in <code>[xsl:]use-when</code> attributes.</p>




            <div3 id="processing-picture-string" diff="del" at="D">
               <head>Processing the Picture String</head>
               <p>
                  The formatting of a number
                     is controlled by a <term>picture string</term>. The picture string is a
                     sequence of characters, in which the characters assigned to the variables
                        <var>decimal-separator-sign</var>, <var>grouping-sign</var>,
                        <var>zero-digit-sign</var>, <var>digit-sign</var> and
                        <var>pattern-separator-sign</var> are classified as active characters, and
                     all other characters (including the <var>percent-sign</var> and
                        <var>per-mille-sign</var>) are classified as passive characters.
               </p>
               <p>The <var>integer part</var> of the sub-picture is defined as the part that appears
                  to the left of the <var>decimal-separator-sign</var> if there is one, or the
                  entire sub-picture otherwise. The <var>fractional part</var> of the sub-picture is
                  defined as the part that appears to the right of the
                     <var>decimal-separator-sign</var> if there is one; it is a zero-length string
                  otherwise.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1310">
                     <p>The <termref def="dt-picture-string">picture string</termref>
                        <error.extra>supplied to the <xfunction>format-number</xfunction>
                           function</error.extra>
                        <rfc2119>must</rfc2119> conform to the following rules. <error.extra> See
                           full specification.</error.extra> It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if
                        the picture string does not satisfy these rules.</p>
                  </error>
               </p>
               <p>Note that in these rules the words "preceded" and "followed" refer to characters
                  anywhere in the string, they are not to be read as "immediately preceded" and
                  "immediately followed".</p>
               <ulist>
                  <item>
                     <p>A picture-string consists either of a sub-picture, or of two sub-pictures
                        separated by a <var>pattern-separator-sign</var>. A picture-string
                           <rfc2119>must not</rfc2119> contain more than one
                           <var>pattern-separator-sign</var>. If the picture-string contains two
                        sub-pictures, the first is used for positive values and the second for
                        negative values.</p>
                  </item>
                  <item>
                     <p>A sub-picture <rfc2119>must not</rfc2119> contain more than one
                           <var>decimal-separator-sign</var>.</p>
                  </item>
                  <item>
                     <p>A sub-picture <rfc2119>must not</rfc2119> contain more than one
                           <var>percent-sign</var> or <var>per-mille-sign</var>, and it
                           <rfc2119>must not</rfc2119> contain one of each.</p>
                  </item>
                  <item>
                     <p>A sub-picture <rfc2119>must</rfc2119> contain at least one
                           <var>digit-sign</var> or <var>zero-digit-sign</var>.</p>
                  </item>
                  <item>
                     <p>A sub-picture <rfc2119>must not</rfc2119> contain a passive character that
                        is preceded by an active character and that is followed by another active
                        character.</p>
                  </item>
                  <item>
                     <p>A sub-picture <rfc2119>must not</rfc2119> contain a
                           <var>grouping-separator-sign</var> adjacent to a
                           <var>decimal-separator-sign</var>.</p>
                  </item>
                  <item>
                     <p>The integer part of a sub-picture <rfc2119>must not</rfc2119> contain a
                           <var>zero-digit-sign</var> that is followed by a <var>digit-sign</var>.
                        The fractional part of a sub-picture <rfc2119>must not</rfc2119> contain a
                           <var>digit-sign</var> that is followed by a
                        <var>zero-digit-sign</var>.</p>
                  </item>
               </ulist>
               <p>The evaluation of the <xfunction>format-number</xfunction> function is described
                  below in two phases, an analysis phase and a formatting phase. The analysis phase
                  takes as its inputs the <termref def="dt-picture-string">picture string</termref>
                  and the variables derived from the relevant <elcode>xsl:decimal-format</elcode>
                  declaration, and produces as its output a number of variables with defined values.
                  The formatting phase takes as its inputs the number to be formatted and the
                  variables produced by the analysis phase, and produces as its output a string
                  containing a formatted representation of the number.</p>
               <note>
                  <p>Numbers will always be formatted with the most significant digit on the
                     left.</p>
               </note>
            </div3>
            <div3 id="analyzing-picture-string" diff="del" at="D">
               <head>Analyzing the Picture String</head>
               <p>This phase of the algorithm analyzes the <termref def="dt-picture-string">picture
                     string</termref> and the attribute settings of the
                     <elcode>xsl:decimal-format</elcode> declaration, and has the effect of setting
                  the values of various variables, which are used in the subsequent formatting
                  phase. These variables are listed below. Each is shown with its initial setting
                  and its data type. </p>
               <p>Several variables are associated with each sub-picture. If there are two
                  sub-pictures, then these rules are applied to one sub-picture to obtain the values
                  that apply to positive numbers, and to the other to obtain the values that apply
                  to negative numbers. If there is only one sub-picture, then the values for both
                  cases are derived from this sub-picture.</p>
               <p>The variables are as follows:</p>
               <ulist>
                  <item>
                     <p>The <var>integer-part-grouping-positions</var> is a sequence of integers
                        representing the positions of grouping separators within the integer part of
                        the sub-picture. For each <var>grouping-separator-sign</var> that appears
                        within the integer part of the sub-picture, this sequence contains an
                        integer that is equal to the total number of <var>digit-sign</var> and
                           <var>zero-digit-sign</var> characters that appear within the integer part
                        of the sub-picture and to the right of the
                           <var>grouping-separator-sign</var>. In addition, if these
                           <var>integer-part-grouping-positions</var> are at regular intervals (that
                        is, if they form a sequence <var>N</var>, <var>2N</var>, <var>3N</var>, ...
                        for some integer value <var>N</var>, including the case where there is only
                        one number in the list), then the sequence contains all integer multiples of
                           <var>N</var> as far as necessary to accommodate the largest possible
                        number.</p>
                  </item>
                  <item>
                     <p>The <var>minimum-integer-part-size</var> is an integer indicating the
                        minimum number of digits that will appear to the left of the
                           <var>decimal-separator-sign</var>. It is normally set to the number of
                           <var>zero-digit-sign</var> characters found in the integer part of the
                        sub-picture. But if the sub-picture contains no <var>zero-digit-sign</var>
                        and no <var>decimal-separator-sign</var>, it is set to one.</p>
                     <note>
                        <p>There is no maximum integer part size. All significant digits in the
                           integer part of the number will be displayed, even if this exceeds the
                           number of <var>digit-sign</var> and <var>zero-digit-sign</var> characters
                           in the subpicture.</p>
                     </note>
                  </item>
                  <item>
                     <p>The <var>prefix</var> is set to contain all passive characters in the
                        sub-picture to the left of the leftmost active character. If the picture
                        string contains only one sub-picture, the <var>prefix</var> for the negative
                        sub-picture is set by concatenating the <var>minus-sign</var> character and
                        the <var>prefix</var> for the positive sub-picture (if any), in that
                        order.</p>
                  </item>
                  <item>
                     <p>The <var>fractional-part-grouping-positions</var> is a sequence of integers
                        representing the positions of grouping separators within the fractional part
                        of the sub-picture. For each <var>grouping-separator-sign</var> that appears
                        within the fractional part of the sub-picture, this sequence contains an
                        integer that is equal to the total number of <var>digit-sign</var> and
                           <var>zero-digit-sign</var> characters that appear within the fractional
                        part of the sub-picture and to the left of the
                           <var>grouping-separator-sign</var>.</p>
                  </item>
                  <item>
                     <p>The <var>minimum-fractional-part-size</var> is set to the number of
                           <var>zero-digit-sign</var> characters found in the fractional part of the
                        sub-picture.</p>
                  </item>
                  <item>
                     <p>The <var>maximum-fractional-part-size</var> is set to the total number of
                           <var>digit-sign</var> and <var>zero-digit-sign</var> characters found in
                        the fractional part of the sub-picture.</p>
                  </item>
                  <item>
                     <p>The <var>suffix</var> is set to contain all passive characters to the right
                        of the rightmost active character in the fractional part of the
                        sub-picture.</p>
                  </item>
               </ulist>
               <note>
                  <p>If there is only one sub-picture, then all variables for positive numbers and
                     negative numbers will be the same, except for <var>prefix</var>: the prefix for
                     negative numbers will be preceded by the <var>minus-sign</var> character.</p>
               </note>
            </div3>
            <div3 id="formatting-the-number" diff="del" at="D">
               <head>Formatting the Number</head>
               <p>This section describes the second phase of processing of the
                     <xfunction>format-number</xfunction> function. This phase takes as input a number
                  to be formatted (referred to as the <emph>input number</emph>), and the variables
                  set up by analyzing the <elcode>xsl:decimal-format</elcode> declaration and the
                     <termref def="dt-picture-string">picture string</termref>, as described above.
                  The result of this phase is a string, which forms the return value of the
                     <xfunction>format-number</xfunction> function.</p>
               <p>The algorithm for this second stage of processing is as follows:</p>
               <olist>
                  <item>
                     <p>If the input number is NaN (not a number), the result is the specified
                           <var>NaN-symbol</var> (with no <var>prefix</var> or
                        <var>suffix</var>).</p>
                  </item>
                  <item>
                     <p>In the rules below, the positive sub-picture and its associated variables
                        are used if the input number is positive, and the negative sub-picture and
                        its associated variables are used otherwise. Negative zero is taken as
                        negative, positive zero as positive.</p>
                  </item>
                  <item>
                     <p>If the input number is positive or negative infinity, the result is the
                        concatenation of the appropriate <var>prefix</var>, the
                           <var>infinity-symbol</var>, and the appropriate <var>suffix</var>.</p>
                  </item>
                  <item>
                     <p>If the sub-picture contains a <var>percent-sign</var>, the number is
                        multiplied by 100. If the sub-picture contains a <var>per-mille-sign</var>,
                        the number is multiplied by 1000. The resulting number is referred to below
                        as the <var>adjusted number</var>.</p>
                  </item>
                  <item>
                     <p>The <var>adjusted number</var> is converted (if necessary) to an
                           <code>xs:decimal</code> value, using an implementation of
                           <code>xs:decimal</code> that imposes no limits on the
                           <code>totalDigits</code> or <code>fractionDigits</code> facets. If there
                        are several such values that are numerically equal to the <var>adjusted
                           number</var> (bearing in mind that if the <var>adjusted number</var> is
                        an <code>xs:double</code> or <code>xs:float</code>, the comparison will be
                        done by converting the decimal value back to an <code>xs:double</code> or
                           <code>xs:float</code>), the one that is chosen <rfc2119>should</rfc2119>
                        be one with the smallest possible number of digits not counting leading or
                        trailing zeroes (whether significant or insignificant). For example, 1.0 is
                        preferred to 0.9999999999, and 100000000 is preferred to 100000001. This
                        value is then rounded so that it uses no more than
                           <code>maximum-fractional-part-size</code> digits in its fractional part.
                        The <var>rounded number</var> is defined to be the result of converting the
                           <var>adjusted number</var> to an <code>xs:decimal</code> value, as
                        described above, and then calling the function
                           <xfunction>round-half-to-even</xfunction> with this converted number as
                        the first argument and the <code>maximum-fractional-part-size</code> as the
                        second argument, again with no limits on the <code>totalDigits</code> or
                           <code>fractionDigits</code> in the result.</p>
                  </item>
                  <item>
                     <p>The absolute value of the <var>rounded number</var> is converted to a string
                        in decimal notation, with no insignificant leading or trailing zeroes, using
                        the characters implied by the choice of <var>zero-digit-sign</var> to
                        represent the ten decimal digits, and the <var>decimal-separator-sign</var>
                        to separate the integer part and the fractional part. (The value zero will
                        at this stage be represented by a <var>decimal-separator-sign</var> on its
                        own.)</p>
                  </item>
                  <item>
                     <p>If the number of digits to the left of the <var>decimal-separator-sign</var>
                        is less than <var>minimum-integer-part-size</var>, leading
                           <var>zero-digit-sign</var> characters are added to pad out to that
                        size.</p>
                  </item>
                  <item>
                     <p>If the number of digits to the right of the
                           <var>decimal-separator-sign</var> is less than
                           <var>minimum-fractional-part-size</var>, trailing
                           <var>zero-digit-sign</var> characters are added to pad out to that
                        size.</p>
                  </item>
                  <item>
                     <p>For each integer <var>N</var> in the
                           <var>integer-part-grouping-positions</var> list, a
                           <var>grouping-separator-sign</var> character is inserted into the string
                        immediately after that digit that appears in the integer part of the number
                        and has <var>N</var> digits between it and the
                           <var>decimal-separator-sign</var>, if there is such a digit.</p>
                  </item>
                  <item>
                     <p>For each integer <var>N</var> in the
                           <var>fractional-part-grouping-positions</var> list, a
                           <var>grouping-separator-sign</var> character is inserted into the string
                        immediately before that digit that appears in the fractional part of the
                        number and has <var>N</var> digits between it and the
                           <var>decimal-separator-sign</var>, if there is such a digit.</p>
                  </item>
                  <item>
                     <p>If there is no <var>decimal-separator-sign</var> in the sub-picture, or if
                        there are no digits to the right of the <var>decimal-separator-sign</var>
                        character in the string, then the <var>decimal-separator-sign</var>
                        character is removed from the string (it will be the rightmost character in
                        the string).</p>
                  </item>
                  <item>
                     <p>The result of the function is the concatenation of the appropriate
                           <var>prefix</var>, the string conversion of the number as obtained above,
                        and the appropriate <var>suffix</var>.</p>
                  </item>
               </olist>
            </div3>
         </div2>

         <div2 id="misc-func">
            <head>Miscellaneous Additional Functions</head>
            <div3 id="current-function">
               <head>current</head>
               <proto class="xslt" name="current" return-type="item()"/>
               <p>The <function>current</function> function, used within an XPath <termref def="dt-expression">expression</termref>, returns the item that was the
                     <termref def="dt-context-item">context item</termref> at the point where the
                  expression was invoked from the XSLT <termref def="dt-stylesheet">stylesheet</termref>. This is referred to as the current item. For an
                  outermost expression (an expression not occurring within another expression), the
                  current item is always the same as the context item. Thus,</p>
               <eg xml:space="preserve">&lt;xsl:value-of select="current()"/&gt;</eg>
               <p>means the same as</p>
               <eg xml:space="preserve">&lt;xsl:value-of select="."/&gt;</eg>
               <p>However, within square brackets, or on the right-hand side of the <code>/</code>
                  operator, the current item is generally different from the context item.</p>
               <example>
                  <head>Using the <code>current</code> Function</head>
                  <p>For example,</p>
                  <eg xml:space="preserve">&lt;xsl:apply-templates select="//glossary/entry[@name=current()/@ref]"/&gt;</eg>
                  <p>will process all <code>entry</code> elements that have a <code>glossary</code>
                     parent element and that have a <code>name</code> attribute with value equal to
                     the value of the current item's <code>ref</code> attribute. This is different
                     from</p>
                  <eg xml:space="preserve">&lt;xsl:apply-templates select="//glossary/entry[@name=./@ref]"/&gt;</eg>
                  <p>which means the same as</p>
                  <eg xml:space="preserve">&lt;xsl:apply-templates select="//glossary/entry[@name=@ref]"/&gt;</eg>
                  <p>and so would process all <code>entry</code> elements that have a
                        <code>glossary</code> parent element and that have a <code>name</code>
                     attribute and a <code>ref</code> attribute with the same value.</p>
               </example>
               <p>If the <function>current</function> function is used within a <termref def="dt-pattern">pattern</termref>, its value is the <phrase diff="chg" at="C">item</phrase> that is being matched against the pattern.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1360">
                     <p>If the <function>current</function> function is evaluated within an
                        expression that is evaluated when the context item is undefined, a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>
                        occurs.</p>
                  </error>
               </p>
            </div3>
            <div3 id="unparsed-entity-uri">
               <head>unparsed-entity-uri</head>
               <proto class="xslt" name="unparsed-entity-uri" return-type="xs:anyURI">
                  <arg name="entity-name" type="xs:string"/>
               </proto>
               <p>The <function>unparsed-entity-uri</function> function returns the URI of the
                  unparsed entity whose name is given by the value of the <code>$entity-name</code>
                  argument, in the document containing the <termref def="dt-context-node">context
                     node</termref>. It returns the zero-length <code>xs:anyURI</code> if there is
                  no such entity. This function maps to the
                     <code>dm:unparsed-entity-system-id</code> accessor defined in <bibref ref="xpath-datamodel-11"/>.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1370">
                     <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                           error</termref> if the <function>unparsed-entity-uri</function> function
                        is called when there is no <termref def="dt-context-node">context
                           node</termref>, or when the root of the tree containing the context node
                        is not a document node.</p>
                  </error>
               </p>
            </div3>
            <div3 id="unparsed-entity-public-id">
               <head>unparsed-entity-public-id</head>
               <proto class="xslt" name="unparsed-entity-public-id" return-type="xs:string">
                  <arg name="entity-name" type="xs:string"/>
               </proto>
               <p>The <function>unparsed-entity-public-id</function> function returns the public
                  identifier of the unparsed entity whose name is given by the value of the
                     <code>$entity-name</code> argument, in the document containing the <termref def="dt-context-node">context node</termref>. It returns the zero-length string
                  if there is no such entity, or if the entity has no public identifier. This
                  function maps to the <code>dm:unparsed-entity-public-id</code> accessor defined in
                     <bibref ref="xpath-datamodel-11"/>.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1380">
                     <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                           error</termref> if the <function>unparsed-entity-public-id</function>
                        function is called when there is no <termref def="dt-context-node">context
                           node</termref>, or when the root of the tree containing the context node
                        is not a document node.</p>
                  </error>
               </p>
            </div3>

            <div3 id="system-property">
               <head>system-property</head>
               <proto class="xslt" name="system-property" return-type="xs:string">
                  <arg name="property-name" type="xs:string"/>
               </proto>
               <p>The <code>$property-name</code> argument <rfc2119>must</rfc2119> evaluate to a
                     <termref def="dt-lexical-qname">lexical QName</termref>. The <termref def="dt-lexical-qname">lexical QName</termref> is expanded as described in
                     <specref ref="qname"/>.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1390">
                     <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                           error</termref> if the value <error.extra>supplied as the
                              <code>$property-name</code> argument to the
                              <function>system-property</function> function</error.extra> is not a
                        valid QName, or if there is no namespace declaration in scope for the prefix
                        of the QName. If the processor is able to detect the error statically (for
                        example, when the argument is supplied as a string literal), then the
                        processor <rfc2119>may</rfc2119> optionally signal this as a <termref def="dt-static-error">static error</termref>. </p>
                  </error>
               </p>
               <p>The <function>system-property</function> function returns a string representing
                  the value of the system property identified by the name. If there is no such
                  system property, the zero-length string is returned.</p>
               <p>Implementations <rfc2119>must</rfc2119> provide the following system properties,
                  which are all in the <termref def="dt-xslt-namespace">XSLT
                  namespace</termref>:</p>
               <ulist>
                  <item>
                     <p>
                        <code>xsl:version</code>, a number giving the version of XSLT implemented by
                        the <termref def="dt-processor">processor</termref>; for implementations
                        conforming to the version of XSLT specified by this document, this is the
                        string <phrase diff="chg" at="A"><code>"2.1"</code></phrase>. The value will
                        always be a string in the lexical space of the decimal data type defined in
                        XML Schema (see <bibref ref="xmlschema-2"/>). This allows the value to be
                        converted to a number for the purpose of magnitude comparisons.</p>
                  </item>
                  <item>
                     <p>
                        <code>xsl:vendor</code>, a string identifying the implementer of the
                           <termref def="dt-processor">processor</termref>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>xsl:vendor-url</code>, a string containing a URL identifying the
                        implementer of the <termref def="dt-processor">processor</termref>;
                        typically this is the host page (home page) of the implementer's Web
                        site.</p>
                  </item>
                  <item>
                     <p>
                        <code>xsl:product-name</code>, a string containing the name of the
                        implementation, as defined by the implementer. This
                           <rfc2119>should</rfc2119> normally remain constant from one release of
                        the product to the next. It <rfc2119>should</rfc2119> also be constant
                        across platforms in cases where the same source code is used to produce
                        compatible products for multiple execution platforms.</p>
                  </item>
                  <item>
                     <p>
                        <code>xsl:product-version</code>, a string identifying the version of the
                        implementation, as defined by the implementer. This
                           <rfc2119>should</rfc2119> normally vary from one release of the product
                        to the next, and at the discretion of the implementer it
                           <rfc2119>may</rfc2119> also vary across different execution
                        platforms.</p>
                  </item>
                  <item>
                     <p>
                        <code>xsl:is-schema-aware</code>, returns the string <code>"yes"</code> in
                        the case of a processor that claims conformance as a <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT
                           processor</termref>, or <code>"no"</code> in the case of a <termref def="dt-basic-xslt-processor">basic XSLT processor</termref>.</p>
                  </item>
                  <item>
                     <p>
                        <code>xsl:supports-serialization</code>, returns the string
                           <code>"yes"</code> in the case of a processor that offers the <termref def="dt-serialization-feature">serialization feature</termref>, or
                           <code>"no"</code> otherwise.</p>
                  </item>
                  <item>
                     <p>
                        <code>xsl:supports-backwards-compatibility</code>, returns the string
                           <code>"yes"</code> in the case of a processor that offers the <phrase diff="chg" at="E"><termref def="dt-1.0-compatibility-feature"/></phrase>,
                        or <code>"no"</code> otherwise.</p>
                  </item>
                  <item>
                     <p diff="add" at="E">
                        <code>xsl:supports-1.0-compatibility</code>, returns the string
                           <code>"yes"</code> in the case of a processor that offers the <termref def="dt-1.0-compatibility-feature"/>, or <code>"no"</code> otherwise.</p>
                  </item>
                  <item>
                     <p diff="add" at="E">
                        <code>xsl:supports-2.0-compatibility</code>, returns the string
                           <code>"yes"</code> in the case of a processor that offers the <termref def="dt-2.0-compatibility-feature"/>, or <code>"no"</code> otherwise.</p>
                  </item>
                  <item>
                     <p diff="add" at="A">
                        <code>xsl:supports-namespace-axis</code>, returns the string
                           <code>"yes"</code> in the case of a processor that offers the XPath
                        namespace axis even when not in backwards compatible mode, or
                           <code>"no"</code> otherwise. Note that a processor that supports
                        backwards compatible mode must support the namespace axis when in that mode,
                        so this property is not relevant to that case.</p>
                  </item>
                  <item>
                     <p diff="add" at="A">
                        <code>xsl:supports-streaming</code>, returns the string <code>"yes"</code>
                        in the case of a processor that offers the streaming feature (see <specref ref="streaming-feature"/>), or <code>"no"</code> otherwise.</p>

                  </item>
               </ulist>
               <p>Some of these properties relate to the conformance levels and features offered by
                  the <termref def="dt-processor">processor</termref>: these options are described
                  in <specref ref="conformance"/>.</p>
               <p>The actual values returned for the above properties are <termref def="dt-implementation-defined">implementation-defined</termref>.</p>
               <p>The set of system properties that are supported, in addition to those listed
                  above, is also <termref def="dt-implementation-defined">implementation-defined</termref>. Implementations <rfc2119>must not</rfc2119>
                  define additional system properties in the XSLT namespace.</p>
               <imp-def-feature>The values returned by the <function>system-property</function>
                  function, and the names of the additional properties that are recognized, are
                  implementation-defined.</imp-def-feature>
               <note>
                  <p>An implementation must not return the value <code>
                        <phrase diff="chg" at="A">2.1</phrase>
                     </code> as the value of the <code>xsl:version</code> system property unless it
                     is conformant to XSLT <phrase diff="chg" at="A">2.1</phrase>.</p>
                  <p>It is recognized that vendors who are enhancing XSLT 1.0 <phrase diff="chg" at="A">or 2.0</phrase> processors may wish to release interim implementations
                     before all the mandatory features of this specification are implemented. Since
                     such products are not conformant to XSLT 2.1, this specification cannot define
                     their behavior. However, implementers of such products are encouraged to return
                     a value for the <code>xsl:version</code> system property that is intermediate
                     between 1.0 and 2.1, and to provide the <function>element-available</function>
                     and <function>function-available</function> functions to allow users to test
                     which features have been fully implemented.</p>
               </note>
            </div3>
            <!--<div3 id="is-last" diff="add" at="C">
               <head>is-last</head>
               <proto class="xslt" name="is-last" return-type="xs:boolean"/>
               <p>The <function>is-last</function> returns true if the value of the 
                  <termref def="dt-context-position">context position</termref> in the dynamic context is the same
                  as the value of the <termref def="dt-context-size">context size</termref>.
               That is, the result is equivalent to the expression <code>position() eq last()</code>.</p>
               
               <p>If the context item is undefined, an error is raised (<xerrorref spec="XP21" class="DY" code="0002"/>)</p>
               
               <note><p>The reason for using this function in preference to the expression <code>position() eq last()</code>,
               apart from brevity, is that it can be used within streamable templates. Calling <xfunction>last</xfunction>
               is not possible within a streamable template, because its value cannot be determined until all the items
               in the current input sequence have been read; by contrast calls to <function>is-last</function> are
               permitted, because the function can be evaluated by means of a single-item lookahead.</p></note>
               
               <ednote><edtext>This function imposes a requirement for lookahead, and unless we restrict its use,
               it could require a very large amount of lookahead in the worst case. For example, evaluating the
               pattern <code>chapter[last()]</code> could require buffering all the appendices that appear after the
                  last chapter. The WG intends to reconsider whether
               the function is desirable.</edtext></ednote>
               
            </div3>-->
         </div2>
         <div2 id="format-date" diff="del" at="D">
            <head>Formatting Dates and Times</head>
            <note>
               <p>These functions have been moved into XPath 2.1</p>
            </note>
            <p>Three functions are provided to represent dates and times as a string, using the
               conventions of a selected calendar, language, and country. Each has two variants.</p>
            <proto class="xslt" name="format-dateTime" return-type="xs:string" returnEmptyOk="yes">
               <arg name="value" type="xs:dateTime" emptyOk="yes"/>
               <arg name="picture" type="xs:string"/>
               <arg name="language" type="xs:string" emptyOk="yes"/>
               <arg name="calendar" type="xs:string" emptyOk="yes"/>
               <arg name="country" type="xs:string" emptyOk="yes"/>
            </proto>
            <proto class="xslt" name="format-dateTime" return-type="xs:string" returnEmptyOk="yes">
               <arg name="value" type="xs:dateTime" emptyOk="yes"/>
               <arg name="picture" type="xs:string"/>
            </proto>
            <proto class="xslt" name="format-date" return-type="xs:string" returnEmptyOk="yes">
               <arg name="value" type="xs:date" emptyOk="yes"/>
               <arg name="picture" type="xs:string"/>
               <arg name="language" type="xs:string" emptyOk="yes"/>
               <arg name="calendar" type="xs:string" emptyOk="yes"/>
               <arg name="country" type="xs:string" emptyOk="yes"/>
            </proto>
            <proto class="xslt" name="format-date" return-type="xs:string" returnEmptyOk="yes">
               <arg name="value" type="xs:date" emptyOk="yes"/>
               <arg name="picture" type="xs:string"/>
            </proto>
            <proto class="xslt" name="format-time" return-type="xs:string" returnEmptyOk="yes">
               <arg name="value" type="xs:time" emptyOk="yes"/>
               <arg name="picture" type="xs:string"/>
               <arg name="language" type="xs:string" emptyOk="yes"/>
               <arg name="calendar" type="xs:string" emptyOk="yes"/>
               <arg name="country" type="xs:string" emptyOk="yes"/>
            </proto>
            <proto class="xslt" name="format-time" return-type="xs:string" returnEmptyOk="yes">
               <arg name="value" type="xs:time" emptyOk="yes"/>
               <arg name="picture" type="xs:string"/>
            </proto>
            <p>The <function>format-dateTime</function>, <function>format-date</function>, and
                  <function>format-time</function> functions format <code>$value</code> as a string
               using the picture string specified by the <code>$picture</code> argument, the
               calendar specified by the <code>$calendar</code> argument, the language specified by
               the <code>$language</code> argument, and the country specified by the
                  <code>$country</code> argument. The result of the function is the formatted string
               representation of the supplied <code>dateTime</code>, <code>date</code>, or
                  <code>time</code> value.</p>
            <p>
               <termdef id="dt-date-formatting-function" term="date formatting function">The three
                  functions <function>format-date</function>, <function>format-time</function>, and
                     <function>format-dateTime</function> are referred to collectively as the
                     <term>date formatting functions</term>.</termdef>
            </p>
            <p>If <code>$value</code> is the empty sequence, the empty sequence is returned.</p>
            <p>Calling the two-argument form of each of the three functions is equivalent to calling
               the five-argument form with each of the last three arguments set to an empty
               sequence.</p>
            <p>For details of the <code>language</code>, <code>calendar</code>, and
                  <code>country</code> arguments, see <specref ref="lang-cal-country"/>.</p>
            <p>In general, the use of an invalid <code>picture</code>, <code>language</code>,
                  <code>calendar</code>, or <code>country</code> argument is classified as a
                  <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref>. By
               contrast, use of an option in any of these arguments that is valid but not supported
               by the implementation is not an error, and in these cases the implementation is
               required to output the value in a fallback representation.</p>
            <div3 id="date-picture-string">
               <head>The Picture String</head>
               <p>The picture consists of a sequence of variable markers and literal substrings. A
                  substring enclosed in square brackets is interpreted as a variable marker;
                  substrings not enclosed in square brackets are taken as literal substrings. The
                  literal substrings are optional and if present are rendered unchanged, including
                  any whitespace. If an opening or closing square bracket is required within a
                  literal substring, it <rfc2119>must</rfc2119> be doubled. The variable markers are
                  replaced in the result by strings representing aspects of the date and/or time to
                  be formatted. These are described in detail below.</p>
               <p>A variable marker consists of a component specifier followed optionally by one or
                  two presentation modifiers and/or optionally by a width modifier. Whitespace
                  within a variable marker is ignored.</p>
               <p>The <emph>component specifier</emph> indicates the component of the date or time
                  that is required, and takes the following values:</p>
               <table border="1" cellpadding="5">
                  <thead>
                     <tr>
                        <th align="left" rowspan="1" colspan="1">Specifier</th>
                        <th align="left" rowspan="1" colspan="1">Meaning</th>
                        <th align="left" rowspan="1" colspan="1">Default Presentation Modifier</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">Y</td>
                        <td rowspan="1" colspan="1">year (absolute value)</td>
                        <td valign="top" rowspan="1" colspan="1">1</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">M</td>
                        <td rowspan="1" colspan="1">month in year</td>
                        <td valign="top" rowspan="1" colspan="1">1</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">D</td>
                        <td rowspan="1" colspan="1">day in month</td>
                        <td valign="top" rowspan="1" colspan="1">1</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">d</td>
                        <td rowspan="1" colspan="1">day in year</td>
                        <td valign="top" rowspan="1" colspan="1">1</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">F</td>
                        <td rowspan="1" colspan="1">day of week</td>
                        <td valign="top" rowspan="1" colspan="1">n</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">W</td>
                        <td rowspan="1" colspan="1">week in year</td>
                        <td valign="top" rowspan="1" colspan="1">1</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">w</td>
                        <td rowspan="1" colspan="1">week in month</td>
                        <td valign="top" rowspan="1" colspan="1">1</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">H</td>
                        <td rowspan="1" colspan="1">hour in day (24 hours)</td>
                        <td valign="top" rowspan="1" colspan="1">1</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">h</td>
                        <td rowspan="1" colspan="1">hour in half-day (12 hours)</td>
                        <td valign="top" rowspan="1" colspan="1">1</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">P</td>
                        <td rowspan="1" colspan="1">am/pm marker</td>
                        <td valign="top" rowspan="1" colspan="1">n</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">m</td>
                        <td rowspan="1" colspan="1">minute in hour</td>
                        <td valign="top" rowspan="1" colspan="1">01</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">s</td>
                        <td rowspan="1" colspan="1">second in minute</td>
                        <td valign="top" rowspan="1" colspan="1">01</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">f</td>
                        <td rowspan="1" colspan="1">fractional seconds</td>
                        <td valign="top" rowspan="1" colspan="1">1</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">Z</td>
                        <td rowspan="1" colspan="1">timezone as a time offset from UTC, or if an
                           alphabetic modifier is present the conventional name of a timezone (such
                           as PST)</td>
                        <td valign="top" rowspan="1" colspan="1">1</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">z</td>
                        <!--Text replaced by erratum E24 change 1"-->
                        <td rowspan="1" colspan="1">timezone as a time offset using GMT, for example
                           GMT+1 or GMT-05:00. For this component there is a fixed prefix of
                              <code>GMT</code>, or a localized variation thereof for the chosen
                           language, and the presentation modifier controls the representation of
                           the signed time offset that follows. </td>
                        <!--End of text replaced by erratum E24-->
                        <td valign="top" rowspan="1" colspan="1">1</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">C</td>
                        <td rowspan="1" colspan="1">calendar: the name or abbreviation of a calendar
                           name</td>
                        <td valign="top" rowspan="1" colspan="1">n</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">E</td>
                        <td rowspan="1" colspan="1">era: the name of a baseline for the numbering of
                           years, for example the reign of a monarch</td>
                        <td valign="top" rowspan="1" colspan="1">n</td>
                     </tr>
                  </tbody>
               </table>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1340">
                     <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                           error</termref> if the syntax of the picture <error.extra>used for
                           date/time formatting</error.extra> is incorrect.</p>
                  </error>
               </p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1350">
                     <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                           error</termref> if a component specifier within the picture
                           <error.extra>used for date/time formatting</error.extra> refers to
                        components that are not available in the given type of <code>$value</code>,
                        for example if the picture supplied to the <function>format-time</function>
                        refers to the year, month, or day component.</p>
                  </error>
               </p>
               <p>It is not an error to include a timezone component when the supplied value has no
                  timezone. In these circumstances the timezone component will be ignored.</p>
               <p>The first <emph>presentation modifier</emph> indicates the style in which the
                  value of a component is to be represented. Its value may be either:</p>
               <ulist>
                  <item>
                     <p>any format token permitted in the <code>format</code> string of the
                           <elcode>xsl:number</elcode> instruction (see <specref ref="number"/>),
                        indicating that the value of the component is to be output numerically using
                        the specified number format (for example, <code>1</code>, <code>01</code>,
                           <code>i</code>, <code>I</code>, <code>w</code>, <code>W</code>, or
                           <code>Ww</code>) or </p>
                  </item>
                  <item>
                     <p>the format token <code>n</code>, <code>N</code>, or <code>Nn</code>,
                        indicating that the value of the component is to be output by name, in
                        lower-case, upper-case, or title-case respectively. Components that can be
                        output by name include (but are not limited to) months, days of the week,
                        timezones, and eras. If the processor cannot output these components by name
                        for the chosen calendar and language then it must use an
                        implementation-defined fallback representation.</p>
                  </item>
               </ulist>
               <p>If the implementation does not support the use of the requested format token, it
                     <rfc2119>must</rfc2119> use the default presentation modifier for that
                  component.</p>
               <p>If the first presentation modifier is present, then it may optionally be followed
                  by a second presentation modifier as follows:</p>
               <table border="1" cellpadding="5">
                  <thead>
                     <tr>
                        <th align="left" rowspan="1" colspan="1">Modifier</th>
                        <th align="left" rowspan="1" colspan="1">Meaning</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">t</td>
                        <td valign="top" rowspan="1" colspan="1">traditional numbering. This has the
                           same meaning as <code>letter-value="traditional"</code> in
                              <elcode>xsl:number</elcode>.</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">o</td>
                        <td valign="top" rowspan="1" colspan="1">ordinal form of a number, for
                           example <code>8th</code> or <code>8</code>. The actual representation of
                           the ordinal form of a number may depend not only on the language, but
                           also on the grammatical context (for example, in some languages it must
                           agree in gender).</td>
                     </tr>
                  </tbody>
               </table>
               <note>
                  <p>Although the formatting rules are expressed in terms of the rules for format
                     tokens in <elcode>xsl:number</elcode>, the formats actually used may be
                     specialized to the numbering of date components where appropriate. For example,
                     in Italian, it is conventional to use an ordinal number (<code>primo</code>)
                     for the first day of the month, and cardinal numbers (<code>due, tre, quattro
                        ...</code>) for the remaining days. A processor may therefore use this
                     convention to number days of the month, ignoring the presence or absence of the
                     ordinal presentation modifier.</p>
               </note>
               <p>Whether or not a presentation modifier is included, a width modifier may be
                  supplied. This indicates the number of characters or digits to be included in the
                  representation of the value.</p>
               <p>The width modifier, if present, is introduced by a comma. It takes the form:</p>
               <p>
                  <code>,min-width ("-" max-width)?</code>
               </p>
               <p>where <code>min-width</code> is either an unsigned integer indicating the minimum
                  number of characters to be output, or <code>*</code> indicating that there is no
                  explicit minimum, and <code>max-width</code> is either an unsigned integer
                  indicating the maximum number of characters to be output, or <code>*</code>
                  indicating that there is no explicit maximum; if <code>max-width</code> is omitted
                  then <code>*</code> is assumed. Both integers, if present, <rfc2119>must</rfc2119>
                  be greater than zero.</p>
               <p>A format token containing leading zeroes, such as <code>001</code>, sets the
                  minimum and maximum width to the number of digits appearing in the format token;
                  if a width modifier is also present, then the width modifier takes precedence.</p>
               <note>
                  <p>A format token consisting of a one-digit on its own, such as <code>1</code>,
                     does not constrain the number of digits in the output. In the case of
                     fractional seconds in particular, <code>[f001]</code> requests three decimal
                     digits, <code>[f01]</code> requests two digits, but <code>[f1]</code> will
                     produce an implementation-defined number of digits. If exactly one digit is
                     required, this can be achieved using the component specifier
                        <code>[f1,1-1]</code>.</p>
               </note>
               <!--Text replaced by erratum E24 change 2"-->
               <p>If the minimum and maximum width are unspecified, then the output uses as many
                  characters as are required to represent the value of the component without
                  truncation and without padding: this is referred to below as the <emph>full
                     representation</emph> of the value. For a timezone offset (component specifier
                     <code>z</code>), the full representation consists of a sign for the offset, the
                  number of hours of the offset, and if the offset is not an integral number of
                  hours, a colon (<code>:</code>) followed by the two digits of the minutes of the
                  offset.. </p>
               <!--End of text replaced by erratum E24-->
               <p>If the full representation of the value exceeds the specified maximum width, then
                  the processor <rfc2119>should</rfc2119> attempt to use an alternative shorter
                  representation that fits within the maximum width. Where the presentation modifier
                  is <code>N</code>, <code>n</code>, or <code>Nn</code>, this is done by
                  abbreviating the name, using either conventional abbreviations if available, or
                  crude right-truncation if not. For example, setting <code>max-width</code> to
                     <code>4</code> indicates that four-letter abbreviations
                     <rfc2119>should</rfc2119> be used, though it would be acceptable to use a
                  three-letter abbreviation if this is in conventional use. (For example, "Tuesday"
                  might be abbreviated to "Tues", and "Friday" to "Fri".) In the case of the year
                  component, setting <code>max-width</code> requests omission of high-order digits
                  from the year, for example, if <code>max-width</code> is set to <code>2</code>
                  then the year 2003 will be output as <code>03</code>. In the case of the
                  fractional seconds component, the value is rounded to the specified size as if by
                  applying the function <code>round-half-to-even(fractional-seconds,
                     max-width)</code>. If no mechanism is available for fitting the value within
                  the specified maximum width (for example, when roman numerals are used), then the
                  value <rfc2119>should</rfc2119> be output in its full representation.</p>
               <!--Text replaced by erratum E24 change 3"-->
               <p>If the full representation of the value is shorter than the specified minimum
                  width, then the processor <rfc2119>should</rfc2119> pad the value to the specified
                  width.</p>
               <ulist>
                  <item>
                     <p>For decimal representations of numbers, this <rfc2119>should</rfc2119> be
                        done by prepending zero digits from the appropriate set of digit characters,
                        or appending zero digits in the case of the fractional seconds
                        component.</p>
                  </item>
                  <item>
                     <p>For timezone offsets this should be done by first appending a colon
                           (<code>:</code>) followed by two zero digits from the appropriate set of
                        digit characters if the full representation does not already include a
                        minutes component and if the specified minimum width permits adding three
                        characters, and then if necessary prepending zero digits from the
                        appropriate set of digit characters to the hour component.</p>
                  </item>
                  <item>
                     <p>In other cases, it <rfc2119>should</rfc2119> be done by appending
                        spaces.</p>
                  </item>
               </ulist>
               <!--End of text replaced by erratum E24-->
            </div3>
            <div3 id="lang-cal-country">
               <head>The Language, Calendar, and Country Arguments</head>
               <p>The set of languages, calendars, and countries that are supported in the <termref def="dt-date-formatting-function">date formatting functions</termref> is
                     <termref def="dt-implementation-defined">implementation-defined</termref>. When
                  any of these arguments is omitted or is an empty sequence, an <termref def="dt-implementation-defined">implementation-defined</termref> default value
                  is used.</p>
               <imp-def-feature>The set of languages, calendars, and countries that are supported in
                  the <termref def="dt-date-formatting-function">date formatting functions</termref>
                  is implementation-defined. If any of these arguments is omitted or set to an empty
                  sequence, the default is implementation-defined.</imp-def-feature>
               <!--Text replaced by erratum E4 change 1"-->
               <p>If the fallback representation uses a different calendar from that requested, the
                  output string <rfc2119>must</rfc2119> identify the calendar actually used, for
                  example by prefixing the string with <code>[Calendar: X]</code> (where X is the
                  calendar actually used), localized as appropriate to the requested language. If
                  the fallback representation uses a different language from that requested, the
                  output string <rfc2119>must</rfc2119> identify the language actually used, for
                  example by prefixing the string with <code>[Language: Y]</code> (where Y is the
                  language actually used) localized in an implementation-dependent way. If a
                  particular component of the value cannot be output in the requested format, it
                     <rfc2119>should</rfc2119> be output in the default format for that
                  component.</p>
               <!--End of text replaced by erratum E4-->
               <p>The <code>language</code> argument specifies the language to be used for the
                  result string of the function. The value of the argument <rfc2119>must</rfc2119>
                  be either the empty sequence or a value that would be valid for the
                     <code>xml:lang</code> attribute (see [XML]). Note that this permits the
                  identification of sublanguages based on country codes (from <bibref ref="ISO3166"/>) as well as identification of dialects and of regions within a country.</p>
               <p>If the <code>language</code> argument is omitted or is set to an empty sequence,
                  or if it is set to an invalid value or a value that the implementation does not
                  recognize, then the processor uses an <termref def="dt-implementation-defined">implementation-defined</termref> language.</p>
               <p>The language is used to select the appropriate language-dependent forms of:</p>
               <slist>
                  <sitem>names (for example, of months)</sitem>
                  <sitem>numbers expressed as words or as ordinals (<code>twenty, 20th,
                        twentieth</code>)</sitem>
                  <sitem>hour convention (0-23 vs 1-24, 0-11 vs 1-12)</sitem>
                  <sitem>first day of week, first week of year</sitem>
               </slist>
               <p>Where appropriate this choice may also take into account the value of the
                     <code>country</code> argument, though this <rfc2119>should</rfc2119> not be
                  used to override the language or any sublanguage that is specified as part of the
                     <code>language</code> argument.</p>
               <p>The choice of the names and abbreviations used in any given language is <termref def="dt-implementation-defined">implementation-defined</termref>. For example,
                  one implementation might abbreviate July as <code>Jul</code> while another uses
                     <code>Jly</code>. In German, one implementation might represent Saturday as
                     <code>Samstag</code> while another uses <code>Sonnabend</code>. Implementations
                     <rfc2119>may</rfc2119> provide mechanisms allowing users to control such
                  choices.</p>
               <imp-def-feature>The choice of the names and abbreviations used in any given language
                  for calendar units such as days of the week and months of the year is <termref def="dt-implementation-defined">implementation-defined</termref>.</imp-def-feature>
               <p>Where ordinal numbers are used, the selection of the correct representation of the
                  ordinal (for example, the linguistic gender) <rfc2119>may</rfc2119> depend on the
                  component being formatted and on its textual context in the picture string.</p>
               <p>The <code>calendar</code> attribute specifies that the <code>dateTime</code>,
                     <code>date</code>, or <code>time</code> supplied in the <code>$value</code>
                  argument <rfc2119>must</rfc2119> be converted to a value in the specified calendar
                  and then converted to a string using the conventions of that calendar.</p>
               <p>A calendar value <rfc2119>must</rfc2119> be a valid <termref def="dt-qname">QName</termref>. If the QName does not have a prefix, then it identifies a
                  calendar with the designator specified below. If the QName has a prefix, then the
                  QName is expanded into an expanded-QName as described in <specref ref="qname"/>;
                  the expanded-QName identifies the calendar; the behavior in this case is <termref def="dt-implementation-defined">implementation-defined</termref>.</p>
               <p>If the calendar attribute is omitted an <termref def="dt-implementation-defined">implementation-defined</termref> value is used.</p>
               <note>
                  <p>The calendars listed below were known to be in use during the last hundred
                     years. Many other calendars have been used in the past.</p>
                  <p>This specification does not define any of these calendars, nor the way that
                     they map to the value space of the <code>xs:date</code> data type in <bibref ref="xmlschema-2"/>. There may be ambiguities when dates are recorded using
                     different calendars. For example, the start of a new day is not simultaneous in
                     different calendars, and may also vary geographically (for example, based on
                     the time of sunrise or sunset). Translation of dates is therefore more reliable
                     when the time of day is also known, and when the geographic location is known.
                     When translating dates between one calendar and another, the processor may take
                     account of the values of the <code>country</code> and/or <code>language</code>
                     arguments, with the <code>country</code> argument taking precedence.</p>
                  <p>Information about some of these calendars, and algorithms for converting
                     between them, may be found in <bibref ref="CALCALC"/>.</p>
               </note>
               <table border="1" cellpadding="5">
                  <thead>
                     <tr>
                        <th valign="top" align="left" rowspan="1" colspan="1">Designator</th>
                        <th valign="top" align="left" rowspan="1" colspan="1">Calendar</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td rowspan="1" colspan="1">AD</td>
                        <td rowspan="1" colspan="1">Anno Domini (Christian Era)</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">AH</td>
                        <td rowspan="1" colspan="1">Anno Hegirae (Muhammedan Era)</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">AME</td>
                        <td rowspan="1" colspan="1">Mauludi Era (solar years since Mohammed's
                           birth)</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">AM</td>
                        <td rowspan="1" colspan="1">Anno Mundi (Jewish Calendar)</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">AP</td>
                        <td rowspan="1" colspan="1">Anno Persici</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">AS</td>
                        <td rowspan="1" colspan="1">Aji Saka Era (Java)</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">BE</td>
                        <td rowspan="1" colspan="1">Buddhist Era</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">CB</td>
                        <td rowspan="1" colspan="1">Cooch Behar Era</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">CE</td>
                        <td rowspan="1" colspan="1">Common Era</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">CL</td>
                        <td rowspan="1" colspan="1">Chinese Lunar Era</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">CS</td>
                        <td rowspan="1" colspan="1">Chula Sakarat Era</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">EE</td>
                        <td rowspan="1" colspan="1">Ethiopian Era</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">FE</td>
                        <td rowspan="1" colspan="1">Fasli Era</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">ISO</td>
                        <td rowspan="1" colspan="1">ISO 8601 calendar</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">JE</td>
                        <td rowspan="1" colspan="1">Japanese Calendar</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">KE</td>
                        <td rowspan="1" colspan="1">Khalsa Era (Sikh calendar)</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">KY</td>
                        <td rowspan="1" colspan="1">Kali Yuga</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">ME</td>
                        <td rowspan="1" colspan="1">Malabar Era</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">MS</td>
                        <td rowspan="1" colspan="1">Monarchic Solar Era</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">NS</td>
                        <td rowspan="1" colspan="1">Nepal Samwat Era</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">OS</td>
                        <td rowspan="1" colspan="1">Old Style (Julian Calendar)</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">RS</td>
                        <td rowspan="1" colspan="1">Rattanakosin (Bangkok) Era</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">SE</td>
                        <td rowspan="1" colspan="1">Saka Era</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">SH</td>
                        <td rowspan="1" colspan="1">Mohammedan Solar Era (Iran)</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">SS</td>
                        <td rowspan="1" colspan="1">Saka Samvat</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">TE</td>
                        <td rowspan="1" colspan="1">Tripurabda Era</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">VE</td>
                        <td rowspan="1" colspan="1">Vikrama Era</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">VS</td>
                        <td rowspan="1" colspan="1">Vikrama Samvat Era</td>
                     </tr>
                  </tbody>
               </table>
               <p>At least one of the above calendars <rfc2119>must</rfc2119> be supported. It is
                     <termref def="dt-implementation-defined">implementation-defined</termref> which
                  calendars are supported.</p>
               <p>The ISO 8601 calendar (<bibref ref="ISO8601"/>), which is included in the above
                  list and designated <code>ISO</code>, is very similar to the Gregorian calendar
                  designated <code>AD</code>, but it differs in several ways. The ISO calendar is
                  intended to ensure that date and time formats can be read easily by other
                  software, as well as being legible for human users. The ISO calendar prescribes
                  the use of particular numbering conventions as defined in ISO 8601, rather than
                  allowing these to be localized on a per-language basis. In particular it provides
                  a numeric 'week date' format which identifies dates by year, week of the year, and
                  day in the week; in the ISO calendar the days of the week are numbered from 1
                  (Monday) to 7 (Sunday), and week 1 in any calendar year is the week (from Monday
                  to Sunday) that includes the first Thursday of that year. The numeric values of
                  the components year, month, day, hour, minute, and second are the same in the ISO
                  calendar as the values used in the lexical representation of the date and time as
                  defined in <bibref ref="xmlschema-2"/>. The era ("E" component) with this calendar
                  is either a minus sign (for negative years) or a zero-length string (for positive
                  years). For dates before 1 January, AD 1, year numbers in the ISO and AD calendars
                  are off by one from each other: ISO year 0000 is 1 BC, -0001 is 2 BC, etc.</p>
               <note>
                  <p>The value space of the date and time data types, as defined in XML Schema, is
                     based on absolute points in time. The lexical space of these data types defines
                     a representation of these absolute points in time using the proleptic Gregorian
                     calendar, that is, the modern Western calendar extrapolated into the past and
                     the future; but the value space is calendar-neutral. The <termref def="dt-date-formatting-function">date formatting functions</termref>
                     produce a representation of this absolute point in time, but denoted in a
                     possibly different calendar. So, for example, the date whose lexical
                     representation in XML Schema is <code>1502-01-11</code> (the day on which Pope
                     Gregory XIII was born) might be formatted using the Old Style (Julian) calendar
                     as <code>1 January 1502</code>. This reflects the fact that there was at that
                     time a ten-day difference between the two calendars. It would be incorrect, and
                     would produce incorrect results, to represent this date in an element or
                     attribute of type <code>xs:date</code> as <code>1502-01-01</code>, even though
                     this might reflect the way the date was recorded in contemporary documents.</p>
                  <p>When referring to years occurring in antiquity, modern historians generally use
                     a numbering system in which there is no year zero (the year before 1 CE is thus
                     1 BCE). This is the convention that <rfc2119>should</rfc2119> be used when the
                     requested calendar is OS (Julian) or AD (Gregorian). When the requested
                     calendar is ISO, however, the conventions of ISO 8601 <rfc2119>should</rfc2119>
                     be followed: here the year before +0001 is numbered zero. In <bibref ref="xmlschema-2"/> (version 1.0), the value space for <code>xs:date</code>
                     and <code>xs:dateTime</code> does not include a year zero: however, a future
                     edition is expected to endorse the ISO 8601 convention. This means that the
                     date on which Julius Caesar was assassinated has the ISO 8601 lexical
                     representation -0043-03-13, but will be formatted as 15 March 44 BCE in the
                     Julian calendar or 13 March 44 BCE in the Gregorian calendar (dependant on the
                     chosen localization of the names of months and eras).</p>
               </note>
               <p>The intended use of the <code>country</code> argument is to identify the place
                  where an event represented by the <code>dateTime</code>, <code>date</code>, or
                     <code>time</code> supplied in the <code>$value</code> argument took place or
                  will take place. If the value is supplied, and is not the empty sequence, then it
                     <rfc2119>should</rfc2119> be a country code defined in <bibref ref="ISO3166"/>.
                  Implementations <rfc2119>may</rfc2119> also allow the use of codes representing
                  subdivisions of a country from ISO 3166-2, or codes representing formerly used
                  names of countries from ISO 3166-3. This argument is not intended to identify the
                  location of the user for whom the date or time is being formatted; that should be
                  done by means of the <code>language</code> attribute. This information
                     <rfc2119>may</rfc2119> be used to provide additional information when
                  converting dates between calendars or when deciding how individual components of
                  the date and time are to be formatted. For example, different countries using the
                  Old Style (Julian) calendar started the new year on different days, and some
                  countries used variants of the calendar that were out of synchronization as a
                  result of differences in calculating leap years. The geographical area identified
                  by a country code is defined by the boundaries as they existed at the time of the
                  date to be formatted, or the present-day boundaries for dates in the future.</p>
            </div3>
            <div3 id="date-time-examples">
               <head>Examples of Date and Time Formatting</head>
               <example>
                  <head>Gregorian Calendar</head>
                  <p>The following examples show a selection of dates and times and the way they
                     might be formatted. These examples assume the use of the Gregorian calendar as
                     the default calendar.</p>
                  <table border="1" cellpadding="5">
                     <thead>
                        <tr>
                           <th align="left" rowspan="1" colspan="1">Required Output</th>
                           <th align="left" rowspan="1" colspan="1">Expression</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>2002-12-31</code>
                           </td>
                           <td rowspan="1" colspan="1">
                              <code>format-date($d, "[Y0001]-[M01]-[D01]")</code>
                           </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>12-31-2002</code>
                           </td>
                           <td rowspan="1" colspan="1">
                              <code>format-date($d, "[M]-[D]-[Y]")</code>
                           </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>31-12-2002</code>
                           </td>
                           <td rowspan="1" colspan="1">
                              <code>format-date($d, "[D]-[M]-[Y]")</code>
                           </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>31 XII 2002</code>
                           </td>
                           <td rowspan="1" colspan="1">
                              <code>format-date($d, "[D1] [MI] [Y]")</code>
                           </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>31st December, 2002</code>
                           </td>
                           <td rowspan="1" colspan="1">
                              <code>format-date($d, "[D1o] [MNn], [Y]", "en", (), ())</code>
                           </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>31 DEC 2002</code>
                           </td>
                           <td rowspan="1" colspan="1">
                              <code>format-date($d, "[D01] [MN,*-3] [Y0001]", "en", (), ())</code>
                           </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>December 31, 2002</code>
                           </td>
                           <td rowspan="1" colspan="1">
                              <code>format-date($d, "[MNn] [D], [Y]", "en", (), ())</code>
                           </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>31 Dezember, 2002</code>
                           </td>
                           <td rowspan="1" colspan="1">
                              <code>format-date($d, "[D] [MNn], [Y]", "de", (), ())</code>
                           </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>Tisdag 31 December 2002</code>
                           </td>
                           <td rowspan="1" colspan="1">
                              <code>format-date($d, "[FNn] [D] [MNn] [Y]", "sv", (), ())</code>
                           </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>[2002-12-31]</code>
                           </td>
                           <td rowspan="1" colspan="1">
                              <code>format-date($d, "[[[Y0001]-[M01]-[D01]]]")</code>
                           </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>Two Thousand and Three</code>
                           </td>
                           <td rowspan="1" colspan="1">
                              <code>format-date($d, "[YWw]", "en", (), ())</code>
                           </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>einunddreiigste Dezember</code>
                           </td>
                           <td rowspan="1" colspan="1">
                              <code>format-date($d, "[Dwo] [MNn]", "de", (), ())</code>
                           </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>3:58 PM</code>
                           </td>
                           <td rowspan="1" colspan="1">
                              <code>format-time($t, "[h]:[m01] [PN]", "en", (), ())</code>
                           </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>3:58:45 pm</code>
                           </td>
                           <td rowspan="1" colspan="1">
                              <code>format-time($t, "[h]:[m01]:[s01] [Pn]", "en", (), ())</code>
                           </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>3:58:45 PM PDT</code>
                           </td>
                           <td rowspan="1" colspan="1">
                              <code>format-time($t, "[h]:[m01]:[s01] [PN] [ZN,*-3]", "en", (),
                                 ())</code>
                           </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>3:58:45 o'clock PM PDT</code>
                           </td>
                           <!--Text replaced by erratum E22 change 1"-->
                           <td rowspan="1" colspan="1">
                              <code>format-time($t, "[h]:[m01]:[s01] o'clock [PN] [ZN,*-3]", "en",
                                 (), ())</code>
                           </td>
                           <!--End of text replaced by erratum E22-->
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>15:58</code>
                           </td>
                           <td rowspan="1" colspan="1">
                              <code>format-time($t,"[H01]:[m01]")</code>
                           </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>15:58:45.762</code>
                           </td>
                           <td rowspan="1" colspan="1">
                              <code>format-time($t,"[H01]:[m01]:[s01].[f001]")</code>
                           </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>15:58:45 GMT+02:00</code>
                           </td>
                           <!--Text replaced by erratum E24 change 4"-->
                           <td rowspan="1" colspan="1">
                              <code>format-time($t,"[H01]:[m01]:[s01] [z,6-6]", "en", (), ())</code>
                           </td>
                           <!--End of text replaced by erratum E24-->
                        </tr>
                        <tr>
                           <!--Text replaced by erratum E24 change 5"-->
                           <td rowspan="1" colspan="1">
                              <code>15.58 Uhr GMT+2</code>
                           </td>
                           <!--End of text replaced by erratum E24-->
                           <td rowspan="1" colspan="1">
                              <code>format-time($t,"[H01]:[m01] Uhr [z]", "de", (), ())</code>
                           </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>3.58pm on Tuesday, 31st December</code>
                           </td>
                           <td rowspan="1" colspan="1">
                              <code>format-dateTime($dt, "[h].[m01][Pn] on [FNn], [D1o]
                                 [MNn]")</code>
                           </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>12/31/2002 at 15:58:45</code>
                           </td>
                           <td rowspan="1" colspan="1">
                              <code>format-dateTime($dt, "[M01]/[D01]/[Y0001] at
                                 [H01]:[m01]:[s01]")</code>
                           </td>
                        </tr>
                     </tbody>
                  </table>
               </example>
               <example>
                  <head>Non-Gregorian Calendars</head>
                  <p>The following examples use calendars other than the Gregorian calendar.</p>
                  <p>These examples use non-Latin characters which might not display correctly in
                     all browsers, depending on the system configuration.</p>
                  <table border="1" cellpadding="5">
                     <thead>
                        <tr>
                           <th align="left" rowspan="1" colspan="1">Description</th>
                           <th align="left" rowspan="1" colspan="1">Request</th>
                           <th align="left" rowspan="1" colspan="1">Result</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td valign="top" rowspan="1" colspan="1">Islamic</td>
                           <!--Text replaced by erratum E23 change 1"-->
                           <td valign="top" rowspan="1" colspan="1">
                              <code>format-date($d, "[D&amp;#x0661;] [Mn] [Y&amp;#x0661;]", "ar",
                                 "AH", ())</code>
                           </td>
                           <!--End of text replaced by erratum E23-->
                           <td valign="top" rowspan="1" colspan="1">
                              
                              </td>
                        </tr>
                        <tr>
                           <td valign="top" rowspan="1" colspan="1">Jewish (with Western
                              numbering)</td>
                           <td valign="top" rowspan="1" colspan="1">
                              <code>format-date($d, "[D] [Mn] [Y]", "he", "AM", ())</code>
                           </td>
                           <td valign="top" rowspan="1" colspan="1">26 
                              5763</td>
                        </tr>
                        <tr>
                           <td valign="top" rowspan="1" colspan="1">Jewish (with traditional
                              numbering)</td>
                           <td valign="top" rowspan="1" colspan="1">
                              <code>format-date($d, "[D&amp;#x05D0;t] [Mn] [Y&amp;#x05D0;t]", "he",
                                 "AM", ())</code>
                           </td>
                           <td valign="top" rowspan="1" colspan="1">
                               </td>
                        </tr>
                        <tr>
                           <td valign="top" rowspan="1" colspan="1">Julian (Old Style)</td>
                           <td valign="top" rowspan="1" colspan="1">
                              <code>format-date($d, "[D] [MNn] [Y]", "en", "OS", ())</code>
                           </td>
                           <td valign="top" rowspan="1" colspan="1">18 December 2002</td>
                        </tr>
                        <tr>
                           <td valign="top" rowspan="1" colspan="1">Thai</td>
                           <td valign="top" rowspan="1" colspan="1">
                              <code>format-date($d, "[D&amp;#x0E51;] [Mn] [Y&amp;#x0E51;]", "th",
                                 "BE", ())</code>
                           </td>
                           <td valign="top" rowspan="1" colspan="1">
                              
                              </td>
                        </tr>
                     </tbody>
                  </table>
               </example>
            </div3>
         </div2>
         <div2 id="context-dependent-functions">
            <head>Function items and context-dependency</head>
            <p><emph>This section describes unfinished work.</emph></p>
            <p>The XPath 2.1 specification introduces the ability for functions to be manipulated as values.
               In the draft of XPath 2.1 that is current at the time of writing, there are no rules describing
               how context-dependent function items (such as <code>position#0</code> or <code>static-base-uri#0</code>)
               are to be handled. The expected resolution is that (a) binding a function item to a function that depends
               on the static context (for example any function that depends on the default collation) will use the
               static context at the point where the function item is created, while (b) binding of function items to
               functions that depend on non-stable parts of the dynamic context (for example <code>position#0</code>
               or <code>name#0</code>) will not be allowed.</p>
            <p>Similar rules may need to be defined for XSLT-specific functions such as <function>key</function> or
            <function>current-group</function> that depend on the XSLT-specific parts of the static and dynamic
            context.</p>
            <issue id="issue-context-dependent-functions" status="open">
               <p>The rules for binding of function items to context-dependent functions need to be defined.</p>
            </issue>
            
         </div2>
      </div1>
      <div1 id="message">
         <head>Messages</head>
         <e:element-syntax name="message">
            <e:in-category name="instruction"/>
            <e:attribute name="select">
               <e:data-type name="expression"/>
            </e:attribute>
            <e:attribute name="terminate">
               <e:attribute-value-template>
                  <e:constant value="yes"/>
                  <e:constant value="no"/>
               </e:attribute-value-template>
            </e:attribute>
            <e:attribute name="error-code">
               <e:attribute-value-template>
                  <e:data-type name="QName"/>
               </e:attribute-value-template>
            </e:attribute>
            <e:model name="sequence-constructor"/>
            <e:allowed-parents>
               <e:parent-category name="sequence-constructor"/>
            </e:allowed-parents>
         </e:element-syntax>
         <p>The <elcode>xsl:message</elcode> instruction sends a message in an <termref def="dt-implementation-defined">implementation-defined</termref> way. The
               <elcode>xsl:message</elcode> instruction causes the creation of a new document, which
            is typically serialized and output to an <termref def="dt-implementation-defined">implementation-defined</termref> destination. The result of the
               <elcode>xsl:message</elcode> instruction is an empty sequence.</p>
         <p>The content of the message may be specified by using either or both of the optional
               <code>select</code> attribute and the <termref def="dt-sequence-constructor">sequence
               constructor</termref> that forms the content of the <elcode>xsl:message</elcode>
            instruction.</p>
         <p>If the <elcode>xsl:message</elcode> instruction contains a <termref def="dt-sequence-constructor">sequence constructor</termref>, then the sequence
            obtained by evaluating this sequence constructor is used to construct the content of the
            new document node, as described in <specref ref="constructing-complex-content"/>.</p>
         <p>If the <elcode>xsl:message</elcode> instruction has a <code>select</code> attribute,
            then the value of the attribute <rfc2119>must</rfc2119> be an XPath expression. The
            effect of the <elcode>xsl:message</elcode> instruction is then the same as if a single
               <elcode>xsl:copy-of</elcode> instruction with this <code>select</code> attribute were
            added to the start of the <termref def="dt-sequence-constructor">sequence
               constructor</termref>.</p>
         <p>If the <elcode>xsl:message</elcode> instruction has no content and no
               <code>select</code> attribute, then an empty message is produced.</p>
         <imp-def-feature>The destination and formatting of messages written using the
               <elcode>xsl:message</elcode> instruction are
            implementation-defined.</imp-def-feature>
         <p>The tree produced by the <elcode>xsl:message</elcode> instruction is not technically a
               <termref def="dt-final-result-tree">final result tree</termref>. The tree has no URI
            and processors are not <rfc2119>required</rfc2119> to make the tree accessible to
            applications.</p>
         <note>
            <p>In many cases, the XML document produced using <elcode>xsl:message</elcode> will
               consist of a document node owning a single text node. However, it may contain a more
               complex structure.</p>
         </note>
         <note>
            <p>An implementation might implement <elcode>xsl:message</elcode> by popping up an alert
               box or by writing to a log file. Because the order of execution of instructions is
               implementation-defined, the order in which such messages appear is not
               predictable.</p>
         </note>
         <p>The <code>terminate</code> attribute is interpreted as an <termref def="dt-attribute-value-template">attribute value template</termref>.</p>
         <p>If the <termref def="dt-effective-value">effective value</termref> of the
               <code>terminate</code> attribute is <code>yes</code>, then the <termref def="dt-processor">processor</termref>
            <rfc2119>must</rfc2119>
            <phrase diff="chg" at="B">signal a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref></phrase> after sending the message.
               <phrase diff="add" at="B">This error may be caught in the same way as any other
               dynamic error using <elcode>xsl:catch</elcode>.</phrase> The default value is
               <code>no</code>. Note that because the order of evaluation of instructions is
               <termref def="dt-implementation-dependent">implementation-dependent</termref>, this
            gives no guarantee that any particular instruction will or will not be evaluated before
            processing terminates.</p>
         <p>The optional <code>error-code</code> attribute may be used to indicate the error code
            associated with the message. This may be used irrespective of the value of
               <code>terminate</code>. The error code is a <termref def="dt-qname">QName</termref>,
            supplied as a <termref def="dt-lexical-qname">lexical QName</termref>. If no error code
            is specified, or if the value is not a valid QName, the error code will have local part
               <code>XTMM9000</code> and namespace URI
               <code>http://www.w3.org/2005/xqt-errors</code>. User-defined error codes
               <rfc2119>should</rfc2119> be in a namespace other than
               <code>http://www.w3.org/2005/xqt-errors</code>. When the value of
               <code>terminate</code> is <code>yes</code>, the error code may be matched in an
               <elcode>xsl:catch</elcode> element to catch the error and cause processing to
            continue normally.</p>
         <p>
            <error spec="XT" type="dynamic" class="MM" code="9000">
               <p>When a transformation is terminated by use of <code>xsl:message
                     terminate="yes"</code>, the effect is the same as when a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> occurs
                  during the transformation. <phrase diff="add" at="B">The default error code is
                        <code>XTMM9000</code>; this may be overridden using the
                        <code>error-code</code> attribute of the <elcode>xsl:message</elcode>
                     instruction.</phrase></p>
            </error>
         </p>
         <example>
            <head>Localizing Messages</head>
            <p>One convenient way to do localization is to put the localized information (message
               text, etc.) in an XML document, which becomes an additional input file to the
                  <termref def="dt-stylesheet">stylesheet</termref>. For example, suppose messages
               for a language <code>
                  <var>L</var>
               </code> are stored in an XML file <code>resources/<var>L</var>.xml</code> in the
               form:</p>
            <eg xml:space="preserve">&lt;messages&gt;
  &lt;message name="problem"&gt;A problem was detected.&lt;/message&gt;
  &lt;message name="error"&gt;An error was detected.&lt;/message&gt;
&lt;/messages&gt;
</eg>
            <p>Then a stylesheet could use the following approach to localize messages:</p>
            <eg xml:space="preserve">&lt;xsl:param name="lang" select="'en'"/&gt;
&lt;xsl:variable name="messages"
  select="document(concat('resources/', $lang, '.xml'))/messages"/&gt;

&lt;xsl:template name="localized-message"&gt;
  &lt;xsl:param name="name"/&gt;
  &lt;xsl:message select="string($messages/message[@name=$name])"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template name="problem"&gt;
  &lt;xsl:call-template name="localized-message"&gt;
    &lt;xsl:with-param name="name"&gt;problem&lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;</eg>
         </example>
         <!--Text inserted by erratum E20 change 1"-->
         <p>Any <termref def="dt-dynamic-error">dynamic error</termref> that occurs while evaluating
            the <code>select</code> expression or the contained <termref def="dt-sequence-constructor">sequence constructor</termref>, and any <termref def="dt-serialization-error">serialization error</termref> that occurs while
            processing the result, is treated as a <termref def="dt-recoverable-error">recoverable
               error</termref> even if the error would not be recoverable under other circumstances.
            The <termref def="dt-optional-recovery-action">optional recovery action</termref> is
               <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p>
         <note>
            <p>An example of such an error is the serialization error that occurs when processing
               the instruction <code>&lt;xsl:message select="@code"/&gt;</code> (on the grounds that
               free-standing attributes cannot be serialized). Making such errors recoverable means
               that it is implementation-defined whether or not they are signaled to the user and
               whether they cause termination of the transformation. If the processor chooses to
               recover from the error, the content of any resulting message is
               implementation-dependent.</p>
            <p>One possible recovery action is to include a description of the error in the
               generated message text.</p>
         </note>
         <!--End of text inserted by erratum E20-->
      </div1>
      <div1 id="extension">
         <head>Extensibility and Fallback</head>
         <p>XSLT allows two kinds of extension, extension instructions and extension functions.</p>
         <p>
            <termdef id="dt-extension-instruction" term="extension instruction">An <term>extension
                  instruction</term> is an element within a <termref def="dt-sequence-constructor">sequence constructor</termref> that is in a namespace (not the <termref def="dt-xslt-namespace">XSLT namespace</termref>) designated as an extension
               namespace.</termdef>
         </p>
         <p>
            <termdef id="dt-extension-function" term="extension function">An <term>extension
                  function</term> is a function that is available for use within an XPath <termref def="dt-expression">expression</termref>, other than a <termref def="dt-core-function">core function</termref> defined in <bibref ref="xpath-functions-11"/>, an additional function defined in this XSLT
               specification, a constructor function named after an atomic type, or a <termref def="dt-stylesheet-function">stylesheet function</termref> defined using an
                  <elcode>xsl:function</elcode> declaration.</termdef>. </p>
         <p>This specification does not define any mechanism for creating or binding implementations
            of <termref def="dt-extension-instruction">extension instructions</termref> or <termref def="dt-extension-function">extension functions</termref>, and it is not
               <rfc2119>required</rfc2119> that implementations support any such mechanism. Such
            mechanisms, if they exist, are <termref def="dt-implementation-defined">implementation-defined</termref>. Therefore, an XSLT stylesheet that
               <rfc2119>must</rfc2119> be portable between XSLT implementations cannot rely on
            particular extensions being available. XSLT provides mechanisms that allow an XSLT
            stylesheet to determine whether the implementation makes particular extensions
            available, and to specify what happens if those extensions are not available. If an XSLT
            stylesheet is careful to make use of these mechanisms, it is possible for it to take
            advantage of extensions and still retain portability.</p>
         <imp-def-feature>This specification does not define any mechanism for creating or binding
            implementations of <termref def="dt-extension-instruction">extension
               instructions</termref> or <termref def="dt-extension-function">extension
               functions</termref>, and it is not <rfc2119>required</rfc2119> that implementations
            support any such mechanism. Such mechanisms, if they exist, are <termref def="dt-implementation-defined">implementation-defined</termref>.</imp-def-feature>
         <div2 id="extension-functions">
            <head>Extension Functions</head>
            <p>The set of functions that can be called from a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-FunctionCall" xlink:type="simple">FunctionCall</xnt> within an XPath <termref def="dt-expression">expression</termref> may include one or more <termref def="dt-extension-function">extension functions</termref>. The <termref def="dt-expanded-qname">expanded-QName</termref> of an extension function always
               has a non-null namespace URI.</p>
            <div3 id="testing-function-availability">
               <head>Testing Availability of Functions</head>
               <p>The <function>function-available</function> function can be used with the
                     <code>[xsl:]use-when</code> attribute (see <specref ref="conditional-inclusion"/>) to explicitly control how a stylesheet behaves if a particular extension
                  function is not available.</p>
               <proto class="xslt" name="function-available" return-type="xs:boolean">
                  <arg name="function-name" type="xs:string"/>
               </proto>
               <proto class="xslt" name="function-available" return-type="xs:boolean">
                  <arg name="function-name" type="xs:string"/>
                  <arg name="arity" type="xs:integer"/>
               </proto>
               <p>A function is said to be available within an XPath expression if it is present in
                  the <xtermref spec="XP21" ref="dt-function-signature">in-scope
                     functions</xtermref> for that expression (see <specref ref="static-context"/>).
                  Functions in the static context are uniquely identified by the name of the
                  function (a QName) in combination with its <termref def="dt-arity">arity</termref>.</p>
               <p>The value of the <code>$function-name</code> argument <rfc2119>must</rfc2119> be a
                  string containing a <termref def="dt-lexical-qname">lexical QName</termref>. The
                  lexical QName is expanded into an <termref def="dt-expanded-qname">expanded-QName</termref> using the namespace declarations in scope for the
                     <termref def="dt-expression">expression</termref>. If the lexical QName is
                  unprefixed, then the <termref def="dt-standard-function-namespace">standard
                     function namespace</termref> is used in the expanded QName.</p>
               <p>The two-argument version of the <function>function-available</function> function
                  returns true if and only if there is an available function whose name matches the
                  value of the <code>$function-name</code> argument and whose <termref def="dt-arity">arity</termref> matches the value of the <code>$arity</code>
                  argument. </p>
               <p>The single-argument version of the <function>function-available</function>
                  function returns true if and only if there is at least one available function
                  (with some arity) whose name matches the value of the <code>$function-name</code>
                  argument. </p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1400">
                     <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                           error</termref> if the argument <error.extra>passed to the
                              <function>function-available</function> function</error.extra> does
                        not evaluate to a string that is a valid <termref def="dt-qname">QName</termref>, or if there is no namespace declaration in scope for
                        the prefix of the <termref def="dt-qname">QName</termref>. If the processor
                        is able to detect the error statically (for example, when the argument is
                        supplied as a string literal), then the processor <rfc2119>may</rfc2119>
                        optionally signal this as a <termref def="dt-static-error">static
                           error</termref>.</p>
                  </error>
               </p>
               <p><phrase diff="chg" at="D">When the containing expression is evaluated with
                        <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref>
                     set to true</phrase>, the <function>function-available</function>
                  function returns false in respect of a function name and arity for which no
                  implementation is available (other than the fallback error function that raises a
                  dynamic error whenever it is called). This means that it is possible (as in XSLT
                  1.0) to use logic such as the following to test whether a function is available
                  before calling it:</p>
               <example>
                  <head>Calling an extension function with backwards compatibility enabled</head>
                  <eg xml:space="preserve">
&lt;summary xsl:version="1.0"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="function-available('my:summary')"&gt;
      &lt;xsl:value-of select="my:summary()"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:text&gt;Summary not available&lt;/xsl:text&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/summary&gt;</eg>
               </example>
               <note>
                  <p>The fact that a function with a given name is available gives no guarantee that
                     any particular call on the function will be successful. For example, it is not
                     possible to determine the types of the arguments expected.</p>
               </note>
               <note diff="del" at="A">
                  <p>In XSLT 2.0 (without backwards compatibility enabled) a static error occurs
                     when an XPath expression references a function that is not available. This is
                     true even in a part of the stylesheet that uses <termref def="dt-forwards-compatible-behavior"/>. 
                     Therefore, the conditional logic to test whether a function
                     is available before calling it should normally be written in a
                        <code>use-when</code> attribute (see <specref ref="conditional-inclusion"/>).</p>
               </note>
               <example>
                  <head>Stylesheet portable between XSLT 1.0, XSLT 2.0, and XSLT 2.1</head>
                  <p>A stylesheet that is designed to use XSLT 2.0 facilities when running under an
                     <phrase diff="chg" at="F">XSLT 2.0 or XSLT 2.1 processor</phrase>, but to fall 
                     back to XSLT 1.0 capabilities when not, might be written
                     using the code:</p>
                  <eg xml:space="preserve">
&lt;out xsl:version="2.0"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="function-available('matches')"&gt;
      &lt;xsl:value-of select="matches($input, '[a-z]*')"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:value-of select="string-length(
	                  translate($in, 'abcdefghijklmnopqrstuvwxyz', '')) = 0"/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/out&gt;</eg>
                  <p>Here an <phrase diff="chg" at="F">XSLT 2.0 or XSLT 2.1</phrase> 
                     processor will always take the <elcode>xsl:when</elcode>
                     branch, while a 1.0 processor will follow the <elcode>xsl:otherwise</elcode>
                     branch. The single-argument version of the
                        <function>function-available</function> function is used here, because that
                     is the only version available in XSLT 1.0. Under the rules of XSLT 1.0, the
                     call on the <code>matches</code> function is not an error, because it is never
                     evaluated.</p>
               </example>
               <example>
                  <head>Stylesheet portable between XSLT 2.1 and a future version of XSLT</head>
                  <p>A stylesheet that is designed to use facilities in some future XSLT version
                     when they are available, but to fall back to <phrase diff="chg" at="F">XSLT 2.0 or XSLT 2.1</phrase> capabilities when not,
                     might be written using code such as the following. This hypothesizes the
                     availability in some future version of a function <code>pad</code> which pads a
                     string to a fixed length with spaces:</p>
                  <eg xml:space="preserve">
 &lt;xsl:value-of select="pad($input, 10)" 
               use-when="function-available('pad', 2)"/&gt;
 &lt;xsl:value-of select="concat($input, string-join(
                          for $i in 1 to 10 - string-length($input) 
						  return ' ', ''))"
               use-when="not(function-available('pad', 2))"/&gt;
 </eg>
                  <p>In this case the two-argument version of
                        <function>function-available</function> is used, because there is no
                     requirement for this code to run under XSLT 1.0.</p>
               </example>
            </div3>
            <div3 id="calling-extension-functions">
               <head>Calling Extension Functions</head>
               <p>If the function name used in a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-FunctionCall" xlink:type="simple">FunctionCall</xnt> within an XPath <termref def="dt-expression">expression</termref> identifies an extension function, then to evaluate the
                     <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-FunctionCall" xlink:type="simple">FunctionCall</xnt>, the
                  processor will first evaluate each of the arguments in the <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XP21" ref="prod-xpath21-FunctionCall" xlink:type="simple">FunctionCall</xnt>. If the processor has
                  information about the data types expected by the extension function, then it
                     <rfc2119>may</rfc2119> perform any necessary type conversions between the XPath
                  data types and those defined by the implementation language. If multiple extension
                  functions are available with the same name, the processor <rfc2119>may</rfc2119>
                  decide which one to invoke based on the number of arguments, the types of the
                  arguments, or any other criteria. The result returned by the implementation is
                  returned as the result of the function call, again after any necessary conversions
                  between the data types of the implementation language and those of XPath. The
                  details of such type conversions are outside the scope of this specification.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1420">
                     <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                           error</termref> if the arguments supplied to a call on an extension
                        function do not satisfy the rules defined for that particular extension
                        function, or if the extension function reports an error, or if the result of
                        the extension function cannot be converted to an XPath value.</p>
                  </error>
               </p>
               <note>
                  <p>Implementations may also provide mechanisms allowing extension functions to
                     report recoverable dynamic errors, or to execute within an environment that
                     treats some or all of the errors listed above as recoverable.</p>
               </note>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1425">
                     <p><phrase diff="chg" at="D">When the containing element is processed with
                              <termref def="dt-xslt-10-behavior">XSLT 1.0
                           behavior</termref>,</phrase> it is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> to
                        evaluate an extension function call if no implementation of the extension
                        function is available.</p>
                  </error>
               </p>
               <note>
                  <p>When <phrase diff="chg" at="D">XSLT 1.0 behavior</phrase> is not enabled, this
                     is a static error
                     <!--<xerrorref spec="XP21" class="ST" code="0017"/>-->[XPST0017].</p>
               </note>
               <note>
                  <p>There is no prohibition on calling extension functions that have side-effects
                     (for example, an extension function that writes data to a file). However, the
                     order of execution of XSLT instructions is not defined in this specification,
                     so the effects of such functions are unpredictable.</p>
               </note>
               <p>Implementations are not <rfc2119>required</rfc2119> to perform full validation of
                  values returned by extension functions. It is an error for an extension function
                  to return a string containing characters that are not permitted in XML, but the
                  consequences of this error are <termref def="dt-implementation-defined">implementation-defined</termref>. The implementation <rfc2119>may</rfc2119>
                  raise an error, <rfc2119>may</rfc2119> convert the string to a string containing
                  valid characters only, or <rfc2119>may</rfc2119> treat the invalid characters as
                  if they were permitted characters.</p>
               <imp-def-feature>The effect of an extension function returning a string containing
                  characters that are not legal in XML is implementation-defined.</imp-def-feature>
               <note>
                  <p>The ability to execute extension functions represents a potential security
                     weakness, since untrusted stylesheets may invoke code that has privileged
                     access to resources on the machine where the <termref def="dt-processor">processor</termref> executes. Implementations may therefore provide
                     mechanisms that restrict the use of extension functions by untrusted
                     stylesheets.</p>
               </note>
               <p>All observations in this section regarding the errors that can occur when invoking
                  extension functions apply equally when invoking <termref def="dt-extension-instruction">extension instructions</termref>.</p>
            </div3>
            <div3 id="external-objects">
               <head>External Objects</head>
               <p>An implementation <rfc2119>may</rfc2119> allow an extension function to return an
                  object that does not have any natural representation in the XDM data model,
                  whether as an atomic value, a node, <phrase diff="add" at="C">or a function
                     item</phrase>. For example, an extension function <code>sql:connect</code>
                  might return an object that represents a connection to a relational database; the
                  resulting connection object might be passed as an argument to calls on other
                  extension functions such as <code>sql:insert</code> and
                  <code>sql:select</code>.</p>
               <p>The way in which such objects are represented in the type system is <termref def="dt-implementation-defined">implementation-defined</termref>. They might be
                  represented by a completely new data type, or they might be mapped to existing
                  data types such as <code>integer</code>, <code>string</code>, or
                     <code>anyURI</code>.</p>
               <imp-def-feature>The way in which external objects are represented in the type system
                  is implementation-defined.</imp-def-feature>
            </div3>
            <div3 id="testing-type-availability">
               <head>Testing Availability of Types</head>
               <!--Text replaced by erratum E15 change 1"-->
               <p>The <function>type-available</function> function can be used to control how a
                  stylesheet behaves if a particular schema type is not available in the static
                  context.</p>
               <!--End of text replaced by erratum E15-->
               <proto class="xslt" name="type-available" return-type="xs:boolean">
                  <arg name="type-name" type="xs:string"/>
               </proto>
               <p>A schema type (that is, a simple type or a complex type) is said to be available
                  within an XPath expression if it is a type definition that is present in the
                     <xtermref spec="XP21" ref="dt-is-types">in-scope schema types</xtermref> for
                  that expression (see <specref ref="static-context"/>). This includes built-in
                  types, types imported using <elcode>xsl:import-schema</elcode>, and extension
                  types defined by the implementation.</p>
               <p>The value of the <code>$type-name</code> argument <rfc2119>must</rfc2119> be a
                  string containing a <termref def="dt-lexical-qname">lexical QName</termref>. The
                  lexical QName is expanded into an <termref def="dt-expanded-qname">expanded-QName</termref> using the namespace declarations in scope for the
                     <termref def="dt-expression">expression</termref>. If the lexical QName is
                  unprefixed, then the default namespace is used in the expanded QName.</p>
               <p>The function returns true if and only if there is an available type whose name
                  matches the value of the <code>$type-name</code> argument. </p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1428">
                     <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                           error</termref> if the argument <error.extra>passed to the
                              <function>type-available</function> function</error.extra> does not
                        evaluate to a string that is a valid <termref def="dt-qname">QName</termref>, or if there is no namespace declaration in scope for the
                        prefix of the <termref def="dt-qname">QName</termref>. If the processor is
                        able to detect the error statically (for example, when the argument is
                        supplied as a string literal), then the processor <rfc2119>may</rfc2119>
                        optionally signal this as a <termref def="dt-static-error">static
                           error</termref>.</p>
                  </error>
               </p>
               <!--Text inserted by erratum E15 change 2"-->
               <note>
                  <p>The <function>type-available</function> function is of limited use within an
                        <code>[xsl:]use-when</code> expression, because the static context for the
                     expression does not include any user-defined types.</p>
               </note>
               <!--End of text inserted by erratum E15-->
            </div3>
         </div2>
         <div2 id="extension-instruction">
            <head>Extension Instructions</head>
            <p>
               <termdef id="dt-extension-namespace" term="extension namespace">The <termref def="dt-extension-instruction">extension instruction</termref> mechanism allows
                  namespaces to be designated as <term>extension namespaces</term>. When a namespace
                  is designated as an extension namespace and an element with a name from that
                  namespace occurs in a <termref def="dt-sequence-constructor">sequence
                     constructor</termref>, then the element is treated as an <termref def="dt-instruction">instruction</termref> rather than as a <termref def="dt-literal-result-element">literal result element</termref>.</termdef> The
               namespace determines the semantics of the instruction.</p>
            <note>
               <p>Since an element that is a child of an <elcode>xsl:stylesheet</elcode> element is
                  not occurring <emph>in a <termref def="dt-sequence-constructor">sequence
                        constructor</termref>
                  </emph>, <termref def="dt-data-element">user-defined data elements</termref> (see
                     <specref ref="user-defined-top-level"/>) are not extension elements as defined
                  here, and nothing in this section applies to them.</p>
            </note>
            <div3 id="designating-extension-namespace">
               <head>Designating an Extension Namespace</head>
               <p>A namespace is designated as an extension namespace by using an
                     <code>[xsl:]extension-element-prefixes</code> attribute on an element in the
                  stylesheet (see <specref ref="standard-attributes"/>). The attribute
                     <rfc2119>must</rfc2119> be in the XSLT namespace only if its parent element is
                     <emph>not</emph> in the XSLT namespace. The value of the attribute is a
                  whitespace-separated list of namespace prefixes. The namespace bound to each of
                  the prefixes is designated as an extension namespace.</p>
               <p>The default namespace (as declared by <code>xmlns</code>) may be designated as an
                  extension namespace by including <code>#default</code> in the list of namespace
                  prefixes.</p>
               <!-- TODO: should clarify whether "default namespace" here includes the null namespace -->
               <p>
                  <error spec="XT" type="static" class="SE" code="1430">
                     <p>It is a <termref def="dt-static-error">static error</termref> if there is no
                        namespace bound to the prefix on the element bearing the
                           <code>[xsl:]extension-element-prefixes</code> attribute or, when
                           <code>#default</code> is specified, if there is no default namespace.</p>
                  </error>
               </p>
               <p>The designation of a namespace as an extension namespace is effective for the
                  element bearing the <code>[xsl:]extension-element-prefixes</code> attribute and
                  for all descendants of that element within the same stylesheet module.</p>
            </div3>
            <div3 id="testing-instruction-available">
               <head>Testing Availability of Instructions</head>
               <p>The <function>element-available</function> function can be used with the
                     <elcode>xsl:choose</elcode> and <elcode>xsl:if</elcode> instructions, or with
                  the <code>[xsl:]use-when</code> attribute (see <specref ref="conditional-inclusion"/>) to explicitly control how a stylesheet behaves
                  when a particular XSLT instruction or extension instruction is (or is not)
                  available.</p>
               <proto class="xslt" name="element-available" return-type="xs:boolean">
                  <arg name="element-name" type="xs:string"/>
               </proto>
               <p>The value of the <code>$element-name</code> argument <rfc2119>must</rfc2119> be a
                  string containing a <termref def="dt-qname">QName</termref>. The <termref def="dt-qname">QName</termref> is expanded into an <termref def="dt-expanded-qname">expanded-QName</termref> using the namespace
                  declarations in scope for the <termref def="dt-expression">expression</termref>.
                  If there is a default namespace in scope, then it is used to expand an unprefixed
                     <termref def="dt-qname">QName</termref>. The
                     <function>element-available</function> function returns true if and only if the
                     <termref def="dt-expanded-qname">expanded-QName</termref> is the name of an
                     <termref def="dt-instruction">instruction</termref>. If the <termref def="dt-expanded-qname">expanded-QName</termref> has a namespace URI equal to
                  the <termref def="dt-xslt-namespace">XSLT namespace</termref> URI, then it refers
                  to an element defined by XSLT. Otherwise, it refers to an <termref def="dt-extension-instruction">extension instruction</termref>. If the <termref def="dt-expanded-qname">expanded-QName</termref> has a null namespace URI, the
                     <function>element-available</function> function will return false.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1440">
                     <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                           error</termref> if the argument <error.extra>passed to the
                              <function>element-available</function> function</error.extra> does not
                        evaluate to a string that is a valid <termref def="dt-qname">QName</termref>, or if there is no namespace declaration in scope for the
                        prefix of the <termref def="dt-qname">QName</termref>. If the processor is
                        able to detect the error statically (for example, when the argument is
                        supplied as a string literal), then the processor <rfc2119>may</rfc2119>
                        optionally signal this as a <termref def="dt-static-error">static
                           error</termref>.</p>
                  </error>
               </p>
               <p>If the <termref def="dt-expanded-qname">expanded-QName</termref> is in the
                     <termref def="dt-xslt-namespace">XSLT namespace</termref>, the function returns
                  true if and only if the expanded QName is the name of an <termref def="dt-xslt-instruction">XSLT instruction</termref>, that is, an <termref def="dt-xslt-element">XSLT element</termref> whose syntax summary in this
                  specification classifies it as an <termref def="dt-instruction">instruction</termref>.</p>
               <note>
                  <p>Although the result of applying this function to a name in the XSLT namespace
                     when using a conformant XSLT <phrase diff="chg" at="A">2.1</phrase> processor
                     is entirely predictable, the function is useful in cases where the stylesheet
                     might be executing under a processor that implements some other version of XSLT
                     with different rules.</p>
               </note>
               <p>If the <termref def="dt-expanded-qname">expanded-QName</termref> is not in the
                     <termref def="dt-xslt-namespace">XSLT namespace</termref>, the function returns
                  true if and only if the processor has an implementation available of an <termref def="dt-extension-instruction">extension instruction</termref> with the given
                  expanded QName. This applies whether or not the namespace has been designated as
                  an <termref def="dt-extension-namespace">extension namespace</termref>.</p>
               <p>If the processor does not have an implementation of a particular extension
                  instruction available, and such an extension instruction is evaluated, then the
                  processor <rfc2119>must</rfc2119> perform fallback for the element as specified in
                     <specref ref="fallback"/>. An implementation <rfc2119>must not</rfc2119> signal
                  an error merely because the stylesheet contains an extension instruction for which
                  no implementation is available.</p>
               <!-- TODO: clarify that the result of element-available() does not depend on designating the namespace as
an extension element namespace -->
            </div3>
            <div3 id="fallback">
               <head>Fallback</head>
               <e:element-syntax name="fallback">
                  <e:in-category name="instruction"/>
                  <e:model name="sequence-constructor"/>
                  <e:allowed-parents>
                     <e:parent-category name="sequence-constructor"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p>The content of an <elcode>xsl:fallback</elcode> element is a <termref def="dt-sequence-constructor">sequence constructor</termref>, and when
                  performing fallback, the value returned by the <elcode>xsl:fallback</elcode>
                  element is the result of evaluating this sequence constructor.</p>
               <p>When not performing fallback, evaluating an <elcode>xsl:fallback</elcode> element
                  returns an empty sequence: the content of the <elcode>xsl:fallback</elcode>
                  element is ignored.</p>
               <p>There are two situations where a <termref def="dt-processor">processor</termref>
                  performs fallback: when an extension instruction that is not available is
                  evaluated, and when an instruction in the XSLT namespace, that is not defined in
                  XSLT <phrase diff="chg" at="A">2.1</phrase>, is evaluated within a region of the
                  stylesheet for which <termref def="dt-forwards-compatible-behavior"/> is enabled.</p>
               <note>
                  <p>Fallback processing is not invoked in other situations, for example it is not
                     invoked when an XPath expression uses unrecognized syntax or contains a call to
                     an unknown function. To handle such situations dynamically, the stylesheet
                     should call functions such as <function>system-property</function> and
                        <function>function-available</function> to decide what capabilities are
                     available.</p>
               </note>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1450">
                     <p>When a <termref def="dt-processor">processor</termref> performs fallback for
                        an <termref def="dt-extension-instruction">extension instruction</termref>
                        that is not recognized, if the instruction element has one or more
                           <elcode>xsl:fallback</elcode> children, then the content of each of the
                           <elcode>xsl:fallback</elcode> children <rfc2119>must</rfc2119> be
                        evaluated; it is a <termref def="dt-nonrec-dynamic-error">non-recoverable
                           dynamic error</termref> if it has no <elcode>xsl:fallback</elcode>
                        children.</p>
                  </error>
               </p>
               <note>
                  <p>This is different from the situation with unrecognized <termref def="dt-xslt-element">XSLT elements</termref>. As explained in <specref ref="forwards"/>, an unrecognized XSLT element appearing within a <termref def="dt-sequence-constructor">sequence constructor</termref> is a static
                     error unless (a) <termref def="dt-forwards-compatible-behavior"/> is enabled, and (b) the instruction
                     has an <elcode>xsl:fallback</elcode> child.</p>
               </note>
            </div3>
         </div2>
      </div1>
      <div1 id="result-trees">
         <head>Final Result Trees</head>
         <p>The output of a transformation is a set of one or more <termref def="dt-final-result-tree">final result trees</termref>.</p>
         <p>A <termref def="dt-final-result-tree">final result tree</termref> can be created
            explicitly, by evaluating an <elcode>xsl:result-document</elcode> instruction. As
            explained in <specref ref="executing-a-transformation"/>, a final result tree is also
            created implicitly if no <elcode>xsl:result-document</elcode> instruction is evaluated,
            or if the result of evaluating the <termref def="dt-initial-template">initial
               template</termref> is a non-empty sequence. </p>
         <p>The way in which a <termref def="dt-final-result-tree">final result tree</termref> is
            delivered to an application is <termref def="dt-implementation-defined">implementation-defined</termref>.</p>
         <imp-def-feature>The way in which a final result tree is delivered to an application is
            implementation-defined.</imp-def-feature>
         <p>Serialization of <termref def="dt-final-result-tree">final result trees</termref> is
            described further in <specref ref="serialization"/>
         </p>
         <div2 id="creating-result-trees">
            <head>Creating Final Result Trees</head>
            <e:element-syntax name="result-document">
               <e:in-category name="instruction"/>
               <e:attribute name="format">
                  <e:attribute-value-template>
                     <e:data-type name="qname"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="href">
                  <e:attribute-value-template>
                     <e:data-type name="uri-reference"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="validation">
                  <e:constant value="strict"/>
                  <e:constant value="lax"/>
                  <e:constant value="preserve"/>
                  <e:constant value="strip"/>
               </e:attribute>
               <e:attribute name="type">
                  <e:data-type name="qname"/>
               </e:attribute>
               <e:attribute name="method">
                  <e:attribute-value-template>
                     <e:constant value="xml"/>
                     <e:constant value="html"/>
                     <e:constant value="xhtml"/>
                     <e:constant value="text"/>
                     <e:data-type name="qname-but-not-ncname"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="byte-order-mark">
                  <e:attribute-value-template>
                     <e:constant value="yes"/>
                     <e:constant value="no"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="cdata-section-elements">
                  <e:attribute-value-template>
                     <e:data-type name="qnames"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="doctype-public">
                  <e:attribute-value-template>
                     <e:data-type name="string"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="doctype-system">
                  <e:attribute-value-template>
                     <e:data-type name="string"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="encoding">
                  <e:attribute-value-template>
                     <e:data-type name="string"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="escape-uri-attributes">
                  <e:attribute-value-template>
                     <e:constant value="yes"/>
                     <e:constant value="no"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="include-content-type">
                  <e:attribute-value-template>
                     <e:constant value="yes"/>
                     <e:constant value="no"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="indent">
                  <e:attribute-value-template>
                     <e:constant value="yes"/>
                     <e:constant value="no"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="media-type">
                  <e:attribute-value-template>
                     <e:data-type name="string"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="normalization-form">
                  <e:attribute-value-template>
                     <e:constant value="NFC"/>
                     <e:constant value="NFD"/>
                     <e:constant value="NFKC"/>
                     <e:constant value="NFKD"/>
                     <e:constant value="fully-normalized"/>
                     <e:constant value="none"/>
                     <e:data-type name="nmtoken"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="omit-xml-declaration">
                  <e:attribute-value-template>
                     <e:constant value="yes"/>
                     <e:constant value="no"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="standalone">
                  <e:attribute-value-template>
                     <e:constant value="yes"/>
                     <e:constant value="no"/>
                     <e:constant value="omit"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="suppress-indentation">
                  <e:attribute-value-template>
                     <e:data-type name="qnames"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="undeclare-prefixes">
                  <e:attribute-value-template>
                     <e:constant value="yes"/>
                     <e:constant value="no"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:attribute name="use-character-maps">
                  <e:data-type name="qnames"/>
               </e:attribute>
               <e:attribute name="output-version">
                  <e:attribute-value-template>
                     <e:data-type name="nmtoken"/>
                  </e:attribute-value-template>
               </e:attribute>
               <e:model name="sequence-constructor"/>
               <e:allowed-parents>
                  <e:parent-category name="sequence-constructor"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:result-document</elcode> instruction is used to create a <termref def="dt-final-result-tree">final result tree</termref>. The content of the
                  <elcode>xsl:result-document</elcode> element is a <termref def="dt-sequence-constructor">sequence constructor</termref> for the children of
               the document node of the tree. A document node is created, and the sequence obtained
               by evaluating the sequence constructor is used to construct the content of the
               document, as described in <specref ref="constructing-complex-content"/>. The tree
               rooted at this document node forms the final result tree.</p>
            <p>The <elcode>xsl:result-document</elcode> instruction defines the URI of the result
               tree, and may optionally specify the output format to be used for serializing this
               tree.</p>
            <p>The <termref def="dt-effective-value">effective value</termref> of the
                  <code>format</code> attribute, if specified, <rfc2119>must</rfc2119> be a <termref def="dt-lexical-qname">lexical QName</termref>. The QName is expanded using the
               namespace declarations in scope for the <elcode>xsl:result-document</elcode> element.
               The <termref def="dt-expanded-qname">expanded-QName</termref>
               <rfc2119>must</rfc2119> match the expanded QName of a named <termref def="dt-output-definition">output definition</termref> in the <termref def="dt-stylesheet">stylesheet</termref>. This identifies the
                  <elcode>xsl:output</elcode> declaration that will control the serialization of the
                  <termref def="dt-final-result-tree">final result tree</termref> (see <specref ref="serialization"/>), if the result tree is serialized. If the
                  <code>format</code> attribute is omitted, the unnamed <termref def="dt-output-definition">output definition</termref> is used to control
               serialization of the result tree.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="1460">
                  <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> if the <termref def="dt-effective-value">effective
                        value</termref> of the <code>format</code> attribute <error.extra>of an
                           <elcode>xsl:result-document</elcode> element</error.extra> is not a valid
                        <termref def="dt-lexical-qname">lexical QName</termref>, or if it does not
                     match the <termref def="dt-expanded-qname">expanded-QName</termref> of an
                        <termref def="dt-output-definition">output definition</termref> in the
                        <termref def="dt-stylesheet">stylesheet</termref>. If the processor is able
                     to detect the error statically (for example, when the <code>format</code>
                     attribute contains no curly brackets), then the processor
                        <rfc2119>may</rfc2119> optionally signal this as a <termref def="dt-static-error">static error</termref>.</p>
               </error>
            </p>
            <note>
               <p>The only way to select the unnamed <termref def="dt-output-definition">output
                     definition</termref> is to omit the <code>format</code> attribute.</p>
            </note>
            <p>The attributes <code>method</code>, <code>byte-order-mark</code>
               <code>cdata-section-elements</code>, <code>doctype-public</code>,
                  <code>doctype-system</code>, <code>encoding</code>,
                  <code>escape-uri-attributes</code>, <code>indent</code>, <code>media-type</code>,
                  <code>normalization-form</code>, <code>omit-xml-declaration</code>,
                  <code>standalone</code>, <phrase diff="add" at="B"><code>suppress-indentation</code>,</phrase>
               <!-- see bug 6535 -->
               <code>undeclare-prefixes</code>, <code>use-character-maps</code>, and
                  <code>output-version</code> may be used to override attributes defined in the
               selected <termref def="dt-output-definition">output definition</termref>.</p>
            <p>With the exception of <code>use-character-maps</code>, these attributes are all
               defined as <termref def="dt-attribute-value-template">attribute value
                  templates</termref>, so their values may be set dynamically. For any of these
               attributes that is present on the <elcode>xsl:result-document</elcode> instruction,
               the <termref def="dt-effective-value">effective value</termref> of the attribute
               overrides or supplements the corresponding value from the output definition. This
               works in the same way as when one <elcode>xsl:output</elcode> declaration overrides
               another:</p>
            <ulist>
               <item>
                  <p>In the case of <code>cdata-section-elements</code>
                     <phrase diff="add" at="B">and <code>suppress-indentation</code></phrase>, the
                     value of the serialization parameter is the union of the expanded names of the
                     elements named in this instruction and the elements named in the selected
                     output definition;</p>
               </item>
               <item>
                  <p>In the case of <code>use-character-maps</code>, the character maps referenced
                     in this instruction supplement and take precedence over those defined in the
                     selected output definition;</p>
               </item>
               <item>
                  <p>In all other cases, the effective value of an attribute actually present on
                     this instruction takes precedence over the value defined in the selected output
                     definition.</p>
               </item>
            </ulist>
            <note>
               <p>In the case of the attributes <code>method</code>,
                     <code>cdata-section-elements</code>, <phrase diff="add" at="B"><code>suppress-indentation</code></phrase>, and
                     <code>use-character-maps</code>, the <termref def="dt-effective-value">effective value</termref> of the attribute contains one or more lexical
                  QNames. The prefix in such a QName is expanded using the in-scope namespaces for
                  the <code>xsl:result-document</code> element. In the case of
                     <code>cdata-section-elements</code>
                  <phrase diff="add" at="B">and <code>suppress-indentation</code></phrase>, an
                  unprefixed element name is expanded using the default namespace.</p>
            </note>
            <p>The <code>output-version</code> attribute on the <elcode>xsl:result-document</elcode>
               instruction overrides the <code>version</code> attribute on
                  <elcode>xsl:output</elcode> (it has been renamed because <code>version</code> is
               available with a different meaning as a standard attribute: see <specref ref="standard-attributes"/>). In all other cases, attributes correspond if they
               have the same name.</p>
            <p>There are some serialization parameters that apply to some output methods but not to
               others. For example, the <code>indent</code> attribute has no effect on the
                  <code>text</code> output method. If a value is supplied for an attribute that is
               inapplicable to the output method, its value is not passed to the serializer. The
               processor <rfc2119>may</rfc2119> validate the value of such an attribute, but is not
                  <rfc2119>required</rfc2119> to do so.</p>
            <p>The <code>href</code> attribute is optional. The default value is the zero-length
               string. The <termref def="dt-effective-value">effective value</termref> of the
               attribute <rfc2119>must</rfc2119> be a <termref def="dt-uri-reference">URI
                  Reference</termref>, which may be absolute or relative. There
                  <rfc2119>may</rfc2119> be <termref def="dt-implementation-defined">implementation-defined</termref> restrictions on the form of absolute URI that
               may be used, but the implementation is not <rfc2119>required</rfc2119> to enforce any
               restrictions. Any legal relative URI <phrase diff="add" at="F">reference</phrase> 
               <rfc2119>must</rfc2119> be accepted. Note that
               the zero-length string is a legal relative URI <phrase diff="add" at="F">reference</phrase>.</p>
            <imp-def-feature>There <rfc2119>may</rfc2119> be <termref def="dt-implementation-defined">implementation-defined</termref> restrictions on
               the form of absolute URI that may be used in the <code>href</code> attribute of the
                  <elcode>xsl:result-document</elcode> instruction.</imp-def-feature>
            <p>The base URI of the document node at the root of the <termref def="dt-final-result-tree">final result tree</termref> is based on the <termref def="dt-effective-value">effective value</termref> of the <code>href</code>
               attribute. If the <termref def="dt-effective-value">effective value</termref> is a
               relative URI <phrase diff="add" at="F">reference</phrase>, then it is resolved relative to the <termref def="dt-base-output-uri">base output URI</termref>. If the implementation provides an API to access final
               result trees, then it <rfc2119>must</rfc2119> allow a final result tree to be
               identified by means of this base URI.</p>
            <note>
               <p>The base URI of the <termref def="dt-final-result-tree">final result
                     tree</termref> is not necessarily the same thing as the URI of its serialized
                  representation on disk, if any. For example, a server (or browser client) might
                  store final result trees only in memory, or in an internal disk cache. As long as
                  the processor satisfies requests for those URIs, it is irrelevant where they are
                  actually written on disk, if at all.</p>
            </note>
            <note>
               <p>It will often be the case that one <termref def="dt-final-result-tree">final
                     result tree</termref> contains links to another final result tree produced
                  during the same transformation, in the form of a relative URI <phrase diff="add" at="F">reference</phrase>. The mechanism of
                  associating a URI with a final result tree has been chosen to allow the integrity
                  of such links to be preserved when the trees are serialized.</p>
               <p>As well as being potentially significant in any API that provides access to final
                  result trees, the base URI of the new document node is relevant if the final
                  result tree, rather than being serialized, is supplied as input to a further
                  transformation.</p>
            </note>
            <p>The optional attributes <code>type</code> and <code>validation</code> may be used on
               the <elcode>xsl:result-document</elcode> instruction to validate the contents of the
               new document, and to determine the <termref def="dt-annotation">type
                  annotation</termref> that elements and attributes within the <termref def="dt-final-result-tree">final result tree</termref> will carry. The permitted
               values and their semantics are described in <specref ref="validating-document-nodes"/>.</p>
            <p>A <termref def="dt-processor">processor</termref>
               <rfc2119>may</rfc2119> allow a <termref def="dt-final-result-tree">final result
                  tree</termref> to be serialized. Serialization is described in <specref ref="serialization"/>. However, an implementation (for example, a <termref def="dt-processor">processor</termref> running in an environment with no access to
               writable filestore) is not <rfc2119>required</rfc2119> to support the serialization
               of <termref def="dt-final-result-tree">final result trees</termref>. An
               implementation that does not support the serialization of final result trees
                  <rfc2119>may</rfc2119> ignore the <code>format</code> attribute and the
               serialization attributes. Such an implementation <rfc2119>must</rfc2119> provide the
               application with some means of access to the (un-serialized) result tree, using its
               URI to identify it.</p>
            <p>Implementations may provide additional mechanisms, outside the scope of this
               specification, for defining the way in which <termref def="dt-final-result-tree">final result trees</termref> are processed. Such mechanisms
                  <rfc2119>may</rfc2119> make use of the XSLT-defined attributes on the
                  <elcode>xsl:result-document</elcode> and/or <elcode>xsl:output</elcode> elements,
               or they <rfc2119>may</rfc2119> use additional elements or attributes in an <termref def="dt-implementation-defined">implementation-defined</termref> namespace.</p>
            <imp-def-feature>Implementations <rfc2119>may</rfc2119> provide additional mechanisms
               allowing users to define the way in which <termref def="dt-final-result-tree">final
                  result trees</termref> are processed.</imp-def-feature>
            <example>
               <head>Multiple Result Documents</head>
               <p> The following example takes an XHTML document as input, and breaks it up so that
                  the text following each &lt;h1&gt; element is included in a separate document. A
                  new document <code>toc.html</code> is constructed to act as an index:</p>
               <eg xml:space="preserve">&lt;xsl:stylesheet
	version="2.1"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:xhtml="http://www.w3.org/1999/xhtml"&gt;
	
&lt;xsl:output name="toc-format" method="xhtml" indent="yes"
     doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
     doctype-public="-//W3C//DTD XHTML 1.0 Strict//EN"/&gt;
            
&lt;xsl:output name="section-format" method="xhtml" indent="no"
     doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
     doctype-public="-//W3C//DTD XHTML 1.0 Transitional//EN"/&gt;	
	 
&lt;xsl:template match="/"&gt;
  &lt;xsl:result-document href="toc.html" 
                       format="toc-format" 
                       validation="strict"&gt;
    &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
      &lt;head&gt;&lt;title&gt;Table of Contents&lt;/title&gt;&lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;Table of Contents&lt;/h1&gt;
        &lt;xsl:for-each select="/*/xhtml:body/(*[1] | xhtml:h1)"&gt;
          &lt;p&gt;
            &lt;a href="section{position()}.html"&gt;
              &lt;xsl:value-of select="."/&gt;
            &lt;/a&gt;
          &lt;/p&gt;
        &lt;/xsl:for-each&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:result-document&gt;
  &lt;xsl:for-each-group select="/*/xhtml:body/*" group-starting-with="xhtml:h1"&gt;
    &lt;xsl:result-document href="section{position()}.html" 
                         format="section-format" validation="strip"&gt;  	
      &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
        &lt;head&gt;&lt;title&gt;&lt;xsl:value-of select="."/&gt;&lt;/title&gt;&lt;/head&gt;
        &lt;body&gt;
          &lt;xsl:copy-of select="current-group()"/&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:result-document&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg>
            </example>
            <p>There are restrictions on the use of the <elcode>xsl:result-document</elcode>
               instruction, designed to ensure that the results are fully interoperable even when
               processors optimize the sequence in which instructions are evaluated. Informally, the
               restriction is that the <elcode>xsl:result-document</elcode> instruction can only be
               used while writing a final result tree, not while writing to a temporary tree or a
               sequence. This restriction is defined formally as follows.</p>
            <p>
               <termdef id="dt-output-state" term="output state">Each instruction in the <termref def="dt-stylesheet">stylesheet</termref> is evaluated in one of two possible
                     <term>output states</term>: <termref def="dt-final-output-state">final output
                     state</termref> or <termref def="dt-temporary-output-state">temporary output
                     state</termref>
               </termdef>.</p>
            <p>
               <termdef id="dt-final-output-state" term="final output state">The first of the two
                     <termref def="dt-output-state">output states</termref> is called <term>final
                     output</term> state. This state applies when instructions are writing to a
                     <termref def="dt-final-result-tree">final result tree</termref>.</termdef>
            </p>
            <p>
               <termdef id="dt-temporary-output-state" term="temporary output state">The second of
                  the two <termref def="dt-output-state">output states</termref> is called
                     <term>temporary output</term> state. This state applies when instructions are
                  writing to a <termref def="dt-temporary-tree">temporary tree</termref> or any
                  other non-final destination.</termdef>
            </p>
            <p>The instructions in the <termref def="dt-initial-template">initial template</termref>
               are evaluated in <termref def="dt-final-output-state">final output state</termref>.
               An instruction is evaluated in the same <termref def="dt-output-state">output
                  state</termref> as its calling instruction, except that
                  <elcode>xsl:variable</elcode>, <elcode>xsl:param</elcode>,
                  <elcode>xsl:with-param</elcode>, <elcode>xsl:attribute</elcode>,
                  <elcode>xsl:comment</elcode>, <elcode>xsl:processing-instruction</elcode>,
                  <elcode>xsl:namespace</elcode>, <elcode>xsl:value-of</elcode>,
                  <elcode>xsl:function</elcode>, <elcode>xsl:key</elcode>,
               <elcode>xsl:sort</elcode>, and <elcode>xsl:message</elcode> always evaluate the
               instructions in their contained <termref def="dt-sequence-constructor">sequence
                  constructor</termref> in <termref def="dt-temporary-output-state">temporary output
                  state</termref>.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="1480">
                  <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> to evaluate the <elcode>xsl:result-document</elcode>
                     instruction in <termref def="dt-temporary-output-state">temporary output
                        state</termref>.</p>
               </error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="1490">
                  <p>It is a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic
                        error</termref> for a transformation to generate two or more <termref def="dt-final-result-tree">final result trees</termref> with the same
                     URI.</p>
               </error>
            </p>
            <note>
               <p>Note, this means that it is an error to evaluate more than one
                     <elcode>xsl:result-document</elcode> instruction that omits the
                     <code>href</code> attribute, or to evaluate any
                     <elcode>xsl:result-document</elcode> instruction that omits the
                     <code>href</code> attribute if an initial <termref def="dt-final-result-tree">final result tree</termref> is created implicitly.</p>
            </note>
            <p>Technically, the result of evaluating the <elcode>xsl:result-document</elcode>
               instruction is an empty sequence. This means it does not contribute any nodes to the
               result of the sequence constructor it is part of.</p>
            <p>
               <error spec="XT" type="dynamic" class="RE" code="1495">
                  <p>It is a <termref def="dt-recoverable-error">recoverable dynamic error</termref>
                     for a transformation to generate two or more <termref def="dt-final-result-tree">final result trees</termref> with URIs that
                     identify the same physical resource. The <termref def="dt-optional-recovery-action">optional recovery action</termref> is
                        <termref def="dt-implementation-dependent">implementation-dependent</termref>, since it may be impossible for the
                     processor to detect the error.</p>
               </error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="RE" code="1500">
                  <p>It is a <termref def="dt-recoverable-error">recoverable dynamic error</termref>
                     for a <termref def="dt-stylesheet">stylesheet</termref> to write to an external
                     resource and read from the same resource during a single transformation,
                     whether or not the same URI is used to access the resource in both cases.
                        <error.action>The <termref def="dt-optional-recovery-action">optional
                           recovery action</termref> is <termref def="dt-implementation-dependent">implementation-dependent</termref>: implementations are not
                           <rfc2119>required</rfc2119> to detect the error condition. Note that if
                        the error is not detected, it is undefined whether the document that is read
                        from the resource reflects its state before or after the result tree is
                        written.</error.action>
                  </p>
               </error>
            </p>
         </div2>
         <div2 id="validation">
            <head>Validation</head>
            <p>It is possible to control the <termref def="dt-annotation">type annotation</termref>
               applied to individual element and attribute nodes as they are constructed. This is
               done using the <code>type</code> and <code>validation</code> attributes of the
                  <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                  <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>,
                  <elcode>xsl:document</elcode>, and <elcode>xsl:result-document</elcode>
               instructions, or the <code>xsl:type</code> and <code>xsl:validation</code> attributes
               of a <termref def="dt-literal-result-element">literal result element</termref>.</p>
            <p>The <code>[xsl:]type</code> attribute is used to request validation of an element or
               attribute against a specific simple or complex type defined in a schema. The
                  <code>[xsl:]validation</code> attribute is used to request validation against the
               global element or attribute declaration whose name matches the name of the element or
               attribute being validated.</p>
            <p>The <code>[xsl:]type</code> and <code>[xsl:]validation</code> attributes are mutually
               exclusive. Both are optional, but if one is present then the other
                  <rfc2119>must</rfc2119> be omitted. If both attributes are omitted, the effect is
               the same as specifying the <code>validation</code> attribute with the value specified
               in the <code>default-validation</code> attribute of the containing
                  <elcode>xsl:stylesheet</elcode> element; if this is not specified, the effect is
               the same as specifying <code>validation="strip"</code>.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="1505">
                  <p>It is a <termref def="dt-static-error">static error</termref> if both the
                        <code>[xsl:]type</code> and <code>[xsl:]validation</code> attributes are
                     present on the <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                        <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>,
                        <elcode>xsl:document</elcode>, or <elcode>xsl:result-document</elcode>
                     instructions, or on a <termref def="dt-literal-result-element">literal result
                        element</termref>.</p>
               </error>
            </p>
            <p>The detailed rules for validation vary depending on the kind of node being validated.
               The rules for element and attribute nodes are given in <specref ref="validating-constructed-nodes"/>, while those for document nodes are given in
                  <specref ref="validating-document-nodes"/>.</p>
            <div3 id="validating-constructed-nodes">
               <head>Validating Constructed Elements and Attributes</head>
               <div4 id="validating-using-validation-attribute">
                  <head>Validation using the <code>[xsl:]validation</code> Attribute</head>
                  <p>The <code>[xsl:]validation</code> attribute defines the validation action to be
                     taken. It determines not only the <termref def="dt-annotation">type
                        annotation</termref> of the node that is constructed by the relevant
                     instruction itself, but also the type annotations of all element and attribute
                     nodes that have the constructed node as an ancestor. Conceptually, the
                     validation requested for a child element or attribute node is applied before
                     the validation requested for its parent element. For example, if the
                     instruction that constructs a child element specifies
                        <code>validation="strict"</code>, this will cause the child element to be
                     checked against an element declaration, but if the instruction that constructs
                     its parent element specifies <code>validation="strip"</code>, then the final
                     effect will be that the child node is annotated as <code>xs:untyped</code>.</p>
                  <p>In the paragraphs below, the term <emph>contained nodes</emph> means the
                     elements and attributes that have the newly constructed node as an
                     ancestor.</p>
                  <ulist>
                     <item>
                        <p>The value <code>strip</code> indicates that the new node and each of the
                           contained nodes will have the <termref def="dt-annotation">type
                              annotation</termref>
                           <code>xs:untyped</code> if it is an element, or
                              <code>xs:untypedAtomic</code> if it is an attribute. Any previous type
                           annotation present on a contained element or attribute node (for example,
                           a type annotation that is present on an element copied from a source
                           document) is also replaced by <code>xs:untyped</code> or
                              <code>xs:untypedAtomic</code> as appropriate. The typed value of the
                           node is changed to be the same as its string value, as an instance of
                              <code>xs:untypedAtomic</code>. In the case of elements the
                              <code>nilled</code> property is set to <code>false</code>. The values
                           of the <code>is-id</code> and <code>is-idrefs</code> properties are
                           unchanged. Schema validation is not invoked.</p>
                     </item>
                     <item>
                        <p>The value <code>preserve</code> indicates that nodes that are copied will
                           retain their <termref def="dt-annotation">type annotations</termref>, but
                           nodes whose content is newly constructed will be annotated as
                              <code>xs:anyType</code> in the case of elements, or
                              <code>xs:untypedAtomic</code> in the case of attributes. Schema
                           validation is not invoked. The detailed effect depends on the
                           instruction:</p>
                        <ulist>
                           <item>
                              <p>In the case of <elcode>xsl:element</elcode> and literal result
                                 elements, the new element has a <termref def="dt-annotation">type
                                    annotation</termref> of <code>xs:anyType</code>, and the type
                                 annotations of contained nodes are retained unchanged.</p>
                           </item>
                           <item>
                              <p>In the case of <elcode>xsl:attribute</elcode>, the effect is
                                 exactly the same as specifying <code>validation="strip"</code>:
                                 that is, the new attribute will have the type annotation
                                    <code>xs:untypedAtomic</code>.</p>
                           </item>
                           <item>
                              <p>In the case of <elcode>xsl:copy-of</elcode>, all the nodes that are
                                 copied will retain their type annotations unchanged.</p>
                           </item>
                           <item>
                              <p>In the case of <elcode>xsl:copy</elcode>, the effect depends on the
                                 kind of node being copied.</p>
                              <olist>
                                 <item>
                                    <p>Where the node being copied is an attribute, the copied
                                       attribute will retain its <termref def="dt-annotation">type
                                          annotation</termref>.</p>
                                 </item>
                                 <item>
                                    <p>Where the node being copied is an element, the copied element
                                       will have a <termref def="dt-annotation">type
                                          annotation</termref> of <code>xs:anyType</code> (because
                                       this instruction does not copy the content of the element, it
                                       would be wrong to assume that the type is unchanged); but any
                                       contained nodes will have their type annotations retained in
                                       the same way as with <elcode>xsl:element</elcode>.</p>
                                 </item>
                              </olist>
                           </item>
                        </ulist>
                     </item>
                     <item>
                        <p>The value <code>strict</code> indicates that <termref def="dt-annotation">type annotations</termref> are established by performing strict
                           schema validity assessment on the element or attribute node created by
                           this instruction as follows:</p>
                        <ulist>
                           <item>
                              <p>In the case of an element, a top-level element declaration is
                                 identified whose local name and namespace (if any) match the name
                                 of the element, and schema-validity assessment is carried out
                                 according to the rules defined in <bibref ref="xmlschema-1"/>
                                 (section 3.3.4 <quote>Element Declaration Validation Rules</quote>,
                                 validation rule <quote>Schema-Validity Assessment
                                 (Element)</quote>, clauses 1.1 and 2, using the top-level element
                                 declaration as the "declaration stipulated by the processor", which
                                 is mentioned in clause 1.1.1.1). The element is considered valid if
                                 the result of the schema validity assessment is a PSVI in which the
                                 relevant element node has a <code>validity</code> property whose
                                 value is <code>valid</code>. If there is no matching element
                                 declaration, or if the element is not considered valid, the
                                 transformation fails <errorref class="TE" code="1510"/>, <errorref class="TE" code="1512"/>. In effect this means that the element
                                 being validated <rfc2119>must</rfc2119> be declared using a
                                 top-level declaration in the schema, and <rfc2119>must</rfc2119>
                                 conform to its declaration. The process of validation applies
                                 recursively to contained elements and attributes to the extent
                                 required by the schema definition.</p>
                              <note>
                                 <p>It is not an error if the identified type definition is a simple
                                    type, although <bibref ref="xmlschema-1"/> does not define
                                    explicitly that this case is permitted.</p>
                              </note>
                           </item>
                           <item>
                              <p>In the case of an attribute, a top-level attribute declaration is
                                 identified whose local name and namespace (if any) match the name
                                 of the attribute, and schema-validity assessment is carried out
                                 according to the rules defined in <bibref ref="xmlschema-1"/>
                                 (section 3.2.4 <quote>Attribute Declaration Validation
                                    Rules</quote>, validation rule <quote>Schema-Validity Assessment
                                    (Attribute)</quote>). The attribute is considered valid if the
                                 result of the schema validity assessment is a PSVI in which the
                                 relevant attribute node has a <code>validity</code> property whose
                                 value is <code>valid</code>. If the attribute is not considered
                                 valid, the transformation fails <errorref class="TE" code="1510"/>.
                                 In effect this means that the attribute being validated
                                    <rfc2119>must</rfc2119> be declared using a top-level
                                 declaration in the schema, and <rfc2119>must</rfc2119> conform to
                                 its declaration.</p>
                           </item>
                           <item>
                              <p>The schema components used to validate an element or attribute may
                                 be located in any way described by <bibref ref="xmlschema-1"/> (see
                                 section 4.3.2, <emph>How schema documents are located on the
                                    Web</emph>). The components in the schema constructed from the
                                 synthetic schema document (see <specref ref="import-schema"/>) will
                                 always be available for validating constructed nodes; if additional
                                 schema components are needed, they <rfc2119>may</rfc2119> be
                                 located in other ways, for example implicitly from knowledge of the
                                 namespace in which the elements and attributes appear, or using the
                                    <code>xsi:schemaLocation</code> attribute of elements within the
                                 tree being validated.</p>
                           </item>
                           <item>
                              <p>If no validation is performed for a node, which can happen when the
                                 schema specifies <code>lax</code> or <code>skip</code> validation
                                 for that node or for a subtree, then the node is annotated as
                                    <code>xs:anyType</code> in the case of an element, and
                                    <code>xs:untypedAtomic</code> in the case of an attribute.</p>
                           </item>
                        </ulist>
                     </item>
                     <item>
                        <p>The value <code>lax</code> has the same effect as the value
                              <code>strict</code>, except that whereas <code>strict</code>
                           validation fails if there is no matching top-level element declaration or
                           if the outcome of validity assessment is a <code>validity</code> property
                           of <code>invalid</code> or <code>notKnown</code>, <code>lax</code>
                           validation fails only if the outcome of validity assessment is a
                              <code>validity</code> property of <code>invalid</code>. That is,
                              <code>lax</code> validation does not cause a type error when the
                           outcome is <code>notKnown</code>.</p>
                        <p>In practice this means that the element or attribute being validated
                              <rfc2119>must</rfc2119> conform to its declaration if a top-level
                           declaration is available. If no such declaration is available, then the
                           element or attribute is not validated, but its attributes and children
                           are validated, again with lax validation. Any nodes whose validation
                           outcome is a <code>validity</code> property of <code>notKnown</code> are
                           annotated as <code>xs:anyType</code> in the case of an element, and
                              <code>xs:untypedAtomic</code> in the case of an attribute.</p>
                        <note>
                           <p>When the parent element lacks a declaration, the XML Schema
                              specification defines the recursive checking of children and
                              attributes as optional. For this specification, this recursive
                              checking is required.</p>
                        </note>
                        <note>
                           <p>If an element that is being validated has an <code>xsi:type</code>
                              attribute, then the value of the <code>xsi:type</code> attribute will
                              be taken into account when performing the validation. However, the
                              presence of an <code>xsi:type</code> attribute will not of itself
                              cause an element to be validated: if validation against a named type
                              is required, as distinct from validation against a top-level element
                              declaration, then it must be requested using the XSLT
                                 <code>[xsl:]type</code> attribute on the instruction that invokes
                              the validation, as described in section <specref ref="validation-xsl-type"/>
                           </p>
                        </note>
                     </item>
                  </ulist>
                  <p>
                     <error spec="XT" type="type" class="TE" code="1510">
                        <p>If the <code>validation</code> attribute of an
                              <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                              <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>, or
                              <elcode>xsl:result-document</elcode> instruction, or the
                              <code>xsl:validation</code> attribute of a literal result element, has
                           the effective value <code>strict</code>, and schema validity assessment
                           concludes that the validity of the element or attribute is invalid or
                           unknown, a type error occurs. As with other type errors, the error
                              <rfc2119>may</rfc2119> be signaled statically if it can be detected
                           statically. </p>
                     </error>
                  </p>
                  <p>
                     <error spec="XT" type="type" class="TE" code="1512">
                        <p>If the <code>validation</code> attribute of an
                              <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                              <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>, or
                              <elcode>xsl:result-document</elcode> instruction, or the
                              <code>xsl:validation</code> attribute of a literal result element, has
                           the effective value <code>strict</code>, and there is no matching
                           top-level declaration in the schema, then a type error occurs. As with
                           other type errors, the error <rfc2119>may</rfc2119> be signaled
                           statically if it can be detected statically. </p>
                     </error>
                  </p>
                  <p>
                     <error spec="XT" type="type" class="TE" code="1515">
                        <p>If the <code>validation</code> attribute of an
                              <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                              <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>, or
                              <elcode>xsl:result-document</elcode> instruction, or the
                              <code>xsl:validation</code> attribute of a literal result element, has
                           the effective value <code>lax</code>, and schema validity assessment
                           concludes that the element or attribute is invalid, a type error occurs.
                           As with other type errors, the error <rfc2119>may</rfc2119> be signaled
                           statically if it can be detected statically. </p>
                     </error>
                  </p>
                  <note>
                     <p>No mechanism is provided to validate an element or attribute against a local
                        declaration in a schema. Such validation can usually be achieved by applying
                        validation to a containing element for which a top-level element declaration
                        exists.</p>
                  </note>
               </div4>
               <div4 id="validation-xsl-type">
                  <head>Validation using the <code>[xsl:]type</code> Attribute</head>
                  <p>The <code>[xsl:]type</code> attribute takes as its value a <code>QName</code>.
                     This <rfc2119>must</rfc2119> be the name of a type definition included in the
                        <termref def="dt-in-scope-schema-component">in-scope schema
                        components</termref> for the stylesheet. If the QName has no prefix, it is
                     expanded using the default namespace established using the effective
                        <code>[xsl:]xpath-default-namespace</code> attribute if there is one;
                     otherwise, it is taken as being a name in no namespace.</p>
                  <p>If the <code>[xsl:]type</code> attribute is present, then the newly constructed
                     element or attribute is validated against the type definition identified by
                     this attribute.</p>
                  <ulist>
                     <item>
                        <p>In the case of an element, schema-validity assessment is carried out
                           according to the rules defined in <bibref ref="xmlschema-1"/> (section
                           3.3.4 <quote>Element Declaration Validation Rules</quote>, validation
                           rule <quote>Schema-Validity Assessment (Element)</quote>, clauses 1.2 and
                           2), using this type definition as the <quote>processor-stipulated type
                              definition</quote>. The element is considered valid if the result of
                           the schema validity assessment is a PSVI in which the relevant element
                           node has a <code>validity</code> property whose value is
                              <code>valid</code>. </p>
                     </item>
                     <item>
                        <p>In the case of an attribute, the attribute is considered valid if (in the
                           terminology of XML Schema) the attribute's normalized value is locally
                           valid with respect to that type definition according to the rules for
                              <quote>String Valid</quote> (<bibref ref="xmlschema-1"/>, section
                           3.14.4). (Normalization here refers to the process of normalizing
                           whitespace according to the rules of the <code>whiteSpace</code> facet
                           for the data type).</p>
                     </item>
                     <item>
                        <p>If the element or attribute is not considered valid, as defined above,
                           the transformation fails <errorref class="TE" code="1540"/>.</p>
                     </item>
                  </ulist>
                  <p>
                     <error spec="XT" type="static" class="SE" code="1520">
                        <p>It is a <termref def="dt-static-error">static error</termref> if the
                           value of the <code>type</code> attribute of an
                              <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                              <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>,
                              <elcode>xsl:document</elcode>, or <elcode>xsl:result-document</elcode>
                           instruction, or the <code>xsl:type</code> attribute of a literal result
                           element, is not a valid <code>QName</code>, or if it uses a prefix that
                           is not defined in an in-scope namespace declaration, or if the QName is
                           not the name of a type definition included in the <termref def="dt-in-scope-schema-component">in-scope schema
                              components</termref> for the stylesheet.</p>
                     </error>
                  </p>
                  <p>
                     <error spec="XT" type="static" class="SE" code="1530">
                        <p>It is a <termref def="dt-static-error">static error</termref> if the
                           value of the <code>type</code> attribute of an
                              <elcode>xsl:attribute</elcode> instruction refers to a complex type
                           definition</p>
                     </error>.</p>
                  <p>
                     <error spec="XT" type="type" class="TE" code="1540">
                        <p>It is a <termref def="dt-type-error">type error</termref> if an
                              <code>[xsl:]type</code> attribute is defined for a constructed element
                           or attribute, and the outcome of schema validity assessment against that
                           type is that the <code>validity</code> property of that element or
                           attribute information item is other than <code>valid</code>.</p>
                     </error>
                  </p>
                  <note>
                     <p>Like other type errors, this error may be signaled statically if it can be
                        detected statically. For example, the instruction <code>&lt;xsl:attribute
                           name="dob" type="xs:date"&gt;1999-02-29&lt;/xsl:attribute&gt;</code> may
                        result in a static error being signaled. If the error is not signaled
                        statically, it will be signaled when the instruction is evaluated.</p>
                  </note>
               </div4>
               <div4 id="validation-process">
                  <head>The Validation Process</head>
                  <p>As well as checking for validity against the schema, the validity assessment
                     process causes <termref def="dt-annotation">type annotations</termref> to be
                     associated with element and attribute nodes. If default values for elements or
                     attributes are defined in the schema, the validation process will where
                     necessary create new nodes containing these default values.</p>
                  <p>Validation of an element or attribute node only takes into account constraints
                     on the content of the element or attribute. Validation rules affecting the
                     document as a whole are not applied. Specifically, this means:</p>
                  <ulist>
                     <item>
                        <p>The validation rule <quote>Validation Root Valid (ID/IDREF)</quote> is
                           not applied. This means that validation will not fail if there are
                           non-unique ID values or dangling IDREF values in the subtree being
                           validated.</p>
                     </item>
                     <item>
                        <!--Text replaced by erratum E12 change 1"-->
                        <p>The validation rule <quote>Validation Rule: Identity-constraint
                              Satisfied</quote>
                           <rfc2119>should</rfc2119> be applied.</p>
                        <!--End of text replaced by erratum E12-->
                     </item>
                     <item>
                        <p>There is no check that the document contains unparsed entities whose
                           names match the values of nodes of type <code>xs:ENTITY</code> or
                              <code>xs:ENTITIES</code>. (XSLT <phrase diff="chg" at="A">2.1</phrase>
                           provides no facility to construct unparsed entities within a tree.)</p>
                     </item>
                     <item>
                        <p>There is no check that the document contains notations whose names match
                           the values of nodes of type <code>xs:NOTATION</code>. (The XDM data model
                           makes no provision for notations to be represented in the tree.)</p>
                     </item>
                  </ulist>
                  <p>With these caveats, validating a newly constructed element, using strict or lax
                     validation, is equivalent to the following steps:</p>
                  <olist>
                     <item>
                        <p>The element is serialized to textual XML form, according to the rules
                           defined in <bibref ref="xslt-xquery-serialization-11"/> using the XML output
                           method, with all parameters defaulted. Note that this process discards
                           any existing <termref def="dt-annotation">type annotations</termref>.</p>
                     </item>
                     <item>
                        <p>The resulting XML document is parsed to create an XML Information Set
                           (see <bibref ref="xml-infoset"/>.)</p>
                     </item>
                     <item>
                        <p>The Information Set produced in the previous step is validated according
                           to the rules in <bibref ref="xmlschema-1"/>. The result of this step is a
                           Post-Schema Validation Infoset (PSVI). If the validation process is not
                           successful (as defined above), a type error is raised.</p>
                     </item>
                     <item>
                        <p>The PSVI produced in the previous step is converted back into the XDM
                           data model by the mapping described in <bibref ref="xpath-datamodel-11"/>
                              (<xspecref spec="DM11" ref="PSVI2Types"/>). This process creates nodes
                           with simple or complex <termref def="dt-annotation">type
                              annotations</termref> based on the types established during schema
                           validation.</p>
                     </item>
                  </olist>
                  <p>Validating an attribute using strict or lax validation requires a modified
                     version of this procedure. A copy of the attribute is first added to an element
                     node that is created for the purpose, and namespace fixup (see <specref ref="namespace-fixup"/>) is performed on this element node. The name of this
                     element is of no consequence, but it must be the same as the name of a
                     synthesized element declaration of the form:</p>
                  <eg xml:space="preserve">&lt;xs:element name="E"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:sequence/&gt;
    &lt;xs:attribute ref="A"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</eg>
                  <p>where A is the name of the attribute being validated.</p>
                  <p>This synthetic element is then validated using the procedure given above for
                     validating elements, and if it is found to be valid, a copy of the validated
                     attribute is made, retaining its <termref def="dt-annotation">type
                        annotation</termref>, but detaching it from the containing element (and
                     thus, from any namespace nodes).</p>
                  <p>The XDM data model does not permit an attribute node with no parent to have a
                     typed value that includes a namespace-qualified name, that is, a value whose
                     type is derived from <code>xs:QName</code> or <code>xs:NOTATION</code>. This
                     restriction is imposed because these types rely on the namespace nodes of a
                     containing element to resolve namespace prefixes. Therefore, it is an error to
                     validate a parentless attribute against such a type. This affects the
                     instructions <elcode>xsl:attribute</elcode>, <elcode>xsl:copy</elcode>, and
                        <elcode>xsl:copy-of</elcode>.</p>
                  <p>
                     <error spec="XT" type="type" class="TE" code="1545">
                        <p>A <termref def="dt-type-error">type error</termref> occurs if a
                              <code>type</code> or <code>validation</code> attribute is defined
                           (explicitly or implicitly) for an instruction that constructs a new
                           attribute node, if the effect of this is to cause the attribute value to
                           be validated against a type that is derived from, or constructed by list
                           or union from, the primitive types <code>xs:QName</code> or
                              <code>xs:NOTATION</code>.</p>
                     </error>
                  </p>
               </div4>
            </div3>
            <div3 id="validating-document-nodes">
               <head>Validating Document Nodes</head>
               <p>It is possible to apply validation to a document node. This happens when a new
                  document node is constructed by one of the instructions
                     <elcode>xsl:document</elcode>, <elcode>xsl:result-document</elcode>,
                     <elcode>xsl:copy</elcode>, or <elcode>xsl:copy-of</elcode>, and this
                  instruction has a <code>type</code> attribute, or a <code>validation</code>
                  attribute with the value <code>strict</code> or <code>lax</code>.</p>
               <p>Document-level validation is not applied to the document node that is created
                  implicitly when a variable-binding element has no <code>select</code> attribute
                  and no <code>as</code> attribute (see <specref ref="temporary-trees"/>). This is
                  equivalent to using <code>validation="preserve"</code> on
                     <elcode>xsl:document</elcode>: nodes within such trees retain their <termref def="dt-annotation">type annotation</termref>. Similarly, validation is not
                  applied to document nodes created using <elcode>xsl:message</elcode>. </p>
               <p>The values <code>validation="preserve"</code> and <code>validation="strip"</code>
                  do not request validation. In the first case, all element and attribute nodes
                  within the tree rooted at the new document node retain their <termref def="dt-annotation">type annotations</termref>. In the second case, elements
                  within the tree have their type annotation set to <code>xs:untyped</code>, while
                  attributes have their type annotation set to <code>xs:untypedAtomic</code>.</p>
               <p>When validation is requested for a document node (that is, when
                     <code>validation</code> is set to <code>strict</code> or <code>lax</code>, or
                  when a <code>type</code> attribute is present), the following processing takes
                  place:</p>
               <ulist>
                  <item>
                     <p>
                        <error spec="XT" type="type" class="TE" code="1550">
                           <p>A <termref def="dt-type-error">type error</termref> occurs
                                 <error.extra>when a document node is validated</error.extra> unless
                              the children of the document node comprise exactly one element node,
                              no text nodes, and zero or more comment and processing instruction
                              nodes, in any order.</p>
                        </error>
                     </p>
                  </item>
                  <item>
                     <p>The single element node child is validated, using the supplied values of the
                           <code>validation</code> and <code>type</code> attributes, as described in
                           <specref ref="validating-constructed-nodes"/>.</p>
                     <note>
                        <p>The <code>type</code> attribute on <elcode>xsl:document</elcode> and
                              <elcode>xsl:result-document</elcode>, and on <elcode>xsl:copy</elcode>
                           and <elcode>xsl:copy-of</elcode> when copying a document node, thus
                           refers to the required type of the element node that is the only element
                           child of the document node. It does not refer to the type of the document
                           node itself.</p>
                     </note>
                  </item>
                  <item>
                     <p>The validation rule <quote>Validation Root Valid (ID/IDREF)</quote> is
                        applied to the single element node child of the document node. This means
                        that validation will fail if there are non-unique ID values or dangling
                        IDREF values in the document tree.</p>
                  </item>
                  <item>
                     <p>Identity constraints, as defined in section 3.11 of <bibref ref="xmlschema-1"/>, are checked. (This refers to constraints defined
                        using <code>xs:unique</code>, <code>xs:key</code>, and
                           <code>xs:keyref</code>.)</p>
                  </item>
                  <item>
                     <p>There is no check that the tree contains unparsed entities whose names match
                        the values of nodes of type <code>xs:ENTITY</code> or
                           <code>xs:ENTITIES</code>. This is because there is no facility in XSLT
                           <phrase diff="chg" at="A">2.1</phrase> to create unparsed entities in a
                           <termref def="dt-result-tree">result tree</termref>. It is possible to
                        add unparsed entity declarations to the result document by referencing a
                        suitable DOCTYPE during serialization.</p>
                  </item>
                  <item>
                     <p>There is no check that the document contains notations whose names match the
                        values of nodes of type <code>xs:NOTATION</code>. This is because notations
                        are not part of the XDM data model. It is possible to add notations to the
                        result document by referencing a suitable DOCTYPE during serialization.</p>
                  </item>
                  <item>
                     <p>All other children of the document node (comments and processing
                        instructions) are copied unchanged.</p>
                  </item>
               </ulist>
               <p>
                  <error spec="XT" type="type" class="TE" code="1555">
                     <p>It is a <termref def="dt-type-error">type error</termref> if, when
                        validating a document node, document-level constraints are not satisfied.
                        These constraints include identity constraints (<code>xs:unique</code>,
                           <code>xs:key</code>, and <code>xs:keyref</code>) and ID/IDREF
                        constraints.</p>
                  </error>
               </p>
            </div3>
         </div2>
      </div1>
      <div1 id="serialization">
         <head>Serialization</head>
         <p>A <termref def="dt-processor">processor</termref>
            <rfc2119>may</rfc2119> output a <termref def="dt-final-result-tree">final result
               tree</termref> as a sequence of octets, although it is not
               <rfc2119>required</rfc2119> to be able to do so (see <specref ref="conformance"/>).
            Stylesheet authors can use <elcode>xsl:output</elcode> declarations to specify how they
            wish result trees to be serialized. If a processor serializes a final result tree, it
               <rfc2119>must</rfc2119> do so as specified by these declarations.</p>
         <p>The rules governing the output of the serializer are defined in <bibref ref="xslt-xquery-serialization-11"/>. The serialization is controlled using a number of
            serialization parameters. The values of these serialization parameters may be set within
            the <termref def="dt-stylesheet">stylesheet</termref>, using the
               <elcode>xsl:output</elcode>, <elcode>xsl:result-document</elcode>, and
               <elcode>xsl:character-map</elcode> declarations.</p>
         <e:element-syntax name="output">
            <e:in-category name="declaration"/>
            <e:attribute name="name">
               <e:data-type name="qname"/>
            </e:attribute>
            <e:attribute name="method">
               <e:constant value="xml"/>
               <e:constant value="html"/>
               <e:constant value="xhtml"/>
               <e:constant value="text"/>
               <e:data-type name="qname-but-not-ncname"/>
            </e:attribute>
            <e:attribute name="byte-order-mark">
               <e:constant value="yes"/>
               <e:constant value="no"/>
            </e:attribute>
            <e:attribute name="cdata-section-elements">
               <e:data-type name="qnames"/>
            </e:attribute>
            <e:attribute name="doctype-public">
               <e:data-type name="string"/>
            </e:attribute>
            <e:attribute name="doctype-system">
               <e:data-type name="string"/>
            </e:attribute>
            <e:attribute name="encoding">
               <e:data-type name="string"/>
            </e:attribute>
            <e:attribute name="escape-uri-attributes">
               <e:constant value="yes"/>
               <e:constant value="no"/>
            </e:attribute>
            <e:attribute name="include-content-type">
               <e:constant value="yes"/>
               <e:constant value="no"/>
            </e:attribute>
            <e:attribute name="indent">
               <e:constant value="yes"/>
               <e:constant value="no"/>
            </e:attribute>
            <e:attribute name="media-type">
               <e:data-type name="string"/>
            </e:attribute>
            <e:attribute name="normalization-form">
               <e:constant value="NFC"/>
               <e:constant value="NFD"/>
               <e:constant value="NFKC"/>
               <e:constant value="NFKD"/>
               <e:constant value="fully-normalized"/>
               <e:constant value="none"/>
               <e:data-type name="nmtoken"/>
            </e:attribute>
            <e:attribute name="omit-xml-declaration">
               <e:constant value="yes"/>
               <e:constant value="no"/>
            </e:attribute>
            <e:attribute name="standalone">
               <e:constant value="yes"/>
               <e:constant value="no"/>
               <e:constant value="omit"/>
            </e:attribute>
            <e:attribute name="suppress-indentation">
               <!--see bug 6535-->
               <e:data-type name="qnames"/>
            </e:attribute>
            <e:attribute name="undeclare-prefixes">
               <e:constant value="yes"/>
               <e:constant value="no"/>
            </e:attribute>
            <e:attribute name="use-character-maps">
               <e:data-type name="qnames"/>
            </e:attribute>
            <e:attribute name="version">
               <e:data-type name="nmtoken"/>
            </e:attribute>
            <e:empty/>
            <e:allowed-parents>
               <e:parent name="stylesheet"/>
               <e:parent name="transform"/>
            </e:allowed-parents>
         </e:element-syntax>
         <p>The <elcode>xsl:output</elcode> declaration is optional; if used, it
               <rfc2119>must</rfc2119> always appear as a <termref def="dt-top-level">top-level</termref> element within a stylesheet module.</p>
         <p>A <termref def="dt-stylesheet">stylesheet</termref> may contain multiple
               <elcode>xsl:output</elcode> declarations and may include or import stylesheet modules
            that also contain <elcode>xsl:output</elcode> declarations. The name of an
               <elcode>xsl:output</elcode> declaration is the value of its <code>name</code>
            attribute, if any.</p>
         <p>
            <termdef id="dt-output-definition" term="output definition">All the
                  <elcode>xsl:output</elcode> declarations in a stylesheet that share the same name
               are grouped into a named <term>output definition</term>; those that have no name are
               grouped into a single unnamed output definition.</termdef>
         </p>
         <p>A stylesheet always includes an unnamed <termref def="dt-output-definition">output
               definition</termref>; in the absence of an unnamed <elcode>xsl:output</elcode>
            declaration, the unnamed output definition is equivalent to the one that would be used
            if the stylesheet contained an <elcode>xsl:output</elcode> declaration having no
            attributes.</p>
         <p>A named <termref def="dt-output-definition">output definition</termref> is used when its
            name matches the <code>format</code> attribute used in an
               <elcode>xsl:result-document</elcode> element. The unnamed output definition is used
            when an <elcode>xsl:result-document</elcode> element omits the <code>format</code>
            attribute. It is also used when serializing the <termref def="dt-final-result-tree">final result tree</termref> that is created implicitly in the absence of an
               <elcode>xsl:result-document</elcode> element.</p>
         <p>All the <elcode>xsl:output</elcode> elements making up an <termref def="dt-output-definition">output definition</termref> are effectively merged. For
            those attributes whose values are namespace-sensitive, the merging is done after
               <termref def="dt-lexical-qname">lexical QNames</termref> have been converted into
               <termref def="dt-expanded-qname">expanded QNames</termref>. For the
               <code>cdata-section-elements</code>
            <phrase diff="add" at="B">and <code>suppress-indentation</code></phrase> attributes, the
            output definition uses the union of the values from all the constituent
               <elcode>xsl:output</elcode> declarations. For the <code>use-character-maps</code>
            attribute, the output definition uses the concatenation of the sequences of <termref def="dt-expanded-qname">expanded QNames</termref> values from all the constituent
               <elcode>xsl:output</elcode> declarations, taking them in order of increasing <termref def="dt-import-precedence">import precedence</termref>, or where several have the
            same import precedence, in <termref def="dt-declaration-order">declaration
               order</termref>. For other attributes, the <termref def="dt-output-definition">output
               definition</termref> uses the value of that attribute from the
               <elcode>xsl:output</elcode> declaration with the highest <termref def="dt-import-precedence">import precedence</termref>.</p>
         <p>
            <error spec="XT" type="static" class="SE" code="1560">
               <p>It is a <termref def="dt-static-error">static error</termref> if two
                     <elcode>xsl:output</elcode> declarations within an <termref def="dt-output-definition">output definition</termref> specify explicit values
                  for the same attribute (other than <code>cdata-section-elements</code> and
                     <code>use-character-maps</code>), with the values of the attributes being not
                  equal, unless there is another <elcode>xsl:output</elcode> declaration within the
                  same <termref def="dt-output-definition">output definition</termref> that has
                  higher import precedence and that specifies an explicit value for the same
                  attribute. </p>
            </error>
         </p>
         <p>If none of the <elcode>xsl:output</elcode> declarations within an <termref def="dt-output-definition">output definition</termref> specifies a value for a
            particular attribute, then the corresponding serialization parameter takes a default
            value. The default value depends on the chosen output method.</p>
         <p>There are some serialization parameters that apply to some output methods but not to
            others. For example, the <code>indent</code> attribute has no effect on the
               <code>text</code> output method. If a value is supplied for an attribute that is
            inapplicable to the output method, its value is not passed to the serializer. The
            processor <rfc2119>may</rfc2119> validate the value of such an attribute, but is not
               <rfc2119>required</rfc2119> to do so.</p>
         <p>An implementation <rfc2119>may</rfc2119> allow the attributes of the
               <elcode>xsl:output</elcode> declaration to be overridden, or the default values to be
            changed, using the API that controls the transformation.</p>
         <p>The location to which <termref def="dt-final-result-tree">final result trees</termref>
            are serialized (whether in filestore or elsewhere) is <termref def="dt-implementation-defined">implementation-defined</termref> (which in practice
               <rfc2119>may</rfc2119> mean that it is controlled using an implementation-defined
            API). However, these locations <rfc2119>must</rfc2119> satisfy the constraint that when
            two <termref def="dt-final-result-tree">final result trees</termref> are both created
            (implicitly or explicitly) using relative URI <phrase diff="add" at="F">references</phrase>
            in the <code>href</code> attribute of the
            <elcode>xsl:result-document</elcode> instruction, then these relative URI 
            <phrase diff="add" at="F">references</phrase> may be
            used to construct references from one tree to the other, and such references
               <rfc2119>must</rfc2119> remain valid when both result trees are serialized. </p>
         <imp-def-feature>If serialization is supported, then the location to which a <termref def="dt-final-result-tree">final result tree</termref> is serialized is
            implementation-defined, subject to the constraint that relative URI <phrase diff="add" at="F">references</phrase> used to reference
            one tree from another remain valid.</imp-def-feature>
         <p>The <code>method</code> attribute on the <elcode>xsl:output</elcode> element identifies
            the overall method that is to be used for outputting the <termref def="dt-final-result-tree">final result tree</termref>.</p>
         <p>
            <error spec="XT" type="static" class="SE" code="1570">
               <p>The value <error.extra>of the <code>method</code> attribute on
                        <elcode>xsl:output</elcode>
                  </error.extra>
                  <rfc2119>must</rfc2119> (if present) be a valid <termref def="dt-qname">QName</termref>. If the <termref def="dt-qname">QName</termref> does not have
                  a prefix, then it identifies a method specified in <bibref ref="xslt-xquery-serialization-11"/> and <rfc2119>must</rfc2119> be one of
                     <code>xml</code>, <code>html</code>, <code>xhtml</code>, or
                  <code>text</code>.</p>
            </error> If the <termref def="dt-qname">QName</termref> has a prefix, then the <termref def="dt-qname">QName</termref> is expanded into an <termref def="dt-expanded-qname">expanded-QName</termref> as described in <specref ref="qname"/>; the <termref def="dt-expanded-qname">expanded-QName</termref> identifies the output method; the
            behavior in this case is not specified by this document.</p>
         <p>The default for the <code>method</code> attribute depends on the contents of the tree
            being serialized, and is chosen as follows. If the document node of the <termref def="dt-final-result-tree">final result tree</termref> has an element child, and any
            text nodes preceding the first element child of the document node of the result tree
            contain only whitespace characters, then:</p>
         <ulist>
            <item>
               <p>If the <termref def="dt-expanded-qname">expanded-QName</termref> of this first
                  element child has local part <code>html</code> (in lower case), and namespace URI
                     <code>http://www.w3.org/1999/xhtml</code>, then the default output method is
                  normally <code>xhtml</code>. However, if the <code>version</code> attribute of the
                     <elcode>xsl:stylesheet</elcode> element of the <termref def="dt-principal-stylesheet-module">principal stylesheet module</termref> has
                  the value <code>1.0</code>, and if the result tree is generated implicitly (rather
                  than by an explicit <elcode>xsl:result-document</elcode> instruction), then the
                  default output method in this situation is <code>xml</code>.</p>
            </item>
            <item>
               <p>If the <termref def="dt-expanded-qname">expanded-QName</termref> of this first
                  element child has local part <code>html</code> (in any combination of upper and
                  lower case) and a null namespace URI, then the default output method is
                     <code>html</code>.</p>
            </item>
         </ulist>
         <p>In all other cases, the default output method is <code>xml</code>.</p>
         <p>The default output method is used if the selected <termref def="dt-output-definition">output definition</termref> does not include a <code>method</code> attribute.</p>
         <p>The other attributes on <elcode>xsl:output</elcode> provide parameters for the output
            method. The following attributes are allowed:</p>
         <ulist>
            <item>
               <p> The value of the <code>encoding</code> attribute provides the value of the
                     <code>encoding</code> parameter to the serialization method. The default value
                  is <termref def="dt-implementation-defined">implementation-defined</termref>, but
                  in the case of the <code>xml</code> and <code>xhtml</code> methods it
                     <rfc2119>must</rfc2119> be either <code>UTF-8</code> or <code>UTF-16</code>. </p>
               <imp-def-feature>The default value of the <code>encoding</code> attribute of the
                     <elcode>xsl:output</elcode> element is
                  implementation-defined.</imp-def-feature>
            </item>
            <item>
               <p>The <code>byte-order-mark</code> attribute defines whether a byte order mark is
                  written at the start of the file. If the value <code>yes</code> is specified, a
                  byte order mark is written; if <code>no</code> is specified, no byte order mark is
                  written. The default value depends on the encoding used. If the encoding is
                     <code>UTF-16</code>, the default is <code>yes</code>; for <code>UTF-8</code> it
                  is <termref def="dt-implementation-defined">implementation-defined</termref>, and
                  for all other encodings it is <code>no</code>. The value of the byte order mark
                  indicates whether high order bytes are written before or after low order bytes;
                  the actual byte order used is <termref def="dt-implementation-dependent">implementation-dependent</termref>, unless it is defined by the selected
                  encoding. </p>
            </item>
            <item>
               <p> The <code>cdata-section-elements</code> attribute is a whitespace-separated list
                  of QNames. The default value is an empty list. After expansion of these names
                  using the in-scope namespace declarations for the <elcode>xsl:output</elcode>
                  declaration in which they appear, this list of names provides the value of the
                     <code>cdata-section-elements</code> parameter to the serialization method. In
                  the case of an unprefixed name, the default namespace (that is, the namespace
                  declared using <code>xmlns="uri"</code>) is used. </p>
               <note>
                  <p>This differs from the rule for most other QNames used in a stylesheet. The
                     reason is that these names refer to elements in the result document, and
                     therefore follow the same convention as the name of a literal result element or
                     the <code>name</code> attribute of <elcode>xsl:element</elcode>.</p>
               </note>
            </item>
            <item>
               <p> The value of the <code>doctype-system</code> attribute provides the value of the
                     <code>doctype-system</code> parameter to the serialization method. By default,
                  the parameter is not supplied. </p>
            </item>
            <item>
               <p> The value of the <code>doctype-public</code> attribute provides the value of the
                     <code>doctype-public</code> parameter to the serialization method. By default,
                  the parameter is not supplied. </p>
               <!--Text inserted by erratum E3 change 1"-->
               <p>The value of <code>doctype-public</code> must conform to the rules for a <xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XML" ref="PubidLiteral" xlink:type="simple">PubidLiteral</xnt> (see <bibref ref="REC-xml"/>).</p>
               <!--End of text inserted by erratum E3-->
            </item>
            <item>
               <p> The value of the <code>escape-uri-attributes</code> attribute provides the value
                  of the <code>escape-uri-attributes</code> parameter to the serialization method.
                  The default value is <code>yes</code>. </p>
            </item>
            <item>
               <p> The value of the <code>include-content-type</code> attribute provides the value
                  of the <code>include-content-type</code> parameter to the serialization method.
                  The default value is <code>yes</code>. </p>
            </item>
            <item>
               <p> The value of the <code>indent</code> attribute provides the value of the
                     <code>indent</code> parameter to the serialization method. The default value is
                     <code>yes</code> in the case of the <code>html</code> and <code>xhtml</code>
                  output methods, <code>no</code> in the case of the <code>xml</code> output method.
               </p>
            </item>
            <item>
               <p> The value of the <code>media-type</code> attribute provides the value of the
                     <code>media-type</code> parameter to the serialization method. The default
                  value is <code>text/xml</code> in the case of the <code>xml</code> output method,
                     <code>text/html</code> in the case of the <code>html</code> and
                     <code>xhtml</code> output methods, and <code>text/plain</code> in the case of
                  the <code>text</code> output method. </p>
            </item>
            <item>
               <p> The value of the <code>normalization-form</code> attribute provides the value of
                  the <code>normalization-form</code> parameter to the serialization method. A value
                  that is an <code>NMTOKEN</code> other than one of those enumerated for the
                     <code>normalization-form</code> attribute specifies an implementation-defined
                  normalization form; the behavior in this case is not specified by this document.
                  The default value is <code>none</code>. </p>
            </item>
            <item>
               <p> The value of the <code>omit-xml-declaration</code> attribute provides the value
                  of the <code>omit-xml-declaration</code> parameter to the serialization method.
                  The default value is <code>no</code>. </p>
            </item>
            <item>
               <p> The value of the <code>standalone</code> attribute provides the value of the
                     <code>standalone</code> parameter to the serialization method. The default
                  value is <code>omit</code>; this means that no <code>standalone</code> attribute
                  is to be included in the XML declaration. </p>
            </item>
            <item diff="add" at="A">
               <p> The <code>suppress-indentation</code> attribute is a whitespace-separated list of
                  QNames. The default value is an empty list. After expansion of these names using
                  the in-scope namespace declarations for the <elcode>xsl:output</elcode>
                  declaration in which they appear, this list of names provides the value of the
                     <code>suppress-indentation</code> parameter to the serialization method. In the
                  case of an unprefixed name, the default namespace (that is, the namespace declared
                  using <code>xmlns="uri"</code>) is used. </p>
               <note>
                  <p>This differs from the rule for most other QNames used in a stylesheet. The
                     reason is that these names refer to elements in the result document, and
                     therefore follow the same convention as the name of a literal result element or
                     the <code>name</code> attribute of <elcode>xsl:element</elcode>.</p>
               </note>
            </item>
            <item>
               <p>The <code>undeclare-prefixes</code> attribute is relevant only when producing
                  output with <code>method="xml"</code> and <code>version="1.1"</code> (or later).
                  It defines whether namespace undeclarations (of the form
                  <code>xmlns:foo=""</code>) <rfc2119>should</rfc2119> be output when a child
                  element has no namespace node with the same name (that is, namespace prefix) as a
                  namespace node of its parent element. The default value is <code>no</code>: this
                  means that namespace undeclarations are not output, which has the effect that when
                  the resulting XML is reparsed, the new tree may contain namespace nodes on the
                  child element that were not there in the original tree before serialization.</p>
            </item>
            <item>
               <p>The <code>use-character-maps</code> attribute provides a list of named character
                  maps that are used in conjunction with this <termref def="dt-output-definition">output definition</termref>. The way this attribute is used is described in
                     <specref ref="character-maps"/>. The default value is an empty list.</p>
            </item>
            <item>
               <p> The value of the <code>version</code> attribute provides the value of the
                     <code>version</code> parameter to the serialization method. The set of
                  permitted values, and the default value, are <termref def="dt-implementation-defined">implementation-defined</termref>. A <termref def="dt-serialization-error">serialization error</termref> will be reported if
                  the requested version is not supported by the implementation.
                  <!--The default value depends on the output method: it is <code>1.0</code> for <code>xml</code>,
						<code>4.01</code> for <code>html</code>, and <code>1.0</code> for <code>xhtml</code>. The 
						parameter is not used by the text output method.-->
               </p>
            </item>
         </ulist>
         <imp-def-feature>It is implementation-defined which versions of XML, HTML, and XHTML are
            supported in the <code>version</code> attribute of the <elcode>xsl:output</elcode>
            declaration.</imp-def-feature>
         <imp-def-feature>The default value of the <code>byte-order-mark</code> serialization
            parameter is implementation-defined in the case of UTF-8 encoding.</imp-def-feature>
         <p>If the processor performs serialization, then it must signal any non-recoverable
            serialization errors that occur. These have the same effect as <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic errors</termref>: that is, the
            processor must signal the error and must not finish as if the transformation had been
            successful.</p>
         <div2 id="character-maps">
            <head>Character Maps</head>
            <p>
               <termdef id="dt-character-map" term="character map">A <term>character map</term>
                  allows a specific character appearing in a text or attribute node in the <termref def="dt-final-result-tree">final result tree</termref> to be substituted by a
                  specified string of characters during serialization.</termdef> The effect of
               character maps is defined in <bibref ref="xslt-xquery-serialization-11"/>.</p>
            <p>The character map that is supplied as a parameter to the serializer is determined
               from the <elcode>xsl:character-map</elcode> elements referenced from the
                  <elcode>xsl:output</elcode> declaration for the selected <termref def="dt-output-definition">output definition</termref>.</p>
            <p>The <elcode>xsl:character-map</elcode> element is a declaration that may appear as a
               child of the <elcode>xsl:stylesheet</elcode> element.</p>
            <e:element-syntax name="character-map">
               <e:in-category name="declaration"/>
               <e:attribute name="name" required="yes">
                  <e:data-type name="qname"/>
               </e:attribute>
               <e:attribute name="use-character-maps">
                  <e:data-type name="qnames"/>
               </e:attribute>
               <e:sequence>
                  <e:element repeat="zero-or-more" name="output-character"/>
               </e:sequence>
               <e:allowed-parents>
                  <e:parent name="stylesheet"/>
                  <e:parent name="transform"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The <elcode>xsl:character-map</elcode> declaration declares a character map with a
               name and a set of character mappings. The character mappings are specified by means
               of <elcode>xsl:output-character</elcode> elements contained either directly within
               the <elcode>xsl:character-map</elcode> element, or in further character maps
               referenced in the <code>use-character-maps</code> attribute.</p>
            <p>The <rfc2119>required</rfc2119>
               <code>name</code> attribute provides a name for the character map. When a character
               map is used by an <termref def="dt-output-definition">output definition</termref> or
               another character map, the character map with the highest <termref def="dt-import-precedence">import precedence</termref> is used.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="1580">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the <termref def="dt-stylesheet">stylesheet</termref> contains two or more character maps
                     with the same name and the same <termref def="dt-import-precedence">import
                        precedence</termref>, unless it also contains another character map with the
                     same name and higher import precedence.</p>
               </error>
            </p>
            <p>The optional <code>use-character-maps</code> attribute lists the names of further
               character maps that are included into this character map.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="1590">
                  <p>It is a <termref def="dt-static-error">static error</termref> if a name in the
                        <code>use-character-maps</code> attribute of the <elcode>xsl:output</elcode>
                     or <elcode>xsl:character-map</elcode> elements does not match the
                        <code>name</code> attribute of any <elcode>xsl:character-map</elcode> in the
                        <termref def="dt-stylesheet">stylesheet</termref>.</p>
               </error>
            </p>
            <p>
               <error spec="XT" type="static" class="SE" code="1600">
                  <p>It is a <termref def="dt-static-error">static error</termref> if a character
                     map references itself, directly or indirectly, via a name in the
                        <code>use-character-maps</code> attribute.</p>
               </error>
            </p>
            <p>It is not an error if the same character map is referenced more than once, directly
               or indirectly.</p>
            <p>An <termref def="dt-output-definition">output definition</termref>, after recursive
               expansion of character maps referenced via its <code>use-character-maps</code>
               attribute, may contain several mappings for the same character. In this situation,
               the last character mapping takes precedence. To establish the ordering, the following
               rules are used:</p>
            <ulist>
               <item>
                  <p>Within a single <elcode>xsl:character-map</elcode> element, the characters
                     defined in character maps referenced in the <code>use-character-maps</code>
                     attribute are considered before the characters defined in the child
                        <elcode>xsl:output-character</elcode> elements.</p>
               </item>
               <item>
                  <p>The character maps referenced in a single <code>use-character-maps</code>
                     attribute are considered in the order in which they are listed in that
                     attribute. The expansion is depth-first: each referenced character map is fully
                     expanded before the next one is considered.</p>
               </item>
               <item>
                  <p>Two <elcode>xsl:output-character</elcode> elements appearing as children of the
                     same <elcode>xsl:character-map</elcode> element are considered in document
                     order.</p>
               </item>
            </ulist>
            <p>The <elcode>xsl:output-character</elcode> element is defined as follows:</p>
            <e:element-syntax name="output-character">
               <e:attribute name="character" required="yes">
                  <e:data-type name="char"/>
               </e:attribute>
               <e:attribute name="string" required="yes">
                  <e:data-type name="string"/>
               </e:attribute>
               <e:empty/>
               <e:allowed-parents>
                  <e:parent name="character-map"/>
               </e:allowed-parents>
            </e:element-syntax>
            <p>The character map that is passed as a parameter to the serializer contains a mapping
               for the character specified in the <code>character</code> attribute to the string
               specified in the <code>string</code> attribute. </p>
            <p>Character mapping is not applied to characters for which output escaping has been
               disabled as described in <specref ref="disable-output-escaping"/>.</p>
            <p>If a character is mapped, then it is not subjected to XML or HTML escaping.</p>
            <example>
               <head>Using Character Maps to Generate Non-XML Output</head>
               <p>Character maps can be useful when producing serialized output in a format that
                  resembles, but is not strictly conformant to, HTML or XML. For example, when the
                  output is a JSP page, there might be a need to generate the output:</p>
               <eg xml:space="preserve">&lt;jsp:setProperty name="user" property="id" value='&lt;%= "id" + idValue %&gt;'/&gt;</eg>
               <p>Although this output is not well-formed XML or HTML, it is valid in Java Server
                  Pages. This can be achieved by allocating three Unicode characters (which are not
                  needed for any other purpose) to represent the strings <code>&lt;%</code>,
                     <code>%&gt;</code>, and <code>"</code>, for example:</p>
               <eg xml:space="preserve">&lt;xsl:character-map name="jsp"&gt;
  &lt;xsl:output-character character="" string="&amp;lt;%"/&gt;   
  &lt;xsl:output-character character="" string="%&amp;gt;"/&gt;
  &lt;xsl:output-character character="" string='"'/&gt;
&lt;/xsl:character-map&gt;</eg>
               <p>When this character map is referenced in the <elcode>xsl:output</elcode>
                  declaration, the required output can be produced by writing the following in the
                  stylesheet:</p>
               <eg xml:space="preserve">&lt;jsp:setProperty name="user" property="id" value='= id + idValue '/&gt;</eg>
               <p>This works on the assumption that when an apostrophe or quotation mark is
                  generated as part of an attribute value by the use of character maps, the
                  serializer will (where possible) use the other choice of delimiter around the
                  attribute value.</p>
            </example>
            <example>
               <head>Constructing a Composite Character Map</head>
               <p>The following example illustrates a composite character map constructed in a
                  modular fashion:</p>
               <eg xml:space="preserve">
&lt;xsl:output name="htmlDoc" use-character-maps="htmlDoc" /&gt;

&lt;xsl:character-map name="htmlDoc"
  use-character-maps="html-chars doc-entities windows-format" /&gt;
  
&lt;xsl:character-map name="html-chars"
  use-character-maps="latin1 ..." /&gt;

&lt;xsl:character-map name="latin1"&gt;
  &lt;xsl:output-character character="&amp;#160;" string="&amp;amp;nbsp;" /&gt;
  &lt;xsl:output-character character="&amp;#161;" string="&amp;amp;iexcl;" /&gt;
  ...
&lt;/xsl:character-map&gt;

&lt;xsl:character-map name="doc-entities"&gt;
  &lt;xsl:output-character character="&amp;#xE400;" string="&amp;amp;t-and-c;" /&gt;
  &lt;xsl:output-character character="&amp;#xE401;" string="&amp;amp;chap1;" /&gt;
  &lt;xsl:output-character character="&amp;#xE402;" string="&amp;amp;chap2;" /&gt;
  ...
&lt;/xsl:character-map&gt;

&lt;xsl:character-map name="windows-format"&gt;
  &lt;!-- newlines as CRLF --&gt;
  &lt;xsl:output-character character="&amp;#xA;" string="&amp;#xD;&amp;#xA;" /&gt;

  &lt;!-- tabs as three spaces --&gt;
  &lt;xsl:output-character character="&amp;#x9;" string="   " /&gt;

  &lt;!-- images for special characters --&gt;
  &lt;xsl:output-character character="&amp;#xF001;"
    string="&amp;lt;img src='special1.gif' /&amp;gt;" /&gt;
  &lt;xsl:output-character character="&amp;#xF002;"
    string="&amp;lt;img src='special2.gif' /&amp;gt;" /&gt;
  ...
&lt;/xsl:character-map&gt;</eg>
            </example>
         </div2>
         <div2 id="disable-output-escaping">
            <head>Disabling Output Escaping</head>
            <p>Normally, when using the XML, HTML, or XHTML output method, the serializer will
               escape special characters such as <code>&amp;</code> and <code>&lt;</code> when
               outputting text nodes. This ensures that the output is well-formed. However, it is
               sometimes convenient to be able to produce output that is almost, but not quite
               well-formed XML; for example, the output may include ill-formed sections which are
               intended to be transformed into well-formed XML by a subsequent non-XML-aware
               process. For this reason, XSLT defines a mechanism for disabling output escaping.</p>
            <p>This feature is <termref def="dt-deprecated">deprecated</termref>.</p>
            <p>This is an optional feature: it is not <rfc2119>required</rfc2119> that a XSLT
               processor that implements the serialization option <rfc2119>should</rfc2119> offer
               the ability to disable output escaping, and there is no conformance level that
               requires this feature.</p>
            <p>This feature requires an extension to the serializer described in <bibref ref="xslt-xquery-serialization-11"/>. Conceptually, the <termref def="dt-final-result-tree">final result tree</termref> provides an additional
               boolean property <code>disable-escaping</code> associated with every character in a
               text node. When this property is set, the normal action of the serializer to escape
               special characters such as <code>&amp;</code> and <code>&lt;</code> is
               suppressed.</p>
            <p>An <elcode>xsl:value-of</elcode> or <elcode>xsl:text</elcode> element may have a
                  <code>disable-output-escaping</code> attribute; the allowed values are
                  <code>yes</code> or <code>no</code>. The default is <code>no</code>; if the value
               is <code>yes</code>, then every character in the text node generated by evaluating
               the <elcode>xsl:value-of</elcode> or <elcode>xsl:text</elcode> element
                  <rfc2119>should</rfc2119> have the <code>disable-output</code> property set.</p>
            <example>
               <head>Disable Output Escaping</head>
               <p>For example,</p>
               <eg xml:space="preserve">&lt;xsl:text disable-output-escaping="yes"&gt;&amp;lt;&lt;/xsl:text&gt;</eg>
               <p>should generate the single character <code>&lt;</code>.</p>
            </example>
            <p>If output escaping is disabled for an <elcode>xsl:value-of</elcode> or
                  <elcode>xsl:text</elcode> instruction evaluated when <termref def="dt-temporary-output-state">temporary output state</termref> is in effect, the
               request to disable output escaping is ignored.</p>
            <p>If output escaping is disabled for text within an element that would normally be
               output using a CDATA section, because the element is listed in the
                  <code>cdata-section-elements</code>, then the relevant text will not be included
               in a CDATA section. In effect, CDATA is treated as an alternative escaping mechanism,
               which is disabled by the <code>disable-output-escaping</code> option.</p>
            <example>
               <head>Interaction of Output Escaping and CDATA</head>
               <p>For example, if <code>&lt;xsl:output cdata-section-elements="title"/&gt;</code> is
                  specified, then the following instructions:</p>
               <eg xml:space="preserve">&lt;title&gt;
  &lt;xsl:text disable-output-escaping="yes"&gt;This is not &amp;lt;hr/&amp;gt; 
                                          good coding practice&lt;/xsl:text&gt;
&lt;/title&gt;</eg>
               <p>should generate the output:</p>
               <eg xml:space="preserve">&lt;title&gt;&lt;![CDATA[This is not ]]&gt;&lt;hr/&gt;&lt;![CDATA[ good coding practice]]&gt;&lt;/title&gt;</eg>
            </example>
            <p>The <code>disable-output-escaping</code> attribute may be used with the
                  <code>html</code> output method as well as with the <code>xml</code> output
               method. The <code>text</code> output method ignores the
                  <code>disable-output-escaping</code> attribute, since it does not perform any
               output escaping.</p>
            <p>A <termref def="dt-processor">processor</termref> will only be able to disable output
               escaping if it controls how the <termref def="dt-final-result-tree">final result
                  tree</termref> is output. This might not always be the case. For example, the
               result tree might be used as a <termref def="dt-source-tree">source tree</termref>
               for another XSLT transformation instead of being output. It is <termref def="dt-implementation-defined">implementation-defined</termref> whether (and
               under what circumstances) disabling output escaping is supported.</p>
            <p>
               <error spec="XT" type="dynamic" class="RE" code="1620">
                  <p>It is a <termref def="dt-recoverable-error">recoverable dynamic error</termref>
                     if an <elcode>xsl:value-of</elcode> or <elcode>xsl:text</elcode> instruction
                     specifies that output escaping is to be disabled and the implementation does
                     not support this. <error.action>The <termref def="dt-optional-recovery-action">optional recovery action</termref> is to ignore the
                           <code>disable-output-escaping</code> attribute.</error.action>
                  </p>
               </error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="RE" code="1630">
                  <p>It is a <termref def="dt-recoverable-error">recoverable dynamic error</termref>
                     if an <elcode>xsl:value-of</elcode> or <elcode>xsl:text</elcode> instruction
                     specifies that output escaping is to be disabled when writing to a <termref def="dt-final-result-tree">final result tree</termref> that is not being
                     serialized. <error.action>The <termref def="dt-optional-recovery-action">optional recovery action</termref> is to ignore the
                           <code>disable-output-escaping</code> attribute.</error.action>
                  </p>
               </error>
            </p>
            <imp-def-feature>It is implementation-defined whether, and under what circumstances,
               disabling output escaping is supported.</imp-def-feature>
            <p>If output escaping is disabled for a character that is not representable in the
               encoding that the <termref def="dt-processor">processor</termref> is using for
               output, the request to disable output escaping is ignored in respect of that
               character.</p>
            <p>Since disabling output escaping might not work with all implementations and can
               result in XML that is not well-formed, it <rfc2119>should</rfc2119> be used only when
               there is no alternative.</p>
            <note>
               <p>The facility to define character maps for use during serialization, as described
                  in <specref ref="character-maps"/>, has been produced as an alternative mechanism
                  that can be used in many situations where disabling of output escaping was
                  previously necessary, without the same difficulties.</p>
            </note>
         </div2>
      </div1>
      <div1 id="conformance">
         <head>Conformance</head>
         <p>A <termref def="dt-processor">processor</termref> that claims conformance with this
            specification <rfc2119>must</rfc2119> claim conformance either as a <termref def="dt-basic-xslt-processor">basic XSLT processor</termref> or as a <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT processor</termref>. The rules
            for these two conformance levels are defined in the following sections.</p>
         <p>A processor that claims conformance at either of these two levels <rfc2119>may</rfc2119>
            additionally claim conformance with either or both of the following optional features:
            the serialization feature, defined in <specref ref="serialization-feature"/>, and the
            backwards compatibility feature, defined in <specref ref="backwards-compatibility-feature"/>.</p>
         <note>
            <p>There is no conformance level or feature defined in this specification that requires
               implementation of the static typing features described in <bibref ref="xpath-21"/>.
               An XSLT processor may provide a user option to invoke static typing, but to be
               conformant with this specification it must allow a stylesheet to be processed with
               static typing disabled. The interaction of XSLT stylesheets with the static typing
               feature of <phrase diff="chg" at="F">XPath 2.1</phrase> has not been specified, so the results of using static typing,
               if available, are implementation-defined.</p>
         </note>
         <p>An XSLT processor takes as its inputs a stylesheet and one or more XDM trees conforming
            to the data model defined in <bibref ref="xpath-datamodel-11"/>. It is not
               <rfc2119>required</rfc2119> that the processor supports any particular method of
            constructing XDM trees, but conformance can only be tested if it provides a mechanism
            that enables XDM trees representing the stylesheet and primary source document to be
            constructed and supplied as input to the processor.</p>
         <p>The output of the XSLT processor consists of zero or more <termref def="dt-final-result-tree">final result trees</termref>. It is not
               <rfc2119>required</rfc2119> that the processor supports any particular method of
            accessing a final result tree, but if it does not support the serialization module,
            conformance can only be tested if it provides some alternative mechanism that enables
            access to the results of the transformation.</p>
         <p>Certain facilities in this specification are described as producing <termref def="dt-implementation-defined">implementation-defined</termref> results. A claim
            that asserts conformance with this specification <rfc2119>must</rfc2119> be accompanied
            by documentation stating the effect of each implementation-defined feature. For
            convenience, a non-normative checklist of implementation-defined features is provided at
               <specref ref="implementation-defined-features"/>.</p>
         <p>A conforming <termref def="dt-processor">processor</termref>
            <rfc2119>must</rfc2119> signal any <termref def="dt-static-error">static error</termref>
            occurring in the stylesheet, or in any XPath <termref def="dt-expression">expression</termref>, except where specified otherwise either for individual error
            conditions or under the general provisions for <termref def="dt-forwards-compatible-behavior"/> (see
               <specref ref="forwards"/>). After signaling such an error, the processor
               <rfc2119>may</rfc2119> continue for the purpose of signaling additional errors, but
               <rfc2119>must</rfc2119> terminate abnormally without performing any
            transformation.</p>
         <p>When a <termref def="dt-dynamic-error">dynamic error</termref> occurs during the course
            of a transformation, the action depends on whether the error is classified as a <termref def="dt-recoverable-error">recoverable error</termref>. If a non-recoverable error
            occurs, the processor <rfc2119>must</rfc2119> signal it and <rfc2119>must</rfc2119>
            eventually terminate abnormally. If a recoverable error occurs, the processor
               <rfc2119>must</rfc2119> either signal it and terminate abnormally, or it
               <rfc2119>must</rfc2119> take the defined recovery action and continue processing.</p>
         <p>Some errors, notably <termref def="dt-type-error">type errors</termref>,
               <rfc2119>may</rfc2119> be treated as <termref def="dt-static-error">static
               errors</termref> or <termref def="dt-dynamic-error">dynamic errors</termref> at the
            discretion of the processor.</p>
         <p>A conforming processor <rfc2119>may</rfc2119> impose limits on the processing resources
            consumed by the processing of a stylesheet.</p>


         <div2 id="basic-conformance">
            <head>Basic XSLT Processor</head>
            <p>
               <termdef id="dt-basic-xslt-processor" term="basic XSLT processor">A <term>basic XSLT
                     processor</term> is an XSLT processor that implements all the mandatory
                  requirements of this specification with the exception of certain explicitly
                  identified constructs related to schema processing.</termdef> These constructs are
               listed below.</p>
            <p>The mandatory requirements of this specification are taken to include the mandatory
               requirements of <phrase diff="chg" at="F">XPath 2.1</phrase>, as described in <bibref ref="xpath-21"/>. A requirement is
               mandatory unless the specification includes wording (such as the use of the words
                  <rfc2119>should</rfc2119> or <rfc2119>may</rfc2119>) that clearly indicates that
               it is optional.</p>
            <p>A <termref def="dt-basic-xslt-processor">basic XSLT processor</termref> 
               <rfc2119>must</rfc2119> enforce the following restrictions. It
                  <rfc2119>must</rfc2119> signal a static or dynamic error when the restriction is
               violated, as described below.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="1650">
                  <p>A <termref def="dt-basic-xslt-processor">basic XSLT processor</termref>
                     <rfc2119>must</rfc2119> signal a <termref def="dt-static-error">static
                        error</termref> if the <termref def="dt-stylesheet">stylesheet</termref>
                     includes an <elcode>xsl:import-schema</elcode> declaration.</p>
               </error>
            </p>
            <note>
               <p>A processor that rejects an <elcode>xsl:import-schema</elcode> declaration will
                  also reject any reference to a user-defined type defined in a schema, or to a
                  user-defined element or attribute declaration; it will not, however, reject
                  references to the built-in types listed in <specref ref="built-in-types"/>.</p>
            </note>
            <p diff="add" at="B">A <termref def="dt-basic-xslt-processor">basic XSLT
                  processor</termref> is not able to validate input documents, and is not able to
               handle input documents containing type annotations other than <code>xs:untyped</code>
               or <code>xs:untypedAtomic</code>. Therefore, such a processor <rfc2119>must</rfc2119>
               treat any <code>[xsl:]validation</code> or <code>default-validation</code> attribute
               with a value of <code>preserve</code> or <code>lax</code> as if the value were
                  <code>strip</code>.</p>

            <note diff="add" at="B">
               <p>The values <code>lax</code> and <code>preserve</code> indicate that the validation
                  to be applied depends on the calling application, so it is appropriate for the
                  request to be treated differently by different kinds of processor. By contrast,
                  requesting <code>strict</code> validation, either through the
                     <code>[xsl:]validation</code> attribute or the <code>type</code> attribute,
                  indicates that the stylesheet is expecting to deal with typed data, and therefore
                  cannot be processed without performing the validation.</p>
            </note>
            <p>
               <error spec="XT" type="static" class="SE" code="1660">
                  <p>A <termref def="dt-basic-xslt-processor">basic XSLT processor</termref>
                     <rfc2119>must</rfc2119> signal a <termref def="dt-static-error">static
                        error</termref> if the <termref def="dt-stylesheet">stylesheet</termref>
                     includes an <code>[xsl:]type</code> attribute, or an
                        <code>[xsl:]validation</code> or <code>default-validation</code> attribute
                     with a value other than <code>strip</code><phrase diff="add" at="B">,
                           <code>preserve</code>, or <code>lax</code></phrase>.</p>
               </error>
            </p>
            <p>A <termref def="dt-basic-xslt-processor">basic XSLT processor</termref> constrains
               the data model as follows:</p>
            <ulist>
               <item>
                  <p>Atomic values <rfc2119>must</rfc2119> belong to one of the atomic types listed
                     in <specref ref="built-in-types"/> (except as noted below).</p>
                  <p>An atomic value may also belong to an implementation-defined type that has been
                     added to the context for use with <termref def="dt-extension-function">extension functions</termref> or <termref def="dt-extension-instruction">extension instructions</termref>.</p>
                  <p>The set of constructor functions available are limited to those that construct
                     values of the above atomic types.</p>
                  <p>The static context, which defines the full set of type names recognized by an
                     XSLT processor and also by the XPath processor, includes these atomic types,
                     plus <code>xs:anyType</code>, <code>xs:anySimpleType</code>,
                        <code>xs:untyped</code>, and <code>xs:anyAtomicType</code>.</p>
               </item>
               <item>
                  <p>Element nodes <rfc2119>must</rfc2119> be annotated with the <termref def="dt-annotation">type annotation</termref>
                     <code>xs:untyped</code>, and attribute nodes with the type annotation
                        <code>xs:untypedAtomic</code>.</p>
               </item>
            </ulist>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="1665">
                  <p>A <termref def="dt-basic-xslt-processor">basic XSLT processor</termref>
                     <rfc2119>must</rfc2119> raise a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if the input to the processor
                     includes a node with a <termref def="dt-annotation">type annotation</termref>
                     other than <code>xs:untyped</code> or <code>xs:untypedAtomic</code>, or an
                     atomic value of a type other than those which a basic XSLT processor
                     supports.</p>
               </error> This error will not arise if the <code>input-type-annotations</code>
               attribute is set to <code>strip</code>.</p>
            <note>
               <p>Although this is expressed in terms of a requirement to detect invalid input, an
                  alternative approach is for a basic XSLT processor to prevent this error condition
                  occurring, by not providing any interfaces that would allow the situation to
                  arise. A processor might, for example, implement a mapping from the PSVI to the
                  data model that loses all non-trivial <termref def="dt-annotation">type
                     annotations</termref>; or it might not accept input from a PSVI at all.</p>
               <p>The phrase <emph>input to the processor</emph> is deliberately wide: it includes
                  the tree containing the <phrase diff="chg" at="E"><termref def="dt-initial-context-item"/></phrase>, trees passed as <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>, trees accessed
                  using the <function>document</function>, <xfunction>doc</xfunction>, and
                     <xfunction>collection</xfunction> functions, and trees returned by <termref def="dt-extension-function">extension functions</termref> and <termref def="dt-extension-instruction">extension instructions</termref>.</p>
            </note>
         </div2>
         <div2 id="schema-aware-conformance">
            <head>Schema-Aware XSLT Processor</head>
            <p>
               <termdef id="dt-schema-aware-xslt-processor" term="schema-aware XSLT processor">A
                     <term>schema-aware XSLT processor</term> is an XSLT processor that implements
                  all the mandatory requirements of this specification, including those features
                  that a <termref def="dt-basic-xslt-processor">basic XSLT processor</termref>
                  signals as an error. The mandatory requirements of this specification are taken to
                  include the mandatory requirements of <phrase diff="chg" at="F">XPath 2.1</phrase>, as described in <bibref ref="xpath-21"/>. A requirement is mandatory unless the specification includes
                  wording (such as the use of the words <rfc2119>should</rfc2119> or
                     <rfc2119>may</rfc2119>) that clearly indicates that it is optional.</termdef>
            </p>
         </div2>
         <div2 id="serialization-feature">
            <head>Serialization Feature</head>
            <p>
               <termdef id="dt-serialization-feature" term="serialization feature">A processor that
                  claims conformance with the <term>serialization feature</term>
                  <rfc2119>must</rfc2119> support the conversion of a <termref def="dt-final-result-tree">final result tree</termref> to a sequence of octets
                  following the rules defined in <specref ref="serialization"/>.</termdef> It
                  <rfc2119>must</rfc2119> respect all the attributes of the
                  <elcode>xsl:output</elcode> and <elcode>xsl:character-map</elcode> declarations,
               and <rfc2119>must</rfc2119> provide all four output methods, <code>xml</code>,
                  <code>xhtml</code>, <code>html</code>, and <code>text</code>. Where the
               specification uses words such as <rfc2119>must</rfc2119> and
                  <rfc2119>required</rfc2119>, then it <rfc2119>must</rfc2119> serialize the result
               tree in precisely the way described; in other cases it <rfc2119>may</rfc2119> use an
               alternative, equivalent representation.</p>
            <p>A processor may claim conformance with the serialization feature whether or not it
               supports the setting <code>disable-output-escaping="yes"</code> on
                  <elcode>xsl:text</elcode>, or <elcode>xsl:value-of</elcode>. </p>
            <p>A processor that does not claim conformance with the serialization feature
                  <rfc2119>must not</rfc2119> signal an error merely because the <termref def="dt-stylesheet">stylesheet</termref> contains <elcode>xsl:output</elcode> or
                  <elcode>xsl:character-map</elcode> declarations, or serialization attributes on
               the <elcode>xsl:result-document</elcode> instruction. Such a processor
                  <rfc2119>may</rfc2119> check that these declarations and attributes have valid
               values, but is not <rfc2119>required</rfc2119> to do so. Apart from optional
               validation, these declarations <rfc2119>should</rfc2119> be ignored.</p>
         </div2>
         <div2 id="backwards-compatibility-feature">
            <head>Compatibility Features</head>
            <p>
               <termdef id="dt-1.0-compatibility-feature" term="XSLT 1.0 compatibility feature">A
                  processor that claims conformance with the <term>XSLT 1.0 compatibility
                     feature</term>
                  <rfc2119>must</rfc2119> support the processing of stylesheet instructions and
                  XPath expressions with <termref def="dt-xslt-10-behavior" diff="chg" at="D">XSLT
                     1.0 behavior</termref>, as defined in <specref ref="backwards"/>.</termdef>
            </p>
            <p>
               <termdef id="dt-2.0-compatibility-feature" term="XSLT 2.0 compatibility feature">A
                  processor that claims conformance with the <term>XSLT 2.0 compatibility
                     feature</term>
                  <rfc2119>must</rfc2119> support the processing of stylesheet instructions and
                  XPath expressions with <termref def="dt-xslt-20-behavior" diff="chg" at="D">XSLT
                     2.0 behavior</termref>, as defined in <specref ref="backwards"/>.</termdef>
            </p>
            <p>Note that a processor that does not claim conformance with the <termref def="dt-1.0-compatibility-feature"/>
               <rfc2119>must</rfc2119> raise a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if an instruction is evaluated whose
                  <termref def="dt-effective-version"/> is 1.0; and similarly, a processor that does
               not claim conformance with the <termref def="dt-2.0-compatibility-feature"/>
               <rfc2119>must</rfc2119> raise a <termref def="dt-nonrec-dynamic-error">non-recoverable dynamic error</termref> if an instruction is evaluated whose
                  <termref def="dt-effective-version"/> is 2.0. <errorref spec="XT" class="DE" code="0160"/>.</p>
            <note>
               <p>The reason this is a dynamic error rather than a static error is to allow
                  stylesheets to contain conditional logic, following different paths depending on
                  whether the XSLT processor implements <phrase diff="chg" at="D">XSLT 1.0, 2.0, or
                     2.1</phrase>. The selection of which path to use can be controlled by using the
                     <function>system-property</function> function to test the
                     <code>xsl:version</code> system property.</p>
            </note>
            <p>A processor that claims conformance with the <termref def="dt-1.0-compatibility-feature"/>
               <rfc2119>must</rfc2119> permit the use of the namespace axis in XPath expressions
               when backwards compatible behavior is enabled. In all other circumstances, support
               for the namespace axis is optional.</p>
            <note>
               <p>Currently, there are no incompatibilities between 2.1 and 2.0 that justify this
                  machinery. This will be reviewed at a later stage of development of the
                  specification.</p>
            </note>
         </div2>
         <div2 id="streaming-feature" diff="add" at="E">
            <head>Streaming Feature</head>
            <p>
               <termdef id="dt-streaming-feature" term="streaming feature">A processor that claims
                  conformance with the <term>streaming feature</term>
                  <rfc2119>must</rfc2119> ....</termdef>
               <issue id="issue-streaming-conformance" status="open">
                  <p>We need to define the conformance rules for streaming processors.</p>
               </issue>
            </p>
         </div2>
      </div1>
   </body>
   <back>
      <div1 id="references">
         <head>References</head>
         <div2 id="normative-references">
            <head>Normative References</head>
            <blist>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-datamodel-11" key="Data Model" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-functions-11" key="Functions and Operators" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               <!--World Wide Web Consortium. 
<emph>XQuery 1.0 and XPath 2.0 Functions and Operators.</emph>
W3C Working Draft. 
See <loc href="http://www.w3.org/TR/xpath-functions/"/>
					</bibl>-->
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xml-infoset" key="XML Information Set" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               <!--World Wide Web Consortium. 
					<emph>XML Information Set.</emph> W3C Recommendation. 
					See <loc href="http://www.w3.org/TR/xml-infoset/"/>
                    </bibl>-->
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="ISO3166" key="ISO 3166-1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ISO (International Organization for
                  Standardization) <emph>Codes for the representation of names of countries and
                  their subdivisions - Part 1: Country codes</emph> ISO 3166-1:1997. 
                  Second edition, 2006-11-20. </bibl>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="ISO8601" key="ISO 8601" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ISO (International Organization for
                  Standardization) <emph>Data elements and interchange formats - Information
                     interchange - Representation of dates and times.</emph> ISO 8601:2004,
                  Third edition, 2004-12-03. </bibl>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xslt-xquery-serialization-11" key="XSLT and XQuery Serialization" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               <!--<bibl id="UNICODE-NORMALIZATION" key="Unicode Normalization">Unicode Consortium.
					<emph>Unicode Normalization Forms</emph>. Unicode Standard Annex #15.
					See <loc href="http://www.unicode.org/unicode/reports/tr15/"/>
					</bibl>-->
               <!--					<bibl id="XHTML10" key="XHTML 1.0">World Wide Web Consortium. <emph>XHTML
1.0: The Extensible HyperText Markup Language.</emph> W3C Recommendation. 
See <loc href="http://www.w3.org/TR/xhtml1/"/>. Note: a second edition of this
specification is in preparation.</bibl>-->
               <!--					<bibl id="XHTML11" key="XHTML 1.1">World Wide Web Consortium. <emph>XHTML
1.1: Module-Based XHTML.</emph> W3C Recommendation. 
See <loc href="http://www.w3.org/TR/xhtml11/"/>
</bibl>-->
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="REC-xml" key="XML 1.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"> World Wide Web Consortium. <emph>Extensible Markup Language (XML)
                     1.0. W3C Recommendation.</emph> See <loc href="http://www.w3.org/TR/REC-xml" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/REC-xml</loc>.
                  The edition of XML 1.0 must be no earlier than the Third Edition; 
                  the edition used is <termref def="dt-implementation-defined"/>, 
                  but we recommend that implementations use the latest version.
               </bibl>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xml11" key="XML 1.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               <!--<bibl id="xml11" key="Extensible Markup Language (XML) 1.1 Recommendation"> World
                  Wide Web Consortium. <emph>Extensible Markup Language (XML) 1.1.</emph> Available
                  at: <loc href="http://www.w3.org/TR/2004/REC-xml11-20040204/"
                     >http://www.w3.org/TR/2004/REC-xml11-20040204/</loc>
               </bibl>-->
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xmlbase" key="XML Base" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               <!--World Wide Web
Consortium. <emph>XML Base.</emph> W3C Recommendation. See
<loc href="http://www.w3.org/TR/xmlbase/"/>
					</bibl>-->
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xml-id" key="xml:id" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               <!--World Wide Web Consortium. <emph>xml:id 1.0</emph> W3C Proposed Recommendation. 
See <loc href="http://www.w3.org/TR/xml-id/"/>
</bibl>-->
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xml-names" key="Namespaces in XML" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/> 
               <!--World Wide Web
Consortium. <emph>Namespaces in XML.</emph> W3C Recommendation. See
<loc href="http://www.w3.org/TR/REC-xml-names/"/>. 
<emph>This specification carries no version number, but is referenced herein
as</emph> XML Namespaces 1.0<emph>, to avoid confusion with later versions.</emph>
					</bibl>-->
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xml-names11" key="Namespaces in XML 1.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               <!--World Wide Web
Consortium. <emph>Namespaces in XML 1.1.</emph> W3C Recommendation. See
<loc href="http://www.w3.org/TR/xml-names11/"/>
					</bibl>-->
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xmlschema-1" key="XML Schema Part 1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xmlschema-2" key="XML Schema Part 2" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               <!--<bibl id="XMLSCHEMA" key="XML Schema">World Wide Web Consortium. 
<emph>XML Schema Part 1: Structures</emph> and 
and <emph>XML Schema Part 2: Data Types</emph>. W3C Recommendation.
See <loc href="http://www.w3.org/TR/xmlschema-1/"/> and
<loc href="http://www.w3.org/TR/xmlschema-2/"/>
					</bibl>-->
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-21" key="XPath 2.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               <!--World Wide Web Consortium. <emph>XML Path
Language Version 2.0</emph> W3C Working Draft.
See <loc href="http://www.w3.org/TR/xpath20/"/>
</bibl>-->
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XSLT-Mime-Type" key="XSLT Media Type" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium.
                     <emph>Registration of MIME Media Type application/xslt+xml</emph>. In <loc href="http://www.w3.org/TR/2007/REC-xslt20-20070123/#media-type-registration" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Appendix B.1 of the XSLT 2.0 specification.</loc></bibl>
            </blist>
         </div2>
         <div2 id="other-references">
            <head>Other References</head>
            <blist>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="CALCALC" key="Calendrical Calculations" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Edward M. Reingold and Nachum
                  Dershowitz. <emph>Calendrical Calculations Millennium edition (2nd
                  Edition)</emph>. Cambridge University Press, ISBN 0 521 77752 6</bibl>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="DOM-Level-2-Core" key="DOM Level 2" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               <!--World Wide Web Consortium. <emph>Document
Object Model (DOM) Level 2 Core Specification.</emph> W3C Recommendation. 
See <loc href="http://www.w3.org/TR/DOM-Level-2-Core/"/>
					</bibl>-->
               <!--					<bibl id="HTML" key="HTML">World Wide Web Consortium. <emph>HTML 4.01
specification</emph>. W3C Recommendation. 
See <loc href="http://www.w3.org/TR/html4/"/>
					</bibl>-->
               <!--					<bibl id="IANA" key="IANA">Internet Assigned Numbers
Authority. <emph>Character Sets</emph>. 
See <loc href="http://www.iana.org/assignments/character-sets"/>.</bibl>-->
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC2119" key="RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">S. Bradner. <emph>Key words for use in RFCs to
                     Indicate Requirement Levels</emph>. IETF RFC 2119. See <loc href="http://www.ietf.org/rfc/rfc2119.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>.</bibl>
               <!--					<bibl id="RFC2278" key="RFC2278">N. Freed, J. Postel.  <emph>IANA
Charset Registration Procedures</emph>.  IETF RFC 2278. 
See <loc href="http://www.ietf.org/rfc/rfc2278.txt"/>.</bibl>-->
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC2376" key="RFC2376" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">E. Whitehead, M. Murata. <emph>XML Media
                     Types</emph>. IETF RFC 2376. See <loc href="http://www.ietf.org/rfc/rfc2376.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>.</bibl>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC3023" key="RFC3023" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">M. Murata, S. St.Laurent, and D. Cohn. <emph>XML
                     Media Types</emph>. IETF RFC 3023. See <loc href="http://www.ietf.org/rfc/rfc3023.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>. References to RFC 3023 should be
                  taken to refer to any document that supersedes RFC 3023.</bibl>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC3986" key="RFC3986" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"> T. Berners-Lee, R. Fielding, and L. Masinter.
                     <emph>Uniform Resource Identifiers (URI): Generic Syntax</emph>. IETF RFC 3986.
                  See <loc href="http://www.ietf.org/rfc/rfc3986.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>.</bibl>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC3987" key="RFC3987" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">M. Duerst, M. Suignard. <emph>Internationalized
                     Resource Identifiers (IRIs)</emph>. IETF RFC 3987. See <loc href="http://www.ietf.org/rfc/rfc3987.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>.</bibl>

               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="marian-simeon" key="Marian &amp; Simon" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"> Amlie Marian and Jrme Simon.
                     <emph>Projecting XML Documents</emph>. VLDB'2003, Berlin, Germany, September
                  2003. See <loc href="http://portal.acm.org/citation.cfm?id=1315471" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               </bibl>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="STX" key="STX" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Petr Cimprich <emph>et al</emph>, <emph>Streaming
                     Transformations for XML (STX) Version 1.0</emph>. Working Draft 27 April 2007.
                  See <loc href="http://stx.sourceforge.net/documents/spec-stx-20070427.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               </bibl>
               <!--					<bibl id="RFC3236" key="RFC3236">M. Baker, P. Stark. 
<emph>The 'application/xhtml+xml' Media Type</emph>.  IETF RFC 3236. 
See <loc href="http://www.ietf.org/rfc/rfc3236.txt"/>.</bibl>-->
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="UNICODE-TR10" key="UNICODE TR10" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Unicode Consortium. <emph>Unicode
                     Technical Standard #10. Unicode Collation Algorithm</emph>. Unicode Technical
                  Report. See <loc href="http://www.unicode.org/unicode/reports/tr10/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>.</bibl>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xinclude" key="XInclude" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               <!--World Wide Web
Consortium. <emph>XML Inclusions (XInclude) Version 1.0</emph>
W3C Recommendation. 
See <loc href="http://www.w3.org/TR/xinclude/"/></bibl>-->
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xlink" key="XLink" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               <!--World Wide Web
Consortium. <emph>XML Linking Language (XLink) Version 1.0</emph>.
W3C Recommendation. 
See <loc href="http://www.w3.org/TR/xlink/"/></bibl>-->
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="SCHEMA-AND-XML-1.1" key="XML Schema 1.0 and XML 1.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web
                  Consortium. <emph>Processing XML 1.1 documents with XML Schema 1.0
                     processors</emph>. W3C Working Group Note 11 May 2005. See <loc href="http://www.w3.org/TR/2005/NOTE-xml11schema10-20050511/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               </bibl>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xml-stylesheet" key="XML Stylesheet" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               <!--World Wide Web
Consortium. <emph>Associating Style Sheets with XML documents.</emph>
W3C Recommendation. 
See <loc href="http://www.w3.org/TR/xml-stylesheet/"/>
					</bibl>-->
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xptr-framework" key="XPointer Framework" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               <!--World Wide Web Consortium. <emph>XPointer
Framework.</emph> W3C Recommendation, 25 March 2003.
See <loc href="http://www.w3.org/TR/xptr-framework/"/>
					</bibl>-->
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xsl11" key="XSL-FO" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               <!--World Wide Web Consortium.  
<emph>Extensible Stylesheet Language (XSL).</emph>  W3C Recommendation.  
See <loc href="http://www.w3.org/TR/xsl/"/>
					</bibl>-->
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xslt" key="XSLT 1.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               <bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xslt20" key="XSLT 2.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/>
               <!--World Wide Web Consortium. 
<emph>XSL Transformations (XSLT) Version 1.0</emph> W3C Recommendation. 
See <loc href="http://www.w3.org/TR/xslt"/>
					</bibl>-->
               <!--<bibl  id="xslt20req"
                     key="XSLT 2.0 Requirements"
                     
                     
                     />-->
               <!--World Wide Web
Consortium. <emph>XSLT Requirements Version 2.0</emph>
W3C Working Draft. See <loc href="http://www.w3.org/TR/xslt20req"/>
					</bibl>-->
            </blist>
         </div2>
      </div1>
      <inform-div1 id="glossary">
         <head>Glossary</head>
         <?glossary?>
      </inform-div1>
      <inform-div1 id="element-syntax-summary">
         <head>Element Syntax Summary</head>
         <?element-syntax-summary?>
      </inform-div1>
      <inform-div1 id="error-summary">
         <head>Summary of Error Conditions</head>
         <p diff="chg" at="E">This appendix provides a summary of error conditions that a processor
            may signal. This list includes all error codes defined in this specification, but this
            is not an exhaustive list of all errors that can occur. Implementations
               <rfc2119>must</rfc2119> signal errors using these error codes, and applications can
            test for these codes; however, when more than one rule in the specification is violated,
            different processors will not necessarily signal the same error code. Implementations
            are not <rfc2119>required</rfc2119> to signal errors using the descriptive text used
            here.</p>
         <note>
            <p>The appendix is non-normative because the same information is given normatively
               elsewhere.</p>
         </note>
         <?error-summary?>
      </inform-div1>
      <inform-div1 id="implementation-defined-features">
         <head>Checklist of Implementation-Defined Features</head>
         <p>This appendix provides a summary of XSLT language features whose effect is explicitly
               <termref def="dt-implementation-defined">implementation-defined</termref>. The
            conformance rules (see <specref ref="conformance"/>) require vendors to provide
            documentation that explains how these choices have been exercised.</p>

         <?implementation-defined-features?>
      </inform-div1>
      <inform-div1 id="XSLT-defined-functions" diff="add" at="E">
         <head>List of XSLT-defined functions</head>
         <p>This appendix acts as an index of functions defined in this specification, to augment
            the set of functions defined in <bibref ref="xpath-functions-11"/>.</p>
         <?xslt-defined-functions?>
      </inform-div1>
      <inform-div1 id="schema-for-xslt">
         <head>Schema for XSLT Stylesheets</head>
         <issue id="issue-schema-for-xslt21" status="open">
            <p>This schema needs to be updated for XSLT 2.1</p>
         </issue>
         <p>The following schema describes the structure of an XSLT stylesheet module. It does not
            define all the constraints that apply to a stylesheet (for example, it does not attempt
            to define a data type that precisely represents attributes containing XPath <termref def="dt-expression">expressions</termref>). However, every valid stylesheet module
            conforms to this schema, unless it contains elements that invoke <termref def="dt-forwards-compatible-behavior"/>.</p>
         <p>A copy of this schema is available at <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2007/schema-for-xslt20.xsd" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/2007/schema-for-xslt20.xsd</loc>
         </p>
         <!--<?schema-for-xslt?>-->
      </inform-div1>

      <inform-div1 id="acknowledgements">
         <head>Acknowledgements</head>
         <p>This specification was developed and approved for publication by the W3C XSL Working
            Group (WG). WG approval of this specification does not necessarily imply that all WG
            members voted for its approval.</p>
         <p>The chair of the XSL WG is Sharon Adler, IBM. The XSL Working Group includes two
            overlapping teams working on XSLT and XSL Formatting Objects. The members of the XSL WG
            currently engaged in XSLT activities, and their current affiliations, are:</p>

         <glist>
            <gitem>
               <label>Anders Berglund</label>
               <def>
                  <p>Invited expert</p>
               </def>
            </gitem>
            <gitem>
               <label>Oliver Becker</label>
               <def>
                  <p>Invited expert</p>
               </def>
            </gitem>
            <gitem>
               <label>Carine Bournez</label>
               <def>
                  <p>W3C</p>
               </def>
            </gitem>
            <gitem>
               <label>Petr Cimprich</label>
               <def>
                  <p>Invited expert</p>
               </def>
            </gitem>
            <gitem>
               <label>Russell Davoli</label>
               <def>
                  <p>Intel</p>
               </def>
            </gitem>
            <gitem>
               <label>Nikolay Fiykov</label>
               <def>
                  <p>Nokia</p>
               </def>
            </gitem>
            <gitem>
               <label>Florent Georges</label>
               <def>
                  <p>Invited expert</p>
               </def>
            </gitem>
            <gitem>
               <label>Xin (Edward) Jiang</label>
               <def>
                  <p>Invited expert</p>
               </def>
            </gitem>
            <gitem>
               <label>Michael Kay</label>
               <def>
                  <p>Invited expert</p>
               </def>
            </gitem>
            <gitem>
               <label>Jirka Kosek</label>
               <def>
                  <p>Invited expert</p>
               </def>
            </gitem>
            <gitem>
               <label>Dmitriy Shabanov</label>
               <def>
                  <p>Invited expert</p>
               </def>
            </gitem>
            <gitem>
               <label>C. Michael Sperberg-McQueen</label>
               <def>
                  <p>Invited expert</p>
               </def>
            </gitem>
            <gitem>
               <label>Mohamed Zergaoui</label>
               <def>
                  <p>Innovimax</p>
               </def>
            </gitem>
            <gitem>
               <label>Henry Zongaro</label>
               <def>
                  <p>IBM</p>
               </def>
            </gitem>
         </glist>

         <p>The Working Group wishes to acknowledge the pioneering work of the developers of STX
            (see <bibref ref="STX"/>) which has formed an important intellectual input to the design
            of XSLT 2.1 and has demonstrated the feasibility of creating a streaming transformation
            language based on the core XSLT concept of recursive descent of the source tree using
            rule-based templates.</p>
         <p diff="add" at="F">The SVG diagrams in this specification are drawn using <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.graphviz.org/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">GraphViz</loc>
            from AT&amp;T Research, in conjunction with the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.martin-loetzsch.de/DOTML/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">DotML</loc> 
            markup language developed by Martin Loetzsch.
         </p>
      </inform-div1>
      <inform-div1 id="open-issues" diff="add" at="F">
         <head>Summary of Open Issues</head>
         <?summary-of-open-issues?>
      </inform-div1>
      <inform-div1 id="changes-since-2.0" diff="add" at="B">
         <head>Changes since XSLT 2.0</head>
         <olist>
            <item>
               <p>A new <elcode>xsl:iterate</elcode> instruction is added. This allows iterative
                  processing of a sequence, with the ability for the processing of one item to
                  depend on the results of processing of previous items, and with the ability to
                  terminate the iteration before all the items in the sequence have been
                  processed.</p>
            </item>

            <item>
               <p>A new <elcode>xsl:mode</elcode> declaration is added, together with the ability
                  for a stylesheet module to declare a default mode. A mode may be declared to be
                  streamable, and rules are given that constrain what the template rules in a
                  streamable mode can do. A default mode can be declared for a stylesheet module,
                  making it easier to reuse existing stylesheet modules to construct a composite
                  stylesheet. The <elcode>xsl:mode</elcode> declaration may contain an
                     <elcode>xsl:context-item</elcode> element to declare the expected type of the
                     <termref def="dt-initial-context-item"/> when this mode is the <termref def="dt-initial-mode"/>.</p>
            </item>

            <item>
               <p>A new instruction <elcode>xsl:stream</elcode> is provided, to read and process an
                  input document using streaming</p>
            </item>
            <item>
               <p>A new instruction <elcode>xsl:merge</elcode> is provided. This allows several
                  input sequences to be merged into a single output sequence, based on the value of
                  a merge key.</p>
            </item>

            <item>
               <p>A new function <function>unparsed-text-lines</function> is provided. This is
                  similar to the <function>unparsed-text</function> function, but delivers the
                  result as a sequence of strings, rather than as a single string.</p>
            </item>

            <item>
               <p>New functions <function>innermost</function> and <function>outermost</function>
                  are provided. Where elements are recursively nested, these provide a simple way to
                  identify those nodes within a set of nodes that (a) have no descendants within the
                  set, or (b) have no ancestors. The intention of these functions is to make
                  streaming of documents easier when they contain recursive structures.</p>
            </item>

            <item>
               <p>New functions <function>copy-of</function> and <function>snapshot</function> are
                  provided, to enable streaming applications to operate in "windowing" mode, where
                  the input document is divided into a sequence of small subtrees processed one at a
                  time.</p>
            </item>

            <item>
               <p>A new <elcode>xsl:try</elcode> instruction is provided, to allow recovery from
                  dynamic errors.</p>
            </item>

            <item>
               <p>A new <elcode>xsl:evaluate</elcode> instruction is provided, to allow evaluation
                  of XPath expressions constructed dynamically from strings, or read from a source
                  document.</p>
            </item>

            <item>
               <p>A new <elcode>xsl:fork</elcode> instruction is introduced to allow multiple
                  results to be computed during a single pass of a streamed input document.</p>
            </item>



            <item>
               <p>The syntax of <termref def="dt-pattern">patterns</termref> has been generalized.
                  Patterns may now match any item (not only nodes). In consequence,
                     <elcode>xsl:apply-templates</elcode> can now process sequences of atomic values
                  as well as nodes, and <elcode>xsl:for-each-group</elcode> with the
                     <code>group-starting-with</code> and <code>group-ending-with</code> options can
                  also process atomic sequences. As a further consequence, the <termref def="dt-initial-context-item"/> supplied when initiating a transformation is no
                  longer required to be a node.</p>
            </item>
            <item>
               <p>The <elcode>xsl:copy</elcode> instruction now has a <code>select</code> attribute,
                  which is convenient when it is used inside a function where there is no context
                  item.</p>
            </item>

            <item>
               <p>A <termref def="dt-basic-xslt-processor">basic XSLT Processor</termref> now
                  recognizes all the built-in types defined in XML Schema.</p>
            </item>

            <item>
               <p>A <termref def="dt-basic-xslt-processor">basic XSLT Processor</termref> will now
                  accept the attribute <code>validation="lax"</code> and interpret it in the same
                  way as a schema-aware processor when there is no schema component available to
                  perform the validation.</p>
            </item>

            <item>
               <p>Some functions, including <code>generate-id</code>, <code>format-date</code>,
                     <code>format-dateTime</code>, <code>format-number</code>, and
                     <code>format-time</code> have been moved from this specification to the core
                  Functions and Operators specification, to make them available in other host
                  languages.</p>
            </item>
         </olist>
      </inform-div1>
      <inform-div1 id="incompatibilities" diff="add" at="E">
         <head>Incompatibilities with XSLT 2.0</head>
         <p>This section lists all known incompatibilities with XSLT 2.0, that is, situations where
            a stylesheet that is error-free according to the XSLT 2.0 specification and where all
            elements have an effective version of <code>2.0</code> or less, will produce different
            results depending on whether it is run under an XSLT 2.0 processor or an XSLT 2.1
            processor.</p>
         <olist>
            <item>
               <p>XSLT 2.0 gave implementations freedom what to do when a node selected by
                     <elcode>xsl:apply-templates</elcode> matched more than one <termref def="dt-template-rule"/>. XSLT 2.1 is more prescriptive in this situation. The
                  behavior prescribed in XSLT 2.1 (selecting the template rule that is last in
                     <termref def="dt-declaration-order"/>) is compatible with the action of some
                  XSLT 2.0 processors but not necessarily others.</p>
            </item>
         </olist>

      </inform-div1>
   </back>
</spec>