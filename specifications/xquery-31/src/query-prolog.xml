<?xml version="1.0" encoding="UTF-8"?>
<div1 role="xquery" id="id-query-prolog">
  <head role="xquery">Modules and Prologs</head>
  <scrap>
    <head/>
    <prodrecap id="Module" ref="Module"/>

    <prodrecap id="MainModule" ref="MainModule"/>
    <prodrecap id="LibraryModule" ref="LibraryModule"/>
    <prodrecap id="Prolog" ref="Prolog"/>
    <prodrecap id="Setter" ref="Setter"/>
    <prodrecap id="Import" ref="Import"/>
    <prodrecap id="Separator" ref="Separator"/>
    <prodrecap id="QueryBody" ref="QueryBody"/>
  </scrap>
  <p>A query can be assembled from one or more fragments called <term>modules</term>. <termdef
      term="module" id="dt-module">A <term>module</term> is a fragment of XQuery code that conforms
      to the <nt def="Module">Module</nt> grammar and can independently undergo the <termref
        def="dt-static-analysis">static analysis phase</termref> described in <specref
        ref="id-expression-processing"/>. Each module is either a <termref def="dt-main-module">main
        module</termref> or a <termref def="dt-library-module">library
    module</termref>.</termdef></p>
  <p>
    <termdef id="dt-main-module" term="main module">A <term>main module</term> consists of a
        <termref def="dt-prolog">Prolog</termref> followed by a <termref def="dt-queryBody">Query
        Body</termref>.</termdef> A query has exactly one main module. In a main module, the
      <termref def="dt-queryBody">Query Body</termref> is evaluated with respect to the static and
    dynamic contexts of the main module in which it is found, and its value is the result of the
    query.</p>
  <p><termdef id="dt-library-module" term="library module">A module that does not contain a <termref
        def="dt-queryBody">Query Body</termref> is called a <term>library module</term>. A library
      module consists of a <termref def="dt-module-declaration">module declaration</termref>
      followed by a <termref def="dt-prolog">Prolog</termref>.</termdef> A library module cannot be
    evaluated directly; instead, it provides function and variable declarations that can be imported
    into other modules.</p>
  <p>The XQuery syntax does not allow a <termref def="dt-module">module</termref> to contain both a
      <termref def="dt-module-declaration">module declaration</termref> and a <termref
      def="dt-queryBody">Query Body</termref>.</p>
  <p><termdef id="dt-prolog" term="Prolog">A <term>Prolog</term> is a series of declarations and
      imports that define the processing environment for the <termref def="dt-module"
        >module</termref> that contains the Prolog.</termdef> Each declaration or import is followed
    by a semicolon. A Prolog is organized into two parts. </p>
  <p>The first part of the Prolog consists of setters, imports, namespace declarations, and default
    namespace declarations. <termdef term="setter" id="dt-setter"><term>Setters</term> are
      declarations that set the value of some property that affects query processing, such as
      construction mode, ordering mode, or default collation.</termdef> Namespace declarations and
    default namespace declarations affect the interpretation of <termref def="dt-qname">lexical
      QNames</termref> within the query. Imports are used to import definitions from schemas and
    modules. <termdef term="target namespace" id="dt-target-namespace"> The <term>target
        namespace</term> of a module is the namespace of the objects (such as elements or functions)
      that it defines. </termdef></p>
  <p>The second part of the Prolog consists of declarations of variables, functions, and options.
    These declarations appear at the end of the Prolog because they may be affected by declarations
    and imports in the first part of the Prolog.</p>
  <p><termdef id="dt-queryBody" term="query body">The <term>Query Body</term>, if present, consists
      of an expression that defines the result of the query.</termdef> Evaluation of expressions is
    described in <specref ref="id-expressions"/>. A module can be evaluated only if it has a Query
    Body.</p>


  <div2 id="id-version-declaration">
    <head>Version Declaration</head>

    <scrap>
      <head/>
      <prodrecap id="VersionDecl" ref="VersionDecl"/>
    </scrap>

    <p>
      <termdef term="version declaration" id="dt-version-declaration">
      A <term>version declaration</term> can identify the applicable
      XQuery syntax and semantics for a <termref
      def="dt-module">module</termref>, as well as its
      encoding.</termdef>

      <phrase diff="add" at="2015-05-18">
      <termdef id="dt-version-number" term="XQuery version number">An <term>XQuery version number</term> consists of two integers separated by a dot. The first integer is referred to as the <term>major version number</term>; the second as the <term>minor version number</term>.</termdef>
  
      Any XQuery processor that implements any version of XQuery with a given major number must accept any query with the same major version number. The processor may reject
      queries labeled with a different major version number. The processor may reject queries with the same major version number and a greater minor version number than the processor recognizes.

      If a query is rejected because of a version mismatch with the processor, a static error  <errorref code="0031" class="ST"/> must be raised.
      </phrase>

      <note diff="add" at="2015-05-18"><p>The processor is allowed to provide an option to require that minor versions also match, or that the minor number of the version in the query is not larger than the largest minor version understood by the processor in this major release of XQuery, or to allow more permissive version matching, perhaps with warnings, but the behaviour is then outside the scope of this specification.</p></note>
    </p>
      <p>The version number "1.0" indicates the intent that the module
      be processed by an <termref def="dt-xquery-10-processor">XQuery
      1.0 processor</termref>, the version number "3.0" indicates the
      intent that the module be processed by an <termref
      def="dt-xquery-30-processor" >XQuery 3.0 processor</termref>, <phrase diff="add"
      at="2014-12-06">
      the version number "3.1" indicates the intent that the module be
      processed by an <termref def="dt-xquery-31-processor" >XQuery
      3.1 processor</termref>. If the version declaration is not
      present or the version is not included in the declaration, an
      XQuery 3.1 processor assumes a version of "3.1".</phrase></p>

      <p diff="del" at="2015-05-18"><phrase diff="chg" at="2014-12-06">If an
      XQuery 3.1 processor processes a module labeled with a version
      other than "3.1"</phrase>, it must do one of the
      following:

      <ulist>
        <item><p>Process the module using the specification of the XQuery version identified in the
            version declaration.</p></item>
        <item><p>Process the module using the specification of XQuery
        <phrase diff="chg" at="2014-12-06">3.1</phrase>.</p>
        <note><p>An implementation may issue a warning in this
        case.</p></note></item>
        <item><p>Raise a static error <errorref code="0031" class="ST"/></p></item>
      </ulist> A processor may raise an error <errorref code="0034" class="ST"/> if the modules of a
      query do not have the same version number. <note><p>In general, this should be done only if a
          processor is not able to evaluate such a query.</p></note>
    </p>


    <p><termdef term="encoding declaration" id="dt-encoding-declaration">If present, a version
        declaration may optionally include an <term>encoding declaration</term>. The value of the
        string literal following the keyword <code>encoding</code> is an encoding name, and must
        conform to the definition of <code>EncName</code> specified in <bibref ref="XML"/><errorref
          code="0087" class="ST"/>. The purpose of an encoding declaration is to allow the writer of
        a query to provide a string that indicates how the query is encoded, such as
          "<code>UTF-8</code>", "<code>UTF-16</code>", or "<code>US-ASCII</code>".</termdef> Since
      the encoding of a query may change as the query moves from one environment to another, there
      can be no guarantee that the encoding declaration is correct.</p>
    <p>The handling of an encoding declaration is <termref def="dt-implementation-dependent"
        >implementation-dependent</termref>. If an implementation has <emph>a priori</emph>
      knowledge of the encoding of a query, it may use this knowledge and disregard the encoding
      declaration. The semantics of a query are not affected by the presence or absence of an
      encoding declaration.</p>
    <p>If a version declaration is present, no <nt def="Comment">Comment</nt> may occur before the
      end of the version declaration. If such a <nt def="Comment">Comment</nt> is present, the
      result is <termref def="dt-implementation-dependent">implementation-dependent</termref>; an
      implementation may raise an implementation-dependent static error, or ignore the comment. <note>
        <p>The effect of a Comment before the end of a version declaration is
          implementation-dependent because it may suppress query processing by interfering with
          detection of the encoding declaration.</p></note></p>

    <p>The following examples illustrate version declarations:</p>

    <eg role="frag-prolog-parse-test">xquery version "1.0";</eg>
    <eg role="frag-prolog-parse-test">xquery version "3.0" encoding "utf-8";</eg>
  </div2>

  <div2 id="id-module-declaration">
    <head>Module Declaration</head>
    <scrap>
      <head></head>
      <prodrecap id="ModuleDecl" ref="ModuleDecl"/>
    </scrap>
    <p>
      <termdef id="dt-module-declaration" term="module declaration">A <term>module
          declaration</term> serves to identify a <termref def="dt-module">module</termref> as a
          <termref def="dt-library-module">library module</termref>. A module declaration begins
        with the keyword <code>module</code> and contains a namespace prefix and a <nt
          def="URILiteral">URILiteral</nt>.</termdef> The URILiteral must be of nonzero length
        <errorref class="ST" code="0088"/>. The URILiteral identifies the <termref
        def="dt-target-namespace">target namespace</termref> of the library module, which is the
      namespace for all variables and functions exported by the library module. The name of every
      variable and function declared in a library module must have a namespace URI that is the same
      as the target namespace of the module; otherwise a <termref def="dt-static-error">static
        error</termref> is raised <errorref class="ST" code="0048"/>. The (prefix,URI) pair is added
      to the set of <termref def="dt-static-namespaces">statically known namespaces</termref>. </p>
    <p>The namespace prefix specified in a module declaration must not be <code>xml</code> or
        <code>xmlns</code>
      <errorref class="ST" code="0070"/>, and must not be the same as any namespace prefix bound in
      the same module by a <termref def="dt-schema-import">schema import</termref>, by a <termref
        def="dt-namespace-declaration">namespace declaration</termref>, or by a <termref
        def="dt-module-import">module import</termref> with a different target namespace <errorref
        class="ST" code="0033"/>.</p>
    <p>Any <termref def="dt-module">module</termref> may import one or more library modules by means
      of a <termref def="dt-module-import">module import</termref> that specifies the target
      namespace of the library modules to be imported. When a module imports one or more library
      modules, the variables and functions declared in the imported modules are added to the
        <termref def="dt-static-context">static context</termref> and (where applicable) to the
        <termref def="dt-dynamic-context">dynamic context</termref> of the importing module.</p>
    <p>The following is an example of a module declaration:</p>
    <eg role="frag-prolog-parse-test">module namespace gis =
      "http://example.org/gis-functions";</eg>

  </div2>

  <div2 id="id-boundary-space-decls">
    <head>Boundary-space Declaration</head>
    <scrap>
      <head></head>
      <prodrecap id="BoundarySpaceDecl" ref="BoundarySpaceDecl"/>
    </scrap>
    <p>
      <termdef id="dt-boundary-space-decl" term="boundary-space declaration">A <term>boundary-space
          declaration</term> sets the <termref def="dt-boundary-space-policy">boundary-space
          policy</termref> in the <termref def="dt-static-context">static context</termref>,
        overriding any implementation-defined default. Boundary-space policy controls whether
          <termref def="dt-boundary-whitespace">boundary whitespace</termref> is preserved by
        element constructors during processing of the query.</termdef> If boundary-space policy is
        <code>preserve</code>, boundary whitespace is preserved. If boundary-space policy is
        <code>strip</code>, boundary whitespace is stripped (deleted). A further discussion of
      whitespace in constructed elements can be found in <specref ref="id-whitespace"/>.</p>
    <p>The following example illustrates a boundary-space declaration:</p>
    <eg role="frag-prolog-parse-test">declare boundary-space preserve;</eg>
    <p>If a Prolog contains more than one boundary-space declaration, a <termref
        def="dt-static-error">static error</termref> is raised <errorref class="ST" code="0068"
      />.</p>
  </div2>
  <div2 id="id-default-collation-declaration">
    <head>Default Collation Declaration</head>
    <scrap>
      <head></head>

      <prodrecap id="DefaultCollationDecl" ref="DefaultCollationDecl"/>
    </scrap>
    <p>
      <termdef term="default collation declaration" id="dt-default-collation-decl">A <term>default
          collation declaration</term> sets the value of the <termref def="dt-def-collation">default
          collation</termref> in the <termref def="dt-static-context">static context</termref>,
        overriding any implementation-defined default.</termdef> The default collation is the
      collation that is used by functions and operators that require a collation if no other
      collation is specified. For example, the <code>gt</code> operator on strings is defined by a
      call to the <code>fn:compare</code> function, which takes an optional collation parameter.
      Since the <code>gt</code> operator does not specify a collation, the <code>fn:compare</code>
      function implements <code>gt</code> by using the default collation.</p>
    <p>If neither the implementation nor the Prolog specifies a default collation, the Unicode
      codepoint collation (<code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>)
      is used. </p>
    <p>The following example illustrates a default collation declaration:</p>
    <eg role="frag-prolog-parse-test">declare default collation "http://example.org/languages/Icelandic";</eg>
    <p>If a default collation declaration specifies a collation by a relative URI, that relative URI
      is <termref def="dt-resolve-relative-uri">resolved to an absolute URI</termref> using the
        <termref def="dt-static-base-uri">Static Base URI</termref>. If a Prolog contains more than
      one default collation declaration, or the value specified by a default collation declaration
      (after resolution of a relative URI, if necessary) is not present in <termref
        def="dt-static-collations">statically known collations</termref>, a <termref
        def="dt-static-error">static error</termref> is raised <errorref class="ST" code="0038"
      />.</p>
  </div2>
  <div2 id="id-base-uri-decl">
    <head>Base URI Declaration</head>
    <scrap>
      <head></head>
      <prodrecap id="BaseURIDecl" ref="BaseURIDecl"/>
    </scrap>

    <p>
      <termdef id="dt-base-uri-decl" term="base URI declaration">A <term>base URI declaration</term>
        specifies the <termref def="dt-static-base-uri">Static Base URI</termref> property. The
          <termref def="dt-static-base-uri">Static Base URI</termref> property is used when
        resolving relative URI references.</termdef> For example, the <termref
        def="dt-static-base-uri">Static Base URI</termref> property is used when resolving relative
      references for <termref def="dt-module-import">module import</termref> and for the
        <code>fn:doc</code> function.</p>

    <note>
      <p>As discussed in the definition of <termref def="dt-static-base-uri">Static Base
          URI</termref>, if there is no base URI declaration, or if the value of the declaration is
        a relative URI reference, then the value of the Static Base URI may depend on the location
        of the query, and it is permissible for this to vary between the static analysis phase and
        the dynamic evaluation phase.</p>
    </note>

    <p>The following is an example of a base URI declaration:</p>
    <eg role="frag-prolog-parse-test">declare base-uri "http://example.org";</eg>
    <p>If a Prolog contains more than one base URI declaration, a <termref def="dt-static-error"
        >static error</termref> is raised <errorref class="ST" code="0032"/>.</p>
    <p>In the terminology of <bibref ref="RFC3986"/> Section 5.1, the URILiteral of the base URI
      declaration is considered to be a "base URI embedded in content". If no base URI declaration
      is present, <termref def="dt-static-base-uri">Static Base URI</termref> property is
      established according to the principles outlined in <bibref ref="RFC3986"/> Section
      5.1&mdash;that is, it defaults first to the base URI of the encapsulating entity, then to the
      URI used to retrieve the entity, and finally to an implementation-defined default. If the
      URILiteral in the base URI declaration is a relative URI, then it is made absolute by
      resolving it with respect to this same hierarchy. For example, if the URILiteral in the base
      URI declaration is <code>../data/</code>, and the query is contained in a file whose URI is
        <code>file:///C:/temp/queries/query.xq</code>, then the <termref def="dt-static-base-uri"
        >Static Base URI</termref> property is <code>file:///C:/temp/data/</code>.</p>

    <p>It is not intrinsically an error if this process fails to establish an absolute base URI;
      however, the <termref def="dt-static-base-uri">Static Base URI</termref> property is then
        <xtermref spec="DM31" ref="dt-absent"/>
      <errorref class="ST" code="0001"/>. When the <termref def="dt-static-base-uri">Static Base
        URI</termref> property is <xtermref spec="DM31" ref="dt-absent"/>, any attempt to use its
      value to <termref def="dt-resolve-relative-uri">resolve a relative URI reference</termref>
      will result in an error <errorref class="ST" code="0001"/>. </p>
  </div2>

  <div2 id="id-construction-declaration">
    <head>Construction Declaration</head>
    <scrap>
      <head></head>

      <prodrecap id="ConstructionDecl" ref="ConstructionDecl"/>
    </scrap>
    <p>
      <termdef term="construction declaration" id="dt-construction-decl">A <term>construction
          declaration</term> sets the <termref def="dt-construction-mode">construction
          mode</termref> in the <termref def="dt-static-context">static context</termref>,
        overriding any implementation-defined default.</termdef> The construction mode governs the
      behavior of element and document node constructors. If construction mode is
        <code>preserve</code>, the type of a constructed element node is <code>xs:anyType</code>,
      and all attribute and element nodes copied during node construction retain their original
      types. If construction mode is <code>strip</code>, the type of a constructed element node is
        <code>xs:untyped</code>; all element nodes copied during node construction receive the type
        <code>xs:untyped</code>, and all attribute nodes copied during node construction receive the
      type <code>xs:untypedAtomic</code>.</p>
    <p>The following example illustrates a construction declaration:</p>
    <eg role="frag-prolog-parse-test">declare construction strip;</eg>
    <p>If a Prolog specifies more than one construction declaration, a <termref
        def="dt-static-error">static error</termref> is raised <errorref class="ST" code="0067"
      />.</p>
  </div2>
  <div2 id="id-default-ordering-decl">
    <head>Ordering Mode Declaration</head>
    <scrap>
      <head></head>

      <prodrecap id="OrderingModeDecl" ref="OrderingModeDecl"/>
    </scrap>
    <p>
      <termdef id="dt-ordering-mode-decl" term="ordering mode declaration">An <term>ordering mode
          declaration</term> sets the <termref def="dt-ordering-mode">ordering mode</termref> in the
          <termref def="dt-static-context">static context</termref>, overriding any
        implementation-defined default.</termdef> This ordering mode applies to all expressions in a
        <termref def="dt-module">module</termref> (including both the <termref def="dt-prolog"
        >Prolog</termref> and the <termref def="dt-queryBody">Query Body</termref>, if any), unless
      overridden by an <code>ordered</code> or <code>unordered</code> expression.</p>
    <p>The following example illustrates an ordering mode declaration:</p>
    <eg role="frag-prolog-parse-test">declare ordering unordered;</eg>
    <p>If a Prolog contains more than one ordering mode declaration, a <termref
        def="dt-static-error">static error</termref> is raised <errorref class="ST" code="0065"
      />.</p>
  </div2>
  <div2 id="id-empty-order-decl">
    <head>Empty Order Declaration</head>
    <scrap>
      <head></head>

      <prodrecap id="EmptyOrderDecl" ref="EmptyOrderDecl"/>
    </scrap>
    <p>
      <termdef term="empty order declaration" id="dt-empty-order-decl">An <term>empty order
          declaration</term> sets the <termref def="dt-default-empty-order">default order for empty
          sequences</termref> in the <termref def="dt-static-context">static context,</termref>
        overriding any implementation-defined default. This declaration controls the processing of
        empty sequences and <code>NaN</code> values as ordering keys in an <code>order by</code>
        clause in a FLWOR expression.</termdef> An individual <code>order by</code> clause may
      override the default order for empty sequences by specifying <code>empty greatest</code> or
        <code>empty least</code>.</p>
    <p>The following example illustrates an empty order declaration:</p>
    <eg role="frag-prolog-parse-test">declare default order empty least;</eg>
    <p>If a Prolog contains more than one empty order declaration, a <termref def="dt-static-error"
        >static error</termref> is raised <errorref class="ST" code="0069"/>.</p>
    <note>
      <p>It is important to distinguish an <termref def="dt-empty-order-decl">empty order
          declaration</termref> from an <termref def="dt-ordering-mode-decl">ordering mode
          declaration</termref>. An <termref def="dt-empty-order-decl">empty order
          declaration</termref> applies only when an <code>order by</code> clause is present, and
        specifies how empty sequences are treated by the <code>order by</code> clause (unless
        overridden). An <termref def="dt-ordering-mode-decl">ordering mode declaration</termref>, on
        the other hand, applies only in the absence of an <code>order by</code> clause.</p>
    </note>
  </div2>


  <div2 id="id-copy-namespaces-decl">
    <head>Copy-Namespaces Declaration</head>
    <scrap>
      <head></head>
      <prodrecap id="CopyNamespacesDecl" ref="CopyNamespacesDecl"/>
      <prodrecap id="PreserveMode" ref="PreserveMode"/>
      <prodrecap id="InheritMode" ref="InheritMode"/>
    </scrap>

    <p>
      <termdef id="dt-copy-namespaces-decl" term="copy-namespaces
declaration">A
          <term>copy-namespaces declaration</term> sets the value of <termref
          def="dt-copy-namespaces-mode">copy-namespaces mode</termref> in the <termref
          def="dt-static-context">static context</termref>, overriding any implementation-defined
        default. Copy-namespaces mode controls the namespace bindings that are assigned when an
        existing element node is copied by an element constructor or document constructor.</termdef>
      Handling of namespace bindings by element constructors is described in <specref
        ref="id-element-constructor"/>.</p>

    <p>The following example illustrates a copy-namespaces declaration:</p>

    <eg role="frag-prolog-parse-test">declare copy-namespaces preserve, no-inherit;</eg>

    <p>If a Prolog contains more than one copy-namespaces declaration, a <termref
        def="dt-static-error">static error</termref> is raised <errorref class="ST" code="0055"
      />.</p>
  </div2>


  <div2 id="id-decimal-format-decl">
    <head>Decimal Format Declaration</head>
    <scrap>
      <head></head>
      <prodrecap id="DecimalFormatDecl" ref="DecimalFormatDecl"/>
      <prodrecap id="DFPropertyName" ref="DFPropertyName"/>
    </scrap>
    
    <p>
      <termdef id="dt-decimal-format-decl" term="decimal-format
        declaration">A <term>decimal format
          declaration</term> adds a decimal format to the <termref def="dt-static-decimal-formats"
            >statically known decimal formats</termref>, which define the properties used to format
        numbers using the <code>fn:format-number()</code> function</termdef>, as described in
      <bibref ref="xpath-functions-31"/>. 
      
      <phrase diff="chg" at="2015-06-02">If the form <code>decimal-format EQName</code> is used, then the declaration 
        defines the properties of the decimal format whose name is <code>EQName</code>, while the form <code>default decimal-format</code> 
        defines the properties of the unnamed decimal format. The declaration contains a set of 
        (<code>DFPropertyName</code>, <code>StringLiteral</code>) pairs, where the <code>DFPropertyName</code> is the name 
        of the property and the <code>StringLiteral</code> is its value. The valid values and default values for each 
        property are defined in <termref def="dt-static-decimal-formats">statically known decimal formats</termref>.
      </phrase></p>
      
      <p>If a format declares no properties, default values are
      used for all properties.</p>
    
    <p>Error conditions are defined as follows:</p>
    <ulist>
      <item><p>It is a <termref def="dt-static-error">static error</termref> for a query prolog to contain
        two decimal format declarations with the same name, or to contain two default decimal format
        declarations <errorref class="ST" code="0111"/>.</p></item>
      <item><p>It is a <termref def="dt-static-error">static
        error</termref> for a decimal format declaration to define the same property more than once
        <errorref class="ST" code="0114"/>.</p></item>
      <item><p>It is a <termref def="dt-static-error">static
        error</termref> for a decimal format declaration to specify a value that is not valid for a
        given property, as described in <termref def="dt-static-decimal-formats">statically known
          decimal formats</termref>
        <errorref class="ST" code="0097"/>.</p></item>
      <item><p>It is a <termref def="dt-static-error">static
        error</termref> if, for any named or unnamed decimal format, the properties representing
        characters used in a picture string do not have distinct values <errorref class="ST"
          code="0098"/>.</p> 
        <p>The following properties represent characters used in a picture string:
        <termref def="id-static-decimal-format-decimal-separator">decimal-separator</termref>, 
        <phrase diff="add" at="2014-04-07"><termref def="id-static-decimal-format-exponent-separator">exponent-separator</termref>,</phrase>
        <termref def="id-static-decimal-format-grouping-separator">grouping-separator</termref>, 
        <termref def="id-static-decimal-format-percent">percent</termref>, 
        <termref def="id-static-decimal-format-per-mille">per-mille</termref>, 
        <phrase diff="add" at="2015-06-04">the family of ten decimal digits starting with </phrase><termref def="id-static-decimal-format-zero-digit">zero-digit</termref>, 
        <termref def="id-static-decimal-format-digit">digit</termref>, 
        and <termref def="id-static-decimal-format-pattern-separator">pattern-separator</termref>.</p>
      </item>
      
    </ulist>

    
    <example>
      
      <p>The following query formats numbers using two different decimal format declarations:</p>
      
      <eg role="parse-test">
declare decimal-format local:de 
  decimal-separator = "," grouping-separator = "."; 
declare decimal-format local:en 
  decimal-separator = "." grouping-separator = ","; 
       
let $numbers := (1234.567, 789, 1234567.765) 
for $i in $numbers
return ( 
  format-number($i, "#.###,##", "local:de"), 
  format-number($i, "#,###.##", "local:en") 
)</eg>
      <p>The output of this query is:</p>
      <eg>1.234,57 1,234.57 789 789 1.234.567,76 1,234,567.76</eg>
    </example>
    
  </div2>

  <div2 id="id-schema-import">
    <head>Schema Import</head>
    <scrap>
      <head></head>

      <prodrecap id="SchemaImport" ref="SchemaImport"/>
      <prodrecap id="SchemaPrefix" ref="SchemaPrefix"/>
    </scrap>


    <p>
      <termdef id="dt-schema-import" term="schema import">A <term>schema import</term> imports the
        element declarations, attribute declarations, and type definitions from a schema into the
          <termref def="dt-issd">in-scope schema definitions</termref>. For each named user-defined
        simple type in the schema, schema import also adds a corresponding <termref
          def="dt-constructor-function">constructor function</termref>. </termdef> The schema to be
      imported is identified by its <termref def="dt-target-namespace">target namespace</termref>.
      The schema import may bind a namespace prefix to the target namespace of the imported schema,
      adding the (prefix, URI) pair to the <termref def="dt-static-namespaces">statically known
        namespaces</termref>, or it may declare that target namespace to be the <termref
        def="dt-def-elemtype-ns">default element/type namespace</termref>. The schema import may
      also provide optional hints for locating the schema.</p>
    <p>The namespace prefix specified in a schema import must not be <code>xml</code> or
        <code>xmlns</code>
      <errorref class="ST" code="0070"/>, and must not be the same as any namespace prefix bound in
      the same module by another schema import, a <termref def="dt-module-import">module
        import</termref>, a <termref def="dt-namespace-declaration">namespace declaration</termref>,
      or a <termref def="dt-module-import">module declaration</termref>
      <errorref class="ST" code="0033"/>. </p>

    <p> The first <nt def="URILiteral">URILiteral</nt> in a schema import specifies the target
      namespace of the schema to be imported. 
      The URILiterals that follow the <code>at</code>
      keyword are optional location hints, and can be interpreted or disregarded in an
      implementation-dependent way. Multiple location hints might be used to indicate more than one
      possible place to look for the schema or multiple physical resources to be assembled to form
      the schema.
    </p>
    <p>
      <phrase diff="add" at="2015-05-26">If the target
      namespace is <code>http://www.w3.org/2005/xpath-functions</code> then the schema described in 
      <xspecref spec="FO31" ref="schemata"/> is imported; any location hints are ignored.</phrase>
    </p>
    <p>A schema import that specifies a zero-length string as target namespace is considered to
      import a schema that has no target namespace. Such a schema import must not bind a namespace
      prefix <errorref class="ST" code="0057"/>, but it may set the default element/type namespace
      to a zero-length string (representing "no namespace"), thus enabling the definitions in the
      imported namespace to be referenced. If the default element/type namespace is not set to "no
      namespace", there is no way to reference the definitions in an imported schema that has no
      target namespace.</p>
    <p>It is a <termref def="dt-static-error">static error</termref>
      <errorref class="ST" code="0058"/> if more than one schema import in the same <termref
        def="dt-prolog">Prolog</termref> specifies the same target namespace. It is a <termref
        def="dt-static-error">static error</termref>
      <errorref class="ST" code="0059"/> if the implementation is not able to process a schema
      import by finding a valid schema with the specified target namespace. It is a <termref
        def="dt-static-error">static error</termref>
      <errorref class="ST" code="0035"/> if multiple imported schemas, or multiple physical
      resources within one schema, contain definitions for the same name in the same symbol space
      (for example, two definitions for the same element name, even if the definitions are
      consistent). However, it is not an error to import the schema with target namespace
        <code>http://www.w3.org/2001/XMLSchema </code>(predeclared prefix <code>xs</code>), even
      though the built-in types defined in this schema are implicitly included in the <termref
        def="dt-is-types">in-scope schema types.</termref>
    </p>



    <p> It is a <termref def="dt-static-error">static error</termref>
      <errorref code="0012" class="ST"/> if the set of definitions contained in all schemas imported
      by a Prolog do not satisfy the conditions for schema validity specified in Sections 3 and 5 of
        <bibref ref="XMLSchema10"/> or <bibref ref="XMLSchema11"/> Part 1--i.e., each definition
      must be valid, complete, and unique.</p>
    <p>The following example imports a schema, specifying both its target namespace and its
      location, and binding the prefix <code>soap</code> to the target namespace:</p>

    <eg role="frag-prolog-parse-test">import schema namespace soap="http://www.w3.org/2003/05/soap-envelope" 
    at "http://www.w3.org/2003/05/soap-envelope/";</eg>
    <p>The following example imports a schema by specifying only its target namespace, and makes it
      the default element/type namespace:</p>
    <eg role="frag-prolog-parse-test">import schema default element namespace "http://example.org/abc";</eg>
    <p>The following example imports a schema that has no target namespace, providing a location
      hint, and sets the default element/type namespace to "no namespace" so that the definitions in
      the imported schema can be referenced:</p>
    <eg role="frag-prolog-parse-test">import schema default element namespace "" at "http://example.org/xyz.xsd";</eg>
    <p>The following example imports a schema that has no target namespace and sets the default
      element/type namespace to "no namespace". Since no location hint is provided, it is up to the
      implementation to find the schema to be imported.</p>
    <eg role="frag-prolog-parse-test">import schema default element namespace "";</eg>
  </div2>
  <div2 id="id-module-import">
    <head>Module Import</head>
    <scrap>
      <head></head>

      <prodrecap id="ModuleImport" ref="ModuleImport"/>
    </scrap>
    <p>
      <termdef term="module import" id="dt-module-import">A <term>module import</term> imports the
        public variable declarations and public function declarations from one or more <termref
          def="dt-library-module">library modules</termref> into the <termref
          def="dt-known-func-signatures">statically known function signatures</termref> and <termref
          def="dt-in-scope-variables">in-scope variables</termref> of the importing <termref
          def="dt-module">module</termref>.</termdef> Each module import names a <termref
        def="dt-target-namespace">target namespace</termref> and imports an <termref
        def="dt-implementation-defined">implementation-defined</termref> set of modules that share
      this target namespace. The module import may bind a namespace prefix to the target namespace,
      adding the (prefix, URI) pair to the <termref def="dt-static-namespaces">statically known
        namespaces</termref>, and it may provide optional hints for locating the modules to be
      imported.</p>

    <p>If a module <code>A</code> imports module <code>B</code>, the static context of module
        <code>A</code> will contain the <termref def="dt-issd">in-scope schema definitions</termref>
      and <termref def="dt-known-func-signatures">statically known function signatures</termref> of
      module <code>B</code>, and the dynamic context of module <code>A</code> will contain the
        <termref def="dt-variable-values">variable values</termref> and <termref
        def="dt-named-functions">named functions</termref> of module <code>B</code>, with the
      exception of non-public functions and variables, and of the functions and variables not
      declared directly in <code>B</code>.</p>

    <p>The following example illustrates a module import:</p>

    <eg role="frag-prolog-parse-test">import module namespace gis="http://example.org/gis-functions";</eg>

    <p>If a query imports the same module via multiple paths, only one instance of the module is
      imported. Because only one instance of a module is imported, there is only one instance of
      each variable declared in a module's prolog.</p>

    <p>A module may import its own target namespace (this is interpreted as importing an <termref
        def="dt-implementation-defined">implementation-defined</termref> set of other modules that
      share its target namespace.)</p>

    <p>The namespace prefix specified in a module import must not be <code>xml</code> or
        <code>xmlns</code>
      <errorref class="ST" code="0070"/>, and must not be the same as any namespace prefix bound in
      the same module by another module import, a <termref def="dt-schema-import">schema
        import</termref>, a <termref def="dt-namespace-declaration">namespace declaration</termref>,
      or a <termref def="dt-module-declaration">module declaration</termref> with a different target
      namespace <errorref class="ST" code="0033"/>.</p>
    <p>The first <nt def="URILiteral">URILiteral</nt> in a module import must be of nonzero length
        <errorref class="ST" code="0088"/>, and specifies the target namespace of the modules to be
      imported. The URILiterals that follow the <code>at</code> keyword are optional location hints,
      and can be interpreted or disregarded in an <termref def="dt-implementation-defined"
        >implementation-defined</termref> way.</p>
    <p>It is a <termref def="dt-static-error">static error</termref>
      <errorref class="ST" code="0047"/> if more than one module import in a <termref
        def="dt-prolog">Prolog</termref> specifies the same target namespace. It is a <termref
        def="dt-static-error">static error</termref>
      <errorref class="ST" code="0059"/> if the implementation is not able to process a module
      import by finding a valid module definition with the specified target namespace. It is a
        <termref def="dt-static-error">static error</termref> if two or more variables declared or
      imported by a <termref def="dt-module">module</termref> have equal <termref
        def="dt-expanded-qname">expanded QNames</termref> (as defined by the <code>eq</code>
      operator) <errorref class="ST" code="0049"/>.</p>
    <p>Each <termref def="dt-module">module</termref> has its own <termref def="dt-static-context"
        >static context</termref>. A <termref def="dt-module-import">module import</termref> imports
      only functions and variable declarations; it does not import other objects from the imported
      modules, such as <termref def="dt-issd">in-scope schema definitions</termref> or <termref
        def="dt-static-namespaces">statically known namespaces</termref>. Module imports are not
      transitive&mdash;that is, importing a module provides access only to function and variable
      declarations contained directly in the imported module. For example, if module A imports
      module B, and module B imports module C, module A does not have access to the functions and
      variables declared in module C. </p>


    <!--	  <change diff="chg" at="XQ.E6"> -->
    <!--	</change> -->

    <example>
      <head>Schema Information and Module Import</head>

      <p>A module import does not import schema definitions from the imported module. In the
        following query, the type geometry:triangle is not defined, even if it is known in the
        imported module, so the variable declaration raises an error <errorref class="ST"
          code="0051"/>:</p>

      <eg role="parse-test">(: Error - geometry:triangle is not defined :) 
import module namespace geo = "http://example.org/geo-functions"; 
declare variable $t as geometry:triangle := geo:make-triangle(); 
$t</eg>

      <p>Without the type declaration for the variable, the variable declaration succeeds:</p>

      <eg role="parse-test">import module namespace geo = "http://example.org/geo-functions";
declare variable $t := geo:make-triangle(); $t</eg>

      <p>Importing the schema that defines the type of the variable,
      the variable declaration succeeds:</p>

      <eg role="parse-test">import schema namespace geometry = "http://example.org/geo-schema-declarations"; 
import module namespace geo = "http://example.org/geo-functions"; 
declare variable $t as geometry:triangle := geo:make-triangle(); $t</eg>
    </example>

    <div3 id="id-module-handling-module-uris">
      <head>The Target Namespace of a Module</head>

      <p>The target namespace of a module should be treated in the same way as other namespace
        URIs.</p>

      <p>To maximize interoperability, query authors should use a string that is a valid absolute
        IRI.</p>

      <p>Implementions must accept any string of Unicode characters. Target namespace URIs are
        compared using the Unicode codepoint collation rather than any concept of semantic
        equivalence.</p>

      <p>Implementations may provide mechanisms allowing the target namespace URI to be used as
        input to a process that delivers the module as a resource, for example a catalog, module
        repository, or URI resolver. For interoperability, such mechanisms should not prevent the
        user from choosing an arbitrary URI for naming a module.</p>

      <p>Similarly, implementations may perform syntactic transformations on the target namespace
        URI to obtain the names of related resources, for example to implement a convention relating
        the name or location of compiled code to the target namespace URI; but again, such
        mechanisms should not prevent the user from choosing an arbitrary target namespace URI.</p>

      <p>As with other namespace URIs, it is common practice to use target namespace URIs whose
        scheme is "http" and whose authority part uses a DNS domain name under the control of the
        user.</p>

      <p>The specifications allow, and some users might consider it good practice, for the target
        namespace URI of a function library to be the same as the namespace URI of the XML
        vocabulary manipulated by the functions in that library.</p>
    </div3>

    <div3 id="id-module-handling-multiple-same">
      <head>Multiple Modules with the same Namespace</head>

      <p>Several different modules with the same target namespace can be used in the same query. The
        names of public variables and public functions must be unique within the <termref
          def="dt-module-context">module contexts</termref> of a query: that is, if two modules with
        the same target namespace URI are used in the same query, the names of the public variables
        and functions in their module contexts must not overlap.</p>

      <p>If one module contains an "import module" declaration with the target namespace
          <code>M</code>, then all public variables and public functions in the contexts of modules
        whose target namespace is <code>M</code> must be accessible in the importing module,
        regardless whether the participation of the imported module was directly due to this "import
        module" declaration.</p>

    </div3>


    <div3 id="id-module-handling-location-uris">
      <head>Location URIs</head>

      <p>The term "location URIs" refers to the URIs in the "at" clause of an "import module"
        declaration.</p>

      <p>Products should (by default or at user option) take account of all the location URIs in an
        "import module" declaration, treating each location URI as a reference to a module with the
        specified target namespace URI. Location URIs should be made absolute with respect to the
        static base URI of the module containing the "import module" declaration where they appear.
        The mapping from location URIs to module source code or compiled code MAY be done in any way
        convenient to the implementation. If possible given the product's architecture, security
        requirements, etc, the product should allow this to fetch the source code of the module to
        use the standard web mechanisms for dereferencing URIs in standard schemes such as the
        "http" URI scheme.</p>

      <p>When the same absolutized location URI is used more than once, either in the same "import
        module" declaration or in different "import module" declarations within the same query, a
        single copy of the resource containing the module is loaded. When different absolutized
        location URIs are used, each results in a single module being loaded, unless the
        implementation is able to determine that the different URIs are references to the same
        resource. No error due to duplicate variable or functions names should arise from the same
        module being imported more than once, so long as the absolute location URI is the same in
        each case.</p>

      <p>Implementations must report a static error if a location URI cannot be resolved after all
        available recovery strategies have been exhausted.</p>

    </div3>
    <div3 id="id-module-handling-cycles">
      <head>Cycles</head>

      <p>Implementations must resolve cycles in the import graph, either at the level of target
        namespace URIs or at the level of location URIs, and ensure that each module is imported
        only once. </p>
    </div3>

  </div2>
  <div2 id="id-namespace-declaration">

    <head>Namespace Declaration</head>
    <scrap>
      <head></head>
      <prodrecap id="NamespaceDecl" ref="NamespaceDecl"/>


    </scrap>

    <p>
      <termdef id="dt-namespace-declaration" term="namespace declaration">A <term>namespace
          declaration</term> declares a namespace prefix and associates it with a namespace URI,
        adding the (prefix, URI) pair to the set of <termref def="dt-static-namespaces">statically
          known namespaces</termref>.</termdef> The namespace declaration is in scope throughout the
      query in which it is declared, unless it is overridden by a <termref
        def="dt-namespace-decl-attr">namespace declaration attribute</termref> in a <termref
        def="dt-direct-elem-const">direct element constructor</termref>.</p>
    <p>If the URILiteral part of a namespace declaration is a zero-length string, any existing
      namespace binding for the given prefix is removed from the <termref def="dt-static-namespaces"
        >statically known namespaces</termref>. This feature provides a way to remove predeclared
      namespace prefixes such as <code>local</code>.</p>
    <p>The following query illustrates a namespace declaration:</p>
    <eg role="parse-test">
<![CDATA[declare namespace foo = "http://example.org";
<foo:bar> Lentils </foo:bar>]]>
    </eg>
    <p>In the query result, the newly created node is in the namespace associated with the namespace
      URI <code>http://example.org</code>.</p>




    <p>The namespace prefix specified in a namespace declaration must not be <code>xml</code> or
        <code>xmlns</code>
      <errorref class="ST" code="0070"/>. The namespace URI specified in a namespace declaration
      must not be <code>http://www.w3.org/XML/1998/namespace</code> or
        <code>http://www.w3.org/2000/xmlns/</code>
      <errorref class="ST" code="0070"/>. The namespace prefix specified in a namespace declaration
      must not be the same as any namespace prefix bound in the same module by a <termref
        def="dt-module-import">module import</termref>, <termref def="dt-schema-import">schema
        import</termref>, <termref def="dt-module-import">module declaration</termref>, or another
      namespace declaration <errorref class="ST" code="0033"/>. </p>

    <p>It is a <termref def="dt-static-error">static error</termref>
      <errorref class="ST" code="0081"/> if an expression contains a <termref def="dt-qname">lexical
        QName</termref> with a namespace prefix that is not in the <termref
        def="dt-static-namespaces">statically known namespaces</termref>.</p>

    <p>XQuery has several predeclared namespace prefixes that are present in the <termref
        def="dt-static-namespaces">statically known namespaces</termref> before each query is
      processed. These prefixes may be used without an explicit declaration. They may be overridden
      by <termref def="dt-namespace-declaration">namespace declarations</termref> in a <termref
        def="dt-prolog">Prolog</termref> or by <termref def="dt-namespace-decl-attr">namespace
        declaration attributes</termref> on constructed elements (however, the prefix
        <code>xml</code> must not be redeclared, and no other prefix may be bound to the namespace
      URI associated with the prefix <code>xml</code>
      <errorref class="ST" code="0070"/>). The predeclared namespace prefixes are as follows:</p>
    <ulist>
      <item>
        <p>
          <code>xml = http://www.w3.org/XML/1998/namespace</code>
        </p>
      </item>
      <item>
        <p>
          <code>xs = http://www.w3.org/2001/XMLSchema</code>
        </p>
      </item>
      <item>
        <p>
          <code>xsi = http://www.w3.org/2001/XMLSchema-instance</code>
        </p>
      </item>
      <item>
        <p>
          <code>fn = http://www.w3.org/2005/xpath-functions</code>
        </p>
      </item>
      <item>
        <p>
          <code>local = http://www.w3.org/2005/xquery-local-functions</code> (see <specref
            ref="FunctionDeclns"/>.)</p>
      </item>
    </ulist>

    <p>Additional predeclared namespace prefixes may be added to the <termref
        def="dt-static-namespaces">statically known namespaces</termref> by an implementation.</p>

    <p>When element or attribute names are compared, they are considered identical if the local
      parts and namespace URIs match on a codepoint basis. Namespace prefixes need not be identical
      for two names to match, as illustrated by the following example:</p>
    <eg role="parse-test">
<![CDATA[declare namespace xx = "http://example.org";

let $i := <foo:bar xmlns:foo = "http://example.org">
              <foo:bing> Lentils </foo:bing>
          </foo:bar>
return $i/xx:bing]]>
    </eg>
    <p>Although the namespace prefixes <code>xx</code> and <code>foo</code> differ, both are bound
      to the namespace URI <code>http://example.org</code>. Since <code>xx:bing</code> and
        <code>foo:bing</code> have the same local name and the same namespace URI, they match. The
      output of the above query is as follows.</p>
    <eg role="parse-test">
<![CDATA[<foo:bing xmlns:foo = "http://example.org"> Lentils </foo:bing>]]>
    </eg>
  </div2>
  <div2 id="id-default-namespace">
    <head>Default Namespace Declaration</head>
    <scrap>
      <head></head>
      <prodrecap id="DefaultNamespaceDecl" ref="DefaultNamespaceDecl"/>

    </scrap>
    <p>
      <term>Default namespace declarations</term> can be used in a <termref def="dt-prolog"
        >Prolog</termref> to facilitate the use of unprefixed QNames.</p>

    <p>The namespace URI specified in a default namespace declaration must not be
        <code>http://www.w3.org/XML/1998/namespace</code> or
        <code>http://www.w3.org/2000/xmlns/</code>
      <errorref class="ST" code="0070"/>.</p>

    <p>The following kinds of default namespace declarations are supported:</p>
    <ulist>
      <item>
        <p>A <term>default element/type namespace declaration</term> declares a namespace URI that
          is associated with unprefixed names of elements and types. This declaration is recorded as
          the <termref def="dt-def-elemtype-ns">default element/type namespace</termref> in the
            <termref def="dt-static-context">static context</termref>. A <termref def="dt-prolog"
            >Prolog</termref> may contain at most one default element/type namespace declaration
            <errorref class="ST" code="0066"/>. If the <nt def="URILiteral">URILiteral</nt> in a
          default element/type namespace declaration is a zero-length string, the <termref
            def="dt-def-elemtype-ns">default element/type namespace</termref> is undeclared (set to
            <xtermref spec="DM31" ref="dt-absent"/>), and unprefixed names of elements and types are
          considered to be in no namespace. The following example illustrates the declaration of a
          default namespace for elements and types:</p>
        <eg role="frag-prolog-parse-test">declare default element namespace "http://example.org/names";</eg>
        <p>A default element/type namespace declaration may be overridden by a <termref
            def="dt-namespace-decl-attr">namespace declaration attribute</termref> in a <termref
            def="dt-direct-elem-const">direct element constructor</termref>.</p>
        <p>If no default element/type namespace declaration is present, unprefixed element and type
          names are in no namespace (however, an implementation may define a different default as
          specified in <specref ref="id-xq-static-context-components"/>.)</p>
      </item>
      <item>
        <p>A <term>default function namespace declaration</term> declares a namespace URI that is
          associated with unprefixed function names in static function calls and function
          declarations. This declaration is recorded as the <termref def="dt-def-fn-ns">default
            function namespace</termref> in the <termref def="dt-static-context">static
            context</termref>. A <termref def="dt-prolog">Prolog</termref> may contain at most one
          default function namespace declaration <errorref class="ST" code="0066"/>. If the
          StringLiteral in a default function namespace declaration is a zero-length string, the
          default function namespace is undeclared (set to <xtermref spec="DM31" ref="dt-absent"/>).
          In that case, any functions that are associated with a namespace can be called only by
          using an explicit namespace prefix.</p>
        <p>If no default function namespace declaration is present, the default function namespace
          is the namespace of XPath/XQuery functions,
            <code>http://www.w3.org/2005/xpath-functions</code> (however, an implementation may
          define a different default as specified in <specref ref="id-xq-static-context-components"
          />.)</p>
        <p>The following example illustrates the declaration of a default function namespace:</p>
        <eg role="frag-prolog-parse-test">declare default function namespace "http://www.w3.org/2005/xpath-functions/math";</eg>
        <p>The effect of declaring a default function namespace is that all functions in the default
          function namespace, including implicitly-declared <termref def="dt-constructor-function"
            >constructor functions</termref>, can be invoked without specifying a namespace prefix.
          When a static function call uses a function name with no prefix, the local name of the
          function must match a function (including implicitly-declared <termref
            def="dt-constructor-function">constructor functions</termref>) in the default function
          namespace <errorref class="ST" code="0017"/>.</p>
        <note>
          <p>Only <termref def="dt-constructor-function">constructor functions</termref> can be in
            no namespace.</p>
        </note>
      </item>
    </ulist>
    <p> Unprefixed attribute names and variable names are in no namespace.</p>
  </div2>

  <div2 id="id-annotations">
    <head>Annotations</head>

    <scrap>
      <head></head>
      <prodrecap id="AnnotatedDecl" ref="AnnotatedDecl"/>
      <prodrecap ref="InlineFunctionExpr"/>
      <prodrecap id="Annotation" ref="Annotation"/>
    </scrap>

    <p>XQuery uses annotations to declare properties associated with functions (inline or declared
      in the prolog) and variables. For instance, a function may be declared <code>%public</code> or
        <code>%private</code>. The semantics associated with these properties are described in
        <specref ref="FunctionDeclns"/>.</p>
    <p>Annotations are <code>(QName, value)</code> pairs. If the EQName of the annotation is a
        <termref def="dt-qname">lexical QName</termref>, the prefix of the QName is resolved using
      the statically known namespaces; if no prefix is present, the name is in the
        <code>http://www.w3.org/2012/xquery</code> namespace. </p>


    <p><phrase role="xquery"> Implementations may define further annotations, whose behaviour is
        implementation-defined. For instance, if the <code>eg</code> prefix is bound to a namespace
        associated with a particular implementation, it could define an annotation like
          <code>eg:sequential</code>. 
        <phrase diff="add" at="2015-07-08">If the namespace URI of an annotation<phrase diff="del" at="bug29170">'s
        <termref def="dt-expanded-qname">expanded QName</termref></phrase> is not recognized by the 
        implementation, then the annotation is ignored. </phrase><phrase diff="add" at="bug29170">Implementations may also provide a way for users to define their own annotations.</phrase>
        Implementations must not define annotations in 
         <termref def="dt-reserved-namespaces">reserved namespaces</termref>; it</phrase><phrase role="xpath">It</phrase> 
        <phrase diff="chg" at="bug29170">is a <termref def="dt-static-error">static error</termref> <errorref class="ST" code="0045"/> for a user to define an annotation in a <termref def="dt-reserved-namespaces">reserved namespace</termref>.</phrase>
        <phrase diff="del" at="bug29170">is an error for users to create annotations in the following reserved namespaces <errorref class="ST" code="0045"/>:</phrase>

    <ulist diff="del" at="bug29170">
      <item>
        <p>http://www.w3.org/XML/1998/namespace</p>
      </item>
      <item>
        <p>http://www.w3.org/2001/XMLSchema</p>
      </item>
      <item>
        <p>http://www.w3.org/2001/XMLSchema-instance</p>
      </item>
      <item>
        <p>http://www.w3.org/2005/xpath-functions</p>
      </item>
      <item>
        <p>http://www.w3.org/2005/xpath-functions/math</p>
      </item>
      <item>
        <p>http://www.w3.org/2012/xquery</p>
      </item>
      <item>
        <p diff="add" at="2015-03-17">http://www.w3.org/2005/xpath-functions/array</p>
      </item>
      <item>
        <p diff="add" at="2015-03-17">http://www.w3.org/2005/xpath-functions/map</p>
      </item>
    </ulist>
</p>


    <p> An annotation can provide values explicitly using a parenthesized list of <termref
        def="id-literals">literals</termref>. For instance, the annotation
        <code>%java:method("java.lang.Math.sin")</code> sets the value of the
        <code>java:method</code> annotation to the string value <code>java.lang.Math.sin</code>.</p>

  </div2>


  <div2 id="id-variable-declarations">
    <head>Variable Declaration</head>

    <scrap>
      <head></head>
      <prodrecap ref="AnnotatedDecl"/>
      <prodrecap ref="Annotation"/>
      <prodrecap id="VarDecl" ref="VarDecl"/>
      <prodrecap ref="VarName"/>
      <prodrecap ref="TypeDeclaration"/>
      <prodrecap id="VarValue" ref="VarValue"/>
      <prodrecap id="VarDefaultValue" ref="VarDefaultValue"/>
    </scrap>



    <p>A <term>variable declaration</term> adds the <termref def="dt-static-type">static
        type</termref> of a variable to the <termref def="dt-in-scope-variables">in-scope
        variables</termref>, and may also add a value for the variable to the <termref
        def="dt-variable-values">variable values</termref>. </p>

    <note>
      <p>A <term>variable declaration</term> always refers to a declaration of a variable in a
        Prolog. The binding of a variable to a value in a query expression, such as a FLWOR
        expression, is known as a <term>variable binding</term>, and does not make the variable
        visible to an importing module.</p>
    </note>

    <p>During static analysis, a variable declaration causes a pair <code>(expanded QName N, type
        T)</code> to be added to the <termref def="dt-in-scope-variables">in-scope
        variables</termref>. The expanded QName N is the <code>VarName</code>. If N is equal (as
      defined by the eq operator) to the expanded QName of another variable in in-scope variables, a
        <termref def="dt-static-error">static error</termref> is raised <errorref class="ST"
        code="0049"/>.
        
      <phrase diff="add" at="bug28749">The type T of the declared variable is as follows:</phrase>
    </p>
    <ulist diff="add" at="bug28749">
      <item>
          <p>If <code>TypeDeclaration</code> is present, then the <code>SequenceType</code> in the
          <code>TypeDeclaration</code>; otherwise</p>
      </item>

      <item>
        <p>If the Static Typing Feature is in effect and <code>VarValue</code> is present, then the
           static type inferred from static analysis of the expression <code>VarValue</code>;</p>

        <note>
          <p>Type inference might not be computable until after the check for circular dependencies,
             described below, is complete.</p>
        </note>
      </item>

      <item>
        <p> Otherwise, <code>item()*</code>.</p>
      </item>
    </ulist>

    <p>All variable names declared in a library module must (when expanded) be in the target
      namespace of the library module <errorref class="ST" code="0048"/>. A variable declaration may
      use annotations to specify that the variable is <code>%private</code> or <code>%public</code>
      (which is the default). <termdef id="dt-private-variable" term="private
  variable">A
          <term>private variable</term> is a variable with a <code>%private</code> annotation. A
        private variable is hidden from <termref def="dt-module-import">module import</termref>,
        which can not import it into the <termref def="dt-in-scope-variables">in-scope
          variables</termref> of another module.</termdef>
      <termdef id="dt-public-variable" term="public variable">A <term>public variable</term> is a
        variable without a <code>%private</code> annotation. A public variable is accessible to
          <termref def="dt-module-import">module import</termref>, which can import it into the
          <termref def="dt-in-scope-variables">in-scope variables</termref> of another module. Using
          <code>%public</code> and <code>%private</code> annotations in a main module is not an
        error, but it does not affect module imports, since a main module cannot be imported. It is
        a <termref def="dt-static-error">static error</termref>
        <errorref class="ST" code="0116"/> if a variable declaration contains both a
          <code>%private</code> and a <code>%public</code> annotation, more than one
          <code>%private</code> annotation, or more than one <code>%public</code>
        annotation.</termdef></p>


    <p>Variable names that have no namespace prefix are in no namespace. Variable declarations that
      have no namespace prefix may appear only in a main module.</p>


    <p>Here are some examples of variable declarations:</p>

    <ulist>
      <item>
        <p>The following declaration specifies both the type and the value of a variable. This
          declaration causes the type <code>xs:integer</code> to be associated with variable
            <code>$x</code> in the <termref def="dt-static-context">static context</termref>, and
          the value <code>7</code> to be associated with variable <code>$x</code> in the <termref
            def="dt-dynamic-context">dynamic context</termref>.</p>

        <eg role="frag-prolog-parse-test">declare variable $x as xs:integer := 7;</eg>

      </item>
      <item>
        <p>The following declaration specifies a value but not a type. The <termref
            def="dt-static-type">static type</termref> of the variable is inferred from the static
          type of its value. In this case, the variable <code>$x</code> has a static type of
            <code>xs:decimal</code>, inferred from its value which is 7.5.</p>

        <eg role="frag-prolog-parse-test">declare variable $x := 7.5;</eg>

      </item>
      <item>
        <p>The following declaration specifies a type but not a value. The keyword
            <code>external</code> indicates that the value of the variable will be provided by the
          external environment. At evaluation time, if the variable <code>$x</code> in the <termref
            def="dt-dynamic-context">dynamic context</termref> does not have a value of type
            <code>xs:integer</code>, a <termref def="dt-type-error">type error</termref> is
          raised.</p>
        <eg role="frag-prolog-parse-test">declare variable $x as xs:integer external;</eg>
      </item>
      <item>
        <p>The following declaration specifies neither a type nor a value. It simply declares that
          the query depends on the existence of a variable named <code>$x</code>, whose type and
          value will be provided by the external environment. During query analysis, the type of
            <code>$x</code> is considered to be <code>item()*</code>. During query evaluation, the
            <termref def="dt-dynamic-context">dynamic context</termref> must include a type and a
          value for <code>$x</code>, and its value must be compatible with its type.</p>
        <eg role="frag-prolog-parse-test">declare variable $x external;</eg>
      </item>
      <item>
        <p>The following declaration, which might appear in a library module, declares a variable
          whose name includes a namespace prefix:</p>
        <eg role="frag-prolog-parse-test">declare variable $sasl:username as xs:string := "jonathan@example.com";</eg>
      </item>

      <item>
        <p>This is an example of an external variable declaration that provides a
            <code>VarDefaultValue</code>:</p>
        <eg role="frag-prolog-parse-test">declare variable $x as xs:integer external := 47;</eg>
      </item>
    </ulist>

    <p>
      <phrase diff="del" at="2015-07-04">The syntax for variable
      declarations allows annotations, but XQuery 3.0 does not define
      annotations that apply to variable declarations.</phrase> An
      implementation can provide annotations it needs. For instance,
      an implementation that supports volatile external variables
      might allow them to be declared using an annotation:</p>

    <eg role="frag-prolog-parse-test">declare %eg:volatile variable $time as xs:time external;</eg>

    <p diff="del" at="bug28749">The type of the declared variable is as follows:</p>

    <ulist diff="del" at="bug28749">
      <item>
        <p>If <code>TypeDeclaration</code> is present, then the <code>SequenceType</code> in the
            <code>TypeDeclaration</code>; otherwise</p>
      </item>

      <item>
        <p>If the Static Typing Feature is in effect and <code>VarValue</code> is present, then the
          static type inferred from static analysis of the expression <code>VarValue</code>;</p>

        <note>
          <p>Type inference might not be computable until after the check for circular dependencies,
            described below, is complete.</p>
        </note>
      </item>

      <item>
        <p> Otherwise, <code>item()*</code>.</p>
      </item>
    </ulist>

    <p>
      <termdef term="initializing expression" id="dt-initializing-expression">If a variable
        declaration includes an expression (<code>VarValue</code> or <code>VarDefaultValue</code>),
        the expression is called an <term>initializing expression.</term> The static context for an
        initializing expression includes all functions, variables, and namespaces that are declared
        or imported anywhere in the Prolog, other than the variable being declared.</termdef>
    </p>


    <p>In a module's dynamic context, a variable value (or the context item) may <termref
        def="dt-depends-on">depend on</termref> another variable value (or the context item).
        <termdef id="dt-depends-on" term="depends on">A variable value (or the context item)
          <term>depends on</term> another variable value (or the context item) if, during the
        evaluation of the initializing expression of the former, the latter is accessed through the
        module context.</termdef></p>

    <p>In the following example, the value of variable <code>$a</code>
      <termref def="dt-depends-on">depends on</termref> the value of variable <code>$b</code>
      because the evaluation of $a's initializing expression accesses the value of $b during the
      evaluation of <code>local:f()</code>.</p>

    <eg role="frag-prolog-parse-test">declare variable $a := local:f(); 
declare variable $b := 1;
declare function local:f() { $b }; </eg>

    <p>A directed graph can be built with all variable values and the context item as nodes, and
      with the <termref def="dt-depends-on">depend on</termref> relation as edges. This graph must
      not contain cycles, as it makes the population of the dynamic context impossible. If it is
      discovered, during static analysis or during dynamic evaluation, that such a cycle exists,
      error <errorref class="DY" code="0054"/> must be raised.</p>


    <!-- ================================================= -->

    <p>During query evaluation, each variable declaration causes a pair <code>(expanded QName N,
        value V)</code> to be added to the <termref def="dt-variable-values">variable
        values</termref>. The expanded QName N is the <code>VarName</code>. The value V is as
      follows:</p>

    <ulist>
      <item>
        <p>If <code>VarValue</code> is specified, then V is the result of evaluating
            <code>VarValue</code>.<phrase diff="del" at="bug28749">as described below.</phrase></p>
      </item>

      <item>
        <p> If <code>external</code> is specified, then:</p>

        <ulist>
          <item>
            <p> if a value is provided for the variable by the external environment, then V is that
              value. The means by which typed values of external variables are provided by the
              external environment is implementation-defined.</p>
          </item>

          <item>
            <p> if no value is provided for the variable by the external environment, and
                <code>VarDefaultValue</code> is specified, then V is the result of evaluating
                <code>VarDefaultValue</code>.<phrase diff="del" at="bug28749"> as described below.</phrase></p>
          </item>

          <item>
            <p>If no value is provided for the variable by the external environment, and
                <code>VarDefaultValue</code> is not specified, then a <termref
                def="dt-dynamic-error">dynamic error</termref> is raised <errorref class="DY"
                code="0002"/>. </p>
            <p>It is implementation-dependent whether this error is raised if the evaluation of the
              query does not reference the value of the variable.</p>
          </item>
        </ulist>
      </item>
    </ulist>

    <p>In all cases the value V must match the type T according to the rules for SequenceType
      matching; otherwise a <termref def="dt-type-error">type error</termref> is raised <errorref
        class="TY" code="0004"/>.</p>

    <p diff="del" at="bug28749">If <code>VarValue</code> or <code>VarDefaultValue</code> is evaluated, the static and dynamic
      contexts for the evaluation are the current module's static and dynamic context. </p>


  </div2>

  <div2 id="id-context-item-declarations">
    <head>Context Item Declaration</head>

    <scrap>
      <head></head>
      <prodrecap ref="ContextItemDecl"/>
    </scrap>

    <!-- ================================================================== -->

    <p>A context item declaration allows a query to specify the <termref def="dt-static-type">static
        type</termref>, value, or default value for the <termref def="dt-initial-context-item"
        >initial context item</termref>.</p>

    <p>Only the main module can set the value of the <termref def="dt-initial-context-item">initial
        context item</termref>. In a library module, a context item declaration must be external,
      and specifies only the static type. Specifying a <nt def="VarValue">VarValue</nt> or <nt
        def="VarDefaultValue">VarDefaultValue</nt> for a context item declaration in a library
      module is a static error <errorref class="ST" code="0113"/>.</p>

    <p>In every module that does not contain a context item declaration, the effect is as if the
      declaration</p>

    <eg>declare context item as item() external;</eg>

    <p>appeared in that module.</p>

    <p>During static analysis, the context item declaration has the effect of setting the context
      item static type <code>T</code> in the static context. The context item static type is set to
        <code>ItemType</code> if specified, or to <code>item()</code> otherwise.</p>

    <p>If a module contains more than one context item declaration, a static error is raised
        <errorref class="ST" code="0099"/>.</p>

    <p>The static context for an initializing expression includes all functions, variables, and
      namespaces that are declared or imported anywhere in the Prolog.</p>

    <p>During query evaluation, a <termref def="dt-singleton-focus">singleton focus</termref> is
      created in the dynamic context for the evaluation of the <code>QueryBody</code> in the main
      module, and for the initializing expression of every variable declaration in every module.
      <phrase diff="del" at="bug29027">
      selecting the context item for the singleton focus as follows:
      </phrase>
      <phrase diff="add" at="bug29027">
      The context item of this singleton focus is called
      the <termref def="dt-initial-context-item">initial context item</termref>,
      which is selected as follows:
      </phrase>
      </p>

    <ulist>
      <item>
        <p>If <code>VarValue</code> is specified, then
          <phrase diff="add" at="bug29027">the initial context item is</phrase>
          the result of evaluating <code>VarValue</code>.</p>
        <note diff="add" at="bug29027">
          <p>
            In such a case,
            the initial context item does not obtain its value from the external environment.
            If the external environment attempts to provide a value for the initial context item,
            it is outside the scope of this specification
            whether that is ignored, or results in an error.
          </p>
        </note>
      </item>
      <item>
        <p>If <code>external</code> is specified, then:</p>
        <ulist>
          <item>
            <p><phrase diff="add" at="bug29246">If the declaration occurs in a main module and</phrase> a value is provided for the context item by the external environment, then
              <phrase diff="add" at="bug29027">the initial context item is</phrase>
              that value. <note diff="add" at="bug29246"><p>If the declaration occurs in a library module, then it does not set the value of the initial context item, the value is set by the main module.</p></note></p>
            <p>The means by which an external value is provided by the external environment is
              implementation-defined.</p>
          </item>

          <item>
            <p>If no value is provided for the context item by the external environment, and
                <code>VarDefaultValue</code> is specified, then
                <phrase diff="add" at="bug29027">the initial context item is</phrase>
                the result of evaluating
                <code>VarDefaultValue</code> as described below. </p>
          </item>

        </ulist>
      </item>
    </ulist>

    <p>In all cases where the context item has a value, that value must match the type
        <code>T</code> according to the rules for SequenceType matching; otherwise a type error is
      raised <errorref class="TY" code="0004"/>. If more than one module contains a context item
      declaration, the context item must match the type declared in each one.</p>

    <p>If <code>VarValue</code> or <code>VarDefaultValue</code> is evaluated, the static and dynamic
      contexts for the evaluation are the current module's static and dynamic context.</p>

    <p>Here are some examples of context item declarations.</p>

    <ulist>
      <item>
        <p>Declare the type of the context item:</p>
        <eg role="frag-prolog-parse-test">declare namespace env="http://www.w3.org/2003/05/soap-envelope"; 

declare context item as element(env:Envelope) external;</eg>

      </item>
      <item>
        <p>Declare a default context item, which is a system log in a default location. If the
          system log is in a different location, it can be specified in the external
          environment:</p>
        <eg role="frag-prolog-parse-test">declare context item as element(sys:log) external := doc("/var/xlogs/sysevent.xml")/sys:log; </eg>
      </item>
    </ulist>
  </div2>


  <div2 id="FunctionDeclns">
    <head>Function Declaration</head>
    <p>In addition to the <termref def="dt-built-in-function" diff="chg" at="28282">built-in functions</termref>, XQuery
      allows users to declare functions of their own. A function declaration specifies the name of
      the function, the names and datatypes of the parameters, and the datatype of the result. All
      datatypes are specified using the syntax described in <specref ref="id-types"/>. A function
      declaration causes the declared function to be added to the <termref
        def="dt-known-func-signatures">statically known function signatures</termref> and the
        <termref def="dt-named-functions">named functions</termref> of the <termref def="dt-module"
        >module</termref> in which it appears.</p>

    <scrap>
      <head></head>
      <prodrecap ref="AnnotatedDecl"/>
      <prodrecap ref="Annotation"/>
      <prodrecap id="FunctionDecl" ref="FunctionDecl"/>
      <prodrecap id="ParamList" ref="ParamList"/>
      <prodrecap id="Param" ref="Param"/>
      <prodrecap id="FunctionBody" ref="FunctionBody"/>
      <prodrecap ref="TypeDeclaration"/>
      <prodrecap ref="EnclosedExpr"/>
    </scrap>

    <p> A function declaration specifies whether a function is <termref def="dt-udf"
        >user-defined</termref> or <termref def="dt-external-function">external</termref>.</p>

    <p>
      <termdef id="dt-udf" term="user-defined function">
        <term>User defined functions</term> are functions that contain a <term>function body</term>,
        which provides the implementation of the function as <phrase diff="del" at="####">an XQuery expression</phrase><phrase diff="add" at="####">a <termref def="dt-content-expression">content expression</termref></phrase>.</termdef> The
        <termref def="dt-static-context">static context</termref> for a function body includes all
      functions, variables, and namespaces that are declared or imported anywhere in the <termref
        def="dt-prolog">Prolog</termref>, including the function being declared. Its <termref
        def="dt-in-scope-variables">in-scope variables</termref> component also includes the
      parameters of the function being declared. 

      However, its <termref def="dt-context-item-static-type">context item static type</termref> component is <xtermref spec="DM31" ref="dt-absent"/>,
      <phrase diff="add" at="bug4378">and an implementation should raise a static error <errorref class="ST" code="0008"/> if an expression depends on the context item</phrase>.
    </p>

    <p>
      <phrase diff="add" at="bug29509">In function declarations, </phrase><termref def="dt-external-function">external functions</termref> are identified by the keyword
        <code>external</code>. The purpose of a function declaration for an external function is to
      declare the datatypes of the function parameters and result, for use in type checking of the
      query that contains or imports the function declaration.</p>

    <p diff="add" at="bug29277">In addition to <termref def="dt-udf">user-defined functions</termref>
    and <termref def="dt-external-function">external functions</termref>, &language; allows anonymous
    functions to be declared in the body of a query using <termref def="dt-inline-func">inline function expressions</termref>.</p>

    <p>A function declaration may use the <code>%private</code> or <code>%public</code> annotations
      to specify that a function is public or private; if neither of these annotations is used, the
      function is public. <termdef id="dt-private-function" term="private function">A <term>private
          function</term> is a function with a <code>%private</code> annotation. A private function
        is hidden from <termref def="dt-module-import">module import</termref>, which can not import
        it into the <termref def="dt-known-func-signatures">statically known function
          signatures</termref> of another module. </termdef>
      <termdef id="dt-public-function" term="public function">A <term>public function</term> is a
        function without a <code>%private</code> annotation. A public function is accessible to
          <termref def="dt-module-import">module import</termref>, which can import it into the
          <termref def="dt-known-func-signatures">statically known function signatures</termref> of
        another module. </termdef> Using <code>%public</code> and <code>%private</code> annotations
      in a main module is not an error, but it does not affect module imports, since a main module
      cannot be imported. It is a <termref def="dt-static-error">static error</termref>
      <errorref class="ST" code="0106"/> if a function declaration contains both a
        <code>%private</code> and a <code>%public</code> annotation, more than one
        <code>%private</code> annotation, or more than one <code>%public</code> annotation. </p>

    <p>An XQuery implementation may provide a facility whereby external functions can be implemented<phrase diff="del" at="bug29509">using a host programming language</phrase>, 
      but it is not required to do so. If such a facility is
      provided, the protocols by which parameters are passed to an external function, and the result
      of the function is returned to the invoking query, are <termref
        def="dt-implementation-defined">implementation-defined</termref>. An XQuery implementation
      may augment the type system of <bibref ref="xpath-datamodel-31"/> with additional types that
      are designed to facilitate exchange of data<phrase diff="del" at="bug29509">with host programming languages</phrase>, or it may provide
      mechanism for the user to define such types. For example, a type might be provided that
      encapsulates an object returned by an external function, such as an SQL database connection.
      These additional types, if defined, are considered to be derived by restriction from
        <code>xs:anyAtomicType</code>.</p>

    <p>An implementation can define annotations, in its own namespace, to support functionality
      beyond the scope of this specification. For instance, an implementation that supports external
      Java functions might use an annotation to associate a Java function with an XQuery external
      function:</p>

    <eg role="frag-prolog-parse-test">declare 
   %java:method("java.lang.StrictMath.copySign") 
   function smath:copySign($magnitude, $sign) 
   external;</eg>

    <p>Every declared function must be in a namespace; that is, every declared function name must
      (when expanded) have a non-null namespace URI <errorref class="ST" code="0060"/>. If the
      function name in a function declaration has no namespace prefix, it is considered to be in the
        <termref def="dt-def-fn-ns">default function namespace</termref>. Every function name
      declared in a <termref def="dt-library-module">library module</termref> must (when expanded)
      be in the <termref def="dt-target-namespace">target namespace</termref> of the library module
        <errorref class="ST" code="0048"/>.</p>

    <p diff="chg" at="bug29170"><termdef term="reserved namespaces" id="dt-reserved-namespaces">A <term>reserved namespace</term> is a namespace that must not be used in the name of a function declaration.</termdef>  It is a <termref def="dt-static-error">static error</termref> <errorref class="ST" code="0045"/> if the function name in a function declaration (when expanded) is in a <termref def="dt-reserved-namespaces">reserved namespace</termref>. The following namespaces are reserved namespaces:
    <ulist>
      <item>
        <p>
          <code>http://www.w3.org/XML/1998/namespace</code>
        </p>
      </item>
      <item>
        <p>
          <code>http://www.w3.org/2001/XMLSchema</code>
        </p>
      </item>
      <item>
        <p>
          <code>http://www.w3.org/2001/XMLSchema-instance</code>
        </p>
      </item>
      <item>
        <p>
          <code>http://www.w3.org/2005/xpath-functions</code>
        </p>
      </item>
      <item>
        <p>
          <code>http://www.w3.org/2005/xpath-functions/math</code>
        </p>
      </item>
      <item>
        <p>
          <code>http://www.w3.org/2012/xquery</code>
        </p>
      </item>
      <item>
        <p diff="add" at="2015-07-09"><code>http://www.w3.org/2005/xpath-functions/array</code></p>
      </item>
      <item>
        <p diff="add" at="2015-07-09"><code>http://www.w3.org/2005/xpath-functions/map</code></p>
      </item>
    </ulist>
    </p>

    <p>In order to allow main modules to declare functions for local use within the module without
      defining a new namespace, XQuery predefines the namespace prefix <code>local</code> to the
      namespace <code>http://www.w3.org/2005/xquery-local-functions</code>. It is suggested (but not
      required) that this namespace be used for defining local functions.</p>

    <p>If a function parameter is declared using a name but no type, its default type is
        <code>item()*</code>. If the result type is omitted from a function declaration, its default
      result type is <code>item()*</code>.</p>
    <p>The parameters of a function declaration are considered to be variables whose scope is the
      function body. It is an <termref def="dt-static-error">static error</termref>
      <errorref class="ST" code="0039"/> for a function declaration to have more than one parameter
      with the same name. The type of a function parameter can be any type that can be expressed as
      a <termref def="dt-sequence-type">sequence type</termref>.</p>

    <p> A <code>FunctionDecl</code> defines a function with the following properties: </p>
    <ulist>
      <item>
        <p>
          <term>name</term>: The <code>EQName</code> of the <code>FunctionDecl</code>, expanded (if
          necessary) using the <termref def="dt-static-namespaces">statically known
            namespaces</termref> and <termref def="dt-def-fn-ns">default function
            namespace</termref> of the module's static context. </p>
      </item>

      <item>
        <p>
          <term>parameter names</term>: The <code>EQName</code>s in the <code>ParamList</code>,
          expanded (if necessary) using the <termref def="dt-static-namespaces">statically known
            namespaces</termref> of the module's static context. </p>
      </item>

      <item>
        <p>
          <term>signature</term>: A <code>FunctionTest</code> built from the
            <code>SequenceType</code>s (explicit or implicit) in the <code>FunctionDecl</code> and
          its <code>ParamList</code>, and from any <code>Annotation</code>s preceding the
            <code>FunctionDecl</code>. </p>
      </item>

      <item>
        <p>
          <term>implementation</term>: If the function is declared external, this property is
          implementation-dependent. Otherwise, this property is the <code>FunctionDecl</code>'s
            <code>FunctionBody</code>. </p>
      </item>

      <item>
        <p>
          <term>nonlocal variable bindings</term>: Empty. </p>
      </item>

    </ulist>

    <p>The following example illustrates the declaration and use of a local function that accepts a
      sequence of <code>employee</code> elements, summarizes them by department, and returns a
      sequence of <code>dept</code> elements.</p>
    <ulist>
      <item>
        <p>Using a function, prepare a summary of employees that are located in Denver.</p>
        <eg role="parse-test">declare function local:summary($emps as element(employee)*) as element(dept)* 
{ 
  for $d in fn:distinct-values($emps/deptno) 
  let $e := $emps[deptno = $d]
  return 
     &lt;dept&gt; 
       &lt;deptno&gt;{$d}&lt;/deptno&gt; 
       &lt;headcount&gt; {fn:count($e)}
       &lt;/headcount&gt; 
       &lt;payroll&gt; 
       {fn:sum($e/salary)} 
       &lt;/payroll&gt; 
     &lt;/dept&gt; 
};
          
local:summary(fn:doc("acme_corp.xml")//employee[location = "Denver"])</eg>
      </item>
    </ulist>

    <p>A function declaration may be recursive&mdash;that is, it may reference itself. Mutually
      recursive functions, whose bodies reference each other, are also allowed. The following
      example declares a recursive function that computes the maximum depth of a node hierarchy, and
      calls the function to find the maximum depth of a particular document. The function
        <code>local:depth</code> calls the built-in functions <code>empty</code> and
        <code>max</code>, which are in the default function namespace.</p>
    <ulist>
      <item>
        <p>Find the maximum depth of the document named <code>partlist.xml</code>.</p>
        <eg role="parse-test">
declare function local:depth($e as node()) as xs:integer
{
   (: A node with no children has depth 1 :)
   (: Otherwise, add 1 to max depth of children :)
   if (fn:empty($e/*)) then 1
   else fn:max(for $c in $e/* return local:depth($c)) + 1
};

local:depth(fn:doc("partlist.xml"))
        </eg>
      </item>
    </ulist>

    <!-- ============================================================ -->


    <!-- ============================================================ -->

  </div2>
  <div2 id="id-option-declaration">
    <head>Option Declaration</head>
    <p>
      <termdef term="option declaration" id="dt-option-declaration">An <term>option
          declaration</term> declares an option that affects the behavior of a particular
        implementation. Each option consists of an identifying EQName and a StringLiteral.</termdef>
    </p>
    <scrap>
      <head></head>
      <prodrecap id="OptionDecl" ref="OptionDecl"/>


    </scrap>
    <p>Typically, a particular option will be recognized by some implementations and not by others.
      The syntax is designed so that option declarations can be successfully parsed by all
      implementations.</p>
    <p>If the EQName of an option is a <termref def="dt-qname">lexical QName</termref> with a
      prefix, it must resolve to a namespace URI and local name, using the <termref
        def="dt-static-namespaces">statically known namespaces</termref>
      <errorref class="ST" code="0081"/>.</p>

    <p>If the EQName of an option <phrase diff="add">is a <termref def="dt-qname">lexical QName</termref> that</phrase> does not have a prefix, the <termref def="dt-expanded-qname"
        >expanded QName</termref> is in the <code>http://www.w3.org/2012/xquery</code> namespace,
      which is reserved for option declarations defined by the XQuery family of specifications.
      XQuery does not currently define declaration options in this namespace.</p>

    <p>Each implementation recognizes the <code>http://www.w3.org/2012/xquery</code> namespace URI
      and and all options defined in this namespace in this specification. In addition, each
      implementation recognizes an <termref def="dt-implementation-defined"
        >implementation-defined</termref> set of namespace URIs and an implementation-defined set of
      option names defined in those namespaces. If the namespace part of an option declaration's
      name is not recognized, the option declaration is ignored.</p>
    <p>Otherwise, the effect of the option declaration, including its error behavior, is <termref
        def="dt-implementation-defined">implementation-defined</termref>. For example, if the local
      part of the QName is not recognized, or if the StringLiteral does not conform to the rules
      defined by the implementation for the particular option declaration, the implementation may
      choose whether to raise an error, ignore the option declaration, or take some other
      action.</p>
    <p>Implementations may impose rules on where particular option declarations may appear relative
      to variable declarations and function declarations, and the interpretation of an option
      declaration may depend on its position.</p>
    <p>An option declaration must not be used to change the syntax accepted by the processor, or to
      suppress the detection of <termref def="dt-static-error">static errors</termref>. However, it
      may be used without restriction to modify the semantics of the query. The scope of the option
      declaration is <termref def="dt-implementation-defined"
      >implementation-defined</termref>&mdash;for example, an option declaration might apply to the
      whole query, to the current module, or to the immediately following function declaration.</p>
    <p>The following examples illustrate several possible uses for option declarations:</p>
    <ulist>
      <item>
        <p>This option declaration might be used to specify how comments in source documents
          returned by the <code>fn:doc()</code> function should be handled:</p>
        <eg role="frag-prolog-parse-test">declare option exq:strip-comments "true"; </eg>
      </item>
      <item>
        <p>This option declaration might be used to associate a namespace used in function names
          with a Java class: </p>
        <eg role="frag-prolog-parse-test">declare namespace smath =
          "http://example.org/MathLibrary"; declare option exq:java-class "smath =
          java.lang.StrictMath"; </eg>
      </item>
    </ulist>
  </div2>
</div1>
