<!--XSLT Processor: Saxonica SAXON HE 9.6.0.7--><!--XSLT Processor: Saxonica SAXON HE 9.6.0.7--><!--XSLT Processor: Saxonica SAXON HE 9.6.0.7--><spec xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax" id="spec-top" w3c-doctype="rec" status="ext-review"><header id="id-spec-header"><title>XML Path Language (XPath) 3.1</title><version/><w3c-designation>REC-xpath-31</w3c-designation><w3c-doctype>W3C Recommendation</w3c-doctype><pubdate><day>21</day><month>March</month><year>2017</year></pubdate><publoc>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/TR/2017/REC-xpath-31-20170321/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://www.w3.org/TR/2017/REC-xpath-31-20170321/</loc>
      </publoc><!-- These altlocs URIs are computed from the concatenation of doc.public, doc.shortname, and either '.xml' or
     '-diff-from-yyyymmdd.html', where 'yyyymmdd' is the earlier version of the spec from which a diff has been produced --><altlocs><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/TR/2017/REC-xpath-31-20170321/xpath-31.xml" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML</loc><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/TR/2017/REC-xpath-31-20170321/xpath-31-diff.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Change markings relative to previous edition</loc></altlocs><!-- The latestloc URI is computed from doc.latestloc --><latestloc doc="XPath 3.1">
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/TR/xpath-31/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://www.w3.org/TR/xpath-31/</loc>
      </latestloc><!-- These prevlocs URIs are always hard-coded and are never computed from entities --><!-- Pubrules doesn't like FPWD to have a prevloc, not even a previous Recommendation --><prevlocs doc="XPath 3.1">
  
  
  
  
  
  
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" role="xpath" href="https://www.w3.org/TR/2017/PR-xpath-31-20170117/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://www.w3.org/TR/2017/PR-xpath-31-20170117/</loc>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" role="xpath" href="https://www.w3.org/TR/2016/CR-xpath-31-20161213/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://www.w3.org/TR/2016/CR-xpath-31-20161213/</loc>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" role="xpath" href="https://www.w3.org/TR/2015/CR-xpath-31-20151217/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://www.w3.org/TR/2015/CR-xpath-31-20151217/</loc>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" role="xpath" href="https://www.w3.org/TR/2014/CR-xpath-31-20141218/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://www.w3.org/TR/2014/CR-xpath-31-20141218/</loc>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" role="xpath" href="https://www.w3.org/TR/2014/WD-xpath-31-20141007/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://www.w3.org/TR/2014/WD-xpath-31-20141007/</loc>
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" role="xpath" href="https://www.w3.org/TR/2014/WD-xpath-31-20140424/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://www.w3.org/TR/2014/WD-xpath-31-20140424/</loc>
      </prevlocs><latestloc-major doc="XPath 3">
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/TR/xpath-3/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://www.w3.org/TR/xpath-3/</loc>
      </latestloc-major><latestloc-tech doc="XPath">
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/TR/xpath/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://www.w3.org/TR/xpath/</loc>
      </latestloc-tech><prevrec doc="XPath">
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" role="xpath" href="https://www.w3.org/TR/2014/REC-xpath-30-20140408/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://www.w3.org/TR/2014/REC-xpath-30-20140408/</loc>
  
      </prevrec><authlist><author><name>Jonathan Robie</name><affiliation>
               <phrase>
                  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jonathanrobie.biblicalhumanities.org" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">biblicalhumanities.org</loc>
               </phrase>
            </affiliation><email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:jonathan.robie@biblicalhumanities.org" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">jonathan.robie@biblicalhumanities.org</email></author><author><name>Michael Dyck</name><affiliation>Invited Expert</affiliation><email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:jmdyck@ibiblio.org" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">jmdyck@ibiblio.org</email></author><author><name>Josh Spiegel</name><affiliation>Oracle Corporation</affiliation><email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:josh.spiegel@oracle.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">josh.spiegel@oracle.com</email></author></authlist><!--* N.B. the value of the errataloc href attribute is set in
    * ../style/assemble-spec.xsl
    * when the XQuery or XPath spec is assembled.  If it changes,
    * change it THERE.
    *--><errataloc xmlns:xlink="http://www.w3.org/1999/xlink" role="spec-conditional" href="https://www.w3.org/XML/2017/qt-errata/xquery-31-errata.html" xlink:type="simple"/><translationloc xmlns:xlink="http://www.w3.org/1999/xlink" role="spec-conditional" href="http://www.w3.org/2003/03/Translations/byTechnology?technology=xquery-31" xlink:type="simple"/><!--* Common status section for QT specs.
    * Use is currently not required, but it simplifies things.
    * 
    * Revisions:
    * 2007-01-15 : CMSMcQ : made file, to simplify publication of Rec.
    * 2008-02-15 : JimMelton : cloned from MSM's REC-only material
                     to generalize for all stages
    *--><status id="status"><!-- ************************************************************************** --><!-- * All Status sections must start with the standard boilerplate paragraph * --><!-- *   This entity is defined in status-entities.dtd                        * --><!-- ************************************************************************** --><p>
            <emph>This section describes the status of this
         document at the time of its publication.
         Other documents may supersede this document.
         A list of current W3C publications and the latest
         revision of this technical report can be found in the
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/TR/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">W3C technical reports index</loc>
         at https://www.w3.org/TR/.</emph>
         </p><p>This document is governed by the
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" id="w3c_process_revision" href="https://www.w3.org/2017/Process-20170301/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">1 March 2017 W3C Process Document</loc>. </p><!-- ************************************************************************** --><!-- * QT publishes suites of documents, which must be described in the       * --><!--     Status section of each document within such a suite.                 * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><!-- ************************************************************************** --><!-- * There is a lot of detailed customization based on the document stage   * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><p>This is a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/2015/Process-20150901/#rec-publication" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Recommendation</loc> of the W3C. 
It was jointly developed by the W3C 
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/XML/Query/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML Query Working Group</loc> and the W3C <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Style/XSL/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XSLT Working Group</loc>, each of which is part of the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/XML/Activity" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML Activity</loc>.</p><!-- ************************************************************************** --><!-- * CR documents must cite features at risk                                * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><!-- ************************************************************************** --><!-- * Every Status section must have a customized paragraph                  * --><!-- *   This entity is defined completely in the host document.              * --><!-- ************************************************************************** --><p diff="chg">This Recommendation specifies XPath
                               version 3.1, a fully compatible extension of <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/TR/xpath-30/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XPath version 3.0</loc>.
                               </p><!-- ************************************************************************** --><!-- * CR docs should, and PR docs must, have a pointer to an implementation  * --><!-- *   report.  We also want to point to the test suite.                    * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><p>This specification is designed to be referenced normatively from
other specifications defining a host language for it; it is not
intended to be implemented outside a host language.  The
implementability of this specification has been tested in the context
of its normative inclusion in host languages defined by the
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/TR/xquery-31/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XQuery 3.1</loc>
and
XSLT 3.0 (expected in 2017) specifications;
see the
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://dev.w3.org/2011/QT3-test-suite/ReportingResults31/report.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XQuery 3.1 implementation report</loc>
(and, in the future, the WGs expect that there will also be an
XSLT 3.0 implementation report) for details.</p><!-- ************************************************************************** --><!-- * The Status section should point to a changelog                         * --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><p>No substantive changes have been made to this specification
since its publication as a Proposed Recommendation.</p><!-- ************************************************************************** --><!-- * The Status section must tell readers where to send comments            * --><!-- *   This entity is defined in status-entities.dtd                        * --><!-- ************************************************************************** --><p>Please report errors in this document using W3C's
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public Bugzilla system</loc>
         (instructions can be found at
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/XML/2005/04/qt-bugzilla" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://www.w3.org/XML/2005/04/qt-bugzilla</loc>).
         If access to that system is not feasible, you may send your comments
         to the W3C XSLT/XPath/XQuery public comments mailing list,
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:public-qt-comments@w3.org" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public-qt-comments@w3.org</loc>.
         It will be very helpful if you include the string 
         “[XPath31]”
         in the subject line of your report, whether made in Bugzilla or in email.
         Please use multiple Bugzilla entries (or, if necessary, multiple email messages)
         if you have more than one comment to make.
         Archives of the comments and responses are available at
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://lists.w3.org/Archives/Public/public-qt-comments/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://lists.w3.org/Archives/Public/public-qt-comments/</loc>. </p><!-- ************************************************************************** --><!-- Status sections must state the stability (not stable, or REC) of the document --><!-- *   This entity is defined in the host document.                         * --><!-- ************************************************************************** --><p>This document has been reviewed by W3C Members, by
software developers, and by other W3C groups and interested parties,
and is endorsed by the Director as a W3C Recommendation. 
It is a stable document and may be used as reference material or cited from
another document. 
W3C's role in making the Recommendation is to draw attention to
the specification and to promote its widespread deployment. 
This enhances the functionality and interoperability of
the Web.</p><!-- ************************************************************************** --><!-- * Finally, all Status sections must end with the appropriate IPR para    * --><!-- *   This entity is defined in status-entities.dtd                        * --><!-- ************************************************************************** --><p>This document was produced by groups operating under the
   <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Consortium/Patent-Policy-20040205/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">5 February 2004 W3C Patent Policy</loc>.
   W3C maintains a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/2004/01/pp-impl/18797/status#disclosures" rel="disclosure" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public list of any 
   patent disclosures (W3C XML Query Working Group)</loc> and a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/2004/01/pp-impl/19552/status#disclosures" rel="disclosure" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public list of any patent 
   disclosures (W3C XSLT Working Group)</loc> made in connection with the deliverables of 
   each group; these pages also include instructions for disclosing a patent.
   An individual who has actual knowledge of a patent which the individual believes contains
   <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Essential Claim(s)</loc>
   must disclose the information in accordance with
   <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">section 6 of the W3C Patent Policy</loc>. </p></status><abstract id="id-abstract"><p role="xpath" diff="chg">

XPath 3.1 is an expression language that allows the processing of
values conforming to the data model defined in
<bibref ref="xpath-datamodel-31"/>. The name of the language derives
from its most distinctive feature, the path expression, which provides
a means of hierarchic addressing of the nodes in an XML tree.  As well
as modeling the tree structure of XML, the data model also includes
atomic values, function items, and sequences.  This version of XPath
supports JSON as well as XML, adding maps and arrays to the data model
and supporting them with new expressions in the
language and new functions in <bibref ref="xpath-functions-31"/>.  
These are the most important new features in XPath 3.1:

<olist><item><p>
                     <specref ref="id-maps"/>.</p></item><item><p>
                     <specref ref="id-arrays"/>.</p></item></olist>

XPath 3.1 is a superset of <bibref ref="xpath-30"/>. A detailed list of changes
made since XPath 3.0 can be found in <specref ref="id-revision-log"/>. 
</p></abstract><langusage><language id="EN">English</language><!--
<language id="ebnf">EBNF</language>
--></langusage><revisiondesc id="id-DOESNOTEXIST"><slist><sitem>XQuery 3.1 First Public Working Draft. (#####)</sitem></slist></revisiondesc></header><body><div1 id="id-introduction"><head>Introduction</head><p role="xpath">The primary purpose of XPath is to address the nodes of <phrase diff="chg" at="2015-07-08">XML</phrase> trees <phrase diff="add" at="2016-12-05">and JSON trees</phrase>. 
		XPath gets its name from its use of a path notation for
		navigating through the hierarchical structure of an XML document. XPath uses a compact,
		non-XML syntax to facilitate use of XPath within URIs and XML attribute values. <phrase diff="add" at="2016-12-05">XPath 3.1 adds a similar syntax for navigating JSON trees</phrase>. </p><p>
		          <termdef id="dt-datamodel" term="data model">XPath 3.1 operates on the abstract, logical
			structure of an XML document <phrase diff="add" at="2016-12-05">or JSON object</phrase>, rather than its surface syntax. This logical structure,
			known as the <term>data model</term>, is defined in <bibref ref="xpath-datamodel-31"/>.</termdef>
	        </p><p role="xpath" diff="chg" at="bug29898">
          XPath is designed to be embedded in a host language such as
          <bibref ref="xslt-30"/> or <bibref ref="xquery-31"/>.
          <termdef id="dt-host-language" term="host-language">
          A <term>host language</term> for XPath is a language or
          specification that incorporates XPath as a sublanguage and
          that defines how the static and dynamic context for
          evaluation of XPath expressions are to be
          established.</termdef>
        </p><p>
          
            <phrase diff="chg" at="bug29898" role="xpath">XPath 3.1 is a subset of XQuery 3.1.</phrase>

 In general, any expression that is
		syntactically valid and executes successfully in both <phrase diff="chg" at="bug28782">XPath 3.1 and XQuery 3.1</phrase> will return
		the same result in both languages. There are a few exceptions to this rule: <ulist><item><p>Because XQuery expands 
					<phrase role="xpath"> predefined entity references and character references
					</phrase> and XPath does not, expressions containing these produce different
					results in the two languages. For instance, the value of the string literal
						<code role="parse-test">"&amp;amp;"</code> is <code>&amp;</code> in XQuery,
					and <code>&amp;amp;</code> in XPath. (XPath is often embedded in other
					languages, which may expand predefined entity references or character references
					before the XPath expression is evaluated.)</p></item><item><p>If XPath 1.0 compatibility mode is enabled, XPath behaves differently from
					XQuery in a number of ways, <phrase role="xpath">which are noted throughout this
						document, and listed in <specref ref="id-incompat-in-false-mode"/>.</phrase>
					             </p></item></ulist>
         </p><p>Because these languages are so closely related, their grammars and language descriptions are
		generated from a common source to ensure consistency, and the editors of these
		specifications work together closely.</p><p>XPath 3.1 also depends on and is closely related to the following specifications:</p><ulist><item><p>
                  <bibref ref="xpath-datamodel-31"/> defines the data model that underlies all
				XPath 3.1 expressions.</p></item><item><p>The type system of XPath 3.1 is based on XML Schema. It is implementation-defined
				whether the type system is based on <bibref ref="XMLSchema10"/> or <bibref ref="XMLSchema11"/>.</p></item><item><p>The built-in function library and the operators supported by XPath 3.1 are defined
				in <bibref ref="xpath-functions-31"/>.</p></item></ulist><p role="path" diff="del" at="bug29898">
		          <termdef id="dt-xpath-30-processor" term="XPath 3.0           Processor">An <term>XPath 3.0
				Processor</term> processes a query according to the XPath 3.0
			specification.</termdef>

		          <termdef id="dt-xpath-20-processor" term="XPath 2.0           Processor">An <term>XPath 2.0
				Processor</term> processes a query according to the XPath 2.0
			specification.</termdef>

		          <termdef id="dt-xpath-10-processor" term="XPath 1.0           Processor">An <term>XPath 1.0
				Processor</term> processes a query according to the XPath 1.0
			specification.</termdef>
	        </p><p>This document specifies a grammar for XPath 3.1, using the same basic EBNF notation used in
			<bibref ref="XML"/>. Unless otherwise noted (see <specref ref="lexical-structure"/>),
		whitespace is not significant in <phrase role="xpath">expressions</phrase>. Grammar productions are introduced together with the features
		that they describe, and a complete grammar is also presented in the appendix [<specref ref="nt-bnf"/>]. The appendix is the normative version.</p><p>In the grammar productions in this document, named symbols are underlined and literal text is
		enclosed in double quotes. For example, the following productions describe the syntax of a
		static function call:</p><scrap headstyle="show"><head/><prod num="63" id="noid_d3e390.doc-xpath31-FunctionCall"><lhs>FunctionCall</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-EQName" xlink:type="simple">EQName</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ArgumentList" xlink:type="simple">ArgumentList</nt>
               </rhs><com>
                  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-reserved-function-names" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgc: reserved-function-names</loc>
               </com><com>
                  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-parens" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">gn: parens</loc>
               </com></prod><prod num="50" id="noid_d3e391.doc-xpath31-ArgumentList"><lhs>ArgumentList</lhs><rhs>"("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Argument" xlink:type="simple">Argument</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Argument" xlink:type="simple">Argument</nt>)*)?  ")"</rhs></prod></scrap><p>The productions should be read as follows: A function call consists of an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-EQName" xlink:type="simple">EQName</nt> followed by an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ArgumentList" xlink:type="simple">ArgumentList</nt>. The
		argument list consists of an opening parenthesis, an optional list of one or more arguments
		(separated by commas), and a closing parenthesis.</p><p>This document normatively defines the static and dynamic semantics of XPath 3.1. In this
		document, examples and material labeled as "Note" are provided for explanatory purposes and
		are not normative.</p><p>Certain aspects of language processing are described in this specification as
			<term>implementation-defined</term> or <term>implementation-dependent</term>.</p><ulist><item><p>
				              <termdef id="dt-implementation-defined" term="implementation defined">
                     <term>Implementation-defined</term> indicates an aspect that may differ
					between implementations, but must be specified by the implementor for each
					particular implementation.</termdef>
			            </p></item><item><p>
				              <termdef id="dt-implementation-dependent" term="implementation   dependent">
                     <term>Implementation-dependent</term> indicates an aspect that may differ
					between implementations, is not specified by this or any W3C specification, and
					is not required to be specified by the implementor for any particular
					implementation.</termdef>
			            </p></item></ulist><p role="xpath">A language aspect described in this specification as
			<term>implementation-defined</term> or <term>implementation dependent</term> may be
		further constrained by the specifications of a host language in which XPath is embedded.</p></div1><div1 id="id-basics"><head>Basics</head><p>The basic  building block of XPath 3.1 is the
	 <term>expression</term>, which is a string of <bibref ref="Unicode"/> characters; the version of Unicode to be used is <termref def="dt-implementation-defined">implementation-defined</termref>.
	 The language provides several kinds of expressions which may be constructed
	 from keywords, symbols, and operands. In general, the operands of an expression
	 are other expressions. XPath 3.1 allows expressions to be nested with full
generality. </p><note><p>This specification contains no
assumptions or requirements regarding the character set encoding of strings
of <bibref ref="Unicode"/> characters.</p></note><p>Like XML, XPath 3.1 is a case-sensitive language. Keywords in
	 XPath 3.1 use lower-case characters and are not reserved—that is, names in XPath 3.1 expressions are allowed to be the same as language keywords, except for certain unprefixed function-names listed in <specref ref="id-reserved-fn-names"/>.</p><p>
            <termdef term="value" id="dt-value">In the <termref def="dt-datamodel">data model</termref>, a <term>value</term> is always a <termref def="dt-sequence">sequence</termref>.</termdef> 
            <termdef id="dt-sequence" term="sequence">A
<term>sequence</term> is an ordered collection of zero or more
<termref def="dt-item">items</termref>.</termdef>
            <termdef id="dt-item" term="item">
  An <term>item</term> is either an <termref def="dt-atomic-value">atomic value</termref>, a <termref def="dt-node">node</termref>,
or a <xtermref diff="chg" at="2013-12-07" spec="DM31" ref="dt-function-item">function</xtermref>.</termdef>
            <termdef id="dt-atomic-value" term="atomic value">An <term>atomic
	 value</term> is a value in the value space of an <term>atomic
	 type</term>, as defined in <bibref ref="XMLSchema10"/>  or <bibref ref="XMLSchema11"/>.</termdef>
            <termdef id="dt-node" term="node">A <term>node</term> is an instance of one of the
	  <term>node kinds</term> defined in <xspecref diff="chg" at="bug28277" spec="DM31" ref="Node"/>.</termdef>
Each node has a unique <term>node identity</term>, a <term>typed value</term>, and a <term>string value</term>. In addition, some nodes have a <term>name</term>. The <term>typed value</term> of a node is a sequence
	 of zero or more atomic values. The <term>string value</term> of a node is a
	 value of type <code>xs:string</code>. The <term>name</term> of a node is a value of type <code>xs:QName</code>.</p><p>
            <termdef id="dt-singleton" term="singleton">A sequence containing exactly one item is called a
	 <term>singleton</term>.</termdef> An item is identical to a singleton sequence
	 containing that item. Sequences are never nested—for example, combining the
	 values 1, (2, 3), and ( ) into a single sequence results in the sequence (1, 2,
	 3). <termdef id="dt-empty-sequence" term="empty sequence">A sequence containing zero items is called an <term>empty sequence</term>.</termdef>
         </p><p>
            <termdef id="dt-data-model-instance" term="XDM instance">The term <term>XDM instance</term> is used,
    synonymously with the term <termref def="dt-value">value</termref>, to denote an unconstrained
    <termref def="dt-sequence">sequence</termref> of <termref def="dt-item">items</termref>.</termdef>
            <phrase diff="del" at="2015-07-08"> in the <termref def="dt-datamodel">data model</termref>
            </phrase>
         </p><p>Element nodes have a property called <term>in-scope namespaces</term>. <termdef term="in-scope namespaces" id="dt-in-scope-namespaces">The <term>in-scope namespaces</term> property of an element node is a set of namespace bindings, each of which associates a namespace prefix with a URI.</termdef>
For a given element, one namespace binding may have an empty prefix; the URI of this namespace binding is the default namespace within the scope of the element.</p><p role="xpath">In <bibref ref="xpath"/>, the in-scope namespaces of an element node are represented by a collection of <term>namespace nodes</term> arranged on a <term>namespace axis</term>. 
As of XPath 2.0, the namespace axis is deprecated and need not be supported by a host language. A host language that does not support the namespace axis need not represent namespace bindings in the form of nodes.</p><!-- --><p diff="del" at="2015-06-09">In the XPath 3.1 grammar, most names are specified using the
      <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-EQName" xlink:type="simple">EQName</nt> production, which allows <termref def="dt-qname-deleted">lexical QNames</termref>, and also allows a
      namespace URI to be specified as a literal:</p><p diff="del">In the XPath 3.1 grammar, most names are QNames,
      a concept defined in XML (see <bibref ref="XMLNAMES"/> or
      <bibref ref="XML1.1"/> and <bibref ref="XMLNAMES11"/>).
      XPath 3.1 uses QNames not only for element and attribute names,
      but also for the names of functions, variables, types, and other
      constructs. <termdef id="dt-qname-del" term="lexical QName">A
      <term>lexical QName</term> is a name that conforms to the syntax of
      <xnt xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/REC-xml-names/#NT-QName" xlink:type="simple">
      [http://www.w3.org/TR/REC-xml-names/#NT-QName]</xnt>.</termdef>
         </p><p diff="chg" at="2015-06-09">
            <termdef id="dt-expanded-qname" term="expanded QName">An <term>expanded QName</term> is a
      triple: its components are a prefix, a local name, and a
      namespace URI. In the case of a name in no namespace, the
      namespace URI and prefix are both absent. In the case of a name
      in the default namespace, the prefix is absent.</termdef> When
      comparing two expanded QNames, the prefixes are ignored: the
      local name parts must be equal under the Unicode Codepoint
      Collation, and the namespace URI parts must either both be
      absent, or must be equal under the Unicode Codepoint
      Collation.</p><p>In the 
      <phrase role="xpath" diff="chg" at="bug28896">XPath</phrase> 
      grammar, QNames representing the names of
      elements, attributes, functions, variables, types, or other such
      constructs are written as instances of the grammatical
      production <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-EQName" xlink:type="simple">EQName</nt>.</p><scrap headstyle="show"><head/><prod num="112" id="doc-xpath31-EQName"><lhs>EQName</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-QName" xlink:type="simple">QName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-URIQualifiedName" xlink:type="simple">URIQualifiedName</nt>
               </rhs></prod><prod num="122" id="doc-xpath31-QName"><lhs>QName</lhs><rhs>
                  <xnt xmlns:xlink="http://www.w3.org/1999/xlink" ref="NT-QName" spec="Names" xlink:type="simple">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</xnt>
               </rhs><com>
                  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgc: xml-version</loc>
               </com></prod><prod num="123" id="noid_d3e655.doc-xpath31-NCName"><lhs>NCName</lhs><rhs>
                  <xnt xmlns:xlink="http://www.w3.org/1999/xlink" ref="NT-NCName" spec="Names" xlink:type="simple">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</xnt>
               </rhs><com>
                  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgc: xml-version</loc>
               </com></prod><prod num="117" id="doc-xpath31-URIQualifiedName"><lhs>URIQualifiedName</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-BracedURILiteral" xlink:type="simple">BracedURILiteral</nt>  
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-NCName" xlink:type="simple">NCName</nt>
               </rhs><com>
                  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc>
               </com></prod><prod num="118" id="doc-xpath31-BracedURILiteral"><lhs>BracedURILiteral</lhs><rhs>"Q"  "{"  [^{}]*  "}"</rhs><com>
                  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc>
               </com></prod></scrap><p>The <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-EQName" xlink:type="simple">EQName</nt> production allows a QName to
      be written in one of three ways:
      <ulist><item><p>local-name only (for example, <code>invoice</code>).</p><p>A name written in this form has no prefix, and the rules
        for determining the namespace depend on the context in which
        the name appears. This form is a <termref def="dt-qname">lexical QName</termref>.</p></item><item><p>prefix plus local-name (for example, <code>my:invoice</code>).</p><p>In this case the prefix and local name of the QName are as
        written, and the namespace URI is inferred from the prefix by
        examining the in-scope namespaces in the static context where
        the QName appears; the context must include a binding for the
        prefix. This form is a <termref def="dt-qname">lexical
        QName</termref>.</p></item><item><p>URI plus local-name (for example,
        <code>Q{http://example.com/ns}invoice)</code>.</p><p>In this case the local name and namespace URI are as
        written, and the prefix is absent. This way of writing a QName
        is context-free, which makes it particularly suitable for use
        in  
        <phrase role="xpath" diff="chg" at="bug28896">expressions</phrase>
        that are generated by software. This
        form is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-URIQualifiedName" xlink:type="simple">URIQualifiedName</nt>.  
        <phrase diff="add" at="bug28896">If the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-BracedURILiteral" xlink:type="simple">
        BracedURILiteral</nt> has no content (for example, <code>Q{}invoice</code>) 
        then the namespace URI of the QName is absent.</phrase>
                  </p></item></ulist>
         </p><p diff="del" at="2015-06-09">Names in XPath 3.1 can be bound to namespaces, and are
	  based on the syntax and semantics defined in <bibref ref="XMLNAMES"/>. <termdef id="dt-qname-deleted" term="lexical QName">A
	  <term>lexical QName</term> is a name that conforms to the syntax of
	  <xnt xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/REC-xml-names/#NT-QName" xlink:type="simple">
	  [http://www.w3.org/TR/REC-xml-names/#NT-QName]</xnt>.</termdef>
	  A <termref def="dt-qname">lexical QName</termref> consists of an optional namespace prefix and a local
	  name. If the namespace prefix is present, it is separated
	  from the local name by a colon. A <termref def="dt-qname">lexical QName</termref> with a prefix can be
	  converted into an <termref def="dt-expanded-qname">expanded
	  QName</termref> by resolving its namespace prefix to a
	  namespace URI, using the <termref def="dt-static-namespaces">statically known
	  namespaces</termref>. The semantics of a <termref def="dt-qname">lexical QName</termref> without a prefix depend on the expression in which it is found.</p><p diff="del" at="2015-06-09">
            <termdef id="dt-expanded-qname-deleted" term="expanded QName">An
	  <term>expanded QName</term> consists of an optional
	  namespace URI and a local name. An expanded QName also
	  retains its original namespace prefix (if any), to
	  facilitate casting the expanded QName into a
	  string.</termdef> 
	  Two <termref def="dt-expanded-qname">expanded QNames</termref> are equal if their
	  namespace URIs are equal and their local names are equal
	  (even if their namespace prefixes are not equal). Namespace
	  URIs and local names are compared on a codepoint basis,
	  without further normalization.</p><p diff="del">The <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-EQName" xlink:type="simple">EQName</nt> production
	  allows expanded QNames to be specified using either a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-QName" xlink:type="simple">QName</nt> or a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-URIQualifiedName" xlink:type="simple">URIQualifiedName</nt>, which allows
          the namespace URI to be specified as a literal.</p><p>
            <phrase diff="add" at="2015-11-24">

               <termdef id="dt-qname" term="lexical QName">A
          <term>lexical QName</term> is a name that conforms to the syntax of the
          <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-QName" xlink:type="simple">QName</nt> production</termdef>.
          </phrase>
         </p><p>
	  The namespace URI value in a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-URIQualifiedName" xlink:type="simple">URIQualifiedName</nt> is whitespace normalized according
	  to the rules for the <code>xs:anyURI</code> type in
          <xspecref spec="XS1-2" ref="anyURI" diff="chg" at="bug28279"/> or 
          <xspecref spec="XS11-2" ref="anyURI" diff="chg" at="bug28279"/>. 

          It is a <termref def="dt-static-error">static
          error</termref> 
            <errorref class="ST" code="0070"/> if the
          namespace URI for an EQName is
          <code>http://www.w3.org/2000/xmlns/</code>.
          </p><p>Here are some examples of <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-EQName" xlink:type="simple">EQName</nt>s:</p><ulist><item><p>
                  <code role="parse-test">pi</code> is a <termref def="dt-qname">lexical QName</termref> without a namespace prefix.</p></item><item><p>
                  <code role="parse-test">math:pi</code> is a <termref def="dt-qname">lexical QName</termref> with a namespace prefix.</p></item><item><p>
                  <code role="parse-test">Q{http://www.w3.org/2005/xpath-functions/math}pi</code> specifies the namespace URI using a  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-BracedURILiteral" xlink:type="simple">BracedURILiteral</nt>; it is not a  <termref def="dt-qname">lexical QName</termref>.</p></item></ulist><p>This document uses the following namespace prefixes to represent the namespace URIs with which they are listed. Although these prefixes are used within this specification to refer to the corresponding namespaces, not all of these bindings will necessarily be present in the static context of every expression, and authors are free to use different prefixes for these namespaces, or to bind these prefixes to different namespaces.</p><ulist><item><p>
                  <code>xs = http://www.w3.org/2001/XMLSchema</code>
               </p></item><item><p>
                  <code>fn = http://www.w3.org/2005/xpath-functions</code>
               </p></item><item><p>
                  <code>map = http://www.w3.org/2005/xpath-functions/map</code>
               </p></item><item><p>
                  <code>array = http://www.w3.org/2005/xpath-functions/array</code>
               </p></item><item><p>
                  <code>math = http://www.w3.org/2005/xpath-functions/math</code>
               </p></item><item role="xpath"><p>
                  <code>err = http://www.w3.org/2005/xqt-errors</code> (see <specref ref="id-identifying-errors"/>).</p></item></ulist><p>
            <termdef term="URI" id="dt-URI">Within this specification, the term <term>URI</term> refers to a Universal Resource Identifier as defined in <bibref ref="RFC3986"/> and extended in <bibref ref="RFC3987"/> with the new name <term>IRI</term>.</termdef>
The term URI has been retained in preference to IRI to avoid introducing new names for concepts such as "Base URI" that are defined or referenced across the whole family of XML specifications.</p><note><p>In most contexts, processors are not required to raise errors if a URI is not lexically valid according to  <bibref ref="RFC3986"/> and  <bibref ref="RFC3987"/>. See <specref ref="id-uri-literals"/> for details.</p></note><div2 id="context"><head>Expression Context</head><p>
               <termdef id="dt-expression-context" term="expression context">The <term>expression
		context</term> for a given expression consists of all
		the information that can affect the result of the
		expression.</termdef>
            </p><p>This information is organized into two categories
		called the <termref def="dt-static-context">static
		context</termref> and the <termref def="dt-dynamic-context">dynamic
		context</termref>.</p><div3 id="static_context"><head>Static Context</head><p>
                  <termdef id="dt-static-context" term="static context">The <term>static context</term> of an expression is
		  the information that is available during static analysis of the expression, prior
		  to its evaluation.</termdef> This information can be used to decide whether the
		  expression contains a <termref def="dt-static-error">static error</termref>. </p><p>The individual components of the <termref def="dt-static-context">static context</termref> are described below. 
      <phrase role="xpath">A default initial value for each component must be specified by the host language. 
      The scope of each component is specified in <specref ref="id-xp-static-context-components" role="xpath"/>.</phrase>
               </p><ulist><item><p>
                        <termdef id="dt-xpath-compat-mode" term="XPath 1.0 compatibility     mode">
                           <term>XPath 1.0 compatibility
			 mode.</term>  
                           <phrase role="xpath">This value is <code>true</code> if rules for backward compatibility with XPath Version 1.0 are in effect; otherwise it is <code>false</code>.</phrase>
                        </termdef>
                     </p></item><item><p>
                        <termdef id="dt-static-namespaces" term="statically known namespaces">
                           <term>Statically known namespaces.</term> 
        This is a mapping from prefix to namespace URI that defines all the namespaces that are known during static processing of a given expression.</termdef> The URI value is
whitespace normalized according to the rules for the <code>xs:anyURI</code> type in <xspecref spec="XS1-2" ref="anyURI" diff="chg" at="bug28280"/> or 
<xspecref spec="XS11-2" ref="anyURI" diff="chg" at="bug28280"/>. Note the difference between <termref def="dt-in-scope-namespaces">in-scope namespaces</termref>, which is a dynamic property of an element node, and <termref def="dt-static-namespaces">statically known namespaces</termref>, which is a static property of an expression.</p></item><item><p>
                        <termdef id="dt-def-elemtype-ns" term="default element/type namespace">
                           <term>Default element/type namespace.</term> This is a
				namespace URI or <xtermref spec="DM31" ref="dt-absent"/>. The namespace URI, if present, is used for any unprefixed QName appearing in a
				position where an element or type name is expected.</termdef> The URI value is
whitespace normalized according to the rules for the <code>xs:anyURI</code> type in <xspecref spec="XS1-2" ref="anyURI" diff="chg" at="bug28280"/> or <xspecref spec="XS11-2" ref="anyURI" diff="chg" at="bug28280"/>.</p></item><item><p>
                        <termdef id="dt-def-fn-ns" term="default function namespace">
                           <term>Default function namespace.</term> This is a
				namespace URI or <xtermref spec="DM31" ref="dt-absent"/>. The namespace URI, if present, is used for any unprefixed QName appearing in a position where a function name is expected.</termdef> The URI value is
whitespace normalized according to the rules for the <code>xs:anyURI</code> type in <xspecref spec="XS1-2" ref="anyURI" diff="chg" at="bug28280"/> or <xspecref spec="XS11-2" ref="anyURI" diff="chg" at="bug28280"/>.</p></item><item><p>
                        <termdef id="dt-issd" term="in-scope schema definitions">
                           <term>In-scope schema
			 definitions.</term> This is a generic term
			 for all the element declarations, attribute declarations, and schema type
			 definitions that are in scope during
			 static analysis of an expression.</termdef> It includes the
			 following three
			 parts:</p><ulist><item><p>

			                           <termdef id="dt-is-types" term="in-scope schema type">
                                 <term>In-scope schema types.</term> Each schema type
			        definition is identified either by an <termref def="dt-expanded-qname">expanded
			        QName</termref> (for a <term>named type</term>)
			        or by an <termref def="dt-implementation-dependent">implementation-dependent</termref> type
			        identifier (for an <term>anonymous
			        type</term>). The in-scope schema types include the predefined schema types described in <specref ref="id-predefined-types"/>.

                                

                         </termdef>
                           </p></item><item><p>
                              <termdef id="dt-is-elems" term="in-scope element declarations">
                                 <term>In-scope element declarations.</term> Each element
declaration is identified either by an <termref def="dt-expanded-qname">expanded QName</termref> (for a top-level element
declaration) or by an <termref def="dt-implementation-dependent">implementation-dependent</termref> element identifier (for a
local element declaration). </termdef> An element
declaration includes information about the element's <termref def="dt-substitution-group">substitution group</termref> affiliation.</p><p>
                              <termdef term="substitution group" id="dt-substitution-group">
                                 <term>Substitution groups</term> are defined in <xspecref spec="XS1-1" ref="Element_Equivalence_Class" diff="chg" at="bug28281"/> and 
<xspecref spec="XS11-1" ref="Element_Equivalence_Class" diff="chg" at="bug28281"/>. Informally, the substitution group headed by a given element (called the <term>head element</term>) consists of  the set of elements that can be substituted for the head element without affecting the outcome of schema validation.</termdef>
                           </p></item><item><p>
                              <termdef id="dt-is-attrs" term="in-scope attribute declarations">
                                 <term>In-scope attribute
declarations.</term> Each attribute declaration is identified either
by an <termref def="dt-expanded-qname">expanded QName</termref> (for a top-level attribute declaration) or by an
<termref def="dt-implementation-dependent">implementation-dependent</termref> attribute identifier (for a local attribute
declaration).  </termdef>
                           </p></item></ulist></item><item><p>
                        <termdef id="dt-in-scope-variables" term="in-scope variables">
                           <term>In-scope variables.</term> 
This is a mapping from <termref def="dt-expanded-qname">expanded QName</termref> to type. It defines the
set of variables that are available for reference within an
expression. The <termref def="dt-expanded-qname">expanded QName</termref> is the name of the variable, and the type is the
<termref def="dt-static-type">static type</termref> of the
variable.</termdef>
                     </p><p>
An expression that binds a variable extends the <termref def="dt-in-scope-variables">in-scope variables</termref>, within the scope of the variable, with the variable and its type. 
Within the body of an
<termref def="dt-inline-func">inline function expression</termref>
, the
<termref def="dt-in-scope-variables">in-scope variables</termref> are extended
by the names and types of the <term>function
parameters</term>.</p></item><item><p>
                        <termdef term="context item static type" id="dt-context-item-static-type">
                           <term>Context item static type.</term> This component defines the <termref def="dt-static-type">static type</termref> of the context item within the scope of a given expression.</termdef>
                     </p></item><item><p>
                        <termdef id="dt-known-func-signatures" term="statically known function signatures">
                           <term>Statically known function signatures.</term>
        This is a mapping from (expanded QName, arity) to 
        <xtermref spec="DM31" ref="dt-signature"/>. 
    </termdef>
    The entries in this mapping define the <phrase diff="add" at="2015-05-26">set of 
    <phrase diff="del" at="bug28175">
                              <term>statically known functions</term>
    — those</phrase> functions</phrase> that are available to be called from a 
    <termref def="dt-static-function-call">static function call</termref>,
    or referenced from a 
    <termref def="dt-named-function-ref">named function reference</termref>.
    Each such function is uniquely identified by its 
    <termref def="dt-expanded-qname">expanded QName</termref>
    and arity (number of parameters).
     <phrase diff="add" at="2015-05-26">Given a statically known function's expanded QName and arity,
    this component supplies the function's 
    <xtermref spec="DM31" ref="dt-signature">signature</xtermref>,
    which specifies</phrase> various static properties of the function,
    including types. 
</p><p>The <phrase>statically known</phrase> function signatures include the signatures of functions from a variety of sources, including
             <phrase diff="chg" at="bug28282" role="xpath">the <termref def="dt-built-in-function">built-in functions</termref>.</phrase>
             


                        <phrase role="xpath">Implementations must ensure that no two functions have the same <termref def="dt-expanded-qname">expanded QName</termref> and the same
arity (even if the signatures are consistent).</phrase>
                     </p></item><item><p> 
                        <termdef id="dt-static-collations" term="statically known collations">
                           <term>Statically known collations.</term> This is an <termref def="dt-implementation-defined">implementation-defined</termref>
        mapping from URI to collation. It defines the names of the collations that are available for
				use in processing  expressions.</termdef> 
                        <termdef term="collation" id="dt-collation">A <term>collation</term> is a specification of the manner in which strings and URIs are compared and, by extension, ordered. For a more complete definition of collation, see <bibref diff="del" at="bug28283" ref="xpath-functions-31"/>
                           <xspecref spec="FO31" ref="string-compare" diff="add" at="bug28283"/>.</termdef>
                     </p></item><item><p> 
                        <termdef id="dt-def-collation" term="default collation">
                           <term>Default
				collation.</term> This identifies one of the collations in <termref def="dt-static-collations">statically known collations</termref> as the  collation to be
				used by functions and operators for comparing and ordering values of type <code>xs:string</code> and <code>xs:anyURI</code> (and types derived from them) when no
				explicit collation is
				specified.</termdef>
                     </p></item><item><p>
                        <termdef id="dt-static-base-uri" term="Static Base URI">
                           <term>Static Base URI.</term>
        This is an absolute URI, used to resolve
        
        <phrase role="xpath">relative URI references.</phrase>
                        </termdef>
      
                        <phrase role="xpath">
        If <var>E</var> is a subexpression of <var>F</var> then the Static 
        Base URI of <var>E</var> is the same as the Static Base URI of <var>F</var>.
        There are no constructs in XPath that require resolution of relative URI references 
        during static analysis.
      </phrase>
      The Static Base URI is available during dynamic evaluation by use of the 
      <code>fn:static-base-uri</code> function, and is used implicitly during dynamic 
      evaluation by functions such as <code>fn:doc</code>. Relative URI references are 
      resolved as described in <specref ref="id-resolve-relative-uri"/>.</p></item><item><p> 
                        <termdef id="dt-known-docs" term="statically known  documents">
                           <term>Statically known documents.</term> This is a mapping
from strings to types.  The string represents the absolute URI of a
resource that is potentially available using the <code>fn:doc</code>
function.  The type is the <termref def="dt-static-type">static type</termref> of a call to <code>fn:doc</code>  with the given URI as its
literal argument. </termdef>
If the argument to <code>fn:doc</code> is a
string literal that is not present in <term>statically known documents</term>, then the
<termref def="dt-static-type">static type</termref> of
<code>fn:doc</code> is <code>document-node()?</code>.</p><note><p>The purpose of the <term>statically known
documents</term> is to provide static type information, not to determine
which documents are available. A URI need not be found in the
<term>statically known documents</term> to be accessed using
<code>fn:doc</code>. </p></note></item><item><p>
                        <termdef id="dt-known-collections" term="statically known  collections">
                           <term>Statically known collections.</term> This is a
mapping from strings to types.  The string represents the absolute
URI of a resource that is potentially available using the
<code>fn:collection</code> function.  The type is the type of the
sequence of <phrase diff="del" at="2015-07-07">nodes</phrase>
                           <phrase diff="add" at="2015-07-07">items</phrase> that would result from calling the
<code>fn:collection</code> function with this URI as its
argument.</termdef> If the argument to
<code>fn:collection</code> is a string literal that is not present in
<term>statically known collections</term>, then the <termref def="dt-static-type">static type</termref> of
<code>fn:collection</code> is <code diff="del" at="2015-07-07">node()*</code>
                        <code diff="add" at="2015-07-07">item()*</code>.</p><note><p>The purpose of the <term>statically known
collections</term> is to provide static type information, not to determine
which collections are available. A URI need not be found in the
<term>statically known collections</term> to be accessed using
<code>fn:collection</code>.
</p></note></item><item><p>
                        <termdef id="dt-known-default-collection" term="statically known default collection type">
                           <term>Statically known default collection type.</term> This is the type of the sequence of 
<phrase diff="del" at="2015-07-07">nodes</phrase>
                           <phrase diff="add" at="2015-07-07">items</phrase> that would result from calling the <code>fn:collection</code> function with no arguments.</termdef> Unless initialized to some other value by an implementation, the value of <term>statically known default collection type</term> is  <code diff="del" at="2015-07-07">node()*</code>
                        <code diff="add" at="2015-07-07">item()*</code>.</p></item><item><p>
                        <termdef id="dt-static-decimal-formats" term="statically known decimal formats">
                           <term>Statically known decimal
		      formats.</term> This is a mapping from QNames to decimal formats, with one default format that has no visible name,
		      referred to as the unnamed decimal format. Each
		      format is available for use when formatting numbers using the <code>fn:format-number</code> function.</termdef> 
                     </p><p>Each decimal format defines a set of properties, which control the interpretation of characters
		        in the picture string supplied to the <code>fn:format-number</code>
		        function, and also specify characters to be used in the result
		        of formatting the number.</p><p>The following properties specify characters used both in the picture string, and in the formatted number. In each case the value is a single character:</p><ulist><item><p>
                              <termdef id="id-static-decimal-format-decimal-separator" term="decimal-separator">
                                 <term>decimal-separator</term> is
		          the character used to separate the integer part of the number from the fractional part, both in the picture
		          string and in the formatted number; the default
		          value is the period character (.)</termdef>
                           </p></item><item><p diff="add" at="2014-04-07">
                              <termdef id="id-static-decimal-format-exponent-separator" term="exponent-separator">
                                 <term>exponent-separator</term> is
		          the character used to separate the mantissa from the exponent in
		          scientific notation both in the picture string and in the
		          formatted number; the default value is the character (e).</termdef>
                           </p></item><item><p>
                              <termdef id="id-static-decimal-format-grouping-separator" term="grouping-separator">
                                 <term>grouping-separator</term>
		          is the character typically used as a thousands separator, both in the picture string and in the formatted number; the default value is the
		          comma character (,)</termdef>
                           </p></item><item><p>
                              <termdef id="id-static-decimal-format-percent" term="percent">
                                 <term>percent</term>
		          is the character used both in the picture string and in the formatted number to indicate that the number is written as a per-hundred fraction; the default
		          value is the percent character (%)</termdef>
                           </p></item><item><p>
                              <termdef id="id-static-decimal-format-per-mille" term="per-mille">
                                 <term>per-mille</term>
		          is the character used both in the picture string and in the formatted number to indicate that the number is written as a per-thousand fraction; the default
		          value is the Unicode per-mille character
		          (#x2030)</termdef>
                           </p></item><item><p>
                              <termdef id="id-static-decimal-format-zero-digit" term="zero-digit">
                                 <term>zero-digit</term>
		          is the character used to represent the digit zero; the default
		          value is the Western digit zero (#x30). This character must be a digit
		          (category Nd in the Unicode property database), and it must have
		          the numeric value zero. This property implicitly defines the
		          ten Unicode characters that are used to represent the values 0
		          to 9: Unicode is organized so that each
		          set of decimal digits forms a contiguous block of characters in
		          numerical sequence. Within the picture string any of these ten character 
		          can be used (interchangeably) as a place-holder for a mandatory digit.
		          Within the final result string, these ten characters are used to represent
		          the digits zero to nine.</termdef>
                           </p></item></ulist><p>The following properties specify 
		        characters to be used in the picture string supplied to the <code>fn:format-number</code>
		        function, but not in the formatted number. In each case the value must be a single character.
		      </p><ulist><item><p>
                              <termdef id="id-static-decimal-format-digit" term="digit">
                                 <term>digit</term> 
		          is a character used in the picture string to represent an optional digit; the default value is the number sign character (#)</termdef>
                           </p></item><item><p>
                              <termdef id="id-static-decimal-format-pattern-separator" term="pattern-separator">
                                 <term>pattern-separator</term> is a character used
		          to separate positive and negative sub-pictures
		          in a picture string; the default value is the semi-colon character (;)</termdef>
                           </p></item></ulist><p>The following properties specify characters or strings that
		        may appear in the result of formatting the number, but not in the picture string:</p><ulist><item><p>
                              <termdef id="id-static-decimal-format-infinity" term="infinity">
                                 <term>infinity</term> is the string used to represent the double value infinity (<code>INF</code>); the
		          default value is the string "Infinity"</termdef>
                           </p></item><item><p>
                              <termdef id="id-static-decimal-format-NaN" term="NaN">
                                 <term>NaN</term> is the string used to
		          represent the double value NaN (not-a-number); the default value is the string "NaN"</termdef>
                           </p></item><item><p>
                              <termdef id="id-static-decimal-format-minus-sign" term="minus-sign">
                                 <term>minus-sign</term> is the single character used to mark negative numbers; the
		          default value is the hyphen-minus character (#x2D). </termdef>
                           </p></item></ulist></item></ulist></div3><div3 id="eval_context"><head>Dynamic Context</head><p>
                  <termdef id="dt-dynamic-context" term="dynamic context">The <term>dynamic
context</term> of an expression is defined as information that is needed for the dynamic evaluation of an expression.</termdef> If
evaluation of an expression relies on some part of the <termref def="dt-dynamic-context">dynamic context</termref> that 
is <xtermref spec="DM31" ref="dt-absent"/>, a <termref def="dt-dynamic-error">dynamic
error</termref> is raised <errorref class="DY" code="0002"/>.</p><p>The individual
components of the <termref def="dt-dynamic-context">dynamic
context</termref> are described below. 

<phrase role="xpath">Further rules governing the semantics of these components can be found in <specref ref="id-xp-evaluation-context-components" role="xpath"/>.</phrase>
               </p><p>The
<termref def="dt-dynamic-context">dynamic context</termref> consists
of all the components of the <termref def="dt-static-context">static
context</termref>, and the additional components listed below.</p><p>
                  <termdef id="dt-focus" term="focus">The first three components of
the <termref def="dt-dynamic-context">dynamic context</termref>
(context item, context position, and context size) are called the
<term>focus</term> of the expression. </termdef> The focus enables the
processor to keep track of which items are being processed by the
expression.



<phrase role="xpath" diff="chg" at="bug29227">If any component in the focus is defined, both the context item and context position are known.</phrase> 
                  <note role="xpath" diff="add" at="bug29227"><p>If any component in the focus is defined, context size is usually defined as well.  However, when streaming, 
the context size cannot be determined without lookahead, so it may be undefined.  If so, expressions like <code>last()</code> will raise a dynamic error because the context size is undefined.</p></note>

                  <termdef id="dt-singleton-focus" term="singleton focus">A <term>singleton focus</term> is a focus that refers to a single item; in a singleton focus, context item is set to the item, context position = 1 and context size = 1.</termdef>
               </p><p>Certain language constructs, notably the <termref def="dt-path-expression">path
operator</termref> 
                  <code role="parse-test">E1/E2</code>, the <phrase diff="chg" at="2015-07-08">
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SimpleMapExpr" xlink:type="simple">simple map operator</nt> 
                     <code role="parse-test">E1!E2</code>
                  </phrase>, and the <termref def="dt-predicate">predicate</termref> 
                  <code role="parse-test">E1[E2]</code>, create a new focus
for the evaluation of a sub-expression. In these constructs, <code role="parse-test">E2</code> is evaluated once for each item in the
sequence that results from evaluating <code role="parse-test">E1</code>. Each time <code role="parse-test">E2</code> is evaluated, it is evaluated with a
different focus. The focus for evaluating <code role="parse-test">E2</code> is referred to below as the <term>inner
focus</term>, while the focus for evaluating <code role="parse-test">E1</code> is referred to as the <term>outer
focus</term>. The inner focus is used only for the evaluation of <code role="parse-test">E2</code>. Evaluation of E1 continues with its original focus unchanged.</p><ulist><item><p>
                        <termdef id="dt-context-item" term="context item">The <term>context item</term>
is the <termref def="dt-item">item</termref> currently being processed.</termdef>
                        <termdef id="dt-context-node" term="context node">When the context item is a
node, it can also be referred to as the <term>context
node</term>.</termdef> The context item is returned by an expression
consisting of a single dot (<code role="parse-test">.</code>). When an expression <code role="parse-test">E1/E2</code> or <code role="parse-test">E1[E2]</code> is evaluated, each item in the
sequence obtained by evaluating <code role="parse-test">E1</code>
becomes the context item in the inner focus for an evaluation of <code role="parse-test">E2</code>. </p><p role="xpath" diff="del" at="2015-07-06">The <term>initial context item</term> is a context item that an implementation can set before processing a query begins. 
  The query body and the prolog of every module in a query share the same initial context item.</p></item><item><p>
                        <termdef id="dt-context-position" term="context position">The <term>context
position</term> is the position of the context item within the
sequence of items currently being processed.</termdef> It changes whenever the context item
changes. When the focus is defined, the value of the context position is an integer greater than zero. The context
position is returned by the expression <code role="parse-test">fn:position()</code>. When an expression <code role="parse-test">E1/E2</code> or <code role="parse-test">E1[E2]</code> is evaluated, the context position in
the inner focus for an evaluation of <code role="parse-test">E2</code>
is the position of the context item in the sequence obtained by
evaluating <code role="parse-test">E1</code>. The position of the
first item in a sequence is always 1 (one). The context position is
always less than or equal to the context size.</p></item><item><p>
                        <termdef id="dt-context-size" term="context size">The <term>context
size</term> is the number of items in the sequence of items currently
being processed.</termdef> Its value is always an
integer greater than zero. The context size is returned by the
expression <code role="parse-test">fn:last()</code>. When an expression
<code role="parse-test">E1/E2</code> or <code role="parse-test">E1[E2]</code> is evaluated, the context size in the
inner focus for an evaluation of <code role="parse-test">E2</code> is
the number of items in the sequence obtained by evaluating <code role="parse-test">E1</code>. </p></item><item><p> 
                        <termdef id="dt-variable-values" term="variable values">
                           <term>Variable values</term>. 
        This is a mapping from <termref def="dt-expanded-qname">expanded QName</termref> to value. 
        It contains the
				same <termref def="dt-expanded-qname">expanded QNames</termref> as the <termref def="dt-in-scope-variables">in-scope variables</termref> in the
				<termref def="dt-static-context">static context</termref> for the expression. The <termref def="dt-expanded-qname">expanded QName</termref> is the name of the variable and the value is the dynamic value of the variable, which includes its <termref def="dt-dynamic-type">dynamic type</termref>.</termdef>
                     </p></item><item><p>
                        <termdef term="named functions" id="dt-named-functions">
                           <term>Named functions</term>.
        This is a mapping from (expanded QName, arity) to 
        <xtermref spec="DM31" ref="dt-function-item">function</xtermref>.
      </termdef>
      It supplies a function for each signature in 
      <termref def="dt-known-func-signatures">
        statically known function signatures
      </termref>
      and may supply other functions 
      (see <specref ref="id-consistency-constraints"/>).  Named functions can include 
      <phrase diff="del" at="bug29277">functions with implementation-dependent implementations; these functions do not have a static context or a dynamic context of their own.</phrase>
                        <phrase diff="add" at="bug29509">
                           <termref def="dt-external-function">external functions</termref>.
      <termdef id="dt-external-function" term="external function">
                              <term>External functions</term> are functions that are implemented outside the query
        environment.</termdef> For example, an implementation might provide a set of 
        <termref def="dt-implementation-defined">implementation-defined</termref>
        external functions in addition to the core function library described in <bibref ref="xpath-functions-31"/>. 
      <termdef id="dt-implementation-defined-function" term="implementation-defined function">An <term>implementation-defined function</term> is an <termref def="dt-external-function" diff="chg" at="bug29509">external function</termref> that is <termref def="dt-implementation-defined">implementation-defined</termref>
                           </termdef>.
        </phrase>
                        <phrase role="xpath">
                           <termdef id="dt-host-language-function" term="host language function" role="xpath">A <term>host language function</term> is an <termref def="dt-external-function">external function</termref> defined by the <termref def="dt-host-language">host language</termref>.</termdef>
                        </phrase>
                     </p></item><item><p> 
                        <termdef id="dt-date-time" term="current dateTime">
                           <term>Current dateTime.</term> This information represents
				an <termref def="dt-implementation-dependent">implementation-dependent</termref> point in time during the processing of <phrase role="xpath">an expression</phrase>, and includes an explicit timezone. It can be retrieved by the  <code>fn:current-dateTime</code> function. If invoked multiple times during the execution of <phrase role="xpath">an expression</phrase>,
				this function always returns the same result.</termdef>
                     </p></item><item><p>
                        <termdef id="dt-timezone" term="implicit timezone">
                           <term>Implicit timezone.</term> This is the timezone to be used when a date,
time, or dateTime value that does not have a timezone is used in a
comparison or arithmetic operation. The implicit timezone is an  <termref def="dt-implementation-defined">implementation-defined</termref> value of type
<code>xs:dayTimeDuration</code>. See <xspecref spec="XS1-2" ref="dateTime-timezones" diff="chg" at="bug28284"/> or
<xspecref spec="XS11-2" ref="dateTime" diff="chg" at="bug28284"/> for the range of valid values of a timezone.</termdef>
                     </p></item><item><p>
                        <termdef id="dt-default-language" term="default language">
                           <term>Default language.</term>
  This is the natural language used when creating human-readable output
  (for example, by the functions <code>fn:format-date</code> and <code>fn:format-integer</code>)
  if no other language is requested. 
  The value is a language code as defined by the type <code>xs:language</code>.</termdef>
                     </p></item><item><p>
                        <termdef id="dt-default-calendar" term="default calendar">
                           <term>Default calendar.</term>
    This is the calendar used when formatting dates in human-readable output
    (for example, by the functions <code>fn:format-date</code> and <code>fn:format-dateTime</code>)
    if no other calendar is requested. 
    The value is a string.</termdef>
                     </p></item><item><p>
                        <termdef id="dt-default-place" term="default place">
                           <term>Default place.</term>
    This is a geographical location used to identify the place where events happened (or will happen) when
    formatting dates and times using functions such as <code>fn:format-date</code> and <code>fn:format-dateTime</code>,
    if no other place is specified. It is used when translating timezone offsets to civil timezone names,
    and when using calendars where the translation from ISO dates/times to a local representation is dependent
    on geographical location. Possible representations of this information are an ISO country code or an
    Olson timezone name, but implementations are free to use other representations from which the above
    information can be derived.</termdef>
                     </p></item><item><p>
                        <termdef id="dt-available-docs" term="available documents">
                           <term>Available
    documents.</term> This is a mapping of strings to document nodes.  Each string
    represents the absolute URI of a resource. The document node is the root of a tree that represents that resource 
    using the <termref def="dt-datamodel">data model</termref>. The document node is returned by the <code>fn:doc</code> 
    function when applied to that URI.</termdef> The set of available documents is not limited to the set of 
    <termref def="dt-known-docs">statically known documents</termref>, and it may be empty.</p><p>If there are one or more 
    URIs in <termref def="dt-available-docs">available documents</termref> that map to a document
    node <code>D</code>, then the document-uri property of <code>D</code> must either be absent, or must
    be one of these URIs.</p><note><p>This means that given a document node <code>$N</code>, the result of
    <code role="parse-test">fn:doc(fn:document-uri($N)) is $N</code> will always be <code>true</code>, unless
  <code role="parse-test">fn:document-uri($N)</code> is an empty sequence.</p></note></item><item><p>
                        <termdef id="dt-available-text-resources" term="available text resources">
                           <term>Available text resources</term>. 
  This is a mapping of strings to text resources. Each string
  represents the absolute URI of a resource. The resource is returned
  by the <code>fn:unparsed-text</code> function when applied to that
  URI.</termdef> The set of available text resources is not limited to
  the set of <termref def="dt-known-docs">statically known
  documents</termref>, and it may be empty.</p></item><item><p>
                        <termdef id="dt-available-collections" term="available item collections">
                           <term>Available
                          <phrase diff="del" at="bug28957">node</phrase> collections.</term> This is a mapping of
                         strings to sequences of <phrase diff="del" at="2015-07-07">nodes</phrase>
                           <phrase diff="add" at="2015-07-07">items</phrase>. Each string
                         represents the absolute URI of a
                         resource. The sequence of <phrase diff="del" at="2015-07-07">nodes</phrase>
                           <phrase diff="add" at="2015-07-07">items</phrase> represents
                         the result of the <code>fn:collection</code>
                         function when that URI is supplied as the
                         argument. </termdef> The set of available
                           <phrase diff="del" at="bug28957">node</phrase> collections is not limited to the set of <termref def="dt-known-collections">statically known
                         collections</termref>, and it may be empty.</p><p>For every document node <code>D</code> that is in the target of a mapping in <termref def="dt-available-collections">available  <phrase diff="del" at="bug28957">node</phrase> collections</termref>, or that is the root of a tree containing such a node, the document-uri property of <code>D</code> must either be absent, or must be a
URI <code>U</code> such that <termref def="dt-available-docs">available documents</termref> contains a mapping from <code>U</code> to <code>D</code>.

</p><note><p>This means that for any document node <code>$N</code> retrieved using the
<code>fn:collection</code> function, either directly or by navigating to the root of a
node that was returned, the result of <code role="parse-test">fn:doc(fn:document-uri($N)) is $N</code>
will always be <code>true</code>, unless <code>fn:document-uri($N)</code> is an empty sequence. This
implies a requirement for the <code>fn:doc</code> and <code>fn:collection</code> functions to be
consistent in their effect. If the implementation uses catalogs or
user-supplied URI resolvers to dereference URIs supplied to the <code>fn:doc</code>
function, the implementation of the <code>fn:collection</code> function must take these
mechanisms into account. For example, an implementation might achieve this
by mapping the collection URI to a set of document URIs, which are then
resolved using the same catalog or URI resolver that is used by the <code>fn:doc</code> function.</p></note></item><item><p>
                        <termdef id="dt-default-collection" term="default collection">
                           <term>Default <phrase diff="del" at="bug28957">node</phrase> collection.</term>
    This is the sequence of <phrase diff="del" at="2015-07-07">nodes</phrase>
                           <phrase diff="add" at="2015-07-07">items</phrase>  that would result from calling the <code>fn:collection</code> function
    with no arguments.</termdef> The value of <term>default  <phrase diff="del" at="bug28957">nodes</phrase> collection</term> may be initialized by the
    implementation.</p></item><item><p>
                        <termdef id="dt-available-uri-collections" term="available uri collections">
                           <term>Available
    <phrase diff="del" at="bug28957">resource</phrase>
                              <phrase diff="add" at="bug28957">URI</phrase> collections.</term> This is a mapping of
    strings to sequences of URIs. The string
    represents the absolute URI of a
    resource which can be interpreted as an aggregation of a number of individual resources each of which
    has its own URI. The sequence of URIs represents
    the result of the <code>fn:uri-collection</code>
    function when that URI is supplied as the
    argument. </termdef> There is no implication that the URIs in this sequence
    can be successfully dereferenced, or that the resources they refer to have any particular media type.</p><note><p>An implementation <rfc2119>may</rfc2119> maintain some consistent relationship between the available
  <phrase diff="del" at="bug28957">node</phrase>  collections and the available <phrase diff="del" at="bug28957">resource</phrase>
                           <phrase diff="add" at="bug28957">URI</phrase> collections, for example by ensuring that the result of
  <code>fn:uri-collection(X)!fn:doc(.)</code> is the same as the result of <code>fn:collection(X)</code>.
    However, this is not required. The <code>fn:uri-collection</code> function is more 
    general than <code>fn:collection</code> in that it allows access to resources other 
    than XML documents; at the same time, <code>fn:collection</code> allows access to 
    nodes that might lack individual URIs, for example nodes corresponding 
    to XML fragments stored in the rows of a relational database.</p></note></item><item><p>
                        <termdef id="dt-default-uri-collection" term="default URI collection">
                           <term>Default <phrase diff="del" at="bug28957">resource</phrase>
                              <phrase diff="add" at="bug28957">URI</phrase> collection.</term>
    This is the sequence of URIs that would result from calling the <code>fn:uri-collection</code> function
    with no arguments.</termdef> The value of <term>default <phrase diff="del" at="bug28957">resource</phrase>
                           <phrase diff="add" at="bug28957">URI</phrase> collection</term> may be initialized by the
    implementation.</p></item><item><p>
                        <termdef id="dt-environment-variables" term="environment variables">
                           <term>Environment variables.</term>
  This is a mapping from names to values. 
    Both the names and the values are strings. The names are compared using an
    <termref def="dt-implementation-defined">implementation-defined</termref> collation, and are unique under this collation. The set of environment variables is
  <termref def="dt-implementation-defined">implementation-defined</termref> and <rfc2119>may</rfc2119> be empty.</termdef>
                     </p><note><p>A possible implementation is to provide the set of POSIX environment variables (or their equivalent on other
      operating systems) appropriate to the process in which the <phrase role="xpath">expression is evaluated</phrase>.</p></note></item></ulist></div3></div2><div2 id="id-processing-model"><head>Processing
                         Model</head><p>XPath 3.1 is defined in terms
                         of the <termref def="dt-datamodel">data
                         model</termref> and the <termref def="dt-expression-context">expression
                         context</termref>.</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="ProcMod-XPath.gif" alt="Processing                          Model Overview" role="xpath" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>Figure 1:
                         Processing Model Overview</p><p>Figure 1 provides a schematic overview of the processing steps that
are discussed in detail below. Some of these steps are completely
outside the domain of XPath 3.1; in Figure 1, these are depicted
outside the line that represents the boundaries of the language, an
area labeled <term>external processing</term>. The external processing
domain includes generation of <termref def="dt-data-model-instance">XDM instances</termref> that represent the data to be queried (see <specref ref="id-data-model-generation"/>), schema import processing (see
<specref ref="id-schema-import-processing"/>) and serialization. The area inside the boundaries of
the language is known as the <phrase role="xpath">
                  <term>XPath processing domain</term>
               </phrase>, which includes the static
analysis and dynamic evaluation phases (see <specref ref="id-expression-processing"/>).  Consistency constraints on the
<phrase role="xpath">XPath</phrase> processing domain are defined in <specref ref="id-consistency-constraints"/>.</p><div3 id="id-data-model-generation"><head>Data Model Generation</head><p>The input data for <phrase role="xpath">an expression</phrase> must be represented as one or more <termref def="dt-data-model-instance">XDM instances</termref>. This process occurs outside
the domain of XPath 3.1, which is why Figure 1 represents it in the
external processing domain. Here are some steps by which an XML
document might be converted to an <termref def="dt-data-model-instance">XDM instance</termref>:</p><olist><item><p>A document may be parsed using an XML parser that
generates an <term>XML Information Set</term> (see <bibref ref="XINFO"/>). The parsed document may then be validated against one
or more schemas. This process, which is described in <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/xmlschema-1/" diff="chg" at="bug28286" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">[XML Schema 1.0 Part 1]</loc> or
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/xmlschema11-1/" diff="chg" at="bug28286" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">[XML Schema 1.1 Part 1]</loc>, results in an abstract information structure called
the <term>Post-Schema Validation Infoset</term> (PSVI). If a document
has no associated schema, its Information Set is preserved. (See DM1
in Fig. 1.)</p></item><item><p>The Information Set or PSVI may be
transformed into an <termref def="dt-data-model-instance">XDM instance</termref>
by a process described in <bibref ref="xpath-datamodel-31"/>. (See DM2 in
Fig. 1.)</p></item></olist><p>The above steps provide an example of how an <termref def="dt-data-model-instance">XDM instance</termref> might be constructed. An XDM instance might
also be synthesized directly from a relational database, or
constructed in some other way (see DM3 in Fig. 1.) XPath 3.1 is defined in terms
of the <termref def="dt-datamodel">data model</termref>,
but it does not place any constraints on how XDM instances are constructed.</p><p>
                  <termdef term="type annotation" id="dt-type-annotation">Each element node and attribute node in an <termref def="dt-data-model-instance">XDM instance</termref> has a <term>type annotation</term> (described in <xspecref diff="chg" at="bug28288" spec="DM31" ref="types"/>). 
The type annotation of a node is a reference to an XML Schema type. 
</termdef>  The <code>type-name</code> of a node is the name of the type referenced by its <termref def="dt-type-annotation">type annotation</termref>. 
If the <termref def="dt-data-model-instance">XDM instance</termref> was derived from a validated XML document as described in <xspecref spec="DM31" ref="const-psvi"/>, the type annotations of the element and attribute nodes are derived from schema
validation. XPath 3.1 does
not provide a way to directly access the type annotation of an element
or attribute node.</p><p>The value of an attribute is represented directly within the
attribute node. An attribute node whose type is unknown (such as might
occur in a schemaless document) is given the <termref def="dt-type-annotation">type annotation</termref>
                  <code>xs:untypedAtomic</code>.</p><p>The value of an element is represented by the children of the
element node, which may include text nodes and other element
nodes. The <termref def="dt-type-annotation">type annotation</termref> of an element node indicates how the values in
its child text nodes are to be interpreted. An element that has not been validated (such as might occur in a schemaless document) is annotated
with the schema type <code>xs:untyped</code>. An element that has been validated and found to be partially valid is annotated with the schema type <code>xs:anyType</code>. If an element node is annotated as <code>xs:untyped</code>, all its descendant element nodes are also annotated as <code>xs:untyped</code>. However, if an element node is annotated as <code>xs:anyType</code>, some of its descendant element nodes may have a more specific <termref def="dt-type-annotation">type annotation</termref>.</p></div3><div3 id="id-schema-import-processing"><head>Schema Import Processing</head><p role="xpath">The <termref def="dt-issd">in-scope schema
definitions</termref> in the <termref def="dt-static-context">static
context</termref> are provided by the host language (see step SI1 in
Figure 1) and must satisfy the consistency constraints defined in
<specref ref="id-consistency-constraints"/>.

</p></div3><div3 id="id-expression-processing"><head>Expression
Processing</head><p>XPath 3.1 defines two phases of processing called
the <termref def="dt-static-analysis">static analysis phase</termref>
and the <termref def="dt-dynamic-evaluation">dynamic evaluation
phase</termref> (see Fig. 1).  During the static analysis phase, <termref def="dt-static-error">static errors</termref>,  <termref def="dt-dynamic-error">dynamic errors</termref>, or <termref def="dt-type-error">type errors</termref> may be raised. During the dynamic evaluation phase, only <termref def="dt-dynamic-error">dynamic errors</termref> or <termref def="dt-type-error">type errors</termref> may be raised. These kinds of errors are defined in <specref ref="id-kinds-of-errors"/>.  </p><p>Within each phase, an implementation is free to use any
strategy or algorithm whose result conforms to the
specifications in this document.</p><div4 id="id-static-analysis"><head>Static Analysis Phase</head><p>
                     <termdef id="dt-static-analysis" term="static analysis phase">The
<term>static analysis phase</term> depends on the expression itself
and on the <termref def="dt-static-context">static context</termref>. The <term>static analysis phase</term> does
not depend on input data (other than schemas).</termdef>
                  </p><p>During the static analysis phase, the <phrase role="xpath">XPath expression</phrase> is parsed into an
internal representation called the <term>operation tree</term> (step
SQ1 in Figure 1).  A parse error is raised as a <termref def="dt-static-error">static error</termref> 
                     <errorref class="ST" code="0003"/>. The <termref def="dt-static-context">static context</termref> is initialized by the implementation (step SQ2).  The <termref def="dt-static-context">static context</termref> is used to resolve schema type names, function names, namespace prefixes, and variable names (step
SQ4).
If a name of one of these kinds in the <term>operation tree</term> is
not found in the <termref def="dt-static-context">static context</termref>, a <termref def="dt-static-error">static error</termref> (<errorref class="ST" code="0008"/> or <errorref class="ST" code="0017"/>) is raised (however, see exceptions to this rule in <specref ref="id-element-test"/> and <specref ref="id-attribute-test"/>.)</p><p>The <term>operation tree</term> is then
<term>normalized</term> by making explicit the implicit operations
such as <termref def="dt-atomization">atomization</termref> and extraction of <termref def="dt-ebv">Effective Boolean Values</termref> (step SQ5).</p><p>During the <termref def="dt-static-analysis">static analysis
phase</termref>, a processor may perform type analysis. The
effect of type analysis is to assign a <termref def="dt-static-type">static type</termref> to each expression in the
operation tree. <termdef id="dt-static-type" term="static type">The
<term>static type</term> of an expression is the best inference that
the processor is able to make statically about the type of the result
of the expression.</termdef> This specification does not define the
rules for type analysis nor the static types that are assigned to
particular expressions: the only constraint is that the inferred type
must match all possible values that the expression is capable of
returning.</p><p>Examples of inferred static types might be:</p><ulist><item><p>For the expression <code>concat(a,b)</code> the inferred static type is <code>xs:string</code>
                        </p></item><item><p>For the expression <code>$a = $v</code> the inferred static type is <code>xs:boolean</code>
                        </p></item><item><p>For the expression <code>$s[exp]</code> the inferred static
    type has the same item type as the static type of <code>$s</code>,
    but a cardinality that allows the empty sequence even if the
    static type of <code>$s</code> does not allow an empty
    sequence.</p></item><item><p>The inferred static type of the expression <code>data($x)</code> (whether written
    explicitly or inserted into the operation tree in places where atomization
    is implicit) depends on the inferred static type of <code>$x</code>: for example, if <code>$x</code>
    has type <code>element(*, xs:integer)</code> then <code>data($x)</code> has static type <code>xs:integer</code>.</p></item></ulist><p>In XQuery 1.0 and XPath 2.0, rules for static type inferencing were published
normatively in <bibref ref="xquery-semantics"/>, but implementations were allowed to
refine these rules to infer a more precise type where possible. In
<phrase diff="chg" at="bug28782">XQuery 3.1 and XPath 3.1</phrase>, the rules for static type inferencing are entirely implementation-dependent.</p><p>Every kind of expression also imposes requirements on the type of its
operands. For example, with the expression <code>substring($a, $b, $c)</code>, <code>$a</code> must be
of type <code>xs:string</code> (or something that can be converted to <code>xs:string</code> by the
function calling rules), while <code>$b</code> and <code>$c</code> must be of type <code>xs:double</code>.</p><p>If the <termref def="dt-xpath-static-typing-feature" role="xpath">Static Typing Feature</termref> is in effect, a processor must raise a
type error during static analysis if the inferred static type of an
expression is not subsumed by the required type of the context where the
expression is used. For example, the call of substring above would cause a
type error if the inferred static type of <code>$a</code> is <code>xs:integer</code>; equally, a type
error would be reported during static analysis if the inferred static type
is <code>xs:anyAtomicType</code>.</p><p>If the <termref def="dt-xpath-static-typing-feature" role="xpath">Static Typing Feature</termref> is not in effect, a processor may raise a type
error during static analysis only if the inferred static type of an
expression has no overlap (intersection) with the required type: so for the
first argument of substring, the processor may raise an error if the
inferred type is <code>xs:integer</code>, but not if it is <code>xs:anyAtomicType</code>.
Alternatively, if the <termref def="dt-xpath-static-typing-feature" role="xpath">Static Typing Feature</termref> is not in effect, the processor
may defer all type checking until the dynamic evaluation phase.</p></div4><div4 id="id-dynamic-evaluation"><head>Dynamic Evaluation Phase</head><p>
                     <termdef id="dt-dynamic-evaluation" term="dynamic evaluation phase">The <term>dynamic evaluation phase</term> is the phase during which the value of an expression is computed.</termdef> It is dependent on successful completion of the <termref def="dt-static-analysis">static analysis phase</termref>.</p><p>The dynamic evaluation phase can occur only if no errors were detected during the <termref def="dt-static-analysis">static analysis phase</termref>. If the <termref def="dt-xpath-static-typing-feature" role="xpath">Static Typing Feature</termref> is in effect, all <termref def="dt-type-error">type errors</termref> are detected during static analysis and serve to inhibit the dynamic evaluation phase.</p><p>The dynamic evaluation phase depends on the <term>operation
tree</term> of the expression being evaluated (step DQ1), on the input
data (step DQ4), and on the <termref def="dt-dynamic-context">dynamic context</termref> (step DQ5), which in turn draws information from  the external environment (step DQ3) and the <termref def="dt-static-context">static context</termref> (step DQ2). The dynamic evaluation phase may create new data-model values (step DQ4) and it may extend the <termref def="dt-dynamic-context">dynamic context</termref> (step DQ5)—for example, by binding values to variables.</p><p>
                     <termdef term="dynamic type" id="dt-dynamic-type">A <term>dynamic type</term> is associated with each value as it is computed. The dynamic type of a value may be more specific than the <termref def="dt-static-type">static type</termref> of the expression that computed it (for example, the  static type of an expression might be <code>xs:integer*</code>, denoting a sequence of zero or more integers, but at evaluation time its value may have the dynamic type <code>xs:integer</code>, denoting exactly one integer.)</termdef>
                  </p><p> If an operand of an expression is found
to have a <termref def="dt-dynamic-type">dynamic type</termref> that is not appropriate for that operand, a
<termref def="dt-type-error">type error</termref> is
raised <errorref class="TY" code="0004"/>.</p><p>Even though static typing can catch many <termref def="dt-type-error">type errors</termref> before an expression is executed, it is possible for an expression to raise an error during evaluation that was not detected by static  analysis. For example, an expression may contain a cast of a string into an integer, which is statically valid. However, if the actual value of the string at run time cannot be cast into an integer, a <termref def="dt-dynamic-error">dynamic error</termref> will result. Similarly, an expression may apply an arithmetic operator to a value whose <termref def="dt-static-type">static type</termref> is <code>xs:untypedAtomic</code>. This is not a <termref def="dt-static-error">static error</termref>, but at run time, if the value cannot be successfully cast to a <termref def="dt-numeric">numeric</termref> type, a <termref def="dt-dynamic-error">dynamic error</termref> will be raised.</p><p>When the <termref def="dt-xpath-static-typing-feature" role="xpath">Static Typing Feature</termref> is in effect, it is also possible for static analysis of an expression to raise a <termref def="dt-type-error">type error</termref>, even though execution of the expression on certain inputs would be successful. For example, an expression might contain a function that requires an element as its parameter, and the static analysis phase might infer the <termref def="dt-static-type">static type</termref> of the function parameter to be an optional element. This case is treated as a <termref def="dt-type-error">type error</termref> and inhibits evaluation, even though the function call would have been successful for input data in which the optional element is present.</p></div4></div3><div3 id="id-consistency-constraints"><head>Consistency Constraints</head><p>In order for XPath 3.1 to
be well defined, the input <termref def="dt-data-model-instance">XDM instances</termref>, the <termref def="dt-static-context">static context</termref>, and the <termref def="dt-dynamic-context">dynamic context</termref> must be mutually
consistent. The consistency constraints listed below are prerequisites
for correct functioning of an XPath 3.1 implementation. Enforcement
of these consistency constraints is beyond the scope of this
specification. This specification does not
define the result of   <phrase role="xpath">an expression</phrase> under any condition in which one
or more of these constraints is not satisfied.</p><ulist><item><p>For every  node that has a type annotation, if that type annotation is found in the <termref def="dt-issd">in-scope schema definitions</termref> (ISSD), then its definition in the ISSD must be equivalent to its definition in the type annotation.
</p></item><item><p>Every element name, attribute name, or schema type name referenced in <termref def="dt-in-scope-variables">in-scope variables</termref> or <termref def="dt-known-func-signatures">statically known function signatures</termref> must be in the <termref def="dt-issd">in-scope schema definitions</termref>, unless it is an element name referenced as part of an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementTest" xlink:type="simple">ElementTest</nt> or an attribute name referenced as part of an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AttributeTest" xlink:type="simple">AttributeTest</nt>.</p></item><item><p>Any reference to a global element, attribute, or type name in
the <termref def="dt-issd">in-scope schema definitions</termref> must have a corresponding element, attribute or type
definition in the <termref def="dt-issd">in-scope schema definitions</termref>.</p></item><item><p> For each mapping of a string to a
document node in <termref def="dt-available-docs">available
documents</termref>, if there exists a mapping of the same string to a document type in <termref def="dt-known-docs">statically known documents</termref>, the document node must match the document type, using the matching rules in <specref ref="id-sequencetype-matching"/>.</p></item><item><p>For each mapping of a string to a sequence of  <phrase diff="del" at="2015-07-07">nodes</phrase>
                        <phrase diff="add" at="2015-07-07">items</phrase> in
<termref def="dt-available-collections">available   <phrase diff="del" at="bug28957">node</phrase>
collections</termref>, if there exists a mapping of the same string to
a type in <termref def="dt-known-collections">statically known collections</termref>, the sequence of <phrase diff="del" at="2015-07-07">nodes</phrase>
                        <phrase diff="add" at="2015-07-07">items</phrase>  must match the type, using the matching rules in  <specref ref="id-sequencetype-matching"/>.</p></item><item><p>The sequence of <phrase diff="del" at="2015-07-07">nodes</phrase>
                        <phrase diff="add" at="2015-07-07">items</phrase> in the <termref def="dt-default-collection">default collection</termref> must match the <termref def="dt-known-default-collection">statically known default collection type</termref>, using the matching rules in  <specref ref="id-sequencetype-matching"/>.</p></item><item><p>The value of the <termref def="dt-context-item">context item</termref> must match the <termref def="dt-context-item-static-type">context item static type</termref>, using the
matching rules in <specref ref="id-sequencetype-matching"/>.</p></item><item><p>For each (variable, type) pair in <termref def="dt-in-scope-variables">in-scope variables</termref> and the corresponding (variable, value) pair in <termref def="dt-variable-values">variable values</termref> such that the variable names are equal, the value must match the type, using the matching rules in  <specref ref="id-sequencetype-matching"/>.</p></item><item><p>In the <termref def="dt-static-namespaces">statically known namespaces</termref>, the prefix <code>xml</code> must not be bound to any namespace URI other than <code>http://www.w3.org/XML/1998/namespace</code>, and no prefix other than <code>xml</code> may be bound to this namespace URI.
The prefix <code>xmlns</code> must not be bound to any namespace URI, and no prefix may be bound to the namespace URI <code>http://www.w3.org/2000/xmlns/</code>.</p></item><item><p>
      For each 
      <code>(expanded QName, arity) -&gt; FunctionTest</code>
      entry in 
      <termref def="dt-known-func-signatures">statically known function signatures</termref>,
      there must exist an 
      <code>(expanded QName, arity) -&gt; function</code>
      entry in 
      <termref def="dt-named-functions">named functions</termref>
      such that the function's 
      <xtermref spec="DM31" ref="dt-signature">signature</xtermref>
      is 
      <code>FunctionTest</code>. 
    </p></item></ulist></div3></div2><div2 id="errors"><head>Error Handling</head><div3 id="id-kinds-of-errors"><head>Kinds of Errors</head><p>
As described in <specref ref="id-expression-processing"/>, XPath 3.1
defines a <termref def="dt-static-analysis">static analysis phase</termref>, which does not depend on input
data, and a <termref def="dt-dynamic-evaluation">dynamic evaluation
phase</termref>, which does depend on input
data.  Errors may be raised during each phase.</p><p>
                  <termdef id="dt-static-error" term="static error">
An error that can be detected during the static analysis phase, and is not a type error, is a <term>static error</term>.</termdef> A syntax error is an example of a <termref def="dt-static-error">static error</termref>.</p><p>
                  <termdef id="dt-dynamic-error" term="dynamic error">A <term>dynamic
error</term> is an error that
must be detected during the dynamic evaluation phase and may be detected
during the static analysis phase.
Numeric overflow is an example of a <termref def="dt-dynamic-error">dynamic error</termref>.</termdef>
               </p><p>
                  <termdef id="dt-type-error" term="type error">A <term>type
error</term> may be raised during the static analysis phase or the dynamic evaluation phase.
During the static analysis phase, a <termref def="dt-type-error">type error</termref> occurs
when the <termref def="dt-static-type">static type</termref> of an expression does not match the expected type
of the context in which the expression occurs.
During the dynamic evaluation phase, a <termref def="dt-type-error">type error</termref> occurs
when the <termref def="dt-dynamic-type">dynamic type</termref> of a value does not match the expected type of
the context in which the value occurs.</termdef>
               </p><p>The outcome of the <termref def="dt-static-analysis">static analysis
phase</termref> is either success or one or more <termref def="dt-type-error">type errors</termref>, <termref def="dt-static-error">static errors</termref>, or statically-detected <termref def="dt-dynamic-error">dynamic errors</termref>. The result of the <termref def="dt-dynamic-evaluation">dynamic evaluation
phase</termref> is either a result value, a <termref def="dt-type-error">type
error</termref>, or a <termref def="dt-dynamic-error">dynamic error</termref>.</p><p>If more than one error is present, or if an error condition comes within the
scope of more than one error defined in this specification, then any non-empty
subset of these errors may be reported.</p><p> During the <termref def="dt-static-analysis">static
analysis phase</termref>, if the <termref def="dt-xpath-static-typing-feature" role="xpath">Static Typing Feature</termref> is in effect and the <termref def="dt-static-type">static type</termref> assigned to an expression other than <code>()</code> or <code>data(())</code> is <code>empty-sequence()</code>, a <termref def="dt-static-error">static error</termref> is raised <errorref class="ST" code="0005"/>. This catches cases in which a query refers to an element or attribute that is not present in the <termref def="dt-issd">in-scope schema definitions</termref>, possibly because of a spelling error.</p><p>Independently of whether the <termref def="dt-xpath-static-typing-feature" role="xpath">Static Typing Feature</termref> is in effect, if an implementation can determine during the
<termref def="dt-static-analysis">static
analysis phase</termref> that <phrase role="xpath">an XPath expression</phrase>, if evaluated, would necessarily
raise a <termref def="dt-dynamic-error">dynamic error</termref> or that an expression, if evaluated, would necessarily raise a <termref def="dt-type-error">type error</termref>, the implementation may (but is not required to) report that
error during the <termref def="dt-static-analysis">static
analysis phase</termref>.</p><p>An implementation can raise a <termref def="dt-dynamic-error">dynamic error</termref> for <phrase role="xpath">an XPath expression</phrase> statically only if the <phrase role="xpath">expression</phrase> can never execute without raising that error, as in the following example:</p><eg role="parse-test" xml:space="preserve">
error()
</eg><p>The following example contains a type error, which can be reported statically even if the implementation can not prove that the expression will actually be evaluated.</p><eg role="parse-test" xml:space="preserve">
if (empty($arg))
then
  "cat" * 2
else
  0
</eg><p>
                  <termdef id="dt-warning" term="warning">In addition to <termref def="dt-static-error">static errors</termref>, <termref def="dt-dynamic-error">dynamic errors</termref>, and <termref def="dt-type-error">type
errors</termref>, an XPath 3.1
implementation may raise <term>warnings</term>, either during the <termref def="dt-static-analysis">static analysis
phase</termref> or the
<termref def="dt-dynamic-evaluation">dynamic evaluation
phase</termref>. The circumstances in which warnings are raised, and
the ways in which warnings are handled, are <termref def="dt-implementation-defined">implementation-defined</termref>.</termdef>
               </p><p>In addition to the errors defined in this
specification, an implementation may raise a <termref def="dt-dynamic-error">dynamic error</termref> for a reason beyond the scope of this specification. For
example, limitations may exist on the maximum
numbers or sizes of various objects. 
<phrase id="id-error-limit-exceeded">An error must be raised if such a limitation is exceeded  <errorref class="DY" code="0130"/>.</phrase>



               </p></div3><div3 id="id-identifying-errors"><head>Identifying and Reporting Errors</head><p>The errors defined in this specification are identified by QNames that have the form <code role="xpath">err:XPYYnnnn</code>, where:</p><ulist><item><p>
                        <code>err</code> denotes the namespace for XPath and XQuery errors, <code>http://www.w3.org/2005/xqt-errors</code>. This binding of the namespace prefix <code>err</code> is used for convenience in this document, and is not normative.</p></item><item role="xpath"><p>
                        <code>XP</code> identifies the error as an XPath error (some errors, originally defined by XQuery and later added to XPath, use the code <code>XQ</code> instead).</p></item><item><p>
                        <code>YY</code> denotes the error category, using the following encoding:</p><ulist><item><p>
                              <code>ST</code> denotes a static error.</p></item><item><p>
                              <code>DY</code> denotes a dynamic error.</p></item><item><p>
                              <code>TY</code> denotes a type error.</p></item></ulist></item><item><p>
                        <code>nnnn</code> is a unique numeric code.</p></item></ulist><note><p>The namespace URI for  XPath and XQuery errors is not expected to
change from one version of <phrase role="xpath">XPath</phrase> to another. However, the contents of this
namespace may be extended to include additional error definitions.</p></note><p>The method by which an XPath 3.1 processor reports error information to the external environment is <termref def="dt-implementation-defined">implementation-defined</termref>.</p><p>An error can be represented by a URI reference that is derived from the error QName as follows: an error with namespace URI <emph>
                     <code>NS</code>
                  </emph> and local part <emph>
                     <code>LP</code>
                  </emph> can be represented as the URI reference <emph>
                     <code>NS</code>
                  </emph>
                  <code>#</code>
                  <emph>
                     <code>LP</code>
                  </emph>. For example, an error whose QName is <code>err:XPST0017</code> could be represented as <code>http://www.w3.org/2005/xqt-errors#XPST0017</code>.</p><note><p>Along with a code identifying an error, implementations may wish to return additional information, such
as the location of the error or the processing phase in which it was detected. If an implementation chooses to do so, then the mechanism that
it uses to return this information is <termref def="dt-implementation-defined">implementation-defined</termref>.</p></note></div3><div3 id="id-handling-dynamic"><head>Handling Dynamic Errors</head><p>Except as noted in this document, if any operand of an expression
raises a <termref def="dt-dynamic-error">dynamic error</termref>, the expression also raises a <termref def="dt-dynamic-error">dynamic error</termref>.
If an expression can validly return a value or raise a dynamic
error, the implementation may choose to return the value or raise
the dynamic error (see <specref ref="id-errors-and-opt"/>).  For example, the logical expression
<code>expr1 and expr2</code> may return the value <code>false</code>
if either operand returns <code>false</code>,
or may raise a dynamic error if either operand raises a dynamic
error.</p><p> If more than one operand of an expression raises
an error, the
implementation may choose which error is raised by the expression.
For example, in this expression:

</p><eg role="parse-test" xml:space="preserve">($x div $y) + xs:decimal($z)</eg><p>

both the sub-expressions <code role="parse-test">($x div $y)</code> and <code role="parse-test">xs:decimal($z)</code> may
raise an error.  The
implementation may choose which error is raised by the "<code>+</code>"
expression.  Once one operand raises an error, the implementation is
not required, but is permitted, to evaluate any other operands.</p><p>
                  <termdef id="dt-error-value" term="error value">In addition to its identifying QName, a dynamic error may also carry a descriptive string and one or more additional values called <term>error values</term>.</termdef> An implementation may provide a mechanism whereby an application-defined error handler can process error values and produce diagnostic messages. 
  
  <phrase diff="chg" at="2015-07-08" role="xpath">The host language may also provide error handling mechanisms.</phrase>
               </p><p>A dynamic error may be raised by a <termref def="dt-built-in-function">built-in
function</termref> or operator.  For example,
the <code>div</code> operator raises an error if its operands are <code>xs:decimal</code> values and its second operand
is equal to zero. Errors raised by built-in functions and operators are defined in <bibref ref="xpath-functions-31"/>.</p><p>A dynamic error can also be raised explicitly by calling the
<code>fn:error</code> function, which always raises a dynamic error and never
returns a value.  This function is defined in <xspecref diff="chg" at="bug28289" spec="FO31" ref="func-error"/>. For example, the following
function call raises a dynamic
error, providing a QName that identifies the error, a descriptive string, and a diagnostic value (assuming that the prefix <code>app</code> is bound to a namespace containing application-defined error codes):</p><eg role="parse-test" xml:space="preserve">fn:error(xs:QName("app:err057"), "Unexpected value", fn:string($v))</eg></div3><div3 id="id-errors-and-opt"><head>Errors and
      Optimization</head><p>Because different implementations may
      choose to evaluate or optimize an expression in different ways,
      certain aspects of raising <termref def="dt-dynamic-error">dynamic errors</termref> are <termref def="dt-implementation-dependent">implementation-dependent</termref>, as described in this section.</p><p>An implementation is always free to evaluate the operands of an operator in any order.</p><p>In some cases,  a processor can determine the result of an expression without accessing all the data that would be implied by the formal expression semantics. For example, the formal description of <termref def="dt-filter-expression">filter expressions</termref> suggests that <code role="parse-test">$s[1]</code> should be evaluated by examining all the items in sequence <code>$s</code>, and selecting all those that satisfy the predicate <code role="parse-test">position()=1</code>. In practice, many implementations will recognize that they can evaluate this expression by taking the first item in the sequence and then exiting. If <code>$s</code> is defined by an expression such as <code role="parse-test">//book[author eq 'Berners-Lee']</code>, then this strategy may avoid a complete scan of a large document and may therefore greatly improve performance. However, a consequence of this strategy is that a dynamic error or type error that would be detected if the expression semantics were followed literally might not be detected at all if the evaluation exits early. In this example, such an error might occur if there is a <code>book</code> element in the input data with more than one <code>author</code> subelement.</p><p>The extent to which a processor may optimize its access to data, at the cost of not raising errors, is defined by the following rules.</p><p>Consider an expression <emph>Q</emph> that has an operand (sub-expression) <emph>E</emph>. In general the value of <emph>E</emph> is a sequence. At an intermediate stage during evaluation of the sequence, some of its items will be known and others will be unknown. If, at such an intermediate stage of evaluation, a processor is able to establish that there are only two possible outcomes of evaluating <emph>Q</emph>, namely the value <emph>V</emph> or an error, then the processor may deliver the result <emph>V</emph> without evaluating further items in the operand <emph>E</emph>. For this purpose, two values are considered to represent the same outcome if their items are pairwise the same, where nodes are the same if they have the same identity, and values are the same if they are equal and have exactly the same type.</p><p>There is an exception to this rule: If a processor evaluates an operand <emph>E</emph> (wholly or in part), then it  is required to establish that the actual value of the operand <emph>E</emph> does not violate any constraints on its cardinality. For example, the expression <code role="parse-test">$e eq 0</code> results in a type error if the value of <code>$e</code> contains two or more items. A processor is not allowed to decide, after evaluating the first item in the value of <code>$e</code> and finding it equal to zero, that the only possible outcomes are the value <code>true</code> or a type error caused by the cardinality violation. It must establish that the value of <code>$e</code> contains no more than one item.</p><p>These rules apply to all the operands of an expression considered in combination: thus if an expression has two operands <emph>E1</emph> and <emph>E2</emph>, it may be evaluated using any samples of the respective sequences that satisfy the above rules.</p><p>The rules cascade: if <emph>A</emph> is an operand of <emph>B</emph> and <emph>B</emph> is an operand of <emph>C</emph>, then the processor needs to evaluate only a sufficient sample of <emph>B</emph> to determine the value of <emph>C</emph>, and needs to evaluate only a sufficient sample of <emph>A</emph> to determine this sample of <emph>B</emph>.</p><p>The effect of these rules is that the processor is free to stop examining further items in a sequence as soon as it can establish that further items would not affect the result except possibly by causing an error. For example, the processor may return <code>true</code> as the result of the expression <code role="parse-test">S1 = S2</code> as soon as it finds a pair of equal values from the two sequences.</p><p>Another consequence of these rules is that where none of the items in a sequence contributes to the result of an expression, the processor is not obliged to evaluate any part of the sequence. Again, however, the processor cannot dispense with a required cardinality check: if an empty sequence is not permitted in the relevant context, then the processor must ensure that the operand is not an empty sequence.</p><p>Examples:</p><ulist><item><p>If an implementation can find (for example, by using an index) that at
least one item returned by <code>$expr1</code> in the following example has the value <code>47</code>, it is allowed to
return <code>true</code> as the result of the <code>some</code> expression, without searching for
another item returned by <code>$expr1</code> that would raise an error if it were evaluated.
</p><eg role="parse-test" xml:space="preserve">some $x in $expr1 satisfies $x = 47</eg></item><item><p>In the following example, if an implementation can find (for example, by using an index) the
<code>product</code> element-nodes that have an <code>id</code> child with the value <code>47</code>, it is allowed to return these nodes as the
result of the <termref def="dt-path-expression">path expression</termref>, without searching for another <code>product</code> node that
would raise an error because it has an <code>id</code> child whose value is not an integer.</p><eg role="parse-test" xml:space="preserve">//product[id = 47]</eg></item></ulist><!-- <change diff="chg" at="XQ.E4 and XP.E4"> --><p>For a variety of reasons, including optimization, implementations
          may rewrite expressions into a different
          form. There are a number of rules that limit the extent of this freedom:
          </p><ulist><item><p>
                Other than the raising or not raising of errors, the result
                of evaluating a rewritten expression must
                conform to the semantics
                defined in this specification for the original expression.
             </p><note><p>
                This allows an implementation to return a result in cases where the
                original expression would have raised an error, or to raise an error in cases
                where the original expression would have returned a result. The main cases
                where this is likely to arise in practice are (a) where a rewrite changes the
                order of evaluation, such that a subexpression causing an error is evaluated
                when the expression is written one way and is not evaluated when the expression
                is written a different way, and (b) where intermediate results of the
                evaluation cause overflow or other out-of-range conditions.
             </p></note><note><p>
                This rule does not mean that the result of the expression will always
                be the same in non-error cases as if it had not been rewritten, because there
                are many cases where the result of an expression is to some degree
                <termref def="dt-implementation-dependent">implementation-dependent</termref>
                or <termref def="dt-implementation-defined">implementation-defined</termref>.
             </p></note></item><item><p>
                        <phrase role="xpath">Conditional</phrase> expressions
                must not raise a dynamic error in
                respect of subexpressions occurring in a branch that is not selected,
                and must not
                return the value delivered by a branch unless that branch is selected.
                Thus, the following example must not raise a
                dynamic error if the document <code>abc.xml</code> does not exist:
             </p><eg xml:space="preserve" role="parse-test">if (doc-available('abc.xml')) then doc('abc.xml') else ()</eg><p diff="add" at="Bug 29320">Of course, the condition must be evaluated in order to determine which branch is selected, and the query must not be rewritten in a way that would bypass evaluating the condition.</p></item><item><p>
                As stated earlier, an expression
                must not be rewritten to dispense with a
                required cardinality check: for example, <code role="parse-test">string-length(//title)</code>
                must raise an
                error if the document contains more than one title element.
             </p></item><item><p>
                Expressions must not be rewritten in such a way
                as to create or remove static errors.

                The static errors in this specification are defined
                for the original expression, and must be preserved if
                the expression is rewritten.</p></item></ulist><p>
          Expression rewrite is illustrated by the following examples.
          </p><!-- </change> --><ulist><item><p>Consider the expression <code role="parse-test">//part[color eq "Red"]</code>. An implementation might
choose to rewrite this expression as <code role="parse-test">//part[color = "Red"][color eq
"Red"]</code>. The implementation might then process the expression as follows:
First process the "<code>=</code>" predicate by probing an index on parts by color to
quickly find all the parts that have a Red color; then process the "<code>eq</code>"
predicate by checking each of these parts to make sure it has only a
single color. The result would be as follows:

<ulist><item><p>Parts that have exactly one color that is Red are returned.</p></item><item><p>If some part has color Red together with some other color, an error is
raised.</p></item><item><p>The existence of some part that has no color Red but has multiple non-Red
colors does not trigger an error.</p></item></ulist>
                     </p></item><item><p>The expression in the following example cannot raise a casting error if it is evaluated
exactly as written (i.e., left to right). Since neither predicate depends on the context position, an implementation might choose to reorder the predicates to achieve better
performance (for example, by taking advantage of an index). This
reordering could cause the expression to raise an
error.</p><eg role="parse-test" xml:space="preserve">$N[@x castable as xs:date][xs:date(@x) gt xs:date("2000-01-01")]</eg><p at="XQ.E4 and XP.E4">To avoid unexpected errors caused by expression rewrite,
tests that are designed to prevent dynamic errors should be expressed
using conditional  expressions. For example, the above expression can be written as
follows:</p><eg role="parse-test" xml:space="preserve">$N[if (@x castable as xs:date)
   then xs:date(@x) gt xs:date("2000-01-01")
   else false()]</eg></item></ulist></div3></div2><div2 id="id-important-concepts"><head>Concepts</head><p>This section explains some concepts that are important to the processing of XPath 3.1 expressions.</p><div3 id="id-document-order"><head>Document Order</head><p>An ordering called <term>document order</term> is defined among all the nodes accessible during processing of a given <phrase role="xpath">expression</phrase>, which may consist of one or more <term>trees</term> (documents or fragments). 

Document order is defined in <xspecref diff="chg" at="bug28290" spec="DM31" ref="document-order"/>, and its definition is repeated here for convenience. 

Document order is a total ordering, although the relative order of some nodes is <termref def="dt-implementation-dependent">implementation-dependent</termref>.  

<termdef term="document order" id="dt-document-order">Informally, <term>document order</term> is the order in which nodes appear in the XML serialization of a document.</termdef>  

                  <termdef term="stable" id="stable">Document order is <term>stable</term>, which means that the relative order of two nodes will not change during the processing of a given <phrase role="xpath">expression</phrase>, even if this order is <termref def="dt-implementation-dependent">implementation-dependent</termref>.</termdef>

                  <termdef term="reverse document order" id="dt-reverse-document-order">The node ordering that is the reverse of document order is called <term>reverse document order</term>.</termdef>
               </p><p>Within a tree, document order satisfies the following constraints:</p><olist><item><p>The root node is the first node.</p></item><item><p>Every node occurs before all of its children and descendants.</p></item><item role="xpath"><p>Namespace nodes immediately follow the element node with
which they are associated. The relative order of namespace nodes is
stable but <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p></item><item><p>Attribute nodes immediately follow the <phrase role="xpath">namespace nodes of the
</phrase> element node with which they are associated. The relative order of
attribute nodes is stable but <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p></item><item><p>The relative order of siblings is the order in which they occur
in the <code>children</code> property of their parent node.</p></item><item><p>Children and descendants occur before following siblings.</p></item></olist><p>The relative order of nodes in distinct trees is stable but
<termref def="dt-implementation-dependent">implementation-dependent</termref>,
subject to the following constraint: If any node in a given tree T1 is before
any node in a different tree T2, then all nodes in tree T1 are before all nodes in
tree T2.</p></div3><div3 id="id-atomization"><head>Atomization</head><p>The semantics of some
XPath 3.1 operators depend on a process called <termref def="dt-atomization">atomization</termref>. Atomization is
applied to a value when the value is used in a context in which a
sequence of atomic values is required. The result of atomization is
either a sequence of atomic values or a <termref def="dt-type-error">type error</termref>  
                  <xerrorref spec="FO31" class="TY" code="0012"/>.  <termdef id="dt-atomization" term="atomization">
                     <term>Atomization</term> of a sequence
is defined as the result of invoking the <phrase diff="add" at="bug28291">
                        <code>fn:data</code> function, as defined in <xspecref spec="FO31" ref="func-data"/>.</phrase>
                     <phrase diff="del" at="bug28291">
                        <code>fn:data</code> function
on the sequence, as defined in <bibref ref="xpath-functions-31"/>.</phrase>
                  </termdef>
               </p><p> The semantics of
<code>fn:data</code> are repeated here for convenience. The result of
<code>fn:data</code> is the sequence of atomic values produced by
applying the following rules to each item in the input
sequence:</p><ulist><item><p>If the item is an atomic value, it is
returned.</p></item><item><p diff="chg" at="2014-02-07">If the item is a node,
its <termref def="dt-typed-value">typed value</termref> is returned (<phrase diff="add" at="2014-02-07">a <termref def="dt-type-error">type error</termref>
                        </phrase> 
                        <xerrorref spec="FO31" class="TY" code="0012"/> is raised if the node has no typed value.)</p></item><item><p>If the item is a <xtermref diff="chg" at="2013-12-07" spec="DM31" ref="dt-function-item">function</xtermref> 
                        <phrase diff="add" at="2015-07-07">(other than an array) </phrase>
                        <phrase diff="add" at="2014-02-07">or map a <termref def="dt-type-error">type error</termref>
                        </phrase> 
                        <phrase diff="chg" at="2015-07-07">
                           <xerrorref spec="FO31" class="TY" code="0013"/>
                        </phrase> is raised.</p></item><item><p diff="chg" at="2014-02-07">If the item is an array <code>$a</code>, atomization is defined as <code diff="del" at="2014-08-20">seq($a) ! fn:data(.)</code>
                        <code diff="add" at="2014-08-20">$a?* ! fn:data(.)</code>, which is equivalent to atomizing the members of the array.</p><note><p diff="chg" at="2014-02-07">This definition recursively atomizes members that are arrays. Hence, the result of atomizing the array <code>[ [1, 2, 3], [4, 5, 6] ]</code> is the sequence <code>(1, 2, 3, 4, 5, 6)</code>.</p></note></item></ulist><p>Atomization is  used in
processing the following types of expressions: </p><ulist><item><p>Arithmetic expressions</p></item><item><p>Comparison expressions</p></item><item><p>Function calls and returns</p></item><item><p>Cast expressions</p></item></ulist></div3><div3 id="id-ebv"><head>Effective Boolean Value</head><p>Under certain circumstances (listed below), it is necessary to find
the <termref def="dt-ebv">effective boolean value</termref> of a
value. <termdef id="dt-ebv" term="effective boolean value">The
<term>effective boolean value</term> of a value is defined as the result
of applying the <code>fn:boolean</code> function to the value, as
defined in <xspecref diff="chg" at="bug28292" spec="FO31" ref="func-boolean"/>.</termdef>
               </p><p>The dynamic semantics of <code>fn:boolean</code> are repeated here for convenience:</p><olist><item><p>If its operand is an empty sequence, <code>fn:boolean</code> returns <code>false</code>.</p></item><item><p>If its operand is a sequence whose first item is a node, <code>fn:boolean</code> returns <code>true</code>.</p></item><item><p>If its operand is a <termref def="dt-singleton">singleton</termref> value of type <code>xs:boolean</code> or derived from <code>xs:boolean</code>, <code>fn:boolean</code> returns the value of its operand unchanged.</p></item><item><p>If its operand is a <termref def="dt-singleton">singleton</termref> value of type <code>xs:string</code>, <code>xs:anyURI</code>, <code>xs:untypedAtomic</code>, or a type derived from one of these, <code>fn:boolean</code> returns <code>false</code> if the operand value has zero length; otherwise it returns <code>true</code>.</p></item><item><p>If its operand is a <termref def="dt-singleton">singleton</termref> value of any <termref def="dt-numeric">numeric</termref> type or derived from a numeric type, <code>fn:boolean</code> returns <code>false</code> if the operand value is <code>NaN</code> or is numerically equal to zero; otherwise it returns <code>true</code>.</p></item><item><p>In all other cases, <code>fn:boolean</code> raises a type error <xerrorref spec="FO31" class="RG" code="0006"/>.</p><note><p diff="chg" at="2014-02-07">For instance, <code>fn:boolean</code> raises a type error if the operand is a function, a map, or an array.</p></note></item></olist><p>The <termref def="dt-ebv">effective boolean value</termref> of a sequence is computed implicitly during  processing of the following types of expressions: </p><ulist><item><p>Logical expressions (<code>and</code>, <code>or</code>)</p></item><item><p>The <code>fn:not</code> function</p></item><item><p>Certain types of <termref def="dt-predicate">predicates</termref>, such as <code>a[b]</code>
                     </p></item><item><p>Conditional expressions (<code>if</code>)</p></item><item><p>Quantified expressions (<code>some</code>, <code>every</code>)</p></item><item role="xpath"><p>General comparisons, in <termref def="dt-xpath-compat-mode">XPath 1.0
		compatibility mode</termref>.</p></item></ulist><note><p>The definition of <termref def="dt-ebv">effective boolean
  value</termref> is <emph>not</emph> used when casting a value to the
  type <code>xs:boolean</code>, for example in a <code>cast</code>
  expression or when passing a value to a function whose expected
  parameter is of type <code>xs:boolean</code>.</p></note></div3><div3 id="id-input-sources"><head>Input Sources</head><p diff="add" at="bug28294">XPath 3.1 has a set of functions that provide access to XML documents (<code>fn:doc</code>, <code>fn:doc-available</code>), collections (<code>fn:collection</code>, <code>fn:uri-collection</code>), text files (<code>fn:unparsed-text</code>, <code>fn:unparsed-text-lines</code>, <code>fn:unparsed-text-available</code>), and environment variables (<code>fn:environment-variable</code>, <code>fn:available-environment-variables</code>).  These functions are defined in <xspecref spec="FO31" ref="fns-on-docs"/>.</p><p diff="del" at="bug28294">XPath 3.1 has a set of functions that provide access to
    input data. These functions are of particular importance because they provide a way in which an expression can reference a document or a collection of documents. The  input functions are described informally here; they are defined in <bibref ref="xpath-functions-31"/>.</p><p>An expression can access input data either by calling one
    of these input functions or by referencing some part of the
    <termref def="dt-dynamic-context">dynamic context</termref> that is initialized by the external
    environment, such as a <termref def="dt-variable-values">variable</termref> or
    <termref def="dt-context-item">context item</termref>.</p><p diff="del" at="bug28294">The input functions supported by XPath 3.1 are as follows:</p><ulist diff="del" at="bug28294"><item><p>The <code>fn:doc</code> function takes a string containing a URI. If that URI is associated with a document in <termref def="dt-available-docs">available documents</termref>, <code>fn:doc</code> returns a document node whose content is the <termref def="dt-datamodel">data model</termref> representation of the given document; otherwise it raises a <termref def="dt-dynamic-error">dynamic error</termref>.</p></item><item><p>The <code>fn:unparsed-text</code> function takes a string containing a URI, which must identify a resource that can be read as text;  otherwise it raises a <termref def="dt-dynamic-error">dynamic error</termref>.</p></item><item><p>The <code>fn:environment-variable</code> and <code>fn:available-environment-variables</code> identify environment variables that are available in the dynamic context.</p></item><item><p>The <code>fn:collection</code> function with one argument takes a string containing a URI. 
    If that URI is associated with a collection in <termref def="dt-available-collections">available  collections</termref>, <code>fn:collection</code> returns the data model representation of that collection; otherwise it raises a <termref def="dt-dynamic-error">dynamic error</termref>.  A collection may be any sequence of <phrase diff="del" at="2015-07-07">nodes</phrase>
                        <phrase diff="add" at="2015-07-07">items, such as document nodes, maps, arrays, or atomic values</phrase>. For example, the expression
    <code role="parse-test">fn:collection("http://example.org")//customer</code>
    identifies all the <code>customer</code> elements that are
    descendants of nodes found in the collection whose URI is
    <code>http://example.org</code>.</p></item><item><p>The <code>fn:collection</code> function with zero arguments returns the <termref def="dt-default-collection">default collection</termref>, an <termref def="dt-implementation-dependent">implementation-dependent</termref> sequence of <phrase diff="del" at="2015-07-07">nodes</phrase>
                        <phrase diff="add" at="2015-07-07">items</phrase>.</p></item><item><p>The <code>fn:uri-collection</code> function returns a sequence of <code>xs:anyURI</code> values representing the URIs in a <phrase diff="del" at="bug28957">resource</phrase>
                        <phrase diff="add" at="bug28957">URI</phrase> collection.</p></item><item><p>The <code>fn:uri-collection</code> function with zero arguments returns the URIs in the <termref def="dt-default-uri-collection">default <phrase diff="del" at="bug28957">resource</phrase>
                           <phrase diff="add" at="bug28957">URI</phrase> collection</termref>.</p></item></ulist><p diff="del" at="bug28294">These input functions are all specified in  <bibref ref="xpath-functions-31"/>, which specifies error conditions and other details not described here.</p></div3><div3 id="id-uri-literals"><head>URI Literals</head><p>XPath 3.1 requires a statically known, valid URI in a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-BracedURILiteral" xlink:type="simple">BracedURILiteral</nt>. 

      An implementation may raise a <termref def="dt-static-error">static error</termref> 
                  <errorref class="ST" code="0046"/> if the value of  a Braced URI Literal is of nonzero length
      and is neither an
      absolute URI nor a relative URI.</p><note><p>The <code>xs:anyURI</code>
      type is designed to anticipate the introduction of
      Internationalized Resource Identifiers (IRI's) as defined in
      <bibref ref="RFC3987"/>.</p></note><p>Whitespace is normalized using the whitespace normalization rules
      of <code>fn:normalize-space</code>. If the result of whitespace
      normalization contains only whitespace, the corresponding URI
      consists of the empty string.  </p><p>A Braced URI Literal or URI Literal is not
      subjected to percent-encoding
      or decoding as defined in <bibref ref="RFC3986"/>.</p></div3><div3 id="id-resolve-relative-uri"><head>Resolving a Relative URI Reference</head><p>
                  <termdef id="dt-resolve-relative-uri" term="resolve">To
      <term>resolve a relative URI</term> 
                     <code>$rel</code> against a
      base URI <code>$base</code> is to expand it to an absolute URI,
      as if by calling the function <code>fn:resolve-uri($rel,
      $base)</code>.</termdef> During static analysis, the base URI is
      the Static Base URI. During dynamic evaluation, the base URI
      used to resolve a relative URI reference depends on the semantics of the
      expression.</p><p>Any process that attempts to <termref def="dt-resolve-relative-uri">resolve URI</termref> against a
      base URI, or to dereference the URI, may apply percent-encoding
      or decoding as defined in the relevant RFCs.</p></div3></div2><div2 id="id-types"><head>Types</head><p>The type system of XPath 3.1 is based on
		<bibref ref="XMLSchema10"/> or <bibref ref="XMLSchema11"/>.
                </p><p>
               <termdef id="dt-sequence-type" term="sequence type">A <term>sequence type</term> is a type that can be expressed using the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SequenceType" xlink:type="simple">SequenceType</nt>
syntax. Sequence types are used whenever it is necessary to refer to a type in an XPath 3.1 expression. The term <term>sequence type</term> suggests that this syntax is used to describe the type of an XPath 3.1 value, which is always a sequence.</termdef>
            </p><p>
               <termdef id="dt-schema-type" term="schema type">A <term>schema type</term> is a type that is (or could be) defined using the facilities of <bibref ref="XMLSchema10"/> or <bibref ref="XMLSchema11"/> (including the built-in types<phrase diff="del" at="bug28297">of <bibref ref="XMLSchema10"/> or <bibref ref="XMLSchema11"/>
                  </phrase>).</termdef> A schema type  can be used as a type annotation on an
element or attribute node (unless it is a non-instantiable type such as <code>xs:NOTATION</code> or <code>xs:anyAtomicType</code>, in which case its derived
types can be so used). Every schema type is either a <term>complex type</term> or a
<term>simple type</term>; simple types are further subdivided into <term>list types</term>, <term>union
types</term>, and <term>atomic types</term> (see <bibref ref="XMLSchema10"/> or <bibref ref="XMLSchema11"/> for definitions and explanations of these terms.)</p><p>
               <termdef id="dt-generalized-atomic-type" term="generalized atomic type">A <term>generalized atomic type</term> is a type which is either (a) an atomic type or (b) a <termref def="dt-pure-union-type">pure union type</termref>
               </termdef>.</p><p>
               <termdef id="dt-pure-union-type" term="pure union type">A <term>pure union type</term> is an XML Schema union type that satisfies the following constraints:
(1) <code>{variety}</code> is <code>union</code>, (2) the <code>{facets}</code> property is empty, (3) no type in the transitive membership of the union type has <code>{variety}</code> 
                  <code>list</code>, and (4) no type in the transitive membership of the union type is a type with <code>{variety}</code> 
                  <code>union</code> having a non-empty <code>{facets}</code> property</termdef>.</p><note><p>The definition of <termref def="dt-pure-union-type">pure union type</termref>
excludes union types derived by non-trivial restriction from other
union types, as well as union types that include list types in their
membership. Pure union types have the property that every
instance of an atomic type defined as one of the member types of the
union is also a valid instance of the union type.</p></note><note><p>The current (second) edition of XML Schema 1.0 contains an
error in respect of the substitutability of a union type by one of its
members: it fails to recognize that this is unsafe if the union is
derived by restriction from another union.</p><p>This problem is fixed in XSD 1.1, but the effect of the resolution
is that an atomic value labeled with an atomic type cannot be treated
as being substitutable for a union type without explicit validation.
This specification therefore allows union types to be used as item
types only if they are defined directly as the union of a number of
atomic types.</p></note><p>
               <termref def="dt-generalized-atomic-type">Generalized atomic types</termref>
represent the intersection between the categories of <termref def="dt-sequence-type">sequence type</termref> and <termref def="dt-schema-type">schema type</termref>. A generalized atomic type, such as <code>xs:integer</code> or <code>my:hatsize</code>, is both a <termref def="dt-sequence-type">sequence type</termref> and a
<termref def="dt-schema-type">schema type</termref>.</p><div3 id="id-predefined-types"><head>Predefined Schema Types</head><p role="xpath">The <termref def="dt-is-types">in-scope schema types</termref>
                 in the <termref def="dt-static-context">static
                 context</termref> are initialized with a set of
                 predefined schema types that is determined by the host
                 language. This set may include some or all of the
                 schema types in the
                 namespace
                 <code>http://www.w3.org/2001/XMLSchema</code>,
                 represented in this document by the namespace prefix
                 <code>xs</code>. The schema types in this namespace are defined in <bibref ref="XMLSchema10"/> or <bibref ref="XMLSchema11"/>
                 and augmented by additional types defined in <bibref ref="xpath-datamodel-31"/>. An implementation
                 that has based its type system on <bibref ref="XMLSchema10"/> is not required to support the <code>xs:dateTimeStamp</code> 
                  <phrase diff="add" at="bug28299">or <code>xs:error</code> types.</phrase>
                  <phrase diff="del" at="bug28299">type.</phrase>
               </p><p>The schema types defined in  <xspecref diff="chg" at="bug28298" spec="DM31" ref="types-predefined"/> are summarized below.</p><olist><item><p>
                        <termdef term="xs:untyped" id="dt-untyped">
                           <code>xs:untyped</code> is  used as the <termref def="dt-type-annotation">type annotation</termref> of an element node that has not been validated, or has been validated in <code>skip</code> mode.</termdef> No predefined schema types are derived from <code>xs:untyped</code>.</p></item><item><p>
                        <termdef id="dt-untypedAtomic" term="xs:untypedAtomic">
                           <code>xs:untypedAtomic</code>
is an atomic type that is used to denote untyped atomic data, such as text that has not been assigned a more specific type.</termdef> An attribute that has been validated in <code>skip</code> mode is represented in the <termref def="dt-datamodel">data model</termref> by an attribute node with the <termref def="dt-type-annotation">type annotation</termref> 
                        <code>xs:untypedAtomic</code>. No predefined schema types are derived from <code>xs:untypedAtomic</code>.</p></item><item><p>
                        <termdef term="xs:dayTimeDuration" id="dt-dayTimeDuration">
                           <code>xs:dayTimeDuration</code> is derived by restriction from <code>xs:duration</code>. The  lexical representation of <code>xs:dayTimeDuration</code>
is restricted to contain only day, hour, minute, and second
components.</termdef>
                     </p></item><item><p>
                        <termdef term="xs:yearMonthDuration" id="dt-yearMonthDuration">
                           <code>xs:yearMonthDuration</code> is derived by restriction from <code>xs:duration</code>. The lexical representation of <code>xs:yearMonthDuration</code> is
restricted to contain only year and month
components.</termdef>
                     </p></item><item><p>
                        <termdef term="xs:anyAtomicType" id="dt-anyAtomicType">
                           <code>xs:anyAtomicType</code> is an atomic type that includes all atomic values (and no values that
are not atomic). Its base type is
<code>xs:anySimpleType</code> from which all simple types, including atomic,
list, and union types, are derived. All primitive atomic types, such as
<code>xs:decimal</code> and <code>xs:string</code>, have <code>xs:anyAtomicType</code> as their base type.</termdef>
                     </p><note><p>
                           <code>xs:anyAtomicType</code>  will not appear as the type of an actual value in an <termref def="dt-data-model-instance">XDM instance</termref>.</p></note></item><item><p>
                        <termdef term="xs:error" id="dt-xs-error">
                           <code>xs:error</code> is a simple type with no value space.  It is defined in <xspecref spec="XS11-1" ref="xsd-error" diff="chg" at="bug28300"/> and <phrase diff="del" at="">In implementations that support XML Schema 1.1, it</phrase> can be used in the <specref ref="id-sequencetype-syntax"/> to raise errors.</termdef>
                     </p></item></olist><p>The relationships among the schema types in the <code>xs</code> namespace are illustrated in Figure 2. A more complete description of the XPath 3.1 type hierarchy can be found in 
<xspecref diff="chg" at="bug28301" spec="FO31" ref="datatypes"/>.</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="types.jpg" alt="Type Hierarchy Diagram" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>Figure 2: Hierarchy of Schema Types used in XPath 3.1.</p></div3><div3 id="id-namespace-sensitive"><head>Namespace-sensitive Types</head><p>
                  <termdef term="namespace-sensitive" id="dt-namespace-sensitive">The <term>namespace-sensitive</term>
  types are <code>xs:QName</code>, <code>xs:NOTATION</code>, types
  derived by restriction from <code>xs:QName</code> or
  <code>xs:NOTATION</code>, list types that have a namespace-sensitive
  item type, and union types with a namespace-sensitive type in their
  transitive membership.</termdef>
               </p><p>It is not possible to preserve the type of a <termref def="dt-namespace-sensitive">namespace-sensitive</termref> value without also preserving the namespace binding that defines the meaning of each namespace prefix used in the value. Therefore, XPath 3.1 defines some error conditions that occur only with <termref def="dt-namespace-sensitive">namespace-sensitive</termref> values. For instance, casting to a <termref def="dt-namespace-sensitive">namespace-sensitive</termref> type raises 
 a <termref def="dt-type-error">type error</termref> 
                  <xerrorref spec="FO31" class="NS" code="0004"/> if the namespace bindings for the result cannot be determined. </p></div3><div3 id="id-typed-value"><head>Typed Value and String Value</head><p>Every node has a <term>typed value</term> and a <term>string value</term>, except for nodes whose value is <xtermref spec="DM31" ref="dt-absent"/>.

<termdef term="typed value" id="dt-typed-value">The <term>typed
value</term> of a node is a sequence of atomic values and can be
extracted by applying the <xspecref diff="chg" at="bug28302" spec="FO31" ref="func-data"/> function to the
node.</termdef> 
                  <termdef id="dt-string-value" term="string value">The
<term>string value</term> of a node is a string and can be extracted
by applying the <xspecref diff="chg" at="bug28302" spec="FO31" ref="func-string"/>
function to the node.</termdef>
                  <phrase diff="del" at="bug28302">Definitions of <code>fn:data</code> and <code>fn:string</code> can be found in <bibref ref="xpath-functions-31"/>.</phrase>
               </p><p>An implementation may store both the <termref def="dt-typed-value">typed value</termref> and the <termref def="dt-string-value">string value</termref> of a node, or it may store only one of these and derive the other as needed. The string value of a node must be a valid lexical representation of the typed value of the node, but the node is not required to preserve the string representation from the original source document. For example, if the typed value of a node is the <code>xs:integer</code> value <code>30</code>, its string value might be "<code>30</code>" or "<code>0030</code>".</p><p role="xpath">The <termref def="dt-typed-value">typed value</termref>, <termref def="dt-string-value">string value</termref>, and <termref def="dt-type-annotation">type annotation</termref> of a node are closely related.  If the node was created by mapping from an Infoset or PSVI, the relationships among these properties are defined by rules in <xspecref diff="chg" at="bug28303" spec="DM31" ref="types"/>.</p><p>As a convenience to the reader, the relationship between <termref def="dt-typed-value">typed value</termref> and
 <termref def="dt-string-value">string value</termref> for various kinds of nodes is summarized and illustrated
 by examples below.</p><olist><item><p>For text and document nodes, the typed value of the node is the same as its
string value, as an instance of  the type <code>xs:untypedAtomic</code>. The
string value of a document node is formed by concatenating the string
values of all its descendant text nodes, in <termref def="dt-document-order">document
order</termref>.</p></item><item><p>The typed value of a comment<phrase role="xpath">, namespace,</phrase> or processing instruction node is the same as its string value. It is an instance of the type <code>xs:string</code>.</p></item><item><p>The typed value of an attribute node with
the <termref def="dt-type-annotation">type annotation</termref> 
                        <code>xs:anySimpleType</code> or <code>xs:untypedAtomic</code> is the same as its
string value, as an instance of <code>xs:untypedAtomic</code>. The
typed value of an attribute node with any other type annotation is
derived from its string value and type annotation using the lexical-to-value-space mapping defined in <bibref ref="XMLSchema10"/> or <bibref ref="XMLSchema11"/> Part 2 for
the relevant type.</p><p>Example: A1 is an attribute
having string value <code>"3.14E-2"</code> and type annotation
<code>xs:double</code>.  The typed value of A1 is the
<code>xs:double</code> value whose lexical representation is
<code>3.14E-2</code>. </p><p>Example: A2 is an attribute with type
annotation <code>xs:IDREFS</code>, which is a list datatype whose item type is the atomic datatype <code>xs:IDREF</code>. Its string value is
"<code>bar baz faz</code>". The typed value of A2 is a sequence of
three atomic values ("<code>bar</code>", "<code>baz</code>",
"<code>faz</code>"), each of type <code>xs:IDREF</code>. The typed
value of a node is never treated as an instance of a named list
type. Instead, if the type annotation of a node is a list type (such
as <code>xs:IDREFS</code>), its typed value is treated as a sequence
of the <termref def="dt-generalized-atomic-type">generalized atomic type</termref> from which it is derived (such as
<code>xs:IDREF</code>).</p></item><item><p>For an element node, the
relationship between typed value and string value depends on the
node's <termref def="dt-type-annotation">type annotation</termref>, as follows:</p><olist><item><p>If the type annotation is <code>xs:untyped</code> or <code>xs:anySimpleType</code> or
denotes a complex type with mixed content (including <code>xs:anyType</code>), then the typed value of the
node is equal to its string value, as an instance of
<code>xs:untypedAtomic</code>.  However, if the <code>nilled</code>
property of the node is <code>true</code>, then its typed value is the empty sequence.</p><p>Example: E1 is an element node
having type annotation <code>xs:untyped</code> and string value
"<code>1999-05-31</code>". The typed value of E1 is
"<code>1999-05-31</code>", as an instance of
<code>xs:untypedAtomic</code>.</p><p>Example: E2 is an element node
with the type annotation <code>formula</code>, which is a complex type
with mixed content. The content of E2 consists of the character
"<code>H</code>", a child element named <code>subscript</code> with
string value "<code>2</code>", and the character "<code>O</code>". The
typed value of E2 is "<code>H2O</code>" as an instance of
<code>xs:untypedAtomic</code>.</p></item><item><p>If the type
annotation denotes a simple type or a complex type with simple
content, then the typed value of the node is derived from its string
value and its type annotation in a way that is consistent with schema
validation. However, if the <code>nilled</code>
property of the node is <code>true</code>, then its typed value is the empty sequence.</p><p>Example: E3 is an element node with the type
annotation <code>cost</code>, which is a complex type that has several
attributes and a simple content type of <code>xs:decimal</code>. The
string value of E3 is "<code>74.95</code>". The typed value of E3 is
<code>74.95</code>, as an instance of
<code>xs:decimal</code>.</p><p>Example: E4 is an element node with the
type annotation <code>hatsizelist</code>, which is a simple type
derived from the atomic type <code>hatsize</code>, which in turn is
derived from <code>xs:integer</code>. The string value of E4 is
"<code>7 8 9</code>". The typed value of E4 is a sequence of three
values (<code>7</code>, <code>8</code>, <code>9</code>), each of type
<code>hatsize</code>.</p><p>Example: E5 is an element node with the type annotation <code>my:integer-or-string</code> which is a union type with member types <code>xs:integer</code> and <code>xs:string</code>. The string value of E5 is "<code>47</code>". The typed value of E5 is <code>47</code> as an <code>xs:integer</code>, since <code>xs:integer</code> is the member type that validated the content of E5. In general, when the type annotation of a node is a union type, the typed value of the node will be an instance of one of the member types of the union.</p><note><p>If an implementation stores only the string value of a node, and the type annotation of the node is a union type, the implementation must be able to deliver the typed value of the node as an instance of the appropriate member type.</p></note></item><item><p>If the type annotation
denotes a complex type with empty content, then the typed value of the
node is the empty sequence and its string value is the zero-length string.</p></item><item><p>If the type annotation
denotes a complex type with element-only content, then the typed value
of the node is <xtermref spec="DM31" ref="dt-absent" diff="chg" at="2013-12-07"/>. The <code>fn:data</code> function raises a
<termref def="dt-type-error">type error</termref> 
                              <xerrorref spec="FO31" class="TY" code="0012"/> when applied to such a node. The string value of such a node is equal to the concatenated string values of all its text node descendants, in document order.</p><p>Example: E6 is an
element node with the type annotation <code>weather</code>, which is a
complex type whose content type specifies
<code>element-only</code>. E6 has two child elements named
<code>temperature</code> and <code>precipitation</code>. The typed
value of E6 is <xtermref spec="DM31" ref="dt-absent" diff="chg" at="2013-12-07"/>, and the <code>fn:data</code> function
applied to E6 raises an error.
</p></item></olist></item></olist></div3><div3 id="id-sequencetype-syntax"><head>SequenceType Syntax</head><p>Whenever it is necessary to refer to a type in an XPath 3.1 expression, the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SequenceType" xlink:type="simple">SequenceType</nt> syntax is used.</p><scrap headstyle="show"><head/><prod num="79" id="doc-xpath31-SequenceType"><lhs>SequenceType</lhs><rhs>("empty-sequence"  "("  ")")<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ItemType" xlink:type="simple">ItemType</nt>  
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>?)</rhs></prod><prod num="81" id="doc-xpath31-ItemType"><lhs>ItemType</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-KindTest" xlink:type="simple">KindTest</nt>  |  ("item"  "("  ")")  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-FunctionTest" xlink:type="simple">FunctionTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-MapTest" xlink:type="simple">MapTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ArrayTest" xlink:type="simple">ArrayTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AtomicOrUnionType" xlink:type="simple">AtomicOrUnionType</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ParenthesizedItemType" xlink:type="simple">ParenthesizedItemType</nt>
                     </rhs></prod><prod num="80" id="doc-xpath31-OccurrenceIndicator"><lhs>OccurrenceIndicator</lhs><rhs>"?"  |  "*"  |  "+"</rhs><com>
                        <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-occurrence-indicators" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgc: occurrence-indicators</loc>
                     </com></prod><prod num="82" id="doc-xpath31-AtomicOrUnionType"><lhs>AtomicOrUnionType</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-EQName" xlink:type="simple">EQName</nt>
                     </rhs></prod><prod num="83" id="doc-xpath31-KindTest"><lhs>KindTest</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-DocumentTest" xlink:type="simple">DocumentTest</nt>
                        <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementTest" xlink:type="simple">ElementTest</nt>
                        <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AttributeTest" xlink:type="simple">AttributeTest</nt>
                        <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>
                        <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt>
                        <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-PITest" xlink:type="simple">PITest</nt>
                        <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-CommentTest" xlink:type="simple">CommentTest</nt>
                        <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TextTest" xlink:type="simple">TextTest</nt>
                        <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-NamespaceNodeTest" xlink:type="simple">NamespaceNodeTest</nt>
                        <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AnyKindTest" xlink:type="simple">AnyKindTest</nt>
                     </rhs></prod><prod num="85" id="doc-xpath31-DocumentTest"><lhs>DocumentTest</lhs><rhs>"document-node"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementTest" xlink:type="simple">ElementTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>)?  ")"</rhs></prod><prod num="94" id="noid_d3e4845.doc-xpath31-ElementTest"><lhs>ElementTest</lhs><rhs>"element"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementNameOrWildcard" xlink:type="simple">ElementNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypeName" xlink:type="simple">TypeName</nt>  "?"?)?)?  ")"</rhs></prod><prod num="96" id="noid_d3e4846.doc-xpath31-SchemaElementTest"><lhs>SchemaElementTest</lhs><rhs>"schema-element"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementDeclaration" xlink:type="simple">ElementDeclaration</nt>  ")"</rhs></prod><prod num="97" id="noid_d3e4847.doc-xpath31-ElementDeclaration"><lhs>ElementDeclaration</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementName" xlink:type="simple">ElementName</nt>
                     </rhs></prod><prod num="90" id="noid_d3e4848.doc-xpath31-AttributeTest"><lhs>AttributeTest</lhs><rhs>"attribute"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AttribNameOrWildcard" xlink:type="simple">AttribNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypeName" xlink:type="simple">TypeName</nt>)?)?  ")"</rhs></prod><prod num="92" id="noid_d3e4850.doc-xpath31-SchemaAttributeTest"><lhs>SchemaAttributeTest</lhs><rhs>"schema-attribute"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AttributeDeclaration" xlink:type="simple">AttributeDeclaration</nt>  ")"</rhs></prod><prod num="93" id="noid_d3e4851.doc-xpath31-AttributeDeclaration"><lhs>AttributeDeclaration</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AttributeName" xlink:type="simple">AttributeName</nt>
                     </rhs></prod><prod num="95" id="noid_d3e4852.doc-xpath31-ElementNameOrWildcard"><lhs>ElementNameOrWildcard</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementName" xlink:type="simple">ElementName</nt>  |  "*"</rhs></prod><prod num="99" id="doc-xpath31-ElementName"><lhs>ElementName</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-EQName" xlink:type="simple">EQName</nt>
                     </rhs></prod><prod num="91" id="noid_d3e4854.doc-xpath31-AttribNameOrWildcard"><lhs>AttribNameOrWildcard</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AttributeName" xlink:type="simple">AttributeName</nt>  |  "*"</rhs></prod><prod num="98" id="doc-xpath31-AttributeName"><lhs>AttributeName</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-EQName" xlink:type="simple">EQName</nt>
                     </rhs></prod><prod num="101" id="doc-xpath31-TypeName"><lhs>TypeName</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-EQName" xlink:type="simple">EQName</nt>
                     </rhs></prod><prod num="89" id="doc-xpath31-PITest"><lhs>PITest</lhs><rhs>"processing-instruction"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-NCName" xlink:type="simple">NCName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-StringLiteral" xlink:type="simple">StringLiteral</nt>)?  ")"</rhs></prod><prod num="87" id="doc-xpath31-CommentTest"><lhs>CommentTest</lhs><rhs>"comment"  "("  ")"</rhs></prod><prod num="88" id="doc-xpath31-NamespaceNodeTest"><lhs>NamespaceNodeTest</lhs><rhs>"namespace-node"  "("  ")"</rhs></prod><prod num="86" id="doc-xpath31-TextTest"><lhs>TextTest</lhs><rhs>"text"  "("  ")"</rhs></prod><prod num="84" id="doc-xpath31-AnyKindTest"><lhs>AnyKindTest</lhs><rhs>"node"  "("  ")"</rhs></prod><prod num="102" id="noid_d3e4863.doc-xpath31-FunctionTest"><lhs>FunctionTest</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AnyFunctionTest" xlink:type="simple">AnyFunctionTest</nt>
                        <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypedFunctionTest" xlink:type="simple">TypedFunctionTest</nt>
                     </rhs></prod><prod num="103" id="noid_d3e4864.doc-xpath31-AnyFunctionTest"><lhs>AnyFunctionTest</lhs><rhs>"function"  "("  "*"  ")"</rhs></prod><prod num="104" id="noid_d3e4865.doc-xpath31-TypedFunctionTest"><lhs>TypedFunctionTest</lhs><rhs>"function"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SequenceType" xlink:type="simple">SequenceType</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SequenceType" xlink:type="simple">SequenceType</nt>)*)?  ")"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SequenceType" xlink:type="simple">SequenceType</nt>
                     </rhs></prod><prod num="111" id="doc-xpath31-ParenthesizedItemType"><lhs>ParenthesizedItemType</lhs><rhs>"("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ItemType" xlink:type="simple">ItemType</nt>  ")"</rhs></prod><prod num="105" id="noid_d3e4867.doc-xpath31-MapTest"><lhs>MapTest</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AnyMapTest" xlink:type="simple">AnyMapTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypedMapTest" xlink:type="simple">TypedMapTest</nt>
                     </rhs></prod><prod num="108" id="noid_d3e4868.doc-xpath31-ArrayTest"><lhs>ArrayTest</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AnyArrayTest" xlink:type="simple">AnyArrayTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypedArrayTest" xlink:type="simple">TypedArrayTest</nt>
                     </rhs></prod></scrap><p>With the exception of the special type
<code>empty-sequence()</code>, a <termref def="dt-sequence-type">sequence type</termref> consists of an
<term>item type</term> that constrains the type of each item in the
sequence, and a <term>cardinality</term> that constrains the number of
items in the sequence. Apart from the item type <code>item()</code>,
which permits any kind of item, item types divide into <term>node
types</term> (such as <code>element()</code>), <term>generalized atomic
types</term> (such as <code>xs:integer</code>) and function types
(such as function() as item()*).</p><p>
                  <termref def="dt-qname">Lexical QNames</termref> appearing in a <termref def="dt-sequence-type">sequence type</termref> have their
		  prefixes expanded to namespace URIs by means of the
		  <termref def="dt-static-namespaces">statically known namespaces</termref> and (where applicable) the
		  <termref def="dt-def-elemtype-ns">default element/type namespace</termref>.
      Equality of QNames is defined by the <code>eq</code> operator.</p><p>Item types representing element
and attribute nodes may specify the required <termref def="dt-type-annotation">type annotations</termref> of those nodes, in
the form of a <termref def="dt-schema-type">schema
type</termref>. Thus the item type <code>element(*, us:address)</code>
denotes any element node whose type annotation is (or is derived from)
the schema type named <code>us:address</code>.</p><p>The occurrence indicators '+', '*', and '?' bind to the last <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ItemType" xlink:type="simple">ItemType</nt> in the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SequenceType" xlink:type="simple">SequenceType</nt>, as described in <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-occurrence-indicators" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">occurrence-indicators</loc> constraint.</p><p>Here are some examples of <termref def="dt-sequence-type">sequence types</termref> that
		  might be used in XPath 3.1:</p><ulist><item><p> 
                        <code>xs:date</code> refers to the built-in atomic schema type named <code>xs:date</code>
                     </p></item><item><p> 
                        <code>attribute()?</code> refers to an optional attribute node</p></item><item><p> 
                        <code>element()</code> refers to any element node</p></item><item><p> 
                        <code>element(po:shipto, po:address)</code> refers to an element node that has the name <code>po:shipto</code> and has the type annotation <code>po:address</code> (or a schema type derived from <code>po:address</code>)</p></item><item><p> 
                        <code>element(*, po:address)</code> refers to an element node of any name that has the type annotation <code>po:address</code> (or a type derived from <code>po:address</code>)</p></item><item><p>
                        <code>element(customer)</code> refers to an element node named <code>customer</code> with any type annotation</p></item><item><p>
                        <code>schema-element(customer)</code> refers to an element node whose name is <code>customer</code> (or is in the substitution group headed by <code>customer</code>) and whose type annotation matches the schema type declared for a <code>customer</code> element in the <termref def="dt-is-elems">in-scope element declarations</termref>
                     </p></item><item><p> 
                        <code>node()*</code> refers to a sequence of zero or more nodes of any kind</p></item><item><p> 
                        <code>item()+</code> refers to a sequence of one or more <termref def="dt-item">items</termref>
                     </p></item><item><p> 
                        <code>function(*)</code> refers to any <xtermref diff="chg" at="2013-12-07" spec="DM31" ref="dt-function-item">function</xtermref>, regardless of arity or type</p></item><item><p> 
                        <code>function(node()) as xs:string*</code> refers to a <xtermref diff="chg" at="2013-12-07" spec="DM31" ref="dt-function-item">function</xtermref> that takes a single argument whose value is a single node,
        and returns a sequence of zero or more xs:string values</p></item><item><p> 
                        <code>(function(node()) as xs:string)*</code> refers to a sequence of zero or more <xtermref diff="chg" at="2013-12-07" spec="DM31" ref="dt-function-item">functions</xtermref>, each of which takes a single
        argument whose value is a single node, and returns as its result a single xs:string value</p></item></ulist></div3><div3 id="id-sequencetype-matching"><head>SequenceType Matching</head><p> 
                  <termdef id="dt-sequencetype-matching" term="SequenceType matching">
                     <term>SequenceType matching</term> compares the <termref def="dt-dynamic-type">dynamic type</termref> of a value
		  with an expected <termref def="dt-sequence-type">sequence type</termref>. </termdef> For example, an <code>instance of</code> expression returns <code>true</code> if the <termref def="dt-dynamic-type">dynamic type</termref> of a given value matches a given <termref def="dt-sequence-type">sequence type</termref>, or <code>false</code> if it does not.</p><p>An XPath 3.1 implementation must be able to determine relationships among the types in type annotations in an <termref def="dt-data-model-instance">XDM instance</termref> and the types in the  <termref def="dt-issd">in-scope schema definitions</termref> (ISSD). </p><p>
                  <termdef term="subtype substitution" id="dt-subtype-substitution">The use of a value whose <termref def="dt-dynamic-type">dynamic type</termref> is derived from an
		  expected type is known as <term>subtype substitution</term>.</termdef>
		  Subtype substitution does not change the actual type of a value. For
		  example, if an <code>xs:integer</code> value is used where an
		  <code>xs:decimal</code> value is expected, the value retains its type
		  as <code>xs:integer</code>.</p><p>The definition of <termref def="dt-sequencetype-matching">SequenceType matching</termref> relies
		  on a pseudo-function named <code>derives-from(</code>
                  <emph>AT</emph>,
		  <emph>ET</emph>
                  <code>)</code>, which takes an actual simple or complex
		  schema type <emph>AT</emph> and an expected simple or complex schema
		  type <emph>ET</emph>, and either returns a boolean value or raises a
		  <termref def="dt-type-error">type error</termref> 
                  <errorref class="TY" code="0004"/>.  This function is defined as follows:</p><ulist><item><p>
                        <code>derives-from(</code>
                        <emph>AT</emph>, <emph>ET</emph>
                        <code>)</code> raises a type error <errorref class="TY" code="0004"/> if <emph>ET</emph> is
		    not present in the <termref def="dt-issd">in-scope schema definitions</termref> (ISSD). </p></item><item><p>
                        <code>derives-from(</code>
                        <emph>AT</emph>,
		    <emph>ET</emph>
                        <code>)</code> returns <code>true</code>  
		    if any of the following conditions applies:

		    <ulist><item><p>
                                 <emph>AT</emph> is <emph>ET</emph>
                              </p></item><item><p>
                                 <emph>ET</emph> is the base type of <emph>AT</emph>
                              </p></item><item><p>
                                 <emph>ET</emph> is a pure union type of which <emph>AT</emph> is a member type</p></item><item><p>There is a type <emph>MT</emph> such that <code>derives-from(</code>
                                 <emph>AT</emph>, <emph>MT</emph>
                                 <code>)</code> 
		      and <code>derives-from(</code>
                                 <emph>MT</emph>, <emph>ET</emph>
                                 <code>)</code>
                              </p></item></ulist>
                     </p></item><item><p>Otherwise, <code>derives-from(</code>
                        <emph>AT</emph>, <emph>ET</emph>
                        <code>)</code> returns <code>false</code>
                     </p></item></ulist><p>The rules for <termref def="dt-sequencetype-matching">SequenceType
		  matching</termref> are given below, with examples (the examples are
		  for purposes of illustration, and do not cover all possible
		  cases).</p><div4 id="id-matching-value"><head>Matching a SequenceType and a Value</head><ulist><item><p>The <termref def="dt-sequence-type">sequence type</termref> 
                           <code>empty-sequence()</code> matches a value that is the empty sequence.</p></item><item><p>An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ItemType" xlink:type="simple">ItemType</nt> with no <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt> matches any value that contains exactly one item if the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ItemType" xlink:type="simple">ItemType</nt> matches that item (see <specref ref="id-matching-item"/>).</p></item><item><p>An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ItemType" xlink:type="simple">ItemType</nt> with an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt> matches a value if the number of items in the value matches the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt> and the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ItemType" xlink:type="simple">ItemType</nt> matches each of the items in the value.</p></item></ulist><p>An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt> specifies the number of items in
		    a sequence, as follows:</p><ulist><item><p> 
                           <code>?</code> matches zero or one items</p></item><item><p> 
                           <code>*</code> matches zero or more items</p></item><item><p> 
                           <code>+</code> matches one or more items</p></item></ulist><p>As a consequence of these rules, any <termref def="dt-sequence-type">sequence type</termref> whose
		    <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt> is <code>*</code> or <code>?</code> matches a
		    value that is an empty sequence.</p></div4><div4 id="id-matching-item"><head>Matching an ItemType and an Item</head><ulist><item><p>An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ItemType" xlink:type="simple">ItemType</nt> consisting simply of an
    EQName is interpreted as an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AtomicOrUnionType" xlink:type="simple">AtomicOrUnionType</nt>.

    The expected type <emph>AtomicOrUnionType</emph> matches an atomic value whose
    actual type is <emph>AT</emph> if <code>derives-from(</code>
                           <emph>AT,
    AtomicOrUnionType</emph>
                           <code>)</code> is <code>true</code>.</p><p>
      The name of an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AtomicOrUnionType" xlink:type="simple">AtomicOrUnionType</nt>
      has its prefix expanded to a namespace URI by means of the
      <termref def="dt-static-namespaces">statically known namespaces</termref>, or if unprefixed, the
      <termref def="dt-def-elemtype-ns">default element/type namespace</termref>.
      If the <termref def="dt-expanded-qname">expanded QName</termref> of an
      <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AtomicOrUnionType" xlink:type="simple">AtomicOrUnionType</nt> is not defined as a  <termref def="dt-generalized-atomic-type">generalized atomic type</termref> in the <termref def="dt-is-types">in-scope schema
      types</termref>, a <termref def="dt-static-error">static
    error</termref> is raised <errorref class="ST" code="0051"/>.</p><p>Example: The <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ItemType" xlink:type="simple">ItemType</nt>
                           <code>xs:decimal</code> matches any value of type
    <code>xs:decimal</code>.  It also matches any value of type
    <code>shoesize</code>, if <code>shoesize</code> is an atomic type
    derived by restriction from <code>xs:decimal</code>.</p><p>Example: Suppose <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ItemType" xlink:type="simple">ItemType</nt> 
                           <code>dress-size</code> is a union type that allows
    either <code>xs:decimal</code> values for numeric sizes (e.g. 4, 6, 10, 12),
    or one of an enumerated set of <code>xs:strings</code> (e.g. "small", "medium", "large"). The <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ItemType" xlink:type="simple">ItemType</nt> 
                           <code>dress-size</code> matches any of these values.</p><note><p>The names of non-atomic
    types such as <code>xs:IDREFS</code> are not accepted in this context,
    but can often be replaced by a <termref def="dt-generalized-atomic-type">generalized atomic type</termref> with an occurrence indicator, such as
    <code>xs:IDREF+</code>.</p></note></item><item><p>
                           <code>item()</code> matches
    any single <termref def="dt-item">item</termref>.</p><p>Example: <code>item()</code> matches the atomic
    value <code>1</code>, the element <code>&lt;a/&gt;</code>, or the function <code>fn:concat#3</code>.</p></item><item><p>
                           <code>node()</code>
    matches any node.</p></item><item><p>
                           <code>text()</code> matches any
    text node.</p></item><item><p>
                           <code>processing-instruction()</code>
    matches any processing-instruction
    node.</p></item><item><p at="XQ.E27 and XP.E19">
                           <code>processing-instruction(</code>
                           <emph>N</emph>
                           <code>)</code>
    matches any processing-instruction node whose PITarget is equal to <code role="parse-test">fn:normalize-space(N)</code>. If <code>fn:normalize-space(N)</code> is not in the lexical space of NCName, a type error is raised <errorref class="TY" code="0004"/>
                        </p><p>Example:
    <code role="parse-test">processing-instruction(xml-stylesheet)</code> matches any
    processing instruction whose PITarget is
    <code>xml-stylesheet</code>.</p><p>For backward compatibility with
    XPath 1.0, the PITarget of a
    processing instruction may also be expressed as a
    string literal, as in this example:
    <code role="parse-test">processing-instruction("xml-stylesheet")</code>.</p><p>If the specified PITarget is not a syntactically valid NCName, a type error is raised <errorref class="TY" code="0004"/>.</p></item><item><p>
                           <code role="parse-test">comment()</code> matches any comment node.</p></item><item><p>
                           <code role="parse-test">namespace-node()</code> matches any
    namespace node.</p></item><item><p>
                           <code role="parse-test">document-node()</code> matches any document
    node.</p></item><item><p>
                           <code>document-node(</code>
                           <emph>E</emph>
                           <code>)</code>
    matches any document node that contains exactly one element node, optionally accompanied by one or more comment and processing instruction nodes, if
    <emph>E</emph> is an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementTest" xlink:type="simple">ElementTest</nt> or <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt> that matches the element node (see
    <specref ref="id-element-test"/> and <specref ref="id-schema-element-test"/>).</p><p>Example:
    <code role="parse-test">document-node(element(book))</code> matches a document node
    containing
    exactly one element node that is matched by the ElementTest
    <code role="parse-test">element(book)</code>.</p></item><item><p>A <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ParenthesizedItemType" xlink:type="simple">ParenthesizedItemType</nt> matches an item if and only if the
    item matches the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ItemType" xlink:type="simple">ItemType</nt> that is in parentheses.</p></item><item><p>An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ItemType" xlink:type="simple">ItemType</nt> that is an
    <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementTest" xlink:type="simple">ElementTest</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AttributeTest" xlink:type="simple">AttributeTest</nt>,
    <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt>, or <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-FunctionTest" xlink:type="simple">FunctionTest</nt> matches an item as described in the following sections.
    </p></item><item><p diff="add" at="2014-02-07">The <code>ItemType</code> 
                           <code>map(K, V)</code> matches an item <var>M</var> if (a) <var>M</var> is a 
    <termref def="dt-map">map</termref>, and (b) every
    entry in <var>M</var> has a key that matches <code>K</code> and an associated value that matches <code>V</code>. For example,
    <code>map(xs:integer, element(employee))</code> matches a map if all the keys in the map are integers, and all the associated
    values are <code>employee</code> elements. Note that a map (like a sequence) carries no intrinsic type information separate
    from the types of its entries, and the type of existing entries in a map does not constrain the type of new entries that can be
    added to the map.</p><note><p diff="add" at="2014-02-07">In consequence, <code>map(K, V)</code> matches an empty map, 
    whatever the types <var>K</var> and <var>V</var> might be.</p></note></item><item><p diff="add" at="2014-02-07">The <code>ItemType</code> 
                           <code>map(*)</code> matches
    any map regardless of its contents. It is equivalent to <code>map(xs:anyAtomicType, item()*)</code>.</p></item><item><p diff="add" at="2014-02-07">The <code>ItemType</code> 
                           <code>array(T)</code> matches any array in which the type of every member is <code>T</code>.</p></item><item><p diff="add" at="2014-02-07">The <code>ItemType</code> 
                           <code>array(*)</code> matches any array regardless of its contents.</p></item></ulist></div4><div4 id="id-element-test"><head>Element Test</head><scrap headstyle="show"><head/><prod num="94" id="doc-xpath31-ElementTest"><lhs>ElementTest</lhs><rhs>"element"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementNameOrWildcard" xlink:type="simple">ElementNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypeName" xlink:type="simple">TypeName</nt>  "?"?)?)?  ")"</rhs></prod><prod num="95" id="doc-xpath31-ElementNameOrWildcard"><lhs>ElementNameOrWildcard</lhs><rhs>
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementName" xlink:type="simple">ElementName</nt>  |  "*"</rhs></prod><prod num="99" id="noid_d3e5726.doc-xpath31-ElementName"><lhs>ElementName</lhs><rhs>
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-EQName" xlink:type="simple">EQName</nt>
                        </rhs></prod><prod num="101" id="noid_d3e5727.doc-xpath31-TypeName"><lhs>TypeName</lhs><rhs>
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-EQName" xlink:type="simple">EQName</nt>
                        </rhs></prod></scrap><p>
    An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementTest" xlink:type="simple">ElementTest</nt> is used to match an
    element node by its name and/or <termref def="dt-type-annotation">type annotation</termref>.
  </p><p>
    The <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementName" xlink:type="simple">ElementName</nt> and <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypeName" xlink:type="simple">TypeName</nt> of an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementTest" xlink:type="simple">ElementTest</nt>
    have their prefixes expanded to namespace URIs by means of the
    <termref def="dt-static-namespaces">statically known namespaces</termref>, or if unprefixed, the
    <termref def="dt-def-elemtype-ns">default element/type namespace</termref>.

    The <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementName" xlink:type="simple">ElementName</nt> need not be
    present in the <termref def="dt-is-elems">in-scope element declarations</termref>, but the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypeName" xlink:type="simple">TypeName</nt> must be present in the
    <termref def="dt-is-types">in-scope schema types</termref> 
                     <errorref class="ST" code="0008"/>. Note that
    <termref def="dt-substitution-group">substitution groups</termref> do not affect the semantics of <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementTest" xlink:type="simple">ElementTest</nt>.
  </p><p>
    An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementTest" xlink:type="simple">ElementTest</nt> may take any of the following forms:
  </p><olist><item><p>
                           <code role="parse-test">element()</code> and

<code role="parse-test">element(*)</code>  match any
single element node, regardless of its name or
type annotation.</p></item><item><p>
                           <code>element(</code>
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementName" xlink:type="simple">ElementName</nt>
                           <code>)</code>
matches any element node whose name is <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementName" xlink:type="simple">ElementName</nt>, regardless of its type annotation or <code>nilled</code> property.</p><p>Example: <code role="parse-test">element(person)</code> matches any element node whose name is <code>person</code>.</p></item><item><p>
                           <code>element(</code>
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementName" xlink:type="simple">ElementName</nt>
                           <code>,</code> 
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypeName" xlink:type="simple">TypeName</nt>
                           <code>)</code>
matches an element node whose name is <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementName" xlink:type="simple">ElementName</nt> if <code>derives-from(</code>
                           <emph>AT</emph>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypeName" xlink:type="simple">TypeName</nt> 
                           <code>)</code> is <code>true</code>, where <emph>AT</emph> is the type annotation of the element node, and the <code>nilled</code> property of the node is <code>false</code>.</p><p>Example: <code role="parse-test">element(person, surgeon)</code> matches a
non-nilled element node whose name is <code>person</code> and whose
type annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>). </p></item><item><p>
                           <code>element(</code>
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementName" xlink:type="simple">ElementName</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypeName" xlink:type="simple">TypeName</nt>
                           <code> ?)</code>
matches an element node whose name is <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementName" xlink:type="simple">ElementName</nt> if <code>derives-from(</code>
                           <emph>AT</emph>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypeName" xlink:type="simple">TypeName</nt>
                           <code>)</code> is <code>true</code>, where <emph>AT</emph> is the type annotation of the element node. The <code>nilled</code> property of the node may be either <code>true</code> or  <code>false</code>.</p><p>Example: <code role="parse-test">element(person, surgeon?)</code> matches a nilled or non-nilled element node whose name is <code>person</code> and whose type
annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>).</p></item><item><p>
                           <code>element(*,
</code>
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypeName" xlink:type="simple">TypeName</nt>
                           <code>)</code> matches an element
node regardless of its name, if
<code>derives-from(</code>
                           <emph>AT</emph>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypeName" xlink:type="simple">TypeName</nt> 
                           <code>)</code> is
<code>true</code>, where <emph>AT</emph> is the type annotation of the element node, and the <code>nilled</code> property of the node is <code>false</code>.</p><p>Example: <code role="parse-test">element(*, surgeon)</code>
matches any non-nilled element node whose type annotation is
<code>surgeon</code> (or is derived from <code>surgeon</code>), regardless of its name.</p></item><item><p>
                           <code>element(*,</code>
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypeName" xlink:type="simple">TypeName</nt>
                           <code> ?)</code> matches an element
node regardless of its name, if
<code>derives-from(</code>
                           <emph>AT</emph>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypeName" xlink:type="simple">TypeName</nt> 
                           <code>)</code> is
<code>true</code>, where <emph>AT</emph> is the type annotation of the element node. The <code>nilled</code> property of the node may be either <code>true</code> or  <code>false</code>.</p><p>Example: <code role="parse-test">element(*, surgeon?)</code>
matches any nilled or non-nilled element node whose type annotation is
<code>surgeon</code> (or is derived from <code>surgeon</code>), regardless of its name.</p></item></olist></div4><div4 id="id-schema-element-test"><head>Schema Element Test</head><scrap headstyle="show"><head/><prod num="96" id="doc-xpath31-SchemaElementTest"><lhs>SchemaElementTest</lhs><rhs>"schema-element"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementDeclaration" xlink:type="simple">ElementDeclaration</nt>  ")"</rhs></prod><prod num="97" id="doc-xpath31-ElementDeclaration"><lhs>ElementDeclaration</lhs><rhs>
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementName" xlink:type="simple">ElementName</nt>
                        </rhs></prod><prod num="99" id="noid_d3e6045.doc-xpath31-ElementName"><lhs>ElementName</lhs><rhs>
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-EQName" xlink:type="simple">EQName</nt>
                        </rhs></prod></scrap><p>
    A <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt> matches an element node against a corresponding
    element declaration found in the <termref def="dt-is-elems">in-scope element declarations</termref>.
  </p><p>
    The <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementName" xlink:type="simple">ElementName</nt> of a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>
    has its prefixes expanded to a namespace URI by means of the
    <termref def="dt-static-namespaces">statically known namespaces</termref>, or if unprefixed, the
    <termref def="dt-def-elemtype-ns">default element/type namespace</termref>.

    If the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementName" xlink:type="simple">ElementName</nt> specified in the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>
    is not found in the <termref def="dt-is-elems">in-scope element declarations</termref>, a
    <termref def="dt-static-error">static error</termref> is raised <errorref class="ST" code="0008"/>.
  </p><p>
    A <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt> matches a candidate element node if all of the following conditions are satisfied:
  </p><olist><item><p>Either:</p><olist><item><p>The name <emph>N</emph> of the candidate node matches the specified <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementName" xlink:type="simple">ElementName</nt>, or</p></item><item><p>The name <emph>N</emph> of the candidate node matches the name of an element declaration that is a member of the actual substitution group headed by the declaration of element <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementName" xlink:type="simple">ElementName</nt>.</p></item></olist><note><p>The term "actual substitution group" is defined in <bibref ref="XMLSchema11"/>. The actual substitution group of an element declaration <emph>H</emph> includes those element declarations <emph>P</emph> that are declared to have <emph>H</emph> as their direct or indirect substitution group head, provided that <emph>P</emph> is not declared as abstract, and that <emph>P</emph> is validly substitutable for <emph>H</emph>, which means that there must be no blocking constraints that prevent substitution.</p></note></item><item><p>The schema element declaration named <emph>N</emph> is not abstract.</p></item><item><p>
                           <code>derives-from( AT, ET )</code> is true, where <emph>AT</emph> is the type annotation of the candidate node and <emph>ET</emph> is the schema type declared in the schema element declaration named <emph>N</emph>.</p></item><item><p>If the schema element declaration named <emph>N</emph> is not nillable, then the nilled property of the candidate node is false.</p></item></olist><p>Example: The <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt> 
                     <code role="parse-test">schema-element(customer)</code> matches a candidate element node 
in the following two situations:
<olist><item><p>customer is a top-level element declaration in the in-scope element declarations; the name of the candidate node is customer; the element declaration of customer is not abstract; the type annotation of the candidate node is the same as or derived from the schema type declared in the customer element declaration; and either the candidate node is not nilled, or customer is declared to be nillable.</p></item><item><p>customer is a top-level element declaration in the in-scope element declarations; the name of the candidate node is client; client is an actual (non-abstract and non-blocked) member of the substitution group of customer; the type annotation of the candidate node is the same as or derived from the schema type declared for the client element; and either the candidate node is not nilled, or client is declared to be nillable.</p></item></olist>
                  </p></div4><div4 id="id-attribute-test"><head>Attribute Test</head><scrap headstyle="show"><head/><prod num="90" id="doc-xpath31-AttributeTest"><lhs>AttributeTest</lhs><rhs>"attribute"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AttribNameOrWildcard" xlink:type="simple">AttribNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypeName" xlink:type="simple">TypeName</nt>)?)?  ")"</rhs></prod><prod num="91" id="doc-xpath31-AttribNameOrWildcard"><lhs>AttribNameOrWildcard</lhs><rhs>
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AttributeName" xlink:type="simple">AttributeName</nt>  |  "*"</rhs></prod><prod num="98" id="noid_d3e6186.doc-xpath31-AttributeName"><lhs>AttributeName</lhs><rhs>
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-EQName" xlink:type="simple">EQName</nt>
                        </rhs></prod><prod num="101" id="noid_d3e6187.doc-xpath31-TypeName"><lhs>TypeName</lhs><rhs>
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-EQName" xlink:type="simple">EQName</nt>
                        </rhs></prod></scrap><p>
    An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AttributeTest" xlink:type="simple">AttributeTest</nt> is used to match an
    attribute node by its name and/or <termref def="dt-type-annotation">type annotation</termref>.
  </p><p>
    The <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AttributeName" xlink:type="simple">AttributeName</nt> and <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypeName" xlink:type="simple">TypeName</nt> of an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AttributeTest" xlink:type="simple">AttributeTest</nt>
    have their prefixes expanded to namespace URIs by means of the
    <termref def="dt-static-namespaces">statically known namespaces</termref>. If unprefixed, the
    <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AttributeName" xlink:type="simple">AttributeName</nt> is in no namespace, but an unprefixed <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypeName" xlink:type="simple">TypeName</nt> is in the
    <termref def="dt-def-elemtype-ns">default element/type namespace</termref>.

    The <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AttributeName" xlink:type="simple">AttributeName</nt> need not be present in the <termref def="dt-is-attrs">in-scope attribute declarations</termref>,
    but the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypeName" xlink:type="simple">TypeName</nt> must be present in the <termref def="dt-is-types">in-scope schema types</termref> 
                     <errorref class="ST" code="0008"/>.
  </p><p>
    An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AttributeTest" xlink:type="simple">AttributeTest</nt> may take any of the following forms:
  </p><olist><item><p>
                           <code role="parse-test">attribute()</code> and <code role="parse-test">attribute(*)</code> match any single attribute node,
regardless of its name or type annotation.</p></item><item><p>
                           <code>attribute(</code>
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AttributeName" xlink:type="simple">AttributeName</nt>
                           <code>)</code>
matches any attribute node whose name is <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AttributeName" xlink:type="simple">AttributeName</nt>, regardless of its type annotation.</p><p>Example: <code role="parse-test">attribute(price)</code>
matches any attribute node whose name is <code>price</code>.</p></item><item><p>
                           <code>attribute(</code>
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AttributeName" xlink:type="simple">AttributeName</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypeName" xlink:type="simple">TypeName</nt>
                           <code>)</code>
matches an attribute node whose name is <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AttributeName" xlink:type="simple">AttributeName</nt> if <code>derives-from(</code>
                           <emph>AT</emph>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypeName" xlink:type="simple">TypeName</nt> 
                           <code>)</code> is <code>true</code>, where <emph>AT</emph> is the type annotation of the attribute node.</p><p>Example: <code role="parse-test">attribute(price, currency)</code> matches an
attribute node whose name is <code>price</code> and whose type
annotation is
<code>currency</code> (or is derived from <code>currency</code>).</p></item><item><p>
                           <code>attribute(*,
</code>
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypeName" xlink:type="simple">TypeName</nt>
                           <code>)</code> matches an attribute
node regardless of its name, if
<code>derives-from(</code>
                           <emph>AT</emph>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypeName" xlink:type="simple">TypeName</nt>
                           <code>)</code> is
<code>true</code>, where <emph>AT</emph> is the type annotation of the attribute node.</p><p>Example:
<code role="parse-test">attribute(*, currency)</code> matches any attribute node whose
type annotation is <code>currency</code> (or is derived from <code>currency</code>), regardless of its
name.</p></item></olist></div4><div4 id="id-schema-attribute-test"><head>Schema Attribute Test</head><scrap headstyle="show"><head/><prod num="92" id="doc-xpath31-SchemaAttributeTest"><lhs>SchemaAttributeTest</lhs><rhs>"schema-attribute"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AttributeDeclaration" xlink:type="simple">AttributeDeclaration</nt>  ")"</rhs></prod><prod num="93" id="doc-xpath31-AttributeDeclaration"><lhs>AttributeDeclaration</lhs><rhs>
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AttributeName" xlink:type="simple">AttributeName</nt>
                        </rhs></prod><prod num="98" id="noid_d3e6373.doc-xpath31-AttributeName"><lhs>AttributeName</lhs><rhs>
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-EQName" xlink:type="simple">EQName</nt>
                        </rhs></prod></scrap><p>
    A <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt> matches an attribute node against a corresponding
    attribute declaration found in the <termref def="dt-is-attrs">in-scope attribute declarations</termref>.
  </p><p>
    The <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AttributeName" xlink:type="simple">AttributeName</nt> of a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt>
    has its prefixes expanded to a namespace URI by means of the
    <termref def="dt-static-namespaces">statically known namespaces</termref>. If unprefixed, an
    <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AttributeName" xlink:type="simple">AttributeName</nt> is in no namespace.

    If the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AttributeName" xlink:type="simple">AttributeName</nt> specified in the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt>
    is not found in the <termref def="dt-is-attrs">in-scope attribute declarations</termref>, a
    <termref def="dt-static-error">static error</termref> is raised <errorref class="ST" code="0008"/>.
  </p><p>
    A <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt> matches a candidate attribute node if both of the
  following conditions are satisfied:
  </p><olist><item><p>The name of the candidate node matches the specified <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AttributeName" xlink:type="simple">AttributeName</nt>.</p></item><item><p>
                           <code>derives-from(</code>
                           <emph>AT, ET</emph>
                           <code>)</code> is <code>true</code>, where <emph>AT</emph> is the type annotation of the candidate node and <emph>ET</emph> is the schema type declared for attribute <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AttributeName" xlink:type="simple">AttributeName</nt> in the <termref def="dt-is-attrs">in-scope attribute declarations</termref>.</p></item></olist><p>Example: The <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt> 
                     <code role="parse-test">schema-attribute(color)</code> matches a candidate attribute node if <code>color</code> is a top-level attribute declaration in the <termref def="dt-is-attrs">in-scope attribute declarations</termref>, the name of the candidate node is <code>color</code>, and the type annotation of the candidate node  is the same as or derived from the schema type declared for the <code>color</code> attribute.</p></div4><div4 id="id-function-test"><head>Function Test</head><scrap headstyle="show"><head/><prod num="102" id="doc-xpath31-FunctionTest"><lhs>FunctionTest</lhs><rhs>
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AnyFunctionTest" xlink:type="simple">AnyFunctionTest</nt>
                           <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypedFunctionTest" xlink:type="simple">TypedFunctionTest</nt>
                        </rhs></prod><prod num="103" id="doc-xpath31-AnyFunctionTest"><lhs>AnyFunctionTest</lhs><rhs>"function"  "("  "*"  ")"</rhs></prod><prod num="104" id="doc-xpath31-TypedFunctionTest"><lhs>TypedFunctionTest</lhs><rhs>"function"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SequenceType" xlink:type="simple">SequenceType</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SequenceType" xlink:type="simple">SequenceType</nt>)*)?  ")"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SequenceType" xlink:type="simple">SequenceType</nt>
                        </rhs></prod></scrap><p>
    A <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-FunctionTest" xlink:type="simple">FunctionTest</nt> matches a <xtermref diff="chg" at="2013-12-07" spec="DM31" ref="dt-function-item">function</xtermref>,
    potentially also checking its <xtermref diff="chg" at="2013-12-07" spec="DM31" ref="dt-signature">function signature</xtermref> .

    An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AnyFunctionTest" xlink:type="simple">AnyFunctionTest</nt>
    matches any item that is a function.

    A <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypedFunctionTest" xlink:type="simple">TypedFunctionTest</nt> matches an
    item if it is a <xtermref diff="chg" at="2013-12-07" spec="DM31" ref="dt-function-item">function</xtermref> and the function's type signature (as defined in
    <xspecref diff="chg" at="2013-12-07" spec="DM31" ref="function-items"/>) is a <termref def="dt-subtype">subtype</termref> of the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypedFunctionTest" xlink:type="simple">TypedFunctionTest</nt>.
  </p><p>
    Here are some examples of <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-FunctionTest" xlink:type="simple">FunctionTest</nt>s:
  </p><olist><item><p diff="add" at="2014-02-07">
                           <code>function(*)</code> matches any <phrase diff="chg">function, including maps and arrays.</phrase>
                        </p></item><item><p>
                           <code>function(int, int) as int</code> matches any <xtermref diff="chg" at="2013-12-07" spec="DM31" ref="dt-function-item">function</xtermref> with the function signature <code>function(int, int) as int</code>.
    </p></item><item><p diff="add" at="2014-02-07">
                           <code>function(xs:anyAtomicType) as item()*</code> matches any map<phrase diff="add" at="bug27059">, or any function with the required signature</phrase>.</p></item><item><p diff="add" at="2014-08-25">
                           <code>function(xs:integer) as item()*</code> matches any array<phrase diff="add" at="bug27059">, or any function with the required signature</phrase>.</p></item></olist></div4><div4 diff="add" at="2014-01-30" id="id-map-test"><head>Map Test</head><scrap headstyle="show" diff="chg" at="2014-02-07"><head/><prod num="105" id="doc-xpath31-MapTest"><lhs>MapTest</lhs><rhs>
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AnyMapTest" xlink:type="simple">AnyMapTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypedMapTest" xlink:type="simple">TypedMapTest</nt>
                        </rhs></prod><prod num="106" id="doc-xpath31-AnyMapTest"><lhs>AnyMapTest</lhs><rhs>"map"  "("  "*"  ")"</rhs></prod><prod num="107" id="doc-xpath31-TypedMapTest"><lhs>TypedMapTest</lhs><rhs>"map"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AtomicOrUnionType" xlink:type="simple">AtomicOrUnionType</nt>  ","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SequenceType" xlink:type="simple">SequenceType</nt>  ")"</rhs></prod></scrap><p diff="chg" at="2014-02-07">The <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-MapTest" xlink:type="simple">MapTest</nt> 
                     <code>map(*)</code> matches any map. The <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-MapTest" xlink:type="simple">MapTest</nt>
                     <code>map(X, Y)</code> matches any map where the type of every key
  is an instance of <code>X</code> and the type of every value is an
  instance of <code>Y</code>.</p><p>Examples:</p><p>Given a map <code>$M</code> whose keys are integers and whose
  results are strings, such as <code>map{0:"no", 1:"yes"}</code>,
  consider the results of the following expressions:
  </p><ulist><item><p>
                           <code>$M instance of map(*)</code>  returns <code>true()</code>
                        </p></item><item><p>
                           <code>$M instance of map(xs:integer, xs:string)</code>  returns <code>true()</code>
                        </p></item><item><p>
                           <code>$M instance of map(xs:decimal, xs:anyAtomicType)</code>  returns <code>true()</code>
                        </p></item><item><p>
                           <code>not($M instance of map(xs:int, xs:string))</code>  returns <code>true()</code>
                        </p></item><item><p>
                           <code>not($M instance of map(xs:integer, xs:token))</code>  returns <code>true()</code>
                        </p></item></ulist><p diff="add">Because of the rules for subtyping of function types according to their signature, it follows that the item type
  <code>function(A) as item()*</code>, where A is an atomic type, also matches any map, regardless of the type of the keys actually
  found in the map. For example, a map whose keys are all strings can be supplied where the required type is 
  <code>function(xs:integer) as item()*</code>; a call on the map that treats it as a function with an integer argument will always succeed,
  and will always return an empty sequence.</p><p diff="del" at="bug29586">The function signature of the map, treated as a function, is always <code>function(xs:anyAtomicType) as item()*</code>,
  regardless of the actual types of the keys and values in the map. This means that a function item type with a more specific return type,
  such as <code>function(xs:anyAtomicType) as xs:integer</code>, does not match a map in the sense required to satisfy the <code>instance of</code>
  operator. However, the rules for function coercion mean that any map can be supplied as a value in a context where such a type is the required
  type, and a type error will only occur if an actual call on the map (treated as a function) returns a value that is not an instance of the
  required return type.</p><p diff="add" at="bug29586">The function signature of a map matching type
  <code>map(K, V)</code>, treated as a function, is
  <code>function(xs:anyAtomicType) as V?</code>.  It is thus always a
  subtype of <code>function(xs:anyAtomicType) as item()*</code> regardless of the
  actual types of the keys and values in the map.  The rules for
  function coercion mean that any map can be supplied as a value in a
  context where the required type has a more specific return type,
  such as <code>function(xs:anyAtomicType) as xs:integer</code>, even when the map
  does not match in the sense required to satisfy the instance of
  operator. In such cases, a type error will only occur if an actual
  call on the map (treated as a function) returns a value that is not
  an instance of the required return type.
</p><p>Examples:</p><ulist><item><p>
                           <code>$M instance of function(*)</code>  returns <code>true()</code>
                        </p></item><item><p>
                           <code>$M instance of function(xs:anyAtomicType) as item()*</code> returns <code>true()</code>
                        </p></item><item><p>
                           <code>$M instance of function(xs:integer) as item()*</code>  returns <code>true()</code>
                        </p></item><item><p>
                           <code>$M instance of function(xs:int) as item()*</code>  returns <code>true()</code>
                        </p></item><item><p>
                           <code>$M instance of function(xs:string) as item()*</code>  returns <code>true()</code>
                        </p></item><item><p>
                           <code>not($M instance of function(xs:integer) as xs:string)</code>  returns <code>true()</code>
                        </p></item></ulist><note><p>The last case might seem surprising; however, function coercion ensures that <code>$M</code> can be used successfully 
  anywhere that the required type is <code>function(xs:integer) as xs:string</code>.</p></note></div4><div4 diff="add" at="2014-01-30" id="id-array-test"><head>Array Test</head><scrap headstyle="show"><head/><prod num="108" id="doc-xpath31-ArrayTest"><lhs>ArrayTest</lhs><rhs>
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AnyArrayTest" xlink:type="simple">AnyArrayTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypedArrayTest" xlink:type="simple">TypedArrayTest</nt>
                        </rhs></prod><prod num="109" id="doc-xpath31-AnyArrayTest"><lhs>AnyArrayTest</lhs><rhs>"array"  "("  "*"  ")"</rhs></prod><prod num="110" id="doc-xpath31-TypedArrayTest"><lhs>TypedArrayTest</lhs><rhs>"array"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SequenceType" xlink:type="simple">SequenceType</nt>  ")"</rhs></prod></scrap><p>The <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AnyArrayTest" xlink:type="simple">AnyArrayTest</nt> 
                     <code>array(*)</code> matches any
  array. The <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypedArrayTest" xlink:type="simple">TypedArrayTest</nt> 
                     <code>array(X)</code> matches any array
  <phrase diff="chg" at="2014-02-07">in which</phrase> every array member matches the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SequenceType" xlink:type="simple">SequenceType</nt> 
                     <code>X</code>.</p><p>Examples:</p><ulist><item><p>
                           <code>[ 1, 2 ] instance array(*)</code> returns <code>true()</code>
                        </p></item><item><p>
                           <code>[] instance of array(xs:string)</code> returns <code>true()</code>
                        </p></item><item><p>
                           <code>[ "foo" ] instance of array(xs:string)</code> returns <code>true()</code>
                        </p></item><item><p>
                           <code>[ "foo" ] instance of array(xs:integer)</code> returns <code>false()</code>
                        </p></item><item><p>
                           <code>[(1,2),(3,4)] instance of array(xs:integer)</code> returns <code>false()</code>
                        </p></item><item><p>
                           <code>[(1,2),(3,4)] instance of array(xs:integer+)</code> returns <code>true()</code>
                        </p></item></ulist><p>An array also matches certain other ItemTypes, including:</p><ulist><item><p>
                           <code>item()</code>
                        </p></item><item><p>
                           <code>function(*)</code>
                        </p></item><item><p>
                           <code>function(xs:integer) as item()*</code>
                        </p></item></ulist><p diff="del" at="bug29586">The function signature of the array, treated as a function, is always <code>function(xs:integer) as item()*</code>,
  regardless of the actual member types in the array. This means that a function item type with a more specific return type,
  such as <code>function(xs:integer) as xs:integer</code>, does not match an array in the sense required to satisfy the <code>instance of</code>
  operator. However, the rules for function coercion mean that any array can be supplied as a value in a context where such a type is the required
  type, and a type error will only occur if an actual call on the array (treated as a function) returns a value that is not an instance of the
  required return type.</p><p diff="add" at="bug29586">The function signature of an array
  matching <code>array(X)</code>, treated as a function, is
  <code>function(xs:integer) as X</code>.  It is thus always a subtype of
  <code>function(xs:integer) as item()*</code>
  regardless of the actual member types in the array.  The rules for
  function coercion mean that any array can be supplied as a value in
  a context where the required type has a more specific return type,
  such as <code>function(xs:integer) as xs:integer</code>, even when the array does
  not match in the sense required to satisfy the instance of
  operator. In such cases, a type error will only occur if an actual
  call on the array (treated as a function) returns a value that is
  not an instance of the required return type.</p></div4></div3><div3 id="id-sequencetype-subtype"><head>SequenceType Subtype Relationships</head><p>
  Given two <termref def="dt-sequence-type">sequence types</termref>, it is possible to determine if one is a subtype of the other.
  <termdef term="subtype" id="dt-subtype">A <termref def="dt-sequence-type">sequence type</termref> 
                     <code>A</code> is a <term>subtype</term> of a sequence type <code>B</code>
  if the judgement <code>subtype(A, B)</code> is true.</termdef>
  
  When the judgement <code>subtype(A, B)</code> is true, it is always the case that for any value <code>V</code>, <code>(V instance of A)</code> implies <code>(V instance of B)</code>.</p><div4 id="id-seqtype-subtype"><head>The judgement <code>subtype(A, B)</code>
                  </head><p>The judgement <code>subtype(A, B)</code> determines if the <termref def="dt-sequence-type">sequence type</termref> 
                     <code>A</code>
    is a <termref def="dt-subtype">subtype</termref> of the sequence type <code>B</code>.

    <code>A</code> can either be <code>empty-sequence()</code>, <code>xs:error</code>, or an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ItemType" xlink:type="simple">ItemType</nt>, <code>Ai</code>, possibly followed by an occurrence indicator. Similarly
    <code>B</code> can either be <code>empty-sequence()</code>, <code>xs:error</code>, or an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ItemType" xlink:type="simple">ItemType</nt>, <code>Bi</code>, possibly followed by an occurrence indicator.
    The result of the <code>subtype(A, B)</code> judgement can be determined from the table below, which makes use of the auxiliary judgement <code>subtype-itemtype(Ai, Bi)</code> defined
    in <specref ref="id-itemtype-subtype"/>.
    </p><table role="medium"><tbody><tr><th rowspan="2" colspan="2"/><th colspan="6" rowspan="1">
                              <termref def="dt-sequence-type">Sequence type</termref> 
                              <code>B</code>
                           </th></tr><tr><th rowspan="1" colspan="1">
                              <code>empty-sequence()</code>
                           </th><th rowspan="1" colspan="1">
                              <code>Bi?</code>
                           </th><th rowspan="1" colspan="1">
                              <code>Bi*</code>
                           </th><th rowspan="1" colspan="1">
                              <code>Bi</code>
                           </th><th rowspan="1" colspan="1">
                              <code>Bi+</code>
                           </th><th rowspan="1" colspan="1">xs:error</th></tr><tr><th rowspan="6" colspan="1">
                              <termref def="dt-sequence-type">Sequence type</termref> 
                              <code>A</code>
                           </th><th rowspan="1" colspan="1">
                              <code>empty-sequence()</code>
                           </th><td rowspan="1" colspan="1">true</td><td rowspan="1" colspan="1">true</td><td rowspan="1" colspan="1">true</td><td rowspan="1" colspan="1">false</td><td rowspan="1" colspan="1">false</td><td rowspan="1" colspan="1">false</td></tr><tr><th rowspan="1" colspan="1">
                              <code>Ai?</code>
                           </th><td rowspan="1" colspan="1">false</td><td rowspan="1" colspan="1">
                              <code>subtype-itemtype(Ai, Bi)</code>
                           </td><td rowspan="1" colspan="1">
                              <code>subtype-itemtype(Ai, Bi)</code>
                           </td><td rowspan="1" colspan="1">false</td><td rowspan="1" colspan="1">false</td><td rowspan="1" colspan="1">false</td></tr><tr><th rowspan="1" colspan="1">
                              <code>Ai*</code>
                           </th><td rowspan="1" colspan="1">false</td><td rowspan="1" colspan="1">false</td><td rowspan="1" colspan="1">
                              <code>subtype-itemtype(Ai, Bi)</code>
                           </td><td rowspan="1" colspan="1">false</td><td rowspan="1" colspan="1">false</td><td rowspan="1" colspan="1">false</td></tr><tr><th rowspan="1" colspan="1">
                              <code>Ai</code>
                           </th><td rowspan="1" colspan="1">false</td><td rowspan="1" colspan="1">
                              <code>subtype-itemtype(Ai, Bi)</code>
                           </td><td rowspan="1" colspan="1">
                              <code>subtype-itemtype(Ai, Bi)</code>
                           </td><td rowspan="1" colspan="1">
                              <code>subtype-itemtype(Ai, Bi)</code>
                           </td><td rowspan="1" colspan="1">
                              <code>subtype-itemtype(Ai, Bi)</code>
                           </td><td rowspan="1" colspan="1">false</td></tr><tr><th rowspan="1" colspan="1">
                              <code>Ai+</code>
                           </th><td rowspan="1" colspan="1">false</td><td rowspan="1" colspan="1">false</td><td rowspan="1" colspan="1">
                              <code>subtype-itemtype(Ai, Bi)</code>
                           </td><td rowspan="1" colspan="1">false</td><td rowspan="1" colspan="1">
                              <code>subtype-itemtype(Ai, Bi)</code>
                           </td><td rowspan="1" colspan="1">false</td></tr><tr><th rowspan="1" colspan="1">
                              <code>xs:error</code>
                           </th><td rowspan="1" colspan="1">true</td><td rowspan="1" colspan="1">true</td><td rowspan="1" colspan="1">true</td><td rowspan="1" colspan="1">true</td><td rowspan="1" colspan="1">true</td><td rowspan="1" colspan="1">true</td></tr></tbody></table><p>
                     <code>xs:error+</code> is treated the same way as <code>xs:error</code> in the above table. <code>xs:error?</code> and <code>xs:error*</code> are treated the same way as <code>empty-sequence()</code>.</p></div4><div4 id="id-itemtype-subtype"><head>The judgement <code>subtype-itemtype(Ai, Bi)</code> 
                  </head><p>The judgement <code>subtype-itemtype(Ai, Bi)</code> determines if the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ItemType" xlink:type="simple">ItemType</nt> 
                     <code>Ai</code>
    is a <termref def="dt-subtype">subtype</termref> of the ItemType <code>Bi</code>. <code>Ai</code> is a subtype of <code>Bi</code>
    if and only if at least one of the following conditions applies:
    </p><olist><item><p>
                           <code>Ai</code> and <code>Bi</code> are <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AtomicOrUnionType" xlink:type="simple">AtomicOrUnionTypes</nt>, and <code>derives-from(Ai, Bi)</code> returns <code>true</code>.
      </p></item><item><p>
                           <code>Ai</code> is a pure union type, 
      and every type <code>t</code> in the transitive membership of <code>Ai</code>
      satisfies <code>subtype-itemType(t, Bi)</code>.</p></item><item><p>
                           <code>Ai</code> is <code>xs:error</code> and <code>Bi</code> is a <termref def="dt-generalized-atomic-type">generalized atomic type</termref>.</p></item><item><p>
                           <code>Bi</code> is <code>item()</code>.
      </p></item><item><p>
                           <code>Bi</code> is <code>node()</code>, and <code>Ai</code> is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-KindTest" xlink:type="simple">KindTest</nt>.
      </p></item><item><p>
                           <code>Bi</code> is <code>text()</code> and <code>Ai</code> is also <code>text()</code>.
      </p></item><item><p>
                           <code>Bi</code> is <code>comment()</code> and <code>Ai</code> is also <code>comment()</code>.
      </p></item><item><p>
                           <code>Bi</code> is <code>namespace-node()</code> and <code>Ai</code> is also <code>namespace-node()</code>.
      </p></item><item><p>
                           <code>Bi</code> is <code>processing-instruction()</code> and <code>Ai</code> is either <code>processing-instruction()</code> or
      <code>processing-instruction(N)</code> for any name N.
      </p></item><item><p>
                           <code>Bi</code> is <code>processing-instruction(Bn)</code>, and <code>Ai</code> is also <code>processing-instruction(Bn)</code>.
      </p></item><item><p>
                           <code>Bi</code> is <code>document-node()</code> and <code>Ai</code> is either <code>document-node()</code> or
      <code>document-node(E)</code> for any <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementTest" xlink:type="simple">ElementTest</nt> E.
      </p></item><item><p>
                           <code>Bi</code> is <code>document-node(Be)</code> and <code>Ai</code> is <code>document-node(Ae)</code>, and <code>subtype-itemtype(Ae, Be)</code>.
      </p></item><item><p>
                           <code>Bi</code> is either <code>element()</code> or <code>element(*)</code>, and <code>Ai</code> is an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementTest" xlink:type="simple">ElementTest</nt>.
      </p></item><item><p>
                           <code>Bi</code> is either <code>element(Bn)</code> or <code>element(Bn, xs:anyType?)</code>,
      the <termref def="dt-expanded-qname">expanded QName</termref> of <code>An</code> equals the <termref def="dt-expanded-qname">expanded QName</termref> of <code>Bn</code>,
      and <code>Ai</code> is either <code>element(An)</code> 
                           <phrase diff="add" at="2014-12-08">or <code>element(An, T)</code> 
                           </phrase> 
      or <code>element(An, T?)</code> for any type T.
      </p></item><item><p>
                           <code>Bi</code> is <code>element(Bn, Bt)</code>,
      the <termref def="dt-expanded-qname">expanded QName</termref> of <code>An</code> equals the <termref def="dt-expanded-qname">expanded QName</termref> of <code>Bn</code>,
      <code>Ai</code> is <code>element(An, At)</code>, and <code>derives-from(At, Bt)</code> returns <code>true</code>.
      </p></item><item><p>
                           <code>Bi</code> is <code>element(Bn, Bt?)</code>,
      the <termref def="dt-expanded-qname">expanded QName</termref> of <code>An</code> equals the <termref def="dt-expanded-qname">expanded QName</termref> of <code>Bn</code>,
      <code>Ai</code> is either <code>element(An, At)</code> or <code>element(An, At?)</code>,
      and <code>derives-from(At, Bt)</code> returns <code>true</code>.
      </p></item><item><p>
                           <code>Bi</code> is <code>element(*, Bt)</code>, <code>Ai</code> is either <code>element(*, At)</code> or <code>element(N, At)</code> for any name N, and <code>derives-from(At, Bt)</code> returns <code>true</code>.
      </p></item><item><p>
                           <code>Bi</code> is <code>element(*, Bt?)</code>, <code>Ai</code> is either <code>element(*, At)</code>, <code>element(*, At?)</code>, <code>element(N, At)</code>, or <code>element(N, At?)</code> for any name N, and <code>derives-from(At, Bt)</code> returns <code>true</code>.
      </p></item><item><p>
                           <code>Bi</code> is <code>schema-element(Bn)</code>,
      <code>Ai</code> is <code>schema-element(An)</code>,
      and every element declaration that is an actual member of the substitution group of <code>An</code> is also an actual member of the substitution group of <code>Bn</code>.
      <note><p>The fact that <code>P</code> is a member of the substitution group of <code>Q</code> does not mean that every element declaration in the substitution group of <code>P</code> is also in the substitution group of <code>Q</code>. For example, <code>Q</code> might block substitution of elements whose type is derived by extension, while <code>P</code> does not.</p></note>
                        </p></item><item><p>
                           <code>Bi</code> is either <code>attribute()</code> or <code>attribute(*)</code>, and <code>Ai</code> is an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AttributeTest" xlink:type="simple">AttributeTest</nt>.
      </p></item><item><p>
                           <code>Bi</code> is either <code>attribute(Bn)</code> or <code>attribute(Bn, xs:anyType)</code>,
      the <termref def="dt-expanded-qname">expanded QName</termref> of <code>An</code> equals the <termref def="dt-expanded-qname">expanded QName</termref> of <code>Bn</code>,
      and <code>Ai</code> is either <code>attribute(An)</code>, or <code>attribute(An, T)</code> for any type T.
      </p></item><item><p>
                           <code>Bi</code> is <code>attribute(Bn, Bt)</code>,
      the <termref def="dt-expanded-qname">expanded QName</termref> of <code>An</code> equals the <termref def="dt-expanded-qname">expanded QName</termref> of <code>Bn</code>,
      <code>Ai</code> is <code>attribute(An, At)</code>,
      and <code>derives-from(At, Bt)</code> returns <code>true</code>.
      </p></item><item><p>
                           <code>Bi</code> is <code>attribute(*, Bt)</code>, <code>Ai</code> is either <code>attribute(*, At)</code>, or <code>attribute(N, At)</code> for any name N, and <code>derives-from(At, Bt)</code> returns <code>true</code>.
      </p></item><item><p>
                           <code>Bi</code> is <code>schema-attribute(Bn)</code>,
      the <termref def="dt-expanded-qname">expanded QName</termref> of <code>An</code> equals the <termref def="dt-expanded-qname">expanded QName</termref> of <code>Bn</code>,
      and <code>Ai</code> is <code>schema-attribute(An)</code>.
      </p></item><item diff="chg" at="bug29414"><p>
                           <code>Bi</code> is <code> function(*)</code>,
      <code>Ai</code> is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-FunctionTest" xlink:type="simple">FunctionTest</nt>.
      </p></item><item><p>
                           <code>Bi</code> is <code>function(Ba_1, Ba_2, ... Ba_N) as Br</code>,
      <code>Ai</code> is <code>function(Aa_1, Aa_2, ... Aa_M) as Ar</code>,
      where 
      
      <code>N</code> (arity of Bi) equals <code>M</code> (arity of Ai);
      <code>subtype(Ar, Br)</code>;
      <phrase role="xpath">and</phrase>
      for values of <code>I</code> between 1 and <code>N</code>, <code>subtype(Ba_I, Aa_I)</code>.
      </p><note><p>Function return types are covariant because this rule invokes subtype(Ar, Br) for  return types. Function arguments are contravariant because this rule invokes subtype(Ba_I, Aa_I) for arguments.</p></note></item><item><p diff="add" at="2014-02-07">
                           <code>Ai</code> is <code>map(K, V)</code>,
      for any <code>K</code> and <code>V</code>
      and <code>Bi</code> is <code>map(*)</code>.</p></item><item><p diff="add" at="2014-02-07">
                           <code>Ai</code> is  <code>map(Ka, Va)</code> 
      and <code>Bi</code> is <code>map(Kb, Vb)</code>, 
      where <code>subtype-itemtype(Ka, Kb)</code>
      and <code>subtype(Va, Vb)</code>.</p></item><item><p diff="add" at="2014-02-07">
                           <code>Ai</code> is <code>map(*)</code> (or, because of the transitivity rules, any other map type), 
      and <code>Bi</code> 
      is <code>function(*)</code>.</p></item><item><p diff="add" at="2014-02-07">
                           <code>Ai</code> is <code>map(*)</code> 
      (or, because of the transitivity rules, any other map type),
      and <code>Bi</code> is 
      <code>function(xs:anyAtomicType) as item()*</code>.</p></item><item><p diff="add" at="2014-02-07">
                           <code>Ai</code> is <code>array(X)</code> and <code>Bi</code> is <code>array(*)</code>.</p></item><item><p diff="add" at="2014-02-07">
                           <code>Ai</code> is <code>array(X)</code> and <code>Bi</code> is <code>array(Y)</code>, and <code>subtype(X, Y)</code> is true.</p></item><item><p diff="add" at="2014-02-07">
                           <code>Ai</code> is <code>array(*)</code> (or, because of the transitivity rules, any other array type) and <code>Bi</code> is <code>function(*)</code>.</p></item><item><p diff="add" at="2014-02-07">
                           <code>Ai</code> is <code>array(*)</code> (or, because of the transitivity rules, any other array type) and <code>Bi</code> is <code>function(xs:integer) as item()*</code>.</p></item><item><p diff="add" at="bug29586">
                           <code>Ai</code> is <code>map(K, V)</code>, and <code>Bi</code> is <code>function(xs:anyAtomicType) as V?</code>.</p></item><item><p diff="add" at="bug29586">
                           <code>Ai</code> is <code>array(X)</code> and <code>Bi</code> is <code>function(xs:integer) as X</code>.</p></item></olist></div4></div3><div3 id="id-xs-error" diff="chg"><head>xs:error</head><p>The type <code>xs:error</code> has an empty value space; it never appears as a dynamic type or as the content type of a dynamic element or attribute type. 
		<phrase diff="del" at="bug29119">
                     <code>xs:error</code> offers an alternative way of raising errors, in addition to fn:error.</phrase>

                  <phrase diff="add" at="bug29119">It was defined in XML Schema in the interests of making the type system complete and closed, and it is also available in XPath 3.1
                for similar reasons.</phrase>
               </p><note diff="add" at="bug29119"><p>Even though it cannot occur in an instance, <code>xs:error</code> is a valid type name in a sequence type. The
                practical uses of <code>xs:error</code> as a sequence type are limited, but they do exist. For instance, an error handling function that always raises a dynamic error 
                never returns a value, so <code>xs:error</code> is a good choice for the return type of the function.</p><p>The semantics of <code>xs:error</code> are well-defined as a consequence of the fact that <code>xs:error</code> is defined as a union type with
                no member types. For example:</p><ulist><item><p>
                           <code role="parse-test">$x instance of xs:error</code> always returns false, regardless of the value of <code>$x</code>.</p></item><item><p>
                           <code role="parse-test">$x cast as xs:error</code> fails dynamically with error <xerrorref spec="FO31" class="RG" code="0001"/>,  regardless of the value of <code>$x</code>.</p></item><item><p>
                           <code role="parse-test">$x cast as xs:error?</code> raises a <termref def="dt-dynamic-error">dynamic error</termref>
                           <xerrorref spec="FO31" class="RG" code="0001"/> if <code>exists($x)</code>, evaluates to the empty sequence if <code>empty($x)</code>.</p></item><item><p>
                           <code role="parse-test">xs:error($x)</code> has the same semantics as <code>$x cast as xs:error?</code> (see the previous bullet point)</p></item><item><p>
                           <code role="parse-test">$x castable as xs:error</code> evaluates to <code>false</code>, regardless of the value of <code>$x</code>.</p></item><item><p>
                           <code role="parse-test">$x treat as xs:error</code>  raises a <termref def="dt-dynamic-error">dynamic error</termref>
                           <errorref code="0050" class="DY"/> if evaluated, regardless of the value of <code>$x</code>. It never fails statically.</p></item></ulist><p>All of the above examples assume that <code>$x</code> is actually evaluated. If the result of the query does not depend on the value of <code>$x</code>. the rules specified in <specref ref="id-errors-and-opt"/> permit an implementation to avoid evaluating <code>$x</code> and thus to avoid raising an error.</p></note></div3></div2><div2 id="comments"><head>Comments</head><scrap headstyle="suppress"><head/><prod num="121" id="doc-xpath31-Comment"><lhs>Comment</lhs><rhs>"(:"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-CommentContents" xlink:type="simple">CommentContents</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Comment" xlink:type="simple">Comment</nt>)*  ":)"</rhs><com>
                     <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc>
                  </com><com>
                     <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-comments" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">gn: comments</loc>
                  </com></prod><prod num="126" id="doc-xpath31-CommentContents"><lhs>CommentContents</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-Char" xlink:type="simple">Char</nt>+ - (Char* ('(:' | ':)') Char*))</rhs></prod></scrap><p>Comments may be used to provide information relevant to programmers who read <phrase role="xpath">an expression</phrase>. Comments are lexical constructs only, and do not affect  <phrase role="xpath">expression</phrase> processing.</p><p>Comments are strings, delimited by the symbols <code>(:</code> and <code>:)</code>. Comments may be nested.</p><p>A comment may be used anywhere <termref def="IgnorableWhitespace">ignorable whitespace</termref> is allowed (see <specref ref="DefaultWhitespaceHandling"/>).</p><p>The following is an example of a comment:</p><eg xml:space="preserve">(: Houston, we have a problem :)</eg></div2></div1><div1 id="id-expressions"><head>Expressions</head><p>This section discusses each of the basic kinds of expression. Each kind of expression has a name such as <code>PathExpr</code>, which is introduced on the left side of the grammar production that defines the expression. Since XPath 3.1 is a composable language, each kind of expression is defined in terms of other expressions whose operators have a higher precedence. In this way, the precedence of operators is represented explicitly in the grammar.</p><p>The order in which expressions are discussed in this document does not reflect the order of operator precedence. In general, this document introduces the simplest kinds of expressions first, followed by more complex expressions.  For the complete grammar, see Appendix [<specref ref="nt-bnf"/>].</p><p> 
            <phrase role="xpath">The highest-level symbol in the XPath grammar is XPath.</phrase> 
         </p><scrap headstyle="show"><head/><prod num="1" id="doc-xpath31-XPath"><lhs>XPath</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Expr" xlink:type="simple">Expr</nt>
               </rhs></prod><prod num="6" id="doc-xpath31-Expr"><lhs>Expr</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod><prod num="7" id="doc-xpath31-ExprSingle"><lhs>ExprSingle</lhs><rhs>
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ForExpr" xlink:type="simple">ForExpr</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-LetExpr" xlink:type="simple">LetExpr</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-QuantifiedExpr" xlink:type="simple">QuantifiedExpr</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-IfExpr" xlink:type="simple">IfExpr</nt>
                  <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-OrExpr" xlink:type="simple">OrExpr</nt>
               </rhs></prod></scrap><p>The XPath 3.1 operator that has lowest precedence is the <termref def="dt-comma-operator">comma operator</termref>, which is used to combine two operands to form a sequence. As shown in the grammar, a general expression (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Expr" xlink:type="simple">Expr</nt>) can consist of multiple <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt> operands, separated by commas. The name <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt> denotes an expression that does not contain a top-level <termref def="dt-comma-operator">comma operator</termref> (despite its name, an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt> may evaluate to a sequence containing more than one item.)</p><p>The symbol <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt> is used in various places in the grammar where an expression is not allowed to contain a top-level comma. For example, each of the arguments of a function call must be an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>, because commas are used to separate the arguments of a function call.</p><p>After the comma, the expressions that have next lowest precedence are

<phrase role="xpath">
               <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ForExpr" xlink:type="simple">ForExpr</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-LetExpr" xlink:type="simple">LetExpr</nt>, </phrase>
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-QuantifiedExpr" xlink:type="simple">QuantifiedExpr</nt>,

<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-IfExpr" xlink:type="simple">IfExpr</nt>,

and <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-OrExpr" xlink:type="simple">OrExpr</nt>. Each of these expressions is described in a separate section of this document.</p><div2 id="id-primary-expressions"><head>Primary Expressions</head><p> 
               <termdef id="dt-primary-expression" term="primary expression">
                  <term>Primary expressions</term> are the basic primitives of the
	 language. They include literals, variable references,  context item expressions,  and function calls. A primary expression may also be created by enclosing any expression in parentheses, which is sometimes helpful in controlling the precedence of operators.</termdef>  
               <phrase diff="add" at="2014-02-07">Map and Array Constructors are described in <specref ref="id-maps-and-arrays"/>.</phrase>

            </p><scrap headstyle="show"><head/><prod num="56" id="doc-xpath31-PrimaryExpr"><lhs>PrimaryExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Literal" xlink:type="simple">Literal</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-VarRef" xlink:type="simple">VarRef</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ParenthesizedExpr" xlink:type="simple">ParenthesizedExpr</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ContextItemExpr" xlink:type="simple">ContextItemExpr</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-FunctionCall" xlink:type="simple">FunctionCall</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-FunctionItemExpr" xlink:type="simple">FunctionItemExpr</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-MapConstructor" xlink:type="simple">MapConstructor</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ArrayConstructor" xlink:type="simple">ArrayConstructor</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-UnaryLookup" xlink:type="simple">UnaryLookup</nt>
                  </rhs></prod><prod num="66" id="doc-xpath31-FunctionItemExpr"><lhs>FunctionItemExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-NamedFunctionRef" xlink:type="simple">NamedFunctionRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-InlineFunctionExpr" xlink:type="simple">InlineFunctionExpr</nt>
                  </rhs></prod></scrap><div3 id="id-literals"><head>Literals</head><p> 
                  <termdef id="dt-literal" term="literal">A <term>literal</term> is a direct syntactic representation of an
		atomic value.</termdef> XPath 3.1 supports two kinds of literals: numeric literals and
		string literals.</p><scrap headstyle="show"><head/><prod num="57" id="doc-xpath31-Literal"><lhs>Literal</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-NumericLiteral" xlink:type="simple">NumericLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-StringLiteral" xlink:type="simple">StringLiteral</nt>
                     </rhs></prod><prod num="58" id="doc-xpath31-NumericLiteral"><lhs>NumericLiteral</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-IntegerLiteral" xlink:type="simple">IntegerLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-DecimalLiteral" xlink:type="simple">DecimalLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-DoubleLiteral" xlink:type="simple">DoubleLiteral</nt>
                     </rhs></prod><prod num="113" id="doc-xpath31-IntegerLiteral"><lhs>IntegerLiteral</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Digits" xlink:type="simple">Digits</nt>
                     </rhs></prod><prod num="114" id="doc-xpath31-DecimalLiteral"><lhs>DecimalLiteral</lhs><rhs>("."  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Digits" xlink:type="simple">Digits</nt>)  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Digits" xlink:type="simple">Digits</nt>  "."  [0-9]*)</rhs><com>
                        <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc>
                     </com></prod><prod num="115" id="doc-xpath31-DoubleLiteral"><lhs>DoubleLiteral</lhs><rhs>(("."  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Digits" xlink:type="simple">Digits</nt>)  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Digits" xlink:type="simple">Digits</nt>  ("."  [0-9]*)?))  [eE]  [+-]?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Digits" xlink:type="simple">Digits</nt>
                     </rhs><com>
                        <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc>
                     </com></prod><prod num="116" id="doc-xpath31-StringLiteral"><lhs>StringLiteral</lhs><rhs>('"'  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-EscapeQuot" xlink:type="simple">EscapeQuot</nt>  |  [^"])*  '"')  |  ("'"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-EscapeApos" xlink:type="simple">EscapeApos</nt>  |  [^'])*  "'")</rhs><com>
                        <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc>
                     </com></prod><prod num="119" id="doc-xpath31-EscapeQuot"><lhs>EscapeQuot</lhs><rhs>'""'</rhs></prod><prod num="120" id="doc-xpath31-EscapeApos"><lhs>EscapeApos</lhs><rhs>"''"</rhs></prod><prod num="125" id="doc-xpath31-Digits"><lhs>Digits</lhs><rhs>[0-9]+</rhs></prod></scrap><p> The value of a <term>numeric literal</term> containing no "<code>.</code>" and no <code>e</code> or <code>E</code> character is  an atomic value of type <code>xs:integer</code>. The value of a numeric literal containing "<code>.</code>" but no <code>e</code> or <code>E</code> character is an atomic value of type <code>xs:decimal</code>. The value of a numeric literal containing an <code>e</code> or <code>E</code> character is an atomic value of type <code>xs:double</code>. The value of the numeric literal is determined by casting it to the
appropriate type according to the rules for casting from <code>xs:untypedAtomic</code>
to a numeric type as specified in <xspecref spec="FO31" ref="casting-from-strings"/>.</p><note><p diff="add" at="bug29419">The effect of the above rule is that in the case of an integer or decimal literal, a dynamic error <xerrorref spec="FO31" class="AR" code="0002"/> will generally be raised if the literal is outside the range of values supported by the implementation (other options are available: see <xspecref spec="FO31" ref="op.numeric"/> for details.)</p><p role="xpath" diff="add" at="bug29419">The XML Schema specification allows implementations to impose a limit (which
must not be less than 18 digits) on the size of integer and decimal
values. The full range of values of built-in subtypes of <code>xs:integer</code>,
such as <code>xs:long</code> and <code>xs:unsignedLong</code>, can be supported only if the
limit is 20 digits or higher. Negative numbers such as the minimum
value of <code>xs:long</code> (<code>-9223372036854775808</code>) are technically unary
expressions rather than literals, but implementations may prefer to
ensure that they are expressible.</p></note><p id="id-string-literal">The value of a <term>string literal</term> is an atomic value whose  type is <code>xs:string</code> and whose value is the string denoted by the characters between the
		delimiting apostrophes or quotation marks. If the literal is delimited by apostrophes, two adjacent apostrophes within the literal are interpreted as a single apostrophe. Similarly, if the literal is delimited by quotation marks, two adjacent quotation marks within the literal are interpreted as one quotation mark.</p><p>Here are some examples of literal expressions:</p><ulist><item><p> 
                        <code role="parse-test">"12.5"</code> denotes the string containing the characters '1', '2', '.', and
			 '5'.</p></item><item><p> 
                        <code role="parse-test">12</code> denotes the <code>xs:integer</code> value twelve.</p></item><item><p> 
                        <code role="parse-test">12.5</code> denotes the <code>xs:decimal</code> value twelve and one half.</p></item><item><p> 
                        <code role="parse-test">125E2</code> denotes the <code>xs:double</code> value twelve thousand, five hundred.</p></item><item><p>
                        <code role="parse-test">"He said, ""I don't like it."""</code> denotes a string containing two quotation marks and one apostrophe.</p><note role="xpath"><p>When XPath expressions are embedded in contexts where quotation
marks have special significance, such as inside XML attributes, additional
escaping may be needed.</p></note></item></ulist><p>
      The <code>xs:boolean</code> values <code>true</code> and <code>false</code> can be constructed by calls to the
      <termref def="dt-built-in-function">built-in functions</termref> 
                  <code>fn:true()</code> and <code>fn:false()</code>, respectively.
    </p><p>Values of other <phrase diff="del" at="bug28915">atomic</phrase>
                  <phrase diff="add" at="bug28915">simple</phrase> types can be constructed by calling the <termref def="dt-constructor-function">constructor function</termref> for the given type. The constructor functions for XML Schema
		built-in types are defined in <xspecref diff="chg" at="bug28304" spec="FO31" ref="constructor-functions-for-xsd-types"/>. In general, the name of a constructor function for a given type is the same as the name of the type (including its namespace). For
		example:</p><ulist><item><p> 
                        <code role="parse-test">xs:integer("12")</code> returns the integer value twelve.</p></item><item><p> 
                        <code role="parse-test">xs:date("2001-08-25")</code> returns an item whose type is <code>xs:date</code> and whose value represents the date 25th August 2001.</p></item><item><p>
                        <code role="parse-test">xs:dayTimeDuration("PT5H")</code> returns an item whose type is <code>xs:dayTimeDuration</code> and whose value represents a duration of five hours.</p></item></ulist><p>Constructor functions can also be used to create special values that have no literal representation, as in the following examples:
<ulist><item><p>
                           <code role="parse-test">xs:float("NaN")</code> returns the special floating-point value, "Not a Number."</p></item><item><p>
                           <code role="parse-test">xs:double("INF")</code> returns the special double-precision value, "positive infinity."</p></item></ulist>
               </p><p>Constructor functions are available for all <termref diff="del" at="bug28915" def="dt-generalized-atomic-type">Generalized atomic types</termref>
                  <phrase diff="add" at="bug28915">simple types</phrase>,
including union types. For example, if <code>my:dt</code> is a user-defined union
type whose member types are <code>xs:date</code>, <code>xs:time</code>, and <code>xs:dateTime</code>, then
the expression <code>my:dt("2011-01-10")</code> creates an atomic value of type
<code>xs:date</code>. The rules follow XML Schema validation rules for union types:
the effect is to choose the first member type that accepts the given
string in its lexical space.</p><p>It is also possible to construct values of various types by using a <code>cast</code> expression. For example:</p><ulist><item><p> 
                        <code role="parse-test">9 cast as
                        hatsize</code> returns the atomic value <code>9</code>
			 whose type is  <code>hatsize</code>.</p></item></ulist></div3><div3 id="id-variables"><head>Variable References</head><scrap headstyle="show"><head/><prod num="59" id="doc-xpath31-VarRef"><lhs>VarRef</lhs><rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-VarName" xlink:type="simple">VarName</nt>
                     </rhs></prod><prod num="60" id="doc-xpath31-VarName"><lhs>VarName</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-EQName" xlink:type="simple">EQName</nt>
                     </rhs></prod></scrap><p> 
                  <termdef id="dt-variable-reference" term="variable reference">A <term>variable reference</term> is an EQName preceded by a $-sign.</termdef> 
An unprefixed variable reference is in no namespace. Two variable references are equivalent if their  <termref def="dt-expanded-qname">expanded QNames</termref>  are equal (as defined by the <code>eq</code> operator). The scope of a variable binding is defined separately for each kind of
expression that can bind variables.</p><p>Every variable reference must match a name in the <termref def="dt-in-scope-variables">in-scope variables</termref>. </p><p>Every variable binding has a static scope. The scope defines where
references to the variable can validly occur.

It is a <termref def="dt-static-error">static error</termref> 
                  <errorref class="ST" code="0008"/> to reference a variable that is not in scope. If a variable is bound in the <termref def="dt-static-context">static context</termref> for an expression, that variable is in scope for the entire expression except where it is occluded by another binding that uses the same name within that scope.</p><p>
At evaluation time, the value of a variable reference is the value to which the relevant variable is bound.</p></div3><div3 id="id-paren-expressions"><head>Parenthesized Expressions</head><scrap headstyle="show"><head/><prod num="61" id="doc-xpath31-ParenthesizedExpr"><lhs>ParenthesizedExpr</lhs><rhs>"("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Expr" xlink:type="simple">Expr</nt>?  ")"</rhs></prod></scrap><p>Parentheses may be used to override the precedence rules.
        For example, the expression <code role="parse-test">(2 + 4)
		    * 5</code> evaluates to thirty, since the parenthesized expression <code role="parse-test">(2 + 4)</code> is evaluated first and its result is multiplied by five. Without
			 parentheses, the expression <code role="parse-test">2 + 4 * 5</code> evaluates to twenty-two, because the multiplication operator has higher
			 precedence than the addition operator.</p><p>Empty parentheses are used to denote an empty sequence, as
		described in <specref ref="construct_seq"/>.</p></div3><div3 id="id-context-item-expression"><head>Context Item Expression</head><scrap headstyle="show"><head/><prod num="62" id="doc-xpath31-ContextItemExpr"><lhs>ContextItemExpr</lhs><rhs>"."</rhs></prod></scrap><p>A <term>context item expression</term> evaluates to
              the <termref def="dt-context-item">context item</termref>, which may be either a node (as in the
              expression
              <code role="parse-test">fn:doc("bib.xml")/books/book[fn:count(./author)&gt;1]</code>),
              or an atomic value or function (as in the expression <code role="parse-test">(1 to
              100)[. mod 5 eq 0]</code>).</p><p>If the <termref def="dt-context-item">context item</termref> is <xtermref spec="DM31" ref="dt-absent" diff="chg" at="2013-12-07"/>, a context item expression raises a <termref def="dt-dynamic-error">dynamic error</termref>  
                  <errorref class="DY" code="0002"/>.</p></div3><div3 id="id-function-calls"><head>Static Function Calls</head><p>
                  <termdef term="built-in function" id="dt-built-in-function">The <term>built-in functions</term> 
                     <phrase diff="del" at="bug28282">supported by XPath 3.1</phrase> are 
                <phrase diff="add" at="bug28282">the functions</phrase>
                defined in <bibref ref="xpath-functions-31"/>
                     <phrase diff="add" at="bug28282">in the 
                  <code>http://www.w3.org/2005/xpath-functions</code>,
                  <code>http://www.w3.org/2001/XMLSchema</code>,
                  <code>http://www.w3.org/2005/xpath-functions/math</code>,
                  <code>http://www.w3.org/2005/xpath-functions/map</code>,
                  and <code>http://www.w3.org/2005/xpath-functions/array</code> namespaces.
                </phrase>
                  </termdef> 
                
                  <phrase role="xpath" diff="add" at="bug28282">The set of built-in functions is specified by the host language.</phrase>

                  <phrase role="xpath">Additional functions may be provided in
		the <termref def="dt-static-context">static
		context</termref>. XPath per se does not provide a way
		to declare named functions, but a host language may provide
		such a mechanism.</phrase>

		             </p><scrap headstyle="show"><head/><prod num="63" id="doc-xpath31-FunctionCall"><lhs>FunctionCall</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-EQName" xlink:type="simple">EQName</nt>  
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ArgumentList" xlink:type="simple">ArgumentList</nt>
                     </rhs><com>
                        <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-reserved-function-names" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgc: reserved-function-names</loc>
                     </com><com>
                        <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-parens" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">gn: parens</loc>
                     </com></prod><prod num="50" id="noid_d3e8645.doc-xpath31-ArgumentList"><lhs>ArgumentList</lhs><rhs>"("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Argument" xlink:type="simple">Argument</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Argument" xlink:type="simple">Argument</nt>)*)?  ")"</rhs></prod><prod num="64" id="doc-xpath31-Argument"><lhs>Argument</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ArgumentPlaceholder" xlink:type="simple">ArgumentPlaceholder</nt>
                     </rhs></prod><prod num="65" id="doc-xpath31-ArgumentPlaceholder"><lhs>ArgumentPlaceholder</lhs><rhs>"?"</rhs></prod></scrap><p>
                  <termdef term="static function call" id="dt-static-function-call">A <term>static function call</term> consists of an EQName followed by a
		parenthesized list of zero or more arguments.</termdef> 
                  <termdef term="argument expression" id="dt-arg-expr">An argument to a function call is either an
    <term>argument expression</term> or an ArgumentPlaceholder ("?").</termdef> If the EQName in a static function
		call is a <termref def="dt-qname">lexical QName</termref> that has no namespace prefix, it is considered to be
		in the <termref def="dt-def-fn-ns">default function
		namespace.</termref>
               </p><p>If the <termref def="dt-expanded-qname">expanded QName</termref>
    and number of arguments in a static function call do not match the name and arity
		of a <termref def="dt-known-func-signatures">function signature</termref> in the
    <termref def="dt-static-context">static context</termref>,  a
    <termref def="dt-static-error">static error</termref> is raised <errorref class="ST" code="0017"/>.</p><p>
                  <termdef term="partial function application" id="dt-partial-function-application">
      A static or <termref def="dt-dynamic-function-invocation">dynamic</termref>
      function call is a <term>partial function application</term>
      if one or more arguments is an ArgumentPlaceholder.
    </termdef>    
               </p><p>
    Evaluation of function calls is described in <specref ref="id-eval-function-call"/>.
  </p><p>Since the arguments of a function call are separated by commas, any
<termref def="dt-arg-expr">argument expression</termref> that contains a top-level <termref def="dt-comma-operator">comma operator</termref> must be
enclosed in parentheses. Here are some illustrative examples of
static function calls:</p><ulist><item><p> 
                        <code role="parse-test">my:three-argument-function(1,
			2, 3)</code> denotes a static function call with three arguments.</p></item><item><p> 
                        <code role="parse-test">my:two-argument-function((1,
			2), 3)</code> denotes a static function call with two arguments, the first of which is a
			 sequence of two values.</p></item><item><p> 
                        <code role="parse-test">my:two-argument-function(1,
			())</code> denotes a static function call with two arguments, the second of which is an
			 empty sequence.</p></item><item><p> 
                        <code role="parse-test">my:one-argument-function((1, 2,
			3))</code> denotes a static function call with one argument that is a sequence of three
			 values. </p></item><item><p> 
                        <code role="parse-test">my:one-argument-function(( ))</code> denotes a static function call with one argument that is an empty sequence.</p></item><item><p> 
                        <code role="parse-test">my:zero-argument-function( )</code> denotes a static function call with zero arguments.</p></item></ulist><div4 id="id-eval-function-call"><head>Evaluating Static and Dynamic Function Calls</head><p>
                      When a static or dynamic function call <var>FC</var> is evaluated
                      with respect to a static context <var>SC</var> and
                      a dynamic context <var>DC</var>,
                      the result is obtained as follows:
                    </p><olist><item><p>
                          <termdef term="arity" id="dt-argumentlist-arity">
                            The number of <code>Argument</code>s
                            in an <code>ArgumentList</code>
                            is its <term>arity</term>.
                          </termdef>
                        </p></item><item><p>
                          The function <var>F</var> to be called or partially applied
                          is obtained as follows:
                        </p><olist><item><p>
                              If <var>FC</var> is a static function call:
                              Using
                              the expanded QName corresponding to <var>FC</var>'s <code>EQName</code>,
                              <!-- obtained during static analysis -->
                              and
                              the arity of <var>FC</var>'s <code>ArgumentList</code>,
                              the corresponding function
                              is looked up
                              in the <termref def="dt-named-functions">named functions</termref> component
                              of <var>DC</var>.
                              Let <var>F</var> denote the function obtained.
                              <!-- It must exist, otherwise static analysis would have raised XPST0017. -->
                            </p></item><item><p>
                              If <var>FC</var> is a dynamic function call:
                              <var>FC</var>'s base expression is evaluated with respect to <var>SC</var> and <var>DC</var>.
                              If this yields a sequence consisting of a single function
                              with the same arity as the arity of the <code>ArgumentList</code>,
                              let <var>F</var> denote that function.
                              Otherwise, a type error is raised
                              <errorref class="TY" code="0004"/>.
                            </p></item></olist></item><item><p>
                           <termdef term="argument value" id="dt-arg-value">
                              <termref def="dt-arg-expr">Argument expressions</termref> are evaluated with respect to <var>DC</var>, producing <term>argument
                        values</term>.</termdef> The order of argument evaluation is <termref def="dt-implementation-dependent">implementation-dependent</termref> and a function need not evaluate an argument if the function can evaluate its body without evaluating that argument.</p></item><item><p>
                          Each argument value is converted
                          to the corresponding parameter type in <var>F</var>'s signature
                          by applying the
                          <termref def="dt-function-conversion">function conversion rules</termref>,
                          resulting in a <termref def="dt-arg-value" diff="chg" at="bug29277">converted argument value</termref>.
                        </p></item><item><p>
                          The remainder depends on whether or not <var>FC</var>
                          is a <termref def="dt-partial-function-application">partial function application</termref>.
                        </p><olist><item><p>
                              If <var>FC</var> is a <termref def="dt-partial-function-application">partial function application</termref>
                                 <phrase diff="add" at="bug29277">the result of the function call is a new function, which is a <termref def="dt-partially-applied-function">partially applied function</termref>.
                              <termdef term="partially applied function" id="dt-partially-applied-function">A <term>partially applied function</term>
                              is a function created by  <termref def="dt-partial-function-application">partial function application</termref>.</termdef>
                                 </phrase>
                                 <termdef term="fixed position" id="dt-fixed-position">In a partial function application, a <term>fixed position</term>
                              is an argument/parameter position for which the <code>ArgumentList</code> has an argument expression (as opposed to an <code>ArgumentPlaceholder</code>).</termdef>
                              A partial function application need not have any fixed positions.  A <termref def="dt-partially-applied-function">partially applied function</termref> has
                              the following properties (which are defined in <xspecref diff="chg" at="2013-12-07" spec="DM31" ref="function-items"/>):
                            </p><ulist><item><p>
                                       <term>name</term>:
                                  Absent.
                                </p></item><item><p>
                                       <term>parameter names</term>:
                                  The parameter names of <var>F</var>,
                                  removing the parameter names at the fixed positions.
                                  (So the function's arity is
                                  the arity of F
                                  minus
                                  the number of fixed positions.)
                                </p></item><item><p>
                                       <term>signature</term>:
                                  The signature of <var>F</var>,
                                  removing the parameter type
                                  at each of the fixed positions.
				  <phrase diff="add" at="bug29586">
				    An implementation which can determine a more specific signature (for example, through use of type analysis) is permitted to do so.</phrase>
                                    </p></item><item><p>
                                       <term>implementation</term>:
                                  <phrase diff="del" at="bug29277">
                                  The implementation of <var>F</var>,
                                  associated with the same contexts as in <var>F</var>. If these contexts are absent in <var>F</var>, it is associated with <var>SC</var> and <var>DC</var>.
                                  </phrase>
                                       <phrase diff="add" at="bug29277">
                                  The implementation of <var>F</var>.
                                  If this is not an XPath 3.1 expression
                                  then the new function's implementation
                                  is associated with a static context and a dynamic context in one of two ways:
                                  if <var>F</var>'s implementation is already associated with contexts, then those are used; otherwise, <var>SC</var> and <var>DC</var> are used. 
                                  </phrase>
                                    </p></item><item><p>
                                       <term>nonlocal variable bindings</term>:
                                  The nonlocal variable bindings of <var>F</var>,
                                  plus, for each fixed position,
                                  a binding of the converted argument value
                                  to the corresponding parameter name.
                                </p></item></ulist><example diff="add" at="bug29277"><head>Partial Application of an Anonymous Function</head><p>In the following example, <code>$f</code> is an anonymous function, and <code>$paf</code> is a partially applied function created from <code>$f</code>.</p><eg role="parse-test" xml:space="preserve">
let $f := function ($seq, $delim) { fn:fold-left($seq, "", fn:concat(?, $delim, ?)) },
    $paf := $f(?, ".")
return $paf(1 to 5)
</eg><p>
                                    <code>$paf</code> is also an anonymous function.  It has one parameter, named <code>$delim</code>, which is taken from the corresponding parameter in <code>$f</code>
                              (the other parameter is fixed).  The implementation of <code>$paf</code> is the implementation of <code>$f</code>, which is <code>fn:fold-left($seq, "", fn:concat(?, $delim, ?))</code>.  This implementation is associated with the <code>SC</code> and <code>DC</code> of the original expression in <code>$f</code>.  The nonlocal bindings associate the value <code>"."</code> with the parameter <code>$delim</code>.</p></example><example diff="add" at="bug29277"><head>Partial Application of a Built-In Function</head><p>The following partial function application creates a function that computes the sum of squares of a sequence.</p><eg role="parse-test" xml:space="preserve">let $sum-of-squares := fn:fold-right(?, 0, function($a, $b) { $a*$a + $b })
return $sum-of-squares(1 to 3)</eg><p>
                                    <code>$sum-of-squares</code> is an anonymous function. It has one parameter, named <code>$seq</code>, which is taken from the corresponding parameter in <code>fn:fold-right</code> (the other two parameters are fixed). The implementation is the implementation of <code>fn:fold-right</code>, which is a built-in context-independent function.  The nonlocal bindings contain the fixed bindings for the second and third parameters of <code>fn:fold-right</code>.</p></example><p diff="add" at="A-640-03">Partial function application never returns a map or an array.  If <code>$F</code> is a map or an array, then <code>$F(?)</code> is 
                            a partial function application that returns a function, but the function it returns is not a map nor an array.</p><example diff="add" at="bug29277"><head>Partial Application of a Map</head><p>The following partial function application converts a map to an equivalent function that is not a map.</p><eg role="parse-test" xml:space="preserve">let $a := map {"A": 1, "B": 2}(?)
return $a("A")</eg></example></item><item><p>
                              If <var>FC</var> is not a partial function application,
                              <phrase diff="add" at="bug29277">
                              the semantics of the call depend on the nature of
                              function <var>F</var>'s 'implementation' property
                              (see <xspecref spec="DM31" ref="function-items"/>):
                              </phrase>
                                 <note diff="add" at="bug29277"><p>XPath 3.1 is a host language with respect to the <termref def="dt-datamodel">data model</termref>.
                              In XPath 3.1, if the implementation is a host language expression, then it is an XPath 3.1 expression.</p></note>
                              </p><olist><item diff="add" at="bug29277"><p>If <var>F</var> is a map, it is evaluated as described in <specref ref="id-map-lookup"/>.  If <var>F</var> is an array, it is evaluated as described in <specref ref="id-array-lookup"/>.</p></item><item><p>
                                  If <var>F</var>'s implementation is 
                                  <phrase diff="del" at="bug29277">a <code>FunctionBody</code>
                                       </phrase>
                                       <phrase diff="add" at="bug29277">an XPath 3.1 expression</phrase>
                                       <phrase diff="add" at="bug29277">
                                    (e.g., <var>F</var> is
                                    
                                    an <termref def="dt-anonymous-function">anonymous function</termref>,
                                    or a
                                    <termref def="dt-partially-applied-function">partial application</termref>
                                    of such a function):
                                  </phrase>
                                    </p><olist><item><p>                                      
                                             <phrase diff="del" at="bug29277">The <code>FunctionBody</code>
                                             </phrase>
                                             <phrase diff="add" at="bug29277">
                                                <var>F</var>'s implementation</phrase> 
                                      is evaluated.
                                      <phrase diff="add" at="bug29277">
                                        The static context for this evaluation
                                        is the static context of the XPath 3.1 expression.
                                      </phrase>
                                      The dynamic context for this evaluation is obtained
                                      by taking the dynamic context of the
                                      
                                      <phrase role="xpath">
                                                <code>InlineFunctionExpr</code>
                                             </phrase>
                                      that contains the <code>FunctionBody</code>, and
                                      making the following changes:
                                    </p><ulist><item><p>
                                          The <termref def="dt-focus">focus</termref>
                                          (context item, context position, and context size)
                                          is <xtermref spec="DM31" ref="dt-absent" diff="chg" at="2013-12-07"/>.
                                        </p></item><item><p>
                                          In the <termref def="dt-variable-values">variable values</termref> component of the dynamic context,
                                          each converted argument value is bound to the
                                          corresponding parameter name.
                                        </p><p>
                                          When
                                          this is done,
                                          the converted argument value retains
                                          its most specific
                                          <termref def="dt-dynamic-type">dynamic type</termref>,
                                          even though this type
                                          may be derived from the type of the formal parameter.
                                          For example, a function with
                                          a parameter <code>$p</code> of type <code>xs:decimal</code>
                                          can be invoked with an argument of type <code>xs:integer</code>,
                                          which is derived from <code>xs:decimal</code>.
                                          During the processing of this function
                                          call,
                                          the <termref def="dt-dynamic-type">dynamic type</termref>
                                          of <code>$p</code> inside the body of the function
                                          is considered to be <code>xs:integer</code>.
                                        </p></item><item><p>
                                          F's nonlocal variable bindings
                                          are also added to the <termref def="dt-variable-values">variable values</termref>.
                                          (Note that the names of the nonlocal variables
                                          are by definition disjoint from the parameter names,
                                          so there can be no conflict.)
                                        </p></item></ulist></item><item><p>
                                      The value returned by evaluating the function body
                                      is then converted to the declared return type of <var>F</var>
                                      by applying the
                                      <termref def="dt-function-conversion">function conversion rules</termref>.
                                      The result is then the result of evaluating <var>FC</var>.
                                    </p><p>
                                      As with argument values,
                                      the value returned by a function
                                      retains its most specific type,
                                      which may be derived from the declared return type of <var>F</var>.
                                      For example, a function that has
                                      a declared return type of <code>xs:decimal</code>
                                      may in fact return a value of dynamic type <code>xs:integer</code>.
                                    </p></item></olist><example><head>Derived Types and Nonlocal Variable Bindings</head><p>
                                          <code>$incr</code> is a nonlocal variable that is available within the function because its variable binding has been added to the variable values of the function..  Even though the parameter and return type of this function are both <code>xs:decimal</code>,
                                  the more specific type <code>xs:integer</code> is preserved in both cases.</p><eg role="parse-test" xml:space="preserve">
let $incr := 1,
    $f := function ($i as xs:decimal) as xs:decimal { $i + $incr }
return $f(5)                      </eg></example><example diff="add" at="bug29701"><head>Using the Context Item in an Anonymous Function</head><p>The following example will raise a dynamic error <errorref class="DY" code="0002"/>:</p><eg role="parse-test" xml:space="preserve">
let $vat := function() { @vat + @price }
return shop/article/$vat()</eg><p>Instead, the context item can be used as an argument to the anonymous function:</p><eg role="parse-test" xml:space="preserve">
let $vat := function($art) { $art/@vat + $art/@price }
return shop/article/$vat(.)</eg><p>Or, the value can be referenced as a nonlocal variable binding:</p><eg role="parse-test" xml:space="preserve">
let $ctx := shop/article,
$vat := function() { for $a in $ctx return $a/@vat + $a/@price }
return $vat()
</eg></example></item><item><p>                                  
                                  If <var>F</var>'s implementation is
                                  <phrase diff="del" at="bug29277">
                                          <termref def="dt-implementation-dependent">implementation-dependent</termref>
                                       </phrase>
                                       <phrase diff="add" at="bug29277">not an XPath 3.1 expression</phrase>
                                  (e.g., <phrase diff="add" at="bug29277">
                                          <var>F</var> is</phrase>
                                  a <termref def="dt-built-in-function">built-in function</termref>
                                  
                                       <phrase role="xpath">or a <termref def="dt-host-language-function">host language function</termref>
                                       </phrase>
                                  or a
                                  <termref def="dt-partially-applied-function">partial application</termref>
                                  of such a function):
                                </p><ulist><item><p>
                                             <var>F</var>'s implementation is invoked
                                      <phrase diff="del" at="bug29277">
                                      with the converted argument values
                                      using the contexts it is
                                      associated with in <var>F</var>. If these contexts
                                      are absent in <var>F</var>, it is associated with
                                      <var>SC</var> and <var>DC</var>.
                                      </phrase>
                                             <phrase diff="add" at="bug29277">
                                      in an implementation-dependent way.
                                      The processor makes the following information
                                      available to that invocation:
                                      </phrase>
                                          </p><ulist diff="add" at="bug29277"><item><p>the converted argument values;</p></item><item><p>
                                                   <var>F</var>'s nonlocal variable bindings; and</p></item><item><p>
                                          a static context and dynamic context.
                                          If <var>F</var>'s implementation is associated with a static and a dynamic context,
                                          then these are supplied,
                                          otherwise <var>SC</var> and <var>DC</var> are supplied.
                                        </p></item></ulist><p diff="add" at="bug29277">
                                      How this information is used is <termref def="dt-implementation-defined">implementation-defined</termref>.
                                      An API used to invoke external functions must state
                                      how the static and dynamic contexts are provided
                                      to a function that is invoked.
                                      The F&amp;O specification states how the static and dynamic contexts
                                      are used in each function that it defines. 
                                      <phrase role="xpath">
                                      A host language must state how the static and dynamic contexts
                                      are used in functions that it provides.
                                      </phrase>
                                          </p></item><item><p>
                                      The result is either an instance of <var>F</var>'s return type
                                      or a dynamic error.
                                      This result is then the result of evaluating <var>FC</var>.
                                    </p></item><item><p>
                                      Errors raised by built-in functions are defined in
                                      <bibref ref="xpath-functions-31"/>.
                                    </p></item><item role="xpath"><p>
                                      Errors raised by host-language-dependent functions are
                                      <termref def="dt-implementation-defined">implementation-defined</termref>.
                                    </p></item></ulist><example diff="add" at="bug29277"><head>A Built-in Function</head><p>The following function call uses the function 
                                  <xspecref spec="FO31" ref="func-base-uri"/>.  Use of <code>SC</code> and <code>DC</code> and errors raised by this function are all defined in 
                                  <bibref ref="xpath-functions-31"/>.</p><eg role="parse-test" xml:space="preserve">fn:base-uri()</eg></example></item></olist><!-- ######### Check Hierarchy for following end tags --></item></olist></item></olist><!-- end of suspicious region ############## --></div4><div4 id="id-function-conversion-rules"><head>Function Conversion Rules</head><p>
                     <termdef term="function conversion rules" id="dt-function-conversion">The <term>function conversion rules</term> are used to convert an
		argument value  to its expected type; that is, to
		the declared type of the function <phrase role="xpath">parameter.</phrase>
                     </termdef> The expected type is expressed as a <termref def="dt-sequence-type">sequence type</termref>. The function conversion rules are applied to a given value
		as follows:</p><ulist><item role="xpath"><p>In a static function call, if  <termref def="dt-xpath-compat-mode">XPath
  1.0 compatibility mode</termref> is <code>true</code> and an
  argument of a static function is not of
  the expected type, then the following conversions are applied
  sequentially to the argument value V:</p><olist><item><p>If the expected type calls for a single item or optional single item (examples: <code>xs:string</code>, <code>xs:string?</code>, <code>xs:untypedAtomic</code>, <code>xs:untypedAtomic?</code>, <code>node()</code>, <code>node()?</code>, <code>item()</code>, <code>item()?</code>), then the value V is effectively replaced by V[1].</p></item><item><p>If the expected type is
		<code>xs:string</code> or <code>xs:string?</code>,
		then the  value <code>V</code> is effectively
		replaced by
		<code>fn:string(V)</code>.</p></item><item><p>If
		the expected type is <code>xs:double</code> or <code>xs:double?</code>, then the value <code>V</code> is effectively replaced by
		<code>fn:number(V)</code>.</p></item></olist><note><p>
                              <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility
    mode</termref> has no effect on dynamic function calls,
    converting the result of an inline function to its required type,
    partial function application, or implicit function calls that
    occur when evaluating functions such as fn:for-each and fn:filter.</p></note></item><item><p>If the expected type is a sequence of a <termref def="dt-generalized-atomic-type">generalized atomic type</termref> (possibly with an occurrence indicator <code>*</code>, <code>+</code>, or <code>?</code>), the following conversions are applied:</p><olist><item><p>
                                 <termref def="dt-atomization">Atomization</termref> is applied
		to the given value, resulting in a sequence of atomic
		values.</p><note diff="del" at="2014-08-25"><p diff="add" at="2014-04-01">Atomization converts arrays to sequences (see <termref def="dt-atomization">Atomization</termref>).</p></note></item><item><p>Each item in the atomic
		sequence that is of type
		<code>xs:untypedAtomic</code> is cast to the expected generalized
		atomic type. <phrase diff="del" at="bug28959">For <termref def="dt-built-in-function">built-in functions</termref> where the expected type is specified as <termref def="dt-numeric">numeric</termref>, arguments of type <code>xs:untypedAtomic</code> are cast to <code>xs:double</code>.</phrase> If the item is of type <code>xs:untypedAtomic</code> and the expected type is <termref def="dt-namespace-sensitive">namespace-sensitive</termref>, a <termref def="dt-type-error">type error</termref> 
                                 <errorref class="TY" code="0117"/> is raised.</p></item><item><p>For each <termref def="dt-numeric">numeric</termref> item
		in the atomic sequence that can be
		<termref def="dt-type-promotion">promoted</termref> to the expected atomic type
		using numeric promotion as described in <specref ref="promotion"/>, the promotion is
		done.</p></item><item><p>For each item of type <code>xs:anyURI</code>
		in the atomic sequence that can be
		<termref def="dt-type-promotion">promoted</termref> to the expected atomic type
		using URI promotion as described in <specref ref="promotion"/>, the promotion is
		done.</p></item></olist></item><item><p>If the
		expected type is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypedFunctionTest" xlink:type="simple">TypedFunctionTest</nt> (possibly with an occurrence indicator <code>*</code>,
		<code>+</code>, or <code>?</code>), <termref def="dt-function-item-coercion">function coercion</termref> is applied to each function in the given value.</p><note diff="add" at="bug27059"><p>In XPath 3.1, maps and arrays are functions, so function coercion applies to them as well.</p></note></item><item><p> If, after the
		above conversions, the resulting value does not match
		the expected type according to the rules for <termref def="dt-sequencetype-matching">SequenceType
		Matching</termref>, a <termref def="dt-type-error">type error</termref> is
		raised <errorref class="TY" code="0004"/>.
		
		Note that the rules for <termref def="dt-sequencetype-matching">SequenceType
		Matching</termref> permit a value of a derived type to
		be substituted for a value of its base
		type. </p></item></ulist></div4><div4 id="id-function-coercion"><head>Function Coercion</head><p>
        Function coercion is a transformation applied to <xtermref diff="chg" at="2013-12-06" spec="DM31" ref="dt-function-item">functions</xtermref> during application of the
        <termref def="dt-function-conversion">function conversion rules</termref>.
        <termdef term="function coercion" id="dt-function-item-coercion">
                        <term>Function coercion</term> wraps a <xtermref diff="chg" at="2013-12-06" spec="DM31" ref="dt-function-item">function</xtermref>
        in a new function
        with signature the same as the expected type.
        This effectively delays the checking
        of the argument and return types
        until the function is invoked.</termdef>
                  </p><p>
        Function coercion
        is only defined to operate on
        <xtermref diff="chg" at="2013-12-06" spec="DM31" ref="dt-function-item">functions</xtermref>.
        Given a function
        <var>F</var>,
	and an expected function type,
        function coercion
	proceeds as follows:
	If <var>F</var> and the expected type have different arity,
	a type error is raised
        <errorref class="TY" code="0004"/>.
	Otherwise, coercion
        returns a new function
        with the following properties
        (as defined in <xspecref diff="chg" at="2013-12-06" spec="DM31" ref="function-items"/>):

        <ulist><item><p>
                              <term>name</term>:
            The name of 
            <var>F</var>.
          </p></item><item><p>
                              <term>parameter names</term>:
	      The parameter names of <var>F</var>.
            </p></item><item><p>
                              <term>signature</term>:
            <code>Annotations</code> is set to the annotations of <var>F</var>. <code>TypedFunctionTest</code> is set to the expected type.
          </p></item><item><p>
                              <term>implementation</term>:
            In effect,
            a <code>FunctionBody</code> that calls <var>F</var>,
            passing it the parameters of this new function,
            in order.
          </p></item><item><p>
                              <term>nonlocal variable bindings</term>:
            An empty mapping.
          </p></item></ulist>
                  </p><p>
        If the result of invoking the new function would
        necessarily result in a type error, that
        error may be raised during
        function coercion. It is implementation dependent whether this
        happens or not.
      </p><p>
        These rules have the following consequences:

        <ulist><item><p>
            SequenceType matching of the function's arguments and result are delayed until that function is invoked.
          </p></item><item><p>
            The function conversion rules applied to the function's arguments and result are defined by the SequenceType
            it has most recently been coerced to. Additional function conversion rules could apply when the wrapped function
            is invoked.
          </p></item><item><p>
            If an implementation has static type information about a function, that can be used to type check the
            function's argument and return types during static analysis.
          </p></item></ulist>

                  </p><note><p>
        Although the semantics of function coercion are specified in terms of wrapping the functions,
        static typing will often be able to reduce the number of places where this is actually necessary.
      </p></note><p diff="add" at="bug27059">Since maps and arrays are also functions in XPath 3.1, function coercion applies to them as well.

        For instance, consider the following expression:
      </p><eg role="parse-test" diff="add" at="bug27059" xml:space="preserve">
let $m := map {
  "Monday" : true(),
  "Wednesday" : true(),
  "Friday" : true(),
  "Saturday" : false(),
  "Sunday" : false()
},
$days := ("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")
return fn:filter($days,$m)
      </eg><p diff="add" at="bug27059">
        The map <code>$m</code> has a function signature of <code>function(xs:anyAtomicType) as item()*</code>. When the <code>fn:filter()</code> function is called, the following occurs to the map:

<olist><item><p>The map <code>$m</code> is treated as <code>function ($f)</code>,  equivalent to <code>map:get($m,?)</code>.</p></item><item><p>The function conversion rules result in applying function coercion to <code>$f</code>, wrapping <code>$f</code> in a new function (<code>$p</code>) with the signature <code>function(item()) as xs:boolean</code>.</p></item><item><p>
                              <code>$p</code> is matched against the SequenceType <code>function(item()) as xs:boolean</code>, and succeeds.</p></item><item><p>When <code>$p</code> is invoked by <code>fn:filter()</code>, function conversion and SequenceType matching rules are applied to the argument, resulting in an <code>item()</code> value (<code>$a</code>) or a type error.</p></item><item><p>
                              <code>$f</code> is invoked with <code>$a</code>, which returns an <code>xs:boolean</code> or the empty sequence.</p></item><item><p>
                              <code>$p</code> applies function conversion rules and SequenceType matching to the result sequence from <code>$f</code>. When the result is an <code>xs:boolean</code> the SequenceType matching succeeds. When it is an empty sequence (such as when <code>$m</code> does not contain a key for <code>"Tuesday"</code>), SequenceType matching results in a type error  <errorref class="TY" code="0004"/>, since the expected type is <code>xs:boolean</code> and the actual type is an empty sequence.</p></item></olist>
                  </p><p diff="add" at="bug27059">Consider the following expression:
      </p><eg role="parse-test" diff="add" at="bug27059" xml:space="preserve">
let $m := map {
"Monday" : true(),
"Tuesday" : false(),
"Wednesday" : true(),
"Thursday" : false(),
"Friday" : true(),
"Saturday" : false(),
"Sunday" : false()
}
let $days := ("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")
return fn:filter($days,$m)
      </eg><p diff="add" at="bug27059">The result of the expression is the sequence <code>("Monday", "Wednesday", "Friday")</code>
                  </p></div4></div3><!-- ******************************************************************** --><div3 id="id-named-function-ref"><head>Named Function References</head><scrap headstyle="show"><head/><prod num="67" id="doc-xpath31-NamedFunctionRef"><lhs>NamedFunctionRef</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-EQName" xlink:type="simple">EQName</nt>  "#"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-IntegerLiteral" xlink:type="simple">IntegerLiteral</nt>
                     </rhs><com>
                        <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-reserved-function-names" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgc: reserved-function-names</loc>
                     </com></prod><prod num="112" id="noid_d3e9847.doc-xpath31-EQName"><lhs>EQName</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-QName" xlink:type="simple">QName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-URIQualifiedName" xlink:type="simple">URIQualifiedName</nt>
                     </rhs></prod></scrap><p>
                  <termdef term="named function reference" id="dt-named-function-ref" diff="chg" at="bug29858">
          A <term>named function reference</term> is an expression
          which evaluates to a <termref def="dt-named-func">named
          function</termref>.  The name and arity of the returned
          function are known statically, and correspond to a function
          signature present in the static context; if the function is
          context dependent, then the returned function is associated
          with the static context of the named function reference and
          the dynamic context in which it is evaluated.
          </termdef>
                  <termdef term="named function" id="dt-named-func">A <term>named function</term> is a function defined in the
          static context for the <phrase role="xpath">expression</phrase>. 
          To uniquely identify a particular named function, both its name as an expanded QName
          and its arity are required.</termdef>
               </p><p>If the EQName is a <termref def="dt-qname">lexical QName</termref> that has no namespace prefix, it is considered to be in the default function namespace.</p><p>If the <termref def="dt-expanded-qname">expanded QName</termref> and arity in a named function reference do not match the name and arity of a function signature in the
          static context, a static error is raised <errorref class="ST" code="0017"/>.</p><p>
            The value of a <code>NamedFunctionRef</code>
            is the function obtained by looking up
            the expanded QName and arity
            in the <termref def="dt-named-functions">named functions</termref> component
            of the dynamic context.
            <!-- We're guaranteed that such a function exists,
            because if it didn't,
            a static error would already have been raised. -->
          </p><p diff="chg" at="bug29858">
            Furthermore, if the function returned by the evaluation of
            a <code>NamedFunctionRef</code> has an
            implementation-dependent implementation, then the
            implementation of this function is associated with the
            static context of this <code>NamedFunctionRef</code>
            expression and with the dynamic context in which
            the <code>NamedFunctionRef</code> is evaluated.
          </p><p diff="del" at="2015-07-04">
            Certain functions in the <bibref ref="xpath-functions-31"/> specification are defined to be polymorphic.
            These are denoted as accepting parameters of "numeric" type, or returning "numeric" type. Here "numeric" is a pseudonym
            for the four primitive numeric types xs:decimal, xs:integer, xs:float, and xs:double. 
            For the purposes of named function references, these functions are regarded as taking arguments and producing results
            of type xs:anyAtomicType, with a type error raised at runtime if the argument value provided is not of the correct
            numeric type.
          </p><note diff="del" at="2015-07-04"><p>
            The above way of modeling polymorphic functions is semantically backwards compatible with <phrase role="xpath">XPath 2.0</phrase>.
            An implementation that supports static typing can choose to model the types of these functions more accurately if
            desired.
          </p></note><p>The following are examples of named function references:
          </p><ulist><item><p>
                        <code role="parse-test">fn:abs#1</code> references the fn:abs function which takes a single argument.</p></item><item><p>
                        <code role="parse-test">fn:concat#5</code> references the fn:concat function which takes 5 arguments.</p></item><item><p>
                        <code role="parse-test">local:myfunc#2</code> references a function named local:myfunc which takes 2 arguments.</p></item></ulist></div3><div3 id="id-inline-func"><head>Inline Function Expressions</head><scrap headstyle="show"><head/><prod num="68" id="doc-xpath31-InlineFunctionExpr"><lhs>InlineFunctionExpr</lhs><rhs>"function"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ParamList" xlink:type="simple">ParamList</nt>?  ")"  ("as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SequenceType" xlink:type="simple">SequenceType</nt>)?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-FunctionBody" xlink:type="simple">FunctionBody</nt>
                     </rhs></prod><prod num="2" id="noid_d3e9938.doc-xpath31-ParamList"><lhs>ParamList</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-Param" xlink:type="simple">Param</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-Param" xlink:type="simple">Param</nt>)*</rhs></prod><prod num="3" id="noid_d3e9939.doc-xpath31-Param"><lhs>Param</lhs><rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-EQName" xlink:type="simple">EQName</nt>  
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?</rhs></prod><prod num="78" id="noid_d3e9940.doc-xpath31-TypeDeclaration"><lhs>TypeDeclaration</lhs><rhs>"as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SequenceType" xlink:type="simple">SequenceType</nt>
                     </rhs></prod><prod num="4" id="noid_d3e9941.doc-xpath31-FunctionBody"><lhs>FunctionBody</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-EnclosedExpr" xlink:type="simple">EnclosedExpr</nt>
                     </rhs></prod></scrap><p>
                  <termdef term="inline function expression" id="dt-inline-func">An <term>inline function expression</term> creates
          an <termref def="dt-anonymous-function">anonymous
          function</termref>
          defined directly in the
          inline function expression.</termdef> An inline function expression specifies the names and SequenceTypes of the parameters to the function,
          the SequenceType of the result, and the body of the function. <termdef id="dt-anonymous-function" term="anonymous function" diff="chg" at="bug29903">An <term>anonymous function</term> is a function with no name.  Anonymous functions may be created, for example, by evaluating an inline function expression or by partial function application.</termdef>
               </p><p>
          If a function parameter is declared using a name but no type, its default type is item()*. If the result type is omitted from an inline function expression, its default result type is item()*.
          </p><p>
          The parameters of an inline function expression are considered to be variables whose scope is the function body. It is a static error
          <errorref class="ST" code="0039"/> for an inline function expression to have more than one parameter with the same name.
          </p><p>
          The static context for the function body is inherited from the location of the inline function expression, with the exception of the
          static type of the context item which is initially <xtermref spec="DM31" ref="dt-absent"/>.
          </p><p>
          The variables in scope for the function body include all variables representing the function parameters, as well as all variables that
          are in scope for the inline function expression.

          <note><p>
            Function parameter names can mask variables that would otherwise be in scope for the function body.
          </p></note>
               </p><p>The result of an inline function expression is a single function with the following properties (as defined in <xspecref spec="DM31" ref="function-items"/>):

          <ulist><item><p>
                           <term>name</term>:
              An absent name.
              Absent.
            </p></item><item><p>
                           <term>parameter names</term>:
              The parameter names in
              the <code>InlineFunctionExpr</code>'s
              <code>ParamList</code>.
            </p></item><item><p>
                           <term>signature</term>:
              A <code>FunctionTest</code>
              constructed from the
               
	      <code>SequenceType</code>s in the <code>InlineFunctionExpr</code>.
	      <phrase diff="add" at="bug29586">An implementation which can determine a more specific signature (for example, through use of type analysis of the function's body) is permitted to do so.</phrase>
                        </p></item><item><p>
                           <term>implementation</term>:
              The <code>InlineFunctionExpr</code>'s <code>FunctionBody</code>.
            </p></item><item><p>
                           <term>nonlocal variable bindings</term>:
              For each nonlocal variable,
              a binding of it to its value in the
              <termref def="dt-variable-values">variable values</termref> component
              of the dynamic context of the <code>InlineFunctionExpr</code>.
            </p></item></ulist>

               </p><p>The following are examples of some inline function expressions:</p><ulist><item><p>This example creates a function that takes no arguments and returns a sequence of the first 6 primes:
                <eg role="parse-test" xml:space="preserve">function() as xs:integer+ { 2, 3, 5, 7, 11, 13 }</eg>
                     </p></item><item><p>This example creates a function that takes two xs:double arguments and returns their product:
                <eg role="parse-test" xml:space="preserve">function($a as xs:double, $b as xs:double) as xs:double { $a * $b }</eg>
                     </p></item><item><p>This example creates a function that returns its item()* argument:
                <eg role="parse-test" xml:space="preserve">function($a) { $a }</eg>
                     </p></item><item><p>This example creates a sequence of functions each of which returns a
different <phrase diff="del" at="2015-07-07">node</phrase>
                        <phrase diff="add" at="2015-07-07">item</phrase>
 from the default  collection.

                <eg role="parse-test" xml:space="preserve">collection()/(let $a := . return function() { $a })</eg>
                     </p></item></ulist></div3><div3 id="id-enclosed-expr" diff="add" at="bug29903"><head>Enclosed Expressions</head><p diff="chg" at="bug29382">
                  <phrase diff="del" at="2016-11-30">Some primary expressions contain  <termref def="dt-enclosed-expression">enclosed expressions</termref>.</phrase>

                  <scrap headstyle="show"><head/><prod num="5" id="doc-xpath31-EnclosedExpr"><lhs>EnclosedExpr</lhs><rhs>"{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Expr" xlink:type="simple">Expr</nt>?  "}"</rhs></prod></scrap>

                  <termdef term="enclosed expression" id="dt-enclosed-expression" diff="add" at="a-621-03">An <term>enclosed expression</term> is an instance of the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-EnclosedExpr" xlink:type="simple">EnclosedExpr</nt> production, which allows an optional expression within curly braces.</termdef>  
                  <termdef id="dt-content-expression" term="content expression">In an  <termref def="dt-enclosed-expression">enclosed expression</termref>, the optional expression enclosed in curly braces is called the <term>content expression</term>.</termdef> If the <termref def="dt-content-expression">content expression</termref> is <phrase diff="del" at="###">omitted</phrase>
                  <phrase diff="add" at="###">not provided explicitly</phrase>, <phrase diff="del" at="###">the value of</phrase> the content expression is <code>()</code>.</p></div3></div2><div2 id="id-postfix-expression"><head>Postfix Expressions</head><scrap headstyle="show"><head/><prod num="49" id="doc-xpath31-PostfixExpr"><lhs>PostfixExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-PrimaryExpr" xlink:type="simple">PrimaryExpr</nt>  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Predicate" xlink:type="simple">Predicate</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ArgumentList" xlink:type="simple">ArgumentList</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Lookup" xlink:type="simple">Lookup</nt>)*</rhs></prod><prod num="52" id="noid_d3e10130.doc-xpath31-Predicate"><lhs>Predicate</lhs><rhs>"["  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Expr" xlink:type="simple">Expr</nt>  "]"</rhs></prod><prod num="50" id="noid_d3e10131.doc-xpath31-ArgumentList"><lhs>ArgumentList</lhs><rhs>"("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Argument" xlink:type="simple">Argument</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Argument" xlink:type="simple">Argument</nt>)*)?  ")"</rhs></prod></scrap><p>
               <termdef term="filter expression" id="dt-filter-expression">An
    expression followed by a predicate (that is, <code>E1[E2]</code>)
    is referred to as a <term>filter expression</term>: its effect is
    to return those items from the value of <code>E1</code> that
    satisfy the predicate in E2.</termdef> Filter expressions are
    described in <specref ref="id-filter-expression"/>
            </p><p>An expression (other than a raw EQName) followed by an argument
    list in parentheses (that is, <code>E1(E2, E3, ...)</code>) is
    referred to as a <termref def="dt-dynamic-function-invocation">dynamic function call</termref>. Its
    effect is to evaluate <code>E1</code> to obtain a function,
    and then call that function, with
    <code>E2</code>, <code>E3</code>, <code>...</code> as
    arguments. Dynamic function calls are described in <specref ref="id-dynamic-function-invocation"/>.</p><div3 id="id-filter-expression"><head>Filter Expressions</head><scrap headstyle="show"><head/><prod num="49" id="noid_d3e10176.doc-xpath31-PostfixExpr"><lhs>PostfixExpr</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-PrimaryExpr" xlink:type="simple">PrimaryExpr</nt>  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Predicate" xlink:type="simple">Predicate</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ArgumentList" xlink:type="simple">ArgumentList</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Lookup" xlink:type="simple">Lookup</nt>)*</rhs></prod><prod num="52" id="doc-xpath31-Predicate"><lhs>Predicate</lhs><rhs>"["  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Expr" xlink:type="simple">Expr</nt>  "]"</rhs></prod></scrap><p>A filter expression consists of a base expression followed by
      a predicate, which is an expression written in square
      brackets. The result of the filter expression consists of the
      items returned by the base expression, filtered by applying the
      predicate to each item in turn. The ordering of the items
      returned by a filter expression is the same as their order in
      the result of the primary expression.</p><note><p>Where the expression before the square brackets is a
      <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ReverseStep" xlink:type="simple">ReverseStep</nt> or <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ForwardStep" xlink:type="simple">ForwardStep</nt>, the expression is technically not a
      filter expression but an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AxisStep" xlink:type="simple">AxisStep</nt>. There are minor differences
      in the semantics: see <specref ref="id-predicate"/>
                  </p></note><p>Here are some examples of filter expressions:</p><ulist><item><p>Given a sequence of products in a variable, return only those products whose price is greater than 100.</p><eg role="parse-test" xml:space="preserve">$products[price gt 100]</eg></item><item><p>List all the integers from 1 to 100 that are divisible by 5. (See <specref ref="construct_seq"/> for an explanation of the <code>to</code> operator.)</p><eg role="parse-test" xml:space="preserve">(1 to 100)[. mod 5 eq 0]</eg></item><item><p>The result of the following expression is the integer 25:</p><eg role="parse-test" xml:space="preserve">(21 to 29)[5]</eg></item><item><p>The following example returns the fifth through ninth items in the sequence bound to variable <code>$orders</code>.</p><eg role="parse-test" xml:space="preserve">$orders[fn:position() = (5 to 9)]</eg></item><item><p>The following example illustrates the use of a filter expression as a <termref def="dt-step">step</termref> in a <termref def="dt-path-expression">path expression</termref>. It returns the last chapter or appendix within the book bound to variable <code>$book</code>:</p><eg role="parse-test" xml:space="preserve">$book/(chapter | appendix)[fn:last()]</eg></item></ulist><p>For each item in the input sequence, the predicate expression
      is evaluated using an <term>inner focus</term>, defined as
      follows: The context item is the item currently being tested
      against the predicate. The context size is the number of items
      in the input sequence. The context position is the position of
      the context item within the input sequence. </p><p>For each item in the input sequence, the result of the
      predicate expression is coerced to an <code>xs:boolean</code>
      value, called the <term>predicate truth value</term>, as
      described below. Those items for which the predicate truth value
      is <code>true</code> are retained, and those for which the
      predicate truth value is <code>false</code> are discarded.</p><p>The predicate truth value is derived by applying the following rules,
       in order:</p><olist><item><p>If the value of the predicate expression is a <termref def="dt-singleton">singleton</termref> atomic value of a
	   <termref def="dt-numeric">numeric</termref> type or derived
	   from a <termref def="dt-numeric">numeric</termref> type,
	   the predicate truth value is <code>true</code> if the value
	   of the predicate expression is equal (by the
	   <code>eq</code> operator) to the <term>context
	   position</term>, and is <code>false</code>
	   otherwise. </p></item><item><p>Otherwise, the predicate truth value is the <termref def="dt-ebv">effective boolean value</termref> of the
	   predicate expression.</p></item></olist></div3><div3 id="id-dynamic-function-invocation"><head>Dynamic Function Calls</head><scrap headstyle="show"><head/><prod num="49" id="noid_d3e10297.doc-xpath31-PostfixExpr"><lhs>PostfixExpr</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-PrimaryExpr" xlink:type="simple">PrimaryExpr</nt>  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Predicate" xlink:type="simple">Predicate</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ArgumentList" xlink:type="simple">ArgumentList</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Lookup" xlink:type="simple">Lookup</nt>)*</rhs></prod><prod num="50" id="doc-xpath31-ArgumentList"><lhs>ArgumentList</lhs><rhs>"("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Argument" xlink:type="simple">Argument</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Argument" xlink:type="simple">Argument</nt>)*)?  ")"</rhs></prod><prod num="64" id="noid_d3e10299.doc-xpath31-Argument"><lhs>Argument</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ArgumentPlaceholder" xlink:type="simple">ArgumentPlaceholder</nt>
                     </rhs></prod><prod num="65" id="noid_d3e10300.doc-xpath31-ArgumentPlaceholder"><lhs>ArgumentPlaceholder</lhs><rhs>"?"</rhs></prod></scrap><p>
                  <termdef term="dynamic function call" id="dt-dynamic-function-invocation">A <term>dynamic function call</term>
            consists of a
            base expression
            that returns the function and a
            parenthesized list of zero or more arguments (<termref def="dt-arg-expr">argument expressions</termref> or
            ArgumentPlaceholders).</termdef>
               </p><p>
            A dynamic function call
            is evaluated as described in
            <specref ref="id-eval-function-call"/>.
          </p><p>The following are examples of some dynamic function calls:</p><ulist><item><p>This example invokes the function contained in $f, passing the arguments 2 and 3:
                <eg role="parse-test" xml:space="preserve">$f(2, 3)</eg>
                     </p></item><item><p>This example fetches the second item from sequence $f, treats it as a function and invokes it, passing an <code>xs:string</code> argument:
                <eg role="parse-test" xml:space="preserve">$f[2]("Hi there")</eg>
                     </p></item><item><p>This example invokes the function $f passing no arguments, and filters the result with a positional predicate:
                <eg role="parse-test" xml:space="preserve">$f()[2]</eg>
                     </p></item></ulist></div3></div2><div2 id="id-path-expressions"><head>Path Expressions</head><scrap headstyle="show"><head/><prod num="36" id="doc-xpath31-PathExpr"><lhs>PathExpr</lhs><rhs>("/"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>?)<br/>|  ("//"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>)<br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>
                  </rhs><com>
                     <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-leading-lone-slash" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgc: leading-lone-slash</loc>
                  </com></prod><prod num="37" id="noid_d3e10346.doc-xpath31-RelativePathExpr"><lhs>RelativePathExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-StepExpr" xlink:type="simple">StepExpr</nt>  (("/"  |  "//")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-StepExpr" xlink:type="simple">StepExpr</nt>)*</rhs></prod></scrap><p>
               <termdef id="dt-path-expression" term="path expression">A <term>path expression</term> can be used to locate nodes
	 within trees. A path expression consists of a series of one or more
	 <termref def="dt-step">steps</termref>, separated by "<code>/</code>" or
	 "<code>//</code>", and optionally beginning with
	 "<code>/</code>" or "<code>//</code>".</termdef> An initial
	 "<code>/</code>" or "<code>//</code>" is an abbreviation for
	 one or more initial steps that are implicitly added to the
	 beginning of the path expression, as described below.</p><p>A
	 path expression consisting of a single step is evaluated as
	 described in <specref ref="id-steps"/>.</p><p>A "<code>/</code>"
	 at the beginning of a path expression is an abbreviation for
	 the initial step <code>(fn:root(self::node()) treat as document-node())/</code> (however, if the
	 "<code>/</code>" is the entire path expression, the trailing "<code>/</code>" is omitted from the expansion.) The effect
	 of this initial step is to begin the path at the root node of
	 the tree that contains the context node. If the context item
	 is not a node, a <termref def="dt-type-error">type
	 error</termref> is raised <errorref class="TY" code="0020"/>. At
	 evaluation time, if the root node <phrase diff="chg" at="bug29212">of</phrase> the context node is
	 not a document node, a <termref def="dt-dynamic-error">dynamic error</termref> is
	 raised <errorref class="DY" code="0050"/>.</p><p>A "<code>//</code>" at the beginning of a path expression
	 is an abbreviation for the initial steps
	 <code>(fn:root(self::node()) treat as
	 document-node())/descendant-or-self::node()/</code> (however, "<code>//</code>" by itself is not a valid path expression <errorref class="ST" code="0003"/>.)  The
	 effect of these initial steps is to establish an initial node
	 sequence that contains the root of the tree in which the
	 context node is found, plus all nodes descended from this
	 root.
	 This node sequence is used as the input to subsequent steps
	 in the path expression. If the context item is not a node, a
	 <termref def="dt-type-error">type error</termref> is
	 raised <errorref class="TY" code="0020"/>. At evaluation time, if the
	 root node <phrase diff="chg" at="bug29212">of</phrase> the context node is not a document node, a
	 <termref def="dt-dynamic-error">dynamic error</termref> is
	 raised <errorref class="DY" code="0050"/>.</p><note><p>The descendants of a node do not include attribute
	 nodes<phrase role="xpath"> or namespace nodes</phrase>.</p></note><p diff="add" at="bug29903">
         A path expression that starts with "<code>/</code>"
         or "<code>//</code>" selects nodes starting from the root of
         the tree containing the context item; it is often referred to
         as an absolute path expression.
         </p><div3 id="id-relative-path-expressions"><head>Relative Path Expressions</head><scrap headstyle="show"><head/><prod num="37" id="doc-xpath31-RelativePathExpr"><lhs>RelativePathExpr</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-StepExpr" xlink:type="simple">StepExpr</nt>  (("/"  |  "//")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-StepExpr" xlink:type="simple">StepExpr</nt>)*</rhs></prod></scrap><p diff="chg" at="bug29903">
          A relative path expression is a path expression that selects
          nodes within a tree by following a series of steps starting
          at the context node (which, unlike an absolute path
          expression, may be any node in a tree).
          </p><p diff="chg" at="bug29903">
          Each non-initial occurrence of "<code>//</code>" in a path expression is
          expanded as described in <specref ref="abbrev"/>, leaving a
          sequence of steps separated by "<code>/</code>". This sequence of steps
          is then evaluated from left to right. So a path such as
          <code>E1/E2/E3/E4</code> is evaluated
          as <code>((E1/E2)/E3)/E4</code>. The semantics of a path
          expression are thus defined by the semantics of the
          binary "<code>/</code>" operator, which is defined in
          <specref ref="id-path-operator"/>.
          </p><note diff="add" at="bug29903"><p>
         Although the semantics describe the evaluation of a path with
         more than two steps as proceeding from left to right, the "<code>/</code>"
         operator is in most cases associative, so evaluation from
         right to left usually delivers the same result. The cases
         where "<code>/</code>" is not associative arise when the functions
         <code>fn:position()</code> and <code>fn:last()</code> are
         used: <code>A/B/position()</code> delivers a sequence of
         integers from 1 to the size of <code>(A/B)</code>, whereas
         <code>A/(B/position())</code> restarts the counting at each <code>B</code> element.
         </p></note><p>The following example illustrates the use of relative path expressions.</p><example><ulist><item><p>
                           <code role="parse-test">child::div1/child::para</code>
                        </p><p>Selects the
	     <code>para</code> element children of the <code>div1</code>
	     element children of the context node; that is, the
	     <code>para</code> element grandchildren of the context node
	     that have <code>div1</code> parents.</p></item></ulist></example><note><p>Since each step in a path provides context nodes for the following step, in effect, only the last step in a path is allowed to return a sequence of non-nodes.</p></note><note><p id="Chg-slash-note">The "<code>/</code>" character
	 can be used either as a complete path expression or as the
	 beginning of a longer path expression such as
	 "<code>/*</code>".  Also, "<code role="parse-test">*</code>"
	 is both the multiply operator and a wildcard in path
	 expressions.  This can cause parsing difficulties when
	 "<code>/</code>" appears on the left-hand side of
	 "<code>*</code>".  This is resolved using the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-leading-lone-slash" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">leading-lone-slash
	 </loc> constraint.  For example, "<code role="parse-test">/*</code>" and "<code role="parse-test">/
	 *</code>" are valid path expressions containing wildcards,
	 but "<code>/*5</code>" and "<code>/ * 5</code>" raise syntax
	 errors. Parentheses must be used when "<code>/</code>" is
	 used on the left-hand side of an operator, as in "<code role="parse-test">(/) * 5</code>". Similarly, "<code>4 + / *
	 5</code>" raises a syntax error, but "<code role="parse-test">4 + (/) * 5</code>" is a valid expression.
	 The expression "<code role="parse-test">4 + /</code>" is also
	 valid, because <code>/</code> does not occur on the left-hand
	 side of the operator.</p><p>Similarly, in the expression <code role="parse-test">/
	 union /*</code>, "union" is interpreted as an element name
	 rather than an operator. For it to be parsed as an operator,
	 the expression should be written <code role="parse-test">(/)
	 union /*</code>.</p></note><div4 id="id-path-operator"><head>Path operator (<code>/</code>)</head><p>The path operator "/" is used to build expressions for locating nodes within trees. Its left-hand side expression must return a sequence of nodes. The operator returns either a sequence of nodes, in which case it additionally performs document ordering and duplicate elimination, or a sequence of non-nodes.</p><p>Each operation <code>E1/E2</code> is evaluated as follows: Expression <code>E1</code> is evaluated, and if the result is not a (possibly empty) sequence <code>S</code> of nodes, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0019"/>. Each node in <code>S</code> then serves in turn to provide an inner focus (the node as the context item, its position in <code>S</code> as the context position, the length of <code>S</code> as the context size) for an evaluation of <code>E2</code>, as described in  <specref ref="eval_context"/>. The sequences resulting from all the evaluations of <code>E2</code> are combined as follows:</p><olist><item><p>If every evaluation of <code>E2</code> returns a (possibly empty) sequence of nodes, these sequences are combined, and duplicate nodes are eliminated based on node identity.
  <phrase role="xpath">The resulting node sequence is returned in <termref def="dt-document-order">document order</termref>.</phrase>
                        </p></item><item><p>If every evaluation of <code>E2</code> returns a (possibly empty) sequence of non-nodes, these sequences are concatenated<phrase role="xpath">, in order,</phrase> and returned.
  
  <phrase role="xpath">The</phrase> returned sequence preserves the orderings within and among the subsequences generated by the evaluations of <code>E2</code>
                           <phrase role="xpath">.</phrase>
                        </p></item><item><p>If the multiple evaluations of <code>E2</code> return at least one node and at least one non-node, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0018"/>.</p></item></olist><note><p>The semantics of the path operator can also be defined using the <phrase diff="chg" at="2015-07-08">simple map operator</phrase> as follows (forming the union with an empty sequence <code>($R | ())</code> has the effect of eliminating duplicates and sorting nodes into document order):</p><eg xml:space="preserve">E1/E2 ::= let $R := E1!E2
  return
    if (every $r in $R satisfies $r instance of node())
    then ($R|())
    else if (every $r in $R satisfies not($r instance of node()))
    then $R
    else error()</eg></note></div4></div3><div3 id="id-steps"><head>Steps</head><scrap headstyle="show"><head/><prod num="38" id="doc-xpath31-StepExpr"><lhs>StepExpr</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-PostfixExpr" xlink:type="simple">PostfixExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AxisStep" xlink:type="simple">AxisStep</nt>
                     </rhs></prod><prod num="39" id="noid_d3e10697.doc-xpath31-AxisStep"><lhs>AxisStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ReverseStep" xlink:type="simple">ReverseStep</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ForwardStep" xlink:type="simple">ForwardStep</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-PredicateList" xlink:type="simple">PredicateList</nt>
                     </rhs></prod><prod num="40" id="doc-xpath31-ForwardStep"><lhs>ForwardStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ForwardAxis" xlink:type="simple">ForwardAxis</nt>  
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-NodeTest" xlink:type="simple">NodeTest</nt>)  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AbbrevForwardStep" xlink:type="simple">AbbrevForwardStep</nt>
                     </rhs></prod><prod num="43" id="doc-xpath31-ReverseStep"><lhs>ReverseStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ReverseAxis" xlink:type="simple">ReverseAxis</nt>  
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-NodeTest" xlink:type="simple">NodeTest</nt>)  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AbbrevReverseStep" xlink:type="simple">AbbrevReverseStep</nt>
                     </rhs></prod><prod num="51" id="noid_d3e10700.doc-xpath31-PredicateList"><lhs>PredicateList</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Predicate" xlink:type="simple">Predicate</nt>*</rhs></prod></scrap><p>
                  <termdef term="step" id="dt-step">A <term>step</term> is a part of a <termref def="dt-path-expression">path expression</termref> that generates a sequence of items
		and then filters the sequence by zero or more
		<termref def="dt-predicate">predicates</termref>. The value of the step
		consists of those items that satisfy the
		predicates, working from left to right. A step may be either an <termref def="dt-axis-step">axis step</termref> or a postfix expression.</termdef> Postfix expressions are described in <specref ref="id-postfix-expression"/>.</p><p>
                  <termdef term="axis step" id="dt-axis-step">An <term>axis step</term> returns a sequence of nodes that are reachable from the context node via a specified axis. Such a step has two parts: an
		<term>axis</term>, which defines the "direction of
		movement" for the step, and a <termref def="dt-node-test">node test</termref>,
		which selects nodes based on their kind, name, and/or
		<termref def="dt-type-annotation">type annotation</termref>.</termdef> If the context item is a node, an axis
		step returns a sequence of zero or more
		nodes; otherwise, a <termref def="dt-type-error">type error</termref> is
		raised <errorref class="TY" code="0020"/>.   <phrase role="xpath">The resulting node sequence is returned in <termref def="dt-document-order">document
	 order</termref>.</phrase>  An axis step may be either a <term>forward
		step</term> or a <term>reverse step</term>, followed
		by zero or more <termref def="dt-predicate">predicates</termref>.</p><p>In the <term>abbreviated syntax</term> for a step, the axis can
		be omitted and other shorthand notations can be used as described in
		<specref ref="abbrev"/>.</p><p>The unabbreviated syntax for an axis step consists of the axis name
		and node test separated by a double colon. The result of the step consists of the nodes
		reachable from the context node via the specified axis that have the node kind, name,
		and/or <termref def="dt-type-annotation">type annotation</termref> specified by the node test. For example, the
		step <code role="parse-test">child::para</code> selects the <code>para</code> element children of the context node: <code>child</code> is the name of the axis, and <code>para</code> is the name of the element nodes to be selected on this axis. The available axes are described in <specref ref="axes"/>. The
		available node tests are described in <specref ref="node-tests"/>. Examples of
		steps are provided in <specref ref="unabbrev"/> and <specref ref="abbrev"/>.</p><div4 id="axes"><head>Axes</head><scrap headstyle="show"><head/><prod num="41" id="doc-xpath31-ForwardAxis"><lhs>ForwardAxis</lhs><rhs>("child"  "::")<br/>|  ("descendant"  "::")<br/>|  ("attribute"  "::")<br/>|  ("self"  "::")<br/>|  ("descendant-or-self"  "::")<br/>|  ("following-sibling"  "::")<br/>|  ("following"  "::")<br/>|  ("namespace"  "::")</rhs></prod><prod num="44" id="doc-xpath31-ReverseAxis"><lhs>ReverseAxis</lhs><rhs>("parent"  "::")<br/>|  ("ancestor"  "::")<br/>|  ("preceding-sibling"  "::")<br/>|  ("preceding"  "::")<br/>|  ("ancestor-or-self"  "::")</rhs></prod></scrap><p role="xpath">XPath defines a full set of <term>axes</term>
		  for traversing documents, but a <term>host language</term> may define a subset
		  of these axes. The following axes are defined:</p><ulist><item><p>The <code>child</code> axis
				contains the children of the context
				node, which are the nodes returned by the
				<xspecref diff="chg" at="bug28307" spec="DM31" ref="dm-children"/>.
                                </p><note><p>Only document
                                                  nodes and element
                                                  nodes have
                                                  children. If the
                                                  context node is any
                                                  other kind of node,
                                                  or if the context
                                                  node is an empty
                                                  document or element
                                                  node, then the child
                                                  axis is an empty
                                                  sequence.  The
                                                  children of a
                                                  document node or
                                                  element node may be
                                                  element, processing
                                                  instruction,
                                                  comment, or text
                                                  nodes.  Attribute<phrase role="xpath">,
                                                  namespace,</phrase> and
                                                  document nodes can
                                                  never appear as
                                                  children.</p></note></item><item><p>the <code>descendant</code>
			 axis is defined as the transitive closure of
			 the child axis; it contains the descendants
			 of the context node (the children, the children of the children, and so on)</p></item><item><p>the <code>parent</code>
                                          axis contains the sequence
                                          returned by the
				          <xspecref diff="chg" at="bug28307" spec="DM31" ref="dm-parent"/>, 
                                          which returns
                                          the parent of the context
                                          node, or an empty sequence
                                          if the context node has no
                                          parent</p><note><p>An attribute node may have an element node as its parent, even though the attribute node is not a child of the element node.</p></note></item><item><p>the
                                        <code>ancestor</code> axis is
                                        defined as the transitive
                                        closure of the parent axis; it
                                        contains the ancestors of the
                                        context node (the parent, the
                                        parent of the parent, and so
                                        on)</p><note><p>The ancestor axis
                                        includes the root node of the
                                        tree in which the context node
                                        is found, unless the context
                                        node is the root node.</p></note></item><item><p>the <code>following-sibling</code>
			 axis contains the context node's following
			 siblings, those children of the context
			 node's parent that occur after the context
			 node in <termref def="dt-document-order">document order</termref>; if the context node
			 is an attribute <phrase role="xpath"> or namespace </phrase> node, the
			 <code>following-sibling</code> axis is
			 empty</p></item><item><p>the <code>preceding-sibling</code>
			 axis contains the context node's preceding
			 siblings, those children of the context
			 node's parent that occur before the context
			 node in <termref def="dt-document-order">document order</termref>; if the context node
			 is an attribute <phrase role="xpath"> or namespace </phrase> node, the
			 <code>preceding-sibling</code> axis is
			 empty</p></item><item><p>the <code>following</code> axis
				contains all nodes that are
				descendants of the root of the tree in
				which the context node is found, are
				not descendants of the context node,
				and occur after the context node in
				<termref def="dt-document-order">document order</termref>
                        </p></item><item><p>the <code>preceding</code> axis
				contains all nodes that are
				descendants of the root of the tree in
				which the context node is found, are
				not ancestors of the context node, and
				occur before the context node in
				<termref def="dt-document-order">document order</termref>
                        </p></item><item><p>the <code>attribute</code> axis
			 contains the attributes of the context node,
			 which are the nodes returned by the
			 <xspecref diff="chg" at="bug28307" spec="DM31" ref="dm-parent"/>; the axis will be
			 empty unless the context node is an
			 element</p></item><item><p>the <code>self</code> axis contains just the context node itself</p></item><item><p>the <code>descendant-or-self</code> axis contains the context node and the descendants of the context
				node</p></item><item><p>the <code>ancestor-or-self</code> axis contains the context node and the ancestors of the context node;
				thus, the ancestor-or-self axis will always include the root node</p></item><item role="xpath"><p>the <code>namespace</code> axis
				contains the namespace nodes of the
				context node, which are the nodes
				returned by the
                                <xspecref diff="chg" at="bug28307" spec="DM31" ref="dm-namespace-nodes"/>; this axis
				is empty unless the context node is an
				element node. The
				<code>namespace</code> axis is
				deprecated as of XPath 2.0. If <termref def="dt-xpath-compat-mode">XPath 1.0
		compatibility mode</termref> is <code>true</code>, the <code>namespace</code> axis must be supported. If <termref def="dt-xpath-compat-mode">XPath 1.0
		compatibility mode</termref> is <code>false</code>, then support for the
				<code>namespace</code> axis is
				<termref def="dt-implementation-defined">implementation-defined</termref>. An implementation
				that does not support the
				<code>namespace</code> axis when <termref def="dt-xpath-compat-mode">XPath 1.0
		compatibility mode</termref> is <code>false</code> must raise
				a <termref def="dt-static-error">static
				error</termref> 
                           <errorref class="ST" code="0010"/> if it is
				used. Applications needing information
				about the <termref def="dt-in-scope-namespaces">in-scope namespaces</termref> of an element
				should use the functions
				<xspecref diff="chg" at="bug28307" spec="FO31" ref="func-in-scope-prefixes"/>, 
				and
				<xspecref diff="chg" at="bug28307" spec="FO31" ref="func-namespace-uri-for-prefix"/>.
                                </p></item></ulist><p>Axes can be categorized as <term>forward axes</term> and
		  <term>reverse axes</term>. An axis that only ever contains the context node or
		  nodes that are after the context node in <termref def="dt-document-order">document order</termref> is a forward axis. An
		  axis that only ever contains the context node or nodes that are before the
		  context node in <termref def="dt-document-order">document order</termref> is a reverse axis.</p><p>The <code>parent</code>, <code>ancestor</code>, <code>ancestor-or-self</code>, <code>preceding</code>, and <code>preceding-sibling</code> axes are reverse axes; all other axes are forward axes. The <code>ancestor</code>, <code>descendant</code>, <code>following</code>, <code>preceding</code> and <code>self</code> axes partition a document (ignoring attribute <phrase role="xpath">and namespace</phrase> nodes):
		  they do not overlap and together they contain all the nodes in the
		  document.</p><p>
                     <termdef id="dt-principal-node-kind" term="principal node kind">Every axis has a <term>principal node kind</term>. If an axis can
		  contain elements, then the principal node kind is element; otherwise, it is the
		  kind of nodes that the axis can contain.</termdef> Thus:</p><ulist><item><p>For the attribute axis, the principal node kind is
				attribute.</p></item><item role="xpath"><p>For the namespace axis, the principal node kind is
				namespace.</p></item><item><p>For all other axes, the principal node kind is element.</p></item></ulist></div4><div4 id="node-tests"><head>Node Tests</head><p>
                     <termdef id="dt-node-test" term="node test">A <term>node test</term> is a condition on the name, kind (element, attribute, text, document, comment,
		  or processing instruction), and/or  <termref def="dt-type-annotation">type annotation</termref> of a node. 
      A node test determines which nodes contained by an axis are selected by a <termref def="dt-step">step</termref>.</termdef> 
                  </p><scrap headstyle="show"><head/><prod num="46" id="doc-xpath31-NodeTest"><lhs>NodeTest</lhs><rhs>
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-KindTest" xlink:type="simple">KindTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-NameTest" xlink:type="simple">NameTest</nt>
                        </rhs></prod><prod num="47" id="doc-xpath31-NameTest"><lhs>NameTest</lhs><rhs>
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-EQName" xlink:type="simple">EQName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Wildcard" xlink:type="simple">Wildcard</nt>
                        </rhs></prod><prod num="48" id="doc-xpath31-Wildcard"><lhs>Wildcard</lhs><rhs>"*"<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-NCName" xlink:type="simple">NCName</nt>  ":*")<br/>|  ("*:"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-NCName" xlink:type="simple">NCName</nt>)<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-BracedURILiteral" xlink:type="simple">BracedURILiteral</nt>  "*")</rhs><com>
                           <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc>
                        </com></prod><prod num="112" id="noid_d3e11068.doc-xpath31-EQName"><lhs>EQName</lhs><rhs>
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-QName" xlink:type="simple">QName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-URIQualifiedName" xlink:type="simple">URIQualifiedName</nt>
                        </rhs></prod></scrap><p>
                     <termdef id="dt-name-test" term="name test">A node test that consists only of an EQName or a
		  Wildcard is called a <term>name test</term>.</termdef> A name
		  test <phrase diff="add" at="bug29903">that consists of an EQName</phrase> is true if and only if the <term>kind</term> of
		  the node is the <termref def="dt-principal-node-kind">principal node kind</termref> for the step axis and the
		  <termref def="dt-expanded-qname">expanded QName</termref> of the node is equal (as defined by the <code>eq</code> operator) to the
		  <termref def="dt-expanded-qname">expanded QName</termref> specified by the name test. For
		  example, <code role="parse-test">child::para</code>
		  selects the <code>para</code> element children of
		  the context node; if the context node has no
		  <code>para</code> children, it selects an empty set
		  of nodes. <code role="parse-test">attribute::abc:href</code> selects
		  the attribute of the context node with the QName
		  <code>abc:href</code>; if the context node has no
		  such attribute, it selects an empty set of
		  nodes.</p><p>If the EQName is a <termref def="dt-qname">lexical QName</termref>, it is resolved into an <termref def="dt-expanded-qname">expanded QName</termref> using the
		  <termref def="dt-static-namespaces">statically known namespaces</termref> in the expression
		  context. It is a <termref def="dt-static-error">static error</termref> 
                     <errorref class="ST" code="0081"/> if the QName has a prefix that does not
		  correspond to any statically known namespace.

          An unprefixed QName, when used as a
		  name test on an axis whose <termref def="dt-principal-node-kind">principal node kind</termref> is
		  element, has the namespace URI of the <termref def="dt-def-elemtype-ns">default element/type namespace</termref> in
		  the expression context; otherwise, it has no namespace URI. </p><p>A name test is not satisfied by an element node whose name does not match the <termref def="dt-expanded-qname">expanded QName</termref> of the name test, even if it is in a <termref def="dt-substitution-group">substitution group</termref> whose head is the named element.</p><p>A node test <code>*</code> is true for any node of the
		  <termref def="dt-principal-node-kind">principal node
		  kind</termref> of the step axis. For example, <code role="parse-test">child::*</code> will select all element
		  children of the context node, and <code role="parse-test">attribute::*</code> will select all
		  attributes of the context node.</p><p>A node test can have the form
		  <code role="parse-test">NCName:*</code>. In this case, the prefix is
		  expanded in the same way as with a <termref def="dt-qname">lexical QName</termref>, using the
		  <termref def="dt-static-namespaces">statically known
		  namespaces</termref> in the <termref def="dt-static-context">static context</termref>. If
		  the prefix is not found in the statically known namespaces,
		  a <termref def="dt-static-error">static
		  error</termref> is raised <errorref class="ST" code="0081"/>.
		  The node test is true for any node of the <termref def="dt-principal-node-kind">principal
		  node kind</termref> of the step axis whose <termref def="dt-expanded-qname">expanded QName</termref> has the namespace URI
		  to which the prefix is bound, regardless of the
		  local part of the name.</p><p>A node test can contain a BracedURILiteral, e.g.
		  <code role="parse-test">Q{http://example.com/msg}*</code> Such a node test is true for any node of the principal node kind of the step axis whose expanded QName has the namespace URI specified in the BracedURILiteral, regardless of the local part of the name.</p><p>A node test can also
		  have the form <code role="parse-test">*:NCName</code>. In this case,
		  the node test is true for any node of the <termref def="dt-principal-node-kind">principal
		  node kind</termref> of the step axis whose local name matches the given NCName,
		  regardless of its namespace or lack of a namespace.</p><p>
                     <termdef term="kind test" id="dt-kind-test">An alternative
		  form of a node test called a
		  <term>kind test</term> can select nodes based
		  on their kind, name, and <termref def="dt-type-annotation">type annotation</termref>.</termdef> The syntax
		  and semantics of a kind test are described in
		  <specref ref="id-sequencetype-syntax"/> and <specref ref="id-sequencetype-matching"/>. When a kind test is used
		  in a <termref def="dt-node-test">node test</termref>, only those nodes on the designated
		  axis that match the kind test are selected. Shown
		  below are several examples of kind tests that might
		  be used in path
		  expressions:</p><ulist><item><p>
                           <code role="parse-test">node()</code>
		  matches any
		  node.</p></item><item><p>
                           <code role="parse-test">text()</code> matches
		  any text
		  node.</p></item><item><p>
                           <code role="parse-test">comment()</code>
		  matches any comment
		  node.</p></item><item><p>
                           <code role="parse-test">namespace-node()</code> matches any
		  namespace node.</p></item><item><p>
                           <code role="parse-test">element()</code>
		  matches any element
		  node.</p></item><item><p>
                           <code role="parse-test">schema-element(person)</code>
		  matches any element node whose name is
		  <code>person</code> (or is in the <termref def="dt-substitution-group">substitution group</termref>
		  headed by <code>person</code>), and whose type
		  annotation is the same as (or is derived from) the declared type of the <code>person</code>
		  element in the <termref def="dt-is-elems">in-scope element declarations</termref>.</p></item><item><p>
                           <code role="parse-test">element(person)</code> matches any element node whose name is
		  <code>person</code>, regardless of its type annotation.</p></item><item><p>
                           <code role="parse-test">element(person, surgeon)</code> matches any non-nilled element node whose name
		  is <code>person</code>, and whose type
		  annotation is
		  <code>surgeon</code> or is derived from <code>surgeon</code>.</p></item><item><p>
                           <code role="parse-test">element(*,
		  surgeon)</code> matches any non-nilled element node whose type
		  annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>), regardless of
		  its
		  name.</p></item><item><p>
                           <code role="parse-test">attribute()</code> matches any
                  attribute node.</p></item><item><p>
                           <code role="parse-test">attribute(price)</code> matches
                  any attribute whose name is <code>price</code>,
                  regardless of its type annotation.</p></item><item><p>
                           <code role="parse-test">attribute(*,
                  xs:decimal)</code> matches any attribute whose type
                  annotation is <code>xs:decimal</code> (or is derived from <code>xs:decimal</code>), regardless of
                  its
                  name.</p></item><item><p>
                           <code role="parse-test">document-node()</code>
                  matches any document
                  node.</p></item><item><p>
                           <code role="parse-test">document-node(element(book))</code>
                  matches any document node whose content consists of
                  a single element node that satisfies the <termref def="dt-kind-test">kind test</termref>
                           <code role="parse-test">element(book)</code>, interleaved with zero or more
                  comments and processing
                  instructions.</p></item></ulist></div4></div3><div3 id="id-predicate"><head>Predicates within Steps</head><scrap headstyle="show"><head/><prod num="39" id="doc-xpath31-AxisStep"><lhs>AxisStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ReverseStep" xlink:type="simple">ReverseStep</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ForwardStep" xlink:type="simple">ForwardStep</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-PredicateList" xlink:type="simple">PredicateList</nt>
                     </rhs></prod><prod num="51" id="doc-xpath31-PredicateList"><lhs>PredicateList</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Predicate" xlink:type="simple">Predicate</nt>*</rhs></prod><prod num="52" id="noid_d3e11357.doc-xpath31-Predicate"><lhs>Predicate</lhs><rhs>"["  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Expr" xlink:type="simple">Expr</nt>  "]"</rhs></prod></scrap><p id="dt-predicate">A predicate within a Step has similar syntax and semantics
	 to a predicate within a <termref def="id-filter-expression">filter expression</termref>.  The
	 only difference is in the way the context position is set for
	 evaluation of the predicate.</p><p>For the purpose of evaluating the context position within
	 a predicate, the input sequence is considered to be sorted as
	 follows: into document order if the predicate is in a
	 forward-axis step, into reverse document order if the
	 predicate is in a reverse-axis step, or in its original order
	 if the predicate is not in a step.</p><p>Here are some examples of <termref def="dt-axis-step">axis steps</termref> that contain predicates:</p><ulist><item><p>This example selects the second <code>chapter</code> element that is a child
			 of the context node:</p><eg role="parse-test" xml:space="preserve">child::chapter[2]</eg></item><item><p>This example selects all the descendants of the
		  context node that are elements named
		  <code>"toy"</code> and whose <code>color</code>
		  attribute has the value <code>"red"</code>:</p><eg role="parse-test" xml:space="preserve">descendant::toy[attribute::color = "red"]</eg></item><item><p>This example selects all the <code>employee</code> children of the context node
		that have both a <code>secretary</code> child element and an <code>assistant</code> child element:</p><eg role="parse-test" xml:space="preserve">child::employee[secretary][assistant]</eg></item></ulist><note><p>When using <termref def="dt-predicate">predicates</termref> with a sequence of nodes selected using a
<term>reverse axis</term>, it is important to remember that the
context positions for such a sequence are assigned in <termref def="dt-reverse-document-order">reverse
document order</termref>. For example, <code role="parse-test">preceding::foo[1]</code>
returns the first qualifying <code>foo</code> element in <termref def="dt-reverse-document-order">reverse document order</termref>, because the predicate is part of an <termref def="dt-axis-step">axis step</termref> using a reverse axis. By
contrast, <code role="parse-test">(preceding::foo)[1]</code> returns the first qualifying <code>foo</code>
element in <termref def="dt-document-order">document order</termref>, because the parentheses cause  <code role="parse-test">(preceding::foo)</code> to be parsed as a <termref def="dt-primary-expression">primary expression</termref> in which context positions are assigned in document order. Similarly, <code role="parse-test">ancestor::*[1]</code>
returns the nearest ancestor element, because the <code>ancestor</code> axis is a
reverse axis, whereas <code role="parse-test">(ancestor::*)[1]</code> returns the root element (first ancestor in document order).</p><p>The fact that a reverse-axis step assigns context positions in reverse
document order for the purpose of evaluating predicates does not alter the
fact that the final result of the step  is always in document order.</p></note></div3><div3 id="unabbrev"><head>Unabbreviated Syntax</head><p>This section provides a number of examples of path expressions in which the
axis is explicitly specified in each <termref def="dt-step">step</termref>. The syntax used in these examples is
called the <term>unabbreviated syntax</term>. In many common cases, it is
possible to write path expressions more concisely using an <term>abbreviated
syntax</term>, as explained in <specref ref="abbrev"/>.</p><ulist><item><p> 
                        <code role="parse-test">child::para</code> selects
the <code>para</code> element children of the context node</p></item><item><p> 
                        <code role="parse-test">child::*</code> selects all element children of the context node</p></item><item><p> 
                        <code role="parse-test">child::text()</code> selects all text node children of the context node</p></item><item><p> 
                        <code role="parse-test">child::node()</code> selects all the children of the context node. Note that no attribute nodes are returned, because attributes are not children.</p></item><item><p> 
                        <code role="parse-test">attribute::name</code> selects the <code>name</code> attribute of the context node</p></item><item><p> 
                        <code role="parse-test">attribute::*</code> selects all the attributes of the context node</p></item><item><p>
                        <code role="parse-test">parent::node()</code> selects the parent of the context node. If the context node is an attribute node, this expression returns the element node (if any) to which the attribute node is attached.</p></item><item><p> 
                        <code role="parse-test">descendant::para</code> selects the <code>para</code> element descendants of the context node</p></item><item><p> 
                        <code role="parse-test">ancestor::div</code> selects all <code>div</code> ancestors of the context node</p></item><item><p> 
                        <code role="parse-test">ancestor-or-self::div</code> selects the <code>div</code> ancestors of the context node and, if the context node is a <code>div</code> element, the context node as well</p></item><item><p> 
                        <code role="parse-test">descendant-or-self::para</code> selects the <code>para</code> element descendants of the context node and, if the context node is a <code>para</code> element, the context node as well</p></item><item><p> 
                        <code role="parse-test">self::para</code> selects the context node if it is a <code>para</code> element, and otherwise returns an empty sequence</p></item><item><p> 
                        <code role="parse-test">child::chapter/descendant::para</code> selects the <code>para</code> element
descendants of the <code>chapter</code> element children of the context node</p></item><item><p> 
                        <code role="parse-test">child::*/child::para</code> selects all <code>para</code> grandchildren of the context node</p></item><item><p> 
                        <code role="parse-test">/</code> selects the root of the tree that contains the context node, but raises a dynamic error if this root is not a document node</p></item><item><p> 
                        <code role="parse-test">/descendant::para</code> selects all the <code>para</code> elements in the same document as the context node</p></item><item><p> 
                        <code role="parse-test">/descendant::list/child::member</code> selects all
the <code>member</code> elements that have a <code>list</code> parent and that are in the same document as the context node</p></item><item><p> 
                        <code role="parse-test">child::para[fn:position() = 1]</code> selects the first <code>para</code> child of the context node</p></item><item><p> 
                        <code role="parse-test">child::para[fn:position() = fn:last()]</code> selects the last <code>para</code> child of the context node</p></item><item><p> 
                        <code role="parse-test">child::para[fn:position() = fn:last()-1]</code> selects the last but one <code>para</code> child of the context node</p></item><item><p> 
                        <code role="parse-test">child::para[fn:position() &gt; 1]</code> selects all the <code>para</code> children of the context node other than the first <code>para</code> child of the context node</p></item><item><p> 
                        <code role="parse-test">following-sibling::chapter[fn:position() = 1]</code> selects the next <code>chapter</code> sibling of the context node</p></item><item><p> 
                        <code role="parse-test">preceding-sibling::chapter[fn:position() = 1]</code> selects the previous <code>chapter</code> sibling of the context node</p></item><item><p> 
                        <code role="parse-test">/descendant::figure[fn:position() = 42]</code> selects the forty-second <code>figure</code> element in the document containing the context node</p></item><item><p> 
                        <code role="parse-test">/child::book/child::chapter[fn:position() = 5]/child::section[fn:position() = 2]</code> selects the
second <code>section</code> of the fifth <code>chapter</code> of the <code>book</code> whose parent is the document node that contains the context node</p></item><item><p> 
                        <code role="parse-test">child::para[attribute::type eq "warning"]</code> selects
all <code>para</code> children of the context node that have a <code>type</code> attribute with value <code>warning</code> 
                     </p></item><item><p> 
                        <code role="parse-test">child::para[attribute::type eq 'warning'][fn:position() = 5]</code> selects the fifth <code>para</code> child of the context node that has a <code>type</code> attribute with value <code>warning</code> 
                     </p></item><item><p> 
                        <code role="parse-test">child::para[fn:position() = 5][attribute::type eq "warning"]</code> selects the fifth <code>para</code> child of the context node if that child has a <code>type</code> attribute with value <code>warning</code> 
                     </p></item><item><p> 
                        <code role="parse-test">child::chapter[child::title = 'Introduction']</code> selects
the <code>chapter</code> children of the context node that have one or
more <code>title</code> children whose <termref def="dt-typed-value">typed value</termref> is equal to the
string <code>Introduction</code> 
                     </p></item><item><p> 
                        <code role="parse-test">child::chapter[child::title]</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children</p></item><item><p> 
                        <code role="parse-test">child::*[self::chapter or self::appendix]</code>
selects the <code>chapter</code> and <code>appendix</code> children of the context node</p></item><item><p> 
                        <code role="parse-test">child::*[self::chapter or
self::appendix][fn:position() = fn:last()]</code> selects the
last <code>chapter</code> or <code>appendix</code> child of the context node</p></item></ulist></div3><div3 id="abbrev"><head>Abbreviated Syntax</head><scrap headstyle="show"><head/><prod num="42" id="doc-xpath31-AbbrevForwardStep"><lhs>AbbrevForwardStep</lhs><rhs>"@"?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-NodeTest" xlink:type="simple">NodeTest</nt>
                     </rhs></prod><prod num="45" id="doc-xpath31-AbbrevReverseStep"><lhs>AbbrevReverseStep</lhs><rhs>".."</rhs></prod></scrap><p>The abbreviated syntax permits the following abbreviations:</p><olist><item><p>The attribute axis <code>attribute::</code> can be
    abbreviated by <code>@</code>. For example, a path expression <code role="parse-test">para[@type="warning"]</code> is short
    for <code role="parse-test">child::para[attribute::type="warning"]</code> and
    so selects <code>para</code> children with a <code>type</code> attribute with value
    equal to <code>warning</code>.</p></item><item><p>If the axis name is omitted from an <termref def="dt-axis-step">axis step</termref>, the default axis is
    <code>child</code>, with two exceptions:

    (1) if the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-NodeTest" xlink:type="simple">NodeTest</nt> in an axis step contains an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AttributeTest" xlink:type="simple">AttributeTest</nt> or <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt> then the
    default axis is <code>attribute</code>;     
    (2) if the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-NodeTest" xlink:type="simple">NodeTest</nt> in an axis step is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-NamespaceNodeTest" xlink:type="simple">NamespaceNodeTest</nt> 
    
                        <phrase role="xpath">then the default axis is <code>namespace</code> - in an implementation that does not support
    the namespace axis, an error is raised <errorref class="ST" code="0134"/>.</phrase>

                        <note><p>
                              <phrase diff="del">In an implementation that does not support the namespace
    axis, an attempt to access it always raises an error. Thus, an
    XQuery implementation will always raise an error in this case,
    since XQuery does not support the namespace axis.</phrase> The namespace
    axis is deprecated as of XPath 2.0, but required in some languages
    that use XPath, including XSLT.</p></note>

    For example, the path expression <code role="parse-test">section/para</code> is an abbreviation for <code role="parse-test">child::section/child::para</code>, and the path
    expression <code role="parse-test">section/@id</code> is an
    abbreviation for <code role="parse-test">child::section/attribute::id</code>.  Similarly,
    <code role="parse-test">section/attribute(id)</code> is an
    abbreviation for <code role="parse-test">child::section/attribute::attribute(id)</code>. Note
    that the latter expression contains both an axis specification and
    a <termref def="dt-node-test">node test</termref>.</p></item><item><p> Each non-initial occurrence of <code>//</code> is effectively replaced by  <code>/descendant-or-self::node()/</code> during processing of a path expression. For example, <code role="parse-test">div1//para</code> is
short for <code role="parse-test">child::div1/descendant-or-self::node()/child::para</code> and so will select all <code>para</code> descendants of <code>div1</code> children.</p><note><p>The path expression <code role="parse-test">//para[1]</code> does <emph>not</emph> mean the same as the path
expression <code role="parse-test">/descendant::para[1]</code>. The latter selects the first descendant <code>para</code> element; the former
selects all descendant <code>para</code> elements that are the first <code>para</code> children of their respective parents.</p></note></item><item><p>A step consisting
of <code role="parse-test">..</code> is short
for <code role="parse-test">parent::node()</code>. For example, <code role="parse-test">../title</code> is short for <code role="parse-test">parent::node()/child::title</code> and so will select the <code>title</code> children of the parent of the context node.</p><note><p>The expression <code>.</code>, known as a <term>context item
   expression</term>, is a <termref def="dt-primary-expression">primary expression</termref>,
   and is described in <specref ref="id-context-item-expression"/>.</p></note></item></olist><p>Here are some examples of path expressions that use the abbreviated
syntax:</p><ulist><item><p> 
                        <code>para</code> selects the <code>para</code> element children of the context node</p></item><item><p> 
                        <code role="parse-test">*</code> selects all element children of the context node</p></item><item><p> 
                        <code role="parse-test">text()</code> selects all text node children of the context node</p></item><item><p> 
                        <code role="parse-test">@name</code> selects
the <code>name</code> attribute of the context node</p></item><item><p> 
                        <code role="parse-test">@*</code> selects all the attributes of the context node</p></item><item><p> 
                        <code role="parse-test">para[1]</code> selects the first <code>para</code> child of the context node</p></item><item><p> 
                        <code role="parse-test">para[fn:last()]</code> selects the last <code>para</code> child of the context node</p></item><item><p> 
                        <code role="parse-test">*/para</code> selects
all <code>para</code> grandchildren of the context node</p></item><item><p> 
                        <code role="parse-test">/book/chapter[5]/section[2]</code> selects the
second <code>section</code> of the fifth <code>chapter</code> of the <code>book</code> whose parent is the document node that contains the context node</p></item><item><p> 
                        <code role="parse-test">chapter//para</code> selects the <code>para</code> element descendants of the <code>chapter</code> element children of the context node</p></item><item><p> 
                        <code role="parse-test">//para</code> selects all
the <code>para</code> descendants of the root document node and thus selects all <code>para</code> elements in the same document as the context node</p></item><item><p>
                        <code role="parse-test">//@version</code> selects all the <code>version</code> attribute nodes that are in the same document as the context node</p></item><item><p> 
                        <code role="parse-test">//list/member</code> selects all the <code>member</code> elements in the same document as the context node that have a <code>list</code> parent</p></item><item><p> 
                        <code role="parse-test">.//para</code> selects
the <code>para</code> element descendants of the context node</p></item><item><p> 
                        <code role="parse-test">..</code> selects the parent of the context node</p></item><item><p> 
                        <code role="parse-test">../@lang</code> selects
the <code>lang</code> attribute of the parent of the context node</p></item><item><p> 
                        <code role="parse-test">para[@type="warning"]</code> selects all <code>para</code> children of the context node that have a <code>type</code> attribute with value <code>warning</code> 
                     </p></item><item><p> 
                        <code role="parse-test">para[@type="warning"][5]</code> selects the fifth <code>para</code> child of the context node that has a <code>type</code> attribute with value <code>warning</code> 
                     </p></item><item><p> 
                        <code role="parse-test">para[5][@type="warning"]</code> selects the fifth <code>para</code> child of the context node if that child has a <code>type</code> attribute with value <code>warning</code> 
                     </p></item><item><p> 
                        <code role="parse-test">chapter[title="Introduction"]</code> selects the <code>chapter</code> children of the context node that have one
or more <code>title</code> children whose <termref def="dt-typed-value">typed value</termref> is equal to the string <code>Introduction</code> 
                     </p></item><item><p> 
                        <code role="parse-test">chapter[title]</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children</p></item><item><p> 
                        <code role="parse-test">employee[@secretary and @assistant]</code> selects all
the <code>employee</code> children of the context node that have both a <code>secretary</code> attribute and
an <code>assistant</code> attribute</p></item><item><p> 
                        <code role="parse-test">book/(chapter|appendix)/section</code> selects
every <code>section</code> element that has a parent that is either a <code>chapter</code> or an <code>appendix</code> element, that in turn is a child of a <code>book</code> element that is a child of the context node.</p></item><item><p>If <code>E</code> is any expression that returns a sequence of nodes, then the expression <code role="parse-test">E/.</code> returns the same nodes in <termref def="dt-document-order">document order</termref>, with duplicates eliminated based on node identity.</p></item></ulist></div3></div2><div2 id="id-sequence-expressions"><head>Sequence Expressions</head><p>XPath 3.1 supports operators to construct, filter,  and combine
<termref def="dt-sequence">sequences</termref> of <termref def="dt-item">items</termref>.
Sequences are never nested—for
example, combining the values <code>1</code>, <code>(2, 3)</code>, and <code>( )</code> into a single sequence results
in the sequence <code>(1, 2, 3)</code>.</p><div3 id="construct_seq"><head>Constructing Sequences</head><scrap headstyle="show"><head/><prod num="6" id="noid_d3e12284.doc-xpath31-Expr"><lhs>Expr</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod><prod num="20" id="doc-xpath31-RangeExpr"><lhs>RangeExpr</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt> ( "to"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt> )?</rhs></prod></scrap><p>
                  <termdef term="comma operator" id="dt-comma-operator">One way to construct a sequence is by using the <term>comma operator</term>, which evaluates each of its operands and concatenates the resulting sequences, in order, into a single result sequence.</termdef> Empty parentheses can be used to denote an empty sequence.</p><p>A sequence may contain duplicate
<termref def="dt-item">items</termref>, but a sequence is never an item in another sequence. When a
new sequence is created by concatenating two or more input sequences, the new
sequence contains all the items of the input sequences and its length is the
sum of the lengths of the input sequences.</p><note><p>In places where the grammar calls for <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>, such as the arguments of a function call, any expression that contains a top-level comma operator must be enclosed in parentheses.</p></note><p>Here are some examples of expressions that construct sequences:
</p><ulist><item><p>The result of this expression is a sequence of five integers:</p><eg role="parse-test" xml:space="preserve">(10, 1, 2, 3, 4)</eg></item><item><p>This expression combines four sequences of length one, two, zero, and two, respectively, into a single sequence of length five. The result of this expression is the sequence <code>10, 1, 2, 3, 4</code>.</p><eg role="parse-test" xml:space="preserve">(10, (1, 2), (), (3, 4))</eg></item><item><p>The result of this expression is a sequence containing
all <code>salary</code> children of the context node followed by all <code>bonus</code> children.</p><eg role="parse-test" xml:space="preserve">(salary, bonus)</eg></item><item><p>Assuming that <code>$price</code> is bound to
the value <code>10.50</code>, the result of this expression is the sequence <code>10.50, 10.50</code>.</p><eg role="parse-test" xml:space="preserve">($price, $price)</eg></item></ulist><p>A <term>range expression</term> can be used to construct a sequence of consecutive
integers. Each of the operands of the <code>to</code> operator is
converted as though it was an argument of a function with the expected
parameter type <code>xs:integer?</code>.
If either operand is an empty sequence, or if the integer derived from the first operand is greater than the integer derived from the second operand, the result of the range expression is an empty sequence. If the two operands convert to the same integer, the result of the range expression is that integer. Otherwise, the result is a sequence containing the two integer operands and
every integer between the two operands, in increasing order. </p><ulist><item><p>This example uses a range expression as one operand in constructing a sequence. It evaluates to the sequence <code>10, 1, 2, 3, 4</code>.</p><eg role="parse-test" xml:space="preserve">(10, 1 to 4)</eg></item><item><p>This example constructs a sequence of length one containing the single integer <code>10</code>.</p><eg role="parse-test" xml:space="preserve">10 to 10</eg></item><item><p>The result of this example is a sequence of length zero.</p><eg role="parse-test" xml:space="preserve">15 to 10</eg></item><item><p>This example uses the <code>fn:reverse</code> function to construct a sequence of six integers in decreasing order. It evaluates to the sequence <code>15, 14, 13, 12, 11, 10</code>.</p><eg role="parse-test" xml:space="preserve">fn:reverse(10 to 15)</eg></item></ulist></div3><div3 id="combining_seq"><head>Combining Node Sequences</head><scrap headstyle="show"><head/><prod num="23" id="doc-xpath31-UnionExpr"><lhs>UnionExpr</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-IntersectExceptExpr" xlink:type="simple">IntersectExceptExpr</nt> ( ("union"  |  "|")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-IntersectExceptExpr" xlink:type="simple">IntersectExceptExpr</nt> )*</rhs></prod><prod num="24" id="doc-xpath31-IntersectExceptExpr"><lhs>IntersectExceptExpr</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-InstanceofExpr" xlink:type="simple">InstanceofExpr</nt> ( ("intersect"  |  "except")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-InstanceofExpr" xlink:type="simple">InstanceofExpr</nt> )*</rhs></prod></scrap><p>XPath 3.1 provides the following operators for combining sequences of
nodes:</p><ulist><item><p>The <code>union</code> and <code>|</code> operators are equivalent. They take two node sequences as operands and
return a sequence containing all the nodes that occur in either of the
operands.</p></item><item><p>The <code>intersect</code> operator takes two node sequences as operands and returns a sequence
containing all the nodes that occur in both operands.</p></item><item><p>The <code>except</code> operator takes two node sequences as operands and returns a sequence
containing all the nodes that occur in the first operand but not in the second
operand.</p></item></ulist><p>
 All these operators eliminate duplicate nodes from their result sequences based on node identity. <phrase role="xpath">The resulting sequence is returned in <termref def="dt-document-order">document
	 order</termref>.</phrase>
               </p><p>If an operand
of <code>union</code>, <code>intersect</code>, or <code>except</code> contains an item that is not a node, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p><p>
If an IntersectExceptExpr contains more than two InstanceofExprs,
they are grouped from left to right.
With a UnionExpr, it makes no difference how operands are grouped,
the results are the same.
</p><example><p>Here are some examples of expressions that combine sequences. Assume the existence of three element nodes that we will refer to by symbolic names A, B, and C.  Assume that the variables <code>$seq1</code>,  <code>$seq2</code>  and <code>$seq3</code> are bound to the following sequences of these nodes:</p><ulist><item><p>
                           <code>$seq1</code> is bound to (A, B)</p></item><item><p>
                           <code>$seq2</code> is bound to (A, B)</p></item><item><p>
                           <code>$seq3</code> is bound to (B, C)</p></item></ulist><p>Then: </p><ulist><item><p> 
                           <code role="parse-test">$seq1 union $seq2</code>  evaluates to the sequence (A, B). </p></item><item><p> 
                           <code role="parse-test">$seq2 union $seq3</code>   evaluates to the sequence (A, B, C). </p></item><item><p> 
                           <code role="parse-test">$seq1 intersect $seq2</code>  evaluates to the sequence (A, B). </p></item><item><p> 
                           <code role="parse-test">$seq2 intersect $seq3</code>  evaluates to the sequence containing B only.</p></item><item><p> 
                           <code role="parse-test">$seq1 except $seq2</code>   evaluates to the empty sequence.</p></item><item><p> 
                           <code role="parse-test">$seq2 except $seq3</code>  evaluates to the sequence containing A only.</p></item></ulist></example><p>In addition to the sequence operators described here, <phrase diff="add" at="bug28308">see <xspecref spec="FO31" ref="sequence-functions"/> for functions defined on sequences.</phrase>
                  <phrase diff="del" at="bug28308">
                     <bibref ref="xpath-functions-31"/> includes functions for indexed access to items or
sub-sequences of a sequence, for indexed insertion or removal of items in a
sequence, and for removing duplicate items from a sequence.</phrase>
               </p></div3></div2><div2 id="id-arithmetic"><head>Arithmetic Expressions</head><p>XPath 3.1 provides arithmetic operators for addition, subtraction,
multiplication, division, and modulus, in their usual binary and unary
forms.</p><scrap headstyle="show"><head/><prod num="21" id="doc-xpath31-AdditiveExpr"><lhs>AdditiveExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-MultiplicativeExpr" xlink:type="simple">MultiplicativeExpr</nt> ( ("+"  |  "-")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-MultiplicativeExpr" xlink:type="simple">MultiplicativeExpr</nt> )*</rhs></prod><prod num="22" id="doc-xpath31-MultiplicativeExpr"><lhs>MultiplicativeExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-UnionExpr" xlink:type="simple">UnionExpr</nt> ( ("*"  |  "div"  |  "idiv"  |  "mod")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-UnionExpr" xlink:type="simple">UnionExpr</nt> )*</rhs></prod><prod num="30" id="doc-xpath31-UnaryExpr"><lhs>UnaryExpr</lhs><rhs>("-"  |  "+")* <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ValueExpr" xlink:type="simple">ValueExpr</nt>
                  </rhs></prod><prod num="31" id="doc-xpath31-ValueExpr"><lhs>ValueExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SimpleMapExpr" xlink:type="simple">SimpleMapExpr</nt>
                  </rhs></prod></scrap><p>A subtraction operator must be preceded by whitespace if
it could otherwise be interpreted as part of the previous token. For
example, <code role="parse-test">a-b</code> will be interpreted as a
name, but <code role="parse-test">a - b</code> and <code role="parse-test">a -b</code> will be interpreted as arithmetic expressions. (See <specref ref="whitespace-rules"/> for further details on whitespace handling.)</p><p>
If an AdditiveExpr contains more than two MultiplicativeExprs,
they are grouped from left to right. So, for instance,
<eg role="parse-test" xml:space="preserve">A - B + C - D</eg>
is equivalent to
<eg role="parse-test" xml:space="preserve">((A - B) + C) - D</eg>
Similarly, the operands of a MultiplicativeExpr are grouped from left to right.
</p><p>The first step in evaluating an arithmetic expression is to evaluate its operands. The order in which the operands are evaluated is <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p><p role="xpath">If <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> is <code>true</code>, each operand is evaluated by applying the following steps, in order:</p><olist role="xpath"><item><p>
                     <termref def="dt-atomization">Atomization</termref> is applied to the operand. The result of this
    operation is called the <term>atomized operand</term>.</p><note diff="del" at="2014-08-25"><p diff="add" at="2014-04-01">Atomization converts arrays to sequences (see <termref def="dt-atomization">Atomization</termref>).</p></note></item><item><p>If the atomized operand is an empty sequence, the result of
    the arithmetic expression is the <code>xs:double</code> value <code>NaN</code>, and the implementation
    need not evaluate the other operand or apply the operator. However,
    an implementation may choose to evaluate the other operand in order
    to determine whether it raises an error.</p></item><item><p>If the atomized operand is a sequence of length greater than one, any items after the first item in the sequence are discarded.</p></item><item><p>If the atomized operand is now an instance of type <code>xs:boolean</code>, <code>xs:string</code>,
<code>xs:decimal</code> (including <code>xs:integer</code>), <code>xs:float</code>, or <code>xs:untypedAtomic</code>, then it
is converted to the type <code>xs:double</code> by applying the <code>fn:number</code> function. (Note that <code>fn:number</code> returns the value <code>NaN</code> if its operand cannot be converted to a number.)</p></item></olist><p>
               <phrase role="xpath">If <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> is <code>false</code>, each</phrase> operand is evaluated by applying the following steps, in order:</p><olist><item><p>
                     <termref def="dt-atomization">Atomization</termref> is applied to the operand. The result of this
    operation is called the <term>atomized operand</term>.</p><note diff="del" at="2014-08-25"><p diff="add" at="2014-04-01">Atomization converts arrays to sequences (see <termref def="dt-atomization">Atomization</termref>).</p></note></item><item><p>If the atomized operand is an empty sequence, the result of
    the arithmetic expression is an empty sequence, and the implementation
    need not evaluate the other operand or apply the operator. However,
    an implementation may choose to evaluate the other operand in order
    to determine whether it raises an error.</p></item><item><p> If the atomized operand is a sequence of
length greater than one, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p></item><item><p>If the atomized operand is of type <code>xs:untypedAtomic</code>, it is cast to  <code>xs:double</code>. If
the cast fails, a <termref def="dt-dynamic-error">dynamic
error</termref> is raised. <xerrorref spec="FO31" class="RG" code="0001"/>
                  </p></item></olist><p>After evaluation of the operands, if the types of the operands are a valid combination
for the given arithmetic operator, the operator is applied to the operands,
resulting in an atomic value or a <termref def="dt-dynamic-error">dynamic error</termref> (for example, an error
might result from dividing by zero.) The combinations of atomic types
that are accepted by the various arithmetic operators, and their
respective result types, are listed in <specref ref="mapping"/>
together with the <termref def="dt-operator-function">operator functions</termref>
that define the semantics of the operator for each
type combination, including the dynamic errors that can be raised by the operator. The definitions of the operator functions are found in <bibref ref="xpath-functions-31"/>.</p><p>If the types of the operands, after evaluation, are not a valid combination for the given operator, according to the rules in <specref ref="mapping"/>, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p><p>XPath 3.1 supports two division operators named <code>div</code> and <code>idiv</code>. Each of these operators accepts two operands of any <termref def="dt-numeric">numeric</termref> type. 
<phrase diff="del" at="bug28309">As described in <bibref ref="xpath-functions-31"/>, <code role="parse-test">$arg1 idiv $arg2</code> is equivalent to <code role="parse-test">($arg1 div $arg2) cast as xs:integer?</code> except for error cases.</phrase>
               <phrase diff="add" at="bug28309">The semantics of <code>div</code> are defined in <xspecref spec="FO31" ref="func-numeric-integer-divide"/>.</phrase>
               <phrase diff="add" at="bug28309">The semantics of <code>idiv</code> are defined in <xspecref spec="FO31" ref="func-numeric-divide"/>.</phrase>
            </p><p>Here are some examples of arithmetic expressions:</p><ulist><item><p>The first expression below returns the <code>xs:decimal</code> value <code role="parse-test">-1.5</code>, and the second expression returns the <code>xs:integer</code> value <code role="parse-test">-1</code>:</p><eg role="parse-test" xml:space="preserve">-3 div 2
-3 idiv 2</eg></item><item><note diff="del" at="2014-08-25"><p diff="add" at="2014-04-01">Atomization converts arrays to sequences (see <termref def="dt-atomization">Atomization</termref>).</p></note><p>Subtraction of two date values results in a value of type <code>xs:dayTimeDuration</code>:</p><eg role="parse-test" xml:space="preserve">$emp/hiredate - $emp/birthdate</eg></item><item><p>This example illustrates the difference between a subtraction operator and a
hyphen:</p><eg role="parse-test" xml:space="preserve">$unit-price - $unit-discount</eg></item><item><p>Unary operators have higher precedence than binary operators (other than "<code>!</code>", "<code>/</code>", and "<code>[]</code>"), subject of
course to the use of parentheses. Therefore, the following two examples have different meanings:</p><eg xml:space="preserve">-$bellcost + $whistlecost
-($bellcost + $whistlecost)</eg></item></ulist><note><p id="note-consecutive-unary-ops">Multiple consecutive unary arithmetic operators are permitted.<phrase diff="del" at="bug29903">for compatibility with <bibref ref="xpath"/>
                  </phrase>
               </p></note></div2><div2 id="id-string-concat-expr"><head>String Concatenation Expressions</head><scrap headstyle="show"><head/><prod num="19" id="doc-xpath31-StringConcatExpr"><lhs>StringConcatExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-RangeExpr" xlink:type="simple">RangeExpr</nt> ( "||"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-RangeExpr" xlink:type="simple">RangeExpr</nt> )*</rhs></prod></scrap><p>String concatenation expressions allow the string representations of values to be concatenated. In XPath 3.1, <code>$a || $b</code> is equivalent to <code>fn:concat($a, $b)</code>. The following expression evaluates to the string <code>concatenate</code>:</p><eg xml:space="preserve">"con" || "cat" || "enate"</eg></div2><div2 id="id-comparisons"><head>Comparison Expressions</head><p>Comparison expressions allow two values to be compared. XPath 3.1 provides
three kinds of comparison expressions, called value comparisons, general
comparisons, and node comparisons.</p><scrap headstyle="show"><head/><prod num="18" id="doc-xpath31-ComparisonExpr"><lhs>ComparisonExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-StringConcatExpr" xlink:type="simple">StringConcatExpr</nt> ( (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ValueComp" xlink:type="simple">ValueComp</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-GeneralComp" xlink:type="simple">GeneralComp</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-NodeComp" xlink:type="simple">NodeComp</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-StringConcatExpr" xlink:type="simple">StringConcatExpr</nt> )?</rhs></prod><prod num="33" id="doc-xpath31-ValueComp"><lhs>ValueComp</lhs><rhs>"eq"  |  "ne"  |  "lt"  |  "le"  |  "gt"  |  "ge"</rhs></prod><prod num="32" id="doc-xpath31-GeneralComp"><lhs>GeneralComp</lhs><rhs>"="  |  "!="  |  "&lt;"  |  "&lt;="  |  "&gt;"  |  "&gt;="</rhs></prod><prod num="34" id="doc-xpath31-NodeComp"><lhs>NodeComp</lhs><rhs>"is"  |  "&lt;&lt;"  |  "&gt;&gt;"</rhs></prod></scrap><note role="xpath"><p role="xpath">When an XPath expression is written
within an XML document, the XML escaping rules for special characters
must be followed; thus "<code>&lt;</code>" must be written as
"<code>&amp;lt;</code>".</p></note><div3 id="id-value-comparisons"><head>Value Comparisons</head><p>The value comparison operators are <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, and <code>ge</code>. Value comparisons are used for comparing single values.</p><p>The first step in evaluating a value comparison is to evaluate its operands. The order in which the operands are evaluated is <termref def="dt-implementation-dependent">implementation-dependent</termref>. Each operand is evaluated by applying the following steps, in order:</p><olist><item><p>
                        <termref def="dt-atomization">Atomization</termref> is applied to <phrase diff="chg" at="2014-09-30">each</phrase>  operand. The result of this
    operation is called the <term>atomized operand</term>.</p><note diff="del" at="2014-08-25"><p diff="add" at="2014-04-01">Atomization converts arrays to sequences (see <termref def="dt-atomization">Atomization</termref>).</p></note></item><item><p>If <phrase diff="chg" at="2014-09-30">an</phrase> atomized operand is an empty sequence, the result of
    the value comparison is an empty sequence, and the implementation
    need not evaluate the other operand or apply the operator. However,
    an implementation may choose to evaluate the other operand in order
    to determine whether it raises an error.</p></item><item><p> If <phrase diff="chg" at="2014-09-30">an</phrase> atomized operand is a sequence of
length greater than one, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p></item><item><p>If <phrase diff="chg" at="2014-09-30">an</phrase>  atomized operand is of type
  <code>xs:untypedAtomic</code>, it is cast to
  <code>xs:string</code>.</p><note><p>The purpose of this rule is to
  make value comparisons transitive. Users should be aware that the
  general comparison operators have a different rule for casting of
  <code>xs:untypedAtomic</code> operands. Users should also be aware
  that transitivity of value comparisons may be compromised by loss of
  precision during type conversion (for example, two
  <code>xs:integer</code> values that differ slightly may both be
  considered equal to the same <code>xs:float</code> value because
  <code>xs:float</code> has less precision than
  <code>xs:integer</code>).</p></note></item><item><p diff="del" at="2014-09-30">Next, if possible, the two operands are converted to their least common
    type by a combination of <termref def="dt-type-promotion">type promotion</termref> and <termref def="dt-subtype-substitution">subtype substitution</termref>.  For
    example, if the operands are of type <code>hatsize</code> (derived from <code>xs:integer</code>) and
    <code>shoesize</code> (derived from <code>xs:float</code>), their least common type is <code>xs:float</code>.</p><p diff="add" at="2014-09-30">If the two operands are instances of different primitive types (meaning the 19 primitive types defined in <xspecref diff="chg" at="bug28310" spec="XS2" ref="built-in-primitive-datatypes"/>), then:
    <olist><item><p>If each operand is an instance of one of the types <code>xs:string</code> or <code>xs:anyURI</code>, then both operands are cast to type <code>xs:string</code>.</p></item><item><p>If each operand is an instance of one of the types <code>xs:decimal</code> or <code>xs:float</code>, then both operands are cast to type <code>xs:float</code>.</p></item><item><p>If each operand is an instance of one of the types <code>xs:decimal</code>, <code>xs:float</code>, or <code>xs:double</code>, then both operands are cast to type <code>xs:double</code>.</p></item><item><p>Otherwise, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p><note><p>The primitive type of an <code>xs:integer</code> value for this purpose is <code>xs:decimal</code>.</p></note></item></olist> 
                     </p></item><item><p>Finally, if the types of the operands are a valid
  combination for the given operator, the operator is applied to the
  operands.</p></item></olist><p>The combinations of atomic types that are accepted by the various
value comparison operators, and their respective result types, are
listed in <specref ref="mapping"/> together with the <termref def="dt-operator-function">operator functions</termref> that define
the semantics of the operator for each type combination. The
definitions of the operator functions are found in <bibref ref="xpath-functions-31"/>.</p><p>Informally, if both atomized operands consist of exactly one atomic
value, then the result of the comparison is <code>true</code> if the value of the
first operand is (equal, not equal, less than, less than or equal,
greater than, greater than or equal) to the value of the second
operand; otherwise the result of the comparison is <code>false</code>.</p><p>If the types of the operands, after evaluation, are not a valid
combination for the given operator, according to the rules in <specref ref="mapping"/>, a <termref def="dt-type-error">type error</termref>
is raised <errorref class="TY" code="0004"/>.</p><p>Here are some examples of value comparisons:</p><ulist><item><p>The following comparison atomizes the node(s) that are returned by the expression <code>$book/author</code>. The comparison is true only if the result of atomization is the value "Kennedy" as an instance of <code>xs:string</code> or <code>xs:untypedAtomic</code>. If the result of atomization is an empty sequence, the result of the comparison is an empty sequence. If the result of atomization is a sequence containing more than one value, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p><eg role="parse-test" xml:space="preserve">$book1/author eq "Kennedy"</eg></item><item diff="add" at="2014-04-02"><p>The following comparison is <code>true</code> because atomization converts an array to its member sequence:</p><eg role="parse-test" xml:space="preserve">[ "Kennedy" ] eq "Kennedy"</eg></item><item><p>The following <termref def="dt-path-expression">path expression</termref> contains a predicate that selects products whose weight is greater than 100. For any product that does not have a <code>weight</code> subelement, the value of the predicate is the empty sequence, and the product is not selected. This example assumes that <code>weight</code> is a validated element with a numeric type.</p><eg role="parse-test" xml:space="preserve">//product[weight gt 100]</eg></item><item><p>The following comparison is true if <code>my:hatsize</code> and <code>my:shoesize</code> are both user-defined types that are derived by restriction from a primitive <termref def="dt-numeric">numeric</termref> type:</p><eg role="parse-test" xml:space="preserve">my:hatsize(5) eq my:shoesize(5)</eg></item><item><p>The following comparison is true. The <code>eq</code> operator compares two QNames by performing codepoint-comparisons of their namespace URIs and their local names, ignoring their namespace prefixes.</p><eg role="parse-test" xml:space="preserve">fn:QName("http://example.com/ns1", "this:color") eq fn:QName("http://example.com/ns1", "that:color")</eg></item></ulist></div3><div3 id="id-general-comparisons"><head>General Comparisons</head><p>The general comparison operators are <code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>. General comparisons are existentially quantified comparisons that may be applied to operand sequences of any length. The result of a general comparison that does not raise an error is
always <code>true</code> or <code>false</code>.</p><p role="xpath">If <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> is <code>true</code>, a general comparison is evaluated by applying the following rules, in order:</p><olist role="xpath"><item><p>If either operand is a single atomic value that is an instance of
<code>xs:boolean</code>, then the other operand is converted to <code>xs:boolean</code> by taking its
<termref def="dt-ebv">effective boolean value</termref>.</p></item><item><p>
                        <termref def="dt-atomization">Atomization</termref> is applied to each operand. After atomization, each operand is a sequence of atomic values.</p><note diff="del" at="2014-08-25"><p diff="add" at="2014-04-01">Atomization converts arrays to sequences (see <termref def="dt-atomization">Atomization</termref>).</p></note></item><item><p>If the comparison operator is <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, or <code>&gt;=</code>, then each item in both of the
operand sequences is converted to the type  <code>xs:double</code> by applying the
<code>fn:number</code> function. (Note that <code>fn:number</code> returns the value <code>NaN</code> if its operand cannot be converted to a number.)</p></item><item><p>The result of the comparison is <code>true</code> if and only if there is a pair of
atomic values, one in the first operand sequence and the other in the second operand sequence, that have the required
<term>magnitude relationship</term>. Otherwise the result of the  comparison is
<code>false</code> 
                        <phrase diff="add" at="2014-09-30">or an error</phrase>. The <term>magnitude relationship</term> between two atomic values is determined by
applying the following rules. If a <code>cast</code> operation called for by these rules is not successful, a <termref def="dt-dynamic-error">dynamic error</termref>  is raised. <xerrorref spec="FO31" class="RG" code="0001"/>
                     </p><olist><item><p>If at least one of the two atomic values is an instance of a <termref def="dt-numeric">numeric</termref> type, then both atomic values are converted to the type <code>xs:double</code> by
applying the <code>fn:number</code> function.</p></item><item><p>If at least one of the two atomic values is an instance of <code>xs:string</code>,
or if both atomic values are instances of <code>xs:untypedAtomic</code>, then both
atomic values are cast to the type <code>xs:string</code>.</p></item><item><p>If one of the atomic values is an instance of <code>xs:untypedAtomic</code> and the other is not an instance of <code>xs:string</code>, <code>xs:untypedAtomic</code>, or any <termref def="dt-numeric">numeric</termref> type, then the <code>xs:untypedAtomic</code> value is
cast to the <termref def="dt-dynamic-type">dynamic type</termref> of the other value.</p></item><item><p>After performing the conversions described above, the atomic values are
compared using one of the value comparison operators <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, or
<code>ge</code>, depending on whether the general comparison operator was <code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>,
<code>&gt;</code>, or <code>&gt;=</code>. The values have the required <term>magnitude relationship</term> if and only if the result
of this value comparison is <code>true</code>.</p></item></olist></item></olist><p>
                  <phrase role="xpath">If <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> is <code>false</code>, a</phrase> general comparison is evaluated by applying the following rules, in order:</p><olist><item><p>
                        <termref def="dt-atomization">Atomization</termref> is applied to each operand. After atomization, each operand is a sequence of atomic values.</p><note diff="del" at="2014-08-25"><p diff="add" at="2014-04-01">Atomization converts arrays to sequences (see <termref def="dt-atomization">Atomization</termref>).</p></note></item><item><p>The result of the comparison is <code>true</code> if and only if there is a pair of
atomic values, one in the first operand sequence and the other in the second operand sequence, that have the required
<term>magnitude relationship</term>. Otherwise the result of the  comparison is
<code>false</code> 
                        <phrase diff="add" at="2015-07-07">or an error</phrase>. The <term>magnitude relationship</term> between two atomic values is determined by
applying the following rules. If a <code>cast</code> operation called for by these rules is not successful, a <termref def="dt-dynamic-error">dynamic error</termref>  is raised. <xerrorref spec="FO31" class="RG" code="0001"/>
                     </p><olist><item><p>If both atomic values are instances of <code>xs:untypedAtomic</code>,
                then the values are cast to the type <code>xs:string</code>.
             </p></item><item><p>If exactly one of the atomic values is an instance of
                <code>xs:untypedAtomic</code>, it is cast to a type depending on
                the other value's dynamic type T according to the following rules,
                in which V denotes the value to be cast:
             </p><olist><item><p>If T is a numeric type or is derived from a numeric type,
                      then V is cast to <code>xs:double</code>.</p></item><item><p>If T is <code>xs:dayTimeDuration</code> or is derived from
                      <code>xs:dayTimeDuration</code>,
                      then V is cast to <code>xs:dayTimeDuration</code>.</p></item><item><p>If T is <code>xs:yearMonthDuration</code> or is derived from
                      <code>xs:yearMonthDuration</code>,
                      then V is cast to <code>xs:yearMonthDuration</code>.</p></item><item><p>In all other cases, V is cast to the primitive base type of T.</p></item></olist><note><p>
                The special treatment of the duration types is required to avoid
                errors that may arise when comparing the primitive type
                <code>xs:duration</code> with any duration type.
             </p></note></item><item><p>After performing the conversions described above, the atomic values are
compared using one of the value comparison operators <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, or
<code>ge</code>, depending on whether the general comparison operator was <code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>,
<code>&gt;</code>, or <code>&gt;=</code>. The values have the required <term>magnitude relationship</term> if and only if the result
of this value comparison is <code>true</code>.</p></item></olist></item></olist><p>When evaluating a general comparison in which either operand is a sequence of items, an implementation may return <code>true</code> as soon as it finds an item in the first operand and an item in the second operand that have the required <term>magnitude relationship</term>. Similarly, a general comparison may raise a <termref def="dt-dynamic-error">dynamic error</termref> as soon as it encounters an error in evaluating either operand, or in comparing a pair of items from the two operands. As a result of these rules, the result of a general comparison is not deterministic in the presence of errors.</p><p>Here are some examples of  general comparisons:</p><ulist><item><p>The following comparison is true if the <termref def="dt-typed-value">typed value</termref> of any
<code>author</code> subelement of <code>$book1</code> is "Kennedy" as an instance of <code>xs:string</code> or <code>xs:untypedAtomic</code>:</p><eg role="parse-test" xml:space="preserve">$book1/author = "Kennedy"</eg></item><item diff="add" at="2014-04-02"><p>The following comparison is <code>true</code> because atomization converts an array to its member sequence:</p><eg role="parse-test" xml:space="preserve">[ "Obama", "Nixon", "Kennedy" ] = "Kennedy"</eg></item><item><p>The following example contains three general comparisons. The value of the first two comparisons is <code>true</code>, and the value of the third comparison is <code>false</code>. This example illustrates the fact that general comparisons are not transitive.</p><eg xml:space="preserve">(1, 2) = (2, 3)
(2, 3) = (3, 4)
(1, 2) = (3, 4)</eg></item><item><p>The following example contains two general comparisons, both of which are <code>true</code>. This example illustrates the fact that the <code>=</code> and <code>!=</code> operators are not inverses of each other.</p><eg xml:space="preserve">(1, 2) = (2, 3)
(1, 2) != (2, 3)</eg></item><item><p>Suppose that <code>$a</code>, <code>$b</code>, and <code>$c</code> are bound to element nodes with type annotation <code>xs:untypedAtomic</code>, with <termref def="dt-string-value">string values</termref> "<code>1</code>", "<code>2</code>", and "<code>2.0</code>" respectively. Then <code role="parse-test">($a, $b) = ($c, 3.0)</code> returns <code>false</code>, because <code>$b</code> and <code>$c</code> are compared as strings. However, <code role="parse-test">($a, $b) = ($c, 2.0)</code> returns <code>true</code>, because <code>$b</code> and <code>2.0</code> are compared as numbers.</p></item></ulist></div3><div3 id="id-node-comparisons"><head>Node Comparisons</head><p>Node comparisons are used to compare two nodes, by their identity or by their <termref def="dt-document-order">document order</termref>. The result of a node comparison is defined by the following rules:</p><olist><item><p>The operands of a node comparison are evaluated in <termref def="dt-implementation-dependent">implementation-dependent</termref> order.</p></item><item><p>If either operand is an empty sequence, the result of the
    comparison is an empty sequence, and the implementation need not
    evaluate the other operand or apply the operator. However, an
    implementation may choose to evaluate the other operand in order to
    determine whether it raises an error.</p></item><item><p> Each operand must be either a single node or an empty sequence; otherwise
a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p></item><item><p>A comparison with the <code>is</code> operator is <code>true</code> if the two operand nodes <phrase diff="del" at="2014-12-06">have the same identity, and are thus</phrase>
                        <phrase diff="add" at="2014-12-06">are</phrase> the same node; otherwise it
is <code>false</code>. See <bibref ref="xpath-datamodel-31"/> for  <phrase diff="chg" at="bug28311">the</phrase> definition of node identity.</p></item><item><p>A comparison with the <code>&lt;&lt;</code> operator returns <code>true</code> if the left operand node precedes the right operand node in
<termref def="dt-document-order">document order</termref>; otherwise it returns <code>false</code>.</p></item><item><p>A comparison with the <code>&gt;&gt;</code> operator returns <code>true</code> if the left operand node follows the right operand node in
<termref def="dt-document-order">document order</termref>; otherwise it returns <code>false</code>.</p></item></olist><p>Here are some examples of node comparisons:</p><ulist><item><p>The following comparison is true only if the left and right sides each
evaluate to exactly the same single node:</p><eg role="parse-test" xml:space="preserve">/books/book[isbn="1558604820"] is /books/book[call="QA76.9 C3845"]</eg></item><item><p>The following comparison is true only if the node identified by the left
side occurs before the node identified by the right side in document order:</p><eg role="parse-test" xml:space="preserve">/transactions/purchase[parcel="28-451"] &lt;&lt; /transactions/sale[parcel="33-870"]</eg></item></ulist></div3></div2><div2 id="id-logical-expressions"><head>Logical Expressions</head><p>A <term>logical expression</term> is either an <term>and-expression</term> or
an <term>or-expression</term>. If a logical expression does not raise an error, its value is always one
of the boolean values <code>true</code> or <code>false</code>.</p><scrap headstyle="show"><head/><prod num="16" id="doc-xpath31-OrExpr"><lhs>OrExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AndExpr" xlink:type="simple">AndExpr</nt> ( "or"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AndExpr" xlink:type="simple">AndExpr</nt> )*</rhs></prod><prod num="17" id="doc-xpath31-AndExpr"><lhs>AndExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ComparisonExpr" xlink:type="simple">ComparisonExpr</nt> ( "and"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ComparisonExpr" xlink:type="simple">ComparisonExpr</nt> )*</rhs></prod></scrap><p>The first step in evaluating a logical expression is to find the  <termref def="dt-ebv">effective boolean value</termref> of each of its operands (see <specref ref="id-ebv"/>).</p><p>The value of an and-expression is determined by the effective
boolean values (EBV's) of its operands, as shown in the following table:</p><table role="medium" width="80%"><tbody><tr><th rowspan="1" colspan="1">AND:</th><th rowspan="1" colspan="1">EBV<sub>2</sub> =
<code>true</code>
                     </th><th rowspan="1" colspan="1">EBV<sub>2</sub> = <code>false</code>
                     </th><th rowspan="1" colspan="1">error in EBV<sub>2</sub>
                     </th></tr><tr><th rowspan="1" colspan="1">EBV<sub>1</sub> =
<code>true</code>
                     </th><td rowspan="1" colspan="1">
                        <code>true</code>
                     </td><td rowspan="1" colspan="1">
                        <code>false</code>
                     </td><td rowspan="1" colspan="1">error</td></tr><tr><th rowspan="1" colspan="1">EBV<sub>1</sub>
= <code>false</code>
                     </th><td rowspan="1" colspan="1">
                        <code>false</code>
                     </td><td rowspan="1" colspan="1">
                        <code>false</code>
                     </td><td rowspan="1" colspan="1">
                        <phrase role="xpath">if <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> is <code>true</code>, then <code>false</code>; otherwise either <code>false</code> or error.</phrase>
                     </td></tr><tr><th rowspan="1" colspan="1">error in EBV<sub>1</sub>
                     </th><td rowspan="1" colspan="1">error</td><td rowspan="1" colspan="1">
                        <phrase role="xpath">if <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> is <code>true</code>, then error; otherwise either <code>false</code> or error.</phrase>
                     </td><td rowspan="1" colspan="1">error</td></tr></tbody></table><p>The value of an
or-expression is determined by the effective boolean values (EBV's) of
its operands, as shown in
the following table:</p><table role="medium" width="80%"><tbody><tr><th rowspan="1" colspan="1">OR:</th><th rowspan="1" colspan="1">EBV<sub>2</sub> =
<code>true</code>
                     </th><th rowspan="1" colspan="1">EBV<sub>2</sub> = <code>false</code>
                     </th><th rowspan="1" colspan="1">error in
EBV<sub>2</sub>
                     </th></tr><tr><th rowspan="1" colspan="1">EBV<sub>1</sub> =
<code>true</code>
                     </th><td rowspan="1" colspan="1">
                        <code>true</code>
                     </td><td rowspan="1" colspan="1">
                        <code>true</code>
                     </td><td rowspan="1" colspan="1">
                        <phrase role="xpath">if <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> is <code>true</code>, then <code>true</code>; otherwise either <code>true</code> or error.</phrase>
                     </td></tr><tr><th rowspan="1" colspan="1">EBV<sub>1</sub> =
<code>false</code>
                     </th><td rowspan="1" colspan="1">
                        <code>true</code>
                     </td><td rowspan="1" colspan="1">
                        <code>false</code>
                     </td><td rowspan="1" colspan="1">error</td></tr><tr><th rowspan="1" colspan="1">error
in EBV<sub>1</sub>
                     </th><td rowspan="1" colspan="1">
                        <phrase role="xpath">if <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> is <code>true</code>, then error; otherwise either <code>true</code> or error.</phrase>
                     </td><td rowspan="1" colspan="1">error</td><td rowspan="1" colspan="1">error</td></tr></tbody></table><p role="xpath">If <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> is <code>true</code>, the order in which the operands of a logical expression are evaluated is effectively prescribed. Specifically, it is defined that when there is no
need to evaluate the second operand in order to determine the result, then
no error can occur as a result of evaluating the second operand.</p><p>
               <phrase role="xpath">If <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> is <code>false</code>, the
order in which the operands of a logical expression are evaluated is
<termref def="dt-implementation-dependent">implementation-dependent</termref>. In this case,</phrase> an or-expression can return <code>true</code> if the first
expression evaluated is true, and it can raise an error if evaluation
of the first expression raises an error. Similarly, an and-expression
can return <code>false</code> if the first expression evaluated is
false, and it can raise an error if evaluation of the first expression
raises an error. As a result of these rules, a logical expression is
not deterministic in the presence of errors, as illustrated in the examples
below.</p><p>Here are some examples of logical expressions:</p><ulist><item><p>The following expressions return
<code>true</code>:</p><eg role="parse-test" xml:space="preserve">1 eq 1 and 2 eq 2</eg><eg role="parse-test" xml:space="preserve">1 eq 1 or 2 eq 3</eg></item><item><p>The following
expression may return either <code>false</code> or raise a <termref def="dt-dynamic-error">dynamic error</termref>
                     <phrase role="xpath"> (in <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref>, the result must be <code>false</code>)</phrase>:</p><eg role="parse-test" xml:space="preserve">1 eq 2 and 3 idiv 0 = 1</eg></item><item><p>The
following expression may return either <code>true</code> or raise a
<termref def="dt-dynamic-error">dynamic error</termref>
                     <phrase role="xpath"> (in <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref>, the result must be <code>true</code>)</phrase>:</p><eg role="parse-test" xml:space="preserve">1 eq 1 or 3 idiv 0 = 1</eg></item><item><p>The
following expression must raise a <termref def="dt-dynamic-error">dynamic error</termref>:</p><eg role="parse-test" xml:space="preserve">1 eq 1 and 3 idiv 0 = 1</eg></item></ulist><p>In addition to and- and or-expressions, XPath 3.1 provides a
function named <code>fn:not</code> that takes a general sequence as
parameter and returns a boolean value.  The <code>fn:not</code> function
is defined in <bibref ref="xpath-functions-31"/>. The
<code>fn:not</code> function reduces its parameter to an <termref def="dt-ebv">effective boolean value</termref>. It then returns
<code>true</code> if the effective boolean value of its parameter is
<code>false</code>, and <code>false</code> if the effective boolean
value of its parameter is <code>true</code>. If an error is
encountered in finding the effective boolean value of its operand,
<code>fn:not</code> raises the same error.</p></div2><div2 role="xpath" id="id-for-expressions"><head>For Expressions</head><p>XPath provides an iteration facility called a <term>for expression</term>.</p><scrap headstyle="show"><head/><prod num="8" id="doc-xpath31-ForExpr"><lhs>ForExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SimpleForClause" xlink:type="simple">SimpleForClause</nt>  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>
                  </rhs></prod><prod num="9" id="doc-xpath31-SimpleForClause"><lhs>SimpleForClause</lhs><rhs>"for"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SimpleForBinding" xlink:type="simple">SimpleForBinding</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SimpleForBinding" xlink:type="simple">SimpleForBinding</nt>)*</rhs></prod><prod num="10" id="doc-xpath31-SimpleForBinding"><lhs>SimpleForBinding</lhs><rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-VarName" xlink:type="simple">VarName</nt>  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>
                  </rhs></prod></scrap><p>A <code>for</code> expression is evaluated as follows:</p><olist><item><p>If the <code>for</code> expression uses multiple variables, it is first expanded to a set of nested <code>for</code> expressions, each of which uses only one variable. For example, the expression
<code role="parse-test">for $x in X, $y in Y return $x + $y</code>
is expanded to
<code role="parse-test">for $x in X return
    for $y in Y return $x + $y</code>.</p></item><item><p>In a single-variable <code>for</code> expression, the variable is called the <term>range variable</term>, the value of the expression that follows the <code>in</code> keyword is called the <term>binding sequence</term>, and the expression that follows the <code>return</code> keyword is called the <term>return expression</term>. The result of the <code>for</code> expression is obtained by evaluating the <code>return</code> expression once for each item in the binding sequence, with the range variable bound to that item. The resulting sequences  are concatenated (as if by the <termref def="dt-comma-operator">comma operator</termref>) in the order of the items in the binding sequence from which they were derived.
</p></item></olist><p role="xpath">The following example illustrates the use of a <code>for</code> expression in restructuring an input document. The example is based on the following
input:</p><eg xml:space="preserve">&lt;bib&gt;
  &lt;book&gt;
    &lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Advanced Programming in the Unix Environment&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Data on the Web&lt;/title&gt;
    &lt;author&gt;Abiteboul&lt;/author&gt;
    &lt;author&gt;Buneman&lt;/author&gt;
    &lt;author&gt;Suciu&lt;/author&gt;
  &lt;/book&gt;
&lt;/bib&gt;</eg><p>The following example transforms the input document into a list in
which each author's name appears only once, followed by a list of
titles of books written by that author. This example assumes that the
context item is the <code>bib</code> element in the input
document.</p><eg role="parse-test" xml:space="preserve"><phrase role="parse-test">for $a in fn:distinct-values(book/author)
return ((book/author[. = $a])[1], book[author = $a]/title)</phrase></eg><p>The result of the above expression consists of the following
sequence of elements. The titles of books written by a given author
are listed after the name of the author.

The ordering of <code>author</code> elements in the result is <termref def="dt-implementation-dependent">implementation-dependent</termref> due to the semantics of the <code>fn:distinct-values</code> function.</p><eg xml:space="preserve">&lt;author&gt;Stevens&lt;/author&gt;
&lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
&lt;title&gt;Advanced Programming in the Unix environment&lt;/title&gt;
&lt;author&gt;Abiteboul&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
&lt;author&gt;Buneman&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
&lt;author&gt;Suciu&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;</eg><p>The following example illustrates a <code>for</code> expression containing more than one variable:</p><eg role="parse-test" xml:space="preserve"><phrase role="parse-test">for $i in (10, 20),
    $j in (1, 2)
return ($i + $j)</phrase></eg><p>The result of the above expression, expressed as a sequence of numbers, is as follows: <code>11, 12, 21, 22</code>
            </p><p>The scope of a variable bound in a <code>for</code> expression comprises all subexpressions of the <code>for</code> expression
that appear after the variable binding. The scope does not
include the expression to which the variable is bound. The following example illustrates how a variable binding may reference another variable bound earlier in the same  <code>for</code> expression:</p><eg role="parse-test" xml:space="preserve"><phrase role="parse-test">for $x in $z, $y in f($x)
return g($x, $y)</phrase></eg><note><p>The focus for evaluation of the <code>return</code> clause of a <code>for</code> expression
is the same as the focus for evaluation of the <code>for</code> expression itself. The
following example, which attempts to find the total value of a set of
order-items, is therefore incorrect:

</p><eg role="error" xml:space="preserve">fn:sum(for $i in order-item return @price * @qty)</eg><p>

Instead, the expression must be written to use the variable bound in the <code>for</code> clause:</p><eg role="parse-test" xml:space="preserve">fn:sum(for $i in order-item return $i/@price * $i/@qty)</eg></note></div2><div2 id="id-let-expressions" role="xpath"><head>Let Expressions</head><p>XPath allows a variable to be declared and bound to a value using a <term>let expression</term>.</p><scrap headstyle="show"><head/><prod num="11" id="doc-xpath31-LetExpr"><lhs>LetExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SimpleLetClause" xlink:type="simple">SimpleLetClause</nt>  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>
                  </rhs></prod><prod num="12" id="doc-xpath31-SimpleLetClause"><lhs>SimpleLetClause</lhs><rhs>"let"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SimpleLetBinding" xlink:type="simple">SimpleLetBinding</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SimpleLetBinding" xlink:type="simple">SimpleLetBinding</nt>)*</rhs></prod><prod num="13" id="doc-xpath31-SimpleLetBinding"><lhs>SimpleLetBinding</lhs><rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-VarName" xlink:type="simple">VarName</nt>  ":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>
                  </rhs></prod></scrap><p>A let expression is evaluated as follows:</p><ulist><item><p>If the let expression uses multiple variables, it is first expanded to a
set of nested let expressions, each of which uses only one variable. For
example, the expression <code role="parse-test">let $x := 4, $y := 3 return $x + $y</code> is expanded to
<code role="parse-test">let $x := 4 return let $y := 3 return $x + $y</code>.</p></item><item><p>In a single-variable let expression, the variable is called the range
variable, the value of the expression that follows the <code>:=</code> symbol is called
the binding sequence, and the expression that follows the return keyword is
called the return expression. The result of the let expression is obtained
by evaluating the return expression with the range variable bound to the
binding sequence. </p></item></ulist><p>The scope of a variable bound in a let expression comprises all
subexpressions of the let expression that appear after the variable binding.
The scope does not include the expression to which the variable is bound.
The following example illustrates how a variable binding may reference
another variable bound earlier in the same let expression:</p><eg role="parse-test" xml:space="preserve">
let $x := doc('a.xml')/*, $y := $x//*
return $y[@value gt $x/@min]
</eg></div2><div2 id="id-maps-and-arrays" diff="add" at="2014-02-07"><head>Maps and Arrays</head><p>Most modern programming languages have support for collections of
key/value pairs, which may be called maps, dictionaries, associative
arrays, hash tables, keyed lists, or objects (these are not the same
thing as objects in object-oriented systems). In XPath 3.1, we call
these maps. Most modern programming languages also support ordered
lists of values, which may be called arrays, vectors, or sequences.
<phrase diff="chg" at="2014-08-20">In XPath 3.1, we have both
sequences and arrays. Unlike sequences, an array is an
item, and can appear as an item in a sequence.</phrase>
            </p><p>In previous versions of the language, element structures and
sequences were the only complex data structures.  We are adding maps
and arrays to XPath 3.1 in order to provide lightweight data
structures that are easier to optimize and less complex to use for
intermediate processing and to allow programs to easily combine XML
processing with JSON processing.</p><note diff="add" at="2014-02-07"><p>The XPath 3.1 specification focuses on syntax provided for maps
  and arrays, especially constructors and lookup.</p><p>Some of the functionality typically needed for maps and
  arrays is provided by functions defined in <xspecref spec="FO31" ref="maps-and-arrays"/>, including functions used to
  read JSON to create maps and arrays, serialize maps and arrays to
  JSON, combine maps to create a new map, remove map entries to create
  a new map, iterate over the keys of a map, convert an array to
  create a sequence, combine arrays to form a new array, and iterate
  over arrays in various ways.</p></note><div3 id="id-maps"><head>Maps</head><p>
                  <termdef term="map" id="dt-map">A <term>map</term> is a <phrase diff="add" at="2014-02-07">function
  that associates a set of keys with values, resulting in a</phrase> collection
  of key / value pairs.</termdef>

                  <termdef term="entry" id="dt-entry">Each key / value pair in a map
  is called an <term>entry</term>.</termdef>

                  <termdef term="associated value" id="dt-associated-value">The value
  associated with a given key is called the <term>associated
  value</term> of the key.</termdef>
               </p><div4 id="id-map-constructors"><head>Map Constructors</head><p>A Map is created using a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-MapConstructor" xlink:type="simple">MapConstructor</nt>.</p><scrap headstyle="show"><head/><prod num="69" id="doc-xpath31-MapConstructor"><lhs>MapConstructor</lhs><rhs>"map"  "{"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-MapConstructorEntry" xlink:type="simple">MapConstructorEntry</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-MapConstructorEntry" xlink:type="simple">MapConstructorEntry</nt>)*)?  "}"</rhs></prod><prod num="70" id="doc-xpath31-MapConstructorEntry"><lhs>MapConstructorEntry</lhs><rhs>
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-MapKeyExpr" xlink:type="simple">MapKeyExpr</nt>  ":"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-MapValueExpr" xlink:type="simple">MapValueExpr</nt>
                        </rhs></prod><prod num="71" id="doc-xpath31-MapKeyExpr"><lhs>MapKeyExpr</lhs><rhs>
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>
                        </rhs></prod><prod num="72" id="doc-xpath31-MapValueExpr"><lhs>MapValueExpr</lhs><rhs>
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>
                        </rhs></prod></scrap><note><p diff="chg">
    In some circumstances, it is necessary to include whitespace before or after the colon
    of a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-MapConstructorEntry" xlink:type="simple">MapConstructorEntry</nt> to ensure that it is parsed as intended.
    </p><p diff="add">
    For instance, consider the expression <code>map{a:b}</code>.
    Although it matches the EBNF for MapConstructor
    (with <code>a</code> matching MapKeyExpr and <code>b</code> matching MapValueExpr),
    the "longest possible match" rule requires that <code>a:b</code> be parsed as a QName,
    which results in a syntax error.
    Changing the expression to <code>map{a :b}</code> or <code>map{a: b}</code>
    will prevent this, resulting in the intended parse.
    </p><p diff="add">Similarly, consider these three expressions:</p><eg diff="add" xml:space="preserve">
    map{a:b:c}
    map{a:*:c}
    map{*:b:c}</eg><p diff="add">
    In each case, the expression matches the EBNF in two different ways,
    but the "longest possible match" rule forces the parse in which
    the MapKeyExpr is <code>a:b</code>, <code>a:*</code>, or <code>*:b</code> (respectively)
    and the MapValueExpr is <code>c</code>.
    To achieve the alternative parse
    (in which the MapKeyExpr is merely <code>a</code> or <code>*</code>),
    insert whitespace before and/or after the first colon.
    </p><p diff="add">See <specref ref="lexical-structure"/>.</p></note><p>The value of the expression is a map whose entries
    correspond to the key-value pairs obtained by
    evaluating the successive <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-MapKeyExpr" xlink:type="simple">MapKeyExpr</nt> and
    <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-MapValueExpr" xlink:type="simple">MapValueExpr</nt> expressions.</p><p>Each <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-MapKeyExpr" xlink:type="simple">MapKeyExpr</nt> expression is evaluated
    and atomized; a 

    <phrase diff="del">
                        <termref def="dt-dynamic-error">dynamic error</termref>   
    XQDY0136 occurs if the result is
    not a single atomic value.</phrase>
                     <phrase diff="add" at="2014-08-20">
                        <termref def="dt-type-error">type error</termref>   
                        <errorref class="TY" code="0004"/> occurs if the result is
    not a single atomic value.</phrase>

                     <phrase diff="del" at="2014-08-25">If the key value is of type
    <code>xs:untypedAtomic</code> it is converted to
    <code>xs:string</code>.</phrase>  The associated value is the
    result of evaluating the corresponding
    <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-MapValueExpr" xlink:type="simple">MapValueExpr</nt>.

    <phrase diff="add" at="2014-12-05">If the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-MapValueExpr" xlink:type="simple">MapValueExpr</nt> evaluates to a node, the
    associated value is the node itself, not a new node with the same
    values.</phrase>

                     <note diff="add" at="2014-12-05"><p>XPath 3.1 has no operators
    that can distinguish a map or array from another map or array with
    the same values.  Future versions of the XQuery Update Facility,
    on the other hand, will expose this difference, and need to be
    clear about the data model instance that is constructed.</p><p>In some existing implementations that support updates via
    proprietary extensions, if the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-MapValueExpr" xlink:type="simple">MapValueExpr</nt> evaluates to a map or array,
    the associated value is a new map or array with the same
    values.</p></note>


                     <termdef id="dt-same-key-del" term="same key" diff="del" at="2015-07-04">Two atomic values K1 and
    K2 have the <term>same key value</term> if the relation
    deep-equal(K1, K2, $UCC) holds, where $UCC is the Unicode
    codepoint collation.</termdef>

                     <termdef id="dt-same-key" term="same key" diff="add" at="2015-07-04">Two atomic values <code>K1</code> and
    <code>K2</code> have the <term>same key value</term> if
    <phrase diff="del" at="bug29362">
    the the following two conditions are both true: 
    (1) the relation <code>fn:deep-equal(K1, K2, $UCC)</code> holds, where <code>$UCC</code> is the Unicode
    codepoint collation; and (2) <code>has-timezone(K1) eq has-timezone(K2)</code>, where the function <code>has-timezone(V)</code> returns <code>true</code> if and only if the timezone component of <code>V</code> is present and <code>V</code> is an instance of <code>xs:dateTime</code>, <code>xs:date</code>, <code>xs:time</code>, <code>xs:gYear</code>, <code>xs:gYearMonth</code>, <code>xs:gMonth</code>, <code>xs:gMonthDay</code>, or <code>xs:gDay</code>.
    </phrase>
                        <phrase diff="add" at="bug29362">
                           <code>op:same-key(K1, K2)</code> returns <code>true</code>, as specified in <xspecref spec="FO31" ref="func-same-key"/> 
                        </phrase>
                     </termdef>

    If two or more entries have the <termref def="dt-same-key">same key value</termref> then a dynamic
    error is raised <errorref class="DY" code="0137" diff="chg" at="2014-02-07"/>.

    <note diff="del" at="bug29903"><p>In some edge cases involving numerics, the <termref def="dt-same-key">same key value</termref> relationship is not transitive.</p></note>
                  </p><p diff="del" at="2015-07-04">If the keys in a map constructor
    contain both date/time values with a timezone and date/time values
    with no timezone, a dynamic error is raised XQDY0139. The term "date/time value" here means an instance
    of any of the types <code>xs:dateTime</code>,
    <code>xs:date</code>, <code>xs:time</code>, <code>xs:gYear</code>,
    <code>xs:gYearMonth</code>, <code>xs:gMonth</code>,
    <code>xs:gMonthDay</code>, or <code>xs:gDay</code>.

    <note diff="del" at="2015-07-04"><p>The reason for this rule is that comparison of a
    date/time value with timezone to one without timezone depends on
    knowing the implicit timezone. If values with timezones and values
    without timezones could be mixed in the same map, such a map could
    become invalid when the implicit timezone changes. The rule
    therefore ensures that the constraint that no two entries have the
    same key applies regardless what timezone is used for the
    assessment. Without this rule, for example, a map created in a
    static variable could be invalid during stylesheet execution,
    since the implicit timezone used during the analysis phase can
    differ from that used during evaluation.</p></note>
                  </p><p>Example:</p><p>The following expression constructs a map with seven entries:</p><eg id="map-weekdays" xml:space="preserve">
map {
  "Su" : "Sunday",
  "Mo" : "Monday",
  "Tu" : "Tuesday",
  "We" : "Wednesday",
  "Th" : "Thursday",
  "Fr" : "Friday",
  "Sa" : "Saturday"
}</eg><p diff="add" at="2014-02-07">Maps can nest, and can contain any XDM value. Here is an example of a nested map with values that can be string values, numeric values, or arrays:</p><eg diff="add" at="2014-02-07" id="map-book" xml:space="preserve">
map {
    "book": map {
        "title": "Data on the Web",
        "year": 2000,
        "author": [
            map {
                "last": "Abiteboul",
                "first": "Serge"
            },
            map {
                "last": "Buneman",
                "first": "Peter"
            },
            map {
                "last": "Suciu",
                "first": "Dan"
            }
        ],
        "publisher": "Morgan Kaufmann Publishers",
        "price": 39.95
    }
}
    </eg><note diff="del" at="2014-08-25"><p>Unlike the <function>map:new</function>
    function, the number of entries in a map that is
    constructed using a map expression is known
    statically.</p></note></div4><div4 id="id-map-lookup" diff="add" at="2014-07-13"><head>Map Lookup using Function Call Syntax</head><p>Maps are functions, and function calls can be used to look up
    the value associated with a key in a map.

    <phrase diff="add" at="bug29683">
    If <code>$map</code> is a map and <code>$key</code> is a key,
    then <code>$map($key)</code> is equivalent to <code>map:get($map, $key)</code>.
    The semantics of such a function call are formally defined in
    <xspecref spec="FO31" ref="func-map-get"/>.
    </phrase>
                     <phrase diff="del" at="bug29683">
    The parameter to a map
    function specifies the key, and the function returns the
    associated value.</phrase>
                  </p><p>Examples:</p><ulist><item><p>
                           <code>$weekdays("Su")</code> returns the <termref def="dt-associated-value">associated value</termref> of the key <code>Su</code>.</p></item><item><p>
                           <code>$books("Green Eggs and Ham")</code> returns  <termref def="dt-associated-value">associated value</termref>  of the key <code>Green Eggs and Ham</code>.</p></item></ulist><note><p>XPath 3.1 also provides an alternate syntax for map and
      array lookup that is more terse, supports wildcards, and allows lookup to
      iterate over a sequence of maps or arrays. See <specref ref="id-lookup"/> for details.</p></note><p>Map lookups can be chained.</p><p>Examples: (These examples assume that <code>$b</code> is bound to the books map from the previous section)</p><ulist><item><p>The expression <code>$b("book")("title")</code> returns the string <code>Data on the Web</code>.</p></item><item><p>The expression <code>$b("book")("author")</code> returns the array of authors.</p></item><item><p>The expression <code>$b("book")("author")(1)("last")</code> returns the string <code>Abiteboul</code>.</p><p>(This example combines <specref ref="id-array-lookup"/> with map lookups.)</p></item></ulist></div4><div4 id="id-map-lookup-deleted" diff="del" at="2014-07-13"><head>Map Lookup</head><p>Values in a map can be looked up using function call syntax,
    the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Lookup" xlink:type="simple">Lookup</nt> operator 
    (a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-PostfixExpr" xlink:type="simple">PostfixExpr</nt>),
    or the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-UnaryLookup" xlink:type="simple">UnaryLookup</nt> operator 
    (a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-PrimaryExpr" xlink:type="simple">PrimaryExp</nt>).
    </p><eg xml:space="preserve">
[128] PrimaryExpr ::=  ...  | UnaryLookup
[177] UnaryLookup ::=  "?" KeySpecifier
[chg] KeySpecifier ::=   NCName | IntegerLiteral | ParenthesizedExpr | "*"
  </eg><p>Maps are functions, and function call syntax can be used to look up the value associated with a key in a map.</p><p>Examples:</p><ulist><item><p>
                           <code>$weekdays("Su")</code> returns the <termref def="dt-associated-value">associated value</termref> of the key <code>Su</code>.</p></item><item><p>
                           <code>$books("Green Eggs &amp; Ham")</code> returns  <termref def="dt-associated-value">associated value</termref>  of the key <code>Green Eggs &amp; Ham</code>.</p></item></ulist><p>Map lookups can be chained.</p><p>Examples: (These examples assume that <code>$b</code> is bound to the books map from the previous section)</p><ulist><item><p>The expression <code>$b("book")("title")</code> returns the string <code>Data on the Web</code>.</p></item><item><p>The expression <code>$b("book")("author")</code> returns the array of authors.</p></item><item><p>The expression <code>$b("book")("author")(1)("last")</code> returns the string <code>Abiteboul</code>.</p><p>(This example combines an <specref ref="id-array-lookup"/> with map lookups.)</p></item></ulist><p>XPath 3.1 also provides the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Lookup" xlink:type="simple">Lookup</nt>
    and <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-UnaryLookup" xlink:type="simple">UnaryLookup</nt> operators for
    convenience. When the expression on the left of the postfix map
    lookup operator evaluates to a single map, it is equivalent to the
    function call syntax.
    </p><p>Examples:</p><ulist><item><p>The expression <code>$b?book?title</code> is equivalent to <code>$b("book")("title")</code>.</p></item><item><p>The expression <code>$b?book?author(1)?last</code> is equivalent to <code>$b("book")("author")(1)("last")</code>.</p><p>(The map lookup operator cannot be used to look up values in arrays.)</p></item></ulist><p>A <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-KeySpecifier" xlink:type="simple">KeySpecifier</nt> can be a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-StringLiteral" xlink:type="simple">StringLiteral</nt>, so that an expression can
    to specify a key that contains any string character. A <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-KeySpecifier" xlink:type="simple">KeySpecifier</nt> can be a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ParenthesizedExpr" xlink:type="simple">ParenthesizedExpr</nt>, so that an expression can
    be computed dynamically.</p><p>Examples:</p><ulist><item><p>The expression <code>$books?"Green Eggs &amp; Ham"</code> is equivalent to <code>$books("Green Eggs &amp; Ham")</code>.</p></item><item><p>The expression <code>$books?(concat("Greek Eggs ","&amp; Ham"))</code> is equivalent to  <code>$books?"Green Eggs &amp; Ham"</code>.</p></item></ulist><p>If the expression on the left of the posfix map lookup operator
    evaluates to an array of maps or a sequence of maps, it performs
    implicit mapping.
   
    <code>$sequence-of-maps?key</code> is equivalent to
    <code>$sequence-of-maps ! .("key")</code>.

    <code>$array-of-maps?key</code> is equivalent to
    <code diff="del" at="2014-08-20">$array-of-maps=&gt;seq() ! .("key")</code>
                     <code diff="add" at="2014-08-20">$array-of-maps?* ! .("key")</code>.

    If the expression on the left of the postfix map lookup operator
    is not a map, a sequence of maps, or an array of maps, 
    a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.
    </p><p>Examples:</p><ulist><item><p>The following expression returns  the sequence <code>( "W0342", "M0535")</code>.</p><eg xml:space="preserve">let $maps := ( map { "id" : "W0342" }, map { "id" : "M0535" } )
return $maps?id</eg></item><item><p>The following expression returns  the sequence <code>( "W0342", "M0535")</code>.</p><eg xml:space="preserve">let $maps := [ map { "id" : "W0342" }, map { "id" : "M0535" } ]
return $maps?id</eg></item><item><p>
                           <code>"W0342"?id</code> raises a type error.</p></item></ulist><p>The unary form operates on the context item, and is typically
    used in predicates. The expression <code>expr[ ?key ]</code> is
    equivalent to the expression <code>expr[ .("key") ]</code>.

    If the context item is an array of maps, the unary map lookup
    operator performs implicit mapping.

    If the expression on the left of the postfix map lookup operator
    is not a map or an array of maps, 
    a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.
    </p><p>Examples:</p><ulist><item><p>The following expression returns the map <code>{ "id" : "W0342" }</code>.</p><eg xml:space="preserve">let $maps := ( map { "id" : "W0342" }, map { "id" : "M0535" })
return $maps[ ?id = "W0342" ]</eg></item><item><p>The following expression returns the string <code>What were you thinking?</code>
                        </p><eg xml:space="preserve">
let $errors := ( 
      map { "level" : 1, "text" : "Boys will be boys ..." },
      map { "level" : 2, "text" : "What were you thinking?" },
      map { "level" : 3, "text" : "Call the cops!" }
    )
return $errors[?level = 2]?text</eg></item></ulist></div4></div3><div3 id="id-arrays"><head>Arrays</head><p/><div4 id="id-array-constructors"><head>Array Constructors</head><p>
                     <termdef id="dt-array" term="array">An <term>array</term> is
      a <phrase diff="chg" at="2014-02-07">function</phrase> that associates a set of positions, represented as
      positive integer keys, with values.</termdef> 
                     <phrase diff="add" at="2014-02-07">The first position
      in an array is associated with the integer 1.</phrase>
                     <termdef id="dt-member" term="member">The values of an array are called
      its <term>members</term>.</termdef>

      In the type hierarchy, array has a distinct type, which is
      derived from function.
      <phrase diff="add" at="2014-08-25">Atomization converts arrays to sequences (see <termref def="dt-atomization">Atomization</termref>).</phrase>  
                  </p><p>An array is created using an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ArrayConstructor" xlink:type="simple">ArrayConstructor</nt>.</p><scrap diff="chg" at="2014-02-07" headstyle="show"><head/><prod num="73" id="doc-xpath31-ArrayConstructor"><lhs>ArrayConstructor</lhs><rhs>
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SquareArrayConstructor" xlink:type="simple">SquareArrayConstructor</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-CurlyArrayConstructor" xlink:type="simple">CurlyArrayConstructor</nt>
                        </rhs></prod><prod num="74" id="doc-xpath31-SquareArrayConstructor"><lhs>SquareArrayConstructor</lhs><rhs>"["  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>)*)?  "]"</rhs></prod><prod num="75" id="doc-xpath31-CurlyArrayConstructor"><lhs>CurlyArrayConstructor</lhs><rhs>"array"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-EnclosedExpr" xlink:type="simple">EnclosedExpr</nt>
                        </rhs></prod></scrap><p>
                     <phrase diff="add" at="2014-12-05">If a member of an array is a
      node, its node identity is preserved.</phrase>

                     <note diff="del" at="bug28900"><p>XPath 3.1 has no operators
      that can distinguish a map or array from another map or array with
      the same values.  Future versions of the XQuery Update Facility,
      on the other hand, will expose this difference, and need to be
      clear about the data model instance that is constructed.</p><p>In some existing implementations that support updates via
      proprietary extensions, if a member expression evaluates to a
      map or array, the member is a new map or array with the same
      values.</p></note>

                     <phrase diff="add" at="2014-11-11">In both forms of an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ArrayConstructor" xlink:type="simple">ArrayConstructor</nt>, if a member
        expression evaluates to a node, the associated value is the
        node itself, not a new node with the same values.  If the
        member expression evaluates to a map or array, the associated
        value is a new map or array with the same values.</phrase>

                     <note diff="del" at="bug28900"><p>XPath 3.1 has no operators that can distinguish a map or
        array from another map or array with the same values.  However, we
        need to be clear about the data model instance that is constructed
        so that future versions of the XQuery Update Facility update the
        instances defined in this specification.</p></note>
                  </p><p diff="del" at="bug28900">The members of a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SquareArrayConstructor" xlink:type="simple">SquareArrayConstructor</nt> can be any value, separated by commas.</p><p diff="add" at="bug28900">A <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SquareArrayConstructor" xlink:type="simple">SquareArrayConstructor</nt> 
      consists of a comma-delimited set of argument expressions. It returns an array in which each member contains the value of the corresponding argument expression.</p><p>Examples:</p><ulist diff="chg" at="2014-02-07"><item><p>
                           <code>[ 1, 2, 5, 7 ]</code> creates an array with four members: <code>1</code>, <code>2</code>, <code>5</code>, and <code>7</code>.</p></item><item><p>
                           <code>[ (), (27, 17, 0)]</code> creates an array with two members: <code>()</code> and the sequence <code>(27, 17, 0)</code>.</p></item><item><p>
                           <code>[ $x, local:items(), &lt;tautology&gt;It is what it is.&lt;/tautology&gt; ]</code> creates an array with three members: the value of $x, the result of evaluating the function call, and a tautology element.</p></item></ulist><p diff="chg" at="2014-02-07">A <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-CurlyArrayConstructor" xlink:type="simple">CurlyArrayConstructor</nt>
      can use any <phrase diff="del" at="bug29143">XQuery</phrase> expression to create its members.  It
      evaluates its operand expression to obtain a sequence of items
      and creates an array with these items as members.  Unlike a
      SquareArrayConstructor, a comma in a CurlyArrayConstructor is
      the <phrase diff="del" at="bug29143">XQuery</phrase> 
                     <termref def="dt-comma-operator">comma operator</termref>, not a delimiter.
      </p><p>Examples:</p><ulist diff="chg" at="2014-02-07"><item><p>
                           <code>array { $x }</code> creates an array with one member for each item <phrase diff="add" at="2014-08-20">in the sequence</phrase> to which $x is bound.</p></item><item><p>
                           <code>array { local:items() }</code> creates an array with one member for each item  <phrase diff="add" at="2014-08-20">in the sequence</phrase> to which <code>local:items()</code> evaluates.</p></item><item><p>
                           <code>array { 1, 2, 5, 7 }</code> creates an array with four members: <code>1</code>, <code>2</code>, <code>5</code>, and <code>7</code>.</p></item><item><p>
                           <code>array { (), (27, 17, 0) }</code> creates an array with three members: <code>27</code>, <code>17</code>, and <code>0</code>.</p></item><item><p>
                           <code>array{ $x, local:items(), &lt;tautology&gt;It is what it is.&lt;/tautology&gt; }</code> creates an array with the following members: the items to which <code>$x</code> is bound, followed by the items to which <code>local:items()</code> evaluates, followed by a tautology element.</p></item></ulist><note diff="chg" at="2014-02-07"><p>XPath 3.1 does not provide explicit support for sparse arrays. Use integer-valued maps to represent sparse arrays, e.g. <code>map { 27 : -1, 153 : 17 } </code>.</p></note></div4><div4 id="id-array-lookup" diff="add" at="2014-07-13"><head>Array Lookup using Function Call Syntax</head><p>Arrays are functions, and function calls can be used to look up
    the value associated with <phrase diff="chg" at="bug29683">position</phrase> in an array.

    <phrase diff="del" at="bug29683">
    The key must be 
    <phrase diff="del" at="2014-08-20">a  positive</phrase> 
                        <phrase diff="add" at="2014-08-20">an</phrase> 
    integer value <errorref class="TY" code="0004"/>.
    </phrase>

                     <phrase diff="add" at="bug29683">
    If <code>$array</code> is an array and <code>$index</code> is an integer corresponding to a position in the array,
    then <code>$array($key)</code> is equivalent to <code>array:get($array, $key)</code>.
    The semantics of such a function call are formally defined in
    <xspecref spec="FO31" ref="func-array-get"/>.
    </phrase>
                     <phrase diff="del" at="bug29683">
    The parameter to an
    array function specifies the key, and the function returns the
    associated value. 

    If position <code>n</code> does not exist in the array, a
    <phrase diff="del" at="2014-12-14">a dynamic error is raised [err:XPDY0138].</phrase>
                        <phrase diff="add" at="2014-12-14">
                           <termref def="dt-dynamic-error">dynamic error</termref>  is raised <xerrorref spec="FO31" class="AY" code="0001"/>
                        </phrase>.</phrase>
                  </p><p>Examples:</p><ulist diff="chg" at="2014-02-07"><item><p>
                           <code>[ 1, 2, 5, 7 ](4)</code> evaluates to <code>7</code>.</p></item><item><p>
                           <code>[ [1, 2, 3], [4, 5, 6]](2)</code> evaluates to <code>[4, 5, 6]</code>.</p></item><item><p>
                           <code>[ [1, 2, 3], [4, 5, 6]](2)(2)</code> evaluates to <code>5</code>.</p></item><item><p>
                           <code>[ 'a', 123, &lt;name&gt;Robert Johnson&lt;/name&gt; ](3)</code> evaluates to <code>&lt;name&gt;Robert Johnson&lt;/name&gt;</code>.</p></item><item><p>
                           <code>array { (), (27, 17, 0) }(1)</code> evaluates to <code diff="del" at="2014-08-20">()</code> 
                           <code diff="add" at="2014-08-20">27</code>.</p></item><item><p>
                           <code>array { (), (27, 17, 0) }(2)</code> evaluates to <code diff="del" at="2014-08-20">(27, 17, 0)</code> 
                           <code diff="add" at="2014-08-20">17</code>.</p></item><item><p>
                           <code>array { "licorice", "ginger" }(20)</code> raises a dynamic error <xerrorref spec="FO31" class="AY" code="0001"/>.</p></item></ulist><note><p>XPath 3.1 also provides an alternate syntax for map and
      array lookup that is more terse, supports wildcards, and allows
      lookup to iterate over a sequence of maps or arrays. See
      <specref ref="id-lookup"/> for details.</p></note></div4><div4 id="id-array-lookup-deleted" diff="del" at="2014-07-13"><head>Array Lookup</head><p>Arrays are functions in XPath 3.1, and the function call
      <code>$a(n)</code> returns the value associated with position
      <code>n</code>, which must be a positive integer value <errorref class="TY" code="0004"/>.
      If position <code>n</code> does not exist in the array, 
      <phrase diff="del" at="2014-12-14">a dynamic error is raised [err:XPDY0138].</phrase>
                     <phrase diff="add" at="2014-12-14">
                        <termref def="dt-dynamic-error">dynamic error</termref>  is raised <xerrorref spec="FO31" class="AY" code="0001"/>
                     </phrase>.
      </p><p>Examples:</p><ulist diff="chg" at="2014-02-07"><item><p>
                           <code>[ 1, 2, 5, 7 ](4)</code> evaluates to <code>7</code>.</p></item><item><p>
                           <code>[ 'a', 123, &lt;name&gt;Robert Johnson&lt;/name&gt; ](3)</code> evaluates to <code>&lt;name&gt;Robert Johnson&lt;/name&gt;</code>.</p></item><item><p>
                           <code>[ [1, 2, 3], [4, 5, 6]](2)</code> evaluates to <code>[4, 5, 6]</code>.</p></item><item><p>
                           <code>array { (), (27, 17, 0) }(1)</code> evaluates to <code>()</code>.</p></item><item><p>
                           <code>array { (), (27, 17, 0) }(2)</code> evaluates to <code>(27, 17, 0)</code>.</p></item><item><p>
                           <code>array { "licorice", "ginger" }(20)</code> raises a dynamic error <xerrorref spec="FO31" class="AY" code="0001"/>.</p></item></ulist></div4><div4 id="id-conv-arr2seq" diff="del" at="2014-08-20"><head>Converting Arrays to Sequences</head><p>If <code>$a</code> is an array, <code>fn:seq($a)</code>
      returns a sequence constructed by concatenating the members of
      the array, in order, using the comma operator. The semantics of
      this function are formally defined in Section 17.3.12 ay:seq [FO31].</p><!-- The preceding xspecref points to a section in F+O 3.1 that has also been deleted. 
Because this div4 is marked diff=del, this is not a problem, so the build error
can be ignored. --><note><p>It is often convenient to use the <termref def="dt-arrow-operator">arrow operator</termref> to call
      <code>fn:seq()</code>.  The following expressions are
      equivalent.</p><ulist><item><p>
                              <code>$a=&gt;seq()</code>
                           </p></item><item><p>
                              <code>seq($a)</code>
                           </p></item></ulist></note><p>If every member of the array contains exactly one item, the above expressions evaluate to the same result as <code>$a[7]</code>, but if a  member contains a null sequence or a sequence with multiple items, this is no longer true.  Consider the following examples.</p><ulist diff="chg" at="2014-02-07"><item><p>
                           <code>[ (), (), 1, (2, 3, 4)](1)</code> evaluates to (), the value of the first array member.</p></item><item><p>
                           <code>[ (), (), 1, (2, 3, 4)]=&gt;seq()[1]</code> evaluates to 1, the first item in the sequence created by concatenating the values of the array.</p></item><item><p>
                           <code>[ (), (), 1, (2, 3, 4)](4)</code> evaluates to <code>(2, 3, 4)</code>, the value of the fourth member in the array.</p></item><item><p>
                           <code>[ (), (), 1, (2, 3, 4)]=&gt;seq()[4]</code> evaluates to <code>4</code>, the value of the fourth item in the sequence created by concatenating the values of the array.</p></item></ulist></div4></div3><div3 id="id-lookup"><head>The Lookup Operator ("?") for Maps and Arrays</head><p>XPath 3.1 provides a lookup operator for maps and arrays that is
  more convenient for some common cases. It provides a terse syntax
  for simple strings as keys in maps or integers as keys in arrays,
  supports wildcards, and iterates over sequences of maps and
  arrays.</p><div4 id="id-unary-lookup"><head>Unary Lookup</head><scrap headstyle="show"><head/><prod num="76" id="doc-xpath31-UnaryLookup"><lhs>UnaryLookup</lhs><rhs>"?"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-KeySpecifier" xlink:type="simple">KeySpecifier</nt>
                        </rhs></prod><prod num="54" id="doc-xpath31-KeySpecifier"><lhs>KeySpecifier</lhs><rhs>
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-NCName" xlink:type="simple">NCName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-IntegerLiteral" xlink:type="simple">IntegerLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ParenthesizedExpr" xlink:type="simple">ParenthesizedExpr</nt>  |  "*"</rhs></prod></scrap><p>Unary lookup is used in predicates (e.g. <code>$map[?name='Mike']</code> or with the <phrase diff="chg" at="2015-07-08">simple map operator</phrase> (e.g. <code>$maps ! ?name='Mike'</code>). See <specref ref="id-postfix-lookup"/> for the postfix lookup operator.</p><p>UnaryLookup returns a sequence of values selected from the
  context item, which must be a map or array. If the context item is
  not a map or an array, <phrase diff="chg" at="2014-12-14">a
  <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.
  </phrase>
                  </p><p diff="chg" at="bug28901">If the context item is a map:</p><olist diff="chg" at="bug28901"><item><p>If the  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-KeySpecifier" xlink:type="simple">KeySpecifier</nt>  is an <code>NCName</code>, the  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-UnaryLookup" xlink:type="simple">UnaryLookup</nt> operator is equivalent to <code>.(KS)</code>, where <code>KS</code> is the value of the <code>NCName</code>.</p></item><item><p>If the   <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-KeySpecifier" xlink:type="simple">KeySpecifier</nt>  is an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-IntegerLiteral" xlink:type="simple">IntegerLiteral</nt>,  the  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-UnaryLookup" xlink:type="simple">UnaryLookup</nt> operator is equivalent to <code>.(KS)</code>, where <code>KS</code> is the value of the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-IntegerLiteral" xlink:type="simple">IntegerLiteral</nt>.</p></item><item><p>If the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-KeySpecifier" xlink:type="simple">KeySpecifier</nt> is a  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ParenthesizedExpr" xlink:type="simple">ParenthesizedExpr</nt>,  the  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-UnaryLookup" xlink:type="simple">UnaryLookup</nt> operator is equivalent to the following expression,  where <code>KS</code> is the value of the  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ParenthesizedExpr" xlink:type="simple">ParenthesizedExpr</nt>:</p><eg diff="del" at="bug29622" xml:space="preserve">
for $k in KS
return .($k)
</eg><eg diff="add" at="bug29622" xml:space="preserve">
for $k in fn:data(KS)
return .($k)  
</eg></item><item><p>If the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-KeySpecifier" xlink:type="simple">KeySpecifier</nt> is a wildcard ("<code>*</code>"), the  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-UnaryLookup" xlink:type="simple">UnaryLookup</nt> operator is equivalent to the following expression:</p><eg xml:space="preserve">
for $k in map:keys(.)
return .($k)
</eg><note><p>The order of keys in map:keys() is implementation-dependent, so
  the order of values in the result sequence is also
  implementation-dependent.</p></note></item></olist><p diff="chg" at="bug28901">If the context item is an array:</p><olist diff="chg" at="bug28901"><item><p>If the  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-KeySpecifier" xlink:type="simple">KeySpecifier</nt>  is an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-IntegerLiteral" xlink:type="simple">IntegerLiteral</nt>,  the  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-UnaryLookup" xlink:type="simple">UnaryLookup</nt> operator is equivalent to <code>.(KS)</code>, where <code>KS</code> is the value of the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-IntegerLiteral" xlink:type="simple">IntegerLiteral</nt>.</p></item><item><p>If the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-KeySpecifier" xlink:type="simple">KeySpecifier</nt> is an <code>NCName</code>, the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-UnaryLookup" xlink:type="simple">UnaryLookup</nt> operator raises a type error <errorref class="TY" code="0004"/>.</p></item><item><p>If the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-KeySpecifier" xlink:type="simple">KeySpecifier</nt> is a  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ParenthesizedExpr" xlink:type="simple">ParenthesizedExpr</nt>,  the  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-UnaryLookup" xlink:type="simple">UnaryLookup</nt> operator is equivalent to the following expression,  where <code>KS</code> is the value of the  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ParenthesizedExpr" xlink:type="simple">ParenthesizedExpr</nt>:</p><eg diff="del" at="bug29622" xml:space="preserve">
for $k in KS
return .($k)
</eg><eg diff="add" at="bug29622" xml:space="preserve">
for $k in fn:data(KS)
return .($k)  
</eg></item><item><p>If the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-KeySpecifier" xlink:type="simple">KeySpecifier</nt> is a wildcard ("<code>*</code>"), the  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-UnaryLookup" xlink:type="simple">UnaryLookup</nt> operator is equivalent to the following expression:</p><eg xml:space="preserve">
for $k in 1 to array:size(.)
return .($k)
</eg><note><p>
                              <phrase diff="del" at="bug29487">This is also equivalent to <xspecref spec="FO31" ref="func-array-flatten"/>. </phrase>Note that array items are returned in order.</p></note></item></olist><p>Examples:</p><ulist><item><p>
                           <code>?name</code> is equivalent to <code>.("name")</code>, an appropriate lookup for a map.</p></item><item><p>
                           <code>?2</code> is equivalent to <code>.(2)</code>, an appropriate lookup for an array or an integer-valued map.</p></item><item><p>
                           <code>?($a)</code> is equivalent to <code>for $k in $a return .($k)</code>, allowing keys for an array or map to be passed using a variable.</p></item><item><p>
                           <code>?(2 to 4)</code> is equivalent to <code>for $k in (2,3,4) return .($k)</code>, a convenient way to return a range of values from an array.</p></item><item><p diff="add" at="2014-12-14">
                           <code>?(3.5)</code> raises a type error <phrase diff="add" at="bug28699">if the context item is an array</phrase> because the parameter must be an integer.</p></item><item><p diff="add" at="2014-12-14">
                           <code>([1,2,3], [1,2,5], [1,2])[?3 = 5]</code> raises an error because <code>?3</code> on one of the
    items in the sequence fails.</p></item><item><p>If <code>$m</code> is bound to the weekdays map described in <specref ref="id-maps"/>, then <code>$m?*</code> returns the values <code>("Sunday","Monday","Tuesday","Wednesday", "Thursday", "Friday","Saturday")</code>, in <termref def="dt-implementation-dependent">implementation-dependent</termref> order.</p></item><item><p>
                           <code>[1, 2, 5, 7]?*</code> evaluates to <code>(1, 2, 5, 7)</code>.</p></item><item><p>
                           <code>[[1, 2, 3], [4, 5, 6]]?*</code> evaluates to <code>([1, 2, 3], [4, 5, 6])</code>
                        </p></item></ulist></div4><div4 id="id-postfix-lookup"><head>Postfix Lookup</head><scrap headstyle="show"><head/><prod num="53" id="doc-xpath31-Lookup"><lhs>Lookup</lhs><rhs>"?"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-KeySpecifier" xlink:type="simple">KeySpecifier</nt>
                        </rhs></prod></scrap><p diff="add" at="bug27536">
      The semantics of a Postfix Lookup expression depend on the form of the KeySpecifier, as follows:
      <ulist><item><p>If the <code>KeySpecifier</code> is an <code>NCName</code>, <code>IntegerLiteral</code>, or <code>Wildcard</code> ("<code>*</code>"), then the expression <code>E?S</code> is equivalent to <code>E!?S</code>. (That is, the semantics of the postfix lookup operator are defined in terms of the unary lookup operator).</p></item><item><p>If the <code>KeySpecifier</code> is a <code>ParenthesizedExpr</code>, then the expression <code>E?(S)</code> is equivalent to</p><eg diff="del" at="bug29622" xml:space="preserve">for $e in E, $s in S return $e($s)</eg><eg diff="add" at="bug29622" xml:space="preserve">for $e in E, $s in fn:data(S) return $e($s)</eg><note><p>The focus for evaluating <code>S</code> is the same as the focus for the <code>Lookup</code> expression itself.</p></note></item></ulist>
                  </p><p diff="del" at="bug27536">The semantics of <code>E?S</code> are equivalent to <phrase diff="chg" at="2014-12-14">
                        <code>for $a in E, $b in S return $a($b)</code>
                     </phrase>, where <code>E</code> is an expression on the left of the postfix <code>?</code> operator and <code>?S</code> is the unary lookup operator described in <specref ref="id-unary-lookup"/>.</p><p>Examples:</p><ulist><item><p>
                           <code>map { "first" : "Jenna", "last" : "Scott" }?first</code> evaluates to <code>"Jenna"</code>
                        </p></item><item><p>
                           <code>[4, 5, 6]?2</code> evaluates to <code>5</code>.</p></item><item><p>
                           <code>(map {"first": "Tom"}, map {"first": "Dick"}, map {"first": "Harry"})?first</code> evaluates to the sequence <code>("Tom", "Dick", "Harry")</code>
                           <phrase diff="del">, in implementation-defined order</phrase>.</p></item><item><p>
                           <code>([1,2,3], [4,5,6])?2</code> evaluates to the sequence <code>(2, 5)</code>.</p></item><item><p>
                           <code>["a","b"]?3</code> raises a dynamic error <xerrorref spec="FO31" class="AY" code="0001"/>
                        </p></item></ulist></div4></div3></div2><div2 id="id-conditionals"><head>Conditional Expressions</head><p>XPath 3.1 supports a conditional expression based on the keywords <code>if</code>, <code>then</code>, and <code>else</code>.</p><scrap headstyle="show"><head/><prod num="15" id="doc-xpath31-IfExpr"><lhs>IfExpr</lhs><rhs>"if"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Expr" xlink:type="simple">Expr</nt>  ")"  "then"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>  "else"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>
                  </rhs></prod></scrap><p>The expression following the <code>if</code> keyword is called the <term>test expression</term>, and the expressions
following the <code>then</code> and <code>else</code> keywords are called the <term>then-expression</term> and <term>else-expression</term>, respectively.</p><p>The first step in processing a conditional expression is to find
the <termref def="dt-ebv">effective boolean value</termref> of the test expression, as defined in <specref ref="id-ebv"/>.</p><p>The value of a conditional expression is defined as follows: If the
effective boolean value of the test expression is <code>true</code>, the value of the then-expression is returned. If the
effective boolean value of the test expression is <code>false</code>,
the value of the else-expression is returned.</p><p>Conditional expressions have a special rule for propagating <termref def="dt-dynamic-error">dynamic errors</termref>. If the effective value of the test expression is <code>true</code>, the conditional expression ignores (does not raise) any dynamic errors encountered in the else-expression. In this case, since the else-expression can have no observable effect, it need not be evaluated. Similarly, if the effective value of the test expression is <code>false</code>, the conditional expression ignores any <termref def="dt-dynamic-error">dynamic errors</termref> encountered in the then-expression, and the then-expression need not be evaluated.</p><p>Here are some examples of conditional expressions:</p><ulist><item><p>In this example, the test expression is a comparison expression:</p><eg role="parse-test" xml:space="preserve">if ($widget1/unit-cost &lt; $widget2/unit-cost)
  then $widget1
  else $widget2</eg></item><item><p>In this example, the test expression tests for the existence of an attribute
named <code>discounted</code>, independently of its value:</p><eg role="parse-test" xml:space="preserve">if ($part/@discounted)
  then $part/wholesale
  else $part/retail</eg></item></ulist></div2><div2 id="id-quantified-expressions"><head>Quantified Expressions</head><p>Quantified expressions support existential and universal quantification. The
value of a quantified expression is always <code>true</code> or <code>false</code>.</p><scrap headstyle="show"><head/><prod num="14" id="doc-xpath31-QuantifiedExpr"><lhs>QuantifiedExpr</lhs><rhs>("some"  |  "every")  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-VarName" xlink:type="simple">VarName</nt>  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-VarName" xlink:type="simple">VarName</nt>  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>)*  "satisfies"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>
                  </rhs></prod></scrap><p>A <term>quantified expression</term> begins with
a <term>quantifier</term>, which is the keyword <code>some</code> or <code>every</code>, followed by one or more in-clauses that are used to bind variables,
followed by the keyword <code>satisfies</code> and a test expression. Each in-clause associates a variable with an
expression that returns a sequence of items, called the binding sequence for that variable. The in-clauses generate tuples of variable bindings, including a tuple for each combination of items in the binding sequences of the respective variables. Conceptually, the test expression is evaluated for each
tuple of variable bindings. Results depend on the <termref def="dt-ebv">effective boolean value</termref> of the test expressions, as defined in <specref ref="id-ebv"/>. The value of the quantified expression is defined
by the following rules:</p><olist><item><p>If the quantifier is <code>some</code>, the quantified expression is <code>true</code> if at least one evaluation of the test expression has the <termref def="dt-ebv">effective boolean value</termref> 
                     <code>true</code>; otherwise the quantified expression is <code>false</code>. This rule implies that, if the in-clauses generate zero binding
tuples, the value of the quantified expression is <code>false</code>.</p></item><item><p>If the quantifier is <code>every</code>, the quantified expression is <code>true</code> if every evaluation of the test expression has the <termref def="dt-ebv">effective boolean value</termref> 
                     <code>true</code>; otherwise the quantified expression is <code>false</code>. This rule implies that, if the in-clauses generate zero binding
tuples, the value of the quantified
expression is <code>true</code>.</p></item></olist><p>The scope of a variable bound in a quantified expression comprises all
subexpressions of the quantified expression that appear after the variable binding. The scope does not include the expression to which the variable is bound.
</p><p>The order in which test expressions are evaluated for the various binding
tuples is <termref def="dt-implementation-dependent">implementation-dependent</termref>. If the quantifier
is <code>some</code>, an implementation may
return <code>true</code> as soon as it finds one binding tuple for which the test expression has
an <termref def="dt-ebv">effective boolean value</termref> of <code>true</code>, and it may raise a <termref def="dt-dynamic-error">dynamic error</termref> as soon as it finds one binding tuple for
which the test expression raises an error. Similarly, if the quantifier is <code>every</code>, an implementation may return <code>false</code> as soon as it finds one binding tuple for which the test expression has
an <termref def="dt-ebv">effective boolean value</termref> of <code>false</code>, and it may raise a <termref def="dt-dynamic-error">dynamic error</termref> as soon as it finds one binding tuple for
which the test expression raises an error. As a result of these rules, the
value of a quantified expression is not deterministic in the presence of
errors, as illustrated in the examples below.</p><p>Here are some examples of quantified expressions:</p><ulist><item><p>This expression is <code>true</code> if every <code>part</code> element has a <code>discounted</code> attribute (regardless of the values of these attributes):</p><eg role="parse-test" xml:space="preserve">every $part in /parts/part satisfies $part/@discounted</eg></item><item><p>This expression is <code>true</code> if at least
one <code>employee</code> element satisfies the given comparison expression:</p><eg role="parse-test" xml:space="preserve">some $emp in /emps/employee satisfies
     ($emp/bonus &gt; 0.25 * $emp/salary)</eg></item><item><p>In the following examples, each quantified expression evaluates its test
expression over nine tuples of variable bindings, formed from the Cartesian
product of the sequences <code>(1, 2, 3)</code> and <code>(2, 3, 4)</code>. The expression beginning with <code>some</code> evaluates to <code>true</code>, and the expression beginning with <code>every</code> evaluates to <code>false</code>.</p><eg role="parse-test" xml:space="preserve">some $x in (1, 2, 3), $y in (2, 3, 4)
satisfies $x + $y = 4</eg><eg role="parse-test" xml:space="preserve">every $x in (1, 2, 3), $y in (2, 3, 4)
satisfies $x + $y = 4</eg></item><item><p>This quantified expression may either return  <code>true</code> or raise a <termref def="dt-type-error">type error</termref>, since its test expression returns <code>true</code> for one variable binding
and raises a <termref def="dt-type-error">type error</termref> for another:</p><eg role="parse-test" xml:space="preserve">some $x in (1, 2, "cat") satisfies $x * 2 = 4</eg></item><item><p>This quantified expression may either return <code>false</code> or raise a <termref def="dt-type-error">type error</termref>, since its test expression returns <code>false</code> for one variable binding and raises a <termref def="dt-type-error">type error</termref> for another:</p><eg role="parse-test" xml:space="preserve">every $x in (1, 2, "cat") satisfies $x * 2 = 4</eg></item></ulist></div2><div2 id="id-expressions-on-datatypes"><head>Expressions on SequenceTypes</head><p diff="chg" at="bug29903">
The <code>instance
of</code>, <code>cast</code>, <code>castable</code>,
and <code>treat</code> expressions are used to test whether a value
conforms to a given type or to convert it to an instance of a given
type.
</p><div3 id="id-instance-of"><head>Instance Of</head><scrap headstyle="show"><head/><prod num="25" id="doc-xpath31-InstanceofExpr"><lhs>InstanceofExpr</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TreatExpr" xlink:type="simple">TreatExpr</nt> ( "instance"  "of"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SequenceType" xlink:type="simple">SequenceType</nt> )?</rhs></prod></scrap><p>The boolean
operator <code>instance of</code>
returns <code>true</code> if the value of its first operand matches
the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SequenceType" xlink:type="simple">SequenceType</nt> in its second
operand, according to the rules for <termref def="dt-sequencetype-matching">SequenceType
matching</termref>; otherwise it returns <code>false</code>. For example:</p><ulist><item><p>
                        <code role="parse-test">5 instance of xs:integer</code>
                     </p><p>This example returns <code>true</code> because the given value is an instance of the given type.</p></item><item><p>
                        <code>5 instance of xs:decimal</code>
                     </p><p>This example returns <code>true</code> because the given value is an integer literal, and <code>xs:integer</code> is derived by restriction from <code>xs:decimal</code>.</p></item><item><p>
                        <code role="parse-test">(5, 6) instance of xs:integer+</code>
                     </p><p>This example returns <code>true</code> because the given sequence contains two integers, and is a valid instance of the specified type.</p></item><item><p>
                        <code role="parse-test">. instance of element()</code>
                     </p><p>This example returns <code>true</code> if the context item is an element node or <code>false</code> if the context item is defined but is not an element node. 
  If the context item is <xtermref spec="DM31" ref="dt-absent"/>, a <termref def="dt-dynamic-error">dynamic error</termref> is raised <errorref class="DY" code="0002"/>.</p></item></ulist></div3><div3 id="id-cast"><head>Cast</head><scrap headstyle="show"><head/><prod num="28" id="doc-xpath31-CastExpr"><lhs>CastExpr</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ArrowExpr" xlink:type="simple">ArrowExpr</nt> ( "cast"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SingleType" xlink:type="simple">SingleType</nt> )?</rhs></prod><prod num="77" id="doc-xpath31-SingleType"><lhs>SingleType</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-SimpleTypeName" xlink:type="simple">SimpleTypeName</nt>  "?"?</rhs></prod></scrap><p>Occasionally
it is necessary to convert a value to a specific datatype. For this
purpose, XPath 3.1 provides a <code>cast</code> expression that
creates a new value of a specific type based on an existing value. A
<code>cast</code> expression takes two operands: an <term>input
expression</term> and a <term>target type</term>. The type of the
atomized value of the input expression is called the <term>input type</term>. 
The SimpleTypeName must be the name of a type defined
in the  <termref def="dt-is-types">in-scope schema types</termref>, and it must be a simple type <errorref class="ST" code="0052"/>.
In addition, the target type cannot be <code>xs:NOTATION</code>, <code>xs:anySimpleType</code>,
or <code>xs:anyAtomicType</code> 
                  <errorref class="ST" code="0080"/>. The optional occurrence indicator "<code>?</code>" denotes that an empty
sequence is permitted. If the target type is a lexical QName that has no namespace prefix, it
is considered to be in the <termref def="dt-def-elemtype-ns">default element/type
namespace</termref>.</p><p>Casting a node to <code>xs:QName</code> can cause surprises because it uses the static context of the cast expression to provide the namespace bindings for this operation. 
Instead of casting to <code>xs:QName</code>, it is generally preferable to use the <code>fn:QName</code> function, which allows the namespace context to be taken from the document containing the QName.</p><p>The semantics of the <code>cast</code> expression
are as follows:</p><olist><item><p>The input expression is evaluated.</p></item><item><p>The result of the first step is <termref def="dt-atomization">atomized</termref>.</p></item><item><p> If the result of atomization is a
sequence of more than one atomic value, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p></item><item><p>If the result
of atomization is an empty sequence:</p><olist><item><p>If
<code>?</code> is specified after the target type, the result of the
<code>cast</code> expression is an empty sequence.</p></item><item><p>
If <code>?</code> is not specified after the target type, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p></item></olist></item><item><p diff="add" at="bug29192">If the result of atomization is a single
atomic value, the result of the cast expression is determined by
casting to the target type as described in <xspecref diff="chg" at="bug28312" spec="FO31" ref="casting"/>. When casting, an
implementation may need to determine whether one type is derived by
restriction from another. An implementation can determine this either
by examining the <termref def="dt-issd">in-scope schema
definitions</termref> or by using an alternative, <termref def="dt-implementation-dependent">implementation-dependent</termref>
mechanism such as a data dictionary.
<phrase diff="add" at="bug29903">
The result of a cast expression is one of the following: 
</phrase>
                        <olist diff="add" at="bug29903"><item><p> 
    A value of the target type (or, in the case of list types,
    a sequence of values that are instances of the item type of the
    list type).
  </p></item><item><p> 
    A type error, if casting from the source type to the
    target type is not supported (for example attempting to convert an
    integer to a date).
  </p></item><item><p> 
    A dynamic error, if the particular input value cannot be
    converted to the target type (for example, attempting to convert
    the string <code>"three"</code> to an integer).
  </p></item></olist>
                     </p><p diff="del" at="bug29192">If the result of atomization is a single atomic value, the result
of the cast expression depends on the input type and the target
type. In general, the cast expression attempts to create a new value
of the target type based on the input value. Only certain combinations
of input type and target type are supported. A summary of the rules
are listed below—the normative definition of these rules is
given in <xspecref diff="chg" at="bug28312" spec="FO31" ref="casting"/>. For the purpose of
these rules, an implementation may determine
that one type is derived by restriction from another type either by examining the <termref def="dt-issd">in-scope schema definitions</termref> or by using an
alternative, <termref def="dt-implementation-dependent">implementation-dependent</termref> mechanism such as a data
dictionary.
</p><olist diff="del" at="bug29192"><item><p>
                              <code>cast</code> is supported for the combinations of
input type and target type listed in <xspecref spec="FO31" ref="casting-from-primitive-to-primitive"/>
                              <phrase diff="add" at="bug28312">, which also defines the semantics of casting for each combination of</phrase>
                              <phrase diff="del" at="bug28312">For each of these combinations, both
the input type and the target type are</phrase> primitive <termref def="dt-schema-type">schema types</termref>. For
example, a value of type <code>xs:string</code> can be cast into the
schema type <code>xs:decimal</code>. For each of these built-in combinations,
the semantics of casting are specified in <xspecref diff="chg" at="bug28312" spec="FO31" ref="casting"/>.</p></item><item><p>
                              <code>cast</code> is
supported if the input type is a non-primitive atomic type that is derived by restriction from the target
type. In this case, the input value
is mapped into the value space of the target type, unchanged except
for its type. For example, if <code>shoesize</code> is derived by
restriction from <code>xs:integer</code>, a value of type
<code>shoesize</code> can be cast into the schema type
<code>xs:integer</code>.</p></item><item><p>
                              <code>cast</code> is supported if the target type is a
     non-primitive atomic type and the input type is
     <code>xs:string</code> or <code>xs:untypedAtomic</code>. The
     input value is first converted to a value in the lexical space of
     the target type by applying the whitespace normalization rules
     for the target type (as defined in <bibref ref="XMLSchema10"/> or <bibref ref="XMLSchema11"/>). The lexical value is then converted to the
     value space of the target type using the schema-defined rules for
     the target type. If the input value fails to satisfy some facet
     of the target type, a <termref def="dt-dynamic-error">dynamic
     error</termref> may be raised as specified in <bibref ref="xpath-functions-31"/>.</p></item><item><p>
                              <code>cast</code> is supported to any target type
     if the input type is <code>xs:string</code> or
     <code>xs:untypedAtomic</code>. The target type may be an atomic
     type, a union type, or a list type. The semantics are based on
     the rules for validation in <bibref ref="XMLSchema10"/> or
     <bibref ref="XMLSchema11"/>.</p><p>The effect of casting a string <var>S</var> to a simple type
     <var>T</var> is the same as constructing an element or attribute
     node whose string value is <var>S</var>, validating it using
     <var>T</var> as the governing type, and atomizing the resulting
     node.

     The result may be a single atomic value or (if list types are
     involved) a sequence of zero or more atomic values. </p><p>If the target type is <termref def="dt-namespace-sensitive">namespace-sensitive</termref>,
     then the namespace  bindings in the static context will be used to resolve any
     namespace prefix found in the supplied string.</p></item><item><p>
                              <code>cast</code> is supported if
the target type is a non-primitive atomic type that is derived by restriction from the input type. The input value must satisfy all the
facets of the target type (in the case of the pattern facet, this is
checked by generating a string representation of the input value,
using the rules for casting to <code>xs:string</code>). The resulting
value is the same as the input value, but with a different <termref def="dt-dynamic-type">dynamic type</termref>.</p></item><item><p>If a primitive type P1 can be cast into a
primitive type P2, then any type derived by restriction from P1 can be cast into any type derived by restriction from P2, provided that the facets of the target type are
satisfied. First the input value is cast to P1 using rule (b)
above. Next, the value of type P1 is cast to the type P2, using rule
(a) above. Finally, the value of type P2 is cast to the target type,
using rule (d) above.</p></item><item><p> For any combination of input
type and target type that is not in the above list, a
<code>cast</code> expression raises a <termref def="dt-type-error">type error</termref> 
                              <errorref class="TY" code="0004"/>.</p></item></olist></item></olist><p diff="del" at="bug29192"> If casting from the input type to the target type is supported but nevertheless it is not possible to cast the input value into the value space of the target type, a <termref def="dt-dynamic-error">dynamic error</termref> is raised. [err:FORG0001] This includes the case when any facet of the target type is not satisfied. For example, the expression <code role="parse-test">"2003-02-31" cast as xs:date</code> would raise a <termref def="dt-dynamic-error">dynamic error</termref>.</p></div3><div3 id="id-castable"><head>Castable</head><scrap headstyle="show"><head/><prod num="27" id="doc-xpath31-CastableExpr"><lhs>CastableExpr</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-CastExpr" xlink:type="simple">CastExpr</nt> ( "castable"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SingleType" xlink:type="simple">SingleType</nt> )?</rhs></prod><prod num="77" id="noid_d3e16481.doc-xpath31-SingleType"><lhs>SingleType</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-SimpleTypeName" xlink:type="simple">SimpleTypeName</nt>  "?"?</rhs></prod></scrap><p>XPath 3.1
provides an expression that tests whether a given value
is castable into a given target type. 

The SimpleTypeName must be the name of a type defined
in the  <termref def="dt-is-types">in-scope schema types</termref>, and the type must be
<code>simple</code> 
                  <errorref class="ST" code="0052"/>. 

In addition, the target type cannot be <code>xs:NOTATION</code>, <code>xs:anySimpleType</code>, or <code>xs:anyAtomicType</code> 
                  <errorref class="ST" code="0080"/>. The optional occurrence indicator "<code>?</code>" denotes that an empty
sequence is permitted. </p><p at="XQ.E5 and XP.E5">The expression <code role="parse-test">E castable as T</code> returns <code>true</code> 
if the result of evaluating <code>E</code>  
can be successfully cast into the target type <code>T</code> by using a <code>cast</code> expression; 
otherwise it returns <code>false</code>. 
If evaluation of <code>E</code> fails with a dynamic error <phrase diff="add" at="bug29903">or if the value of <code>E</code> cannot be atomized</phrase>, 
the <code>castable</code> expression as a whole fails. 
The <code>castable</code> expression can be used as a <termref def="dt-predicate">predicate</termref>  to
avoid errors at evaluation time. 
It can also be used to select an appropriate type for processing of a given value, as illustrated in
the following example:</p><eg role="parse-test" xml:space="preserve">
if ($x castable as hatsize)
   then $x cast as hatsize
   else if ($x castable as IQ)
   then $x cast as IQ
   else $x cast as xs:string</eg></div3><div3 id="id-constructor-functions"><head>Constructor Functions</head><p>For every  <termref def="dt-generalized-atomic-type" diff="del" at="bug28915">generalized atomic type</termref>
                  <phrase diff="add" at="bug28915">simple type</phrase> in the <termref def="dt-is-types">in-scope schema types</termref>  (except <code>xs:NOTATION</code> and <code>xs:anyAtomicType</code>, <phrase diff="add" at="bug29583">and <code>xs:anySimpleType</code>,</phrase> which are not instantiable), a <term>constructor function</term> is implicitly defined. In each case, the name of the constructor function is the same as the name of its target type (including namespace). The signature of the constructor function for  <phrase diff="del" at="bug28915"> type
<emph>T</emph> is as follows:</phrase>
                  <phrase diff="add" at="bug28915">a given type depends on the type that is being constructed, and can be found in  <xspecref spec="FO31" ref="constructor-functions"/>.</phrase>
               </p><eg diff="del" at="bug28915" xml:space="preserve">T($arg as xs:anyAtomicType?) as T?</eg><p> 
                  <termdef term="constructor function" id="dt-constructor-function">The <term>constructor function</term> for a given type is used to convert instances of other  <phrase diff="del" at="bug28915">atomic</phrase>
                     <phrase diff="add" at="bug28915">simple</phrase> types into the given type. The semantics of the constructor function call <code>T($arg)</code> are defined to be equivalent to the expression <code role="parse-test">(($arg) cast as T?)</code>.</termdef>
               </p><p>The following examples illustrate the use of constructor functions:</p><ulist><item><p>This
example is equivalent to <code role="parse-test">("2000-01-01" cast as
xs:date?)</code>.</p><eg role="parse-test" xml:space="preserve">xs:date("2000-01-01")</eg></item><item><p>This
example is equivalent to

<code role="parse-test">(($floatvalue * 0.2E-5) cast as xs:decimal?)</code>.</p><eg role="parse-test" xml:space="preserve">xs:decimal($floatvalue * 0.2E-5)</eg></item><item><p>This example returns an
<code>xs:dayTimeDuration</code> value equal to 21 days. It is
equivalent to <code role="parse-test">("P21D" cast as xs:dayTimeDuration?)</code>.</p><eg role="parse-test" xml:space="preserve">xs:dayTimeDuration("P21D")</eg></item><item><p>If
<code>usa:zipcode</code> is a user-defined atomic type
in the <termref def="dt-is-types">in-scope schema types</termref>, then the
following expression is equivalent to the
expression <code role="parse-test">("12345" cast as
usa:zipcode?)</code>.</p><eg role="parse-test" xml:space="preserve">usa:zipcode("12345")</eg></item></ulist><note diff="chg" at="28960"><p>
  An instance of an atomic type that is not in a namespace can be
  constructed by using a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-URIQualifiedName" xlink:type="simple">URIQualifiedName</nt> 
  in either a cast expression or a constructor function call.  Examples:
  </p><eg role="parse-test" xml:space="preserve">17 cast as Q{}apple</eg><eg role="parse-test" xml:space="preserve">Q{}apple(17)</eg><p>
  If the <termref def="dt-def-elemtype-ns">default element/type
  namespace</termref> is absent, the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-QName" xlink:type="simple">QName</nt> syntax can also be used.
   Examples:
  </p><eg role="parse-test" xml:space="preserve">17 cast as apple</eg><eg role="parse-test" xml:space="preserve">apple(17)</eg></note></div3><div3 id="id-treat"><head>Treat</head><scrap headstyle="show"><head/><prod num="26" id="doc-xpath31-TreatExpr"><lhs>TreatExpr</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-CastableExpr" xlink:type="simple">CastableExpr</nt> ( "treat"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SequenceType" xlink:type="simple">SequenceType</nt> )?</rhs></prod></scrap><p>XPath 3.1 provides an
expression called <code>treat</code> that can be used to modify the
<termref def="dt-static-type">static type</termref> of its
operand.</p><p>Like <code>cast</code>, the <code>treat</code>
expression takes two operands: an expression and a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SequenceType" xlink:type="simple">SequenceType</nt>. Unlike
<code>cast</code>, however, <code>treat</code> does not change the
<termref def="dt-dynamic-type">dynamic type</termref> or value of its operand. Instead, the purpose of
<code>treat</code> is to ensure that an expression has an expected
dynamic type at evaluation time.</p><p>The semantics of <emph>
                     <code>expr1</code>
                  </emph>
                  <code> treat as </code>
                  <emph>
                     <code>type1</code>
                  </emph> are as
follows:</p><ulist><item><p>During static analysis:</p><p> The
<termref def="dt-static-type">static type</termref> of the
<code>treat</code> expression is <emph>
                           <code>type1</code>
                        </emph>. This enables the
expression to be used as an argument of a function that requires a
parameter of <emph>
                           <code>type1</code>
                        </emph>.</p></item><item><p>During expression
evaluation:</p><p>If <emph>
                           <code>expr1</code>
                        </emph> matches <emph>
                           <code>type1</code>
                        </emph>,
using the rules for <termref def="dt-sequencetype-matching">SequenceType
matching</termref>,
the <code>treat</code> expression returns the value of
<emph>
                           <code>expr1</code>
                        </emph>; otherwise, it raises a <termref def="dt-dynamic-error">dynamic error</termref> 
                        <errorref class="DY" code="0050"/>.
If the value of <emph>
                           <code>expr1</code>
                        </emph> is returned, <phrase diff="del" at="2014-12-06">its identity</phrase>
                        <phrase diff="add" at="2014-12-06">the identity of any nodes in the value</phrase> is
preserved. The <code>treat</code> expression ensures that the value of
its expression operand conforms to the expected type at
run-time.</p></item><item><p>Example:</p><eg role="parse-test" xml:space="preserve">$myaddress treat as element(*, USAddress)</eg><p>The
<termref def="dt-static-type">static type</termref> of
<code>$myaddress</code> may be <code>element(*, Address)</code>, a
less specific type than <code>element(*, USAddress)</code>. However,
at run-time, the value of <code>$myaddress</code> must match the type
<code>element(*, USAddress)</code> using rules for <termref def="dt-sequencetype-matching">SequenceType
matching</termref>;
otherwise a <termref def="dt-dynamic-error">dynamic error</termref> is
raised <errorref class="DY" code="0050"/>.</p></item></ulist></div3></div2><div2 id="id-map-operator"><head>Simple map operator (<code>!</code>)</head><scrap headstyle="show"><head/><prod num="35" id="doc-xpath31-SimpleMapExpr"><lhs>SimpleMapExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-PathExpr" xlink:type="simple">PathExpr</nt>  ("!"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-PathExpr" xlink:type="simple">PathExpr</nt>)*</rhs></prod></scrap><p diff="chg" at="bug29903">
    A mapping expression <code>S!E</code> evaluates the
    expression <code>E</code> once for every item in the sequence
    obtained by evaluating <code>S</code>. The simple mapping operator
    "<code>!</code>" can be applied to any sequence, regardless of the
    types of its items, and it can deliver a mixed sequence of nodes,
    atomic values, and functions. Unlike the similar "<code>/</code>"
    operator, it does not sort nodes into document order or eliminate
    duplicates.
  </p><p>Each operation <code>E1!E2</code> is evaluated as follows: Expression <code>E1</code> is evaluated to a sequence <code>S</code>. Each item in <code>S</code> then serves in turn to provide an inner focus (the item as the context item, its position in <code>S</code> as the context position, the length of <code>S</code> as the context size) for an evaluation of <code>E2</code> in the <termref def="dt-dynamic-context">dynamic context</termref>. The sequences resulting from all the evaluations of <code>E2</code> are combined as follows: Every evaluation of <code>E2</code> returns a (possibly empty) sequence of items. These sequences are concatenated and returned. <phrase role="xpath" at="bug28862">The</phrase> returned sequence preserves the orderings within and among the subsequences generated by the evaluations of <code>E2</code>
               <phrase role="xpath">.</phrase>
            </p><p>Simple map operators have functionality similar to <specref ref="id-path-operator"/>.
  The following table summarizes the differences between these two operators</p><table role="medium" width="100%"><thead><tr><th rowspan="1" colspan="1">Operator</th><th rowspan="1" colspan="1">Path operator (<code>E1 / E2</code>)</th><th rowspan="1" colspan="1">Simple map operator (<code>E1 ! E2</code>)</th></tr></thead><tbody><tr><th rowspan="1" colspan="1">E1</th><td rowspan="1" colspan="1">Any sequence of nodes</td><td rowspan="1" colspan="1">Any sequence of items</td></tr><tr><th rowspan="1" colspan="1">E2</th><td rowspan="1" colspan="1">Either a sequence of nodes or a sequence of non-node items</td><td rowspan="1" colspan="1">A sequence of items</td></tr><tr><th rowspan="1" colspan="1">Additional processing</th><td rowspan="1" colspan="1">Duplicate elimination and document ordering</td><td rowspan="1" colspan="1">Simple sequence concatenation</td></tr></tbody></table><p>The following examples illustrate the use of simple map operators combined with path expressions.</p><example><ulist><item><p>
                        <code role="parse-test">child::div1 / child::para / string() ! concat("id-", .)</code>
                     </p><p>Selects the <code>para</code> element children of the <code>div1</code> element children of the context node; that is, the <code>para</code> element grandchildren of the context node that have <code>div1</code> parents. It then outputs the strings obtained by prepending <code>"id-"</code> to each of the string values of these grandchildren.</p></item><item><p>
                        <code role="parse-test">$emp ! (@first, @middle, @last)</code>
                     </p><p>Returns the values of the attributes <code>first</code>, <code>middle</code>, and <code>last</code> for element <code>$emp</code>, in the order given. (The <code>/</code> operator here returns the attributes in an unpredictable order.)</p></item><item><p>
                        <code role="parse-test">$docs ! ( //employee)</code>
                     </p><p>Returns all the employees within all the documents identified by the variable docs, in document order within each document, but retaining the order of documents.</p></item><item><p>
                        <code role="parse-test">avg( //employee / salary ! translate(., '$', '') ! number(.))</code>
                     </p><p>Returns the average salary of the employees, having converted the salary to a number by removing any <code>$</code> sign and then converting to a number. (The second occurrence of <code>!</code> could not be written as <code>/</code> because the left-hand operand of <code>/</code> cannot be an atomic value.)</p></item><item><p>
                        <code role="parse-test">fn:string-join((1 to $n)!"*")</code>
                     </p><p>Returns a string containing <code>$n</code> asterisks.</p></item><item><p>
                        <code role="parse-test">$values!(.*.) =&gt; fn:sum()</code>
                     </p><p>Returns the sum of the squares of a sequence of numbers.</p></item><item><p>
                        <code role="parse-test">string-join(ancestor::*!name(), '/')</code>
                     </p><p>Returns a path containing the names of the ancestors of an element, separated by "<code>/</code>" characters.</p></item></ulist></example></div2><div2 id="id-arrow-operator" diff="add" at="2015-07-06"><head>Arrow operator (<code>=&gt;</code>)</head><scrap headstyle="show"><head/><prod num="29" id="doc-xpath31-ArrowExpr"><lhs>ArrowExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-UnaryExpr" xlink:type="simple">UnaryExpr</nt> ( "=&gt;"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ArrowFunctionSpecifier" xlink:type="simple">ArrowFunctionSpecifier</nt>  
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ArgumentList" xlink:type="simple">ArgumentList</nt> )*</rhs></prod><prod num="55" id="doc-xpath31-ArrowFunctionSpecifier"><lhs>ArrowFunctionSpecifier</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-EQName" xlink:type="simple">EQName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-VarRef" xlink:type="simple">VarRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ParenthesizedExpr" xlink:type="simple">ParenthesizedExpr</nt>
                  </rhs></prod></scrap><p>
               <termdef term="arrow operator" id="dt-arrow-operator">An <term>arrow operator</term> 
                  <phrase diff="del" at="2015-07-06">is a postfix operator that</phrase> applies a function to <phrase diff="del" at="2015-03-17">an item</phrase>
                  <phrase diff="add" at="2015-03-17">the value of an expression</phrase>, using <phrase diff="del" at="2015-03-17">the item</phrase>
                  <phrase diff="add" at="2015-03-17">the value</phrase> as the first argument to the function.</termdef>  
               <phrase diff="del" at="bug29346">If <code>$s</code> is <phrase diff="del" at="2014-12-14">an item</phrase>
                  <phrase diff="add" at="2014-12-14">a sequence</phrase> and <code>f()</code> is a function, then <code>$s=&gt;f()</code> is equivalent to <code>f($s)</code>, and <code>$s=&gt;f($j)</code> is equivalent to <code>f($s, $j)</code>.</phrase>
               <phrase diff="add" at="bug29346">
Given a  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-UnaryExpr" xlink:type="simple">UnaryExpr</nt> 
                  <code>U</code>, an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ArrowFunctionSpecifier" xlink:type="simple">ArrowFunctionSpecifier</nt> 
                  <code>F</code>, 
and an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ArgumentList" xlink:type="simple">ArgumentList</nt> 
                  <code>(A, B, C...)</code>, the expression <code>U =&gt; F(A, B, C...)</code> is equivalent to the
 expression <code>F(U, A, B, C...)</code>.
</phrase>
            </p><p diff="chg" at="bug29903">
    This syntax is particularly helpful when applying multiple
    functions to a value in turn. For example, the following
    expression invites syntax errors due to misplaced parentheses:
  </p><eg role="parsetest" xml:space="preserve">tokenize((normalize-unicode(upper-case($string))),"\s+")</eg><p diff="chg" at="bug29903">In the following reformulation, it is easier to see that the parentheses are balanced:</p><eg role="parse-test" xml:space="preserve">$string =&gt; upper-case() =&gt; normalize-unicode() =&gt; tokenize("\s+")</eg></div2></div1><div1 id="id-conformance"><head>Conformance</head><p>This section defines the conformance criteria for an XPath 3.1 processor. In this section, the
        following terms are used to indicate the requirement levels defined in <bibref ref="RFC2119"/>. <termdef id="must" term="must">
               <term>MUST</term> means that the item is an absolute
            requirement of the specification.</termdef>
            <termdef id="mustnot" term="must not">
               <term>MUST NOT</term> means that the item is an
            absolute prohibition of the specification.</termdef>
            <termdef id="may" term="may">
               <term>MAY</term> means that an item is truly
            optional.</termdef>
        
         </p><p role="xpath">XPath is intended primarily as a component that can be used by
      other specifications. Therefore, XPath relies on specifications that
      use it (such as <bibref ref="XPTR"/> and <bibref ref="xslt-30"/>) to
      specify conformance criteria for XPath in their respective
      environments. Specifications that set conformance criteria for their
      use of XPath <termref def="mustnot" diff="chg">MUST NOT</termref> change the
      syntactic or semantic definitions of XPath as given in this
      specification, except by subsetting and/or compatible extensions.</p><p role="xpath">
            <phrase diff="add" at="bug29498">If a language is described as an extension of XPath, 
      then every expression that conforms to the XPath grammar <termref def="must">MUST</termref>  behave as described in this specification.</phrase>
            <phrase diff="del" at="bug29498">The specification of such a language may describe it as an
      extension of XPath provided that every expression that conforms to the
      XPath grammar behaves as described in this specification.</phrase>
         </p><div2 id="id-xpath-static-typing" role="xpath"><head>Static Typing Feature</head><p>
               <termdef id="dt-xpath-static-typing-feature" term="static typing feature" role="xpath">The <term>Static
        Typing Feature</term> is an optional feature of XPath that provides support for static semantics, and requires implementations to detect and report <termref def="dt-type-error">type errors</termref> during the <termref def="dt-static-analysis">static analysis phase</termref>.</termdef> Specifications that use XPath <termref def="may" diff="chg" at="bug29498">MAY</termref>  specify conformance criteria for use of the Static Typing Feature.</p><p>If an implementation does not support the <termref def="dt-xpath-static-typing-feature">Static Typing Feature</termref>, but can
        nevertheless determine during the static analysis phase that
        <phrase role="xpath">an XPath expression</phrase>, if evaluated, would necessarily raise a <termref def="dt-dynamic-error">dynamic error</termref> or that an expression, if evaluated, would necessarily raise a <termref def="dt-type-error">type error</termref>, the implementation <termref def="may" diff="chg" at="bug29498">MAY</termref> raise that error during the static analysis phase. The choice
        of whether to raise such an error at analysis time is <termref def="dt-implementation-dependent">implementation dependent</termref>.</p></div2></div1></body><back id="id-appendices"><div1 id="nt-bnf"><head>XPath 3.1 Grammar</head><div2 id="id-grammar"><head>EBNF</head><p>The grammar of XPath 3.1 uses the same simple Extended Backus-Naur Form (EBNF) notation as
        <bibref ref="XML"/> with the following minor differences.</p><ulist><item><p>All named symbols have a name that begins with an uppercase letter.</p></item><item><p>It adds a notation for referring to productions in external specifications.</p></item><item><p>Comments or extra-grammatical constraints on grammar productions are between '/*' and
          '*/' symbols.</p><ulist><item><p>A 'xgc:' prefix is an extra-grammatical constraint, the details of which are
              explained in <specref ref="extra-grammatical-constraints"/>
                        </p></item><item><p>A 'ws:' prefix explains the whitespace rules for the production, the details of which
              are explained in <specref ref="whitespace-rules"/>
                        </p></item><item><p>A 'gn:' prefix means a 'Grammar Note', and is meant as a clarification for parsing
              rules, and is explained in <specref ref="notes-on-parsing"/>. These notes are not
              normative.</p></item></ulist></item></ulist><p>The terminal symbols for this grammar include the quoted strings used in the production rules
      below, and the terminal symbols defined in section <specref ref="terminal-symbols"/>.</p><p>The EBNF notation is described in more detail in <specref ref="EBNFNotation"/>.</p><p diff="del" at="bug29702">To increase readability, the EBNF in the main body of this document omits some of these
      notational features. This appendix is the normative version of the EBNF.</p><scrap id="BNF-Grammar" role="non-terminal-structure-expand" headstyle="show"><head/><prod num="1" id="prod-xpath31-XPath"><lhs>XPath</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-Expr" xlink:type="simple">Expr</nt>
                  </rhs></prod><prod num="2" id="prod-xpath31-ParamList"><lhs>ParamList</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-Param" xlink:type="simple">Param</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-Param" xlink:type="simple">Param</nt>)*</rhs></prod><prod num="3" id="prod-xpath31-Param"><lhs>Param</lhs><rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-EQName" xlink:type="simple">EQName</nt>  
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-TypeDeclaration" xlink:type="simple">TypeDeclaration</nt>?</rhs></prod><prod num="4" id="prod-xpath31-FunctionBody"><lhs>FunctionBody</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-EnclosedExpr" xlink:type="simple">EnclosedExpr</nt>
                  </rhs></prod><prod num="5" id="prod-xpath31-EnclosedExpr"><lhs>EnclosedExpr</lhs><rhs>"{"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-Expr" xlink:type="simple">Expr</nt>?  "}"</rhs></prod><prod num="6" id="prod-xpath31-Expr"><lhs>Expr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod><prod num="7" id="prod-xpath31-ExprSingle"><lhs>ExprSingle</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ForExpr" xlink:type="simple">ForExpr</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-LetExpr" xlink:type="simple">LetExpr</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-QuantifiedExpr" xlink:type="simple">QuantifiedExpr</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-IfExpr" xlink:type="simple">IfExpr</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-OrExpr" xlink:type="simple">OrExpr</nt>
                  </rhs></prod><prod num="8" id="prod-xpath31-ForExpr"><lhs>ForExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-SimpleForClause" xlink:type="simple">SimpleForClause</nt>  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>
                  </rhs></prod><prod num="9" id="prod-xpath31-SimpleForClause"><lhs>SimpleForClause</lhs><rhs>"for"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-SimpleForBinding" xlink:type="simple">SimpleForBinding</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-SimpleForBinding" xlink:type="simple">SimpleForBinding</nt>)*</rhs></prod><prod num="10" id="prod-xpath31-SimpleForBinding"><lhs>SimpleForBinding</lhs><rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-VarName" xlink:type="simple">VarName</nt>  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>
                  </rhs></prod><prod num="11" id="prod-xpath31-LetExpr"><lhs>LetExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-SimpleLetClause" xlink:type="simple">SimpleLetClause</nt>  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>
                  </rhs></prod><prod num="12" id="prod-xpath31-SimpleLetClause"><lhs>SimpleLetClause</lhs><rhs>"let"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-SimpleLetBinding" xlink:type="simple">SimpleLetBinding</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-SimpleLetBinding" xlink:type="simple">SimpleLetBinding</nt>)*</rhs></prod><prod num="13" id="prod-xpath31-SimpleLetBinding"><lhs>SimpleLetBinding</lhs><rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-VarName" xlink:type="simple">VarName</nt>  ":="  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>
                  </rhs></prod><prod num="14" id="prod-xpath31-QuantifiedExpr"><lhs>QuantifiedExpr</lhs><rhs>("some"  |  "every")  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-VarName" xlink:type="simple">VarName</nt>  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-VarName" xlink:type="simple">VarName</nt>  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>)*  "satisfies"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>
                  </rhs></prod><prod num="15" id="prod-xpath31-IfExpr"><lhs>IfExpr</lhs><rhs>"if"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-Expr" xlink:type="simple">Expr</nt>  ")"  "then"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>  "else"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>
                  </rhs></prod><prod num="16" id="prod-xpath31-OrExpr"><lhs>OrExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-AndExpr" xlink:type="simple">AndExpr</nt> ( "or"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-AndExpr" xlink:type="simple">AndExpr</nt> )*</rhs></prod><prod num="17" id="prod-xpath31-AndExpr"><lhs>AndExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ComparisonExpr" xlink:type="simple">ComparisonExpr</nt> ( "and"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ComparisonExpr" xlink:type="simple">ComparisonExpr</nt> )*</rhs></prod><prod num="18" id="prod-xpath31-ComparisonExpr"><lhs>ComparisonExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-StringConcatExpr" xlink:type="simple">StringConcatExpr</nt> ( (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ValueComp" xlink:type="simple">ValueComp</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-GeneralComp" xlink:type="simple">GeneralComp</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-NodeComp" xlink:type="simple">NodeComp</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-StringConcatExpr" xlink:type="simple">StringConcatExpr</nt> )?</rhs></prod><prod num="19" id="prod-xpath31-StringConcatExpr"><lhs>StringConcatExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-RangeExpr" xlink:type="simple">RangeExpr</nt> ( "||"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-RangeExpr" xlink:type="simple">RangeExpr</nt> )*</rhs></prod><prod num="20" id="prod-xpath31-RangeExpr"><lhs>RangeExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt> ( "to"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt> )?</rhs></prod><prod num="21" id="prod-xpath31-AdditiveExpr"><lhs>AdditiveExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-MultiplicativeExpr" xlink:type="simple">MultiplicativeExpr</nt> ( ("+"  |  "-")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-MultiplicativeExpr" xlink:type="simple">MultiplicativeExpr</nt> )*</rhs></prod><prod num="22" id="prod-xpath31-MultiplicativeExpr"><lhs>MultiplicativeExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-UnionExpr" xlink:type="simple">UnionExpr</nt> ( ("*"  |  "div"  |  "idiv"  |  "mod")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-UnionExpr" xlink:type="simple">UnionExpr</nt> )*</rhs></prod><prod num="23" id="prod-xpath31-UnionExpr"><lhs>UnionExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-IntersectExceptExpr" xlink:type="simple">IntersectExceptExpr</nt> ( ("union"  |  "|")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-IntersectExceptExpr" xlink:type="simple">IntersectExceptExpr</nt> )*</rhs></prod><prod num="24" id="prod-xpath31-IntersectExceptExpr"><lhs>IntersectExceptExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-InstanceofExpr" xlink:type="simple">InstanceofExpr</nt> ( ("intersect"  |  "except")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-InstanceofExpr" xlink:type="simple">InstanceofExpr</nt> )*</rhs></prod><prod num="25" id="prod-xpath31-InstanceofExpr"><lhs>InstanceofExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-TreatExpr" xlink:type="simple">TreatExpr</nt> ( "instance"  "of"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-SequenceType" xlink:type="simple">SequenceType</nt> )?</rhs></prod><prod num="26" id="prod-xpath31-TreatExpr"><lhs>TreatExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-CastableExpr" xlink:type="simple">CastableExpr</nt> ( "treat"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-SequenceType" xlink:type="simple">SequenceType</nt> )?</rhs></prod><prod num="27" id="prod-xpath31-CastableExpr"><lhs>CastableExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-CastExpr" xlink:type="simple">CastExpr</nt> ( "castable"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-SingleType" xlink:type="simple">SingleType</nt> )?</rhs></prod><prod num="28" id="prod-xpath31-CastExpr"><lhs>CastExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ArrowExpr" xlink:type="simple">ArrowExpr</nt> ( "cast"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-SingleType" xlink:type="simple">SingleType</nt> )?</rhs></prod><prod num="29" id="prod-xpath31-ArrowExpr"><lhs>ArrowExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-UnaryExpr" xlink:type="simple">UnaryExpr</nt> ( "=&gt;"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ArrowFunctionSpecifier" xlink:type="simple">ArrowFunctionSpecifier</nt>  
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ArgumentList" xlink:type="simple">ArgumentList</nt> )*</rhs></prod><prod num="30" id="prod-xpath31-UnaryExpr"><lhs>UnaryExpr</lhs><rhs>("-"  |  "+")* <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ValueExpr" xlink:type="simple">ValueExpr</nt>
                  </rhs></prod><prod num="31" id="prod-xpath31-ValueExpr"><lhs>ValueExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-SimpleMapExpr" xlink:type="simple">SimpleMapExpr</nt>
                  </rhs></prod><prod num="32" id="prod-xpath31-GeneralComp"><lhs>GeneralComp</lhs><rhs>"="  |  "!="  |  "&lt;"  |  "&lt;="  |  "&gt;"  |  "&gt;="</rhs></prod><prod num="33" id="prod-xpath31-ValueComp"><lhs>ValueComp</lhs><rhs>"eq"  |  "ne"  |  "lt"  |  "le"  |  "gt"  |  "ge"</rhs></prod><prod num="34" id="prod-xpath31-NodeComp"><lhs>NodeComp</lhs><rhs>"is"  |  "&lt;&lt;"  |  "&gt;&gt;"</rhs></prod><prod num="35" id="prod-xpath31-SimpleMapExpr"><lhs>SimpleMapExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-PathExpr" xlink:type="simple">PathExpr</nt>  ("!"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-PathExpr" xlink:type="simple">PathExpr</nt>)*</rhs></prod><prod num="36" id="prod-xpath31-PathExpr"><lhs>PathExpr</lhs><rhs>("/"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>?)<br/>|  ("//"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>)<br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>
                  </rhs><com>
                     <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-leading-lone-slash" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgc: leading-lone-slash</loc>
                  </com></prod><prod num="37" id="prod-xpath31-RelativePathExpr"><lhs>RelativePathExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-StepExpr" xlink:type="simple">StepExpr</nt>  (("/"  |  "//")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-StepExpr" xlink:type="simple">StepExpr</nt>)*</rhs></prod><prod num="38" id="prod-xpath31-StepExpr"><lhs>StepExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-PostfixExpr" xlink:type="simple">PostfixExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-AxisStep" xlink:type="simple">AxisStep</nt>
                  </rhs></prod><prod num="39" id="prod-xpath31-AxisStep"><lhs>AxisStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ReverseStep" xlink:type="simple">ReverseStep</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ForwardStep" xlink:type="simple">ForwardStep</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-PredicateList" xlink:type="simple">PredicateList</nt>
                  </rhs></prod><prod num="40" id="prod-xpath31-ForwardStep"><lhs>ForwardStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ForwardAxis" xlink:type="simple">ForwardAxis</nt>  
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-NodeTest" xlink:type="simple">NodeTest</nt>)  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-AbbrevForwardStep" xlink:type="simple">AbbrevForwardStep</nt>
                  </rhs></prod><prod num="41" id="prod-xpath31-ForwardAxis"><lhs>ForwardAxis</lhs><rhs>("child"  "::")<br/>|  ("descendant"  "::")<br/>|  ("attribute"  "::")<br/>|  ("self"  "::")<br/>|  ("descendant-or-self"  "::")<br/>|  ("following-sibling"  "::")<br/>|  ("following"  "::")<br/>|  ("namespace"  "::")</rhs></prod><prod num="42" id="prod-xpath31-AbbrevForwardStep"><lhs>AbbrevForwardStep</lhs><rhs>"@"?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-NodeTest" xlink:type="simple">NodeTest</nt>
                  </rhs></prod><prod num="43" id="prod-xpath31-ReverseStep"><lhs>ReverseStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ReverseAxis" xlink:type="simple">ReverseAxis</nt>  
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-NodeTest" xlink:type="simple">NodeTest</nt>)  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-AbbrevReverseStep" xlink:type="simple">AbbrevReverseStep</nt>
                  </rhs></prod><prod num="44" id="prod-xpath31-ReverseAxis"><lhs>ReverseAxis</lhs><rhs>("parent"  "::")<br/>|  ("ancestor"  "::")<br/>|  ("preceding-sibling"  "::")<br/>|  ("preceding"  "::")<br/>|  ("ancestor-or-self"  "::")</rhs></prod><prod num="45" id="prod-xpath31-AbbrevReverseStep"><lhs>AbbrevReverseStep</lhs><rhs>".."</rhs></prod><prod num="46" id="prod-xpath31-NodeTest"><lhs>NodeTest</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-KindTest" xlink:type="simple">KindTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-NameTest" xlink:type="simple">NameTest</nt>
                  </rhs></prod><prod num="47" id="prod-xpath31-NameTest"><lhs>NameTest</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-EQName" xlink:type="simple">EQName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-Wildcard" xlink:type="simple">Wildcard</nt>
                  </rhs></prod><prod num="48" id="prod-xpath31-Wildcard"><lhs>Wildcard</lhs><rhs>"*"<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-NCName" xlink:type="simple">NCName</nt>  ":*")<br/>|  ("*:"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-NCName" xlink:type="simple">NCName</nt>)<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-BracedURILiteral" xlink:type="simple">BracedURILiteral</nt>  "*")</rhs><com>
                     <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc>
                  </com></prod><prod num="49" id="prod-xpath31-PostfixExpr"><lhs>PostfixExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-PrimaryExpr" xlink:type="simple">PrimaryExpr</nt>  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-Predicate" xlink:type="simple">Predicate</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ArgumentList" xlink:type="simple">ArgumentList</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-Lookup" xlink:type="simple">Lookup</nt>)*</rhs></prod><prod num="50" id="prod-xpath31-ArgumentList"><lhs>ArgumentList</lhs><rhs>"("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-Argument" xlink:type="simple">Argument</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-Argument" xlink:type="simple">Argument</nt>)*)?  ")"</rhs></prod><prod num="51" id="prod-xpath31-PredicateList"><lhs>PredicateList</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-Predicate" xlink:type="simple">Predicate</nt>*</rhs></prod><prod num="52" id="prod-xpath31-Predicate"><lhs>Predicate</lhs><rhs>"["  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-Expr" xlink:type="simple">Expr</nt>  "]"</rhs></prod><prod num="53" id="prod-xpath31-Lookup"><lhs>Lookup</lhs><rhs>"?"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-KeySpecifier" xlink:type="simple">KeySpecifier</nt>
                  </rhs></prod><prod num="54" id="prod-xpath31-KeySpecifier"><lhs>KeySpecifier</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-NCName" xlink:type="simple">NCName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-IntegerLiteral" xlink:type="simple">IntegerLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ParenthesizedExpr" xlink:type="simple">ParenthesizedExpr</nt>  |  "*"</rhs></prod><prod num="55" id="prod-xpath31-ArrowFunctionSpecifier"><lhs>ArrowFunctionSpecifier</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-EQName" xlink:type="simple">EQName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-VarRef" xlink:type="simple">VarRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ParenthesizedExpr" xlink:type="simple">ParenthesizedExpr</nt>
                  </rhs></prod><prod num="56" id="prod-xpath31-PrimaryExpr"><lhs>PrimaryExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-Literal" xlink:type="simple">Literal</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-VarRef" xlink:type="simple">VarRef</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ParenthesizedExpr" xlink:type="simple">ParenthesizedExpr</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ContextItemExpr" xlink:type="simple">ContextItemExpr</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-FunctionCall" xlink:type="simple">FunctionCall</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-FunctionItemExpr" xlink:type="simple">FunctionItemExpr</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-MapConstructor" xlink:type="simple">MapConstructor</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ArrayConstructor" xlink:type="simple">ArrayConstructor</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-UnaryLookup" xlink:type="simple">UnaryLookup</nt>
                  </rhs></prod><prod num="57" id="prod-xpath31-Literal"><lhs>Literal</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-NumericLiteral" xlink:type="simple">NumericLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-StringLiteral" xlink:type="simple">StringLiteral</nt>
                  </rhs></prod><prod num="58" id="prod-xpath31-NumericLiteral"><lhs>NumericLiteral</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-IntegerLiteral" xlink:type="simple">IntegerLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-DecimalLiteral" xlink:type="simple">DecimalLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-DoubleLiteral" xlink:type="simple">DoubleLiteral</nt>
                  </rhs></prod><prod num="59" id="prod-xpath31-VarRef"><lhs>VarRef</lhs><rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-VarName" xlink:type="simple">VarName</nt>
                  </rhs></prod><prod num="60" id="prod-xpath31-VarName"><lhs>VarName</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-EQName" xlink:type="simple">EQName</nt>
                  </rhs></prod><prod num="61" id="prod-xpath31-ParenthesizedExpr"><lhs>ParenthesizedExpr</lhs><rhs>"("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-Expr" xlink:type="simple">Expr</nt>?  ")"</rhs></prod><prod num="62" id="prod-xpath31-ContextItemExpr"><lhs>ContextItemExpr</lhs><rhs>"."</rhs></prod><prod num="63" id="prod-xpath31-FunctionCall"><lhs>FunctionCall</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-EQName" xlink:type="simple">EQName</nt>  
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ArgumentList" xlink:type="simple">ArgumentList</nt>
                  </rhs><com>
                     <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-reserved-function-names" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgc: reserved-function-names</loc>
                  </com><com>
                     <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-parens" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">gn: parens</loc>
                  </com></prod><prod num="64" id="prod-xpath31-Argument"><lhs>Argument</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ArgumentPlaceholder" xlink:type="simple">ArgumentPlaceholder</nt>
                  </rhs></prod><prod num="65" id="prod-xpath31-ArgumentPlaceholder"><lhs>ArgumentPlaceholder</lhs><rhs>"?"</rhs></prod><prod num="66" id="prod-xpath31-FunctionItemExpr"><lhs>FunctionItemExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-NamedFunctionRef" xlink:type="simple">NamedFunctionRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-InlineFunctionExpr" xlink:type="simple">InlineFunctionExpr</nt>
                  </rhs></prod><prod num="67" id="prod-xpath31-NamedFunctionRef"><lhs>NamedFunctionRef</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-EQName" xlink:type="simple">EQName</nt>  "#"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-IntegerLiteral" xlink:type="simple">IntegerLiteral</nt>
                  </rhs><com>
                     <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-reserved-function-names" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgc: reserved-function-names</loc>
                  </com></prod><prod num="68" id="prod-xpath31-InlineFunctionExpr"><lhs>InlineFunctionExpr</lhs><rhs>"function"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ParamList" xlink:type="simple">ParamList</nt>?  ")"  ("as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-SequenceType" xlink:type="simple">SequenceType</nt>)?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-FunctionBody" xlink:type="simple">FunctionBody</nt>
                  </rhs></prod><prod num="69" id="prod-xpath31-MapConstructor"><lhs>MapConstructor</lhs><rhs>"map"  "{"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-MapConstructorEntry" xlink:type="simple">MapConstructorEntry</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-MapConstructorEntry" xlink:type="simple">MapConstructorEntry</nt>)*)?  "}"</rhs></prod><prod num="70" id="prod-xpath31-MapConstructorEntry"><lhs>MapConstructorEntry</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-MapKeyExpr" xlink:type="simple">MapKeyExpr</nt>  ":"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-MapValueExpr" xlink:type="simple">MapValueExpr</nt>
                  </rhs></prod><prod num="71" id="prod-xpath31-MapKeyExpr"><lhs>MapKeyExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>
                  </rhs></prod><prod num="72" id="prod-xpath31-MapValueExpr"><lhs>MapValueExpr</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>
                  </rhs></prod><prod num="73" id="prod-xpath31-ArrayConstructor"><lhs>ArrayConstructor</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-SquareArrayConstructor" xlink:type="simple">SquareArrayConstructor</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-CurlyArrayConstructor" xlink:type="simple">CurlyArrayConstructor</nt>
                  </rhs></prod><prod num="74" id="prod-xpath31-SquareArrayConstructor"><lhs>SquareArrayConstructor</lhs><rhs>"["  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ExprSingle" xlink:type="simple">ExprSingle</nt>)*)?  "]"</rhs></prod><prod num="75" id="prod-xpath31-CurlyArrayConstructor"><lhs>CurlyArrayConstructor</lhs><rhs>"array"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-EnclosedExpr" xlink:type="simple">EnclosedExpr</nt>
                  </rhs></prod><prod num="76" id="prod-xpath31-UnaryLookup"><lhs>UnaryLookup</lhs><rhs>"?"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-KeySpecifier" xlink:type="simple">KeySpecifier</nt>
                  </rhs></prod><prod num="77" id="prod-xpath31-SingleType"><lhs>SingleType</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-SimpleTypeName" xlink:type="simple">SimpleTypeName</nt>  "?"?</rhs></prod><prod num="78" id="prod-xpath31-TypeDeclaration"><lhs>TypeDeclaration</lhs><rhs>"as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-SequenceType" xlink:type="simple">SequenceType</nt>
                  </rhs></prod><prod num="79" id="prod-xpath31-SequenceType"><lhs>SequenceType</lhs><rhs>("empty-sequence"  "("  ")")<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ItemType" xlink:type="simple">ItemType</nt>  
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>?)</rhs></prod><prod num="80" id="prod-xpath31-OccurrenceIndicator"><lhs>OccurrenceIndicator</lhs><rhs>"?"  |  "*"  |  "+"</rhs><com>
                     <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-occurrence-indicators" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgc: occurrence-indicators</loc>
                  </com></prod><prod num="81" id="prod-xpath31-ItemType"><lhs>ItemType</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-KindTest" xlink:type="simple">KindTest</nt>  |  ("item"  "("  ")")  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-FunctionTest" xlink:type="simple">FunctionTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-MapTest" xlink:type="simple">MapTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ArrayTest" xlink:type="simple">ArrayTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-AtomicOrUnionType" xlink:type="simple">AtomicOrUnionType</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ParenthesizedItemType" xlink:type="simple">ParenthesizedItemType</nt>
                  </rhs></prod><prod num="82" id="prod-xpath31-AtomicOrUnionType"><lhs>AtomicOrUnionType</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-EQName" xlink:type="simple">EQName</nt>
                  </rhs></prod><prod num="83" id="prod-xpath31-KindTest"><lhs>KindTest</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-DocumentTest" xlink:type="simple">DocumentTest</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ElementTest" xlink:type="simple">ElementTest</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-AttributeTest" xlink:type="simple">AttributeTest</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-PITest" xlink:type="simple">PITest</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-CommentTest" xlink:type="simple">CommentTest</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-TextTest" xlink:type="simple">TextTest</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-NamespaceNodeTest" xlink:type="simple">NamespaceNodeTest</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-AnyKindTest" xlink:type="simple">AnyKindTest</nt>
                  </rhs></prod><prod num="84" id="prod-xpath31-AnyKindTest"><lhs>AnyKindTest</lhs><rhs>"node"  "("  ")"</rhs></prod><prod num="85" id="prod-xpath31-DocumentTest"><lhs>DocumentTest</lhs><rhs>"document-node"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ElementTest" xlink:type="simple">ElementTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>)?  ")"</rhs></prod><prod num="86" id="prod-xpath31-TextTest"><lhs>TextTest</lhs><rhs>"text"  "("  ")"</rhs></prod><prod num="87" id="prod-xpath31-CommentTest"><lhs>CommentTest</lhs><rhs>"comment"  "("  ")"</rhs></prod><prod num="88" id="prod-xpath31-NamespaceNodeTest"><lhs>NamespaceNodeTest</lhs><rhs>"namespace-node"  "("  ")"</rhs></prod><prod num="89" id="prod-xpath31-PITest"><lhs>PITest</lhs><rhs>"processing-instruction"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-NCName" xlink:type="simple">NCName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-StringLiteral" xlink:type="simple">StringLiteral</nt>)?  ")"</rhs></prod><prod num="90" id="prod-xpath31-AttributeTest"><lhs>AttributeTest</lhs><rhs>"attribute"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-AttribNameOrWildcard" xlink:type="simple">AttribNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-TypeName" xlink:type="simple">TypeName</nt>)?)?  ")"</rhs></prod><prod num="91" id="prod-xpath31-AttribNameOrWildcard"><lhs>AttribNameOrWildcard</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-AttributeName" xlink:type="simple">AttributeName</nt>  |  "*"</rhs></prod><prod num="92" id="prod-xpath31-SchemaAttributeTest"><lhs>SchemaAttributeTest</lhs><rhs>"schema-attribute"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-AttributeDeclaration" xlink:type="simple">AttributeDeclaration</nt>  ")"</rhs></prod><prod num="93" id="prod-xpath31-AttributeDeclaration"><lhs>AttributeDeclaration</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-AttributeName" xlink:type="simple">AttributeName</nt>
                  </rhs></prod><prod num="94" id="prod-xpath31-ElementTest"><lhs>ElementTest</lhs><rhs>"element"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ElementNameOrWildcard" xlink:type="simple">ElementNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-TypeName" xlink:type="simple">TypeName</nt>  "?"?)?)?  ")"</rhs></prod><prod num="95" id="prod-xpath31-ElementNameOrWildcard"><lhs>ElementNameOrWildcard</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ElementName" xlink:type="simple">ElementName</nt>  |  "*"</rhs></prod><prod num="96" id="prod-xpath31-SchemaElementTest"><lhs>SchemaElementTest</lhs><rhs>"schema-element"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ElementDeclaration" xlink:type="simple">ElementDeclaration</nt>  ")"</rhs></prod><prod num="97" id="prod-xpath31-ElementDeclaration"><lhs>ElementDeclaration</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ElementName" xlink:type="simple">ElementName</nt>
                  </rhs></prod><prod num="98" id="prod-xpath31-AttributeName"><lhs>AttributeName</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-EQName" xlink:type="simple">EQName</nt>
                  </rhs></prod><prod num="99" id="prod-xpath31-ElementName"><lhs>ElementName</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-EQName" xlink:type="simple">EQName</nt>
                  </rhs></prod><prod num="100" id="prod-xpath31-SimpleTypeName"><lhs>SimpleTypeName</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-TypeName" xlink:type="simple">TypeName</nt>
                  </rhs></prod><prod num="101" id="prod-xpath31-TypeName"><lhs>TypeName</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-EQName" xlink:type="simple">EQName</nt>
                  </rhs></prod><prod num="102" id="prod-xpath31-FunctionTest"><lhs>FunctionTest</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-AnyFunctionTest" xlink:type="simple">AnyFunctionTest</nt>
                     <br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-TypedFunctionTest" xlink:type="simple">TypedFunctionTest</nt>
                  </rhs></prod><prod num="103" id="prod-xpath31-AnyFunctionTest"><lhs>AnyFunctionTest</lhs><rhs>"function"  "("  "*"  ")"</rhs></prod><prod num="104" id="prod-xpath31-TypedFunctionTest"><lhs>TypedFunctionTest</lhs><rhs>"function"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-SequenceType" xlink:type="simple">SequenceType</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-SequenceType" xlink:type="simple">SequenceType</nt>)*)?  ")"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-SequenceType" xlink:type="simple">SequenceType</nt>
                  </rhs></prod><prod num="105" id="prod-xpath31-MapTest"><lhs>MapTest</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-AnyMapTest" xlink:type="simple">AnyMapTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-TypedMapTest" xlink:type="simple">TypedMapTest</nt>
                  </rhs></prod><prod num="106" id="prod-xpath31-AnyMapTest"><lhs>AnyMapTest</lhs><rhs>"map"  "("  "*"  ")"</rhs></prod><prod num="107" id="prod-xpath31-TypedMapTest"><lhs>TypedMapTest</lhs><rhs>"map"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-AtomicOrUnionType" xlink:type="simple">AtomicOrUnionType</nt>  ","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-SequenceType" xlink:type="simple">SequenceType</nt>  ")"</rhs></prod><prod num="108" id="prod-xpath31-ArrayTest"><lhs>ArrayTest</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-AnyArrayTest" xlink:type="simple">AnyArrayTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-TypedArrayTest" xlink:type="simple">TypedArrayTest</nt>
                  </rhs></prod><prod num="109" id="prod-xpath31-AnyArrayTest"><lhs>AnyArrayTest</lhs><rhs>"array"  "("  "*"  ")"</rhs></prod><prod num="110" id="prod-xpath31-TypedArrayTest"><lhs>TypedArrayTest</lhs><rhs>"array"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-SequenceType" xlink:type="simple">SequenceType</nt>  ")"</rhs></prod><prod num="111" id="prod-xpath31-ParenthesizedItemType"><lhs>ParenthesizedItemType</lhs><rhs>"("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-ItemType" xlink:type="simple">ItemType</nt>  ")"</rhs></prod><prod num="112" id="prod-xpath31-EQName"><lhs>EQName</lhs><rhs>
                     <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-QName" xlink:type="simple">QName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-URIQualifiedName" xlink:type="simple">URIQualifiedName</nt>
                  </rhs></prod></scrap><div3 id="EBNFNotation"><head>Notation</head><p diff="del">The following definitions will be helpful in defining precisely this exposition.</p><p>
                  <termdef id="symbol" term="symbol">Each rule in the grammar defines one <term>symbol</term>,
          using the following format: <eg xml:space="preserve">symbol ::= expression</eg>
                  </termdef>
               </p><p>
                  <termdef term="terminal" id="terminal">A <term>terminal</term> is a symbol or string or
          pattern that can appear in the right-hand side of a rule, but never appears on the
          left-hand side in the main grammar, although it may appear on the left-hand side of a rule
          in the grammar for terminals.</termdef> The following constructs are used to match strings
        of one or more characters in a terminal:</p><glist><gitem><label>[a-zA-Z]</label><def><p>matches any <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-Char" xlink:type="simple">Char</nt> with a value in the range(s) indicated
              (inclusive).</p></def></gitem><gitem><label>[abc]</label><def><p>matches any <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-Char" xlink:type="simple">Char</nt> with a value among the characters enumerated.
            </p></def></gitem><gitem><label>[^abc]</label><def><p>matches any <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-Char" xlink:type="simple">Char</nt> with a value not among the characters given.</p></def></gitem><gitem><label>"string"</label><def><p>matches the sequence of characters that appear inside the double quotes.</p></def></gitem><gitem><label>'string'</label><def><p>matches the sequence of characters that appear inside the single quotes.</p></def></gitem><gitem><label> [http://www.w3.org/TR/REC-example/#NT-Example]</label><def><p>matches any string matched by the production defined in the external specification as
              per the provided reference.</p></def></gitem></glist><p>Patterns (including the above constructs) can be combined with grammatical operators to
        form more complex patterns, matching more complex sets of character strings. In the examples
        that follow, A and B represent (sub-)patterns.</p><glist><gitem><label>(A)</label><def><p>
                           <code>A</code> is treated as a unit and may be combined as described in this list.</p></def></gitem><gitem><label>A?</label><def><p>matches <code>A</code> or nothing; optional <code>A</code>.</p></def></gitem><gitem><label>A B</label><def><p>matches <code>A</code> followed by <code>B</code>. This operator has higher
              precedence than alternation; thus <code>A B | C D</code> is identical to <code>(A B) |
                (C D)</code>.</p></def></gitem><gitem><label>A | B</label><def><p>matches <code>A</code> or <code>B</code> but not both.</p></def></gitem><gitem><label>A - B</label><def><p>matches any string that matches <code>A</code> but does not match <code>B</code>.</p></def></gitem><gitem><label>A+</label><def><p>matches one or more occurrences of <code>A</code>. Concatenation has higher
              precedence than alternation; thus <code>A+ | B+</code> is identical to <code>(A+) |
                (B+)</code>.</p></def></gitem></glist><glist><gitem><label>A*</label><def><p>matches zero or more occurrences of <code>A</code>. Concatenation has higher
              precedence than alternation; thus <code>A* | B*</code> is identical to <code>(A*) |
                (B*)</code>
                        </p></def></gitem></glist></div3><div3 id="extra-grammatical-constraints"><head>Extra-grammatical Constraints</head><p>This section contains constraints on the EBNF productions, which are required to parse
        syntactically valid sentences. The notes below are referenced from the right side of the
        production, with the notation: <emph>/* xgc: &lt;id&gt; */</emph>.</p><constraintnote id="parse-note-leading-lone-slash" type="xgc"><head>leading-lone-slash</head><p>A single slash may appear either as a complete path expression or as the first part of a
          path expression in which it is followed by a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>. In some cases, the next token after the slash is insufficient to
          allow a parser to distinguish these two possibilities: the <code>*</code> token and
          keywords like <code>union</code> could be either an operator or a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-NameTest" xlink:type="simple">NameTest</nt>
          . For example,
          without lookahead the first part of the expression <code>/ * 5</code> is easily taken to
          be a complete expression, <code role="parse-test">/ *</code>, which has a very different
          interpretation (the child nodes of <code>/</code>).</p><p>If the token immediately following a slash
          can form the start of a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>, then the slash
          must be the beginning of a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-PathExpr" xlink:type="simple">PathExpr</nt>, not the entirety of it.</p><p>A single slash may be used as the left-hand argument of an operator by parenthesizing it:
            <code role="parse-test">(/) * 5</code>. The expression <code role="parse-test">5 *
            /</code>, on the other hand, is syntactically valid without parentheses.</p></constraintnote><constraintnote id="parse-note-xml-version" type="xgc"><head>xml-version</head><p>The version of XML and XML Names (e.g. <bibref ref="XML"/> and <bibref ref="XMLNAMES"/>,
          or <bibref ref="XML1.1"/> and <bibref ref="XMLNAMES11"/>) is <termref def="dt-implementation-defined">implementation-defined</termref>. It is recommended that
          the latest applicable version be used (even if it is published later than this
          specification). The EBNF in this specification links only to the 1.0 versions. Note also
          that these external productions follow the whitespace rules of their respective
          specifications, and not the rules of this specification, in particular <specref ref="DefaultWhitespaceHandling"/>. Thus <code>prefix : localname</code> is not a
          syntactically valid <termref def="dt-qname">lexical QName</termref> for purposes of this
          specification, just as it is not permitted in a XML document. Also, comments are not
          permissible on either side of the colon. Also extra-grammatical constraints such as
          well-formedness constraints must be taken into account.</p><p role="xpath" diff="del" at="bug29962">XPath expressions allow any legal XML Unicode character, subject only to
          constraints imposed by the host language.</p></constraintnote><constraintnote id="parse-note-reserved-function-names" type="xgc"><head>reserved-function-names</head><p>Unprefixed function names spelled the same way as language keywords could make the
          language impossible to parse. For instance, <code>element(foo)</code> could be taken either as
          a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-FunctionCall" xlink:type="simple">FunctionCall</nt> or as an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementTest" xlink:type="simple">ElementTest</nt>. Therefore, an unprefixed function name must not be any of the names in
            <specref ref="id-reserved-fn-names"/>.</p><p>A function named "if" can be called by binding its namespace to a prefix and using the
          prefixed form: "library:if(foo)" instead of "if(foo)".</p></constraintnote><constraintnote id="parse-note-occurrence-indicators" type="xgc"><head>occurrence-indicators</head><p>As written, the grammar in <specref ref="nt-bnf"/> is ambiguous for some forms using the
          '+' and '*' occurrence indicators. The ambiguity is resolved as follows: these operators are
          tightly bound to the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SequenceType" xlink:type="simple">SequenceType</nt> expression, and have higher
          precedence than other uses of these symbols. Any occurrence of '+' and '*', as well as
          '?', following a sequence type is assumed to be an occurrence indicator, which binds to
          the last <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ItemType" xlink:type="simple">ItemType</nt> in the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SequenceType" xlink:type="simple">SequenceType</nt>.</p><p>Thus, <code role="parse-test">4 treat as item() + - 5</code> must be interpreted as <code role="parse-test">(4 treat as item()+) - 5</code>, taking the '+' as an
          OccurrenceIndicator and the '-' as a subtraction operator. To force the interpretation of
          "+" as an addition operator (and the corresponding interpretation of the "-" as a unary
          minus), parentheses may be used: the form <code role="parse-test">(4 treat as item()) +
            -5</code> surrounds the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SequenceType" xlink:type="simple">SequenceType</nt> expression with
          parentheses and leads to the desired interpretation.</p><p>
                     <code>function () as xs:string *</code> is interpreted as <code>function () as (xs:string
            *)</code>, not as <code>(function () as xs:string) *</code>. Parentheses can be used as
          shown to force the latter interpretation.</p><p>This rule has as a consequence that certain forms which would otherwise be syntactically
          valid and unambiguous are not recognized: in "4 treat as item() + 5", the "+" is taken as
          an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>, and not as an operator, which
          means this is not a syntactically valid expression.</p></constraintnote></div3><div3 id="notes-on-parsing"><head>Grammar Notes</head><p>This section contains general notes on the EBNF productions, which may be helpful in
        understanding how to interpret and implement the EBNF. These notes are not normative. The
        notes below are referenced from the right side of the production, with the notation:
          <emph>/* gn: &lt;id&gt; */</emph>.</p><note><glist><gitem id="parse-note-parens"><label>grammar-note: parens</label><def><p>Look-ahead is required to distinguish <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-FunctionCall" xlink:type="simple">FunctionCall</nt> from
                a EQName or keyword followed by a 
                <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Comment" xlink:type="simple">Comment</nt>. For example: <code role="parse-test">address (: this
                  may be empty :)</code> may be mistaken for a call to a function named "address"
                unless this lookahead is employed. Another example is <code role="parse-test">for (:
                  whom the bell :) $tolls in 3 return $tolls</code>, where the keyword "for" must
                not be mistaken for a function name.</p></def></gitem><gitem id="parse-note-comments"><label>grammar-note: comments</label><def><p>Comments are allowed everywhere that <termref def="IgnorableWhitespace">ignorable
                  whitespace</termref> is allowed, and the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Comment" xlink:type="simple">Comment</nt> symbol
                does not explicitly appear on the right-hand side of the grammar (except in its own
                production). See <specref ref="DefaultWhitespaceHandling"/>. </p><p>A comment can contain nested comments, as long as all "(:" and ":)" patterns are
                balanced, no matter where they occur within the outer comment.</p><note><p>Lexical analysis may typically handle nested comments by incrementing a counter
                  for each "(:" pattern, and decrementing the counter for each ":)" pattern. The
                  comment does not terminate until the counter is back to zero.</p></note><p>Some illustrative examples:</p><ulist><item><p>
                                    <code>(: commenting out a (: comment :) may be confusing, but often helpful
                      :)</code> is a syntactically valid Comment, since balanced nesting of comments
                    is allowed.</p></item><item><p>
                                    <code role="parse-test">"this is just a string :)"</code> is a syntactically
                    valid expression. However, <code>(: "this is just a string :)" :)</code> will
                    cause a syntax error. Likewise, <code role="parse-test">"this is another string
                      (:"</code> is a syntactically valid expression, but <code>(: "this is another
                      string (:" :)</code> will cause a syntax error. It is a limitation of nested
                    comments that literal content can cause unbalanced nesting of comments.</p></item><item><p>
                                    <code role="parse-test">for (: set up loop :) $i in $x return $i</code> is
                    syntactically valid, ignoring the comment.</p></item><item><p>
                                    <code role="parse-test">5 instance (: strange place for a comment :) of
                      xs:integer</code> is also syntactically valid.</p></item></ulist></def></gitem></glist></note></div3></div2><div2 id="lexical-structure"><head>Lexical structure</head><p>The terminal symbols assumed by the grammar above are described in this section.</p><p>Quoted strings appearing in production rules are terminal symbols.</p><p>Other terminal symbols are defined in <specref ref="terminal-symbols"/>.</p><p>Some productions are defined by reference to the XML and XML Names specifications (e.g.
        <bibref ref="XML"/> and <bibref ref="XMLNAMES"/>, or <bibref ref="XML1.1"/> and <bibref ref="XMLNAMES11"/> . <phrase role="xpath">A host language may choose</phrase> which version of these specifications is
      used; it is recommended that the latest applicable version be used (even if it is published
      later than this specification).</p><p role="xpath">A <term>host language</term> may choose whether the lexical rules of <bibref ref="XML"/> and <bibref ref="XMLNAMES"/> are followed, or alternatively, the lexical rules
      of <bibref ref="XML1.1"/> and <bibref ref="XMLNAMES11"/> are followed.</p><p>When tokenizing, the longest possible match that is consistent with the EBNF is used.</p><p>All keywords are case sensitive. Keywords are not reserved—that is, any <termref def="dt-qname">lexical QName</termref> may duplicate a keyword except as noted in <specref ref="id-reserved-fn-names"/>.</p><div3 id="terminal-symbols"><head>Terminal Symbols</head><scrap headstyle="show"><head/><prod num="113" id="prod-xpath31-IntegerLiteral"><lhs>IntegerLiteral</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-Digits" xlink:type="simple">Digits</nt>
                     </rhs></prod><prod num="114" id="prod-xpath31-DecimalLiteral"><lhs>DecimalLiteral</lhs><rhs>("."  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-Digits" xlink:type="simple">Digits</nt>)  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-Digits" xlink:type="simple">Digits</nt>  "."  [0-9]*)</rhs><com>
                        <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc>
                     </com></prod><prod num="115" id="prod-xpath31-DoubleLiteral"><lhs>DoubleLiteral</lhs><rhs>(("."  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-Digits" xlink:type="simple">Digits</nt>)  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-Digits" xlink:type="simple">Digits</nt>  ("."  [0-9]*)?))  [eE]  [+-]?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-Digits" xlink:type="simple">Digits</nt>
                     </rhs><com>
                        <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc>
                     </com></prod><prod num="116" id="prod-xpath31-StringLiteral"><lhs>StringLiteral</lhs><rhs>('"'  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-EscapeQuot" xlink:type="simple">EscapeQuot</nt>  |  [^"])*  '"')  |  ("'"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-EscapeApos" xlink:type="simple">EscapeApos</nt>  |  [^'])*  "'")</rhs><com>
                        <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc>
                     </com></prod><prod num="117" id="prod-xpath31-URIQualifiedName"><lhs>URIQualifiedName</lhs><rhs>
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-BracedURILiteral" xlink:type="simple">BracedURILiteral</nt>  
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-NCName" xlink:type="simple">NCName</nt>
                     </rhs><com>
                        <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc>
                     </com></prod><prod num="118" id="prod-xpath31-BracedURILiteral"><lhs>BracedURILiteral</lhs><rhs>"Q"  "{"  [^{}]*  "}"</rhs><com>
                        <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc>
                     </com></prod><prod num="119" id="prod-xpath31-EscapeQuot"><lhs>EscapeQuot</lhs><rhs>'""'</rhs></prod><prod num="120" id="prod-xpath31-EscapeApos"><lhs>EscapeApos</lhs><rhs>"''"</rhs></prod><prod num="121" id="prod-xpath31-Comment"><lhs>Comment</lhs><rhs>"(:"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-CommentContents" xlink:type="simple">CommentContents</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-Comment" xlink:type="simple">Comment</nt>)*  ":)"</rhs><com>
                        <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc>
                     </com><com>
                        <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-comments" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">gn: comments</loc>
                     </com></prod><prod num="122" id="prod-xpath31-QName"><lhs>QName</lhs><rhs>
                        <xnt xmlns:xlink="http://www.w3.org/1999/xlink" ref="NT-QName" spec="Names" xlink:type="simple">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</xnt>
                     </rhs><com>
                        <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgc: xml-version</loc>
                     </com></prod><prod num="123" id="prod-xpath31-NCName"><lhs>NCName</lhs><rhs>
                        <xnt xmlns:xlink="http://www.w3.org/1999/xlink" ref="NT-NCName" spec="Names" xlink:type="simple">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</xnt>
                     </rhs><com>
                        <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgc: xml-version</loc>
                     </com></prod><prod num="124" id="prod-xpath31-Char"><lhs>Char</lhs><rhs>
                        <xnt xmlns:xlink="http://www.w3.org/1999/xlink" ref="NT-Char" spec="XML" xlink:type="simple">[http://www.w3.org/TR/REC-xml#NT-Char]</xnt>
                     </rhs><com>
                        <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgc: xml-version</loc>
                     </com></prod></scrap><p>The following symbols are used only in the definition of terminal symbols; they are not
        terminal symbols in the grammar of <specref ref="id-grammar"/>.</p><scrap headstyle="show"><head/><prod num="125" id="prod-xpath31-Digits"><lhs>Digits</lhs><rhs>[0-9]+</rhs></prod><prod num="126" id="prod-xpath31-CommentContents"><lhs>CommentContents</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-Char" xlink:type="simple">Char</nt>+ - (Char* ('(:' | ':)') Char*))</rhs></prod></scrap></div3><div3 id="id-terminal-delimitation"><head>Terminal Delimitation</head><p>XPath 3.1 expressions consist of <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#terminal-symbols" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">terminal symbols</loc> and
          <termref def="symbolseparators">symbol separators</termref>.</p><p>Terminal symbols that are not used exclusively in <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">/* ws: explicit
          */</loc> productions are of two kinds: delimiting and non-delimiting.</p><!-- The next paragraph is "filled in" by various stylesheets used to generate the "assembled" source files. --><p>
                  <termdef id="delimiting-token" term="delimiting terminal symbol">The <term>delimiting
            terminal symbols</term> are: "!", "!=", <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-StringLiteral" xlink:type="simple">StringLiteral</nt>, "#", "$", "(", ")", "*", "*:", "+", (comma), "-", (dot), "..", "/", "//", (colon), ":*", "::", ":=", "&lt;", "&lt;&lt;", "&lt;=", "=", "=&gt;", "&gt;", "&gt;=", "&gt;&gt;", "?", "@", <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-BracedURILiteral" xlink:type="simple">BracedURILiteral</nt>, "[", "]", "{", "|", "||", "}"
                  </termdef>
               </p><!-- The next paragraph is "filled in" by various stylesheets used to generate the "assembled" source files. --><p>
                  <termdef id="non-delimiting-token" term="non-delimiting terminal symbol">The
            <term>non-delimiting terminal symbols</term> are: <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-IntegerLiteral" xlink:type="simple">IntegerLiteral</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-URIQualifiedName" xlink:type="simple">URIQualifiedName</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-NCName" xlink:type="simple">NCName</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-DecimalLiteral" xlink:type="simple">DecimalLiteral</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-DoubleLiteral" xlink:type="simple">DoubleLiteral</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath31-QName" xlink:type="simple">QName</nt>, "ancestor", "ancestor-or-self", "and", "array", "as", "attribute", "cast", "castable", "child", "comment", "descendant", "descendant-or-self", "div", "document-node", "element", "else", "empty-sequence", "eq", "every", "except", "following", "following-sibling", "for", "function", "ge", "gt", "idiv", "if", "in", "instance", "intersect", "is", "item", "le", "let", "lt", "map", "mod", "namespace", "namespace-node", "ne", "node", "of", "or", "parent", "preceding", "preceding-sibling", "processing-instruction", "return", "satisfies", "schema-attribute", "schema-element", "self", "some", "text", "then", "to", "treat", "union"
                  </termdef>
               </p><p>
                  <termdef id="symbolseparators" term="symbol separators">
                     <termref def="Whitespace">Whitespace</termref> and <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Comment" xlink:type="simple">Comments</nt>
          function as <term>symbol separators</term>. For the most part, they are not mentioned in
          the grammar, and may occur between any two terminal symbols mentioned in the grammar,
          except where that is forbidden by the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">/* ws: explicit */</loc>
          annotation in the EBNF, or by the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">/* xgc: xml-version
            */</loc> annotation.</termdef>
               </p><p diff="del">It is customary to separate consecutive terminal symbols by <termref def="Whitespace">whitespace</termref> and <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Comment" xlink:type="simple">Comments</nt>, but this is required only when
        otherwise two non-delimiting symbols would be adjacent to each other. There are two
        exceptions to this, that of "." and "-", which do require a <termref def="symbolseparators">symbol separator</termref> if they follow a QName or NCName. Also, "." requires a
        separator if it precedes or follows a numeric literal.</p><p diff="add">
        One or more <termref def="symbolseparators">symbol separators</termref>
        are required between two consecutive terminal symbols
        T and U (where T precedes U) when any of the following is true:
      </p><ulist diff="add"><item><p>T and U are both <termref def="non-delimiting-token">non-delimiting terminal symbols</termref>.</p></item><item><p>T is a QName or an NCName and U is "." or "-".</p></item><item><p>T is a numeric literal and U is ".", or vice versa.</p></item></ulist></div3><div3 id="id-eol-handling"><head>End-of-Line Handling</head><p role="xpath">The host language must specify whether the XPath 3.1 processor normalizes all
        line breaks on input, before parsing, and if it does so, whether it uses the rules of
          <bibref ref="XML"/> or <bibref ref="XML1.1"/>. </p><div4 id="id-xml10-eol-handling"><head>XML 1.0 End-of-Line Handling</head><p>For <bibref ref="XML"/> processing, all of the following must be translated to a single
          #xA character:</p><olist><item><p>the two-character sequence #xD #xA</p></item><item><p>any #xD character that is not immediately followed by #xA.</p></item></olist></div4><div4 id="id-xml11-eol-handling"><head>XML 1.1 End-of-Line Handling</head><p>For <bibref ref="XML1.1"/> processing, all of the following must be translated to a
          single #xA character:</p><olist><item><p>the two-character sequence #xD #xA</p></item><item><p>the two-character sequence #xD #x85</p></item><item><p>the single character #x85</p></item><item><p>the single character #x2028</p></item><item><p>any #xD character that is not immediately followed by #xA or #x85.</p></item></olist></div4></div3><div3 id="whitespace-rules"><head>Whitespace Rules</head><div4 id="DefaultWhitespaceHandling"><head>Default Whitespace Handling</head><p>
                     <termdef id="Whitespace" term="whitespace">A <term>whitespace</term> character is any of
            the characters defined by <xnt xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/REC-xml/#NT-S" xlink:type="simple">
              [http://www.w3.org/TR/REC-xml/#NT-S]</xnt>.</termdef>
                  </p><p>
                     <termdef term="ignorable whitespace" id="IgnorableWhitespace">
                        <term>Ignorable whitespace</term> consists of any <termref def="Whitespace">whitespace</termref> characters that may occur between <termref def="terminal">terminals</termref>, unless these characters occur in the context of a production
            marked with a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ExplicitWhitespaceHandling" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"> ws:explicit</loc> annotation, in
            which case they can occur only where explicitly specified (see <specref ref="ExplicitWhitespaceHandling"/>).</termdef> Ignorable whitespace characters are not
          significant to the semantics of an expression. Whitespace is allowed before the first
          terminal and after the last terminal <phrase role="xpath">of an XPath expression</phrase>. Whitespace is allowed between any two <termref def="terminal">terminals</termref>. <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Comment" xlink:type="simple">Comments</nt> may also act as
          "whitespace" to prevent two adjacent terminals from being recognized as one. Some
          illustrative examples are as follows:</p><ulist><item><p>
                           <code>foo- foo</code> results in a syntax error. "foo-" would be recognized as a
              QName.</p></item><item><p>
                           <code role="parse-test">foo -foo</code> is syntactically equivalent to <code role="parse-test">foo - foo</code>, two QNames separated by a subtraction
              operator.</p></item><item><p>
                           <code role="parse-test">foo(: This is a comment :)- foo</code> is syntactically
              equivalent to <code>foo - foo</code>. This is because the comment prevents the two
              adjacent terminals from being recognized as one.</p></item><item><p>
                           <code role="parse-test">foo-foo</code> is syntactically equivalent to single QName.
              This is because "-" is a valid character in a QName. When used as an operator after
              the characters of a name, the "-" must be separated from the name, e.g. by using
              whitespace or parentheses.</p></item><item><p>
                           <code>10div 3</code> results in a syntax error.</p></item><item><p>
                           <code>10 div3</code> also results in a syntax error.</p></item><item><p>
                           <code>10div3</code> also results in a syntax error.</p></item></ulist></div4><div4 id="ExplicitWhitespaceHandling"><head>Explicit Whitespace Handling</head><p>Explicit whitespace notation is specified with the EBNF productions, when it is different
          from the default rules, using the notation shown below. This notation is not inherited. In
          other words, if an EBNF rule is marked as /* ws: explicit */, the notation does not
          automatically apply to all the 'child' EBNF productions of that rule.</p><glist><gitem id="ws-explicit"><label>ws: explicit</label><def><p>/* ws: explicit */ means that the EBNF notation explicitly notates, with
                  <code>S</code> or otherwise, where <termref def="Whitespace">whitespace
                  characters</termref> are allowed. In productions with the /* ws: explicit */
                  annotation, <specref ref="DefaultWhitespaceHandling"/> does not apply.
		  Comments are <phrase diff="del" at="bug29700">also</phrase> not allowed in these productions <phrase diff="add" at="bug29700">except where the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Comment" xlink:type="simple">Comment</nt> non-terminal appears</phrase>.
	      </p></def></gitem></glist></div4></div3></div2><div2 id="id-reserved-fn-names"><head>Reserved Function Names</head><p>The following names are not allowed as function names in an unprefixed form because
      expression syntax takes precedence.</p><!-- Note to editors: This list is (or should be) in alphabetical order. --><ulist><item><p diff="add">
                     <code>array</code>
                  </p></item><item><p>
                     <code>attribute</code>
                  </p></item><item><p>
                     <code>comment</code>
                  </p></item><item><p>
                     <code>document-node</code>
                  </p></item><item><p>
                     <code>element</code>
                  </p></item><item><p>
                     <code>empty-sequence</code>
                  </p></item><item><p>
                     <code>function</code>
                  </p></item><item><p>
                     <code>if</code>
                  </p></item><item><p>
                     <code>item</code>
                  </p></item><item><p diff="add">
                     <code>map</code>
                  </p></item><item><p>
                     <code>namespace-node</code>
                  </p></item><item><p>
                     <code>node</code>
                  </p></item><item><p>
                     <code>processing-instruction</code>
                  </p></item><item><p>
                     <code>schema-attribute</code>
                  </p></item><item><p>
                     <code>schema-element</code>
                  </p></item><item><p>
                     <code>switch</code>
                  </p></item><item><p>
                     <code>text</code>
                  </p></item><item><p>
                     <code>typeswitch</code>
                  </p></item></ulist><note role="xpath"><p> Although the keywords <code>switch</code> and <code>typeswitch</code> are not used in
        XPath, they are considered reserved function names for compatibility with XQuery. </p></note></div2><div2 id="id-precedence-order"><head>Precedence Order (Non-Normative)</head><p>The grammar in <specref ref="id-grammar"/> normatively defines built-in precedence among the
      operators of <phrase role="xpath">XPath</phrase>. These operators are summarized here to make clear the order of their
      precedence from lowest to highest. The associativity column indicates the order in which
      operators of equal precedence in an expression are applied.</p><table role="medium"><tbody><tr><th rowspan="1" colspan="1">#</th><th rowspan="1" colspan="1">Operator</th><th rowspan="1" colspan="1">Associativity</th></tr><tr><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Expr" xlink:type="simple">, (comma)</nt>
                     </td><td rowspan="1" colspan="1">either</td></tr><tr><td rowspan="1" colspan="1">2</td><td rowspan="1" colspan="1">
                        <phrase role="xpath">
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ForExpr" xlink:type="simple">for</nt>,</phrase>
                        <phrase role="xpath">
                           <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-LetExpr" xlink:type="simple">let</nt>,</phrase>
            
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-QuantifiedExpr" xlink:type="simple">some, every</nt>, 
            
            
            <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-IfExpr" xlink:type="simple">if</nt>
                     </td><td rowspan="1" colspan="1">NA</td></tr><tr><td rowspan="1" colspan="1">3</td><td rowspan="1" colspan="1">
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-OrExpr" xlink:type="simple">or</nt>
                     </td><td rowspan="1" colspan="1">either</td></tr><tr><td rowspan="1" colspan="1">4</td><td rowspan="1" colspan="1">
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AndExpr" xlink:type="simple">and</nt>
                     </td><td rowspan="1" colspan="1">either</td></tr><tr><td rowspan="1" colspan="1">5</td><td rowspan="1" colspan="1">
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ValueComp" xlink:type="simple">eq, ne, lt, le, gt, ge</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-GeneralComp" xlink:type="simple">=, !=, &lt;,
              &lt;=, &gt;, &gt;=</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-NodeComp" xlink:type="simple">is, &lt;&lt;, &gt;&gt;</nt>
                     </td><td rowspan="1" colspan="1">NA</td></tr><tr><td rowspan="1" colspan="1">6</td><td rowspan="1" colspan="1">
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-StringConcatExpr" xlink:type="simple">||</nt>
                     </td><td rowspan="1" colspan="1">left-to-right</td></tr><tr><td rowspan="1" colspan="1">7</td><td rowspan="1" colspan="1">
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-RangeExpr" xlink:type="simple">to</nt>
                     </td><td rowspan="1" colspan="1">NA</td></tr><tr><td rowspan="1" colspan="1">8</td><td rowspan="1" colspan="1">
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AdditiveExpr" xlink:type="simple">+, - (binary)</nt>
                     </td><td rowspan="1" colspan="1">left-to-right</td></tr><tr><td rowspan="1" colspan="1">9</td><td rowspan="1" colspan="1">
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-MultiplicativeExpr" xlink:type="simple">*, div, idiv, mod</nt>
                     </td><td rowspan="1" colspan="1">left-to-right</td></tr><tr><td rowspan="1" colspan="1">10</td><td rowspan="1" colspan="1">
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-UnionExpr" xlink:type="simple">union, |</nt>
                     </td><td rowspan="1" colspan="1">either</td></tr><tr><td rowspan="1" colspan="1">11</td><td rowspan="1" colspan="1">
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-IntersectExceptExpr" xlink:type="simple">intersect, except</nt>
                     </td><td rowspan="1" colspan="1">left-to-right</td></tr><tr><td rowspan="1" colspan="1">12</td><td rowspan="1" colspan="1">
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-InstanceofExpr" xlink:type="simple">instance of</nt>
                     </td><td rowspan="1" colspan="1">NA</td></tr><tr><td rowspan="1" colspan="1">13</td><td rowspan="1" colspan="1">
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TreatExpr" xlink:type="simple">treat as</nt>
                     </td><td rowspan="1" colspan="1">NA</td></tr><tr><td rowspan="1" colspan="1">14</td><td rowspan="1" colspan="1">
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-CastableExpr" xlink:type="simple">castable as</nt>
                     </td><td rowspan="1" colspan="1">NA</td></tr><tr><td rowspan="1" colspan="1">15</td><td rowspan="1" colspan="1">
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-CastExpr" xlink:type="simple">cast as</nt>
                     </td><td rowspan="1" colspan="1">NA</td></tr><tr><td diff="add" rowspan="1" colspan="1">16</td><td diff="add" rowspan="1" colspan="1">
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ArrowExpr" xlink:type="simple">=&gt;</nt>
                     </td><td diff="add" rowspan="1" colspan="1">left-to-right</td></tr><tr><td diff="chg" rowspan="1" colspan="1">17</td><td rowspan="1" colspan="1">
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-UnaryExpr" xlink:type="simple">-, + (unary)</nt>
                     </td><td rowspan="1" colspan="1">right-to-left</td></tr><tr><td diff="chg" rowspan="1" colspan="1">18</td><td rowspan="1" colspan="1">
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SimpleMapExpr" xlink:type="simple">!</nt>
                     </td><td rowspan="1" colspan="1">left-to-right</td></tr><tr><td diff="chg" rowspan="1" colspan="1">19</td><td rowspan="1" colspan="1">
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-PathExpr" xlink:type="simple">/, //</nt>
                     </td><td rowspan="1" colspan="1">left-to-right</td></tr><!--        <tr diff="chg" at="XQ.E26 and XP.E18"> --><tr><td diff="chg" rowspan="1" colspan="1">20</td><td diff="chg" at="bug29118" rowspan="1" colspan="1">
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Predicate" xlink:type="simple">[ ]</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-Lookup" xlink:type="simple">?</nt>
                     </td><td rowspan="1" colspan="1">left-to-right</td></tr><tr><td diff="chg" rowspan="1" colspan="1">21</td><td diff="chg" at="bug29891" rowspan="1" colspan="1">
                        <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-UnaryLookup" xlink:type="simple">? (unary)</nt>
                     </td><td rowspan="1" colspan="1">NA</td></tr></tbody></table><p> In the "Associativity" column, "either" indicates that all the operators at that level have
      the associative property (i.e., <code>(A op B) op C</code> is equivalent to <code>A op (B op
        C)</code>), so their associativity is inconsequential. "NA" (not applicable) indicates that
      the EBNF does not allow an expression that directly contains multiple operators from that
      precedence level, so the question of their associativity does not arise. </p><note><p>Parentheses can be used to override the operator precedence in the usual way. Square
        brackets in an expression such as A[B] serve two roles: they act as an operator causing B to
        be evaluated once for each item in the value of A, and they act as parentheses enclosing the
        expression B.</p></note></div2></div1><div1 id="id-type-promotion-and-operator-mapping"><head>Type Promotion and Operator Mapping</head><div2 id="promotion"><head>Type Promotion</head><p>
               <termdef term="type promotion" id="dt-type-promotion">Under certain circumstances, an atomic value can be promoted from
one type to another. <term>Type promotion</term> is used in evaluating function calls (see <specref ref="id-eval-function-call"/>)  and operators that accept numeric or string operands (see <specref ref="mapping"/>).</termdef> The following type promotions are permitted:</p><olist><item><p>Numeric type promotion:</p><olist><item><p>A value of type <code>xs:float</code> (or any type
derived by restriction from <code>xs:float</code>) can be promoted to
the type <code>xs:double</code>. The result is the
<code>xs:double</code> value that is the same as the original
value.</p></item><item><p>A value of type <code>xs:decimal</code> (or any type derived
by restriction from <code>xs:decimal</code>) can be promoted to either
of the types <code>xs:float</code> or <code>xs:double</code>.  The
result of this promotion is created by casting the original value to
the required type. This kind of promotion may cause loss of
precision.</p></item></olist></item><item><p>URI type promotion: A value of type <code>xs:anyURI</code> (or any type derived by restriction from <code>xs:anyURI</code>) can be promoted to the type <code>xs:string</code>. The result of this promotion is created by casting the original value to the type <code>xs:string</code>.</p><note><p>Since <code>xs:anyURI</code> values can be promoted to <code>xs:string</code>, functions and operators that compare strings using the <termref def="dt-def-collation">default collation</termref> also compare <code>xs:anyURI</code> values using the <termref def="dt-def-collation">default collation</termref>. This ensures that orderings that include strings, <code>xs:anyURI</code> values, or any combination of the two types are consistent and well-defined.</p></note></item></olist><p>Note that <termref def="dt-type-promotion">type promotion</termref> is different from <termref def="dt-subtype-substitution">subtype substitution</termref>. For example:</p><ulist><item><p>A function that expects a parameter <code>$p</code> of type <code>xs:float</code> can be invoked with a value of type <code>xs:decimal</code>. This is an example of <termref def="dt-type-promotion">type promotion</termref>. The value is actually converted to the expected type. Within the body of the function, <code>$p instance of xs:decimal</code> returns <code>false</code>.</p></item><item><p>A function that expects a parameter <code>$p</code> of type <code>xs:decimal</code> can be invoked with a value of type <code>xs:integer</code>. This is an example of <termref def="dt-subtype-substitution">subtype substitution</termref>. The value retains its original type. Within the body of the function, <code>$p instance of xs:integer</code> returns <code>true</code>.</p></item></ulist></div2><div2 id="mapping"><head>Operator Mapping</head><p>The operator mapping tables in this section list the
combinations of types for which the various operators of XPath 3.1
are defined. <termdef term="operator function" id="dt-operator-function">For each operator and valid combination of operand types, the operator mapping tables specify a result type and an <term>operator function</term> that implements the semantics of the operator for the given types.</termdef> The definitions of the operator functions are given in  <bibref ref="xpath-functions-31"/>. The result of an operator may be the raising of an error by its operator function, as defined in <bibref ref="xpath-functions-31"/>. The operator function fully defines the semantics of a given operator for the case where the operands are single atomic values of the types given in the table. For the definition of each operator (including its
behavior for empty sequences or sequences of length greater than one),
see the descriptive material in the main part of this
document.</p><p>The <code>and</code> and
<code>or</code> operators are defined directly in the main body of
this document, and do not occur in the operator mapping tables.</p><p>If an operator in the operator mapping tables expects an operand of type
<emph>ET</emph>, that operator can be applied to an operand of type <emph>AT</emph> if type <emph>AT</emph> can
be converted to type <emph>ET</emph> by a combination of <termref def="dt-type-promotion">type promotion</termref> and <termref def="dt-subtype-substitution">subtype substitution</termref>. For example, a table entry indicates that the <code>gt</code> operator may
be applied to two <code>xs:date</code> operands, returning
<code>xs:boolean</code>. Therefore, the <code>gt</code> operator may
also be applied to two (possibly different) subtypes of
<code>xs:date</code>, also returning <code>xs:boolean</code>.</p><p>
               <termdef id="dt-numeric" term="numeric">When referring to a type, the term <term>numeric</term> denotes the types
<code>xs:integer</code>, <code>xs:decimal</code>,
<code>xs:float</code>, and <code>xs:double</code>
                  <phrase diff="add" at="2014-11-11">which are all member types of the built-in union type <code>xs:numeric</code>
                  </phrase>.</termdef> An operator whose
operands and result are designated as <termref def="dt-numeric">numeric</termref> might be
thought of as representing four operators, one for each of the numeric
types. For example, the numeric <code>+</code> operator might be
thought of as representing the following four operators:</p><table width="80%" role="medium"><tbody><tr><th align="center" rowspan="1" colspan="1">Operator</th><th align="center" rowspan="1" colspan="1">First operand type</th><th align="center" rowspan="1" colspan="1">Second operand type</th><th align="center" rowspan="1" colspan="1">Result type</th></tr><tr><td align="center" rowspan="1" colspan="1">
                        <code>+</code>
                     </td><td align="center" rowspan="1" colspan="1">
                        <code>xs:integer</code>
                     </td><td align="center" rowspan="1" colspan="1">
                        <code>xs:integer</code>
                     </td><td align="center" rowspan="1" colspan="1">
                        <code>xs:integer</code>
                     </td></tr><tr><td align="center" rowspan="1" colspan="1">
                        <code>+</code>
                     </td><td align="center" rowspan="1" colspan="1">
                        <code>xs:decimal</code>
                     </td><td align="center" rowspan="1" colspan="1">
                        <code>xs:decimal</code>
                     </td><td align="center" rowspan="1" colspan="1">
                        <code>xs:decimal</code>
                     </td></tr><tr><td align="center" rowspan="1" colspan="1">
                        <code>+</code>
                     </td><td align="center" rowspan="1" colspan="1">
                        <code>xs:float</code>
                     </td><td align="center" rowspan="1" colspan="1">
                        <code>xs:float</code>
                     </td><td align="center" rowspan="1" colspan="1">
                        <code>xs:float</code>
                     </td></tr><tr><td align="center" rowspan="1" colspan="1">
                        <code>+</code>
                     </td><td align="center" rowspan="1" colspan="1">
                        <code>xs:double</code>
                     </td><td align="center" rowspan="1" colspan="1">
                        <code>xs:double</code>
                     </td><td align="center" rowspan="1" colspan="1">
                        <code>xs:double</code>
                     </td></tr></tbody></table><p>A numeric operator may be validly applied to an operand of type <emph>AT</emph> if type
<emph>AT</emph> can be converted to any of the four numeric types by a combination of
<termref def="dt-type-promotion">type promotion</termref> and <termref def="dt-subtype-substitution">subtype substitution</termref>. If the result type of an
operator is listed as numeric, it means "the first type in the ordered list <code>(xs:integer, xs:decimal, xs:float, xs:double)</code> into which all operands can be converted by <termref def="dt-subtype-substitution">subtype substitution</termref> and <termref def="dt-type-promotion">type promotion</termref>." As an example, suppose that the type <code>hatsize</code> is derived from <code>xs:integer</code> and the type <code>shoesize</code> is derived from <code>xs:float</code>.   Then if the <code>+</code> operator is invoked with operands of type <code>hatsize</code> and <code>shoesize</code>, it returns a result of type <code>xs:float</code>.  Similarly, if <code>+</code> is invoked with two operands of type <code>hatsize</code> it returns a result of type <code>xs:integer</code>.</p><p>
               <termdef id="dt-gregorian" term="Gregorian">In the operator mapping tables,
the term <term>Gregorian</term> refers to the types
<code>xs:gYearMonth</code>, <code>xs:gYear</code>,
<code>xs:gMonthDay</code>, <code>xs:gDay</code>, and
<code>xs:gMonth</code>.</termdef>  For binary operators that accept two
Gregorian-type operands, both operands must have the same type (for
example, if one operand is of type <code>xs:gDay</code>, the other
operand must be of type <code>xs:gDay</code>.)</p><table border="1" role="small"><caption>Binary Operators</caption><tbody><tr><th rowspan="1" colspan="1">Operator</th><th rowspan="1" colspan="1">Type(A)</th><th rowspan="1" colspan="1">Type(B)</th><th rowspan="1" colspan="1">Function</th><th rowspan="1" colspan="1">Result type</th></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:numeric-add(A, B)</td><td rowspan="1" colspan="1">numeric</td></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:add-yearMonthDuration-to-date(A, B)</td><td rowspan="1" colspan="1">xs:date</td></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">op:add-yearMonthDuration-to-date(B, A)</td><td rowspan="1" colspan="1">xs:date</td></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:add-dayTimeDuration-to-date(A, B)</td><td rowspan="1" colspan="1">xs:date</td></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">op:add-dayTimeDuration-to-date(B, A)</td><td rowspan="1" colspan="1">xs:date</td></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:add-dayTimeDuration-to-time(A, B)</td><td rowspan="1" colspan="1">xs:time</td></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">op:add-dayTimeDuration-to-time(B, A)</td><td rowspan="1" colspan="1">xs:time</td></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:add-yearMonthDuration-to-dateTime(A, B)</td><td rowspan="1" colspan="1">xs:dateTime</td></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">op:add-yearMonthDuration-to-dateTime(B, A)</td><td rowspan="1" colspan="1">xs:dateTime</td></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:add-dayTimeDuration-to-dateTime(A, B)</td><td rowspan="1" colspan="1">xs:dateTime</td></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">op:add-dayTimeDuration-to-dateTime(B, A)</td><td rowspan="1" colspan="1">xs:dateTime</td></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:add-yearMonthDurations(A, B)</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:add-dayTimeDurations(A, B)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr><tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:numeric-subtract(A, B)</td><td rowspan="1" colspan="1">numeric</td></tr><tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">op:subtract-dates(A, B)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr><tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:subtract-yearMonthDuration-from-date(A, B)</td><td rowspan="1" colspan="1">xs:date</td></tr><tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:subtract-dayTimeDuration-from-date(A, B)</td><td rowspan="1" colspan="1">xs:date</td></tr><tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">op:subtract-times(A, B)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr><tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:subtract-dayTimeDuration-from-time(A, B)</td><td rowspan="1" colspan="1">xs:time</td></tr><tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">op:subtract-dateTimes(A, B)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr><tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:subtract-yearMonthDuration-from-dateTime(A, B)</td><td rowspan="1" colspan="1">xs:dateTime</td></tr><tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:subtract-dayTimeDuration-from-dateTime(A, B)</td><td rowspan="1" colspan="1">xs:dateTime</td></tr><tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:subtract-yearMonthDurations(A, B)</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td></tr><tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:subtract-dayTimeDurations(A, B)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr><tr><td rowspan="1" colspan="1">A * B</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:numeric-multiply(A, B)</td><td rowspan="1" colspan="1">numeric</td></tr><tr><td rowspan="1" colspan="1">A * B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:multiply-yearMonthDuration(A, B)</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td></tr><tr><td rowspan="1" colspan="1">A * B</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:multiply-yearMonthDuration(B, A)</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td></tr><tr><td rowspan="1" colspan="1">A * B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:multiply-dayTimeDuration(A, B)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr><tr><td rowspan="1" colspan="1">A * B</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:multiply-dayTimeDuration(B, A)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr><tr><td rowspan="1" colspan="1">A idiv B</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:numeric-integer-divide(A, B)</td><td rowspan="1" colspan="1">xs:integer</td></tr><tr><td rowspan="1" colspan="1">A div B</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:numeric-divide(A, B)</td><td rowspan="1" colspan="1">numeric; but xs:decimal if both operands are xs:integer</td></tr><tr><td rowspan="1" colspan="1">A div B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:divide-yearMonthDuration(A, B)</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td></tr><tr><td rowspan="1" colspan="1">A div B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:divide-dayTimeDuration(A, B)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr><tr><td rowspan="1" colspan="1">A div B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:divide-yearMonthDuration-by-yearMonthDuration (A, B)</td><td rowspan="1" colspan="1">xs:decimal</td></tr><tr><td rowspan="1" colspan="1">A div B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:divide-dayTimeDuration-by-dayTimeDuration (A, B)</td><td rowspan="1" colspan="1">xs:decimal</td></tr><tr><td rowspan="1" colspan="1">A mod B</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:numeric-mod(A, B)</td><td rowspan="1" colspan="1">numeric</td></tr><tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:numeric-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">op:boolean-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">op:numeric-equal(fn:compare(A, B), 0)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">op:date-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">op:time-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">op:dateTime-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:duration</td><td rowspan="1" colspan="1">xs:duration</td><td rowspan="1" colspan="1">op:duration-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">Gregorian</td><td rowspan="1" colspan="1">Gregorian</td><td rowspan="1" colspan="1">op:gYear-equal(A, B) etc.</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:hexBinary</td><td rowspan="1" colspan="1">xs:hexBinary</td><td rowspan="1" colspan="1">op:hexBinary-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:base64Binary</td><td rowspan="1" colspan="1">xs:base64Binary</td><td rowspan="1" colspan="1">op:base64Binary-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr diff="del"><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">op:numeric-equal(fn:compare(A, B), 0)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:QName</td><td rowspan="1" colspan="1">xs:QName</td><td rowspan="1" colspan="1">op:QName-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:NOTATION</td><td rowspan="1" colspan="1">xs:NOTATION</td><td rowspan="1" colspan="1">op:NOTATION-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr diff="add" at="2014-04-08"><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:hexBinary</td><td rowspan="1" colspan="1">xs:hexBinary</td><td rowspan="1" colspan="1">op:hexBinary-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr diff="add" at="2014-04-08"><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:base64Binary</td><td rowspan="1" colspan="1">xs:base64Binary</td><td rowspan="1" colspan="1">op:hexBinary-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">fn:not(op:numeric-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">fn:not(op:boolean-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">fn:not(op:numeric-equal(fn:compare(A, B), 0))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">fn:not(op:date-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">fn:not(op:time-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">fn:not(op:dateTime-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:duration</td><td rowspan="1" colspan="1">xs:duration</td><td rowspan="1" colspan="1">fn:not(op:duration-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">Gregorian</td><td rowspan="1" colspan="1">Gregorian</td><td rowspan="1" colspan="1">fn:not(op:gYear-equal(A, B)) etc.</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:hexBinary</td><td rowspan="1" colspan="1">xs:hexBinary</td><td rowspan="1" colspan="1">fn:not(op:hexBinary-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:base64Binary</td><td rowspan="1" colspan="1">xs:base64Binary</td><td rowspan="1" colspan="1">fn:not(op:base64Binary-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr diff="del"><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">fn:not(op:numeric-equal(fn:compare(A, B), 0))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:QName</td><td rowspan="1" colspan="1">xs:QName</td><td rowspan="1" colspan="1">fn:not(op:QName-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:NOTATION</td><td rowspan="1" colspan="1">xs:NOTATION</td><td rowspan="1" colspan="1">fn:not(op:NOTATION-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr diff="add" at="2014-04-08"><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:hexBinary</td><td rowspan="1" colspan="1">xs:hexBinary</td><td rowspan="1" colspan="1">fn:not(op:hexBinary-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr diff="add" at="2014-04-08"><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:base64Binary</td><td rowspan="1" colspan="1">xs:base64Binary</td><td rowspan="1" colspan="1">fn:not(op:base64Binary-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:numeric-greater-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">op:boolean-greater-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">op:numeric-greater-than(fn:compare(A, B), 0)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">op:date-greater-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">op:time-greater-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">op:dateTime-greater-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:yearMonthDuration-greater-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:dayTimeDuration-greater-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr diff="del"><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">op:numeric-greater-than(fn:compare(A, B), 0)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr diff="add" at="2014-04-08"><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:hexBinary</td><td rowspan="1" colspan="1">xs:hexBinary</td><td rowspan="1" colspan="1">op:hexBinary-greater-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr diff="add" at="2014-04-08"><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:base64Binary</td><td rowspan="1" colspan="1">xs:base64Binary</td><td rowspan="1" colspan="1">op:base64Binary-greater-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:numeric-less-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">op:boolean-less-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">op:numeric-less-than(fn:compare(A, B), 0)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">op:date-less-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">op:time-less-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">op:dateTime-less-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:yearMonthDuration-less-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:dayTimeDuration-less-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr diff="del"><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">op:numeric-less-than(fn:compare(A, B), 0)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr diff="add" at="2014-04-08"><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:hexBinary</td><td rowspan="1" colspan="1">xs:hexBinary</td><td rowspan="1" colspan="1">op:hexBinary-less-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr diff="add" at="2014-04-08"><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:base64Binary</td><td rowspan="1" colspan="1">xs:base64Binary</td><td rowspan="1" colspan="1">op:base64Binary-less-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:numeric-greater-than(A, B) or op:numeric-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">fn:not(op:boolean-less-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">op:numeric-greater-than(fn:compare(A, B), -1)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">fn:not(op:date-less-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">fn:not(op:time-less-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">fn:not(op:dateTime-less-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">fn:not(op:yearMonthDuration-less-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">fn:not(op:dayTimeDuration-less-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr diff="del"><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">op:numeric-greater-than(fn:compare(A, B), -1)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr diff="add" at="2014-04-08"><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:hexBinary</td><td rowspan="1" colspan="1">xs:hexBinary</td><td rowspan="1" colspan="1">fn:not(op:hexBinary-less-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr diff="add" at="2014-04-08"><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:base64Binary</td><td rowspan="1" colspan="1">xs:base64Binary</td><td rowspan="1" colspan="1">fn:not(op:base64Binary-less-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:numeric-less-than(A, B) or op:numeric-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">fn:not(op:boolean-greater-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">op:numeric-less-than(fn:compare(A, B), 1)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">fn:not(op:date-greater-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">fn:not(op:time-greater-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">fn:not(op:dateTime-greater-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">fn:not(op:yearMonthDuration-greater-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">fn:not(op:dayTimeDuration-greater-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr diff="del"><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">op:numeric-less-than(fn:compare(A, B), 1)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr diff="add" at="2014-04-08"><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:hexBinary</td><td rowspan="1" colspan="1">xs:hexBinary</td><td rowspan="1" colspan="1">fn:not(op:hexBinary-greater-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr diff="add" at="2014-04-08"><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:base64Binary</td><td rowspan="1" colspan="1">xs:base64Binary</td><td rowspan="1" colspan="1">fn:not(op:base64Binary-greater-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr diff="del" at="2015-05-26"><td rowspan="1" colspan="1">A is B</td><td rowspan="1" colspan="1">node()</td><td rowspan="1" colspan="1">node()</td><td rowspan="1" colspan="1">op:is-same-node(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr diff="del" at="2015-05-26"><td rowspan="1" colspan="1">A &lt;&lt; B</td><td rowspan="1" colspan="1">node()</td><td rowspan="1" colspan="1">node()</td><td rowspan="1" colspan="1">op:node-before(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr diff="del" at="2015-05-26"><td rowspan="1" colspan="1">A &gt;&gt; B</td><td rowspan="1" colspan="1">node()</td><td rowspan="1" colspan="1">node()</td><td rowspan="1" colspan="1">op:node-after(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr diff="del" at="2015-05-26"><td rowspan="1" colspan="1">A union B</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">op:union(A, B)</td><td rowspan="1" colspan="1">node()*</td></tr><tr diff="del" at="2015-05-26"><td rowspan="1" colspan="1">A | B</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">op:union(A, B)</td><td rowspan="1" colspan="1">node()*</td></tr><tr diff="del" at="2015-05-26"><td rowspan="1" colspan="1">A intersect B</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">op:intersect(A, B)</td><td rowspan="1" colspan="1">node()*</td></tr><tr diff="del" at="2015-05-26"><td rowspan="1" colspan="1">A except B</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">op:except(A, B)</td><td rowspan="1" colspan="1">node()*</td></tr><tr diff="del" at="2015-05-26"><td rowspan="1" colspan="1">A to B</td><td rowspan="1" colspan="1">xs:integer</td><td rowspan="1" colspan="1">xs:integer</td><td rowspan="1" colspan="1">op:to(A, B)</td><td rowspan="1" colspan="1">xs:integer*</td></tr><tr diff="del" at="2015-05-26"><td rowspan="1" colspan="1">A , B</td><td rowspan="1" colspan="1">item()*</td><td rowspan="1" colspan="1">item()*</td><td rowspan="1" colspan="1">op:concatenate(A, B)</td><td rowspan="1" colspan="1">item()*</td></tr><tr diff="del" at="2015-05-26"><td rowspan="1" colspan="1">A || B</td><td rowspan="1" colspan="1">xs:anyAtomicType</td><td rowspan="1" colspan="1">xs:anyAtomicType</td><td rowspan="1" colspan="1">fn:concat(A, B)</td><td rowspan="1" colspan="1">xs:string</td></tr></tbody></table><table border="1" role="small"><caption>Unary Operators</caption><tbody><tr><th rowspan="1" colspan="1">Operator</th><th rowspan="1" colspan="1">Operand type</th><th rowspan="1" colspan="1">Function</th><th rowspan="1" colspan="1">Result type</th></tr><tr><td rowspan="1" colspan="1">+ A</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:numeric-unary-plus(A)</td><td rowspan="1" colspan="1">numeric</td></tr><tr><td rowspan="1" colspan="1">- A</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:numeric-unary-minus(A)</td><td rowspan="1" colspan="1">numeric</td></tr></tbody></table></div2></div1><div1 id="id-xp-context-components" role="xpath"><head>Context Components</head><p>The tables in this
section describe the scope (range of applicability) of the various
components in a module's static context and dynamic context.</p><div2 id="id-xp-static-context-components"><head>Static Context
Components</head><p>The following table describes the components of
the <term>static context</term>. For each component, "global"
indicates that the value of the component applies throughout an XPath
expression, whereas "lexical" indicates that the value of the
component applies only within the subexpression in which it is
defined.</p><table width="60%" border="1" role="small"><caption>Static Context Components</caption><tbody><tr><th rowspan="1" colspan="1">Component</th><th rowspan="1" colspan="1">Scope</th></tr><tr><td rowspan="1" colspan="1">XPath 1.0 Compatibility Mode</td><td rowspan="1" colspan="1">global</td></tr><tr><td rowspan="1" colspan="1">Statically known namespaces</td><td rowspan="1" colspan="1">global</td></tr><tr><td rowspan="1" colspan="1">Default element/type namespace</td><td rowspan="1" colspan="1">global</td></tr><tr><td rowspan="1" colspan="1">Default function namespace</td><td rowspan="1" colspan="1">global</td></tr><tr><td rowspan="1" colspan="1">In-scope schema types</td><td rowspan="1" colspan="1">global</td></tr><tr><td rowspan="1" colspan="1">In-scope element declarations</td><td rowspan="1" colspan="1">global</td></tr><tr><td rowspan="1" colspan="1">In-scope attribute declarations</td><td rowspan="1" colspan="1">global</td></tr><tr><td rowspan="1" colspan="1">In-scope variables</td><td rowspan="1" colspan="1">lexical; for-expressions, let-expressions, and quantified expressions can bind new variables</td></tr><tr><td rowspan="1" colspan="1">Context item static type</td><td rowspan="1" colspan="1">lexical</td></tr><tr><td rowspan="1" colspan="1">Statically known function signatures</td><td rowspan="1" colspan="1">global</td></tr><tr><td rowspan="1" colspan="1">Statically known collations</td><td rowspan="1" colspan="1">global</td></tr><tr><td rowspan="1" colspan="1">Default collation</td><td rowspan="1" colspan="1">global</td></tr><tr><td rowspan="1" colspan="1">Base URI</td><td rowspan="1" colspan="1">global</td></tr><tr><td rowspan="1" colspan="1">Statically known documents</td><td rowspan="1" colspan="1">global</td></tr><tr><td rowspan="1" colspan="1">Statically known collections</td><td rowspan="1" colspan="1">global  </td></tr><tr><td rowspan="1" colspan="1">Statically known default collection type</td><td rowspan="1" colspan="1">global</td></tr></tbody></table></div2><div2 id="id-xp-evaluation-context-components"><head>Dynamic Context Components</head><p>The following table describes how values are assigned to the various components of the <term>dynamic context</term>. All these components are initialized by mechanisms defined by the host language. For each component, "global" indicates that the value of the component remains constant throughout evaluation of the XPath expression, whereas "dynamic" indicates that the value of the component can be modified by the evaluation of subexpressions.</p><table width="60%" border="1" role="small"><caption>Dynamic Context Components</caption><tbody><tr><th rowspan="1" colspan="1">Component</th><th rowspan="1" colspan="1">Scope</th></tr><tr><td rowspan="1" colspan="1">Context item</td><td rowspan="1" colspan="1">dynamic; changes during evaluation of path expressions and predicates</td></tr><tr><td rowspan="1" colspan="1">Context position</td><td rowspan="1" colspan="1">dynamic; changes during evaluation of path expressions and predicates</td></tr><tr><td rowspan="1" colspan="1">Context size</td><td rowspan="1" colspan="1">dynamic; changes during evaluation of path expressions and predicates</td></tr><tr><td rowspan="1" colspan="1">Variable values</td><td rowspan="1" colspan="1">dynamic; for-expressions, let-expressions, and quantified expressions can bind new variables</td></tr><tr><td rowspan="1" colspan="1">Current date and time</td><td rowspan="1" colspan="1">global; must be initialized </td></tr><tr><td rowspan="1" colspan="1">Implicit timezone</td><td rowspan="1" colspan="1">global; must be initialized </td></tr><tr><td rowspan="1" colspan="1">Available documents</td><td rowspan="1" colspan="1">global; must be initialized </td></tr><tr><td rowspan="1" colspan="1">Available  <phrase diff="del" at="2015-07-07">node</phrase> collections</td><td rowspan="1" colspan="1">global; must be initialized </td></tr><tr><td rowspan="1" colspan="1">Default  <phrase diff="del" at="2015-07-07">node</phrase> collection</td><td rowspan="1" colspan="1">global; overwriteable by implementation</td></tr><tr><td rowspan="1" colspan="1">Available <phrase diff="del" at="bug28957">resource</phrase>
                        <phrase diff="add" at="bug28957">URI</phrase> collections</td><td rowspan="1" colspan="1">global; must be initialized </td></tr><tr><td rowspan="1" colspan="1">Default <phrase diff="del" at="bug28957">resource</phrase>
                        <phrase diff="add" at="bug28957">URI</phrase> collection</td><td rowspan="1" colspan="1">global; overwriteable by implementation</td></tr></tbody></table></div2></div1><div1 id="id-impl-defined-items"><head>Implementation-Defined Items</head><p>The following items in this specification are <termref def="dt-implementation-defined">implementation-defined</termref>:</p><olist><item><p>The version of Unicode that is used to construct expressions.</p></item><item><p>The <termref def="dt-static-collations">statically-known collations</termref>.</p></item><item><p>The <termref def="dt-timezone">implicit timezone</termref>.</p></item><item><p>The circumstances in which <termref def="dt-warning">warnings</termref> are raised, and the ways in which warnings are handled.</p></item><item><p>The method by which errors are reported to the external processing environment.</p></item><item><p>Which version of XML and XML Names (e.g. <bibref ref="XML"/> and <bibref ref="XMLNAMES"/> or <bibref ref="XML1.1"/> and <bibref ref="XMLNAMES11"/>) and which version of XML Schema (e.g. <bibref ref="XMLSchema10"/> or <bibref ref="XMLSchema11"/>) is used for the definitions of primitives such as characters and names, and for the definitions  of operations such as normalization of line endings and normalization of whitespace in attribute values. It is recommended that the latest applicable version be used (even if it is published later than this specification).</p></item><item><p>How XDM instances are created from sources other than an Infoset or PSVI.</p></item><item role="xpath"><p>Whether the implementation supports the namespace axis.</p></item><item><p>Whether the type system is based on <bibref ref="XMLSchema10"/> or <bibref ref="XMLSchema11"/>. An implementation that has based its type system on XML Schema 1.0 is not required to support the use of the <code>xs:dateTimeStamp</code> constructor or the use of <code>xs:dateTimeStamp</code> 
                  <phrase diff="add" at="bug28299">or <code>xs:error</code>
                  </phrase> as <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-TypeName" xlink:type="simple">TypeName</nt> in any expression.</p></item><item><p>The signatures of functions provided by the implementation or via an implementation-defined API (see <specref ref="static_context"/>).</p></item><item><p>Any <termref def="dt-environment-variables">environment variables</termref> provided by the implementation.</p></item><item><p>Any rules used for static typing (see <specref ref="id-static-analysis"/>).</p></item><item><p>Any serialization parameters provided by the implementation</p></item><item><p>What error, if any, is returned if an external function's implementation does not return the declared result type (see <specref ref="id-consistency-constraints"/>).</p></item></olist><note><p>Additional <termref def="dt-implementation-defined">implementation-defined</termref> items are listed in <bibref ref="xpath-datamodel-31"/> and <bibref ref="xpath-functions-31"/>.</p></note></div1><div1 id="id-references"><head>References</head><div2 id="id-normative-references"><head>Normative References</head><blist><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC2119" key="RFC2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">S. Bradner.
      <emph>Key Words for use in RFCs to Indicate Requirement Levels.</emph> IETF RFC 2119.
      See <loc href="http://www.ietf.org/rfc/rfc2119.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc2119.txt</loc>.</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC3986" key="RFC3986" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">T. Berners-Lee, R. Fielding, and
      L. Masinter.  <emph>Uniform Resource Identifiers (URI): Generic
      Syntax</emph>. IETF RFC 3986.
      See <loc href="http://www.ietf.org/rfc/rfc3986.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc3986.txt</loc>.</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC3987" key="RFC3987" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">M. Duerst and M. Suignard.
      <emph>Internationalized Resource Identifiers (IRIs)</emph>.
      IETF RFC 3987. See <loc href="http://www.ietf.org/rfc/rfc3987.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc3987.txt</loc>.</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="ISO10646" key="ISO/IEC 10646" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ISO (International Organization for Standardization).
      <emph>ISO/IEC 10646:2003. Information technology—Universal Multiple-Octet Coded Character Set (UCS)</emph>,
      as, from time to time, amended, replaced by a new edition, or expanded by the addition of new parts.
      [Geneva]: International Organization for Standardization.
      (See <loc href="http://www.iso.org" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.iso.org</loc> for the latest version.)</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="Unicode" key="Unicode" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">The Unicode Consortium. <emph>The Unicode Standard</emph>
      Reading, Mass.: Addison-Wesley, 2003, as updated from time to time by the publication of new versions.
      See <loc href="http://www.unicode.org/standard/versions/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.unicode.org/standard/versions/</loc>
      for the latest version and additional information on versions of the standard and of the Unicode Character Database.
      The version of Unicode to be used is <termref def="dt-implementation-defined">implementation-defined</termref>,
      but implementations are recommended to use the latest Unicode version.</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XML" key="XML 1.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium.
      <emph>Extensible Markup Language (XML) 1.0.</emph>
      W3C Recommendation.
      See <loc href="http://www.w3.org/TR/REC-xml/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/REC-xml/</loc>.
      The edition of XML 1.0 must be no earlier than the Third Edition;
      the edition used is <termref def="dt-implementation-defined">implementation-defined</termref>,
      but we recommend that implementations use the latest version.
</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XML1.1" key="XML 1.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium.
      <emph>Extensible Markup Language (XML) 1.1.</emph>
      W3C Recommendation.
      See <loc href="http://www.w3.org/TR/xml11/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xml11/</loc>
               </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLBASE" key="XML Base" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium.
      <emph>XML Base.</emph> W3C Recommendation. See
      <loc href="http://www.w3.org/TR/xmlbase/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xmlbase/</loc>
               </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLNAMES" key="XML Names" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium.
      <emph>Namespaces in XML.</emph> W3C Recommendation. See
      <loc href="http://www.w3.org/TR/REC-xml-names/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/REC-xml-names/</loc>
               </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLNAMES11" key="XML Names 1.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium.
      <emph>Namespaces in XML 1.1.</emph> W3C Recommendation. See
      <loc href="http://www.w3.org/TR/xml-names11/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xml-names11/</loc>
               </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLID" key="XML ID" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium. <emph>xml:id Version 1.0.</emph>
      W3C Recommendation. See <loc href="http://www.w3.org/TR/xml-id/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xml-id/</loc>
               </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLSchema10" key="XML Schema 1.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium.
      <emph>XML Schema, Parts 0, 1, and 2 (Second Edition)</emph>. W3C Recommendation, 28 October 2004.
      See <loc href="http://www.w3.org/TR/xmlschema-0/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xmlschema-0/</loc>,
      <loc href="http://www.w3.org/TR/xmlschema-1/" id="schema1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xmlschema-1/</loc>,
      and <loc href="http://www.w3.org/TR/xmlschema-2/" id="schema2" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xmlschema-2/</loc>.</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLSchema11" key="XML Schema 1.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium.
      <emph>XML Schema, Parts 1, and 2</emph>. W3C Recommendation 5 April 2012.
      See <loc href="http://www.w3.org/TR/xmlschema11-1/" id="schema1-11" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xmlschema11-1/</loc>,
      and <loc href="http://www.w3.org/TR/xmlschema11-2/" id="schema2-11" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xmlschema11-2/</loc>.</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-datamodel-31" key="XQuery and XPath Data Model (XDM) 3.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xpath-functions-31" key="XQuery and XPath Functions and Operators 3.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xslt-xquery-serialization-31" key="XSLT and XQuery Serialization 3.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/></blist></div2><div2 id="id-non-normative-references"><head>Non-normative References</head><blist><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xquery-31" key="XQuery 3.1: An XML Query Language" role="xpath" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xquery-semantics" key="XQuery 1.0 and XPath 2.0 Formal Semantics" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xslt-30" key="XSL Transformations (XSLT) Version 3.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XINFO" key="XML Infoset" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web
Consortium. <emph>XML Information Set <phrase diff="add" at="2015-07-08">(Second Edition).</phrase>
                  </emph> W3C Recommendation <phrase diff="chg" at="2015-07-08">4 February 2004.</phrase> See
<loc href="http://www.w3.org/TR/xml-infoset/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xml-infoset/</loc>
               </bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="XML Path Language (XPath) Version 1.0" id="xpath" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="XML Path Language (XPath) Version 2.0" id="xpath20" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="XML Path Language (XPath) Version 3.0" id="xpath-30" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XPTR" key="XPointer" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium. <emph>XML
Pointer Language (XPointer).</emph> W3C Last Call Working Draft 8 January 2001.
See <loc href="http://www.w3.org/TR/WD-xptr" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/WD-xptr</loc>
               </bibl></blist></div2><div2 id="id-background-material"><head>Background Material</head><blist><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="CHARMOD" key="Character Model" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium.
<emph>Character Model for the World Wide Web.</emph> W3C Working
Draft. See <loc href="http://www.w3.org/TR/charmod/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/charmod/</loc>.</bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="xslt" key="XSL Transformations (XSLT) Version 1.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"/></blist></div2></div1><div1 id="id-errors"><head>Error Conditions</head><error-list><error spec="XP" code="0001" class="ST" type="static"><p> It is a <termref def="dt-static-error">static error</termref> if analysis of an
            expression relies on some component of the <termref def="dt-static-context">static
               context</termref> that <phrase diff="del">has not been assigned a
               value</phrase>
                  <phrase diff="add">is <xtermref spec="DM31" ref="dt-absent"/>
                  </phrase>.</p></error><error spec="XP" code="0002" class="DY" type="dynamic"><p>It is a <termref def="dt-dynamic-error">dynamic error</termref> if evaluation of an
            expression relies on some part of the <termref def="dt-dynamic-context">dynamic
               context</termref> that <phrase diff="del">has not been assigned a
               value</phrase>
                  <phrase diff="add">is <xtermref spec="DM31" ref="dt-absent"/>
                  </phrase>.</p></error><error spec="XP" code="0003" class="ST" type="static"><p> It is a <termref def="dt-static-error">static error</termref> if an expression is not a
            valid instance of the grammar defined in <specref ref="id-grammar"/>.</p></error><error spec="XP" code="0004" class="TY" type="type"><p>It is a <termref def="dt-type-error">type error</termref> if, during the <termref def="dt-static-analysis">static analysis phase</termref>, an expression is found to
            have a <termref def="dt-static-type">static type</termref> that is not appropriate for
            the context in which the expression occurs, or during the <termref def="dt-dynamic-evaluation">dynamic evaluation phase</termref>, the <termref def="dt-dynamic-type">dynamic type</termref> of a value does not match a required
            type as specified by the matching rules in <specref ref="id-sequencetype-matching"/>.</p></error><error spec="XP" code="0005" class="ST" type="static"><p> During the analysis phase, it is a <termref def="dt-static-error">static
               error</termref> if the <termref def="dt-static-type">static type</termref> assigned
            to an expression other than the expression <code>()</code> or <code>data(())</code> is
               <code>empty-sequence()</code>.</p></error><!--
<error spec="XP" code="0006" class="TY" type="type">
<p>
(Not currently used.)</p></error>

<error spec="XP" code="0007" class="TY" type="type">
<p>(Not currently used.)</p>
</error>
--><error spec="XP" code="0008" class="ST" type="static"><p> It is a <termref def="dt-static-error">static error</termref> if an expression refers
            to an element name, attribute name, schema type name, namespace prefix, or variable name
            that is not defined in the <termref def="dt-static-context">static context</termref>,
            except for an ElementName in an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-ElementTest" xlink:type="simple">ElementTest</nt> or an
            AttributeName in an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AttributeTest" xlink:type="simple">AttributeTest</nt>.</p></error><error spec="XP" code="0010" class="ST" type="static" role="xpath"><p> An implementation that does not support the namespace axis must raise a <termref def="dt-static-error">static error</termref> if it encounters a reference to the
            namespace axis and XPath 1.0 compatibility mode is false. </p></error><!--
<error spec="XQ" role="xquery" code="0014" class="ST" type="static">
<p>(Not currently used.)</p>
</error>
--><!--
<error spec="XQ" role="xquery" code="0015" class="ST" type="static">
<p>(Not currently used.)</p>
</error>
--><error spec="XP" code="0017" class="ST" type="static"><p> It is a <termref def="dt-static-error">static error</termref> if the <termref def="dt-expanded-qname">expanded QName</termref> and number of arguments in a <phrase diff="add">static</phrase> function call do not match the name and arity of a
               <termref def="dt-known-func-signatures">function signature</termref> in the <termref def="dt-static-context">static context</termref>.</p></error><error spec="XP" code="0018" class="TY" type="type"><p>It is a <termref def="dt-type-error">type error</termref> if the result of a path
            operator contains both nodes and non-nodes.</p></error><error spec="XP" code="0019" class="TY" type="type"><p> It is a <termref def="dt-type-error">type error</termref> if <code>E1</code> in a path
            expression <code>E1/E2</code> does not evaluate to a sequence of nodes.</p></error><error spec="XP" code="0020" class="TY" type="type"><p> It is a <termref def="dt-type-error">type error</termref> if, in an axis step, the
            context item is not a node.</p></error><!--
<error spec="XP" code="0021" class="DY" type="dynamic">
<p>
(Not currently used.)</p>
</error>
--><!--
<error spec="XQ" role="xquery" code="0023" class="TY" type="type">
<p>(Not currently used.)</p>
</error>
--><!--
<error spec="XQ" role="xquery" code="0028" class="TY" type="type">
<p>
(Not currently used.)</p>
</error>
--><!--
<error spec="XQ" code="0029" class="DY" type="dynamic" role="xquery">
<p>(Not currently used.)</p>
</error>
--><!--
<error spec="XQ" role="xquery" code="0036" class="ST" type="type">
          <p diff="add">(Not currently used.)</p>
          <p diff="del">
            It is a <termref def="dt-static-error">static error</termref>
            to import a module if the
            <termref def="dt-issd">in-scope schema definitions</termref>
            of the importing module do not include all of the following:
          </p>
          <olist diff="del">
             <item>
                <p>An <termref def="dt-is-types">in-scope schema type</termref>
                   for each type name that appears:
                </p>
                <olist>
                   <item>
                      <p>in the type of a variable that is declared in the imported module
                         and referenced in the importing module, OR
                      </p>
                   </item><item>
                      <p>in a parameter-type or result-type of a function that is declared
                         in the imported module and referenced in the importing module.
                      </p>
                   </item>
                </olist>
             </item><item>
                <p>An <termref def="dt-is-elems">in-scope element declaration</termref>
                   for each element-name <code>EN</code> such that:
                </p>
                <olist>
                   <item>
                      <p><code>schema-element(EN)</code> appears in the declared
                         type of a variable
                         in the imported module, and that variable is referenced
                         in the importing module, OR
                      </p>
                   </item><item>
                      <p><code>schema-element(EN)</code> appears in a parameter-type or
                         result-type of a function declared in the imported module, and
                         that function is referenced in the importing module.
                      </p>
                   </item>
                </olist>
             </item><item>
                <p>An <termref def="dt-is-attrs">in-scope attribute declaration</termref>
                   for each attribute-name <code>AN</code> such that:
                </p>
                <olist>
                   <item>
                      <p><code>schema-attribute(AN)</code> appears in the declared
                         type of a variable
                         in the imported module, and that variable is referenced
                         in the importing module, OR
                      </p>
                   </item><item>
                      <p><code>schema-attribute(AN)</code> appears in a parameter-type
                         or result-type
                         of a function declared in the imported module, and that function
                         is referenced in the importing module.
                      </p>
                   </item>
                </olist>
             </item>
          </olist>
</error>
--><!--
<error spec="XQ" role="xquery" code="0037" class="ST" type="static">
<p>(Not currently used.)</p>
</error>
--><error spec="XQ" code="0039" class="ST" type="static"><p> It is a <termref def="dt-static-error">static error</termref> for 
            <phrase diff="add">an inline function expression</phrase> to have more than one
            parameter with the same name. </p></error><!--
<error spec="XQ" role="xquery" code="0042" class="ST" type="static">
<p>
(Not currently used.)</p>
</error>
--><!--
<error spec="XQ" role="xquery" code="0043" class="ST" type="static">
<p>
(Not currently used.)</p>
</error>
--><error spec="XQ" code="0046" class="ST" type="static"><p>An implementation <phrase role="xpath">MAY</phrase> raise a <termref def="dt-static-error">static
               error</termref> if the value of a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-BracedURILiteral" xlink:type="simple">BracedURILiteral</nt> is
            of nonzero length and is <phrase diff="del">not in the lexical space of
                  <code>xs:anyURI</code>
                  </phrase>
                  <phrase diff="add">neither an absolute URI nor a
               relative URI</phrase>.</p></error><error spec="XP" code="0050" class="DY" type="dynamic"><p>It is a <termref def="dt-dynamic-error">dynamic error</termref> if the <termref def="dt-dynamic-type">dynamic type</termref> of the operand of a <code>treat</code>
            expression does not match the <termref def="dt-sequence-type">sequence type</termref>
            specified by the <code>treat</code> expression. This error might also be raised by a
            path expression beginning with "<code>/</code>" or "<code>//</code>" if the context node
            is not in a tree that is rooted at a document node. This is because a leading
               "<code>/</code>" or "<code>//</code>" in a path expression is an abbreviation for an
            initial step that includes the clause <code>treat as document-node()</code>.</p></error><error spec="XP" code="0051" class="ST" type="static"><p>It is a <termref def="dt-static-error">static error</termref> if the <termref def="dt-expanded-qname">expanded QName</termref> for an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-AtomicOrUnionType" xlink:type="simple">AtomicOrUnionType</nt> in a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-SequenceType" xlink:type="simple">SequenceType</nt> is not defined
            in the <termref def="dt-is-types">in-scope schema types</termref> as a <termref def="dt-generalized-atomic-type">generalized atomic type</termref>.</p></error><error spec="XQ" code="0052" class="ST" type="static"><p>The type named in a cast or castable expression must be the name of a type defined in the <termref def="dt-is-types">in-scope
               schema types</termref>, and the<phrase diff="del" at="2015-07-07">
                     <code>{variety}</code> of the</phrase> type must be
               <code>simple</code>.</p></error><!--
<error spec="XQ" role="xquery" code="0053" class="ST" type="static">
<p>
(Not currently used.)</p>
</error>
--><!--
<error spec="XQ" code="0056" class="ST" type="static" role="xquery">
<p>
(Not currently used.)</p>
</error>
--><!--
<error spec="XQ" role="xquery" code="0062" class="DY" type="dynamic">
<p>(Not currently used.)</p>
</error>
--><!--
<error spec="XQ" code="0063" class="ST" type="static" role="xquery">
<p>
(Not currently used.)</p>
</error>
--><error spec="XQ" code="0070" class="ST" type="static" diff="chg"><!-- <change diff="chg" at="XQ.E19"> --><p role="xpath">A <termref def="dt-static-error">static error</termref> is raised if any of
            the following conditions is statically detected in any expression: </p><ulist><item><p>The prefix <code>xml</code> is bound to some namespace URI other than
                     <code>http://www.w3.org/XML/1998/namespace</code>. </p></item><item><p>A prefix other than <code>xml</code> is bound to the namespace URI
                     <code>http://www.w3.org/XML/1998/namespace</code>. </p></item><item><p>The prefix <code>xmlns</code> is bound to any namespace URI. </p></item><item><p>A prefix other than <code>xmlns</code> is bound to the namespace URI
                     <code>http://www.w3.org/2000/xmlns/</code>. </p></item></ulist><!-- </change> --></error><!--
<error spec="XQ" role="xquery" code="0073" class="ST" type="static">
<p diff="chg" at="XQ.E8">(Not currently used.)</p>
</error>
--><!--
<error spec="XQ" role="xquery" code="0077" class="ST" type="static">
<p>
(Not currently used.)</p>
</error>
--><!--
<error spec="XQ" role="xquery" code="0078" class="ST" type="static">
<p>
(Not currently used.)</p>
</error>
--><error spec="XP" code="0080" class="ST" type="static"><p>It is a <termref def="dt-static-error">static error</termref> if the target type of a
               <code>cast</code> or <code>castable</code> expression is
               <code>xs:NOTATION</code>, <phrase diff="add">
                     <code>xs:anySimpleType</code>,</phrase> or
               <code>xs:anyAtomicType</code>.</p></error><error spec="XP" code="0081" class="ST" type="static"><p> It is a <termref def="dt-static-error">static error</termref> if a QName used in
               <phrase role="xpath">an expression</phrase>
            contains a namespace prefix that cannot be expanded into a namespace URI by using the
               <termref def="dt-static-namespaces">statically known namespaces</termref>.</p></error><!--
<error spec="XQ" role="xquery" code="0082" class="ST" type="static">
<p>(Not currently used.)</p>
</error>
--><!--
<error spec="XP" code="0083" class="ST" type="static">
<p>
(Not currently used.)</p>
</error>
--><!--
<error spec="XQ" role="xquery" code="0093" class="ST" type="static">
<p>
It is a <termref def="dt-static-error">static
error</termref> to import a module M<sub>1</sub> if there exists a sequence of modules M<sub>1</sub> ... M<sub>i</sub> ... M<sub>1</sub> such that each module <termref def="dt-module-directly-depends">directly depends</termref> on the next module in the sequence (informally, if M<sub>1</sub> depends on itself through some chain of module dependencies.)</p>
</error>
--><!--
<error spec="XQ" role="xquery" code="0095" class="DY" type="dynamic">
<p>
In the <code>group by</code> clause of a FLWOR expression, it is a <termref def="dt-dynamic-error">dynamic error</termref>
if the value bound to a grouping  variable consists of a sequence of more than one item.</p>
</error> --><!-- ################ --><!--
<error  spec="XQ" role="xquery" code="0100" class="ST" type="static">
<p>(Not currently used.)
</p>
  <ulist>

  <item><p><termref
  def="id-static-decimal-separator">decimal-separator</termref></p></item>
  <item><p><termref
    def="id-static-decimal-format-grouping-separator">grouping-separator</termref></p></item>

    <item><p><termref
    def="id-static-decimal-format-percent">percent-sign</termref></p></item>

    <item><p><termref
    def="id-static-decimal-format-per-mille">per-mille-sign</termref></p></item>

    <item><p><termref
		 def="id-static-decimal-format-zero-digit">zero-digit</termref></p></item>

    <item><p><termref def="id-static-decimal-format-digit">digit-sign</termref></p></item>
    <item><p><termref def="id-static-decimal-format-pattern-separator">pattern-separator-sign</termref></p></item>
  </ulist>
</error>
--><!-- ############ --><!-- ################ 0112 --><error spec="XP" code="0117" class="TY" type="type"><!-- Bug 28588 --><p>When applying the function conversion rules, if an item is of type <code>xs:untypedAtomic</code> and the
            expected type is <termref def="dt-namespace-sensitive">namespace-sensitive</termref>, a
               <termref def="dt-type-error">type error</termref>
                  <errorref class="TY" code="0117"/> is raised. </p></error><!--
<error  spec="XQ" role="xquery" code="0121" class="ST" type="static">
<p>It is a static error if a feature specified in <code>prohibit-feature</code> is supported by the implementation.</p>
</error>
--><!--
<error  spec="XQ" role="xquery" code="0124" class="ST" type="static" diff="del">
<p>
It is a static error if the name of a feature in
<code>require-feature</code> or <code>prohibit-feature</code> is not recognized by the implementation.
</p>
</error>
--><!--
<error  spec="XQ" role="xquery" code="0127" class="ST" type="static" diff="add">
<p>
  It is a <termref def="dt-static-error">static error</termref> if a
  given feature is both required and prohibited, directly or indirectly, in a module.
</p>
</error>
--><error spec="XP" code="0130" class="DY" type="dynamic"><p>An implementation-dependent limit has been exceeded.</p></error><!--
<error  spec="XQ" role="xquery" code="0132" class="ST" type="static">
<p>The <code>module</code> feature can only be required or prohibited in a main module, not in a library module.</p>
</error>
--><!--
      <error spec="XP" code="0133" class="ST" type="static" diff="del">

         <p>It is a <termref def="dt-static-error">static error</termref>
            <errorref class="ST" code="0133"/> if the namespace URI for an EQName is
               <code>http://www.w3.org/2000/xmlns/</code>.</p>
      </error>
--><error spec="XQ" code="0134" class="ST" type="static"><p>The namespace axis is not supported.</p></error><!-- DELETED
<error  spec="XP" role="xquery" code="0135" class="ST" type="static" diff="del">
<p> A processor may raise an error  <errorref code="0034" class="ST"/> if the modules of a query do not have the same version number.</p>
</error>
--><!--  DELETED
      <error spec="XQ" code="0136" class="DY" type="dynamic">
         <p>A map key must be a single atomic value.</p>
      </error>
--><error spec="XQ" code="0137" class="DY" type="dynamic"><p>No two keys in a map may have the  <termref def="dt-same-key">same key value</termref>.</p></error><!--  DELETED (bug 28689) 
      <error spec="XP" code="0138" class="DY" type="dynamic">
         <p>Position <code>n</code> does not exist in this array.</p>
      </error>


      <error spec="XP" code="0139" class="DY" type="dynamic">
         <p>The keys in a map constructor cannot contain both
         date/time values with a timezone and date/time values with no
         timezone. 
         </p>
      </error>
--><!--


<error  spec="XQ" role="xquery" code="010X" class="ST" type="static">
<p>
</p>
</error>

<error  spec="XQ" role="xquery" code="010X" class="ST" type="static">
<p>
</p>
</error>

<error  spec="XQ" role="xquery" code="010X" class="ST" type="static">
<p>
</p>
</error>

--></error-list></div1><inform-div1 id="id-glossary"><head>Glossary</head><!-- This processing instruction automatically generates the glossary. --><?glossary?></inform-div1><inform-div1 id="id-incompatibilities"><head>Backwards Compatibility</head><div2><head>Incompatibilities relative to XPath 3.0</head><p>The following names are now reserved, and cannot appear as function names (see <specref ref="id-reserved-fn-names"/>):</p><ulist><item><p>
                     <code>map</code>
                  </p></item><item><p>
                     <code>array</code>
                  </p></item></ulist></div2><div2><head>Incompatibilities relative to XPath <phrase role="xpath">2.0</phrase>
            </head><p>The following names are now reserved, and cannot appear as function names (see <specref ref="id-reserved-fn-names"/>):</p><ulist><item><p>
                     <code>function</code>
                  </p></item><item><p>
                     <code>namespace-node</code>
                  </p></item><item><p>
                     <code>switch</code>
                  </p></item></ulist><p diff="chg" at="bug28894">If <code>U</code> is a union type with <code>T</code> as one of its members, and if <code>E</code> is an element with <code>T</code> as its type annotation, the expression <code role="parse-test">E instance of element(*, U)</code> returns <code>true</code> in both XPath 3.0 and 3.1.  In <phrase role="xpath">XPath 2.0</phrase>, it returns <code>false</code>.</p><note diff="chg" at="bug28894"><p>This is not an incompatibility with XPath 3.0.  It should be included in XPath 3.0 as an incompatibility with <phrase role="xpath">XPath 2.0</phrase> but it was discovered after publication.</p></note></div2><div2 role="xpath" id="id-backwards-compatibility"><head>Incompatibilities relative to XPath 1.0</head><p>This appendix provides a summary of the areas of incompatibility between <phrase diff="chg" at="bug28782">XPath 3.1</phrase> and
            <bibref ref="xpath"/>. In each of these cases, an  <phrase diff="chg" at="bug28782">XPath 3.1</phrase> processor is compatible with an XPath 2.0 processor <phrase diff="chg" at="bug28782">or an XPath 3.0 processor</phrase>.</p><p>Three separate cases are considered:</p><olist><item><p>Incompatibilities that exist when source documents have no schema, and when running
                with XPath 1.0 compatibility mode set to true. This specification has been designed
                to reduce the number of incompatibilities in this situation to an absolute minimum,
                but some differences remain and are listed individually.</p></item><item><p>Incompatibilities that arise when XPath 1.0 compatibility mode is set to false. In
                this case, the number of expressions where compatibility is lost is rather
                greater.</p></item><item><p>Incompatibilities that arise when the source document is processed using a schema
                (whether or not XPath 1.0 compatibility mode is set to true). Processing the
                document with a schema changes the way that the values of nodes are interpreted, and
                this can cause an XPath expression to return different results.</p></item></olist><div3 id="id-incompat-in-true-mode"><head>Incompatibilities when Compatibility Mode is true</head><p>The list below contains all known areas, within the scope of this specification, where an
            <phrase diff="chg" at="bug28782">XPath 3.1</phrase> processor running with compatibility mode set to true will produce different
            results from an XPath 1.0 processor evaluating the same expression, assuming that the
            expression was valid in XPath 1.0, and that the nodes in the source document have no
            type annotations other than <code>xs:untyped</code> and
            <code>xs:untypedAtomic</code>.</p><p>Incompatibilities in the behavior of individual functions are not listed here, but are
            included in an appendix of <bibref ref="xpath-functions-31"/>.</p><p>Since both XPath 1.0 and <phrase diff="chg" at="bug28782">XPath 3.1</phrase> leave some aspects of the specification
            implementation-defined, there may be incompatibilities in the behavior of a particular
            implementation that are outside the scope of this specification. Equally, some aspects
            of the behavior of XPath are defined by the host language.</p><olist><item><p>Consecutive comparison operators such as <code>A &lt; B &lt; C</code> were
                    supported in XPath 1.0, but are not permitted by the <phrase diff="chg" at="bug28782">XPath 3.1</phrase> grammar. In most
                    cases such comparisons in XPath 1.0 did not have the intuitive meaning, so it is
                    unlikely that they have been widely used in practice. If such a construct is
                    found, an <phrase diff="chg" at="bug28782">XPath 3.1</phrase> processor will report a syntax error, and the construct can
                    be rewritten as <code role="parse-test">(A &lt; B) &lt; C</code>
                     </p></item><item><p>When converting strings to numbers (either explicitly when using the
                        <code>number</code> function, or implicitly say on a function call), certain
                    strings that converted to the special value <code>NaN</code> under XPath 1.0
                    will convert to values other than <code>NaN</code> under <phrase diff="chg" at="bug28782">XPath 3.1</phrase>. These
                    include any number written with a leading <code>+</code> sign, any number in
                    exponential floating point notation (for example <code>1.0e+9</code>), and the
                    strings <code>INF</code> and <code>-INF</code>.</p><p>Furthermore, the strings <code>Infinity</code> and <code>-Infinity</code>, which
                    were accepted by XPath 1.0 as representations of the floating-point values
                    positive and negative infinity, are no longer recognized. They are converted to
                        <code>NaN</code> when running under <phrase diff="chg" at="bug28782">XPath 3.1</phrase> with compatibility mode set to
                    true, and cause a dynamic error when compatibility mode is set to false.</p></item><item><p>
                        <phrase diff="chg" at="bug28782">XPath 3.1</phrase> does not allow a token starting with a letter to follow immediately
                    after a numeric literal, without intervening whitespace. For example,
                        <code>10div 3</code> was permitted in XPath 1.0, but in <phrase diff="chg" at="bug28782">XPath 3.1</phrase> must be
                    written as <code>10 div 3</code>.</p></item><item><p>The namespace axis is deprecated as of XPath 2.0. Implementations may support the
                    namespace axis for backward compatibility with XPath 1.0, but they are not
                    required to do so. (XSLT 2.0 requires that if XPath backwards compatibility mode
                    is supported, then the namespace axis must also be supported; but other host
                    languages may define the conformance rules differently.)</p></item><item><p>In XPath 1.0, the expression <code>-x|y</code> parsed as <code>-(x|y)</code>, and
                    returned the negation of the numeric value of the first node in the union of
                        <code>x</code> and <code>y</code>. In <phrase diff="chg" at="bug28782">XPath 3.1</phrase>, this expression parses as
                        <code>(-x)|y</code>. When XPath 1.0 Compatibility Mode is true, this will
                    always cause a type error.</p></item><item><p>The rules for converting numbers to strings have changed. These may affect the
                    way numbers are displayed in the output of a stylesheet. For numbers whose
                    absolute value is in the range <code>1E-6</code> to <code>1E+6</code>, the
                    result should be the same, but outside this range, scientific format is used for
                    non-integral <code>xs:float</code> and <code>xs:double</code> values.</p></item><item><p>If one operand in a general comparison is a single atomic value of type
                        <code>xs:boolean</code>, the other operand is converted to
                        <code>xs:boolean</code> when XPath 1.0 compatibility mode is set to true. In
                    XPath 1.0, if neither operand of a comparison operation using the &lt;, &lt;=,
                    &gt; or &gt;= operator was a node set, both operands were converted to numbers.
                    The result of the expression <code>true() &gt; number('0.5')</code> is therefore
                    true in XPath 1.0, but is false in <phrase diff="chg" at="bug28782">XPath 3.1</phrase> even when compatibility mode is set
                    to true.</p></item><item><p>In <phrase diff="chg" at="bug28782">XPath 3.1</phrase>, a type error is raised if the PITarget specified in a SequenceType
                    of form <code>processing-instruction(PITarget)</code> is not a valid NCName. In
                    XPath 1.0, this condition was not treated as an error.</p></item></olist></div3><div3 id="id-incompat-in-false-mode"><head>Incompatibilities when Compatibility Mode is false</head><p>Even when the setting of the XPath 1.0 compatibility mode is false, many XPath
            expressions will still produce the same results under <phrase diff="chg" at="bug28782">XPath 3.1</phrase> as under XPath 1.0. The
            exceptions are described in this section.</p><p>In all cases it is assumed that the expression in question was valid under XPath 1.0,
            that XPath 1.0 compatibility mode is false, and that all elements and attributes are
            annotated with the types <code>xs:untyped</code> and <code>xs:untypedAtomic</code>
            respectively.</p><p>In the description below, the terms <emph>node-set</emph> and <emph>number</emph> are
            used with their XPath 1.0 meanings, that is, to describe expressions which according to
            the rules of XPath 1.0 would have generated a node-set or a number respectively.</p><olist><item><p>When a node-set containing more than one node is supplied as an argument to a
                    function or operator that expects a single node or value, the XPath 1.0 rule was
                    that all nodes after the first were discarded. Under <phrase diff="chg" at="bug28782">XPath 3.1</phrase>, a type error
                    occurs if there is more than one node. The XPath 1.0 behavior can always be
                    restored by using the predicate <code>[1]</code> to explicitly select the first
                    node in the node-set.</p></item><item><p>In XPath 1.0, the <code>&lt;</code> and <code>&gt;</code> operators, when applied
                    to two strings, attempted to convert both the strings to numbers and then made a
                    numeric comparison between the results. In <phrase diff="chg" at="bug28782">XPath 3.1</phrase>, these operators perform a
                    string comparison using the default collating sequence. (If either value is
                    numeric, however, the results are compatible with XPath 1.0)</p></item><item><p>When an empty node-set is supplied as an argument to a function or operator that
                    expects a number, the value is no longer converted implicitly to NaN. The XPath
                    1.0 behavior can always be restored by using the <code>number</code> function to
                    perform an explicit conversion.</p></item><item><p>More generally, the supplied arguments to a function or operator are no longer
                    implicitly converted to the required type, except in the case where the supplied
                    argument is of type <code>xs:untypedAtomic</code> (which will commonly be the
                    case when a node in a schemaless document is supplied as the argument). For
                    example, the function call <code role="parse-test">substring-before(10 div 3,
                        ".")</code> raises a type error under <phrase diff="chg" at="bug28782">XPath 3.1</phrase>, because the arguments to
                    the <code>substring-before</code> function must be strings rather than numbers.
                    The XPath 1.0 behavior can be restored by performing an explicit conversion to
                    the required type using a constructor function or cast.</p></item><item><p>The rules for comparing a node-set to a boolean have changed. In XPath 1.0, an
                    expression such as <code role="parse-test">$node-set = true()</code> was
                    evaluated by converting the node-set to a boolean and then performing a boolean
                    comparison: so this expression would return <code>true</code> if
                        <code>$node-set</code> was non-empty. In <phrase diff="chg" at="bug28782">XPath 3.1</phrase>, this expression is
                    handled in the same way as other comparisons between a sequence and a singleton:
                    it is <code>true</code> if <code>$node-set</code> contains at least one node
                    whose value, after atomization and conversion to a boolean using the casting
                    rules, is <code>true</code>.</p><p>This means that if <code>$node-set</code> is empty, the result under <phrase diff="chg" at="bug28782">XPath 3.1</phrase>
                    will be <code>false</code> regardless of the value of the boolean operand, and
                    regardless of which operator is used. If <code>$node-set</code> is non-empty,
                    then in most cases the comparison with a boolean is likely to fail, giving a
                    dynamic error. But if a node has the value "0", "1", "true", or "false",
                    evaluation of the expression may succeed.</p></item><item><p>Comparisons of a number to a boolean, a number to a string, or a string to a
                    boolean are not allowed in <phrase diff="chg" at="bug28782">XPath 3.1</phrase>: they result in a type error. In XPath 1.0
                    such comparisons were allowed, and were handled by converting one of the
                    operands to the type of the other. So for example in XPath 1.0 <code role="parse-test">4 = true()</code> was true; <code role="parse-test">4 =
                        "+4"</code> was false (because the string <code>+4</code> converts to
                        <code>NaN</code>), and <code>false = "false"</code> was false (because the
                    string <code>"false"</code> converts to the boolean <code>true</code>). In XPath
                    3.0 all these comparisons are type errors.</p></item><item><p>Additional numeric types have been introduced, with the effect that arithmetic
                    may now be done as an integer, decimal, or single- or double-precision floating
                    point calculation where previously it was always performed as double-precision
                    floating point. The result of the <code>div</code> operator when dividing two
                    integers is now a value of type decimal rather than double. The expression <code role="parse-test">10 div 0</code> raises an error rather than returning
                    positive infinity.</p></item><item><p>The rules for converting strings to numbers have changed. The implicit conversion
                    that occurs when passing an <code>xs:untypedAtomic</code> value as an argument
                    to a function that expects a number no longer converts unrecognized strings to
                    the value <code>NaN</code>; instead, it reports a dynamic error. This is in
                    addition to the differences that apply when backwards compatibility mode is set
                    to true.</p></item><item><p>Many operations in <phrase diff="chg" at="bug28782">XPath 3.1</phrase> produce an empty sequence as their result when one
                    of the arguments or operands is an empty sequence. Where the operation expects a
                    string, an empty sequence is usually considered equivalent to a zero-length
                    string, which is compatible with the XPath 1.0 behavior. Where the operation
                    expects a number, however, the result is not the same. For example, if
                        <code>@width</code> returns an empty sequence, then in XPath 1.0 the result
                    of <code role="parse-test">@width+1</code> was <code>NaN</code>, while with
                    <phrase diff="chg" at="bug28782">XPath 3.1</phrase> it is <code>()</code>. This has the effect that a filter expression
                    such as <code role="parse-test">item[@width+1 != 2]</code> will select items
                    having no <code>width</code> attribute under XPath 1.0, and will not select them
                    under <phrase diff="chg" at="bug28782">XPath 3.1</phrase>.</p></item><item><p>The typed value of a comment node, processing instruction node, or namespace node
                    under <phrase diff="chg" at="bug28782">XPath 3.1</phrase> is of type <code>xs:string</code>, not
                        <code>xs:untypedAtomic</code>. This means that no implicit conversions are
                    applied if the value is used in a context where a number is expected. If a
                    processing-instruction node is used as an operand of an arithmetic operator, for
                    example, XPath 1.0 would attempt to convert the string value of the node to a
                    number (and deliver <code>NaN</code> if unsuccessful), while <phrase diff="chg" at="bug28782">XPath 3.1</phrase> will
                    report a type error.</p></item><item><p>In XPath 1.0, it was defined that with an expression of the form <code>A and
                        B</code>, B would not be evaluated if A was false. Similarly in the case of
                        <code>A or B</code>, B would not be evaluated if A was true. This is no
                    longer guaranteed with <phrase diff="chg" at="bug28782">XPath 3.1</phrase>: the implementation is free to evaluate the two
                    operands in either order or in parallel. This change has been made to give more
                    scope for optimization in situations where XPath expressions are evaluated
                    against large data collections supported by indexes. Implementations may choose
                    to retain backwards compatibility in this area, but they are not obliged to do
                    so.</p></item><item><p>In XPath 1.0, the expression <code>-x|y</code> parsed as <code>-(x|y)</code>, and
                    returned the negation of the numeric value of the first node in the union of
                        <code>x</code> and <code>y</code>. In <phrase diff="chg" at="bug28782">XPath 3.1</phrase>, this expression parses as
                        <code>(-x)|y</code>. When XPath 1.0 Compatibility Mode is false, this will
                    cause a type error, except in the situation where <code>x</code> evaluates to an
                    empty sequence. In that situation, <phrase diff="chg" at="bug28782">XPath 3.1</phrase> will return the value of
                        <code>y</code>, whereas XPath 1.0 returned the negation of the numeric value
                    of <code>y</code>.</p></item></olist></div3><div3 id="id-incompat-when-using-schema"><head>Incompatibilities when using a Schema</head><p>An XPath expression applied to a document that has been processed against a schema will
            not always give the same results as the same expression applied to the same document in
            the absence of a schema. Since schema processing had no effect on the result of an XPath
            1.0 expression, this may give rise to further incompatibilities. This section gives a
            few examples of the differences that can arise.</p><p>Suppose that the context node is an element node derived from the following markup:
                <code>&lt;background color="red green blue"/&gt;</code>. In XPath 1.0, the predicate
                <code>[@color="blue"]</code> would return <code>false</code>. In <phrase diff="chg" at="bug28782">XPath 3.1</phrase>, if the
                <code>color</code> attribute is defined in a schema to be of type
                <code>xs:NMTOKENS</code>, the same predicate will return <code>true</code>.</p><p>Similarly, consider the expression <code role="parse-test">@birth &lt; @death</code>
            applied to the element <code>&lt;person birth="1901-06-06"
                death="1991-05-09"/&gt;</code>. With XPath 1.0, this expression would return false,
            because both attributes are converted to numbers, which returns <code>NaN</code> in each
            case. With <phrase diff="chg" at="bug28782">XPath 3.1</phrase>, in the presence of a schema that annotates these attributes as
            dates, the expression returns <code>true</code>.</p><p>Once schema validation is applied, elements and attributes cannot be used as operands and
            arguments of expressions that expect a different data type. For example, it is no longer
            possible to apply the <code>substring</code> function to a date to extract the year
            component, or to a number to extract the integer part. Similarly, if an attribute is
            annotated as a boolean then it is not possible to compare it with the strings
                <code>"true"</code> or <code>"false"</code>. All such operations lead to type
            errors. The remedy when such errors occur is to introduce an explicit conversion, or to
            do the computation in a different way. For example, <code role="parse-test">substring-after(@temperature, "-")</code> might be rewritten as <code role="parse-test">abs(@temperature)</code>.</p><p>In the case of an <phrase diff="chg" at="bug28782">XPath 3.1</phrase> implementation that provides the static typing feature, many
            further type errors will be reported in respect of expressions that worked under XPath
            1.0. For example, an expression such as <code role="parse-test">round(../@price)</code>
            might lead to a static type error because the processor cannot infer statically that
                <code role="parse-test">../@price</code> is guaranteed to be numeric.</p><p>Schema validation will in many cases perform whitespace normalization on the contents of
            elements (depending on their type). This will change the result of operations such as
            the <code>string-length</code> function.</p><p>Schema validation augments the data model by adding default values for omitted attributes
            and empty elements.</p></div3></div2></inform-div1><inform-div1 id="id-revision-log"><head>Change Log</head><p role="xpath">This appendix lists the changes that have been made to this
specification since the publication of XPath 3.0 Recommendation.</p><div2 id="id-changes-since-2CR"><head>Changes since the Candidate Recommendation of 17 December 2015</head><div3><head>Substantive Changes</head><olist><item><p>Added switch expressions to list of conditional expressions in <specref ref="id-errors-and-opt"/>.  Resolves  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29320" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 29320</loc>.</p></item><item><p>If the <termref def="dt-content-expression">content expression</termref> is not provided explicitly, the content expression is <code>()</code>.  Previously, no content expression was provided, but the value of the content was specified.  This caused problems evaluating functions with empty bodies, and failed to provide a host language expression for the function implementation in the data model.</p></item><item><p>Partial function application never returns a map or an array.  If <code>$F</code> is a map or an array, then <code>$F(?)</code> is 
             a partial function application that returns a function, but the function it returns is not a map nor an array. Resolves action A-640-03.</p></item><item><p>Added <code>xs:anySimpleType</code> to the list of types that have no contructor function.   Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29583" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 29583</loc>.</p></item><item><p>Added requirement to specify minimum values for some date and time functions.   Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29576" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 29576</loc>.</p></item><item><p>Changed the rules for atomization in lookup in <specref ref="id-lookup"/>.   Resolves  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29622" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 29622</loc>.</p></item><item><p>Allowed more specific typing of maps, arrays, and functions.  Affects <specref ref="id-map-test"/>, <specref ref="id-array-test"/>, <specref ref="id-itemtype-subtype"/>, <specref ref="id-eval-function-call"/>, and <specref ref="id-inline-func"/>. Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29586" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 29586</loc>.</p></item><item><p>Changed <specref ref="id-map-lookup"/> to define semantics using only <xspecref spec="FO31" ref="func-map-get"/>, changed <specref ref="id-array-lookup"/> to define semantics using only <xspecref spec="FO31" ref="func-array-get"/>, thus aligning edge cases and eliminating the possibility of discrepancies creeping in.   Resolves  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29683" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 29683</loc>.</p></item></olist></div3><div3><head>Editorial Changes</head><olist><item><p>Significantly changed the prose in <specref ref="id-eval-function-call"/>.  Resolves  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29277" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 29277</loc>.</p></item><item><p>Created formal definition<phrase role="xpath">s</phrase> for <termref def="dt-implementation-defined-function">implementation-defined function</termref>
                        <phrase role="xpath">
      and <termref def="dt-host-language-function" role="xpath">host language function</termref>
                        </phrase>.</p></item><item><p>Fixed a problem with conditional text in <specref ref="id-itemtype-subtype"/>:
      <code>Bi</code> is <code> function(*)</code>,
      <code>Ai</code> is a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath31-FunctionTest" xlink:type="simple">FunctionTest</nt>.
      Resolves  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29414" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 29414</loc>.</p></item><item><p>Changed definition of <termref def="dt-same-key">same key</termref>, redefining it in terms of  <xspecref spec="FO31" ref="func-same-key"/>. Resolves  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29362" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 29362</loc>.</p></item><item><p>Moved definition of <termref def="dt-enclosed-expression">enclosed expression</termref> to prevent it from disappearing in XPath. Resolves  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29382" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 29382</loc>.</p></item><item><p>Modified <specref ref="id-conformance"/> to be more consistent with RFC2119.  Resolves  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29498" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 29498</loc>.</p></item><item><p>Deleted erroneous note in <specref ref="id-unary-lookup"/> that claimed <code>array?*</code> is equivalent to <code>array:flatten</code>. Resolves  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29487" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 29487</loc>.</p></item><item><p>Provided definitions of <termref def="dt-implementation-defined-function">implementation-defined function</termref>, moved definition of <termref def="dt-external-function">external function</termref>
                        <phrase role="xpath">, added definition of <termref def="dt-host-language-function">host language function</termref>
                        </phrase>.  Eliminated references to "host programming languages". Clarified wording on external function declarations. Resolves  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29509" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 29509</loc>.</p></item><item role="xpath"><p>Removed a dangling otherwise clause that belonged to the XQuery specification. Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29693" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 29693</loc>.</p></item><item><p>Made EBNF productions in the document body look the same as those in Appendix A (by adding production annotations to the former), thus eliminating the need to specify which is normative.</p></item><item><p>Clarified ambiguous wording about comments in <specref ref="ExplicitWhitespaceHandling"/>. Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29700" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 29700</loc>.</p></item></olist></div3></div2><div2><head>Changes introduced in the Candidate Recommendation of 17 December 2015</head><div3 id="id-changes-2CR-substantive"><head>Substantive Changes</head><olist><item><p>Significant rewrite of <specref ref="id-xs-error"/>. Resolves  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 29119</loc>. </p></item><item><p>Removed non-normative description of casting rules, referring to the normative definition instead. Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29192" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 29192</loc>.</p></item><item role="xpath"><p>To allow streaming, context size may be undefined in an XPath implementation, in which case <code>last()</code> raises an error. Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29227" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 29227</loc>.</p></item><item role="query"><p>Clarified semantics of external context item declaration in library modules. Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29246" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 29246</loc>.</p></item><item><p>In <specref ref="static_context"/>, clarified that
      only function signatures that are present in the static context
      — not actual function implementations. Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=28175" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 28175</loc>.</p></item><item><p>Changed rules for <termref def="dt-same-key">same key
      value</termref> to improve handling of maps in which keys may or
      may not have timezones.  Resolves  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=28632" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 28632</loc>
      and  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=28729" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 28729</loc>.</p></item><item><p>The precedence of the <specref ref="id-arrow-operator"/> has changed.  Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27537" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 27537</loc>.</p></item><item><p>The error when atomizing a function, map, or array is <code>[err:FOTY0013]</code>, not <code>[err:FOTY0012]</code>.  Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27610" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 27610</loc>.</p></item><item><p>Collections can now contain any item.  This affects <termref def="dt-known-collections">statically known collections</termref>, <termref def="dt-known-collections">statically known collection type</termref>, 
      <termref def="dt-available-collections">available collections</termref> (formerly known as <termref def="dt-available-collections">available node collections</termref>, 
      <termref def="dt-default-collection">default collection</termref> (formerly known as <termref def="dt-default-collection">default node collection</termref>, 
      <specref ref="id-consistency-constraints"/>, 
      <specref ref="id-input-sources"/>.</p></item><item><p>Fixed outdated text that restricted constructor functions to atomic or generalized atomic types.  Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=28915" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 28915</loc>.</p></item><item><p>Changed the semantics of <specref ref="id-postfix-lookup"/> . Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27536" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 27536</loc>, fixing inadequacies in the earlier resolution.</p></item></olist></div3><div3 id="id-changes-PR-editorial"><head>Editorial Changes</head><olist><item><p>Refactored the grammar to use <code role="xpath">EnclosedExpr</code>  consistently.</p></item><item><p>Added a paragraph clarifying the type of an array as a function.   Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29260" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 29260</loc>.</p></item><item><p>Clarified how function coercion applies to maps and arrays using two examples.  Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27059" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 27059</loc>.</p></item><item><p>Removed nine operators from <specref ref="mapping"/> to eliminate redundant specification. Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=22456" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 22456</loc>.</p></item><item role="xpath"><p>Modified <specref ref="id-conformance"/> to use the term <termref def="mustnot">MUST NOT</termref>. Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=28023" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 28023</loc>.</p></item><item><p>Added explicit semantics for NCName in <specref ref="id-lookup"/>.  Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=28701" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 28701</loc>.</p></item><item><p>Deleted obsolete discussion of named function references and <code>xs:numeric</code>.
         Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=28081" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 28081</loc>.</p></item><item role="xpath"><p>Removed the unused definition of the initial context item.  Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=28905" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 28905</loc>.</p></item><item><p>Significantly changed description of names in <specref ref="id-basics"/>.  Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=28241" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 28241</loc>.</p></item><item><p>Fixed a number of dangling references to XQuery/XPath 3.0 where 3.1 was intended. Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=28782" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 28782</loc>.</p></item><item><p>Clarified the text in <specref ref="id-incompatibilities"/> about SequenceType matching and union types. Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=28894" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 28894</loc>.</p></item><item><p>Renamed Available Resource Collections to <termref def="dt-available-uri-collections">Available URI Collections</termref>, 
        renamed Available Node Collections to <termref def="dt-available-collections">Available Collections</termref>, 
        renamed Default Resource Collection to <termref def="dt-default-uri-collection">Default URI Collection</termref>, 
        renamed Default Node Collection to <termref def="dt-default-collection">Default Collection</termref>.
        Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=28957" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 28957</loc>.</p></item><item><p>Clarified the definition of <termref def="dt-built-in-function">built-in functions</termref>.  Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=28282" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 28282</loc>.</p></item><item><p>Clarified the text in <specref ref="id-arrow-operator"/>.  Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=29346" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 29346</loc>.</p></item></olist></div3></div2><div2><head>Changes introduced in the Candidate Recommendation of 18 December 2014</head><div3 id="id-changes-CR-substantive"><head>Substantive Changes</head><olist><item><p>If a value in a map constructor or a member in an array constructor is a map or array, it is copied. If a value in a map
      constructor or a member in an array constructor is a node, it is not copied. Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=26958" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 26958</loc>.</p></item><item><p>In the definition of <termref def="dt-numeric">numeric</termref>, we now state that all numeric types are member types of <code>xs:numeric</code>.  Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=20631" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 20631</loc>.</p></item><item><p>Modified rule 14 of <specref ref="id-itemtype-subtype"/>. Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27175" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 27175</loc>.</p></item><item><p>In <specref ref="id-unary-lookup"/>, if the context item is not a map or an array, a type error [err:XPTY0004] is raised.  If the array index is out of bounds, [err:FOAY0001] is raised. Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27382" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 27382</loc>.</p></item><item><p>Changed the semantics of <specref ref="id-postfix-lookup"/> to <code>for $a in E, $b in S return $a($b)</code>. Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27536" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 27536</loc>.</p></item><item><p>Arrays in element content are flattened, not atomized. Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27463" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 27463</loc>.</p></item><item><p>
                        <specref ref="id-arrow-operator"/> is now well defined when the left hand operand is a sequence rather than an item.  Partially resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27537" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 27537</loc>.</p></item></olist></div3><div3 id="id-changes-CR-editorial"><head>Editorial Changes</head><olist><item><p>Modified the wording used to describe node identity per <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27048" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 27048</loc>, comment #2.</p></item><item><p>Fixed specification gaps in unary lookup.  Resolves <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27455" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 27455</loc>.</p></item></olist></div3></div2><div2 id="id-changes-prior-drafts"><head>Changes introduced in prior Working Drafts</head><!--  <div3 id="id-changes-WD-substantive">
    <head>Substantive Changes</head>
--><olist><item diff="chg" at="bug28782"><p>Added <specref ref="id-maps"/> and <specref ref="id-arrays"/>. These are the most important new features in XPath 3.1</p></item><item><p>Clarified error code XQST0134 for XPath implementations that do not support the namespace axis, default axis for namespace-node() in abbreviated syntax. Resolves  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=26788" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 26788</loc>.</p></item><item><p>Simplified type conversions for value comparisons and orderspecs, eliminating the concept of lowest common supertype. Resolves  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=26453" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 26453</loc>.</p></item><item><p>Modified text of <specref ref="id-general-comparisons"/> to clarify that the result of a comparison can be either false or an error. Resolves  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=26832" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 26832</loc>.</p></item><item diff="del"><p>Fixed an example that lists the namespaces for an element node.  Resolves  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=26029" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Bug 26029</loc>.</p></item><item><p>Added <specref ref="id-map-constructors"/> and <specref ref="id-map-lookup"/>.</p></item><item><p>Added <specref ref="id-array-constructors"/> and <specref ref="id-array-lookup"/>.</p></item><item><p>Defined <specref ref="id-atomization"/> of an array (atomization of a map is an error).</p></item><item><p>Added <specref ref="id-map-test"/> and <specref ref="id-array-test"/> to test whether an item is a map or an array respectively.</p></item><item><p>Added <code>exponent-separator</code> to the static context to support <code>fn:format-number()</code>.</p></item><item><p>Eliminated use of to array functions that are no longer in Functions &amp; and Operators, such as <code>fn:seq()</code>. Changed <code>ay:</code> prefix to <code>array:</code> to match current  Functions &amp; and Operators.</p></item><item><p>Added <specref ref="id-map-lookup"/>, replacing the less general map lookup operator from the previous Working Draft.</p></item><item><p>
                     <specref ref="id-array-lookup"/> with negative integer arguments are no longer type errors, they are dynamic errors.</p></item><item><p>If the keys in a <specref ref="id-map-constructors"/>
      contain both date/time values with a timezone and date/time
      values with no timezone, a dynamic error is raised. </p></item><item><p>In maps, keys of type <code>xs:untypedAtomic</code> are no longer converted to <code>xs:string</code>.</p></item></olist><!--  </div3> --><!-- 
  <div3 id="id-changes-prior-drafts-substantive">
    <head>Substantive Changes</head>

    <p>The following substantive changes have been made in prior Working Drafts.</p>

    <olist>
      <item><p></p></item>
    </olist>
  </div3>

  <div3 role="xquery" id="id-changes-prior-drafts-editorial">
    <head>Editorial Changes</head>

    <p>The following are some of the editorial changes that have been made.</p>

    <olist>
      <item><p></p></item>
    </olist>


  </div3>
--></div2></inform-div1></back></spec>