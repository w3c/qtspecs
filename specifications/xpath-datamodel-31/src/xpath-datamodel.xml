<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE spec SYSTEM "../../../schema/xsl-query.dtd"[

<!-- Things to update in these ENTITY definitions before publishing this document:
* Relationships between doc.stage, w3c-doctype, and doc.w3c-doctype-full
* doc.stage  w3c-doctype  doc.w3c-doctype-full
* FPWD       wd           First Public Working Draft
  WD         wd           Working Draft
  WD         wd           Last Call Working Draft
  CR         cr           Candidate Recommendation
  PR         pr           Proposed Recommendation
  PER        per          Proposed Edited Recommendation
  REC        rec          Recommendation
  WGNOTE     note         Working Group Note
* date.day, date.DD, date.month, date.monthnum, and date.year must represent the date of publication of the document
* doc.w3c-prevdesignation must properly represent the stage and shortname of the immediately preceding publication of the document
* Various status section generation ENTITY definitions below must be properly updated
-->

<!ENTITY doc.version "3.1">
<!ENTITY doc.major-version "3">
<!ENTITY doc.version-code "31">
<!ENTITY doc.stage "REC">
<!ENTITY doc.w3c-doctype "rec">
<!ENTITY doc.w3c-doctype-full "Recommendation">

<!ENTITY date.day "21">
<!ENTITY date.DD "21">
<!ENTITY date.month "March">
<!ENTITY date.monthnum "03">
<!ENTITY date.year "2017">
<!ENTITY doc.date "&date.year;&date.monthnum;&date.DD;">

<!ENTITY w3c.tr "https://www.w3.org/TR">
<!ENTITY doc.generic-shortname "xpath-datamodel">
<!ENTITY doc.shortname "&doc.generic-shortname;-&doc.version-code;">
<!ENTITY doc.w3c-designation "&doc.stage;-&doc.shortname;">
<!ENTITY doc.publoc "&w3c.tr;/&date.year;/&doc.w3c-designation;-&doc.date;/">
<!ENTITY doc.latestloc "&w3c.tr;/&doc.shortname;/">
<!ENTITY doc.latestloc-major "&w3c.tr;/&doc.generic-shortname;-&doc.major-version;/">
<!ENTITY doc.latestloc-tech "&w3c.tr;/&doc.generic-shortname;/">
<!ENTITY language-tech "XQuery and XPath Data Model">
<!ENTITY language "XQuery and XPath Data Model &doc.version;">
<!ENTITY language-major "XQuery and XPath Data Model &doc.major-version;">
<!-- ************************ THIS MUST BE EITHER 'WG Review Draft' OR ''   ************** -->
<!ENTITY version "">
<!-- ************************************************************************************* -->

<!ENTITY Document SYSTEM "document.xml">
<!ENTITY Element  SYSTEM "element.xml">
<!ENTITY Attribute  SYSTEM "attribute.xml">
<!ENTITY Namespace  SYSTEM "namespace.xml">
<!ENTITY ProcessingInstruction  SYSTEM "processing-instruction.xml">
<!ENTITY Comment  SYSTEM "comment.xml">
<!ENTITY Text  SYSTEM "text.xml">
<!ENTITY ChangeLog  SYSTEM "changelog.xml">

<!ENTITY documentNode "Document Node">
<!ENTITY elementNode "Element Node">
<!ENTITY attributeNode "Attribute Node">
<!ENTITY namespaceNode "Namespace Node">
<!ENTITY processingInstructionNode "Processing Instruction Node">
<!ENTITY commentNode "Comment Node">
<!ENTITY textNode "Text Node">

<!ENTITY dm-example.xml SYSTEM "../build/dm-example.xml.cdata">
<!ENTITY dm-example.xsd SYSTEM "../build/dm-example.xsd.cdata">
<!ENTITY dm-example.tbl SYSTEM "../build/dm-example.tbl.xml">
<!ENTITY xdt-schema-app SYSTEM "xdt-schema-app.xml">
<!ENTITY xdt-datatypes  SYSTEM "xdt-datatypes.xml">
<!ENTITY xdt-isoref     '<bibref ref="ISO8601"/>'>

<!ENTITY dm.prop.attributes   "<emph role='dm-node-property'>attributes</emph>">
<!ENTITY dm.prop.base-uri     "<emph role='dm-node-property'>base-uri</emph>">
<!ENTITY dm.prop.node-kind    "<emph role='dm-node-property'>node-kind</emph>">
<!ENTITY dm.prop.children     "<emph role='dm-node-property'>children</emph>">
<!ENTITY dm.prop.content      "<emph role='dm-node-property'>content</emph>">
<!ENTITY dm.prop.namespaces   "<emph role='dm-node-property'>namespaces</emph>">
<!ENTITY dm.prop.nilled	      "<emph role='dm-node-property'>nilled</emph>">
<!ENTITY dm.prop.node-name    "<emph role='dm-node-property'>node-name</emph>">
<!ENTITY dm.prop.parent	      "<emph role='dm-node-property'>parent</emph>">
<!ENTITY dm.prop.prefix	      "<emph role='dm-node-property'>prefix</emph>">
<!ENTITY dm.prop.string-value "<emph role='dm-node-property'>string-value</emph>">
<!ENTITY dm.prop.target	      "<emph role='dm-node-property'>target</emph>">
<!ENTITY dm.prop.type-name    "<emph role='dm-node-property'>schema-type</emph>">
<!ENTITY dm.prop.uri          "<emph role='dm-node-property'>uri</emph>">
<!ENTITY dm.prop.typed-value  "<emph role='dm-node-property'>typed-value</emph>">

<!ENTITY % status-entities SYSTEM "../../../etc/status-entities.dtd">
%status-entities;

<!ENTITY doc.WD-pubdate "24 April 2014">
<!ENTITY doc.LC-pubdate "7 October 2014">
<!ENTITY doc.LC-comments-due "7 November 2014">
<!ENTITY doc.CR-pubdate "13 December 2016">
<!ENTITY doc.CR-comments-due "10 January 2017">
<!ENTITY doc.PR-expected "10 January 2017">
<!ENTITY doc.PR-pubdate "17 January 2017">
<!ENTITY doc.PR-comments-due "28 February 2017">
<!ENTITY doc.REC-pubdate "21 March 2017">

<!ENTITY doc.pubdate "&doc.REC-repubdate;">
<!ENTITY doc.comments-due "&doc.PR-comments-due;">


<!ENTITY status-section-id "status">
<!ENTITY spec-devby    "&devby.joint1;">
<!ENTITY changelog-id  "ChangeLog">
<!ENTITY changes-para  "&post.PR.nochanges;">
<!ENTITY implementation-report '&no-implementation-report-exists;'>
<!ENTITY implementation-report-location "">
<!ENTITY implementation-report-availability "">
<!ENTITY test-suite-location "">
<!ENTITY Bugzilla-key "XDM31">
<!ENTITY patent-policy-paragraph "&ppp-two;">
<!ENTITY documents-and-relationships "&set-of-documents-30-preREC;">
<!ENTITY advancement.statement "&advance.2WGs;">
<!ENTITY document-stage "&doc-stage-REC;">
<!ENTITY doc-stability "&doc-stability-REC;">

<!ENTITY PR-entrance-criteria '<p>This document will be
considered ready for transition to Proposed Recommendation
at the same time that the XQuery 3.1 specification is ready
for transition to Proposed Recommendation. </p>'>
<!ENTITY features-at-risk-para "&no-features-at-risk;">
<!ENTITY features-at-risk "">

<!ENTITY customized-paragraph '<p diff="chg" at="2013-12-06">This &doc.w3c-doctype-full; specifies the XQuery and XPath Data Model (XDM)
                               version 3.1, a fully compatible extension of <loc href="https://www.w3.org/TR/xpath-datamodel-30/">XDM version 3.0</loc>. </p>'>

<!ENTITY status-section SYSTEM "../../../etc/status-general.xml">
]>

<!-- <spec id="spec-top" w3c-doctype="&doc.w3c-doctype;" status="int-review"> -->
<spec id="spec-top" w3c-doctype="&doc.w3c-doctype;">
  <header id="spec-header">
    <title>&language;</title>
  <version>&version;</version>
  <w3c-designation>&doc.w3c-designation;</w3c-designation>
  <w3c-doctype>W3C &doc.w3c-doctype-full;</w3c-doctype>
  <pubdate diff="chg" at="2013-12-06">
    <day>&date.day;</day>
    <month>&date.month;</month>
    <year>&date.year;</year>
  </pubdate>
  <publoc>
    <loc diff="chg" at="2014-12-18" href="&doc.publoc;">&doc.publoc;</loc>
  </publoc>
<!-- These altlocs URIs are computed from the concatenation of doc.public, doc.shortname, and either '.xml' or
     '-diff-from-yyyymmdd.html', where 'yyyymmdd' is the earlier version of the spec from which a diff has been produced -->
  <altlocs>
      <loc diff="chg" at="2014-12-18" href="&doc.publoc;&doc.shortname;.xml">XML</loc>
      <loc diff="chg" at="2014-12-18" href="&doc.publoc;&doc.shortname;-diff.html">Change markings relative to previous edition</loc>
  </altlocs>
<!-- The latestloc URI is computed from doc.latestloc -->
  <latestloc doc="&language;">
    <loc diff="chg" at="2014-12-18" href="&doc.latestloc;">&doc.latestloc;</loc>
  </latestloc>
<!-- These prevlocs URIs are always hard-coded and are never computed from entities -->
<!-- Pubrules doesn't like FPWD to have a prevloc, not even a previous Recommendation -->
  <prevlocs doc="&language;" diff="chg" at="2014-12-18">
    <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/TR/2017/PR-xpath-datamodel-31-20170117/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://www.w3.org/TR/2017/PR-xpath-datamodel-31-20170117/</loc>
    <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/TR/2016/CR-xpath-datamodel-31-20161213/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://www.w3.org/TR/2016/CR-xpath-datamodel-31-20161213/</loc>
    <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="https://www.w3.org/TR/2014/CR-xpath-datamodel-31-20141218/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">https://www.w3.org/TR/2014/CR-xpath-datamodel-31-20141218/</loc>
  </prevlocs>
  <latestloc-major doc="&language-major;">
    <loc href="&doc.latestloc-major;">&doc.latestloc-major;</loc>
  </latestloc-major>
  <latestloc-tech doc="&language-tech;">
    <loc href="&doc.latestloc-tech;">&doc.latestloc-tech;</loc>
  </latestloc-tech>
  <prevrec doc="&language-tech;">
    <loc href="https://www.w3.org/TR/2014/REC-xpath-datamodel-30-20140408/">https://www.w3.org/TR/2014/REC-xpath-datamodel-30-20140408/</loc>
  </prevrec>
  <authlist>

    <author>
      <name>Norman Walsh (XML Query WG)</name>
      <affiliation>MarkLogic Corporation</affiliation>
      <email href="mailto:Norman.Walsh@marklogic.com">Norman.Walsh@marklogic.com</email>
    </author>
    <author>
      <name><phrase><loc href="http://john.snelson.org.uk">John Snelson</loc> (XML Query WG)</phrase></name>
      <affiliation>MarkLogic Corporation</affiliation>
      <email href="mailto:john.snelson@marklogic.com">john.snelson@marklogic.com</email>
    </author>
    <author>
      <name>Andrew Coleman (XML Query WG)</name>
      <affiliation>IBM Hursley Laboratories</affiliation>
      <email href="mailto:andrew_coleman@uk.ibm.com">andrew_coleman@uk.ibm.com</email>
    </author>
  </authlist>
  <errataloc href="https://www.w3.org/XML/2017/qt-errata/xpath-datamodel-31-errata.html"
    xlink:type="simple" xmlns:xlink="http://www.w3.org/1999/xlink"/>

  <translationloc href="https://www.w3.org/2003/03/Translations/byTechnology?technology=xpath-datamodel-31"/>


&status-section;

<abstract>
<p>This document defines the <phrase diff="chg" at="2013-12-06">&language;,
which is the data model of <bibref ref="xpath-31"/>,
<bibref ref="xslt-30"/>, and <bibref ref="xquery-31"/></phrase>, and any other
specifications that reference it.
This document is the result of joint
work by the <bibref ref="XSLWG"/> and the <bibref ref="XQWG"/>.</p>
</abstract>

<langusage>
<language id="en">English</language>
</langusage>

<revisiondesc>
<p>See the CVS changelog.</p>
</revisiondesc>
</header>

<body>

<div1 id="intro">
<head>Introduction</head>

<p>This document defines the <phrase diff="chg" at="2013-12-06">&language;,
which is the data model of <bibref ref="xpath-31"/>, <bibref ref="xslt-30"/>, and
<bibref ref="xquery-31"/></phrase>. </p>

<p diff="del" at="2014-12-01">In this document, examples and material
labeled as <quote>Note</quote> are provided for explanatory purposes
and are not normative. </p>

<p>The &language; (henceforth "data model")
serves two purposes.
First, it defines the information contained in the input to an
XSLT or XQuery processor.  Second, it defines all permissible values of
expressions in the XSLT, XQuery, and XPath languages.  A
language is <emph>closed</emph> with respect to a data model if the value
of every expression in the language is guaranteed to be in the data model.
<phrase diff="chg" at="2013-12-06">XSLT 3.0, XQuery 3.1, and XPath 3.1</phrase> are all closed with respect to
the data model.</p>

<p>The data model <phrase diff="del" at="2016-12-06">is based on</phrase>
<phrase diff="add" at="2016-12-06">describes items similar to those of</phrase> 
the <bibref ref="xml-infoset"/>
(henceforth "Infoset")<phrase diff="del" at="2016-12-06">, but it requires the following new features to
meet the
<bibref diff="chg" at="2013-12-06" ref="xquery-31-requirements"/>:</phrase><phrase diff="add" at="2016-12-06">.
 It is written to provide a data model suitable for XPath, XQuery and XSLT, which was not a goal of the Infoset,
 and this leads to a number of differences, some of which are:
</phrase>
</p>

<ulist>
  <item>
    <p>Support for XML Schema types. The XML Schema recommendations
    define features, such as structures (<bibref ref="xmlschema-1"/>)
    and simple data types (<bibref ref="xmlschema-2"/>), that extend
    the Infoset with precise type information.</p>
  </item>
  <item>
    <p>Representation of collections of documents and of
    complex values. (<bibref diff="chg" at="2013-12-06" ref="xquery-31-requirements"/>)</p>
  </item>
  <item>
    <p>Support for typed atomic values.</p>
  </item>
  <item>
    <p>Support for ordered, heterogeneous sequences.</p>
  </item>
</ulist>

<p>As with the Infoset, the &language;
specifies what information in the documents is accessible but does
not specify the programming-language interfaces or bindings used to
represent or access the data.</p>

<p>The data model can represent various
values including not only the input and the output of a stylesheet or query, but all
values of expressions used during the intermediate calculations.
Examples include the input document or document repository (represented
as a &documentNode; or a sequence of &documentNode;s), the result of a
path expression (represented as a sequence of nodes), the result of an
arithmetic or a logical expression (represented as an atomic value),
a sequence expression resulting in a sequence of items, etc.
</p>

<p>This document provides a precise definition of the properties of nodes
in the &language;, how they are accessed, and how
they relate to values in the Infoset and PSVI.</p>

</div1>

<div1 id="concepts">
<head>Concepts</head>

<p>This section outlines a number of general concepts that apply throughout
this specification.</p>

<p>In this document, examples and material labeled as "Note" are provided for
explanatory purposes and are not normative.</p>

<div2 id="terminology">
<head>Terminology</head>

<p>For a full glossary of terms, see <specref ref="glossary"/>.</p>

<p>In this specification the words <rfc2119>must</rfc2119>,
<rfc2119>must not</rfc2119>,
<rfc2119>should</rfc2119>,
<rfc2119>should not</rfc2119>,
<rfc2119>may</rfc2119> and
<rfc2119>recommended</rfc2119>
are to be interpreted as described in <bibref ref="RFC2119"/>.</p>

<p>This specification distinguishes between the data model as a general
concept and specific items (documents, elements, atomic values, etc.)
that are concrete examples of the data model by identifying all concrete
examples as <termref def="dt-instance">instances of the data model</termref>.
</p>

<p><termdef id="dt-instance" term="instance of the data model">Every
<term>instance of the data model</term> is a
<termref def="dt-sequence">sequence</termref>.</termdef>
</p>

<p><termdef id="dt-sequence" term="sequence">A <term>sequence</term>
is an ordered collection of zero or more <termref
def="dt-item">items</termref>.</termdef> A sequence cannot be a member
of a sequence. A single item appearing on its own is modeled as a
sequence containing one item. Sequences are defined in <specref
ref="sequences"/>.</p>

<p><termdef id="dt-item" term="item">An <term>item</term>
is either
a <termref def="dt-node">node</termref>,
a <termref def="dt-function-item">function</termref>,
or an <termref def="dt-atomic-value">atomic value</termref>.</termdef>
</p>

<p>Sometimes it is necessary to distinguish the case where a
particular property has no value in the data model. The canonical
example of such a case is the namespace URI property of an
<termref def="dt-expanded-qname">expanded QName</termref>
that is not in any namespace. For such properties, it is
convenient to be able to speak of "the state of having no value".
<termdef id="dt-absent" term="absent">When a property has no value, we
say that it is <term>absent</term>.</termdef>
</p>

<p>Every node is one of the seven kinds of nodes defined in Section <specref
ref="Node"/>. Nodes form a tree. Each node has at most one parent
(reachable via the <function>parent</function> accessor) and descendant
nodes that are reachable directly or indirectly
via the <function>children</function>,
<function>attributes</function>, and
<function>namespace-nodes</function> accessors.</p>
<p><termdef id="dt-root-node" term="root node">The
<term>root node</term> is the topmost node of a tree, the node with no
parent.</termdef>
Every tree has exactly one root node and every other node can be reached
from exactly one root node.
</p>

<note><p>The term “root node” is merely a designator, based on
position, for one of the nodes in the tree without implying what kind
of a node it is. In the XPath 1.0 datamodel the root node was a kind
of node.</p>
</note>

<p><termdef id="dt-document" term="document">A
tree whose root node is a &documentNode; is referred to as a
<term>document</term>.</termdef></p>

<p><termdef id="dt-fragment"
term="fragment">A tree whose root node is not a &documentNode; is
referred to as a <term>fragment</term>.</termdef></p>

<p><termdef id="dt-atomic-value" term="atomic value">An
<term>atomic value</term> is a value in the value space
of an <termref def="dt-atomic-type">atomic type</termref> and is labeled with
the name of that atomic type.</termdef></p>

<p><termdef id="dt-atomic-type" term="atomic type">An <term>atomic type</term>
is a <termref def="dt-primitive-simple-type">primitive simple type</termref>
or a type derived by restriction from
another atomic type.</termdef>
(Types derived by list or union are not atomic.)
</p>

<p><termdef id="dt-primitive-simple-type" term="primitive simple type">The
<term>primitive simple types</term> are the types defined
in <specref ref="xs-types"/>.</termdef></p>

<p>A type is represented in the data model by an
<termref def="dt-expanded-qname">expanded-QName</termref>.
</p>

<p><termdef id="dt-expanded-qname" term="expanded-QName">An
<term>expanded-QName</term> is a set of three values consisting of a
possibly empty prefix, a possibly empty namespace URI, and a local
name.</termdef> See <specref ref="qnames-and-notations"/>.</p>

<p><termdef id="dt-implementation-defined" term="implementation
defined"><term>Implementation-defined</term> indicates an aspect that
may differ between implementations, but must be specified by the
implementor for each particular implementation.</termdef></p>

<p><termdef id="dt-implementation-dependent" term="implementation
dependent"><term>Implementation-dependent</term> indicates an aspect
that may differ between implementations, is not specified by this or
any W3C specification, and is not required to be specified by the
implementor for any particular implementation.</termdef></p>

<p>Within this specification, the term URI refers to a
<phrase diff="chg" at="20150305">Uniform</phrase>
Resource Identifier as defined in
<bibref ref="RFC3986"/> and extended in <bibref ref="RFC3987"/>
with the new name IRI. The term URI has been retained in preference to
IRI to avoid introducing new names for concepts such as “Base URI”
that are defined or referenced across the whole family of XML
specifications.</p>

<p>In all cases where this specification leaves the behavior
implementation-defined or implementation-dependent, the implementation
has the option of providing mechanisms that allow the user to
influence the behavior.</p>

<div3 id="xs-types">
<head>Types adopted from XML Schema</head>

<p>The data model adopts the following types:</p>

<ulist>
<item>
<p>The 19 types defined in
<xspecref spec="XS2" ref="built-in-primitive-datatypes"/>
of <bibref ref="xmlschema-2"/>.</p>
</item>
<item>
<p>Three built-in list types:
<code>xs:NMTOKENS</code>, <code>xs:IDREFS</code>, and <code>xs:ENTITIES</code>.
</p>
<p>The following types which were originally defined in
<bibref ref="xpath-datamodel"/> and were subsequently adopted by
<bibref ref="xmlschema11-2"/>:
<code>xs:anyAtomicType</code>, <code>xs:dayTimeDuration</code>,
<code>xs:yearMonthDuration</code>.
</p>
</item>
<item>
<p>In the case of a processor that supports
<bibref ref="xmlschema11-2"/>, the data model also includes:
the new union type <code>xs:error</code> (a type with no instances)
and the new derived type <code>xs:dateTimeStamp</code>.</p>
</item>
<item>
<p>The following types, although they use the <code>xs:</code> namespace,
are defined here in the data model and not in XML Schema:
<code>xs:untypedAtomic</code><phrase diff="add" at="2016-12-06">,</phrase> and
<code>xs:numeric</code>,
a union type whose members are <code>xs:double</code>, <code>xs:float</code>
and <code>xs:decimal</code>.
</p>
</item>
</ulist>
</div3>
</div2>

<div2 id="notation">
<head>Notation</head>

<p>In addition to prose, this specification defines a set of accessor
functions to explain the data model. The accessors are shown with the
prefix <emph>dm:</emph>. This prefix is always shown in italics to
emphasize that these functions are abstract; they exist to explain the
interface between the data model and specifications that rely on the
data model: they are not accessible directly from the host
language.</p>

<p>Several prefixes are used throughout this document for notational
convenience. The following bindings are assumed.</p>

<olist>
<item><p><code>xs:</code> bound to
<code>http://www.w3.org/2001/XMLSchema</code>
</p></item>
<item><p><code>xsi:</code> bound to
<code>http://www.w3.org/2001/XMLSchema-instance</code>
</p></item>
<item><p><code>fn:</code> bound to
<code>http://www.w3.org/2005/xpath-functions</code>
</p></item>
</olist>

<p>In practice, any prefix that is bound to the appropriate URI may be used.</p>

<p>The signature of accessor functions is shown using the same style as
<bibref diff="chg" at="2013-12-06" ref="xpath-functions-31"/>, described in
<xspecref diff="chg" at="2013-12-06" spec="FO31" ref="func-signatures"/>.</p>

<p>This document relies on the <bibref ref="xml-infoset"/> and
<loc href="https://www.w3.org/TR/xmlschema-1/#key-psvi">Post-Schema-Validation
Infoset</loc> (PSVI). Information items
and properties are indicated by the styles <emph role="info-item">information
item</emph> and <emph role="infoset-property">infoset property</emph>, respectively.</p>

<p>Some aspects of type assignment rely on the ability to access properties of
the schema components. Such properties are indicated by the style
{component property}. Note that this does not mean a lightweight schema processor
cannot be used, it only means that the application must have some mechanism to
access the necessary properties.</p>

</div2>

<div2 id="node-identity">
<head>Node Identity</head>

<p>Each node has a unique identity.
<phrase diff="del" at="2014-12-02">Every node in an
instance of the data model is unique: identical to itself, and not
identical to any other node.</phrase>
<phrase diff="add" at="2014-12-02">The identity of
a node is distinct from its value or other visible properties; nodes may be
distinct even when they have the same values for all intrinsic
properties other than their identity.</phrase>
<phrase diff="del" at="2014-12-02">Atomic
values do not have identity</phrase><phrase diff="add" at="2014-12-02">(The
identity of atomic values, by contrast, is determined solely by their
intrinsic properties. No two distinct integers, for example, have the
same value</phrase>;
every instance of the value “5” as an integer is identical to every
other instance of the value “5” as an integer.)
</p>

<note>
<p>The concept of node identity should not be confused with the
concept of a unique ID, which is a unique name assigned to an element
by the author to represent references using ID/IDREF correlation.</p>
</note>
</div2>

<div2 id="document-order">
<head>Document Order</head>

<p><termdef id="dt-document-order" term="document order">A
<term>document order</term> is defined among all the nodes
accessible during a given query or transformation. Document order is a
total ordering, although the relative order of some nodes is
implementation-dependent. Informally, document order is the order in
which nodes appear in the XML serialization of a document.</termdef>
<termdef id="dt-stable" term="stable">Document order is
<term>stable</term>, which means that the relative order of two
nodes will not change during the processing of a given query or
transformation, even if this order is implementation-dependent.</termdef></p>

<p>Within a tree, document order satisfies the following constraints:</p>

<olist>
<item>
<p>The root node is the first node.
</p>
</item>

<item>
<p>Every node occurs before all of its children and descendants.</p>
</item>

<item>
<p>&namespaceNode;s immediately follow the &elementNode; with which
they are associated. The relative order of &namespaceNode;s is
stable but implementation-dependent.</p>
<imp-dep-feature>The relative order of &namespaceNode;s nodes is
stable but implementation-dependent.</imp-dep-feature>
</item>

<item>
<p>&attributeNode;s immediately follow the &namespaceNode;s of the
element with which they are associated. If there are no
&namespaceNode;s associated with a given element, then the
&attributeNode;s associated with that element immediately
follow the element. The relative order of &attributeNode;s is
stable but implementation-dependent.</p>
<imp-dep-feature>The relative order of &attributeNode;s nodes is
stable but implementation-dependent.</imp-dep-feature>
</item>

<item>
<p>The relative order of siblings is the order in which they occur in
the &dm.prop.children; property of their parent node.</p>
</item>

<item>
<p>Children and descendants occur before following siblings.</p>
</item>
</olist>

<p>The relative order of nodes in distinct trees is stable but
implementation-dependent, subject to the following constraint: If
any node in a given tree, <code>T1</code>, occurs before any node in a different
tree, <code>T2</code>, then all nodes in <code>T1</code> are before all nodes in
<code>T2</code>.</p>
<imp-dep-feature>The relative order of distinct trees is
stable but implementation-dependent.</imp-dep-feature>
</div2>

<div2 id="sequences">
<head>Sequences</head>

<p>An important characteristic of the data model is that there is no
distinction between an item (a node, function, or atomic value) and a
singleton sequence containing that item. An item is
equivalent to a singleton sequence containing that item and vice
versa.</p>

<p>A sequence may contain any mixture of nodes, functions, and atomic values. When a node is added to a sequence its
identity remains the same. Consequently a node may occur in more than
one sequence and a sequence may contain duplicate items.</p>

<p>Sequences never contain other sequences; if sequences are combined,
the result is always a “flattened” sequence. In other words, appending
“(d e)” to “(a b c)” produces a sequence of length 5: “(a b c d e)”.
It <emph>does not</emph> produce a sequence of length 4: “(a b c (d e))”,
such a nested sequence never occurs.</p>

<note>
<p>Sequences replace node-sets from XPath 1.0. In XPath 1.0, node-sets
do not contain duplicates. In generalizing node-sets to sequences in
XPath 3.0<phrase at="2013-12-06" diff="add"> and XPath 3.1</phrase>,
duplicate removal is provided by functions on node sequences.</p>
</note>
<note>
<p diff="add" at="2016-12-06">Arrays and maps are derived from functions and
therefore can also be contained within sequences.</p>
</note>
</div2>

<div2 id="namespace-names">
<head>Namespace Names</head>

<p>The specifications
<bibref ref="xml-names"/> and <bibref ref="xml-names11"/>
introduce
the concept of a namespace name. In <bibref ref="xml-names"/> a namespace name
is required to be a URI; in <bibref ref="xml-names11"/> it is required to be an
IRI; but both specifications explicitly do not require a processor to
check that namespace names appearing in an instance document are in
fact valid URIs or IRIs.</p>

<p><termdef id="dt-namespace-uri" term="Namespace URI"> This
specification uses the term <term>Namespace URI</term> to refer to a
namespace name, whether or not it is a valid URI or IRI</termdef>.
Following the lead of <bibref ref="xml-names"/> and <bibref ref="xml-names11"/>,
processors implementing this data model <rfc2119>may</rfc2119> raise an error if a
namespace name is not a valid URI or IRI (depending on whether they
support
<bibref ref="xml-names"/> or <bibref ref="xml-names11"/>),
but they are <emph>not required</emph> to make any checks.
Note that the use of a relative reference as a namespace name is
deprecated and is defined to be meaningless, but it is not an error.
Namespace names, whatever form they take, are treated as character
strings and compared for equality using codepoint-by-codepoint
comparison, subject only to whitespace normalization if they appear in
a context (for example, within an attribute value) where this is
appropriate.</p>

<p>In some interfaces, namespace names are held as values of type
<code>xs:anyURI</code>. For example, the namespace part of an expanded QName is
defined to be a value of type <code>xs:anyURI</code>. In
<bibref ref="xmlschema-2"/>, the type <code>xs:anyURI</code> imposes some
restrictions on the value space, but there is latitude for
implementors to decide exactly what these restrictions are. In
<bibref ref="xmlschema11-2"/> there are no restrictions on the form of
an <code>xs:anyURI</code> value, so any sequence of characters is
acceptable within the value space. In this and related specifications,
the use of the type <code>xs:anyURI</code> to hold a namespace name does not imply
any restrictions on the value space beyond those described in this
section: implementations <rfc2119>may</rfc2119> reject character strings that are not
valid URIs or IRIs, but they are <emph>not required</emph> to do so.
</p>
</div2>

<div2 id="types">
<head>Schema Information</head>

<p>The data model supports strongly typed languages such as
<bibref diff="chg" at="2013-12-06" ref="xpath-31"/> and <bibref diff="chg" at="2013-12-06" ref="xquery-31"/>
that have a type system based on <bibref ref="xmlschema-1"/>. To achieve this,
the data model includes (by reference) the Schema Component Model described in
<bibref ref="xmlschema-1"/>.
</p>

<note>
<p>The Schema Component Model includes a number of kinds of
component, such as type definitions and element and attribute
declarations, and defines the properties and relationships of these
components. Many of these components and properties are not used by the
language specifications that rely on XDM, and where this is the case,
there is no requirement for implementations to make them visible.
However, this specification makes no attempt to define the minimal
subset of the schema component model that is needed to support the
semantics of XPath and XQuery processing.</p>

<p>There are two main areas where the language semantics depend on
information in schema components:</p>

<olist>
<item>
<p>Expressions are evaluated with respect to a static context, which
includes schema components, specifically type definitions, element
declarations, and attribute declarations. The names of such components
may be used in language constructs only if the components are present in
the static context.</p>
</item>
<item>
<p>Values including element and attribute nodes, and atomic values,
have a property called a type annotation whose value is a type: this is
a reference to a type definition in the Schema Component Model.
</p>
</item>
</olist>
</note>

<p>Every <termref def="dt-item">item</termref> in the data model has
both a value and a type. In addition to nodes, the data model can
represent atomic values like the number 5 or the string “Hello World.”
For each of these atomic values, the data model contains both the
value of the item (such as 5 or “Hello World”) and its type.
The property that holds the type is sometimes referred to
as the type annotation: its value is a type definition component as
defined in the Schema Component Model. This may be a built-in type (a type with a
name such as <code>xs:integer</code> or <code>xs:string</code>), or a user-defined type.
</p>

<p>There is a constraint that the total set of components used during
expression processing (both statically and dynamically) must constitute
a valid schema. This implies, for example, that this total set does not
include two different types with the same expanded name.</p>

<note>
<p>This makes it the responsibility of the processor to ensure that
the schema components used in the static context of a query or
expression during static analysis are consistent with the schema
components used to validate documents during query or expression
evaluation. This specification does not say how this should be achieved.
</p>
</note>

<p>It is also a constraint that the schema available to the processor must
contain at least the components and properties needed to correctly
implement the semantics of the XPath and XQuery language. For example,
this means that given a node with a particular type annotation T, and a
function that expects an argument of type S, there must be sufficient
information available to the processor to establish whether or not T is
derived from S. As with other consistency constraints described in this
data model, it is a precondition that these constraints are satisfied;
the specifications do not speculate on what happens if they are not.</p>

<div3 id="types-representation">
<head>Representation of Types</head>

<p>The data model uses
<termref def="dt-expanded-qname">expanded-QNames</termref> to
represent the names of schema types, which include the built-in
types defined by <bibref ref="xmlschema-2"/>, five additional types
defined by this specification, and may include other user- or
implementation-defined types.</p>

<imp-def-feature>Support for additional user-defined or
implementation-defined types is implementation-defined.</imp-def-feature>

<p>For XML Schema types, the namespace name of the expanded-QName is
the {target namespace} property of the type definition, and its local
name is the {name} property of the type definition.</p>

<p>The data model relies on the fact that an expanded-QName uniquely
identifies every named type. Although it is possible for different
schemas to define different types with the same expanded-QName, at
most one of them can be used in any given validation episode. The data model
cannot support environments where different types with the same expanded-QName
are available.
</p>

<imp-dep-feature>The names of anonymous types are implementation-dependent.
</imp-dep-feature>

<p>The scope over which the names of anonymous types must be
meaningful and distinct is depends on the processing context.
It is the responsibility of the host language to define the
size and scope of the processing context.</p>

</div3>

<div3 id="types-predefined">
<head>Predefined Types</head>

<p>In addition to the 19 types defined in
<xspecref spec="XS2" ref="built-in-primitive-datatypes"/>
of <bibref ref="xmlschema-2"/>, the data model defines five
additional types: <code>xs:anyAtomicType</code>,
<code>xs:untyped</code>, <code>xs:untypedAtomic</code>,
<code>xs:dayTimeDuration</code>, and
<code>xs:yearMonthDuration</code>.
These types are defined in the XML Schema namespace with permission
of the XML Schema Working Group; in implementations that support
<bibref ref="xmlschema11-2"/>, the XSD 1.1 definitions of
<code>xs:anyAtomicType</code>, <code>xs:dayTimeDuration</code>,
and <code>xs:yearMonthDuration</code> supersede the definitions in this
specification.
</p>

&xdt-datatypes;

<p>A schema for <code>xs:dayTimeDuration</code> and
<code>xs:yearMonthDuration</code> is provided in <specref
ref="xdtschema"/>.</p>
</div3>

<div3 id="xml-and-xsd-versions">
<head>XML and XSD Versions</head>

<p>Some of the types defined in XML Schema have differing definitions
in XSD 1.0 and XSD 1.1; furthermore, some types are defined by
reference to other specifications including XML and XML Namespaces,
and these too may vary from one version of the specification to the
next.</p>

<p>As a general policy, implementations of data types
<rfc2119>should</rfc2119> support the latest definitive version of any
referenced specification, even if that is published after the date of
this specification.</p>

<p>This means, for example, that the xs:string data type <rfc2119>should</rfc2119> (at
the time of writing) support the set of characters defined by the Char
production in XML 1.1 Second Edition. Similarly, the xs:anyURI data
type <rfc2119>should</rfc2119> support the definition used in XSD 1.1 (which allows any
sequence of characters), and the xs:NCName data type <rfc2119>should</rfc2119> support
the definition based on the syntax of a name as defined in both XML
1.1 Second Edition and XML 1.0 Fifth Edition (which are the same).</p>

<p>In practice interoperability problems can arise both because
specifications are not always in synchronization with each other (for
example, XSD 1.0 contains referenced to dated versions of XML 1.0
other than the latest version), and also because implementations <rfc2119>may</rfc2119>
use third-party components (such as XML parsers, serializers, and
schema validators) that were built against different versions of the
base specifications. For these reasons, use of the latest version of
referenced specifications is generally <emph>recommended</emph> but not
<emph>required</emph>.
It is implementation-dependent how a processor handles any such
conflicts.</p>

<p><termdef term="string" id="dt-string">A
<term>string</term>
<phrase diff="chg" at="20150305">is a sequence of zero or more
<termref def="dt-character">characters</termref>, or equivalently, a
value in the value space of the <code>xs:string</code> data
type.</phrase></termdef></p>

<p><termdef term="character" id="dt-character">
A <term>character</term> is an instance of the <code>Char</code> production in
<phrase diff="del" at="20150305">[XML]</phrase><phrase diff="add"
at="20150305"><bibref ref="xml"/></phrase>.
<phrase diff="del" at="20150305">It
is <emph>recommended</emph> that the implementation use the latest
definition, currently <emph>XML 1.1 Second Edition</emph>.</phrase></termdef></p>

<p diff="add" at="20150305"><termdef id="dt-codepoint" term="codepoint">A
<term>codepoint</term> is a non-negative integer assigned to a
<termref def="dt-character">character</termref> by the Unicode
consortium, or reserved for future assignment to a
character.</termdef></p>

</div3>

<!-- Jim: New text to correspond to new graphics and to new tables copied from F&O, 2009-10-21 -->
<div3 id="types-hierarchy">
<head>Type System</head>

<p diff="chg" at="20140909">The diagrams below show how nodes, functions,
<termref def="dt-primitive-simple-type">primitive simple types</termref>,
and user defined types fit together into a type system.
This type system comprises two distinct subsystems that both include
the primitive simple types. 
In the diagrams, connecting lines represent relationships between derived types
and the types from which they are derived;
the arrowheads point toward the type from which they are derived. 
The dashed line represents relationships not present in this diagram,
but that appear in one of the other diagrams. 
Dotted lines represent additional relationships that follow an evident pattern.
The information that appears in each diagram is recapitulated in tabular form.
</p>

<p diff="chg" at="20140909">The <code>xs:IDREFS</code>, <code>xs:NMTOKENS</code>,
<code>xs:ENTITIES</code> types, and <code>xs:numeric</code> and both the
<code>user-defined list types</code> and
<code>user-defined union types</code>
are special types in that these types are lists or unions
rather than types derived by extension or restriction.</p>

<p diff="chg" at="20140909">The first diagram and its corresponding table illustrate
the relationship of various item types. Item types in the data model
form a directed graph, rather than a hierarchy or lattice: in the relationship defined
by the <code>derived-from(A, B)</code> function, some types are derived
   from more than one other type. Examples include functions (<code>function(xs:string) as xs:int</code>
   is substitutable for <code>function(xs:NCName) as xs:int</code> and also for 
   <code>function(xs:string) as xs:decimal</code>), and union types (<code>A</code>
 is substitutable for <code>union(A, B)</code> and also for <code>union(A, C)</code>.
   In XDM, item types include node types, function types, and built-in atomic types. 
The diagram, which shows only hierarchic relationships, is therefore a simplification of
the full model.</p>

<graphic source="XPathTypeHierarchy-1-items-3.1.png" alt="Type hierarchy graphic, item hierarchy" diff="chg" at="20140909"/>

<p>In the table, each type whose name is indented is derived from the type
whose name appears nearest above it with one less level of indentation.</p>

<table role="hierarchy">
  <tbody>
    <tr>
      <td>item</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td>xs:anyAtomicType</td>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td>node</td>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td>attribute</td>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td/>
      <td>user-defined attribute types</td>
    </tr>
    <tr>
      <td/>
      <td/>
      <td>comment</td>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td>document</td>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td/>
      <td>user-defined document types</td>
    </tr>
    <tr>
      <td/>
      <td/>
      <td>element</td>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td/>
      <td>user-defined element types</td>
    </tr>
    <tr>
      <td/>
      <td/>
      <td>namespace</td>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td>processing-instruction</td>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td>text</td>
      <td role="dummy"/>
    </tr>
    <tr>
      <td></td>
      <td>function(*)</td>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>array(*)</td>
      <td role="dummy"/>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>map(*)</td>
      <td role="dummy"/>
    </tr>
  </tbody>
</table>

<p diff="chg" at="20140909">The next diagram and table illustrate the <quote>any type</quote> type subsystem, in which
all types are derived from distinguished type <code>xs:anyType</code>. </p>

<graphic source="XPathTypeHierarchy-2-anyTypes-3.1.png" alt="Type hierarchy graphic, anyType hierarchy" diff="chg" at="20140909"/>

<p>In the table, each type whose name is indented is derived from the type
whose name appears nearest above it with one less level of indentation.</p>

<table role="hierarchy">
  <tbody>
    <tr>
      <td>xs:anyType</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td>xs:anySimpleType</td>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td>xs:anyAtomicType</td>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td>list types</td>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td/>
      <td>xs:IDREFS</td>
    </tr>
    <tr>
      <td/>
      <td/>
      <td/>
      <td>xs:NMTOKENS</td>
    </tr>
    <tr>
      <td/>
      <td/>
      <td/>
      <td>xs:ENTITIES</td>
    </tr>
    <tr>
      <td/>
      <td/>
      <td/>
      <td>user-defined list types</td>
    </tr>
    <tr>
      <td/>
      <td/>
      <td>union types</td>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td/>
      <td>xs:numeric</td>
    </tr>
    <tr>
      <td/>
      <td/>
      <td/>
      <td>user-defined union types</td>
    </tr>
    <tr>
      <td/>
      <td>complex types</td>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td>xs:untyped</td>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td>user-defined complex types</td>
      <td role="dummy"/>
    </tr>
  </tbody>
</table>

<p diff="chg" at="20140909">The final diagram and table show all of the atomic types, including the primitive simple types and the
built-in types derived from the primitive simple types. 
This includes all the built-in datatypes defined in <bibref ref="xmlschema-2"/>.</p>

<graphic source="XPathTypeHierarchy-3-anyAtomicTypes-3.1.png" alt="Type hierarchy graphic, anyAtomicType hierarchy" diff="chg" at="20140909"/>

<p>In the table, each type whose name is indented is derived from the type
whose name appears nearest above it with one less level of indentation.</p>

<table role="hierarchy">
  <tbody>
    <tr>
      <td>xs:untypedAtomic</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td>xs:dateTime</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td>xs:dateTimeStamp</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td>xs:date</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td>xs:time</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td>xs:duration</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td>xs:yearMonthDuration</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td>xs:dayTimeDuration</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td>xs:float</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td>xs:double</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td>xs:decimal</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td>xs:integer</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td>xs:nonPositiveInteger</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td/>
      <td>xs:negativeInteger</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td>xs:long</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td/>
      <td>xs:int</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td/>
      <td/>
      <td>xs:short</td>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td/>
      <td/>
      <td/>
      <td>xs:byte</td>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td>xs:nonNegativeInteger</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td/>
      <td>xs:unsignedLong</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td/>
      <td/>
      <td>xs:unsignedInt</td>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td/>
      <td/>
      <td/>
      <td>xs:unsignedShort</td>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td/>
      <td/>
      <td/>
      <td/>
      <td>xs:unsignedByte</td>
    </tr>
    <tr>
      <td/>
      <td/>
      <td/>
      <td>xs:positiveInteger</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td>xs:gYearMonth</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td>xs:gYear</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td>xs:gMonthDay</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td>xs:gDay</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td>xs:gMonth</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td>xs:string</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td>xs:normalizedString</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td>xs:token</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td/>
      <td>xs:language</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td/>
      <td>xs:NMTOKEN</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td/>
      <td>xs:Name</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td/>
      <td/>
      <td>xs:NCName</td>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td/>
      <td/>
      <td/>
      <td>xs:ID</td>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td/>
      <td/>
      <td/>
      <td>xs:IDREF</td>
      <td role="dummy"/>
    </tr>
    <tr>
      <td/>
      <td/>
      <td/>
      <td/>
      <td/>
      <td>xs:ENTITY</td>
      <td role="dummy"/>
    </tr>
    <tr>
      <td>xs:boolean</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td>xs:base64Binary</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td>xs:hexBinary</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td>xs:anyURI</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td>xs:QName</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
    <tr>
      <td>xs:NOTATION</td>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
      <td role="dummy"/>
    </tr>
  </tbody>
</table>

</div3>

<div3 id="AtomicValue">
<head>Atomic Values</head>

<p>An atomic value can be constructed from a lexical
representation. Given a string and an atomic type, the atomic value is
constructed in such a way as to be
<loc href="#typed-string-relationships">consistent with schema validation</loc>.
If the
string does not represent a valid value of the type, an error is
raised. When <code>xs:untypedAtomic</code> is specified as the type,
no validation takes place. The details of the construction are
described in <phrase at="2013-12-06" diff="chg"><xspecref spec="FO31" ref="constructor-functions"/>
and the related <xspecref spec="FO31" ref="casting"/>
section of <bibref ref="xpath-functions-31"/>.</phrase>
</p>
</div3>

<div3 id="StringValue">
<head>String Values</head>

<p>A string value can be constructed from an atomic value.
Such a value is constructed by
converting the atomic value to its string representation as described
in <phrase at="2013-12-06" diff="chg"><xspecref spec="FO31" ref="casting"/></phrase>.
Using the canonical lexical representation for atomic values
is not always compatible with XPath 1.0. These and other backwards
incompatibilities are described in
<phrase at="2013-12-06" diff="chg"><xspecref spec="XP31" ref="id-backwards-compatibility"/></phrase>.</p>
</div3>

<div3 id="NegativeZero">
<head>Negative Zero</head>

<p>The <code>xs:float</code> and <code>xs:double</code> data types
in the data model have the same value space as in
XML Schema 1.1 (<bibref ref="xmlschema11-2"/>).
Specifically they include both negative and positive zero, and in this
respect they differ from XML Schema 1.0.</p>

<p>To accommodate this difference,
when converting from an
<code>xs:string</code> to an <code>xs:float</code> or
<code>xs:double</code>, it is implementation-defined whether the
lexical value “-0” (and similar forms such as “-0.0”) convert to
negative zero or to positive zero in the value space.</p>

<!-- I think it's *really* weird that imp-def-feature and imp-dep-feature
     produce no output in the normal flow, but I'm not going to try to
     change that today. -->
<imp-def-feature>When converting from an
<code>xs:string</code> to an <code>xs:float</code> or
<code>xs:double</code>, it is implementation-defined whether the
lexical value “-0” (and similar forms such as “-0.0”) convert to
negative zero or to positive zero in the value space.</imp-def-feature>
</div3>

</div2>

<!-- ************************************************** -->

<div2 id="other-items">
<head>Other Items</head>

<p>The XPath Data Model is the abstraction over which XPath expressions are evaluated.
Historically, all of the items in the data model could be derived directly (nodes) or
indirectly (typed values, sequences) from an XML document. However, as the XPath
expression language has matured, new features have been added which require additional
types of items to appear in the data model. These items have no direct XML serialization,
but they are never the less part of the data model.
</p>

<div3 id="function-items">
<head>Functions</head>

<p>
<termdef term="function" id="dt-function-item">
  A <term>function</term> is an item that can be <term>called</term>.
</termdef>
Functions <phrase diff="del" at="2014-12-02">have no
identity,</phrase> cannot be compared<phrase diff="add" at="2014-12-02"> for
identity, equality, or otherwise</phrase>, and have no serialization.
</p>

<p>A function has the following properties:
</p>

<ulist>
  <item>
    <p>
      <term>name</term>
      <phrase>(<code>xs:QName</code>)</phrase>:
      An expanded QName, possibly
      <termref def="dt-absent">absent</termref>. 
    </p>
  </item>
  <item>
    <p>
      <term>parameter names</term>
      <phrase>(<code>xs:QName*</code>)</phrase>:
      A list of distinct names, one for each of the function's parameters.
    </p>
  </item>
  <item>
    <p>
      <term>signature</term>
      <phrase>
        (a <code>FunctionTest</code> of the form
        <code>Annotation* TypedFunctionTest</code>)</phrase>:

      <phrase diff="chg" at="2013-12-06">
        The
        <xnt spec="XP31" ref="doc-xpath31-TypedFunctionTest">TypedFunctionTest</xnt>
        has one
        <xnt spec="XP31" ref="doc-xpath31-SequenceType">SequenceType</xnt>
        for each parameter,
        and one SequenceType for the function's result.
      </phrase>
      <termdef term="function signature" id="dt-signature">
        A <term>function signature</term>
        represents the type of a
        <termref def="dt-function-item">function</termref>.</termdef>
      The presence of annotations is language dependent;
functions defined in languages, such as XPath, that have no mechanism for defining annotations
will create functions in the data model with zero annotations.
    </p>
  </item>
  <item>
    <p>
      <term>implementation</term>
      This enables the function, when it's called,
      to map instances of its parameter types into an instance of its result type.
      The implementation is either:
      <ulist>
        <item>
          <p>a host language expression, which is always associated
          with a static context, or
          </p>
        </item>
        <item>
          <p>an implementation-dependent function implementation,
          which is optionally associated with both a static and a
          dynamic context.</p>
        </item>
      </ulist>
    </p>
  </item>
  <item>
    <p>
      <term>nonlocal variable bindings</term>
      (a mapping from <code>xs:QName</code> to <code>item()*</code>):
      This provides a value for each of the function's free variables
      (i.e., variables referenced by the function's implementation, other than locals and parameters).
    </p>
  </item>
</ulist>

<p>
<termdef term="function arity" id="dt-function-arity">
  A function's <term>arity</term> is the number of its parameters.
</termdef>
The number of names in a function's parameter names,
and the number of parameter types in its signature,
must equal the function's arity.
</p>

<p>The space of all possible <termref def="dt-signature">function signatures</termref> forms a hierarchy of function types. All function types are a subtype of
<code>function(*)</code>, which is itself a subtype of <code>item()</code>. Subtypes of <code>function(*)</code>
are partitioned into discrete types, each representing <termref def="dt-function-item">functions</termref> that accept a particular number of arguments.
Function types which have the same arity can be subtypes of each other based on their argument and return types. This subtype relationship is defined in
<phrase at="2013-12-06" diff="chg"><xspecref spec="XP31" ref="id-sequencetype-subtype"/></phrase>. For example:
</p>

<ulist>
  <item><p><code>function(item()) as item()</code> is a subtype of <code>function(*)</code>
  </p></item>
  <item><p><code>function(item()) as xs:integer</code> is a subtype of <code>function(item()) as item()</code>
  </p></item>
  <item><p>
    <code>function(item()) as item()</code> is a subtype of <code>function(xs:string) as item()</code>
  </p></item>
</ulist>

</div3>

<div3 id="map-items" at="2013-12-06" diff="add">
<head>Map Items</head>

<p><termdef term="map item" id="dt-map-item">A <term>map item</term>
is a value that represents a map (sometimes called a hash or an
associative array).</termdef> A map is logically a collection of
key/value pairs. Each key in the map is unique (there is no other key
to which it is equal) and has associated with it a value that is a
single item or sequence of items. There is no uniqueness constraint on
values. The semantics of equality are described in
<xspecref spec="FO31" ref="func-same-key"/>.</p>

<p at="2014-10-05" diff="del">If any date/time values (xs:date,
xs:dateTime, xs:time, xs:gYear, etc.) are used as keys, all such
values must either have a timezone or must not have a timezone. An
error is raised if an attempt is made to mix date/time key values that
have a timezone with values that do not. This constraint applies only
to map keys and applies independently to each map (it is not an error
to have one map that uses date/time keys with timezones and another
which uses values without timezones).</p>

<note>
<p>This version of the XPath Data Model does not specify whether or
not maps have any identity other than their values. No operations
currently defined on maps depend on the notion of map identity. Other
specifications, for example, the <emph>XQuery Update Facility</emph>, may make
identity of maps explicit.
</p>
</note>

<p>There is a single accessor associated with maps, it is defined
in the following section.</p>

<div4 id="dm-map-keys">
<head><code>map-entries</code> Accessor</head>

<example role="signature">
  <proto class="dm" name="map-entries" return-type="array(array(item()))" returnSeq="no">
    <arg name="map" type="map()"/>
  </proto>
</example>

<p>The <function>map-entries</function> accessor returns an array
of arrays. For each key/value pair in the <code>$map</code>, an
array will be constructed with the key in position 1 and the value
in position 2. The array returned by <function>map-entries</function> is
the array of the arrays constructed for the key/value pairs. The
order of the members in the array returned is implementation-dependent.</p>

</div4>

</div3>

<div3 id="array-items" at="2014-09-05" diff="add">
<head>Array Items</head>

<p><termdef term="array item" id="dt-array-item">An <term>array item</term>
is a value that represents an array.</termdef>
An array is an ordered list of values; these values are called the
members of the array. Unlike sequences, a member of an array can be
any value (including a sequence or an array). The number of members in
an array is called its size, and they are referenced by their
position, in the range 1 to the size of the array.</p>

<note>
<p>This version of the XPath Data Model does not specify whether or
not arrays have any identity other than their values. No operations
currently defined on arrays depend on the notion of array identity. Other
specifications, for example, the XQuery Update Facility, may make
identity of arrays explicit.
</p>
</note>

<p>The accessors associated with arrays are defined in the following
sections.</p>

<div4 id="dm-array-size">
<head><code>array-size</code> Accessor</head>

<example role="signature">
  <proto class="dm" name="array-size" return-type="xs:nonNegativeInteger" returnSeq="no">
    <arg name="array" type="array()"/>
  </proto>
</example>

<p>The <function>array-size</function> accessor returns the number
of items in the array.
</p>
</div4>

<div4 id="dm-array-get">
<head><code>array-get</code> Accessor</head>

<example role="signature">
  <proto class="dm" name="array-get" return-type="item()" returnSeq="yes">
    <arg name="array" type="array()"/>
    <arg name="position" type="xs:positiveInteger"/>
  </proto>
</example>

<p>The <function>array-get</function> accessor returns the value in the array
at the position <code>$position</code>. An error is raised
if the array does not contain a value at that position.
For all positions greater than 0 and less than or equal to the array size,
<function>array-get</function> will return a value.</p>
</div4>

</div3>
</div2>
</div1>

<div1 id="construction">
<head>Data Model Construction</head>

<p>This section describes the constraints on instances of the data model.</p>

<p>The data model supports well-formed XML documents conforming to
<bibref ref="xml-names"/> or <bibref ref="xml-names11"/>.
Documents that are not well-formed are,
by definition, not XML. XML documents that do not conform to
<bibref ref="xml-names"/> or <bibref ref="xml-names11"/>
are not supported (nor are they supported by
<bibref ref="xml-infoset"/>).</p>

<p>In other words, the data model supports the following classes
of XML documents:</p>

<ulist>
  <item>
    <p>Well-formed documents conforming to <bibref ref="xml-names"/> or
<bibref ref="xml-names11"/>.</p>
  </item>
  <item>
    <p>DTD-valid documents conforming to <bibref ref="xml-names"/> or
<bibref ref="xml-names11"/>, and</p>
  </item>
  <item>
    <p>W3C XML Schema-validated documents.</p>
  </item>
</ulist>

<p>This document describes how to construct an instance of the data
model from an infoset (<bibref ref="xml-infoset"/>) or a Post Schema Validation
Infoset (PSVI), the augmented infoset produced by an XML Schema
validation episode.</p>

<p>An instance of the data model can also be constructed directly
through application APIs, or from non-XML sources such as relational
tables in a database.
Data model construction from sources other than
an Infoset or PSVI is implementation-defined.
Regardless of how an instance of the data model
is constructed, every node and atomic value in the data model must
have a typed-value that is consistent with its type.</p>

<imp-def-feature>Data model construction from sources other than
an Infoset or PSVI is implementation-defined.</imp-def-feature>

<p>The data model supports some kinds of values that are not supported
by <bibref ref="xml-infoset"/>. Examples of these are
<termref def="dt-fragment">document fragments</termref>
and sequences of &documentNode;s.
The data model also supports values that are not nodes. Examples of
these are sequences of <termref def="dt-atomic-value">atomic values</termref>,
or sequences mixing nodes and atomic
values. These are necessary to be able to represent the results of
intermediate expressions in the data model during expression
processing.
</p>

<div2 id="const-other">
<head>Direct Construction</head>

<p>Although this document describes construction of an instance of the
data model in terms of infoset properties, an infoset is not a
necessary precondition for building an instance of the data model.</p>

<p>There are no constraints on how an instance of the data model may be
constructed directly, save that the resulting instance
<rfc2119>must</rfc2119> satisfy all of the constraints described in
this document.</p>

</div2>

<div2 id="const-infoset">
<head>Construction from an Infoset</head>

<p>An instance of the data model can be constructed from an infoset
that satisfies the
following general constraints:</p>

<ulist>
<item><p>All general and external parsed entities must be fully expanded. The
Infoset must not contain any <emph role="info-item">unexpanded entity
reference information items</emph>.</p>
</item>
<item><p>The infoset <rfc2119>must</rfc2119> provide all of the properties identified as
<quote>required</quote> in this document.
The properties identified as <quote>optional</quote>
may be used, if they are present. All other properties are ignored.</p>
</item>
</ulist>

<p>An instance of the data model constructed from an information set
<rfc2119>must</rfc2119> be consistent with the description provided
for each node kind.</p>

<p diff="add" at="2014-12-01">Furthermore, construction of an instance
of the data model from an Infoset is only guaranteed to be
well-defined for Infosets that could have been derived from a
conforming XML document.</p>

</div2>

<div2 id="const-psvi">
<head>Construction from a PSVI</head>

<p>An instance of the data model can be constructed from a PSVI, whose
element and attribute information items have been strictly assessed,
laxly assessed, or have not been assessed. Constructing an instance of
the data model from a PSVI <rfc2119>must</rfc2119> be consistent with
the description provided in this section and with the description
provided for each node kind.</p>

<p>Data model construction requires that the PSVI provide unique names
for all anonymous schema types.</p>

<note>
<p><bibref ref="xmlschema-1"/> does not require all schema processors to
provide unique names for anonymous schema types. In order to build an
instance of the data model
from a PSVI produced by a processor that does not provide the names,
some post-processing will be required in order to assure that they are
all uniquely identified before construction begins.</p>
</note>

<p><termdef id="dt-incompletely-validated" term="incompletely validated">An
<term>incompletely validated</term> document is an XML document that has a
corresponding schema but whose schema-validity assessment has resulted
in one or more element or attribute information items being assigned
values other than 'valid' for the <emph role="infoset-property">validity</emph>
property in the PSVI.</termdef></p>

<p>The data model supports incompletely validated documents. Elements
and attributes that are not valid are treated as having unknown types.</p>

<p>The most significant difference between Infoset construction and PSVI
construction occurs in the area of schema type assignment. Other differences
can also arise from schema processing: default attribute and element values
may be provided, white space normalization of element content may occur, and the
user-supplied lexical form of elements and attributes with atomic schema types
may be lost.</p>

<div3 id="PSVI2Types">
<head>Mapping PSVI Additions to Node Properties</head>

<p>A PSVI element or attribute information item may have a
<emph role="infoset-property">validity</emph> property.
The <emph role="infoset-property">validity</emph> property may be
<quote><emph>valid</emph></quote>, <quote><emph>invalid</emph></quote>,
or <quote><emph>notKnown</emph></quote>
and reflects the outcome of schema-validity assessment. In the data
model, precise schema type information is exposed for Element and
&attributeNode;s that are <quote><emph>valid</emph></quote>. Nodes
that are not <quote><emph>valid</emph></quote> are treated as if they
were simply well-formed XML and only very general schema type
information is associated with them.
</p>

<div4 id="PSVI2NodeTypes">
<head>Element and Attribute Node Types</head>

<p>The precise definition of the schema type of an element or attribute
information item depends on the properties of the PSVI.
In the PSVI, <bibref ref='xmlschema-1'/>
defines a
<emph role="infoset-property">type definition</emph> property
as well as the
<emph role="infoset-property">type definition namespace</emph>,
<emph role="infoset-property">type definition name</emph> and
<emph role="infoset-property">type definition anonymous</emph>
properties, which are effectively short-cut terms for properties of
the type definition.
Further, the <emph role="infoset-property">element declaration</emph> and
<emph role="infoset-property">attribute declaration</emph>
properties are defined for elements and attributes, respectively.
These declarations in turn will identify the
<emph role="infoset-property">type definition</emph>
declared for the element or attribute. To distinguish the
<emph role="infoset-property">type definition</emph>
given in the PSVI for the element or attribute instance
from the <emph role="infoset-property">type definition</emph> associated
with the declaration, the former is referred to below as the actual
type and the latter as the declared type of the element or attribute
instance in question.
</p>

<p>The type depends on the declared type, the actual type, and the
<emph role="infoset-property">validity</emph> and
<emph role="infoset-property">validation attempted</emph> properties in
the PSVI. If:</p>

<ulist>
<item>
<p>The <emph role="infoset-property">validity</emph> and
<emph role="infoset-property">validation attempted</emph> properties exist
and have the values <quote><emph>valid</emph></quote> and
<quote><emph>full</emph></quote>, respectively, the
schema type of an element or attribute information item is
represented by an <termref def="dt-expanded-qname">expanded-QName</termref>
whose namespace and local name correspond
to the first applicable items in the following list:
</p>

<ulist>
<item>
<p>If the declared type exists and is a union and the actual type is (not the
same as the declared type, and not a type derived from the declared
type, but) one of the member types of the union, or derived from one
of its member types:
</p>
  <ulist>
  <item>
  <p>If the {name} property of the declared type is present: the
  {target namespace} and {name} properties of the declared type.
  </p>
  </item>
  <item>
  <p>If the {name} property of the declared type is absent: the
  namespace and local name of the anonymous type name supplied for the
  declared type.
  </p>
  </item>
  </ulist>
</item>

<item>
<p>If there is no declared type, and the actual type is a union, then:</p>
  <ulist>
  <item>
  <p>If the {name} property of the actual type is present: the {target
  namespace} and {name} properties of the actual type.
  </p>
  </item>
  <item>
  <p>If the {name} property of the actual type is absent: the
  namespace and local name of the anonymous type name supplied for the
  actual type.</p>
  </item>
  </ulist>
</item>

<item>
<p>Otherwise:</p>
  <ulist>
  <item>
  <p>If <emph role="infoset-property">type definition anonymous</emph>
  is false: the {target namespace} and {name} properties of the actual type.
  </p>
  </item>
  <item>
  <p>If <emph role="infoset-property">type definition anonymous</emph> is true:
  the namespace and local name of the anonymous type name supplied for
  the actual type.</p>
  </item>
  </ulist>
</item>
</ulist>

</item>
<item>
<p>The <emph role="infoset-property">validity</emph> property exists
and is <quote><emph>invalid</emph></quote>, or the
<emph role="infoset-property">validation attempted</emph> property exists
and is <quote><emph>partial</emph></quote>, the schema type of an element
is <code>xs:anyType</code> and the type of an attribute is
<code>xs:anySimpleType</code>.</p>
</item>
<item>
<p>The <emph role="infoset-property">validity</emph> property exists and is
<quote><emph>notKnown</emph></quote>, the schema type of an element is
<code>xs:anyType</code> and the type of an attribute is
<code>xs:anySimpleType</code>.
</p>
</item>
<item>
<p>The <emph role="infoset-property">validity</emph> or
<emph role="infoset-property">validation attempted</emph> properties do not
exist, the schema type of an element is
<code>xs:untyped</code> and the type of an attribute is
<code>xs:untypedAtomic</code>.
</p>
</item>
</ulist>

<p>The prefix associated with the type names is implementation-dependent.</p>

<imp-dep-feature>The prefix associated with type names is
implementation-dependent.
</imp-dep-feature>

</div4>

<div4 id="TypedValueDetermination">
<head>Typed Value Determination</head>

<p>This section describes how the typed value of an Element or
&attributeNode; is computed from an element or attribute PSVI
information item, where the information item has either a simple type
or a complex type with simple content. For other kinds of
&elementNode;s, see <specref ref="const-psvi-element"/>; for other kinds of
&attributeNode;s, see <specref ref="const-psvi-attribute"/>.</p>

<p>The typed value of &attributeNode;s and some &elementNode;s is a
sequence of atomic values. The
types of the items in the typed value of a node may differ from
the type of the node itself. This section describes how the typed
value of a node is derived from the properties of an information item
in a PSVI.</p>

<p>The types of the items in the typed value of a node are determined as follows.
The process begins with a type, <code>T</code>. If the schema type of the node itself, as
represented in the PSVI, is a complex type with simple content, then <code>T</code> is the
{content type} of the schema type of the node; otherwise, <code>T</code> is the schema type
of the node itself. For each primitive or ordinary simple type <code>T</code>, the W3C XML
Schema specification defines a function <code>M</code> mapping the lexical representation of
a value onto the value itself.</p>

<note>
<p>For atomic and list types, the mapping is the “lexical mapping”
defined for <code>T</code> in
<bibref ref="xmlschema-2"/>; for union types, the mapping is the
lexical mapping defined in
<bibref ref="xmlschema-2"/> modified
as appropriate by any applicable rules in
<bibref ref="xmlschema-1"/>. The mapping, so modified, is a function
(in the mathematical sense) which maps to a single value even
in cases where the lexical mapping proper maps to multiple values.
</p>
</note>

<p>The typed value is determined as follows:</p>

<ulist>
<item>
<p>If the &dm.prop.nilled; property of the node in question is
<code>true</code>, then the typed value is the empty sequence.
</p>
</item>
<item>
<p>If <code>T</code> is <code>xs:anySimpleType</code> or
<code>xs:anyAtomicType</code>, the typed value
is the <emph role="infoset-property">schema normalized value</emph> as
an instance of <code>xs:untypedAtomic</code>.
</p>
</item>
<item>
<p>Otherwise, the typed value is the result of applying <code>M</code>
to the string value as an instance of the appropriate value type,
where the appropriate value type is the <emph role="infoset-property">member
type definition</emph> if <code>T</code> is a union type, otherwise it
is simply <code>T</code>.
</p>
</item>
</ulist>

<p>The typed value determination process is guaranteed to result in a
sequence of atomic values, each having a well-defined atomic type. This
sequence of atomic values, in turn, determines the
typed-value property of the node in the data model.</p>
</div4>

<div4 id="typed-string-relationships">
<head>Relationship Between Typed-Value and String-Value</head>

<p>Element and attribute nodes have both typed-value and string-value
properties. However, implementations are allowed some flexibility in
how these properties are stored. An implementation may choose to store
the string-value only and derive the typed-value from it, or to store
the typed-value only and derive the string-value from it, or to store
both the string-value and the typed-value.</p>

<p>In order to permit these various implementation strategies, some
variations in the string value of a node are defined as insignificant.
Implementations that store only the typed value of a node are permitted to
return a string value that is different from the original lexical form of
the node content. For example, consider the following element:</p>

<eg>&lt;offset xsi:type="xs:integer"&gt;0030&lt;/offset&gt;</eg>

<p>Assuming that the node is valid, it has a typed value of 30 as an
<code>xs:integer</code>. An implementation may return either "30" or
"0030" as the string value of the node. Any string that is a valid
lexical representation of the typed value is acceptable. In this
specification, we express this rule by saying that the relationship
between the string value of a node and its typed value must be
"consistent with schema validation."</p>

<p>If an implementation stores only the string-value of a node, the
following considerations apply:</p>

<ulist>
<item>
<p>Where union types occur, the implementation must be able to deliver
the typed-value as an instance of the appropriate member type. For
example, if the type <phrase diff="add" at="2016-11-14">of</phrase> 
an element node is my:integer-or-string, which is
defined as a union of xs:integer and xs:string, and the string-value
of the node is "47", the implementation must be able to deliver the
typed-value of the node as either the integer 47 or the string "47",
depending on which member type validated the element.</p>
</item>
<item>
<p>Where types of <code>xs:QName</code>, <code>xs:NOTATION</code>, or
types derived from one of these types occur, the implementation must
be able to deliver the typed-value as a triple including a local name,
a namespace prefix, and a namespace URI, even though the namespace URI
is not part of the string-value (see
<specref ref="qnames-and-notations"/>).</p>
</item>
<item>
<p>Where an element with a complex type and element-only content
occurs, it is an error to attempt to access the typed-value of the
&elementNode;.</p>
</item>
</ulist>

<p>If an implementation stores only the typed-value of a node, it must
be prepared to construct string values from not only the node, but in
some cases also the descendants of that node. For example, an element
with a complex type and element-only content has no typed-value but
does have a string-value that is the concatenation of the
string-values of all its &textNode; descendants in document order.</p>

<p>A further caveat applies if an implementation stores the typed
value of a node. If a new data model is constructed by copying
portions of another data model, and the copy operation does not
preserve inherited namespaces, and the type is a union type that is
sensitive to the namespace context, then the typed value may be
different than what would be obtained by revalidating the node within
its new namespace context. Although this may stretch the semantics of
“consistent with schema validation”, we accept this possibility; it
is not an error.</p>

</div4>

<div4 id="pattern-facets">
<head>Pattern Facets</head>

<p>Creating a subtype by restriction generally reduces the
<emph>value</emph> space of the original schema type. For example,
expressing a hat size as a restriction of decimal with a minimum value
of 6.5 and maximum value of 8.0 creates a schema type whose valid values are
only those in the range 6.5 to 8.0.</p>

<p>The pattern facet is different because it restricts the
<emph>lexical</emph> space of the schema type, not its value space.
Expressing a three-digit number as a restriction of integer with the
pattern facet “[0-9]{3}” creates a schema type whose valid values
are only those with a lexical form consisting of three digits.</p>

<p>The pattern facet is not reversible in practice. A given point in
the value space might have several lexical representations. In
general, there's no practical way to determine which, if any, of these
representations satisfies the pattern facet of the type.</p>

<p>As a consequence, pattern facets are not respected when mapping to
an Infoset or during serialization and values in the data model that
were originally valid with respect to a schema that contains
pattern-based restrictions may be invalid after serialization.</p>
</div4>
</div3>

<!--
<div3 id="nilled">
<head>Mapping <att>xsi:nil</att> on &elementNode;s</head>

<p><bibref ref="xmlschema-2"/> introduced a mechanism for signaling
that an element should be accepted as valid when it has no content
despite a content type which does not require or even necessarily
allow empty content. That mechanism is the <att>xsi:nil</att> attribute.
</p>

<p>The data model exposes this special semantic in the &dm.prop.nilled; property.
(It also exposes the attribute, irrespective of whether or not schema
processing has been performed.)
</p>

<p>If the <emph role="infoset-property">validity</emph> property exists on
an information item and is <quote><emph>valid</emph></quote> then if
the <emph role="infoset-property">nil</emph> property exists and is true,
then the &dm.prop.nilled; property is <quote><emph>true</emph></quote>.
In all other cases, including all cases where schema validity assessment was
not attempted or did not succeed, the
&dm.prop.nilled; property is <quote><emph>false</emph></quote>.</p>

</div3>
-->

<div3 id="dates-and-times">
<head>Dates and Times</head>

<p>The date and time types require special attention. This section
applies to implementations that store the typed value of
<code>xs:dateTime</code>, <code>xs:date</code>, <code>xs:time</code>,
<code>xs:gYearMonth</code>, <code>xs:gYear</code>,
<code>xs:gMonthDay</code>, <code>xs:gMonth</code>,
<code>xs:gDay</code>, and types that are derived from them. These are
known collectively as the date/time types in this specification.</p>

<p>The values of the date/time types are represented in the data model
using seven components:</p>

<glist>
<gitem>
<label>year</label>
<def>
<p>An <code>xs:integer</code>.
</p>
</def>
</gitem>

<gitem>
<label>month</label>
<def>
<p>An <code>xs:integer</code> between 1 and 12, inclusive.
</p>
</def>
</gitem>

<gitem>
<label>day</label>
<def>
<p>An <code>xs:integer</code> between 1 and 31, inclusive, possibly
restricted further depending on the values of month and year.
</p>
</def>
</gitem>

<gitem>
<label>hour</label>
<def>
<p>An <code>xs:integer</code> between 0 and 23, inclusive.
</p>
</def>
</gitem>

<gitem>
<label>minute</label>
<def>
<p>An <code>xs:integer</code> between 0 and 59, inclusive.
</p>
</def>
</gitem>

<gitem id="tuple-timezone">
<label>second</label>
<def>
<p>An <code>xs:decimal</code> greater than or equal to zero and less
than 60. Leap seconds are not supported.
</p>
</def>
</gitem>

<gitem>
<label>timezone</label>
<def>
<p>An <code>xs:dayTimeDuration</code> between -PT14H00M and PT14H00M,
inclusive. All timezone values must be an integral number of minutes.
</p>
</def>
</gitem>
</glist>

<p>Components that are intrinsic to the datatype (for example, day,
month, and year in a <code>xs:date</code>) are required; components
that can never be part of a datatype (for example, years in a
<code>xs:time</code>) must be missing. Missing components are
represented by the empty sequence. When a component is present, it
contains the “local value” that has not been normalized in any way.
The timezone component is optional for all the date/time datatypes.</p>

<p>Thus, the lexical <code>xs:dateTime</code> representation
“<code>2003-01-02T11:30:00-05:00</code>” is stored as
“<code>{2003,&#160;1,&#160;2,&#160;11,&#160;30,&#160;0.0,&#160;-PT05H00M}</code>”.
The value of the lexical representation “<code>2003-01-16T16:30:00</code>”
is stored as
“<code>{2003,&#160;1,&#160;16,&#160;16,&#160;30,&#160;0,&#160;()}</code>”
because it has no timezone.
The value of the lexical <code>xs:gDay</code> representation
“<code>---30+10:30</code>” is
stored as
“<code>{(),&#160;(),&#160;30,&#160;(),&#160;(),&#160;(),&#160;PT10H30M}</code>”.
</p>

<p>The lexical form “<code>24:00:00</code>” is normalized in the component
model. As a <code>xs:time</code>, it is stored as
“<code>{(),&#160;(),&#160;(),&#160;0,&#160;0,&#160;0.0,&#160;()}</code>”
and the <code>xs:dateTime</code> representation
“<code>1999-12-31T24:00:00</code>” is stored as
“<code>{2000,&#160;1,&#160;1,&#160;0,&#160;0,&#160;0.0,&#160;()}</code>”.
</p>

<note><p>Implementations are permitted to store date/time values in
any representation that's convenient for them, provided that the
individual properties can be accessed and modified.</p></note>

</div3>

<div3 id="qnames-and-notations">
<head>QNames and NOTATIONS</head>

<p>The <code>QName</code> and <code>NOTATION</code> data types require
special attention. The following sections apply to
<code>xs:QName</code>, <code>xs:NOTATION</code>, and types derived
from them. These types are referred to collectively as “qualified
names”.</p>

<p>As defined in XML Schema, the lexical space for qualified names
includes a local name and an optional namespace prefix. The value
space for qualified names contains a local name and an optional
namespace URI. Therefore, it is not possible to derive a lexical value
from the typed value, or vice versa, without access to some context
that defines the namespace bindings.</p>

<p>When qualified names exist as values of nodes in a well-formed document,
it is always possible to determine such a namespace context. However,
the data model also allows qualified names to exist as freestanding
atomic values, or as the name or value of a parentless attribute node,
and in these cases no namespace context is available.</p>

<p>In this Data Model, therefore, the value space for qualified names
contains a local-name, an optional namespace URI, and an optional
prefix. The prefix is used only when producing a lexical
representation of the value, that is, when casting the value to a
string. The prefix plays no part in other operations involving
qualified names: in particular, two qualified names are equal if their
local names and namespace URIs match, regardless whether they have the
same prefix.</p>

<p>The following consistency constraints apply:</p>

<ulist>
<item>
<p>If the namespace URI of a qualified name is
<termref def="dt-absent">absent</termref>, then the prefix must
also be
<termref def="dt-absent">absent</termref>.</p>
</item>

<item>
<p>For every element node whose name has a prefix, the prefix must be one
that has a binding to the namespace URI of the element name in the namespaces
property of the element.</p>
</item>

<item>
<p>For every element node whose name has no prefix, the element must have a
a binding for the empty prefix to the namespace URI of the element name,
or must have no binding for the empty prefix in
the case where the name of the element has no namespace URI.</p>
</item>

<item>
<p>For every attribute node whose name has a prefix, the attribute node must
either be parentless, or the prefix must be one that has a binding to the
namespace URI of the attribute name in the namespaces property of the
parent element.</p>
</item>

<item>
<p>For every qualified name that contains a prefix and that is included in
the typed value of an element node, or of an attribute node that has an
element node as its parent, the prefix must be one that is bound to the
namespace URI of the qualified name in the namespaces property of that
element.</p>
</item>

<item>
<p>For every qualified name that contains a namespace URI and no prefix, and
that is included in the typed value of an element node, or of an attribute
node that has an element node as its parent, that element node must have a
binding for the empty prefix to that namespace URI in its namespace property.
</p>
</item>

<item>
<p>For every qualified name that contains neither a namespace URI nor a
prefix, and that is included in the typed value of an element node, or of an
attribute node that has an element node as its parent, that node
must not have a binding for the empty prefix.</p>
</item>

<item>
<p>No qualified name that contains a prefix may be included in the typed value of
an attribute node that has no parent.</p>
</item>
</ulist>
</div3>
</div2>
</div1>

<div1 id="infoset-mapping">
<head>Infoset Mapping</head>

<p>This specification describes how to map each kind of node to the
corresponding information item. This mapping produces an Infoset; it
does not and cannot produce a PSVI. Validation must be used to obtain
a PSVI for a (portion of a) data model instance.
</p>

</div1>

<div1 id="accessors">
<head>Accessors</head>

<p>A set of accessors is defined on <loc href="#Node">nodes</loc> in
the data model. For consistency, all the accessors are defined on
every kind of node, although several accessors return a constant empty
sequence on some kinds of nodes.</p>

<p>In order for processors to be able to operate on instances of the
data model, the model must expose the properties of the items it contains.
The data model does this by defining a family of accessor functions.
These are not functions in the literal sense; they are not available
for users or applications to call directly. Rather they are
descriptions of the information that an implementation of the data model
must expose to applications. Functions and operators available to end-users
are described in <bibref diff="chg" at="2013-12-06" ref="xpath-functions-31"/>.</p>

<p>Some typed values in the data model
are <termref def="dt-absent">absent</termref>.
Attempting to access an absent typed value is an error. Behavior
in these cases is implementation-defined and the host language is responsible
for determining the result.</p>

<imp-def-feature>Some typed values in the data model are <emph>absent</emph>.
Attempting to access an absent typed value is an error. Behavior
in these cases is implementation-defined and the host language is responsible
for determining the result.</imp-def-feature>

<div2 id="dm-attributes">
<head><code>attributes</code> Accessor</head>

<example role="signature">
  <proto class="dm" name="attributes" return-type="attribute()" returnSeq="yes">
    <arg name="n" type="node()"/>
  </proto>
</example>

<p>The <function>attributes</function> accessor returns the attributes of
a node as a sequence containing zero or more &attributeNode;s.
The order of &attributeNode;s is stable but implementation dependent.</p>


<p>It is defined on
<loc href="#acc-summ-attributes">all seven</loc> node kinds.</p>

</div2>

<div2 id="dm-base-uri">
<head><code>base-uri</code> Accessor</head>

<example role="signature">
  <proto class="dm" name="base-uri" return-type="xs:anyURI" returnEmptyOk="yes">
    <arg name="n" type="node()"/>
  </proto>
</example>

<p>The <function>base-uri</function> accessor returns the base URI of a node
as a sequence containing zero or one URI reference. For more information
about base URIs, see <bibref ref="xmlbase"/>.</p>

<p>It is defined on
<loc href="#acc-summ-base-uri">all seven</loc> node kinds.</p>
</div2>

<div2 id="dm-children">
<head><code>children</code> Accessor</head>

<example role="signature">
  <proto class="dm" name="children" return-type="node()" returnSeq="yes">
    <arg name="n" type="node()"/>
  </proto>
</example>

<p>The <function>children</function> accessor returns the children of a node
as a sequence containing zero or more nodes.</p>

<p>It is defined on
<loc href="#acc-summ-children">all seven</loc> node kinds.</p>

</div2>

<div2 id="dm-document-uri">
<head><code>document-uri</code> Accessor</head>

<example role="signature">
  <proto class="dm" name="document-uri" return-type="xs:anyURI" returnEmptyOk="yes">
    <arg name="node" type="node()"/>
  </proto>
</example>

<p>The <function>document-uri</function> accessor returns the
absolute URI of the resource from which the &documentNode; was constructed, if
the absolute URI is available. If there is no URI available, or if it cannot
be made absolute when the &documentNode; is constructed, or if it is used
on a node other than a &documentNode;,
the empty sequence is returned.
</p>

<p>It is defined on
<loc href="#acc-summ-document-uri">all seven</loc> node kinds.</p>
</div2>

<div2 id="dm-is-id">
<head><code>is-id</code> Accessor</head>

<example role="signature">
  <proto class="dm" name="is-id" return-type="xs:boolean" returnEmptyOk="yes">
    <arg name="node" type="node()"/>
  </proto>
</example>

<p>The <function>is-id</function> accessor returns true if the
node is an XML ID. Exactly what constitutes an ID depends in part on
how the data model was constructed, see
<specref ref="ElementNode"/> and <specref ref="AttributeNode"/>.
</p>

<p>It is defined on <loc href="#acc-summ-is-id">all seven</loc>
node kinds.</p>
</div2>

<div2 id="dm-is-idrefs">
<head><code>is-idrefs</code> Accessor</head>

<example role="signature">
  <proto class="dm" name="is-idrefs" return-type="xs:boolean" returnEmptyOk="yes">
    <arg name="node" type="node()"/>
  </proto>
</example>

<p>The <function>is-idrefs</function> accessor returns true if the
node is an XML IDREF or IDREFS.
Exactly what constitutes an IDREF or IDREFS depends in part on
how the data model was constructed, see
<specref ref="ElementNode"/> and <specref ref="AttributeNode"/>.</p>

<p>It is defined on <loc href="#acc-summ-is-idrefs">all seven</loc>
node kinds.</p>
</div2>

<!--
<div2 diff="del" at="2010-12-14" id="dm-namespace-bindings">
<head><code>namespace-bindings</code> Accessor</head>

<example role="signature">
  <proto class="dm" name="namespace-bindings" return-type="xs:string" returnSeq="yes">
    <arg name="n" type="node()"/>
  </proto>
</example>

<p>The <function>namespace-bindings</function> accessor returns the dynamic,
in-scope namespaces associated with a node as a set of prefix/URI pairs,
using an implementation-dependent representation.</p>

<p>The prefix for the default namespace is the zero length string.</p>

<p>The <function>dm:namespace-bindings</function> accessor is defined on all seven node kinds.</p>

<note><p>this accessor and the namespace-nodes accessor provide two views of the same information.</p></note>

</div2>
-->

<div2 id="dm-namespace-nodes">
<head><code>namespace-nodes</code> Accessor</head>

<example role="signature">
  <proto class="dm" name="namespace-nodes" return-type="node()" returnSeq="yes">
    <arg name="n" type="node()"/>
  </proto>
</example>

<p>The <function>namespace-nodes</function> accessor returns the dynamic,
in-scope namespaces associated with a node as a sequence containing
zero or more &namespaceNode;s. The order of &namespaceNode;s is stable
but implementation dependent.</p>

<p>It is defined on
<loc href="#acc-summ-namespace-nodes">all seven</loc> node kinds.</p>

<!--
<note diff="del" at="2010-12-14"><p>this accessor and the <function>namespace-bindings</function> accessor
provide two views of the same information. 
Implementations that do not need to expose Namespace Nodes might choose not to implement this accessor.</p></note>
-->

</div2>

<div2 id="dm-nilled">
<head><code>nilled</code> Accessor</head>

<example role="signature">
  <proto class="dm" name="nilled" return-type="xs:boolean" returnSeq="no"
	 returnEmptyOk="yes">
    <arg name="n" type="node()"/>
  </proto>
</example>

<p>The <function>nilled</function> accessor returns true if the
node is <quote>nilled</quote>.
<bibref ref="xmlschema-1"/> introduced the nilled mechanism to
signal that an element should be accepted as valid when it has no
content even when it has a content type which does not require or even
necessarily allow empty content.
</p>

<p>It is defined on
<loc href="#acc-summ-nilled">all seven</loc> node kinds.</p>
</div2>

<div2 id="dm-node-kind">
<head><code>node-kind</code> Accessor</head>

<example role="signature">
  <proto class="dm" name="node-kind" return-type="xs:string" returnEmptyOk="no">
    <arg name="n" type="node()"/>
  </proto>
</example>

<p>The <function>node-kind</function> accessor returns a string identifying the
kind of node. It will be one of the following, depending on the kind of
node:
“attribute”,
“comment”,
“document”,
“element”,
“namespace”
“processing-instruction”, or
“text”.
</p>

<p>It is defined on
<loc href="#acc-summ-node-kind">all seven</loc> node kinds.</p>

</div2>

<div2 id="dm-node-name">
<head><code>node-name</code> Accessor</head>

<example role="signature">
  <proto class="dm" name="node-name" return-type="xs:QName" returnEmptyOk="yes">
    <arg name="n" type="node()"/>
  </proto>
</example>

<p>The <function>node-name</function> accessor returns the name of the node
as a sequence of zero or one <code>xs:QName</code>s. Note that the
QName value includes an optional prefix as described in
<specref ref="qnames-and-notations"/>.</p>

<p>It is defined on
<loc href="#acc-summ-node-name">all seven</loc> node kinds.</p>

</div2>

<div2 id="dm-parent">
<head><code>parent</code> Accessor</head>

<example role="signature">
  <proto class="dm" name="parent" return-type="node()" returnEmptyOk="yes">
    <arg name="n" type="node()"/>
  </proto>
</example>

<p>The <function>parent</function> accessor returns the parent of a node
as a sequence containing zero or one nodes.</p>

<p>It is defined on
<loc href="#acc-summ-parent">all seven</loc> node kinds.</p>

</div2>

<div2 id="dm-string-value">
<head><code>string-value</code> Accessor</head>

<example role="signature">
  <proto class="dm" name="string-value" return-type="xs:string" returnEmptyOk="no">
    <arg name="n" type="node()"/>
  </proto>
</example>

<p>The <function>string-value</function> accessor returns the string value
of a node.</p>

<p>It is defined on
<loc href="#acc-summ-string-value">all seven</loc> node kinds.</p>

</div2>

<div2 id="dm-type-name">
<head><code>type-name</code> Accessor</head>

<example role="signature">
  <proto class="dm" name="type-name" return-type="xs:QName" returnEmptyOk="yes">
    <arg name="n" type="node()"/>
  </proto>
</example>

<p>The <function>type-name</function> accessor returns the name of the schema type
of a node as a sequence of zero or one <code>xs:QName</code>s.</p>

<p>It is defined on
<loc href="#acc-summ-type-name">all seven</loc> node kinds.</p>

</div2>

<div2 id="dm-typed-value">
<head><code>typed-value</code> Accessor</head>

<example role="signature">
  <proto class="dm" name="typed-value" return-type="xs:anyAtomicType" returnSeq="yes">
    <arg name="n" type="node()"/>
  </proto>
</example>

<p>The <function>typed-value</function> accessor returns the
typed-value of the node as a sequence of zero or more atomic
values.</p>

<p>It is defined on
<loc href="#acc-summ-typed-value">all seven</loc> node kinds.</p>

</div2>

<div2 id="dm-unparsed-entity-public-id">
<head><code>unparsed-entity-public-id</code> Accessor</head>

<example role="signature">
  <proto class="dm" name="unparsed-entity-public-id" return-type="xs:string" returnEmptyOk="yes">
    <arg name="node" type="node()"/>
    <arg name="entityname" type="xs:string"/>
  </proto>
</example>

<p>The <function>unparsed-entity-public-id</function> accessor returns
the public identifier of an unparsed external entity declared in the
specified document. If no entity with the name specified in
<code>$entityname</code> exists, or if the entity is not an external
unparsed entity, or if the entity has no public identifier, the empty
sequence is returned.</p>

<p>It is defined on
<loc href="#acc-summ-unparsed-entity-public-id">all seven</loc> node kinds.</p>
</div2>

<div2 id="dm-unparsed-entity-system-id">
<head><code>unparsed-entity-system-id</code> Accessor</head>

<example role="signature">
  <proto class="dm" name="unparsed-entity-system-id" return-type="xs:anyURI" returnEmptyOk="yes">
    <arg name="node" type="node()"/>
    <arg name="entityname" type="xs:string"/>
  </proto>
</example>

<p>The <function>unparsed-entity-system-id</function> accessor returns the
system identifier of an unparsed external entity declared in the
specified document.
The value is an absolute URI, and is obtained by resolving the
<emph role="infoset-property">system identifier</emph>
of the unparsed entity information item against the
<emph role="infoset-property">declaration base URI</emph>
of the same item.
If no entity with the name specified in <code>$entityname</code>
exists, or if the entity is not an external unparsed entity, the empty sequence
is returned.</p>

<p>It is defined on
<loc href="#acc-summ-unparsed-entity-system-id">all seven</loc> node kinds.</p>
</div2>
</div1>

<div1 id="Node">
<head>Nodes</head>

<p><termdef id="dt-node" term="Node">There are seven kinds of
<term>Nodes</term> in the data model:
<loc href="#DocumentNode">document</loc>,
<loc href="#ElementNode">element</loc>,
<loc href="#AttributeNode">attribute</loc>,
<loc href="#TextNode">text</loc>,
<loc href="#NamespaceNode">namespace</loc>,
<loc href="#ProcessingInstructionNode">processing instruction</loc>, and
<loc href="#CommentNode">comment</loc>.</termdef> Each kind of
node is described in the following sections.</p>

<!--
<note diff="del" at="2010-12-14"><p>A host language based on the Data Model
may specify that its usage of the Data Model does not include namespace nodes. 
Namespace nodes are used only in the "namespaces" property of an element node,
which records the bindings of namespace prefixes to namespace URIs. 
These bindings may be represented either by means of namespace nodes or by using
an alternative, implementation-dependent representation.</p></note>
-->

<p id="constraints-general">All nodes <rfc2119>must</rfc2119> satisfy
the following general constraints:</p>

<olist>
<item><p>Every node <rfc2119>must</rfc2119> have a unique identity,
distinct from all other nodes.
</p></item>
<item>
<p>The &dm.prop.children; property of a node <rfc2119>must not</rfc2119>
contain two consecutive &textNode;s.</p>
</item>
<item>
<p>The &dm.prop.children; property of a node <rfc2119>must not</rfc2119>
contain any empty &textNode;s.</p>
</item>
<item>
<p diff="del" at="2014-12-02">The &dm.prop.children; and &dm.prop.attributes; properties of a node
<rfc2119>must not</rfc2119>
contain two nodes with the same identity.</p>
<p diff="add" at="2014-12-02">No node may appear more than once in the
&dm.prop.children; or &dm.prop.attributes; properties of a node.</p>
</item>
</olist>

&Document;
&Element;
&Attribute;
&Namespace;
&ProcessingInstruction;
&Comment;
&Text;

</div1>

<div1 id="conformance">
<head>Conformance</head>

<p>The data model is intended primarily as a component that can be
used by other specifications. Therefore, the data model relies on
specifications that use it (such as <bibref diff="chg" at="2013-12-06" ref="xpath-31"/>,
<bibref ref="xslt-30"/>, and <bibref diff="chg" at="2013-12-06" ref="xquery-31"/>) to specify conformance
criteria for the data model in their respective environments.
Specifications that set conformance criteria for their use of the data
model must not relax the constraints expressed in this
specification.</p>

<p>Authors of conformance criteria for the use of the data
model should pay particular attention to the following features of
the data model:</p>

<olist>
<item>
<p>Support for the normative construction from an infoset described in
<specref ref="const-infoset"/>.
</p>
</item>
<item>
<p>Support for the normative construction from a PSVI described in
<specref ref="const-psvi"/>.
</p>
</item>
<item>
<p>Support for XML 1.0 and XML 1.1.
</p>
</item>
<item>
<p>Support for data types in XML Schema 1.0 and XML Schema 1.1.
</p>
</item>
<item>
<p>How namespaces are supported, through nodes or through the
alternative, implementation-dependent representation.</p>
</item>
</olist>

<note>
<p diff="add" at="2016-12-07">In addition, the <function>is-id</function> 
and <function>base-uri</function> accessors are required by functions in <bibref ref="xpath-functions-31" />.
These refer to the specifications  <bibref ref="xml-id"/>
and <bibref ref="xmlbase"/> respectively.</p>
</note>

</div1>

</body>

<back>
<div1 id="infoset-conformance">
<head>XML Information Set Conformance</head>

<p>This specification conforms to the XML Information Set
<bibref ref="xml-infoset"/>.
The following information items <rfc2119>must</rfc2119> be exposed
by the infoset producer to construct a data model unless they are explicitly
identified as optional:</p>

<ulist>
  <item><p>The <emph role="info-item">Document Information Item</emph> with
           <emph role="infoset-property">base URI</emph>,
           <emph role="infoset-property">children</emph>, and, optionally,
           <emph role="infoset-property">unparsed entities</emph>
           properties. If the
           <emph role="infoset-property">unparsed entities</emph> property
	   is supported, the <emph role="info-item">Unparsed Entity
           Information Items</emph> must also be supported.</p></item>

  <item><p><emph role="info-item">Element Information Items</emph> with
           <emph role="infoset-property">base URI</emph>,
           <emph role="infoset-property">children</emph>,
           <emph role="infoset-property">attributes</emph>,
           <emph role="infoset-property">in-scope namespaces</emph>,
           <emph role="infoset-property">prefix</emph>,
           <emph role="infoset-property">local name</emph>,
           <emph role="infoset-property">namespace name</emph>,
           <emph role="infoset-property">parent</emph> properties.</p></item>

  <item><p><emph role="info-item">Attribute Information Items</emph> with
           <emph role="infoset-property">namespace name</emph>,
           <emph role="infoset-property">prefix</emph>,
           <emph role="infoset-property">local name</emph>,
           <emph role="infoset-property">normalized value</emph>,
           <emph role="infoset-property">attribute type</emph>, and
           <emph role="infoset-property">owner element</emph> properties.</p></item>

  <item><p><emph role="info-item">Character Information Items</emph> with
           <emph role="infoset-property">character code</emph>,
           <emph role="infoset-property">parent</emph>, and, optionally,
           <emph role="infoset-property">element content whitespace</emph>
           properties.</p></item>

  <item><p><emph role="info-item">Processing Instruction Information Items</emph> with
           <emph role="infoset-property">base URI</emph>,
           <emph role="infoset-property">target</emph>,
           <emph role="infoset-property">content</emph> and
           <emph role="infoset-property">parent</emph> properties.</p></item>

  <item><p><emph role="info-item">Comment Information Items</emph> with
           <emph role="infoset-property">content</emph> and
           <emph role="infoset-property">parent</emph> properties.</p></item>

  <item><p><emph role="info-item">Namespace Information Items</emph> with
           <emph role="infoset-property">prefix</emph> and
           <emph role="infoset-property">namespace name</emph> properties.</p></item>
</ulist>

<p>Other information items and properties made available by the
Infoset processor are ignored.  In addition to the properties above,
the following PSVI properties are required
on
<emph role="info-item">Element Information Items</emph> and
<emph role="info-item">Attribute Information Items</emph>
if the data model is constructed from a PSVI:</p>

<ulist>
  <item><p><emph role="infoset-property">validity</emph>,
  <emph role="infoset-property">validation attempted</emph>,
  <emph role="infoset-property">type definition</emph>,
  <emph role="infoset-property">type definition namespace</emph>,
  <emph role="infoset-property">type definition name</emph>,
  <emph role="infoset-property">type definition anonymous</emph>,
  <emph role="infoset-property">nil</emph>,
  <emph role="infoset-property">member type definition</emph>,
  <emph role="infoset-property">member type definition namespace</emph>,
  <emph role="infoset-property">member type definition name</emph>,
  <emph role="infoset-property">member type definition anonymous</emph> and
  <emph role="infoset-property">schema normalized value</emph>.</p>
  </item>
</ulist>

</div1>

<div1 id="references">
<head>References</head>

<div2 id="normative-references">
<head>Normative References</head>

<blist>

<!--FIXME: update ../etc/tr with the latest TR page info! -->

<bibl id="xml"                key="XML"/>
<bibl id="xml-infoset"        key="Infoset"/>
<bibl id="xml-names"          key="Namespaces in XML"/>
<bibl id="xml-names11"        key="Namespaces in XML 1.1"/>
<bibl id="xml-id"             key="xml:id"/>

<bibl id="xpath-datamodel"    key="XQuery 1.0 and XPath 2.0 Data Model (XDM)"/>
<bibl id="xpath-31"           key="XML Path Language (XPath) 3.1"/>
<bibl id="xpath-functions-31" key="XQuery and XPath Functions and Operators 3.1"/>

<bibl id="xmlschema-1"        key="Schema Part 1"/>
<bibl id="xmlschema-2"        key="Schema Part 2"/>
<bibl id="xmlschema11-1"      key="Schema 1.1 Part 1"/>
<bibl id="xmlschema11-2"      key="Schema 1.1 Part 2"/>

<bibl id="xslt-xquery-serialization-31" key="XSLT and XQuery Serialization 3.1"/>

<bibl id="xquery-semantics"   key="XQuery 1.0 and XPath 2.0 Formal Semantics"/>
<bibl id="RFC2119"            key="RFC 2119"/>
<bibl id="RFC3986"            key="RFC 3986"/>
<bibl id="RFC3987"            key="RFC 3987"/>
<bibl id="charmod"            key="Character Model"/>

</blist>
</div2>

<div2 id="informative-references">
<head>Other References</head>

<blist>

<bibl id="xmlbase"            key="XML Base"/>

<bibl id="xslt-30"            key="XSL Transformations (XSLT) Version 3.0"/>

<bibl id="XQWG" key="XML Query Working Group">
<titleref href="https://www.w3.org/XML/Query/"
>XML Query Working Group</titleref>,
World Wide Web Consortium.
Home page: https://www.w3.org/XML/Query/
</bibl>

<bibl id="XSLWG" key="XSLT Working Group">
<titleref href="https://www.w3.org/Style/XSL/"
>XSL Working Group</titleref>,
World Wide Web Consortium.
Home page: https://www.w3.org/Style/XSL/
</bibl>

<bibl diff="chg" at="2013-12-06" id="xquery-31" key="XQuery 3.1: An XML Query Language"/>

<bibl diff="chg" at="2013-12-06" id="xquery-31-requirements" key="XQuery 3.1 Requirements"/>

<bibl id="ISO8601"
      key="ISO 8601">ISO (International Organization for Standardization).
<emph>Representations of dates and times, 2000-08-03.</emph>
Available from: <loc href="http://www.iso.org/">http://www.iso.org/</loc>
</bibl>

</blist>
</div2>
</div1>

<div1 id="xdtschema">
&xdt-schema-app;
</div1>

<inform-div1 id="glossary">
<head>Glossary</head>
<?glossary?>
</inform-div1>

<inform-div1 id="example">
<head>Example</head>

<p>The following XML document is used to illustrate the information
contained in a data model:</p>

<eg>&dm-example.xml;</eg>

<p>The document is associated with the URI
<quote>http://www.example.com/catalog.xml</quote>,
and is valid with respect to the following XML schema:</p>

<eg>&dm-example.xsd;</eg>

<p>The schema is associated with the URI
<quote>http://www.example.com/dm-example.xsd</quote>.</p>

<p>This example exposes the data model for a document that has an associated
schema and has been validated successfully against it.
In general, an XML Schema is not required,
that is, the data model can represent a schemaless, well-formed XML
document with the rules described in <specref ref="types"/>.</p>

<p>The XML document is represented by the nodes described below.
The value <emph>D1</emph> represents a &documentNode;;
the values <emph>E1, E2, etc.</emph> represent &elementNode;s;
the values <emph>A1, A2, etc.</emph> represent &attributeNode;s;
the values <emph>N1, N2, etc.</emph> represent &namespaceNode;s;
the values <emph>P1, P2, etc.</emph> represent &processingInstructionNode;s;
the values <emph>T1, T2, etc.</emph> represent &textNode;s.</p>

<p>For brevity:</p>

<ulist>
<item><p>&textNode;s in the data model that contain only white space are not shown.</p>
</item>
<item><p>Literal strings are shown in quotes without the <code>xs:string()</code>
constructor
</p></item>
<item><p>Literal decimals are shown without the <code>xs:decimal()</code>
constructor
</p></item>
<item><p>Nodes are referred to using the syntax <code>[nodeID]</code>
</p></item>
<item><p>xs:QNames are used with the following prefixes bindings:</p>

<table>
<tbody>
  <tr>
    <td>xs</td><td>http://www.w3.org/2001/XMLSchema</td>
  </tr>
  <tr>
    <td>xsi</td><td>http://www.w3.org/2001/XMLSchema-instance</td>
  </tr>
  <tr>
    <td>cat</td><td>http://www.example.com/catalog</td>
  </tr>
  <tr>
    <td>xlink</td><td>http://www.w3.org/1999/xlink</td>
  </tr>
  <tr>
    <td>html</td><td>http://www.w3.org/1999/xhtml</td>
  </tr>
  <tr>
    <td>anon</td><td>An implementation-dependent prefix associated with
anonymous type names</td>
  </tr>
</tbody>
</table>

</item>
<item><p>The abbreviation <quote><code>\n</code></quote> is used in string literals
to represent a newline character; this isn't supported in XPath, but it makes
this presentation clearer.</p></item>
<item><p>Accessors that return the empty sequence have been omitted.</p>
</item>
<item><p>To simplify the presentation, we’re assuming an implementation
that does not expose the namespace axis. Therefore,
&namespaceNode;s are shared across multiple elements.
See <specref ref="NamespaceNode"/>.</p>
</item>
</ulist>

&dm-example.tbl;

<p>A graphical representation of the data model for the preceding
example is shown below. Document order in this representation can be
found by following the traditional left-to-right,
depth-first traversal; however, because the image has been rotated for
easier presentation, this appears to be bottom-to-top,
depth-first order.</p>

<table>
  <tbody>
    <tr>
      <td><graphic source="dm-example.png"
                   alt="Graphical depiction of the example data model."/>
      </td>
    </tr>
    <tr>
      <td>Graphic representation of the data model.
[<loc href="dm-example-large.png">large view</loc>,
<loc href="dm-example.svg">SVG</loc>]
      </td>
    </tr>
  </tbody>
</table>

</inform-div1>

<inform-div1 id="impl-summary">
<head>Implementation-Defined and Implementation-Dependent Items</head>

<div2 id="implementation-defined">
<head>Implementation-Defined Items</head>

<p>The following items are
<termref def="dt-implementation-defined">implementation-defined</termref>.
</p>

<?imp-def-feature?>
</div2>

<div2 id="implementation-dependent">
<head>Implementation-Dependent Items</head>

<p>The following items are
<termref def="dt-implementation-dependent">implementation-dependent</termref>.
</p>

<?imp-dep-feature?>
</div2>
</inform-div1>

&ChangeLog;

</back>
</spec>
