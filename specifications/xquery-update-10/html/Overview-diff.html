<?xml version="1.0" encoding="utf-8"?><!--{xml-fix} XSLT Processor: SAXON 9.1.0.2 from Saxonica SAXON SA 9.1.0.2--><!--This document was created at 20110311 1647--><html xmlns="http://www.w3.org/1999/xhtml" lang="EN"><head><title>XQuery Update Facility 1.0  -- Review Version</title><style type="text/css">
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

div.issue
p.title        { margin-left: -2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }

li p           { margin-top: 0.3em;
                 margin-bottom: 0.3em; }

sup small      { font-style: italic;
                 color: #8F8F8F;
               }
    
div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}

div.issue { border-bottom-color: black;
            border-bottom-style: solid;
	    border-bottom-width: 1pt;
	    margin-bottom: 20pt;
}

th.issue-toc-head { border-bottom-color: black;
                    border-bottom-style: solid;
                    border-bottom-width: 1pt;
}

      
.diff-add  { background-color: #99ff99 }
.diff-del  { background-color: #ff9999; text-decoration: line-through }
.diff-chg  { background-color: #ffff99 }
.diff-off  {  }
.diff-add  { background-color: #99ff99 }
.diff-del  { background-color: #ff9999; text-decoration: line-through }
.diff-chg  { background-color: #ffff99 }
.diff-off  {  }table.small                             { font-size: x-small; }
a.judgment:visited, a.judgment:link     { font-family: sans-serif;
                              	          color: black; 
                              	          text-decoration: none }
a.processing:visited, a.processing:link { color: black; 
                              		        text-decoration: none }
a.env:visited, a.env:link               { color: black; 
                                          text-decoration: none }</style><link rel="stylesheet" type="text/css" href="http://www.w3.org/StyleSheets/TR/W3C-REC.css"/></head><body><div><p>The presentation of this document has been augmented to
            identify changes from a previous version. Three kinds of changes
            are highlighted: <span class="diff-add">new, added text</span>,
            <span class="diff-chg">changed text</span>, and
            <span class="diff-del">deleted text</span>.</p><hr/></div><div class="head"><p><a href="http://www.w3.org/"><img src="http://www.w3.org/Icons/w3c_home" alt="W3C" height="48" width="72"/></a></p>
<h1><a name="title" id="title"/>XQuery Update Facility 1.0 </h1>
<h2><a name="w3c-doctype" id="w3c-doctype"/>W3C Recommendation 13 March 2011</h2><dl><dt>This version:</dt><dd>
<a href="http://www.w3.org/TR/2011/REC-xquery-update-10-20110313/">http://www.w3.org/TR/2011/REC-xquery-update-10-20110313/</a>
</dd><dt>Latest version:</dt><dd>
<a href="http://www.w3.org/TR/xquery-update-10/">http://www.w3.org/TR/xquery-update-10/</a>
</dd><dt>Previous version:</dt><dd>
<a href="http://www.w3.org/TR/2011/PR-xquery-update-10-20110125/">http://www.w3.org/TR/2011/PR-xquery-update-10-20110125/</a>,

</dd><dt>Editors:</dt><!--xmlspec, match="author"--><dd>Jonathan Robie, Red Hat <a href="mailto:jonathan.robie@redhat.com">&lt;jonathan.robie@redhat.com&gt;</a></dd><!--xmlspec, match="author"--><dd><!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span><a href="http://www.almaden.ibm.com/cs/people/chamberlin/">Don Chamberlin</a></span>, IBM Almaden Research Center</dd><div title="since 2008-10-07" class="diff-add"><dd><span class="diff-add">Michael Dyck <a href="mailto:jmdyck@ibiblio.org">&lt;jmdyck@ibiblio.org&gt;</a></span></dd></div><!--xmlspec, match="author"--><dd>Daniela Florescu, Oracle <a href="mailto:dana.florescu@oracle.com">&lt;dana.florescu@oracle.com&gt;</a></dd><!--xmlspec, match="author"--><dd>Jim Melton, Oracle <a href="mailto:jim.melton@oracle.com">&lt;jim.melton@oracle.com&gt;</a></dd><!--xmlspec, match="author"--><dd>Jérôme Siméon, IBM T.J. Watson Research Center <a href="mailto:simeon@us.ibm.com">&lt;simeon@us.ibm.com&gt;</a></dd></dl><p>Please refer to the <a href="http://www.w3.org/XML/2012/qt-errata/xquery-update-10-errata.html"><strong>errata</strong></a> for this document, which may
      include some normative corrections.</p><p>See also <a href="http://www.w3.org/2003/03/Translations/byTechnology?technology=xquery-update-10"><strong>translations</strong></a>.</p><p>This document is also available in these non-normative formats: <a href="http://www.w3.org/TR/2011/REC-xquery-update-10-20110313/xquery-update-10.xml">XML</a> and <a href="http://www.w3.org/TR/2011/REC-xquery-update-10-20110313/Overview-diff.html">Recent revisions (HTML)</a>.</p><p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2011 <a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href="http://www.ercim.eu/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p></div><hr/><div>
<h2><a name="abstract" id="abstract"/>Abstract</h2><p>This document defines an update facility that extends the XML Query language, XQuery. 
The XQuery Update Facility provides expressions that can be used to make persistent changes
to instances of the XQuery 1.0 and XPath 2.0 Data Model.</p></div><div>
<h2><a name="status" id="status"/>Status of this Document</h2><p><em>This section describes the status of this
         document at the time of its publication.
         Other documents may supersede this document.
         A list of current W3C publications and the latest
         revision of this technical report can be found in the
         <a href="http://www.w3.org/TR/">W3C technical reports index</a>
         at http://www.w3.org/TR/.</em></p><p>This is a <a href="http://www.w3.org/2005/10/Process-20051014/tr.html#RecsW3C">Recommendation</a> of the W3C. 
  It was developed by the W3C <a href="http://www.w3.org/XML/Query/">XML Query Working Group</a>,
which is part of the <a href="http://www.w3.org/XML/Activity">XML Activity</a>.</p><p>This document incorporates minor changes made against the Proposed Recommendation
                               of 25 January 2011. 
                               Changes to this document since the Proposed Recommendation are detailed in
                               <a href="#id-revision-log"><b>[H Revision Log]</b></a>.
                               A Java applet that parses XQuery Update Facility 1.0
                               expressions is available at <a href="http://www.w3.org/2010/02/qt-applets/xquery10-update/">
                               http://www.w3.org/2010/02/qt-applets/xquery10-update/</a>.</p><p>A Test Suite has been created for this document.
Implementors are encouraged to run this test suite and report their results.
The Test Suite can be found at <a href="http://dev.w3.org/2007/xquery-update-10-test-suite/">http://dev.w3.org/2007/xquery-update-10-test-suite/</a>. 
An implementation report is available at
<a href="http://dev.w3.org/2007/xquery-update-10-test-suite/results/">http://dev.w3.org/2007/xquery-update-10-test-suite/results/</a>.</p><p>No substantive changes have been made to this specification
since its publication as a Proposed Recommendation.</p><p>Please report errors in this document using W3C's
         <a href="http://www.w3.org/Bugs/Public/">public Bugzilla system</a>
         (instructions can be found at
         <a href="http://www.w3.org/XML/2005/04/qt-bugzilla">http://www.w3.org/XML/2005/04/qt-bugzilla</a>).
         If access to that system is not feasible, you may send your comments
         to the W3C XSLT/XPath/XQuery public comments mailing list,
         <a href="mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</a>.
         It will be very helpful if you include the string 
         “[UPD]”
         in the subject line of your report, whether made in Bugzilla or in email.
         Please use multiple Bugzilla entries (or, if necessary, multiple email messages)
         if you have more than one comment to make.
         Archives of the comments and responses are available at
         <a href="http://lists.w3.org/Archives/Public/public-qt-comments/">http://lists.w3.org/Archives/Public/public-qt-comments/</a>. </p><p>This document has been reviewed by W3C Members, by
software developers, and by other W3C groups and interested parties,
and is endorsed by the Director as a W3C Recommendation. 
It is a stable document and may be used as reference material or cited from
another document. 
W3C's role in making the Recommendation is to draw attention to
the specification and to promote its widespread deployment. 
This enhances the functionality and interoperability of
the Web.</p><p>This document was produced by a group operating under the
  <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004
  W3C Patent Policy</a>.
  W3C maintains a 
  <a href="http://www.w3.org/2004/01/pp-impl/18797/status#disclosures">public list of any patent disclosures</a>
  made in connection with the deliverables of the group; 
  that page also includes instructions for disclosing a patent.
  An individual who has actual knowledge of a patent 
  which the individual believes contains
  <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential Claim(s)</a>
  must disclose the information in accordance with
  <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">
  section 6 of the W3C Patent Policy</a>. </p></div><div class="toc">
<h2><a name="contents" id="contents"/>Table of Contents</h2><p class="toc">1 <a href="#introduction">Introduction</a><br/>
    1.1 <a href="#id-terminology">Terminology</a><br/>
2 <a href="#id-extensions"><span class="diff-chg">Extensions to XQuery 1.0</span></a><br/>
    2.1 <a href="#id-processing-model">Extensions to the Processing Model</a><br/>
    2.2 <a href="#id-prolog-extensions">Extensions to the Prolog</a><br/>
        2.2.1 <a href="#id-revalidation-declaration">Revalidation Declaration</a><br/>
        2.2.2 <a href="#id-variable-declaration">Variable Declaration</a><br/>
        2.2.3 <a href="#id-function-declaration">Function Declaration</a><br/>
    2.3 <a href="#id-static-context-extensions">Extensions to the Static Context</a><br/>
    2.4 <a href="#id-new-expressions">New Kinds of Expressions</a><br/>
        2.4.1 <a href="#id-insert">Insert</a><br/>
        2.4.2 <a href="#id-delete"><span class="diff-chg">Delete</span></a><br/>
        2.4.3 <a href="#id-replace">Replace</a><br/>
            2.4.3.1 <a href="#id-replacing-node">Replacing a Node</a><br/>
            2.4.3.2 <a href="#id-replacing-node-value">Replacing the Value of a Node</a><br/>
        2.4.4 <a href="#id-rename">Rename</a><br/>
        2.4.5 <a href="#id-transform"><span class="diff-chg">Transform</span></a><br/>
        2.4.6 <a href="#id-compatibility">Compatibility of Updating Expressions</a><br/>
    2.5 <a href="#id-extensions-to-existing">Extensions to Existing Expressions</a><br/>
        2.5.1 <a href="#id-flwor-expr">FLWOR Expression</a><br/>
        2.5.2 <a href="#id-typeswitch-expr">Typeswitch Expression</a><br/>
        2.5.3 <a href="#id-conditional-expr">Conditional Expression</a><br/>
        2.5.4 <a href="#id-comma-expr">Comma Expression</a><br/>
        2.5.5 <a href="#id-parenthesized-expr">Parenthesized Expression</a><br/>
        2.5.6 <a href="#id-function-call">Function Call</a><br/>
        2.5.7 <a href="#id-other-expr"><span class="diff-chg">Other Expressions</span></a><br/>
    2.6 <a href="#id-new-functions">Extensions to Built-in Function Library</a><br/>
        2.6.1 <a href="#id-func-put">fn:put</a><br/>
3 <a href="#id-update-operations">Update Operations</a><br/>
    3.1 <a href="#id-update-primitives">Update Primitives</a><br/>
        3.1.1 <a href="#id-upd-insert-before"><span class="diff-chg">upd:insertBefore</span></a><br/>
        3.1.2 <a href="#id-upd-insert-after">upd:insertAfter</a><br/>
        3.1.3 <a href="#id-upd-insert-into">upd:insertInto</a><br/>
        3.1.4 <a href="#id-upd-insert-into-as-first">upd:insertIntoAsFirst</a><br/>
        3.1.5 <a href="#id-upd-insert-into-as-last">upd:insertIntoAsLast</a><br/>
        3.1.6 <a href="#id-upd-insert-attributes"><span class="diff-chg">upd:insertAttributes</span></a><br/>
        3.1.7 <a href="#id-upd-delete">upd:delete</a><br/>
        3.1.8 <a href="#id-upd-replacenode"><span class="diff-chg">upd:replaceNode</span></a><br/>
        3.1.9 <a href="#id-upd-replace-value">upd:replaceValue</a><br/>
        3.1.10 <a href="#id-upd-replace-element-content">upd:replaceElementContent</a><br/>
        3.1.11 <a href="#id-upd-rename"><span class="diff-chg">upd:rename</span></a><br/>
        3.1.12 <a href="#id-upd-put">upd:put</a><br/>
    3.2 <a href="#id-update-routines">Update Routines</a><br/>
        3.2.1 <a href="#id-upd-merge-updates">upd:mergeUpdates</a><br/>
        3.2.2 <a href="#id-upd-apply-updates"><span class="diff-chg">upd:applyUpdates</span></a><br/>
        3.2.3 <a href="#id-upd-revalidate">upd:revalidate</a><br/>
        3.2.4 <a href="#id-upd-remove-type">upd:removeType</a><br/>
        3.2.5 <a href="#id-upd-set-to-untyped"><span class="diff-chg">upd:setToUntyped</span></a><br/>
        3.2.6 <a href="#id-upd-propagate-namespace"><span class="diff-chg">upd:propagateNamespace</span></a><br/>
4 <a href="#id-update-static">Static Typing Feature</a><br/>
    4.1 <a href="#id-update-overview">Overview and notations</a><br/>
    4.2 <a href="#id-static-typing-changes">Change to Static Typing Rules of XQuery 1.0</a><br/>
    4.3 <a href="#id-update-core">Core Grammar</a><br/>
    4.4 <a href="#id-update-norm-prolog">XQuery Update Facility 1.0 Prolog</a><br/>
    4.5 <a href="#id-update-norm-expr">XQuery Update Facility 1.0 Expressions</a><br/>
        4.5.1 <a href="#id-update-typing-insert">Insert</a><br/>
        4.5.2 <a href="#id-update-typing-delete">Delete</a><br/>
        4.5.3 <a href="#id-update-typing-replace">Replace</a><br/>
        4.5.4 <a href="#id-update-typing-rename">Rename</a><br/>
        4.5.5 <a href="#id-update-typing-transform"><span class="diff-chg">Transform</span></a><br/>
        4.5.6 <a href="#id-update-typing-examples">Examples</a><br/>
5 <a href="#id-xquery-update-conformance">Conformance</a><br/>
    5.1 <a href="#id-minimal-conformance">Minimal Conformance</a><br/>
    5.2 <a href="#id-conform-optional-features">Optional Features</a><br/>
        5.2.1 <a href="#id-update-facility-static-typing-feature">Update Facility Static Typing Feature</a><br/>
6 <a href="#id-xqueryx-update-conformance">XQueryX Conformance</a><br/>
</p>
<h3><a name="appendices" id="appendices"/>Appendices</h3><p class="toc">A <a href="#id-grammar">EBNF for XQuery 1.0 Grammar with Update extensions</a><br/>
    A.1 <a href="#id-terminal-symbols">Terminal Symbols</a><br/>
B <a href="#id-impl-defs"><span class="diff-chg">Implementation-Defined Items</span></a><br/>
C <a href="#References">References</a><br/>
    C.1 <a href="#id-normative-references">Normative References</a><br/>
    C.2 <a href="#id-non-normative-references">Non-normative References</a><br/>
D <a href="#id-errors">Error Conditions</a><br/>
    D.1 <a href="#id-new-error-codes"><span class="diff-chg">New Error Codes</span></a><br/>
    D.2 <a href="#id-amended-error-codes">Amendments to Existing Error Codes</a><br/>
E <a href="#id-xquf-xqueryx">XML Syntax (XQueryX) for XQuery Update Facility 1.0</a><br/>
    E.1 <a href="#id-xquf-update-schema">Schema</a><br/>
    E.2 <a href="#id-xquf-update-stylesheet">Stylesheet</a><br/>
    E.3 <a href="#id-xquf-update-examples">Example</a><br/>
        E.3.1 <a href="#id-xquery-rep">XQuery Representation</a><br/>
        E.3.2 <a href="#id-xqueryx-rep">XQueryX Representation</a><br/>
        E.3.3 <a href="#id-transformed-rep">Transformed XQuery Representation</a><br/>
F <a href="#id-glossary">Glossary</a> (Non-Normative)<br/>
G <a href="#id-precedence-rationale">Rationale for Precedence of Update Primitives</a> (Non-Normative)<br/>
H <a href="#id-revision-log">Revision Log</a> (Non-Normative)<br/>
</p></div><hr/><div class="body"><div class="div1">
<h2><a name="introduction" id="introduction"/>1 Introduction</h2><p>
This document defines the syntax and semantics of an extension 
to <a href="#xquery">[XQuery 1.0]</a> called the XQuery Update Facility 1.0.
This language extension is designed to meet the
requirements for updating instances of the  <a href="#xpath-datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>, as defined in
<a href="#xquery-update-10-requirements">[XQuery Update Facility 1.0 Requirements]</a>.</p><p>
The XQuery Update Facility 1.0 provides facilities to perform any or all
of the following operations on an
<a title="XDM instance" href="#dt-xdm-instance">XDM instance</a>:
</p><ul><li><p>Insertion of a node.</p></li><li><p>Deletion of a node.</p></li><li><p>Modification of a node by changing
some of its properties while preserving its <a title="node identity" href="#dt-node-identity">node identity</a>.</p></li><li><p>Creation of a modified copy of a node with a new <a title="node identity" href="#dt-node-identity">node identity</a>.</p></li></ul><p>
Additionally, this document defines an XML syntax for the XQuery Update Facility 1.0. 
The most recent versions of the two XQueryX XML Schemas and the
XQueryX XSLT stylesheet for the XQuery Update Facility 1.0 are available at
<a href="http://www.w3.org/2007/xquery-update-10/xquery-update-10-xqueryx.xsd">http://www.w3.org/2007/xquery-update-10/xquery-update-10-xqueryx.xsd</a>,
<a href="http://www.w3.org/2007/xquery-update-10/xquery-update-10-xqueryx-redef.xsd">http://www.w3.org/2007/xquery-update-10/xquery-update-10-xqueryx-redef.xsd</a>,
and <a href="http://www.w3.org/2007/xquery-update-10/xquery-update-10-xqueryx.xsl">http://www.w3.org/2007/xquery-update-10/xquery-update-10-xqueryx.xsl</a>,
respectively. 
</p><div class="div2">
<h3><a name="id-terminology" id="id-terminology"/>1.1 Terminology</h3><p>
[<a name="dt-xquery" id="dt-xquery" title="XQuery">Definition</a>: Within this document,
the term <b>XQuery</b> refers to the language specified by <a href="#xquery">[XQuery 1.0]</a>.]
[<a name="dt-data-model" id="dt-data-model" title="data model">Definition</a>: The term <b>data model</b> refers to
the data model specified by <a href="#xpath-datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>.]
[<a name="dt-xdm-instance" id="dt-xdm-instance" title="XDM instance">Definition</a>: The term <b>XDM instance</b>
denotes an unconstrained sequence of zero or more nodes and/or atomic values
as defined by the <a title="data model" href="#dt-data-model">data model</a>.]
[<a name="dt-node-identity" id="dt-node-identity" title="node identity">Definition</a>: The term <b>node identity</b>
denotes the unique identity that is a property of every node in an
<a title="XDM instance" href="#dt-xdm-instance">XDM instance</a>
(see <a href="http://www.w3.org/TR/xpath-datamodel/#node-identity">Section 
2.3 Node Identity</a><sup><small>DM</small></sup>.)]
</p><p>
As described in <a href="http://www.w3.org/TR/xpath-datamodel/#qnames-and-notations">Section 
3.3.3 QNames and NOTATIONS</a><sup><small>DM</small></sup>,
names in XQuery are qualified names (QNames) that consist of an
optional namespace prefix, a local name, and an optional namespace URI. 
[<a name="dt-implied-namespace-binding" id="dt-implied-namespace-binding" title="implied namespace binding">Definition</a>: The
<b>implied namespace binding</b> of a QName is the association of its namespace prefix
(or absence thereof) with its namespace URI (or absence thereof).]
[<a name="dt-conflict" id="dt-conflict" title="conflict">Definition</a>: Two namespace bindings are said to
<b>conflict</b> if their namespace prefixes (or absence thereof) are
the same but their namespace URI's (or absence thereof) are different.]
Update operations that result in conflicting namespace bindings generally raise errors,
as described in this document. 

However, if the namespace prefix of an attribute is absent, it is in
no namespace, and its implied namespace binding is not added to the namespace bindings of its parent element. Therefore, an update operation can create such an attribute in an element even though its implied namespace binding conflicts with a namespace binding in the "namespaces" property of the element.
</p><p>
In this document, examples and material labeled as "Note" are provided for
explanatory purposes and are not normative.
</p><p>
Some of the examples in this document will be rejected by an implementation that supports the <a href="#id-update-static"><b>[4 Static Typing Feature]</b></a>.
</p></div></div><div class="div1">
<h2><a name="id-extensions" id="id-extensions"/>2 Extensions to XQuery 1.0</h2><p>The basic  building block of XQuery is the expression. XQuery 1.0 provides 
several kinds of expressions that can be composed with each other in 
arbitrary ways. An XQuery 1.0 expression takes zero or more 
<a title="XDM instance" href="#dt-xdm-instance">XDM instances</a> as input and returns an <a title="XDM instance" href="#dt-xdm-instance">XDM instance</a> as 
a result. In XQuery 1.0, an expression never modifies the state of 
an existing node; however, constructor expressions create new nodes 
with new <a title="node identity" href="#dt-node-identity">node identities</a>.</p><p>XQuery Update Facility 1.0 introduces a new category of expression called an <a title="updating expression" href="#dt-updating-expression">updating expression</a>, which can potentially modify the state of an existing node.</p><p>The extensions to XQuery 1.0 provided by XQuery Update Facility 1.0 may be characterized 
as follows:</p><ol class="enumar"><li><p>XQuery Update Facility 1.0 introduces five new kinds of expressions, called insert, 
delete, replace, rename, and transform expressions, and specifies the syntax and semantics of each new kind of expression.</p></li><li><p>XQuery Update Facility 1.0 classifies XQuery expressions into the following categories:
</p><ol class="enumla"><li><p>[<a name="dt-basic-updating-expression" id="dt-basic-updating-expression" title="basic updating expression">Definition</a>: A <b>basic updating expression</b> is an insert, delete, replace, or rename expression, or a call to an <a title="updating function" href="#dt-updating-function">updating function</a>.]</p></li><li><p>[<a name="dt-updating-expression" id="dt-updating-expression" title="updating expression">Definition</a>: An <b>updating expression</b> is a <a title="basic updating expression" href="#dt-basic-updating-expression">basic updating expression</a> or any
expression (other than a transform expression) that directly
contains an <a title="updating expression" href="#dt-updating-expression">updating expression</a>.]</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The definition of an <a title="updating expression" href="#dt-updating-expression">updating expression</a> is recursive.</p></div></li><li><p>[<a name="dt-simple-expression" id="dt-simple-expression" title="simple expression">Definition</a>: A <b>simple expression</b> is any XQuery expression that is not an <a title="updating expression" href="#dt-updating-expression">updating expression</a>.]</p></li><li><div class="diff-del"><p>
[<a name="dt-vacuous-expression-obsolete" id="dt-vacuous-expression-obsolete" title="vacuous expression">Definition</a>: A <b>vacuous expression</b> is a <a title="simple expression" href="#dt-simple-expression">simple expression</a> that can only return an empty sequence or raise an error.]</p></div><div class="diff-add"><p>[<a name="dt-vacuous-expression" id="dt-vacuous-expression" title="vacuous expression">Definition</a>: 
Certain expressions are defined in this specification
   to be <b>vacuous expressions</b>. These all have the characteristic that
   they can be determined statically to either return an empty
   sequence or raise an error.]</p></div><span class="diff-add"><div class="note"><p class="prefix"><b>Note:</b></p><p>Every vacuous expression is identified explicitly in this specification. Some expressions can be determined to either return an empty
   sequence or raise an error, but are nevertheless not defined to be vacuous.  For convenience, here is a list of the vacuous expressions:</p><ul><li><p>A call to the built-in function <code>fn:error</code> is a vacuous expression.</p></li><li><p>An empty parenthesized expression ( ) is a vacuous expression.</p></li><li><p>A non-empty parenthesized expression is a vacuous expression if the expression it contains is a vacuous expression.</p></li><li><p>If all branches are vacuous expressions, the typeswitch expression is a
vacuous expression.</p></li><li><p>If both branches are vacuous expressions, the conditional expression is a
vacuous expression.</p></li><li><p>If all operands are vacuous expressions, the comma expression is a vacuous
expression.</p></li><li><p>If the return clause of a FLWOR Expression is vacuous, the FLWOR expression is a vacuous expression.</p></li></ul></div></span></li></ol></li><li><p>XQuery Update Facility 1.0 defines  the places 
in which each type of expression can be used. In so doing, it makes small 
extensions to the syntax and semantics of certain existing expressions.</p></li></ol><p>The classification of each expression into one of the above categories is performed by static analysis, according to rules specified in this document for each type of expression.</p><div class="div2">
<h3><a name="id-processing-model" id="id-processing-model"/>2.1 Extensions to the Processing Model</h3><p>XQuery Update Facility 1.0 defines the following extensions to the XQuery processing model:</p><ol class="enumar"><li><p>In XQuery 1.0, the result of each expression is an <a title="XDM instance" href="#dt-xdm-instance">XDM instance</a>. XQuery Update Facility 1.0 extends the XQuery processing model so that the
result of an expression consists of both an <a title="XDM instance" href="#dt-xdm-instance">XDM instance</a> and a <a title="pending update list" href="#dt-pending-update-list">pending update list</a> (either or both of which may be empty). [<a name="dt-pending-update-list" id="dt-pending-update-list" title="pending update list">Definition</a>: A <b>pending update list</b> is an unordered collection of <a title="update primitive" href="#dt-update-primitive">update primitives</a>, which represent node state changes that have not yet been applied.] The term "result" used in <a href="http://www.w3.org/TR/xquery/#id-errors-and-opt">Section 
2.3.4 Errors and
      Optimization</a><sup><small>XQ</small></sup> includes both the  <a title="XDM instance" href="#dt-xdm-instance">XDM instance</a> and the <a title="pending update list" href="#dt-pending-update-list">pending update list</a> returned by an expression.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In XQuery Update Facility 1.0, no expression returns both a non-empty <a title="XDM instance" href="#dt-xdm-instance">XDM instance</a> and a non-empty <a title="pending update list" href="#dt-pending-update-list">pending update list</a>.</p></div></li><li><p>XQuery Update Facility 1.0 also defines a set of <a title="update operation" href="#dt-update-operation">update operations</a>. [<a name="dt-update-operation" id="dt-update-operation" title="update operation">Definition</a>: <b>Update operations</b> are used in defining the semantics of XQuery updates, but are not directly available to users. Update operations are defined in <a href="#id-update-operations"><b>[3 Update Operations]</b></a>.] Update operations fall into the following categories:</p><ol class="enumla"><li><p> [<a name="dt-update-primitive" id="dt-update-primitive" title="update primitive">Definition</a>: <b>Update primitives</b> are the components of <a title="pending update list" href="#dt-pending-update-list">pending update lists</a>. Each <b>update primitive</b> represents a node state change that has not yet been applied.] [<a name="dt-target-node" id="dt-target-node" title="target node">Definition</a>: The first argument of an update primitive, called its <b>target node</b>, is the principal node to be affected by the update primitive.] Update primitives are held on <a title="pending update list" href="#dt-pending-update-list">pending update lists</a> until they are made effective by a <a href="#id-upd-apply-updates">upd:applyUpdates</a> operation.</p></li><li><p>[<a name="dt-update-routine" id="dt-update-routine" title="update routine">Definition</a>: <b>Update routines</b> are sequences of actions that are used in the definition of XQuery semantics but do not appear on <a title="pending update list" href="#dt-pending-update-list">pending update lists</a>.] <a href="#id-upd-apply-updates">upd:applyUpdates</a> is an example of an update routine.</p></li></ol></li><li><p>If the outermost expression in a query returns a <a title="pending update list" href="#dt-pending-update-list">pending update list</a>, <a href="#id-upd-apply-updates">upd:applyUpdates</a> is implicitly invoked to apply the pending updates to the  <a title="XDM instance" href="#dt-xdm-instance">XDM instance</a>. This invocation of <a href="#id-upd-apply-updates">upd:applyUpdates</a> may raise an error (see <a href="#id-upd-apply-updates"><b>[3.2.2 upd:applyUpdates]</b></a> for possible error codes.)</p></li></ol><p>[<a name="dt-snapshot" id="dt-snapshot" title="snapshot">Definition</a>: A <b>snapshot</b> is a scope within which expressions are evaluated
with respect to a fixed <a title="XDM instance" href="#dt-xdm-instance">XDM instance</a> and updates are held pending.] A snapshot
is terminated by invocation of the <a href="#id-upd-apply-updates">upd:applyUpdates</a> operation. XQuery Update Facility 1.0 defines an entire query as one snapshot.</p><p>This specification defines the semantics of updates to an <a title="XDM instance" href="#dt-xdm-instance">XDM instance</a>.
Propagation of these updates to an underlying persistent store (if any)
is beyond the scope of this specification.</p></div><div class="div2">
<h3><a name="id-prolog-extensions" id="id-prolog-extensions"/>2.2 Extensions to the Prolog</h3><div class="div3">
<h4><a name="id-revalidation-declaration" id="id-revalidation-declaration"/>2.2.1 Revalidation Declaration</h4>
<h5><a name="d8e595" id="d8e595"/></h5><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery-Setter" id="doc-xquery-Setter"/>[<small>7</small>]   </td><td><code><a href="#prod-xquery-Setter"><a href="#prod-xquery-Setter">Setter</a></a></code></td><td>   ::=   </td><td><code><a href="#prod-xquery-BoundarySpaceDecl">BoundarySpaceDecl</a>  |  <a href="#prod-xquery-DefaultCollationDecl">DefaultCollationDecl</a>  |  <a href="#prod-xquery-BaseURIDecl">BaseURIDecl</a>  |  <a href="#prod-xquery-ConstructionDecl">ConstructionDecl</a>  |  <a href="#prod-xquery-OrderingModeDecl">OrderingModeDecl</a>  |  <a href="#prod-xquery-EmptyOrderDecl">EmptyOrderDecl</a>  |  <a href="#doc-xquery-RevalidationDecl">RevalidationDecl</a>  |  <a href="#prod-xquery-CopyNamespacesDecl">CopyNamespacesDecl</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-xquery-RevalidationDecl" id="doc-xquery-RevalidationDecl"/>[<small>141</small>]   </td><td><code><a href="#prod-xquery-RevalidationDecl"><a href="#prod-xquery-RevalidationDecl">RevalidationDecl</a></a></code></td><td>   ::=   </td><td><code>"declare"  "revalidation"  ("strict"  |  "lax"  |  "skip")</code></td></tr></tbody></table><p>The Prolog is extended by adding a new kind of <a href="#doc-xquery-Setter">Setter</a>
called a revalidation declaration. 
[<a name="dt-revalidation-decl" id="dt-revalidation-decl" title="revalidation declaration">Definition</a>: A <b>revalidation declaration</b>
sets the <a title="revalidation mode" href="#dt-revalidation-mode">revalidation mode</a> in the static context,
overriding any implementation-defined default.]
If a Prolog contains more than one revalidation declaration,
a static error is raised [<a href="#ERRXUST0003" title="err:XUST0003">err:XUST0003</a>]. 
<a title="revalidation mode" href="#dt-revalidation-mode">Revalidation mode</a> controls the process by which type information
is recovered for an updated document, as described in <a href="#id-upd-revalidate"><b>[3.2.3 upd:revalidate]</b></a></p><p>Support for each of the three revalidation modes is implementation-defined; however, an implementation must support at least one of the three revalidation modes. If a revalidation declaration specifies a revalidation mode that is not supported by the current implementation, a static error is raised [<a href="#ERRXUST0026" title="err:XUST0026">err:XUST0026</a>].</p></div><div class="div3">
<h4><a name="id-variable-declaration" id="id-variable-declaration"/>2.2.2 Variable Declaration</h4><p>The following rule is added: If the expression on the right-hand-side of a variable declaration (the initializing expression) is not a <a title="simple expression" href="#dt-simple-expression">simple expression</a>, a static error is raised [<a href="#ERRXUST0001" title="err:XUST0001">err:XUST0001</a>].</p></div><div class="div3">
<h4><a name="id-function-declaration" id="id-function-declaration"/>2.2.3 Function Declaration</h4>
<h5><a name="d8e667" id="d8e667"/></h5><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery-FunctionDecl" id="doc-xquery-FunctionDecl"/>[<small>26</small>]   </td><td><code><a href="#prod-xquery-FunctionDecl"><a href="#prod-xquery-FunctionDecl">FunctionDecl</a></a></code></td><td>   ::=   </td><td><code>"declare"  "updating"?  "function"  <a href="#prod-xquery-QName">QName</a>  "("  <a href="#prod-xquery-ParamList">ParamList</a>?  ")"  ("as"  <a href="#prod-xquery-SequenceType">SequenceType</a>)?  (<a href="#prod-xquery-EnclosedExpr">EnclosedExpr</a>  |  "external")</code></td></tr></tbody></table><p>The syntax of a function declaration is extended with an optional keyword: <code>updating</code>. [<a name="dt-updating-function" id="dt-updating-function" title="updating function">Definition</a>: Functions whose declarations contain the keyword <code>updating</code>, and certain built-in functions including <code>fn:put</code>, are called <b>updating functions</b>.] The semantics of a function declaration, described in Section 4.15 of <a href="#xquery">[XQuery 1.0]</a>,  are extended as follows:</p><ol class="enumar"><li><p>If <code>updating</code> is not specified:</p><ol class="enumla"><li><p>If <code>external</code> is not specified, the EnclosedExpr in the function declaration must be a <a title="simple expression" href="#dt-simple-expression">simple expression</a>; otherwise a static error is raised [<a href="#ERRXUST0001" title="err:XUST0001">err:XUST0001</a>].</p></li><li><p>If <code>external</code> is specified, the external function  must not return a non-empty <a title="pending update list" href="#dt-pending-update-list">pending update list</a>; otherwise a dynamic error is raised [<a href="#ERRXUDY0018" title="err:XUDY0018">err:XUDY0018</a>].</p></li></ol></li><li><p>If <code>updating</code> is specified:</p><ol class="enumla"><li><p>A return type must not  be specified [<a href="#ERRXUST0028" title="err:XUST0028">err:XUST0028</a>].</p></li><li><p>If <code>external</code> is not specified, the EnclosedExpr in the function declaration must be an <a title="updating expression" href="#dt-updating-expression">updating expression</a> or a <a title="vacuous expression" href="#dt-vacuous-expression">vacuous expression</a>; otherwise a static error is raised [<a href="#ERRXUST0002" title="err:XUST0002">err:XUST0002</a>].</p></li><li><p>If <code>external</code> is specified, the external function may return a non-empty <a title="pending update list" href="#dt-pending-update-list">pending update list</a> but it must not return a non-empty <a title="XDM instance" href="#dt-xdm-instance">XDM instance</a>; otherwise a dynamic error is raised [<a href="#ERRXUDY0019" title="err:XUDY0019">err:XUDY0019</a>].</p></li></ol></li></ol><p>The means by which an external function returns an <a title="XDM instance" href="#dt-xdm-instance">XDM instance</a> or a <a title="pending update list" href="#dt-pending-update-list">pending update list</a> is implementation-defined.</p><p>The following example illustrates a declaration of an updating function.</p><ul><li><p>This function takes an element, a QName, and an atomic value. If the given element has an attribute with the given QName, the function updates the attribute with the given value; otherwise it inserts a new attribute with the given name and value.</p><div class="exampleInner"><pre>declare updating function 
   upsert($e as element(), 
          $an as xs:QName, 
          $av as xs:anyAtomicType) 
   {
   let $ea := $e/attribute()[fn:node-name(.) = $an]
   return
      if (fn:empty($ea))
      then insert node attribute {$an} {$av} into $e
      else replace value of node $ea with $av
   }</pre></div></li></ul></div></div><div class="div2">
<h3><a name="id-static-context-extensions" id="id-static-context-extensions"/>2.3 Extensions to the Static Context</h3><ol class="enumar"><li><p>The following definition is added to the XQuery static context
(documented in <a href="http://www.w3.org/TR/xquery/#static_context">Section 
2.1.1 Static Context</a><sup><small>XQ</small></sup>):</p><p>[<a name="dt-revalidation-mode" id="dt-revalidation-mode" title="revalidation mode">Definition</a>: <b>Revalidation mode</b>,
which may be <code>strict</code>, <code>lax</code>, or <code>skip</code>,
is a component of the static context that controls the behavior of the
<code><a href="#id-upd-revalidate">upd:revalidate</a></code> operation.]</p></li><li><p>The following entry is added to the table of static context components
(documented in <a href="http://www.w3.org/TR/xquery/#id-xq-static-context-components">Section 
C.1 Static Context Components</a><sup><small>XQ</small></sup>):</p><ul><li><p>Component: Revalidation mode</p></li><li><p>Default initial value: <code>lax</code>.</p></li><li><p>Can be overwritten by an implementation: Yes (implementation defined.)</p></li><li><p>Can be overwritten by a query: Yes, overwritable by declaration in query prolog.</p></li><li><p>Scope: Module.</p></li><li><p>Consistency rules: Must be <code>strict</code>, <code>lax</code>, or <code>skip</code>.</p></li></ul></li></ol></div><div class="div2">
<h3><a name="id-new-expressions" id="id-new-expressions"/>2.4 New Kinds of Expressions</h3>
<h5><a name="d8e857" id="d8e857"/></h5><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery-ExprSingle" id="doc-xquery-ExprSingle"/>[<small>32</small>]   </td><td><code><a href="#prod-xquery-ExprSingle"><a href="#prod-xquery-ExprSingle">ExprSingle</a></a></code></td><td>   ::=   </td><td><code><a href="#prod-xquery-FLWORExpr">FLWORExpr</a><br/>|  <a href="#prod-xquery-QuantifiedExpr">QuantifiedExpr</a><br/>|  <a href="#prod-xquery-TypeswitchExpr">TypeswitchExpr</a><br/>|  <a href="#prod-xquery-IfExpr">IfExpr</a><br/>|  <a href="#doc-xquery-InsertExpr">InsertExpr</a><br/>|  <a href="#doc-xquery-DeleteExpr">DeleteExpr</a><br/>|  <a href="#doc-xquery-RenameExpr">RenameExpr</a><br/>|  <a href="#doc-xquery-ReplaceExpr">ReplaceExpr</a><br/>|  <a href="#doc-xquery-TransformExpr">TransformExpr</a><br/>|  <a href="#prod-xquery-OrExpr">OrExpr</a></code></td></tr></tbody></table><p>XQuery Update Facility 1.0 extends the syntax of <a href="#doc-xquery-ExprSingle">ExprSingle</a> by adding five new kinds of expressions, called insert, delete, replace, rename, and transform expressions.
The syntax and semantics of these expressions are described in the following sections.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In general, <a title="updating expression" href="#dt-updating-expression">updating expressions</a> cause a loss of type information from nodes that are affected by the update. Type information for these nodes may be recovered by a revalidation process at the end of the <a title="snapshot" href="#dt-snapshot">snapshot</a>. For more details on type loss and recovery, see the <a title="update primitive" href="#dt-update-primitive">update primitives</a> associated with each updating expression; see also <a href="#id-upd-remove-type"><b>[3.2.4 upd:removeType]</b></a> and <a href="#id-upd-revalidate"><b>[3.2.3 upd:revalidate]</b></a>.</p></div><div class="div3">
<h4><a name="id-insert" id="id-insert"/>2.4.1 Insert</h4>
<h5><a name="d8e927" id="d8e927"/></h5><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery-InsertExpr" id="doc-xquery-InsertExpr"/>[<small>143</small>]   </td><td><code><a href="#prod-xquery-InsertExpr"><a href="#prod-xquery-InsertExpr">InsertExpr</a></a></code></td><td>   ::=   </td><td><code>"insert"  ("node"  |  "nodes")  <a href="#doc-xquery-SourceExpr">SourceExpr</a>  <a href="#doc-xquery-InsertExprTargetChoice">InsertExprTargetChoice</a>  <a href="#doc-xquery-TargetExpr">TargetExpr</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-xquery-InsertExprTargetChoice" id="doc-xquery-InsertExprTargetChoice"/>[<small>142</small>]   </td><td><code><a href="#prod-xquery-InsertExprTargetChoice"><a href="#prod-xquery-InsertExprTargetChoice">InsertExprTargetChoice</a></a></code></td><td>   ::=   </td><td><code>(("as"  ("first"  |  "last"))?  "into")<br/>|  "after"<br/>|  "before"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-xquery-SourceExpr" id="doc-xquery-SourceExpr"/>[<small>147</small>]   </td><td><code><a href="#prod-xquery-SourceExpr"><a href="#prod-xquery-SourceExpr">SourceExpr</a></a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-xquery-TargetExpr" id="doc-xquery-TargetExpr"/>[<small>148</small>]   </td><td><code><a href="#prod-xquery-TargetExpr"><a href="#prod-xquery-TargetExpr">TargetExpr</a></a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-ExprSingle">ExprSingle</a></code></td></tr></tbody></table><p>An insert expression is an <a title="updating expression" href="#dt-updating-expression">updating expression</a> that inserts copies of zero or more nodes into a 
designated position with respect to a target node. The keywords <code>node</code> and <code>nodes</code> may be used interchangeably, regardless of how many nodes are actually inserted. The position of the inserted nodes is determined as follows:</p><ul><li><p>If <code>before</code> (or <code>after</code>) is specified:</p><ul><li><p>The inserted nodes become the preceding (or following) siblings of the 
target node.</p></li><li><p>If multiple nodes are inserted by a single insert expression, the nodes 
remain adjacent and their order preserves the node ordering of the source expression.</p></li><li><p>If multiple groups of nodes are inserted by multiple insert expressions 
in the same <a title="snapshot" href="#dt-snapshot">snapshot</a>, adjacency and ordering of nodes within each group is 
preserved but ordering among the groups is implementation-dependent.
</p></li></ul></li><li><p>If <code>as first into</code> (or <code>as last into</code>) is specified:</p><ul><li><p>The inserted nodes become the first (or last) children of the target 
node.</p></li><li><p>If multiple nodes are inserted by a single insert expression, the nodes 
remain adjacent and their order preserves the node ordering of the source expression.</p></li><li><p>If multiple groups of nodes are inserted by multiple insert expressions 
in the same <a title="snapshot" href="#dt-snapshot">snapshot</a>, adjacency and ordering of nodes within each group is 
preserved but ordering among the groups is implementation-dependent.</p></li></ul></li><li><p>If <code>into</code> is specified without <code>as first</code> or <code>as last</code>:</p><ul><li><p>The inserted nodes become children of the target node.</p></li><li><p>If multiple nodes are inserted by a single insert expression, their 
order preserves the node ordering of the source expression.</p></li><li><p>The positions of the inserted nodes are chosen so as not to  interfere with the intended 
position of nodes that are inserted with the specification <code>before</code>, <code>after</code>, 
<code>as first into</code>, or <code>as last into</code>. For example, If node B is inserted "after node A", 
no other node will be inserted between nodes A and B unless it is also 
inserted "after node A".</p></li><li><p>Subject to the above constraints, the positions of the inserted nodes 
among the children of the target node are implementation-dependent.</p></li></ul></li></ul><p>Examples:</p><ul><li><p>Insert a <code>year</code> element after the publisher of the first book.</p><div class="exampleInner"><pre>insert node &lt;year&gt;2005&lt;/year&gt;
    after fn:doc("bib.xml")/books/book[1]/publisher</pre></div></li><li><p>Navigating by means of several bound variables, insert a new police report into the list of police reports for a particular accident.</p><div class="exampleInner"><pre>insert node $new-police-report
   as last into fn:doc("insurance.xml")/policies
      /policy[id = $pid]
      /driver[license = $license]
      /accident[date = $accdate]
      /police-reports</pre></div></li></ul><p>The semantics of an insert 
expression are as follows:</p><ol class="enumar"><li><p><a href="#doc-xquery-SourceExpr">SourceExpr</a> must be a <a title="simple expression" href="#dt-simple-expression">simple expression</a>; otherwise a static error is raised [<a href="#ERRXUST0001" title="err:XUST0001">err:XUST0001</a>]. <a href="#doc-xquery-SourceExpr">SourceExpr</a> is evaluated as though it were an enclosed 
expression in an element constructor (see Rule 1e in <a href="http://www.w3.org/TR/xquery/#id-content">Section 
3.7.1.3 Content</a><sup><small>XQ</small></sup>). The result of this step is either an error or a 
sequence of nodes to be inserted, called the <b>insertion sequence</b>. If the insertion sequence contains a document node, the document node is replaced in the insertion sequence by its children. If the insertion sequence contains an attribute node following a node that is not an attribute node, a type error is raised [<a href="#ERRXUTY0004" title="err:XUTY0004">err:XUTY0004</a>]. Let <code>$alist</code> be the sequence of attribute nodes in the insertion sequence. Let <code>$clist</code> be the remainder of the insertion sequence, in its original order.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Either <code>$alist</code> or <code>$clist</code> or both may be empty.</p></div></li><li><p>The target expression must be a <a title="simple expression" href="#dt-simple-expression">simple expression</a>; otherwise a static error is raised [<a href="#ERRXUST0001" title="err:XUST0001">err:XUST0001</a>]. The target expression is evaluated and checked as follows:</p><ol class="enumla"><li><p>If the result is an empty sequence, [<a href="#ERRXUDY0027" title="err:XUDY0027">err:XUDY0027</a>] is raised.</p></li><li><p>If any form of <code>into</code> is specified, 
the result must be a single element or document node; any other non-empty result raises a type error [<a href="#ERRXUTY0005" title="err:XUTY0005">err:XUTY0005</a>].</p></li><li><p>If <code>before</code> or <code>after</code> 
is specified, the result must be a single element, text, comment, or processing instruction node; any other non-empty result raises a type error  [<a href="#ERRXUTY0006" title="err:XUTY0006">err:XUTY0006</a>].</p></li><li><p>If <code>before</code> or <code>after</code> 
is specified, the node returned by the target expression must have a non-empty <code>parent</code> property [<a href="#ERRXUDY0029" title="err:XUDY0029">err:XUDY0029</a>].</p></li></ol><p>  Let 
<code>$target</code> be the  node returned by the target expression.</p></li><li><p>If <code>$alist</code> is not empty and any form of <code>into</code> is specified, the following checks are performed:</p><ol class="enumla"><li><p><code>$target</code> must be an element node [<a href="#ERRXUTY0022" title="err:XUTY0022">err:XUTY0022</a>].</p></li><li><p>No attribute node in <code>$alist</code> may have a QName whose
<a title="implied namespace binding" href="#dt-implied-namespace-binding">implied namespace
binding</a> <a title="conflict" href="#dt-conflict">conflicts</a> with
a namespace binding in the "namespaces" property of
<code>$target</code> [<a href="#ERRXUDY0023" title="err:XUDY0023">err:XUDY0023</a>], unless the
namespace prefix for the attribute is absent.</p></li><li><p>Multiple attribute nodes in <code>$alist</code> must not have QNames whose <a title="implied namespace binding" href="#dt-implied-namespace-binding">implied namespace bindings</a> <a title="conflict" href="#dt-conflict">conflict</a> with each other [<a href="#ERRXUDY0024" title="err:XUDY0024">err:XUDY0024</a>].</p></li></ol></li><li><p>If <code>$alist</code> is not empty and <code>before</code> or <code>after</code> is specified, the following checks are performed:</p><ol class="enumla"><li><p> <code>parent($target)</code> must be an element node [<a href="#ERRXUDY0030" title="err:XUDY0030">err:XUDY0030</a>].</p></li><li><p>No attribute node in <code>$alist</code> may have a QName whose <a title="implied namespace binding" href="#dt-implied-namespace-binding">implied namespace binding</a> <a title="conflict" href="#dt-conflict">conflicts</a> with a namespace binding in the "namespaces" property of <code>parent($target)</code> [<a href="#ERRXUDY0023" title="err:XUDY0023">err:XUDY0023</a>] unless the namespace prefix for the attribute is absent.</p></li><li><p>Multiple attribute nodes in <code>$alist</code> must not have QNames whose <a title="implied namespace binding" href="#dt-implied-namespace-binding">implied namespace bindings</a> <a title="conflict" href="#dt-conflict">conflict</a> with each other [<a href="#ERRXUDY0024" title="err:XUDY0024">err:XUDY0024</a>].</p></li></ol></li><li><p>The result of the insert expression is an empty <a title="XDM instance" href="#dt-xdm-instance">XDM instance</a> and a <a title="pending update list" href="#dt-pending-update-list">pending update list</a> constructed
as follows:</p><ol class="enumla"><li><p>If <code>as first into</code> is specified, the <a title="pending update list" href="#dt-pending-update-list">pending update list</a> consists of the following <a title="update primitive" href="#dt-update-primitive">update primitives</a>:</p><ol class="enumlr"><li><p>If <code>$alist</code> is not empty, <code><a href="#id-upd-insert-attributes">upd:insertAttributes</a>($target, $alist)</code></p></li><li><p>If <code>$clist</code> is not empty, <code><a href="#id-upd-insert-into-as-first">upd:insertIntoAsFirst</a>($target, $clist)</code></p></li></ol></li><li><p>If <code>as last into</code> is specified, the <a title="pending update list" href="#dt-pending-update-list">pending update list</a> consists of the following <a title="update primitive" href="#dt-update-primitive">update primitives</a>:</p><ol class="enumlr"><li><p>If <code>$alist</code> is not empty, <code><a href="#id-upd-insert-attributes">upd:insertAttributes</a>($target, $alist)</code></p></li><li><p>If <code>$clist</code> is not empty, <code><a href="#id-upd-insert-into-as-last">upd:insertIntoAsLast($target, $clist)</a></code></p></li></ol></li><li><p>If <code>into</code> is specified with neither <code>as first</code> nor <code>as last</code>, the <a title="pending update list" href="#dt-pending-update-list">pending update list</a> consists of the following <a title="update primitive" href="#dt-update-primitive">update primitives</a>:</p><ol class="enumlr"><li><p>If <code>$alist</code> is not empty, <code><a href="#id-upd-insert-attributes">upd:insertAttributes</a>($target, $alist)</code></p></li><li><p>If <code>$clist</code> is not empty, <code><a href="#id-upd-insert-into">upd:insertInto</a>($target, $clist)</code></p></li></ol></li><li><p>If <code>before</code> is specified, let <code>$parent</code> be the parent node of <code>$target</code>. The <a title="pending update list" href="#dt-pending-update-list">pending update list</a> consists of the following <a title="update primitive" href="#dt-update-primitive">update primitives</a>:</p><ol class="enumlr"><li><p>If <code>$alist</code> is not empty, <code><a href="#id-upd-insert-attributes">upd:insertAttributes</a>($parent, $alist)</code></p></li><li><p>If <code>$clist</code> is not empty, <code><a href="#id-upd-insert-before">upd:insertBefore($target, $clist)</a></code></p></li></ol></li><li><p>If <code>after</code> is specified, let <code>$parent</code> be the parent node of <code>$target</code>. The <a title="pending update list" href="#dt-pending-update-list">pending update list</a> consists of the following <a title="update primitive" href="#dt-update-primitive">update primitives</a>:</p><ol class="enumlr"><li><p>If <code>$alist</code> is not empty, <code><a href="#id-upd-insert-attributes">upd:insertAttributes</a>($parent, $alist)</code></p></li><li><p>If <code>$clist</code> is not empty, <code><a href="#id-upd-insert-after">upd:insertAfter</a>($target, $clist)</code></p></li></ol></li></ol></li></ol></div><div class="div3">
<h4><a name="id-delete" id="id-delete"/>2.4.2 Delete</h4>
<h5><a name="d8e1457" id="d8e1457"/></h5><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery-DeleteExpr" id="doc-xquery-DeleteExpr"/>[<small>144</small>]   </td><td><code><a href="#prod-xquery-DeleteExpr"><a href="#prod-xquery-DeleteExpr">DeleteExpr</a></a></code></td><td>   ::=   </td><td><code>"delete"  ("node"  |  "nodes")  <a href="#doc-xquery-TargetExpr">TargetExpr</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="noid_d4e1339.doc-xquery-_no-id" id="noid_d4e1339.doc-xquery-_no-id"/>[<small>148</small>]   </td><td><code>TargetExpr</code></td><td>   ::=   </td><td><code><a href="#doc-xquery-ExprSingle">ExprSingle</a></code></td></tr></tbody></table><p>A delete expression deletes zero or more nodes from an <a title="XDM instance" href="#dt-xdm-instance">XDM instance</a>. 
The keywords <code>node</code> and <code>nodes</code> may be used interchangeably, regardless of how many nodes are actually deleted. A delete expression is an <a title="updating expression" href="#dt-updating-expression">updating expression</a>.</p><p>Examples:</p><ul><li><p>Delete the last author of the first book in a given bibliography.</p><div class="exampleInner"><pre>delete node fn:doc("bib.xml")/books/book[1]/author[last()]</pre></div></li><li><p>Delete all email messages that are more than 365 days old.</p><div class="exampleInner"><pre>delete nodes /email/message
     [fn:currentDate() - date &gt; xs:dayTimeDuration("P365D")]</pre></div></li></ul><p>The semantics of a delete expression are as follows:
</p><ol class="enumar"><li><p>The target expression must be a <a title="simple expression" href="#dt-simple-expression">simple expression</a>; otherwise a static error is raised [<a href="#ERRXUST0001" title="err:XUST0001">err:XUST0001</a>]. The target expression is evaluated. The result must be a 
sequence of zero or more nodes; otherwise a type error is raised [<a href="#ERRXUTY0007" title="err:XUTY0007">err:XUTY0007</a>]. 
Let <code>$tlist</code> be the list of nodes returned by 
the target expression.</p></li><li><p>If any node in <code>$tlist</code> has no parent, 
<span class="diff-add"><!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>it is removed from <code>$tlist</code> (and is thus ignored in the following step).</span></span>
<span class="diff-del"><!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>the node is removed from <code>$tlist</code> (and is thus ignored in the following step)an implementation may (but is not required to) raise a dynamic error <span class="diff-del" title="">[<a href="#ERRXUDY0020" title="err:XUDY0020">err:XUDY0020</a>]</span>.
</span></span></p></li><li><p>A new <a title="pending update list" href="#dt-pending-update-list">pending update list</a> is created. For each node 
<code>$tnode</code> in <code>$tlist</code>, the following <a title="update primitive" href="#dt-update-primitive">update primitive</a> is appended  to the pending update list: <code>upd:delete($tnode)</code>. The resulting 
pending update list (together with an empty <a title="XDM instance" href="#dt-xdm-instance">XDM instance</a>)  is the result of the delete expression.</p></li></ol><div class="note"><p class="prefix"><b>Notes:</b></p><ul><li><p>Since node deletions do not become effective until the end of a <a title="snapshot" href="#dt-snapshot">snapshot</a>, they have no effect on variable bindings or on the set of available documents or collections within the current query.</p></li><li><p>The semantics of a delete expression are defined in terms of their effect on an  <a title="XDM instance" href="#dt-xdm-instance">XDM instance</a>: the deleted nodes are detached from their parents after completion of the current query. The effects of a delete expression on persistent storage are beyond the scope of this specification.</p></li></ul></div></div><div class="div3">
<h4><a name="id-replace" id="id-replace"/>2.4.3 Replace</h4>
<h5><a name="d8e1578" id="d8e1578"/></h5><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery-ReplaceExpr" id="doc-xquery-ReplaceExpr"/>[<small>145</small>]   </td><td><code><a href="#prod-xquery-ReplaceExpr"><a href="#prod-xquery-ReplaceExpr">ReplaceExpr</a></a></code></td><td>   ::=   </td><td><code>"replace"  ("value"  "of")?  "node"  <a href="#doc-xquery-TargetExpr">TargetExpr</a>  "with"  <a href="#doc-xquery-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="noid_d4e1449.doc-xquery-_no-id" id="noid_d4e1449.doc-xquery-_no-id"/>[<small>148</small>]   </td><td><code>TargetExpr</code></td><td>   ::=   </td><td><code><a href="#doc-xquery-ExprSingle">ExprSingle</a></code></td></tr></tbody></table><p>A replace expression is an <a title="updating expression" href="#dt-updating-expression">updating expression</a>. A replace expression has two forms, depending on whether <code>value of</code> 
is specified.</p><div class="div4">
<h5><a name="id-replacing-node" id="id-replacing-node"/>2.4.3.1 Replacing a Node</h5><p>If <code>value of</code> is not specified, a replace expression 
 replaces one node with a new sequence of zero or more nodes. The replacement nodes occupy the position in the node hierarchy that was formerly occupied by the node that was replaced. For this reason, an attribute node can be replaced only by zero or more attribute nodes, and an element, text, comment, or processing instruction node can be replaced only by zero or more element, text, comment, or processing instruction nodes.  Example:</p><ul><li><p>Replace the publisher of the first book with the publisher of the second book.</p><div class="exampleInner"><pre>replace node fn:doc("bib.xml")/books/book[1]/publisher
with fn:doc("bib.xml")/books/book[2]/publisher</pre></div></li></ul><p> The semantics of this form of replace expression are as follows:
</p><ol class="enumar"><li><p>The expression following the keyword <code>with</code> must be a <a title="simple expression" href="#dt-simple-expression">simple expression</a>; otherwise a static error is raised [<a href="#ERRXUST0001" title="err:XUST0001">err:XUST0001</a>]. This expression is evaluated as though it were an enclosed 
expression in an element constructor (see Rule 1e in <a href="http://www.w3.org/TR/xquery/#id-content">Section 
3.7.1.3 Content</a><sup><small>XQ</small></sup>). Let <code>$rlist</code> be the node sequence that results from this evaluation. If <code>$rlist</code> contains a document node, the document node is replaced in <code>$rlist</code> by its children.</p></li><li><p>The target expression must be a <a title="simple expression" href="#dt-simple-expression">simple expression</a>; otherwise a static error is raised [<a href="#ERRXUST0001" title="err:XUST0001">err:XUST0001</a>]. The target expression is evaluated and checked as follows:</p><ol class="enumla"><li><p>If the result is an empty sequence, [<a href="#ERRXUDY0027" title="err:XUDY0027">err:XUDY0027</a>] is raised.</p></li><li><p>If the result is non-empty and does not consist of a single element, attribute, text, comment, or processing instruction node, [<a href="#ERRXUTY0008" title="err:XUTY0008">err:XUTY0008</a>] is raised.</p></li><li><p>If the result consists of a node whose parent property is empty, [<a href="#ERRXUDY0009" title="err:XUDY0009">err:XUDY0009</a>] is raised.</p></li></ol><p>  Let 
<code>$target</code> be the  node returned by the target expression, and let <code>$parent</code> be its parent node.</p></li><li><p>If <code>$target</code> is an element, text, comment, or processing 
instruction node, then <code>$rlist</code> must consist exclusively of zero or more element, text, comment, or processing instruction nodes [<a href="#ERRXUTY0010" title="err:XUTY0010">err:XUTY0010</a>].</p></li><li><p>If <code>$target</code> is an attribute node, then:</p><ol class="enumla"><li><p> <code>$rlist</code> must consist exclusively of zero or more attribute nodes [<a href="#ERRXUTY0011" title="err:XUTY0011">err:XUTY0011</a>].</p></li><li><p>No attribute node in <code>$rlist</code> may have a QName whose <a title="implied namespace binding" href="#dt-implied-namespace-binding">implied namespace binding</a> <a title="conflict" href="#dt-conflict">conflicts</a> with a namespace binding in the "namespaces" property of <code>$parent</code> [<a href="#ERRXUDY0023" title="err:XUDY0023">err:XUDY0023</a>]
unless the namespace prefix for the attribute is absent.</p></li><li><p>Multiple attribute nodes in <code>$rlist</code> must not have QNames whose <a title="implied namespace binding" href="#dt-implied-namespace-binding">implied namespace bindings</a> <a title="conflict" href="#dt-conflict">conflict</a> with each other [<a href="#ERRXUDY0024" title="err:XUDY0024">err:XUDY0024</a>].</p></li></ol></li><li><p>The result of the replace expression is an empty <a title="XDM instance" href="#dt-xdm-instance">XDM instance</a> and a <a title="pending update list" href="#dt-pending-update-list">pending update list</a> consisting of the following <a title="update primitive" href="#dt-update-primitive">update primitive</a>:
<code><a href="#id-upd-replacenode">upd:replaceNode</a>($target, $rlist)</code></p></li></ol></div><div class="div4">
<h5><a name="id-replacing-node-value" id="id-replacing-node-value"/>2.4.3.2 Replacing the Value of a Node</h5><p>If <code>value of</code> is specified, 
a replace expression is used to modify the value of a node while preserving 
its <a title="node identity" href="#dt-node-identity">node identity</a>. Example:</p><ul><li><p>Increase the price of the first book by ten percent.</p><div class="exampleInner"><pre>replace value of node fn:doc("bib.xml")/books/book[1]/price
with fn:doc("bib.xml")/books/book[1]/price * 1.1</pre></div></li></ul><p>The semantics of this form of replace expression are as 
follows:
</p><ol class="enumar"><li><p>The expression following the keyword <code>with</code> must be a <a title="simple expression" href="#dt-simple-expression">simple expression</a>; otherwise a static error is raised [<a href="#ERRXUST0001" title="err:XUST0001">err:XUST0001</a>]. This expression is evaluated as though it were the content 
expression of a text node constructor (see  Section 3.7.3.4 of 
<a href="#xquery">[XQuery 1.0]</a>.) The result of this step, in the absence of errors, is 
either a single text node or an empty sequence. Let <code>$text</code> be the result of this step. 
</p></li><li><p>The target expression must be a <a title="simple expression" href="#dt-simple-expression">simple expression</a>; otherwise a static error is raised [<a href="#ERRXUST0001" title="err:XUST0001">err:XUST0001</a>]. The target expression is evaluated and checked as follows:</p><ol class="enumla"><li><p>If the result is an empty sequence, [<a href="#ERRXUDY0027" title="err:XUDY0027">err:XUDY0027</a>] is raised.</p></li><li><p>If the result is non-empty and does not consist of a single element, attribute, text, comment, or processing instruction node, [<a href="#ERRXUTY0008" title="err:XUTY0008">err:XUTY0008</a>] is raised.</p></li></ol><p>  Let 
<code>$target</code> be the  node returned by the target expression.</p></li><li><p>If <code>$target</code> is an element node, the result of the replace 
expression is an empty <a title="XDM instance" href="#dt-xdm-instance">XDM instance</a> and a <a title="pending update list" href="#dt-pending-update-list">pending update list</a> consisting of the following <a title="update primitive" href="#dt-update-primitive">update primitive</a>: <code><a href="#id-upd-replace-element-content">upd:replaceElementContent</a>($target, $text)</code></p></li><li><p>If <code>$target</code> is an attribute, text, comment, or processing 
instruction node, let <code>$string</code> be the string value of the text node 
constructed in Step 1. If Step 1 did not construct 
a text node, let <code>$string</code> be a zero-length string.

Then:</p><ol class="enumla"><li><p>If <code>$target</code> is a comment node, and <code>$string</code> contains two adjacent hyphens or ends with a hyphen,
a dynamic error is raised [<a href="#ERRXQDY0072" title="err:XQDY0072">err:XQDY0072</a>].</p></li><li><p>If <code>$target</code> is a processing instruction node, and <code>$string</code> contains the substring "<code>?&gt;</code>", a dynamic error is raised [<a href="#ERRXQDY0026" title="err:XQDY0026">err:XQDY0026</a>].</p></li><li><p>In the absence of errors, the result of a replace expression is an empty <a title="XDM instance" href="#dt-xdm-instance">XDM instance</a> and a <a title="pending update list" href="#dt-pending-update-list">pending update list</a> containing the following <a title="update primitive" href="#dt-update-primitive">update primitive</a>: 
<code><a href="#id-upd-replace-value">upd:replaceValue</a>($target, $string)</code>.</p></li></ol></li></ol></div></div><div class="div3">
<h4><a name="id-rename" id="id-rename"/>2.4.4 Rename</h4>
<h5><a name="d8e1886" id="d8e1886"/></h5><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery-RenameExpr" id="doc-xquery-RenameExpr"/>[<small>146</small>]   </td><td><code><a href="#prod-xquery-RenameExpr"><a href="#prod-xquery-RenameExpr">RenameExpr</a></a></code></td><td>   ::=   </td><td><code>"rename"  "node"  <a href="#doc-xquery-TargetExpr">TargetExpr</a>  "as"  <a href="#doc-xquery-NewNameExpr">NewNameExpr</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="noid_d4e1743.doc-xquery-_no-id" id="noid_d4e1743.doc-xquery-_no-id"/>[<small>148</small>]   </td><td><code>TargetExpr</code></td><td>   ::=   </td><td><code><a href="#doc-xquery-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-xquery-NewNameExpr" id="doc-xquery-NewNameExpr"/>[<small>149</small>]   </td><td><code><a href="#prod-xquery-NewNameExpr"><a href="#prod-xquery-NewNameExpr">NewNameExpr</a></a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-ExprSingle">ExprSingle</a></code></td></tr></tbody></table><p>A rename expression replaces the <code>name</code> property of a <a title="data model" href="#dt-data-model">data model</a> node with a 
new QName. A rename expression is an <a title="updating expression" href="#dt-updating-expression">updating expression</a>.</p><p>Examples:</p><ul><li><p>Rename the first <code>author</code> element of the first book to <code>principal-author</code>.</p><div class="exampleInner"><pre>rename node fn:doc("bib.xml")/books/book[1]/author[1]
as "principal-author"</pre></div></li><li><p>Rename the first <code>author</code> element of the first book to the QName that is the value of the variable <code>$newname</code>.</p><div class="exampleInner"><pre>rename node fn:doc("bib.xml")/books/book[1]/author[1]
as $newname</pre></div></li></ul><p>The semantics of a rename expression are as follows:</p><ol class="enumar"><li><p>The target expression must be a <a title="simple expression" href="#dt-simple-expression">simple expression</a>; otherwise a static error is raised [<a href="#ERRXUST0001" title="err:XUST0001">err:XUST0001</a>]. The target expression is evaluated and checked as follows:</p><ol class="enumla"><li><p>If the result is an empty sequence, [<a href="#ERRXUDY0027" title="err:XUDY0027">err:XUDY0027</a>] is raised.</p></li><li><p>If the result is non-empty and does not consist of a single element, attribute, or processing instruction node, [<a href="#ERRXUTY0012" title="err:XUTY0012">err:XUTY0012</a>] is raised.</p></li></ol><p>  Let 
<code>$target</code> be the  node returned by the target expression.</p></li><li><p><a href="#doc-xquery-NewNameExpr">NewNameExpr</a> must be a <a title="simple expression" href="#dt-simple-expression">simple expression</a>; otherwise a static error is raised [<a href="#ERRXUST0001" title="err:XUST0001">err:XUST0001</a>]. <a href="#doc-xquery-NewNameExpr">NewNameExpr</a> is 
processed as follows:</p><ol class="enumla"><li><p>If <code>$target</code> is an element node, let <code>$QName</code> be the result of evaluating
<a href="#doc-xquery-NewNameExpr">NewNameExpr</a> as though it were the name expression of a computed element
constructor  (see <a href="http://www.w3.org/TR/xquery/#id-computedElements">Section 
3.7.3.1 Computed Element Constructors</a><sup><small>XQ</small></sup>). If the namespace binding of <code>$QName</code>
conflicts with any namespace binding in the <code>namespaces</code> property of <code>$target</code>, a
dynamic error is raised [<a href="#ERRXUDY0023" title="err:XUDY0023">err:XUDY0023</a>].</p></li><li><p>If <code>$target</code> is an attribute node, let <code>$QName</code> be the result of evaluating
<a href="#doc-xquery-NewNameExpr">NewNameExpr</a> as though it were the name expression of a computed attribute
constructor (see <a href="http://www.w3.org/TR/xquery/#id-computedAttributes">Section 
3.7.3.2 Computed Attribute
   Constructors</a><sup><small>XQ</small></sup>). If <code>$QName</code> has a non-absent namespace URI, and if the namespace binding of <code>$QName</code>
conflicts with any namespace binding in the <code>namespaces</code> property of the parent
(if any) of <code>$target</code>, a dynamic error is raised [<a href="#ERRXUDY0023" title="err:XUDY0023">err:XUDY0023</a>].</p></li><li><p>If <code>$target</code> is a processing instruction node, let <code>$NCName</code> be the result of
evaluating <a href="#doc-xquery-NewNameExpr">NewNameExpr</a> as though it were the name expression of a computed
processing instruction constructor (see <a href="http://www.w3.org/TR/xquery/#id-computed-pis">Section 
3.7.3.5 Computed Processing Instruction Constructors</a><sup><small>XQ</small></sup>), and let <code>$QName</code> be
defined as <code>fn:QName((), $NCName)</code>.</p></li></ol></li><li><p>The result of the rename expression is an empty <a title="XDM instance" href="#dt-xdm-instance">XDM instance</a> and a <a title="pending update list" href="#dt-pending-update-list">pending update list</a> 
containing the following <a title="update primitive" href="#dt-update-primitive">update primitive</a>: 
<code><a href="#id-upd-rename">upd:rename</a>($target, $QName)</code>.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>The effects of a rename expression are limited to its target node. Attributes and descendants of the target node are not affected. If a global change of names or namespaces is intended, some form of explicit iteration must be used. The following example illustrates such a global change. The example operates on the node bound to variable <code>$root</code> and all its attributes and descendants, changing all QNames with the prefix <code>abc</code> to have a new prefix <code>xyz</code> and a new namespace URI <code>http://xyz/ns</code>.
</p><div class="exampleInner"><pre>for $node in $root//abc:*
let $localName := fn:local-name($node),
    $newQName := fn:concat("xyz:", $localName)
return (
   rename node $node as fn:QName("http://xyz/ns", $newQName),
   for $attr in $node/@abc:*
   let $attrLocalName := fn:local-name($attr),
       $attrNewQName := fn:concat("xyz:", $attrLocalName)
   return
      rename node $attr as fn:QName("http://xyz/ns", $attrNewQName)
)</pre></div></div></div><div class="div3">
<h4><a name="id-transform" id="id-transform"/>2.4.5 Transform</h4>
<h5><a name="d8e2100" id="d8e2100"/></h5><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery-TransformExpr" id="doc-xquery-TransformExpr"/>[<small>150</small>]   </td><td><code><a href="#prod-xquery-TransformExpr"><a href="#prod-xquery-TransformExpr">TransformExpr</a></a></code></td><td>   ::=   </td><td><code>"copy"  "$"  <a href="#prod-xquery-VarName">VarName</a>  ":="  <a href="#doc-xquery-ExprSingle">ExprSingle</a>  (","  "$"  <a href="#prod-xquery-VarName">VarName</a>  ":="  <a href="#doc-xquery-ExprSingle">ExprSingle</a>)*  "modify"  <a href="#doc-xquery-ExprSingle">ExprSingle</a>  "return"  <a href="#doc-xquery-ExprSingle">ExprSingle</a></code></td></tr></tbody></table><p>A transform expression can be used to create modified copies of existing nodes in an <a title="XDM instance" href="#dt-xdm-instance">XDM instance</a>. Each node created by a transform expression has a new <a title="node identity" href="#dt-node-identity">node identity</a>. The result of a transform expression is an <a title="XDM instance" href="#dt-xdm-instance">XDM instance</a> that may include both nodes that were created by the transform expression and other, previously existing nodes. A transform expression is a <a title="simple expression" href="#dt-simple-expression">simple expression</a> because it does not modify the value of any existing nodes.</p><p>Examples:</p><ul><li><p>Return a sequence consisting of all <code>employee</code> elements that have Java as a skill, excluding their <code>salary</code> child-elements:</p><div class="exampleInner"><pre>for $e in //employee[skill = "Java"]
return 
   copy $je := $e
   modify delete node $je/salary
   return $je</pre></div></li><li><p>The following example copies a node, modifies the copy, and returns both the original node and the modified copy:</p><div class="exampleInner"><pre>let $oldx := /a/b/x
return
   copy $newx := $oldx
   modify (rename node $newx as "newx", 
           replace value of node $newx with $newx * 2)
   return ($oldx, $newx)
</pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>No persistent changes to the underlying data result from this example.</p></div></li></ul><p>A transform expression consists of three clauses, denoted by the keywords <code>copy</code>, <code>modify</code>, and <code>return</code>. The semantics of a transform expression are as follows:</p><ol class="enumar"><li><p>The <code>copy</code> clause contains one or more variable bindings, each of which consists of a variable name and an expression called the <b>source expression</b>. Each variable binding is processed as follows:</p><ol class="enumla"><li><p>The source expression must be a <a title="simple expression" href="#dt-simple-expression">simple expression</a>; otherwise a static error is raised [<a href="#ERRXUST0001" title="err:XUST0001">err:XUST0001</a>].</p></li><li><p>The result of evaluating the source expression must be a single node [<a href="#ERRXUTY0013" title="err:XUTY0013">err:XUTY0013</a>]. Let <code>$node</code> be this single node.</p></li><li><p>A new copy is made of <code>$node</code> and all nodes that have <code>$node</code> as an ancestor,
collectively referred to as <b>copied nodes</b>. Each copied node receives a new node
identity. The <code>parent</code>, <code>children</code>, and <code>attributes</code> properties of the copied nodes
are set so as to preserve their inter-node relationships. 

<span class="diff-add"><!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>The parent property of the copy of <code>$node</code> is set
to empty.</span></span>

Other properties of the copied nodes are determined as follows:</p><ol class="enumlr"><li><p>For a copied element node, the <code>type-name</code> property is set to <code>xs:untyped</code>,
and the <code>nilled</code>, <code>is-id</code>, and <code>is-idrefs</code> properties are set to <code>false</code>.</p></li><li><p>For a copied attribute node, the <code>type-name</code> property is set to
<code>xs:untypedAtomic</code> and the <code>is-idrefs</code> property is set to <code>false</code>. The <code>is-id</code> property
is set to <code>true</code> if the qualified name of the attribute node is <code>xml:id</code>; otherwise
it is set to <code>false</code>.</p></li><li><p>The string value of each copied element and attribute node remains
unchanged, and its typed value becomes equal to its string value as an instance
of <code>xs:untypedAtomic</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Implementations that store only the typed value of a
node are required at this point to convert the typed value to a string form.</p></div></li><li><p>If <code>copy-namespaces mode</code> in the static context specifies <code>preserve</code>, all in-scope-namespaces of the original element are
retained in the new copy. If <code>copy-namespaces</code> mode specifies <code>no-preserve</code>, the new copy retains only those in-scope namespaces of the original element that are used in the names of the element and its
     attributes.</p></li><li><p>All other properties of the copied nodes are preserved.</p></li></ol></li><li><p>The variable name is bound to the top-level copied node generated in the
previous step. The scope of this variable binding includes all subexpressions
of the containing transform expression that appear after the variable binding
clause, including the source expressions of later variable bindings, but it
does not include the source expression to which the current variable name is
bound.</p></li></ol></li><li><p>The <code>modify</code> clause must

<span class="diff-add"><!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>contain an <a title="updating expression" href="#dt-updating-expression">updating expression</a> or a <a title="vacuous expression" href="#dt-vacuous-expression">vacuous expression</a>
</span></span>

<span class="diff-del"><!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>contain either an <a title="updating expression" href="#dt-updating-expression">updating expression</a>, an empty expression <code>( )</code>, or a call to the <code>fn:error</code> function</span></span>; 

otherwise a static error is raised [<a href="#ERRXUST0002" title="err:XUST0002">err:XUST0002</a>]. The  expression in the <code>modify</code> clause is evaluated, resulting in a <a title="pending update list" href="#dt-pending-update-list">pending update list</a>. If the <a title="target node" href="#dt-target-node">target node</a> of any <a title="update primitive" href="#dt-update-primitive">update primitive</a> on this pending update list is a node that was not newly created in Step 1, a dynamic error is raised [<a href="#ERRXUDY0014" title="err:XUDY0014">err:XUDY0014</a>]. <span class="diff-del"><!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>Let <code>$pul</code> be the pending update list generated by this step.</span></span></p></li><li><p><span class="diff-add"><!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>Let <code>$pul</code> be the pending update list generated by the previous step.</span></span> Let <code>$revalidation-mode</code> be the value of
the revalidation mode in the static context of the transform expression. <span class="diff-add"><!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>Let <code>$inherit-namespaces</code> be <code>true</code> if the <code>copy-namespaces</code> mode specifies <code>inherit</code>, or <code>false</code> if the 
<code>copy-namespaces</code> mode specifies <code>no-inherit</code>.</span></span> The following <a title="update operation" href="#dt-update-operation">update operation</a> is invoked: <code><a href="#id-upd-apply-updates">upd:applyUpdates</a>($pul, $revalidation-mode<span class="diff-add"><!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>, $inherit-namespaces</span></span>)</code>. The effect of this operation is to make the updates specified in the <code>modify</code> clause effective on the copied nodes.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In the event of incompatible updates, the <a href="#id-upd-apply-updates">upd:applyUpdates</a> operation may raise an error, as described in <a href="#id-upd-apply-updates"><b>[3.2.2 upd:applyUpdates]</b></a>.</p></div></li><li><p>The <code>return</code> clause must contain a <a title="simple expression" href="#dt-simple-expression">simple expression</a>; otherwise a static error is raised [<a href="#ERRXUST0001" title="err:XUST0001">err:XUST0001</a>]. The <code>return</code> clause is evaluated, and its result is the result of the transform expression. During evaluation of the <code>return</code> clause, changes applied to copied nodes by the preceding step are visible.</p></li></ol></div><div class="div3">
<h4><a name="id-compatibility" id="id-compatibility"/>2.4.6 Compatibility of Updating Expressions</h4><p>The rules defining compatibility of <a title="updating expression" href="#dt-updating-expression">updating expressions</a> within a <a title="snapshot" href="#dt-snapshot">snapshot</a> are defined in <a href="#id-upd-apply-updates"><b>[3.2.2 upd:applyUpdates]</b></a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The effect of these rules is as follows:</p><ol class="enumar"><li><p>If any node is affected by more than one <code>rename</code> expression within a  <a title="snapshot" href="#dt-snapshot">snapshot</a>, a dynamic error is raised [<a href="#ERRXUDY0015" title="err:XUDY0015">err:XUDY0015</a>].</p></li><li><p>If any node is affected by more than one <code>replace</code> expression (without <code>value of</code> being specified) within a  <a title="snapshot" href="#dt-snapshot">snapshot</a>, a dynamic error is raised [<a href="#ERRXUDY0016" title="err:XUDY0016">err:XUDY0016</a>].</p></li><li><p>If any node is affected by more than one <code>replace value of</code> expression within a  <a title="snapshot" href="#dt-snapshot">snapshot</a>, a dynamic error is raised [<a href="#ERRXUDY0017" title="err:XUDY0017">err:XUDY0017</a>].</p></li><li><p>If multiple calls to <code>fn:put</code> operate on the same URI in the same <a title="snapshot" href="#dt-snapshot">snapshot</a>, a dynamic error is raised [<a href="#ERRXUDY0031" title="err:XUDY0031">err:XUDY0031</a>].</p></li><li><p>Within a given <a title="snapshot" href="#dt-snapshot">snapshot</a>, if an element node <code>E</code> is the target of a <code>replace value of</code> expression, and the children of <code>E</code> are also modified by other expressions, the final children of <code>E</code> are determined by the <code>replace value of</code> expression. For example:</p><ul><li><p>Suppose that <code>$A</code> is bound to an element node that has a child element named <code>B</code>. Suppose that the following expressions are evaluated in the same <a title="snapshot" href="#dt-snapshot">snapshot</a>:</p><div class="exampleInner"><pre>replace node $A/B with &lt;C&gt;Hello&lt;/C&gt;,
replace value of node $A with &lt;D&gt;Goodbye&lt;/D&gt;</pre></div><p>The expressions on the left and right side of the comma can be evaluated in any order. No error is raised. At the end of the <a title="snapshot" href="#dt-snapshot">snapshot</a>, the children of <code>$A</code> will consist of a single text node with the content <code>"Goodbye"</code>.</p></li></ul></li></ol></div></div></div><div class="div2">
<h3><a name="id-extensions-to-existing" id="id-extensions-to-existing"/>2.5 Extensions to Existing Expressions</h3><p>XQuery Update Facility 1.0 provides extensions to the semantics of several existing kinds of XQuery expressions, as specified in this section.</p><div class="div3">
<h4><a name="id-flwor-expr" id="id-flwor-expr"/>2.5.1 FLWOR Expression</h4><p>The syntax of the FLWOR expression is not changed. Its semantics are extended as follows:</p><ol class="enumar"><li><p>If a <code>for</code>,
<code>let</code>, <code>where</code>, or <code>order by</code>
clause contains an <a title="updating expression" href="#dt-updating-expression">updating expression</a>, a static error is raised [<a href="#ERRXUST0001" title="err:XUST0001">err:XUST0001</a>].</p></li><li><p>The <code>return</code> clause may contain any category of expression. The category of the FLWOR expression is the same as the category of the expression in its <code>return</code> clause (simple, vacuous, or updating.)</p></li><li><p>If the <code>return</code> clause contains a <a title="simple expression" href="#dt-simple-expression">simple expression</a>, the semantics of the FLWOR expression  are as specified in <a href="http://www.w3.org/TR/xquery/#id-flwor-expressions">Section 
3.8 FLWOR Expressions</a><sup><small>XQ</small></sup>.</p></li><li><p>If the <code>return</code> clause contains an <a title="updating expression" href="#dt-updating-expression">updating expression</a>, the semantics of the FLWOR expression are as follows:</p><ol class="enumla"><li><p>The semantics of the <code>for</code>,
<code>let</code>, <code>where</code>, and <code>order by</code>
clauses are as specified in <a href="http://www.w3.org/TR/xquery/#id-flwor-expressions">Section 
3.8 FLWOR Expressions</a><sup><small>XQ</small></sup>. These clauses generate a stream of tuples of bound
variables.</p></li><li><p>For each tuple
generated by the previous step, the updating expression in the
<code>return</code> clause is evaluated, resulting in a <a title="pending update list" href="#dt-pending-update-list">pending update list</a>.</p></li><li><p>All the <a title="pending update list" href="#dt-pending-update-list">pending update lists</a> generated by the
previous step are merged by successive invocations of the <code><a href="#id-upd-merge-updates">upd:mergeUpdates</a></code>
operation. The resulting merged pending update list is the
result of the FLWOR expression.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In the event of incompatible updates, the <code><a href="#id-upd-merge-updates">upd:mergeUpdates</a></code> operation may raise an error, as described in <a href="#id-upd-merge-updates"><b>[3.2.1 upd:mergeUpdates]</b></a>.</p></div></li></ol></li></ol><p>The following example illustrates the use of an updating expression in a FLWOR expression:</p><ul><li><p>Update an inventory of parts according to a set of changes provided in the bound variable <code>$changes</code>. Both <code>/inventory</code> and <code>$changes</code> contain a set of <code>part</code> elements, each with a <code>partno</code> and a <code>quantity</code>.</p><div class="exampleInner"><pre>for $p in /inventory/part
let $deltap := $changes/part[partno eq $p/partno]
return 
    replace value of node $p/quantity
    with $p/quantity + $deltap/quantity</pre></div></li></ul></div><div class="div3">
<h4><a name="id-typeswitch-expr" id="id-typeswitch-expr"/>2.5.2 Typeswitch Expression</h4><p>The syntax of the typeswitch expression is not changed. Its semantics are extended as
follows. Let the expressions in the  <code>case</code>  and <code>default</code> clauses be called <b>branches</b>. Then:
</p><ol class="enumar"><li><p>If the operand expression of a typeswitch is an <a title="updating expression" href="#dt-updating-expression">updating expression</a>, a static error is raised [<a href="#ERRXUST0001" title="err:XUST0001">err:XUST0001</a>].</p></li><li><p>If any branch is an <a title="updating expression" href="#dt-updating-expression">updating expression</a>, then all branches must be <a title="updating expression" href="#dt-updating-expression">updating</a> or <a title="vacuous expression" href="#dt-vacuous-expression">vacuous expressions</a> [<a href="#ERRXUST0001" title="err:XUST0001">err:XUST0001</a>].  In this case, the typeswitch expression is an <a title="updating expression" href="#dt-updating-expression">updating expression</a>.</p></li><li><p>If all branches are <a title="vacuous expression" href="#dt-vacuous-expression">vacuous expressions</a>, the typeswitch expression is a <a title="vacuous expression" href="#dt-vacuous-expression">vacuous expression</a>.</p></li><li><p>Otherwise, the typeswitch expression is a <a title="simple expression" href="#dt-simple-expression">simple expression</a>.</p></li><li><p>If the typeswitch expression is a <a title="simple expression" href="#dt-simple-expression">simple</a> (including <a title="vacuous expression" href="#dt-vacuous-expression">vacuous</a>) expression, its semantics are as specified in <a href="http://www.w3.org/TR/xquery/#id-typeswitch">Section 
3.12.2 Typeswitch</a><sup><small>XQ</small></sup>.</p></li><li><p>If the typeswitch expression is an <a title="updating expression" href="#dt-updating-expression">updating expression</a>, then  selection of the effective case and
binding of variables are performed as specified in <a href="http://www.w3.org/TR/xquery/#id-typeswitch">Section 
3.12.2 Typeswitch</a><sup><small>XQ</small></sup>. The  expression in the <code>return</code>
clause of the effective case (or default) is then evaluated, resulting
in a <a title="pending update list" href="#dt-pending-update-list">pending update list</a>, which serves as the result of
the typeswitch expression.</p></li></ol></div><div class="div3">
<h4><a name="id-conditional-expr" id="id-conditional-expr"/>2.5.3 Conditional Expression</h4><p>The semantics of
conditional expressions are extended as follows.
Let the expressions in the  <code>then</code>  and <code>else</code> clauses be called <b>branches</b>. Then:
</p><ol class="enumar"><li><p>If the if-clause contains an <a title="updating expression" href="#dt-updating-expression">updating expression</a>, a static error is raised [<a href="#ERRXUST0001" title="err:XUST0001">err:XUST0001</a>].</p></li><li><p>If either branch is an <a title="updating expression" href="#dt-updating-expression">updating expression</a>, then both branches must be <a title="updating expression" href="#dt-updating-expression">updating</a> or <a title="vacuous expression" href="#dt-vacuous-expression">vacuous expressions</a> [<a href="#ERRXUST0001" title="err:XUST0001">err:XUST0001</a>].  In this case, the conditional expression is an <a title="updating expression" href="#dt-updating-expression">updating expression</a>.</p></li><li><p>If both branches are <a title="vacuous expression" href="#dt-vacuous-expression">vacuous expressions</a>, the conditional expression is a <a title="vacuous expression" href="#dt-vacuous-expression">vacuous expression</a>.</p></li><li><p>Otherwise, the conditional expression is a <a title="simple expression" href="#dt-simple-expression">simple expression</a>.</p></li><li><p>If the conditional expression is a <a title="simple expression" href="#dt-simple-expression">simple</a> (including <a title="vacuous expression" href="#dt-vacuous-expression">vacuous</a>) expression, its semantics are as specified in <a href="http://www.w3.org/TR/xquery/#id-conditionals">Section 
3.10 Conditional Expressions</a><sup><small>XQ</small></sup>.</p></li><li><p>If the conditional expression is an <a title="updating expression" href="#dt-updating-expression">updating expression</a>, then  selection of the effective branch performed as specified in <a href="http://www.w3.org/TR/xquery/#id-conditionals">Section 
3.10 Conditional Expressions</a><sup><small>XQ</small></sup>. The result of the conditional expression is
the <a title="pending update list" href="#dt-pending-update-list">pending update list</a> returned by the
selected branch.</p></li></ol><p>The following example illustrates the use of updating expressions in a conditional expression:</p><ul><li><p>If the element bound to variable <code>$e</code> has a <code>last-updated</code> attribute, update its value to the current date; otherwise insert such an attribute.</p><div class="exampleInner"><pre>if ($e/@last-updated)
then replace value of node 
        $e/last-updated with fn:currentDate()
else insert node 
        attribute last-updated {fn:currentDate()} into $e</pre></div></li></ul></div><div class="div3">
<h4><a name="id-comma-expr" id="id-comma-expr"/>2.5.4 Comma Expression</h4><p>The semantics of
comma expressions (composed of one or more expressions concatenated by the comma operator, as described in <a href="http://www.w3.org/TR/xquery/#construct_seq">Section 
3.3.1 Constructing Sequences</a><sup><small>XQ</small></sup>) are extended as follows:
</p><ol class="enumar"><li><p>If any operand is an <a title="updating expression" href="#dt-updating-expression">updating expression</a>, then all operands must be <a title="updating expression" href="#dt-updating-expression">updating</a> or <a title="vacuous expression" href="#dt-vacuous-expression">vacuous expressions</a> [<a href="#ERRXUST0001" title="err:XUST0001">err:XUST0001</a>].  In this case, the comma expression is an <a title="updating expression" href="#dt-updating-expression">updating expression</a>.</p></li><li><p>If all operands are <a title="vacuous expression" href="#dt-vacuous-expression">vacuous expressions</a>, the comma expression is a <a title="vacuous expression" href="#dt-vacuous-expression">vacuous expression</a>.</p></li><li><p>Otherwise, the comma expression is a <a title="simple expression" href="#dt-simple-expression">simple expression</a>.</p></li><li><p>If the comma expression is a <a title="simple expression" href="#dt-simple-expression">simple</a> (including <a title="vacuous expression" href="#dt-vacuous-expression">vacuous</a>) expression, its semantics are as specified in <a href="http://www.w3.org/TR/xquery/#construct_seq">Section 
3.3.1 Constructing Sequences</a><sup><small>XQ</small></sup>.</p></li><li><p>If the comma expression is an <a title="updating expression" href="#dt-updating-expression">updating expression</a>, its operand expressions are evaluated (in any order), and the <a title="pending update list" href="#dt-pending-update-list">pending update lists</a>
returned by the operand expressions are merged by the <code><a href="#id-upd-merge-updates">upd:mergeUpdates</a></code>
operation. The resulting merged <a title="pending update list" href="#dt-pending-update-list">pending update list</a> is the result of the comma expression.</p></li></ol><p>The following example illustrates the use of an updating comma expression:</p><ul><li><p>This example makes the value of an element empty and gives the element an <code>xsi:nil="true"</code> attribute. Both of these operations may be necessary in order to preserve the validity of the element.</p><div class="exampleInner"><pre>let $q := /inventory/item[serialno = "123456"]/quantity
return
   ( replace value of node $q with ( ),
     insert node attribute xsi:nil {"true"} into $q )</pre></div></li></ul></div><div class="div3">
<h4><a name="id-parenthesized-expr" id="id-parenthesized-expr"/>2.5.5 Parenthesized Expression</h4><p>The semantics of a parenthesized expression (any XQuery expression enclosed in parentheses) are extended as follows:</p><p>The category of a parenthesized expression is the same as the category of the expression enclosed in parentheses, which may have any category. The result of a parenthesized expression is also the same as the result of the expression enclosed in parentheses. </p><p>An empty parenthesized expression <code>( )</code> is a <a title="vacuous expression" href="#dt-vacuous-expression">vacuous expression</a>. Its result is an empty sequence and an empty <a title="pending update list" href="#dt-pending-update-list">pending update list</a>.</p></div><div class="div3">
<h4><a name="id-function-call" id="id-function-call"/>2.5.6 Function Call</h4><p>The semantics of a function call are extended as follows:</p><p>The function call is evaluated as specified in Section 3.1.5 of <a href="#xquery">[XQuery 1.0]</a>. If any input parameter of the function  call is an <a title="updating expression" href="#dt-updating-expression">updating expression</a>, a static error is raised [<a href="#ERRXUST0001" title="err:XUST0001">err:XUST0001</a>].</p><p>The expression category of a function call is as follows:</p><ul><li><p>A call to the built-in function <code>fn:error</code> is a <a title="vacuous expression" href="#dt-vacuous-expression">vacuous expression</a>.</p></li><li><p>A call to an <a title="updating function" href="#dt-updating-function">updating function</a> is an <a title="updating expression" href="#dt-updating-expression">updating expression</a>.</p></li><li><p>A call to any other function is a <a title="simple expression" href="#dt-simple-expression">simple expression</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This includes calls to built-in functions other than <code>fn:error</code> and calls to user-defined functions that were not declared to be <code>updating</code>.</p></div></li></ul></div><div class="div3">
<h4><a name="id-other-expr" id="id-other-expr"/>2.5.7 Other Expressions</h4><p>The semantics of all XQuery expressions other than FLWOR expressions, 
typeswitch expressions, conditional expressions, comma expressions, 
parenthesized expressions, and function calls are extended as follows:</p><p>If any operand of this expression is an <a title="updating expression" href="#dt-updating-expression">updating expression</a>, a static error is raised [<a href="#ERRXUST0001" title="err:XUST0001">err:XUST0001</a>].</p><div class="diff-del"><p>In addition, the initializing expression of a variable declaration in a Prolog must not be an <a title="updating expression" href="#dt-updating-expression">updating expression</a> [<a href="#ERRXUST0001" title="err:XUST0001">err:XUST0001</a>].</p></div></div></div><div class="div2">
<h3><a name="id-new-functions" id="id-new-functions"/>2.6 Extensions to Built-in Function Library</h3><p>XQuery Update Facility 1.0 provides extensions to XQuery built-in function library, as specified in this
  section.</p><div class="div3">
<h4><a name="id-func-put" id="id-func-put"/>2.6.1 fn:put</h4><div class="proto"><code class="function">fn:put</code>(<code class="arg">$node</code><code class="as"> as </code><code class="type">node()</code>, <code class="arg">$uri</code><code class="as"> as </code><code class="type">xs:string</code>)<code class="as"> as </code><code class="return-type">empty-sequence()</code></div><p><b>Summary:</b> Stores  a document or element to the location specified by <code>$uri</code>.
This function is normally invoked to create
a resource on an external storage system such as a file system or a
database.</p><p>The external effects of <code>fn:put</code> are implementation-defined,
since they occur outside the domain of XQuery. The intent is that, if <code>fn:put</code> is invoked on a document node and no error is raised, a
subsequent query can access the stored document by invoking
<code>fn:doc</code> with the same URI.</p><p><b>Semantics:</b></p><ol class="enumar"><li><p><code>fn:put</code> is an updating function.</p></li><li><p>If <code>$node</code> is not a document node or an element node, and the implementation does not support <code>fn:put</code> on the given node kind, a dynamic error is
raised [<a href="#ERRFOUP0001" title="err:FOUP0001">err:FOUP0001</a>].</p></li><li><p>If
<code>$uri</code> is not a valid lexical representation of the <code>xs:anyURI</code> type, a dynamic error is
raised [<a href="#ERRFOUP0002" title="err:FOUP0002">err:FOUP0002</a>]. If <code>$uri</code> is a relative URI reference, it is resolved
relative to the value of the base URI property in the static
context.</p></li><li><p>The result of a call to <code>fn:put</code> is an empty <a title="XDM instance" href="#dt-xdm-instance">XDM instance</a> and a <a title="pending update list" href="#dt-pending-update-list">pending update list</a> 
containing the following <a title="update primitive" href="#dt-update-primitive">update primitive</a>: 
<code><a href="#id-upd-put">upd:put</a>($node, $uri)</code>.</p></li></ol><div class="note"><p class="prefix"><b>Notes:</b></p><ul><li><p>The results of <code>fn:put</code> do not become effective until after completion of the current <a title="snapshot" href="#dt-snapshot">snapshot</a>. The <code>fn:put</code> function has no effect on the set of available documents or collections seen by the current <a title="snapshot" href="#dt-snapshot">snapshot</a>.</p></li><li><p>If a node that is an operand of <code>fn:put</code> is affected by updating expressions in the current <a title="snapshot" href="#dt-snapshot">snapshot</a>, the <code>fn:put</code> function operates on the node after these updating expressions are made effective. As a result, after completion of the current <a title="snapshot" href="#dt-snapshot">snapshot</a>, the effects of updates to <code>$node</code> can be seen via <code>$uri</code>. (For details on application of updates, see <a href="#id-upd-apply-updates"><b>[3.2.2 upd:applyUpdates]</b></a>.)</p></li><li><p>If multiple calls to <code>fn:put</code> in the same <a title="snapshot" href="#dt-snapshot">snapshot</a> operate on the same URI (after any necessary resolution of relative URIs), a dynamic error [<a href="#ERRXUDY0031" title="err:XUDY0031">err:XUDY0031</a>] is raised. The dynamic error is raised by an expression at some level of the query that contains more than one call to <code>fn:put</code>. For a normative description of this error, see <a href="#id-upd-merge-updates"><b>[3.2.1 upd:mergeUpdates]</b></a> and <a href="#id-upd-apply-updates"><b>[3.2.2 upd:applyUpdates]</b></a>.</p></li></ul></div></div></div></div><div class="div1">
<h2><a name="id-update-operations" id="id-update-operations"/>3 Update Operations</h2><p>This section describes the update operations defined by XQuery Update Facility 1.0. Although these update operations are described using a functional notation, they are not true functions because many of them have no return value. These update operations are used in defining the semantics of XQuery expressions, but they are not directly available to users.</p><p>Update operations consist of <a title="update primitive" href="#dt-update-primitive">update primitives</a>, which are the components of <a title="pending update list" href="#dt-pending-update-list">pending update lists</a>, and <a title="update routine" href="#dt-update-routine">update routines</a>, which are used in defining XQuery semantics but do not appear on <a title="pending update list" href="#dt-pending-update-list">pending update lists</a>.</p><div class="div2">
<h3><a name="id-update-primitives" id="id-update-primitives"/>3.1 Update Primitives</h3><p>The update primitives described in this section may be held on <a title="pending update list" href="#dt-pending-update-list">pending update lists</a>. When an update primitive is held on a pending update list, its node operands are represented by their <a title="node identity" href="#dt-node-identity">node identities</a>. The semantics of an update primitive do not become effective until their pending update list is processed by the  <code>upd:applyUpdates</code> routine.</p><div class="div3">
<h4><a name="id-upd-insert-before" id="id-upd-insert-before"/>3.1.1 upd:insertBefore</h4><dl><dt class="label"><dt class="label">Parameters</dt></dt><dd><div class="exampleInner"><pre>upd:insertBefore(
   $target as node(),
   $content as node()+)</pre></div></dd><dt class="label"><dt class="label">Summary</dt></dt><dd><p>Inserts <code>$content</code> immediately before <code>$target</code>.</p></dd><dt class="label"><dt class="label">Constraints</dt></dt><dd><p><code>$target</code> must be an element, text, processing
									instruction, or comment node with a non-empty <code>parent</code> property. <code>$content</code> must be a sequence containing only element, text, processing instruction,
									and comment nodes.</p></dd><dt class="label"><dt class="label">Semantics</dt></dt><dd><ol class="enumar"><li><p>Effects on nodes in <code>$content</code>:</p><ol class="enumla"><li><p>For each node in <code>$content</code>, the <code>parent</code> property is set to <code>parent($target)</code>.</p></li><li><p>If the <code>type-name</code> property of <code>parent($target)</code> is <code>xs:untyped</code>, then <code><a href="#id-upd-set-to-untyped">upd:setToUntyped()</a></code> is invoked on each element or attribute node in <code>$content</code>.</p></li></ol></li><li><p>Effects on <code>parent($target)</code>:</p><ol class="enumla"><li><p>The <code>children</code> property of <code>parent($target)</code> is modified to add the nodes in <code>$content</code> just before <code>$target</code>, preserving their order.</p></li><li><p>If at least one of the nodes in <code>$content</code> is an element or text node, <code><a href="#id-upd-remove-type">upd:removeType</a>(parent($target))</code> is invoked.</p></li></ol></li><li class="diff-add"><div class="diff-add"><li><p>All the namespace bindings of <code>parent($target)</code> are <a title="mark" href="#dt-mark">marked for namespace propagation</a>.</p></li></div></li></ol></dd></dl></div><div class="div3">
<h4><a name="id-upd-insert-after" id="id-upd-insert-after"/>3.1.2 upd:insertAfter</h4><dl><dt class="label"><dt class="label">Parameters</dt></dt><dd><div class="exampleInner"><pre>upd:insertAfter(
   $target as node(),
   $content as node()+)</pre></div></dd><dt class="label"><dt class="label">Summary</dt></dt><dd><p>Inserts <code>$content</code> immediately after <code>$target</code>.</p></dd><dt class="label"><dt class="label">Constraints</dt></dt><dd><p><code>$target</code> must be an element, text, processing
									instruction, or comment node with a non-empty <code>parent</code> property. <code>$content</code> must be a sequence containing only element, text, processing instruction,
									and comment nodes.</p></dd><dt class="label"><dt class="label">Semantics</dt></dt><dd><p>The semantics of <code>upd:insertAfter</code> are identical to the semantics of <code>upd:insertBefore</code>, except that Rule 2a is changed as follows:</p><ul><li><p>The <code>children</code> property of <code>parent($target)</code> is modified to add the nodes in <code>$content</code> just after <code>$target</code>, preserving their order.</p></li></ul></dd></dl></div><div class="div3">
<h4><a name="id-upd-insert-into" id="id-upd-insert-into"/>3.1.3 upd:insertInto</h4><dl><dt class="label"><dt class="label">Parameters</dt></dt><dd><div class="exampleInner"><pre>upd:insertInto(
   $target as node(),
   $content as node()+)</pre></div></dd><dt class="label"><dt class="label">Summary</dt></dt><dd><p>Inserts <code>$content</code> as the children of <code>$target</code>, in an implementation-dependent position.</p></dd><dt class="label"><dt class="label">Constraints</dt></dt><dd><p><code>$target</code> must be an element or document node. <code>$content</code> must be a sequence containing only element, text, processing instruction,
									and comment nodes.</p></dd><dt class="label"><dt class="label">Semantics</dt></dt><dd><p>The semantics of <code>upd:insertInto</code> are identical to the semantics of <code>upd:insertBefore</code>, except that <code>$target</code> is substituted everywhere for <code>parent($target)</code>, and Rule 2a is changed as follows:</p><ul><li><p>The <code>children</code> property of <code>$target</code> is changed to add the nodes in <code>$content</code> in implementation-dependent positions, preserving their relative order.</p></li></ul></dd></dl></div><div class="div3">
<h4><a name="id-upd-insert-into-as-first" id="id-upd-insert-into-as-first"/>3.1.4 upd:insertIntoAsFirst</h4><dl><dt class="label"><dt class="label">Parameters</dt></dt><dd><div class="exampleInner"><pre>upd:insertIntoAsFirst(
   $target as node(),
   $content as node()+)</pre></div></dd><dt class="label"><dt class="label">Summary</dt></dt><dd><p>Inserts <code>$content</code> as the first children of <code>$target</code>.</p></dd><dt class="label"><dt class="label">Constraints</dt></dt><dd><p><code>$target</code> must be an element or document node. <code>$content</code> must be a sequence containing only element, text, processing instruction,
									and comment nodes.</p></dd><dt class="label"><dt class="label">Semantics</dt></dt><dd><p>The semantics of <code>upd:insertIntoAsFirst</code> are identical to the semantics of <code>upd:insertBefore</code>, except that <code>$target</code> is substituted everywhere for <code>parent($target)</code>, and Rule 2a is changed as follows:</p><ul><li><p>The <code>children</code> property of <code>$target</code> is changed to add the nodes in <code>$content</code> as the first children, preserving their order.</p></li></ul></dd></dl></div><div class="div3">
<h4><a name="id-upd-insert-into-as-last" id="id-upd-insert-into-as-last"/>3.1.5 upd:insertIntoAsLast</h4><dl><dt class="label"><dt class="label">Parameters</dt></dt><dd><div class="exampleInner"><pre>upd:insertIntoAsLast(
   $target as node(),
   $content as node()+)</pre></div></dd><dt class="label"><dt class="label">Summary</dt></dt><dd><p>Inserts <code>$content</code> as the last children of <code>$target</code>.</p></dd><dt class="label"><dt class="label">Constraints</dt></dt><dd><p><code>$target</code> must be an element or document node. <code>$content</code> must be a sequence containing only element, text, processing instruction,
									and comment nodes.</p></dd><dt class="label"><dt class="label">Semantics</dt></dt><dd><p>The semantics of <code>upd:insertIntoAsLast</code> are identical to the semantics of <code>upd:insertBefore</code>, except that <code>$target</code> is substituted everywhere for <code>parent($target)</code>, and Rule 2a is changed as follows:</p><ul><li><p>The <code>children</code> property of <code>$target</code> is changed to add the nodes in <code>$content</code> as the last children, preserving their order.</p></li></ul></dd></dl></div><div class="div3">
<h4><a name="id-upd-insert-attributes" id="id-upd-insert-attributes"/>3.1.6 upd:insertAttributes</h4><dl><dt class="label"><dt class="label">Parameters</dt></dt><dd><div class="exampleInner"><pre>upd:insertAttributes(
   $target as element(),
   $content as attribute()+)</pre></div></dd><dt class="label"><dt class="label">Summary</dt></dt><dd><p>Inserts <code>$content</code> as attributes of <code>$target</code>.</p></dd><dt class="label"><dt class="label">Constraints</dt></dt><dd><p>None</p></dd><dt class="label"><dt class="label">Semantics</dt></dt><dd><ol class="enumar"><li><p>For each node <code>$A</code> in <code>$content</code>:</p><ol class="enumla"><li><p>The <code>parent</code> property of <code>$A</code> is set to <code>$target</code>.</p></li><li><p>If the <code>type-name</code> property of <code>$target</code> is <code>xs:untyped</code>, then <code><a href="#id-upd-set-to-untyped">upd:setToUntyped</a>($A)</code> is invoked.</p></li></ol></li><li><p>The following properties of <code>$target</code> are changed:</p><ol class="enumla"><li><p><code>attributes</code>: Modified to <span class="diff-del"><!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>include</span></span><span class="diff-add"><!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>add</span></span> the nodes in <code>$content</code>.</p></li><li><p><code>namespaces:</code> Modified to add namespace bindings for any attribute namespace prefixes in <code>$content</code> that did not already have bindings.
<span class="diff-add"><!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>These bindings are <a title="mark" href="#dt-mark">marked for namespace propagation</a>.</span></span>

</p></li><li><p><code><a href="#id-upd-remove-type">upd:removeType</a>($target)</code> is invoked.</p></li></ol></li></ol></dd></dl></div><div class="div3">
<h4><a name="id-upd-delete" id="id-upd-delete"/>3.1.7 upd:delete</h4><dl><dt class="label"><dt class="label">Parameters</dt></dt><dd><div class="exampleInner"><pre>upd:delete(
   $target as node())</pre></div></dd><dt class="label"><dt class="label">Constraints</dt></dt><dd><p>None</p></dd><dt class="label"><dt class="label">Semantics</dt></dt><dd><ol class="enumar"><li><p>If <code>$target</code> has a parent node <code>$P</code>, then:</p><ol class="enumla"><li><p>The <code>parent</code> property of <code>$target</code> is set to empty.</p></li><li><p>If <code>$target</code> is an attribute node, the <code>attributes</code> property of <code>$P</code> is modified to remove <code>$target</code>.</p></li><li><p>If <code>$target</code> is a non-attribute node, the <code>children</code> property of <code>$P</code> is modified to remove <code>$target</code>.</p></li><li><p>If <code>$target</code> is an element, attribute, or text node, and <code>$P</code> is an element node, then <code><a href="#id-upd-remove-type">upd:removeType</a>($P)</code>  is invoked.</p></li></ol></li><li><p>If <code>$target</code> has no parent, the <a title="XDM instance" href="#dt-xdm-instance">XDM instance</a> is unchanged.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>Deleted nodes are detached from their parent nodes; however, a node deletion has no effect on variable bindings or on the set of available documents or collections during processing of the current query.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Multiple <code>upd:delete</code> operations may be applied to the same node during execution of a query; this is not an error.</p></div></dd></dl></div><div class="div3">
<h4><a name="id-upd-replacenode" id="id-upd-replacenode"/>3.1.8 upd:replaceNode</h4><dl><dt class="label"><dt class="label">Parameters</dt></dt><dd><div class="exampleInner"><pre>upd:replaceNode(
   $target as node(),
   $replacement as node()*)</pre></div></dd><dt class="label"><dt class="label">Summary</dt></dt><dd><p>Replaces <code>$target</code> with <code>$replacement</code>.</p></dd><dt class="label"><dt class="label">Constraints</dt></dt><dd><p><code>$target</code> must be a node that has a parent. If <code>$target</code> is an attribute node, <code>$replacement</code> must consist of zero or more attribute nodes. If <code>$target</code> is an element, text, comment, or processing instruction node, <code>$replacement</code> must be consist of zero or more element, text, comment, or processing instruction nodes.</p></dd><dt class="label"><dt class="label">Semantics</dt></dt><dd><ol class="enumar"><li><p>Effects on nodes in <code>$replacement</code>:</p><ol class="enumla"><li><p>For each node in <code>$replacement</code>, the <code>parent</code> property is set to <code>parent($target)</code>.</p></li><li><p>If the <code>type-name</code> property of <code>parent($target)</code> is <code>xs:untyped</code>, then <code><a href="#id-upd-set-to-untyped">upd:setToUntyped</a>()</code> is invoked on each <span class="diff-del"><!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>element</span></span> node in <code>$replacement</code>.</p></li></ol></li><li><p>Effect on <code>$target</code>:</p><ol class="enumla"><li><p>The <code>parent</code> property of <code>$target</code> is set to empty.</p></li></ol></li><li><p>Effects on <code>parent($target)</code>:</p><ol class="enumla"><li><p>If <code>$target</code> is an attribute node, the <code>attributes</code> property of <code>parent($target)</code> is modified by removing <code>$target</code> and adding the nodes in <code>$replacement</code> (if any).</p></li><li><p>If <code>$target</code> is an attribute node, the <code>namespaces</code> property of <code>parent($target)</code> is modified to add namespace bindings for any attribute namespace prefixes in <code>$replacement</code> that did not already have bindings. <span class="diff-add"><!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>These bindings are <a title="mark" href="#dt-mark">marked for namespace propagation</a>.</span></span></p></li><li><p>If <code>$target</code> is an element, text, comment, or processing instruction node, the <code>children</code> property of <code>parent($target)</code> is modified by removing <code>$target</code> and adding the nodes in <code>$replacement</code> (if any) in the former position of <code>$target</code>, preserving their order.</p></li><li><p>If <code>$target</code> or any node in <code>$replacement</code> is an element, attribute, or text
node,  <code><a href="#id-upd-remove-type">upd:removeType</a>(parent($target))</code> is invoked.</p></li></ol></li></ol></dd></dl></div><div class="div3">
<h4><a name="id-upd-replace-value" id="id-upd-replace-value"/>3.1.9 upd:replaceValue</h4><dl><dt class="label"><dt class="label">Parameters</dt></dt><dd><div class="exampleInner"><pre>upd:replaceValue(
   $target as node(),
   $string-value as xs:string)</pre></div></dd><dt class="label"><dt class="label">Summary</dt></dt><dd><p>Replaces the string value of <code>$target</code> with <code>$string-value</code>.</p></dd><dt class="label"><dt class="label">Constraints</dt></dt><dd><p><code>$target</code> must be an attribute, text, comment, or processing instruction node.</p></dd><dt class="label"><dt class="label">Semantics</dt></dt><dd><ol class="enumar"><li><p>If <code>$target</code> is an attribute node:</p><ol class="enumla"><li><p><code>string-value</code> of <code>$target</code> is set to <code>$string-value</code>.</p></li><li><p><code><a href="#id-upd-remove-type">upd:removeType</a>($target)</code> is invoked.</p></li></ol></li><li><p>If <code>$target</code> is a text, comment, or processing instruction node: <code>content</code> of <code>$target</code> is set to <code>$string-value</code>.</p></li><li><p>If  <code>$target</code> is a text node that has a parent, <code><a href="#id-upd-remove-type">upd:removeType</a>(parent($target))</code> is invoked.</p></li></ol></dd></dl></div><div class="div3">
<h4><a name="id-upd-replace-element-content" id="id-upd-replace-element-content"/>3.1.10 upd:replaceElementContent</h4><dl><dt class="label"><dt class="label">Parameters</dt></dt><dd><div class="exampleInner"><pre>upd:replaceElementContent(
   $target as element(),
   $text as text()?)</pre></div></dd><dt class="label"><dt class="label">Summary</dt></dt><dd><p>Replaces the existing children of the element node <code>$target</code> by the optional text node <code>$text</code>. The attributes of <code>$target</code> are not affected.</p></dd><dt class="label"><dt class="label">Constraints</dt></dt><dd><p>None.</p></dd><dt class="label"><dt class="label">Semantics</dt></dt><dd><ol class="enumar"><li><p>For each node <code>$C</code> that is a child of <code>$target</code>, the <code>parent</code> property of <code>$C</code> is set to empty.</p></li><li><p>The <code>parent</code> property of <code>$text</code> is set to <code>$target</code>.</p></li><li><p>Effects on <code>$target</code>:</p><ol class="enumla"><li><p><code>children</code> is set to consist exclusively of <code>$text</code>. If <code>$text</code> is an empty sequence, then <code>$target</code> has no children.</p></li><li><p><code>typed-value</code> and <code>string-value</code> are set to the <code>content</code> property of <code>$text</code>. If <code>$text</code> is an empty sequence, then <code>typed-value</code> is an empty sequence and <code>string-value</code> is an empty string.</p></li><li><p><code><a href="#id-upd-remove-type">upd:removeType($target)</a></code> is invoked.</p></li></ol></li></ol></dd></dl></div><div class="div3">
<h4><a name="id-upd-rename" id="id-upd-rename"/>3.1.11 upd:rename</h4><dl><dt class="label"><dt class="label">Parameters</dt></dt><dd><div class="exampleInner"><pre>upd:rename(
   $target as node(),
   $newName as xs:QName)</pre></div></dd><dt class="label"><dt class="label">Summary</dt></dt><dd><p>Changes the node-name of <code>$target</code> to <code>$newName</code>.</p></dd><dt class="label"><dt class="label">Constraints</dt></dt><dd><p><code>$target</code> must be an element, attribute, or processing instruction node.</p></dd><dt class="label"><dt class="label">Semantics</dt></dt><dd><ol class="enumar"><li><p>If <code>$target</code> is an element node:</p><ol class="enumla"><li><p><code>node-name</code> of <code>$target</code> is set to <code>$newName</code>.</p></li><li><p><code><a href="#id-upd-remove-type">upd:removeType</a>($target)</code> is invoked.</p></li><li><p>If <code>$newname</code> has no prefix and no namespace URI, 
the <code>namespaces</code> property of <code>$target</code> is modified by removing the binding (if any) 
for the empty prefix.</p></li><li><p>The <code>namespaces</code> property of <code>$target</code> is modified to add a namespace binding derived from <code>$newName</code>, if this binding did not already exist.

<span class="diff-add"><!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>This binding is <a title="mark" href="#dt-mark">marked for namespace propagation</a>.</span></span>
</p></li></ol></li><li><p>If <code>$target</code> is an attribute node:</p><ol class="enumla"><li><p><code>node-name</code> of <code>$target</code> is set to <code>$newName</code>.</p></li><li><p><code><a href="#id-upd-remove-type">upd:removeType</a>($target)</code> is invoked.</p></li><li><p>If <code>$newName</code> is <code>xml:id</code>, the <code>is-id</code> property of <code>$target</code> is set to <code>true</code>.</p></li><li><p>If <code>$target</code> has a parent, the <code>namespaces</code> property of <code>parent($target)</code> is modified to add a namespace binding derived from <code>$newName</code>, if this binding did not already exist.

<span class="diff-add"><!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>This binding is <a title="mark" href="#dt-mark">marked for namespace propagation</a>.</span></span>
</p></li></ol></li><li><p>If <code>$target</code> is a processing instruction node, its <code>target</code> property is set to the local part of  <code>$newName</code>.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>At the end of a <a title="snapshot" href="#dt-snapshot">snapshot</a>, if multiple attribute nodes with the same parent have the same qualified name, an error will be raised by <code>upd:applyUpdates</code>.</p></div></dd></dl></div><div class="div3">
<h4><a name="id-upd-put" id="id-upd-put"/>3.1.12 upd:put</h4><dl><dt class="label"><dt class="label">Parameters</dt></dt><dd><div class="exampleInner"><pre>upd:put(
   $node as node(),
   $uri as xs:string)</pre></div></dd><dt class="label"><dt class="label">Summary</dt></dt><dd><p> The XDM node tree rooted at <code>$node</code> is stored to the location specified by <code>$uri</code>.</p></dd><dt class="label"><dt class="label">Constraints</dt></dt><dd><p><code>$uri</code> must be a valid absolute URI.</p></dd><dt class="label"><dt class="label">Semantics</dt></dt><dd><p>The external effects of <code>upd:put</code> are implementation-defined,
since they occur outside the domain of XQuery. The intent is that, if <code>upd:put</code> is invoked on a document node and no error is raised, a
subsequent query can access the stored document by invoking
<code>fn:doc</code> with the same URI.</p></dd></dl></div></div><div class="div2">
<h3><a name="id-update-routines" id="id-update-routines"/>3.2 Update Routines</h3><div class="div3">
<h4><a name="id-upd-merge-updates" id="id-upd-merge-updates"/>3.2.1 upd:mergeUpdates</h4><dl><dt class="label"><dt class="label">Parameters</dt></dt><dd><div class="exampleInner"><pre>upd:mergeUpdates(
   $pul1 as pending-update-list,
   $pul2 as pending-update-list)</pre></div></dd><dt class="label"><dt class="label">Summary</dt></dt><dd><p>Merges two <a title="pending update list" href="#dt-pending-update-list">pending update lists</a>.</p></dd><dt class="label"><dt class="label">Constraints</dt></dt><dd><p>None.</p></dd><dt class="label"><dt class="label">Semantics</dt></dt><dd><ol class="enumar"><li><p>The two <a title="pending update list" href="#dt-pending-update-list">pending update lists</a> are merged and a single pending update list containing all the update primitives from both lists is returned.</p></li><li><p>Optionally, <code>upd:mergeUpdates</code> may raise a dynamic error if any of the following conditions are detected:</p><ol class="enumla"><li><p>Two or more <code>upd:rename</code> primitives on the merged list have the same target node [<a href="#ERRXUDY0015" title="err:XUDY0015">err:XUDY0015</a>].</p></li><li><p>Two or more <code>upd:replaceNode</code> primitives on the merged list have the same target node [<a href="#ERRXUDY0016" title="err:XUDY0016">err:XUDY0016</a>].</p></li><li><p>Two or more <code>upd:replaceValue</code> primitives on the merged list have the same target node [<a href="#ERRXUDY0017" title="err:XUDY0017">err:XUDY0017</a>].</p></li><li><p>Two or more <code>upd:replaceElementContent</code> primitives on the merged list have the same target node [<a href="#ERRXUDY0017" title="err:XUDY0017">err:XUDY0017</a>].</p></li><li><p>Two or more <code>upd:put</code> primitives on the merged list have the same <code>$uri</code> operand [<a href="#ERRXUDY0031" title="err:XUDY0031">err:XUDY0031</a>].</p></li><li><p>Two or more primitives on the merged list create  <a title="conflict" href="#dt-conflict">conflicting</a> namespace bindings for the same element node [<a href="#ERRXUDY0024" title="err:XUDY0024">err:XUDY0024</a>]. The following kinds of primitives create namespace bindings:</p><ol class="enumlr"><li><p><code>upd:insertAttributes</code>
                              creates one namespace binding on the
                              <code>$target</code> element
                              corresponding to the <a title="implied namespace binding" href="#dt-implied-namespace-binding">implied
                              namespace binding</a> of the name
                              of each attribute node in
                              <code>$content</code> if the name 
                              has a non-empty prefix.</p></li><li><p><code>upd:replaceNode</code> creates one namespace binding on the <code>parent($target)</code> element
                              corresponding to the <a title="implied namespace binding" href="#dt-implied-namespace-binding">implied namespace binding</a> of the name of each attribute node in
                              <code>$replacement</code> if the name has a non-empty prefix.</p></li><li><p><code>upd:rename</code> creates a namespace binding on <code>$target</code>, or on the parent (if any) of
                              <code>$target</code> if <code>$target</code> is an attribute node, corresponding to the <a title="implied namespace binding" href="#dt-implied-namespace-binding">implied namespace binding</a> of <code>$newName</code>.
However, if $target is an attribute and its name has an empty prefix, the namespace binding is not created.
</p></li></ol></li></ol></li></ol></dd></dl></div><div class="div3">
<h4><a name="id-upd-apply-updates" id="id-upd-apply-updates"/>3.2.2 upd:applyUpdates</h4><dl><dt class="label"><dt class="label">Parameters</dt></dt><dd><div class="exampleInner"><pre>upd:applyUpdates(
   $pul as pending-update-list,
   $revalidation-mode as xs:string<span class="diff-add"><!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>,
   $inherit-namespaces as xs:boolean</span></span>)</pre></div></dd><dt class="label"><dt class="label">Summary</dt></dt><dd><p>This routine ends a <a title="snapshot" href="#dt-snapshot">snapshot</a> by making effective  the semantics of all the update primitives on a <a title="pending update list" href="#dt-pending-update-list">pending update list</a> and by revalidating the resulting <a title="XDM instance" href="#dt-xdm-instance">XDM instance</a>.</p></dd><dt class="label"><dt class="label">Constraints</dt></dt><dd><p><code>$revalidation-mode</code> must be <code>"strict"</code>, <code>"lax"</code>, or <code>"skip"</code></p></dd><dt class="label"><dt class="label">Semantics</dt></dt><dd><ol class="enumar"><li><p>Checks the update primitives on <code>$pul</code> for compatibility. Raises a dynamic error if any of the following conditions are detected:</p><ol class="enumla"><li><p>Two or more <code>upd:rename</code> primitives on <code>$pul</code> have the same target node [<a href="#ERRXUDY0015" title="err:XUDY0015">err:XUDY0015</a>].</p></li><li><p>Two or more <code>upd:replaceNode</code> primitives on <code>$pul</code> have the same target node [<a href="#ERRXUDY0016" title="err:XUDY0016">err:XUDY0016</a>].</p></li><li><p>Two or more <code>upd:replaceValue</code> primitives on <code>$pul</code> have the same target node [<a href="#ERRXUDY0017" title="err:XUDY0017">err:XUDY0017</a>].</p></li><li><p>Two or more <code>upd:replaceElementContent</code> primitives on <code>$pul</code> have the same target node [<a href="#ERRXUDY0017" title="err:XUDY0017">err:XUDY0017</a>].</p></li><li><p>Two or more <code>upd:put</code> primitives on the merged list have the same <code>$uri</code> operand [<a href="#ERRXUDY0031" title="err:XUDY0031">err:XUDY0031</a>].</p></li><li><p>Two or more primitives on <code>$pul</code> create  <a title="conflict" href="#dt-conflict">conflicting</a> namespace bindings for the same element node [<a href="#ERRXUDY0024" title="err:XUDY0024">err:XUDY0024</a>]. The following kinds of primitives create namespace bindings:</p><ol class="enumlr"><li><p><code>upd:insertAttributes</code> creates one namespace binding on the <code>parent($target)</code> element
                            corresponding to the <a title="implied namespace binding" href="#dt-implied-namespace-binding">implied namespace binding</a> of the name of each attribute node in
                            <code>$content</code> if the name 
                              has a non-empty prefix.</p></li><li><p><code>upd:replaceNode</code> creates one namespace binding on the <code>$target</code> element
                            corresponding to the <a title="implied namespace binding" href="#dt-implied-namespace-binding">implied namespace binding</a> of the name of each attribute node in
                            <code>$replacement</code>  if the name 
                              has a non-empty prefix.</p></li><li><p><code>upd:rename</code> creates a namespace binding on <code>$target</code>, or on the parent (if any) of
                            <code>$target</code> if <code>$target</code> is an attribute node, corresponding to the <a title="implied namespace binding" href="#dt-implied-namespace-binding">implied namespace binding</a> of <code>$newName</code>. However, if $target is an attribute and its name has an empty prefix, the namespace binding is not created.</p></li></ol></li></ol></li><li><p>The semantics of all  <a title="update primitive" href="#dt-update-primitive">update primitives</a> on <code>$pul</code>, other than <code>upd:put</code> primitives, are made effective in the following order:</p><ol class="enumla"><li><p>First, all <code>upd:insertInto</code>, <code>upd:insertAttributes</code>, <code>upd:replaceValue</code>, and <code>upd:rename</code>  primitives are applied.</p></li><li><p>Next, all <code>upd:insertBefore</code>, <code>upd:insertAfter</code>, <code>upd:insertIntoAsFirst</code>, and <code>upd:insertIntoAsLast</code> primitives are applied.</p></li><li><p>Next, all <code>upd:replaceNode</code> primitives are applied.</p></li><li><p>Next, all <code>upd:replaceElementContent</code> primitives are applied.</p></li><li><p>Next, all <code>upd:delete</code> primitives are applied.</p></li></ol></li><li><p>If, as a net result of the above steps, the <code>children</code> property of some node contains adjacent text nodes, these adjacent text nodes are merged into a single text node. The string-value of the resulting text node is the concatenated string-values of the adjacent text nodes, with no intervening space added. The <a title="node identity" href="#dt-node-identity">node identity</a> of the resulting text node is implementation-dependent.</p></li><li><p>If, as a net result of the above steps, the <code>children</code> property of some node contains an empty text node, that empty text node is deleted from the <code>children</code> property.</p></li><li><div class="diff-del"><p>If the resulting <a title="XDM instance" href="#dt-xdm-instance">XDM instance</a> violates any constraint specified in <a href="#xpath-datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>, a dynamic error is raised [<a href="#ERRXUDY0021" title="err:XUDY0021">err:XUDY0021</a>].</p></div><div class="diff-add"><p>If, after applying the updates, any <a title="XDM instance" href="#dt-xdm-instance">XDM instance</a> (including a node that has
been deleted or detached from its parent, or that is a descendant of such a
node) violates any constraint specified in <a href="#xpath-datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>, a
dynamic error is raised [<a href="#ERRXUDY0021" title="err:XUDY0021">err:XUDY0021</a>].</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>For example, a data model constraint violation might occur if multiple attributes with the same parent have the same qualified name (see <a href="http://www.w3.org/TR/xpath-datamodel/#ElementNodeOverview">Section 
6.2.1 Overview</a><sup><small>DM</small></sup>.)</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>During processing of a <a title="pending update list" href="#dt-pending-update-list">pending update list</a>, an <a title="XDM instance" href="#dt-xdm-instance">XDM instance</a> may temporarily violate a data model constraint. An error is raised only if a constraint remains unsatisfied after all update primitives other than <code>upd:put</code> have been applied.</p></div></li><li class="diff-add"><div class="diff-add"><li><p>If <code>$inherit-namespaces</code> is
<code>true</code>, then <code><a href="#id-upd-propagate-namespace">upd:propagateNamespace</a>($element,
$prefix, $uri)</code> is invoked for each namespace binding that was
<a title="mark" href="#dt-mark">marked for namespace propagation</a>,
except for namespace bindings associated with the empty prefix,
where <code>$element</code> is the element node on which the namespace
binding appears, <code>$prefix</code> is the namespace prefix, and
<code>$uri</code> is the namespace URI. Each of these nodes is then
unmarked.</p></li></div></li><li><p>For each document or element node <code>$top</code> that was <a title="mark" href="#dt-mark">marked for revalidation</a> by one of the earlier steps, <code>upd:revalidate($top, $revalidation-mode)</code> is invoked. <span class="diff-add"><!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>Each of these nodes is then unmarked.</span></span></p></li><li><p>As the final step, all <code>upd:put</code> primitives on <code>$pul</code> are applied.</p></li><li><p>The  <code>upd:applyUpdates</code> operation is atomic with respect to the data model. In other words, if <code>upd:applyUpdates</code> terminates normally, the resulting <a title="XDM instance" href="#dt-xdm-instance">XDM instance</a> reflects the result of all update primitives; but if <code>upd:applyUpdates</code> raises an error, the resulting <a title="XDM instance" href="#dt-xdm-instance">XDM instance</a>  reflects no changes. Atomicity is guaranteed only with respect to operations on XDM instances, 
and only with respect to error conditions specified in this document.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The results of implementation-dependent error conditions such as exceeding 
resource limits are beyond the scope of this specification.</p></div></li><li><p>Propagation
of XDM changes to an underlying persistent store is beyond the
scope of this specification. For example, the effect on persistent storage of deleting a node that has no parent is beyond the scope of this specification.</p></li></ol></dd></dl></div><div class="div3">
<h4><a name="id-upd-revalidate" id="id-upd-revalidate"/>3.2.3 upd:revalidate</h4><dl><dt class="label"><dt class="label">Parameters</dt></dt><dd><div class="exampleInner"><pre>upd:revalidate(
   $top as node(),
   $revalidation-mode as xs:string)</pre></div></dd><dt class="label"><dt class="label">Constraints</dt></dt><dd><p><code>$top</code> must be a document node or an element node.</p><p><code>$revalidation-mode</code> must be <code>"strict"</code>, <code>"lax"</code>, or <code>"skip"</code>.</p></dd><dt class="label"><dt class="label">Summary</dt></dt><dd><p>Schema validation is applied to the subtree rooted at <code>$top</code> in order to recover the types of updated nodes while preserving their <a title="node identity" href="#dt-node-identity">node identities</a>.</p></dd><dt class="label"><dt class="label">Semantics</dt></dt><dd><p>If <code>$revalidation-mode</code> is <code>skip</code>, <code>upd:revalidate</code> performs no action. Otherwise:</p><ol class="enumar"><li><p>If <code>$revalidation-mode</code> is <code>lax</code>,
              define <code>$topV</code> as the result of the XQuery expression <code>validate lax {$top}</code>. 
              If <code>$revalidation-mode</code> is <code>strict</code>,
              define <code>$topV</code> as the result of the XQuery expression <code>validate strict {$top}</code>. 
              During computation of <code>$topV</code>, it is necessary to maintain a mapping between each node
              in <code>$topV</code> and the corresponding node (if any) in the subtree rooted at <code>$top</code>
              (this mapping is maintained in an implementation-dependent way.)</p><div class="note"><p class="prefix"><b>Note:</b></p><ul><li><p>This step may raise an error [<a href="http://www.w3.org/TR/xquery/#ERRXQDY0027" title="err:XQDY0027">err:XQDY0027</a>]<sup><small>XQ</small></sup>
              if <code>$top</code> is found to be invalid.</p></li><li><p>Some of the nodes in <code>$topV</code> (for example, default attributes generated by
              the validation process) may have no corresponding nodes in <code>$top</code>.</p></li></ul></div></li><li><p>For each node <code>$nV</code> in <code>$topV</code> that has a corresponding node
              <code>$n</code> in <code>$top</code>, replace the following properties of <code>$n</code>
              with the corresponding properties of <code>$nV</code>: <code>type-name</code>,
              <code>typed-value</code>, <code>string-value</code>, <code>is-id</code>, <code>is-idrefs</code>,
              <code>namespace-bindings</code>, <code>nilled</code>.</p></li><li><p>For each node <code>$nV</code> in <code>$topV</code> that does not have
              a corresponding node in <code>$top</code>, insert the node <code>$nV</code>
              into the subtree rooted at <code>$top</code> as a child or attribute of the node
              corresponding to the parent of <code>$nV</code>.</p></li><li><p>The result of <code>upd:revalidate</code> is to modify the properties of the nodes
              rooted at <code>$top</code> and possibly to add some new nodes to this subtree. 
              When the revalidation process is complete, <code>$topV</code> can be discarded.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>After revalidation, the type annotations of the nodes in the validated subtree
              are consistent with their content. 
              It is expected that implementations will optimize the revalidation process by taking into account
              which nodes have been modified since they were last validated.</p></div></dd></dl></div><div class="div3">
<h4><a name="id-upd-remove-type" id="id-upd-remove-type"/>3.2.4 upd:removeType</h4><dl><dt class="label"><dt class="label">Parameters</dt></dt><dd><div class="exampleInner"><pre>upd:removeType(
   $N as node())</pre></div></dd><dt class="label"><dt class="label">Constraints</dt></dt><dd><p><code>$N</code> must be an element or attribute node</p></dd><dt class="label"><dt class="label">Summary</dt></dt><dd><p> This routine is applied to a node whose name or content has been modified, in order to remove specific type information from the node and its ancestors, pending revalidation.</p></dd><dt class="label"><dt class="label">Semantics</dt></dt><dd><ol class="enumar"><li><p>If <code>$N</code> is an element node, its properties are changed as follows:</p><ol class="enumla"><li><p> If <code>type-name</code> is not equal to <code>xs:untyped</code>, then</p><ol class="enumlr"><li><p><code>type-name</code> is set to <code>xs:anyType</code></p></li><li><p>If the parent of <code>N</code> is an element node, then <code>upd:removeType(parent($N))</code> is invoked.</p></li></ol></li><li><p><code>string-value</code> is set equal to the concatenated contents of the text node descendants, in document order.</p></li><li><p><code>typed-value</code> is set equal to the <code>string-value</code> property, as an instance of <code>xs:untypedAtomic</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The <a title="data model" href="#dt-data-model">data model</a> allows some flexibility to implementations regarding whether <code>string-value</code> and/or <code>typed-value</code> are stored or computed dynamically.</p></div></li><li><p><code>nilled</code>, <code>is-id</code>, and <code>is-idrefs</code> are set to <code>false</code>.</p></li></ol></li><li><p>If <code>$N</code> is an attribute node, its properties are changed as follows:</p><ol class="enumla"><li><p><code>type-name</code> is set to <code>xs:untypedAtomic</code>.</p></li><li><p><code>typed-value</code> is set equal to the <code>string-value</code> property, as an instance of <code>xs:untypedAtomic</code>.</p></li><li><p> <code>is-id</code> and <code>is-idrefs</code> are set to <code>false</code>.</p></li><li><p>If <code>$N</code> has a parent, <code>upd:removeType(parent($N))</code> is invoked.</p></li></ol></li><li><p>The topmost ancestor of <code>$N</code> is <a title="mark" href="#dt-mark">marked</a> for revalidation.</p><p>[<a name="dt-mark" id="dt-mark" title="mark">Definition</a>: To <b>mark</b> a node means to identify the node as participating in a later operation.] Marking of nodes is accomplished in an implementation-dependent way--for example, an implementation might maintain a list of marked nodes.</p></li></ol></dd></dl></div><div class="div3">
<h4><a name="id-upd-set-to-untyped" id="id-upd-set-to-untyped"/>3.2.5 upd:setToUntyped</h4><dl><dt class="label"><dt class="label">Parameters</dt></dt><dd><div class="exampleInner"><pre>upd:setToUntyped(
   $N as node())</pre></div></dd><dt class="label"><dt class="label">Constraints</dt></dt><dd><p><code>$N</code> must be an element or attribute node</p></dd><dt class="label"><dt class="label">Summary</dt></dt><dd><p> This routine is applied to a node that has been inserted into an untyped context, which requires that the node and its descendants be untyped as well.</p></dd><dt class="label"><dt class="label">Semantics</dt></dt><dd><ol class="enumar"><li><p>If <code>$N</code> is an element node, its properties are changed as follows:</p><ol class="enumla"><li><p><code>type-name</code> is set to <code>xs:untyped</code>.</p></li><li><p><code>typed-value</code> is set equal to the <code>string-value</code> property, as an instance of <code>xs:untypedAtomic</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The <a title="data model" href="#dt-data-model">data model</a> allows some flexibility to implementations regarding whether <code>string-value</code> and/or <code>typed-value</code> are stored or computed dynamically.</p></div></li><li><p><code>nilled</code>, <code>is-id</code>, and <code>is-idrefs</code> are set to <code>false</code>.</p></li><li><p><code>upd:setToUntyped()</code> is invoked on the attributes and child element nodes of <code>$N</code>.</p></li></ol></li><li><p>If <code>$N</code> is an attribute node, its properties are changed as follows:</p><ol class="enumla"><li><p><code>type-name</code> is set to <code>xs:untypedAtomic</code>.</p></li><li><p><code>typed-value</code> is set equal to the <code>string-value</code> property, as an instance of <code>xs:untypedAtomic</code>.</p></li><li><p><span class="diff-del"><!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span><code>is-id</code> and </span></span><code>is-idrefs</code> <span class="diff-del"><!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>are</span></span><span class="diff-add"><!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>is</span></span> set to <code>false</code>.</p></li><li class="diff-add"><div class="diff-add"><li><p><code>is-id</code> is set to <code>false</code> if the attribute name is not <code>xml:id</code>.</p></li></div></li></ol></li></ol></dd></dl></div><div class="diff-add"><div class="div3">
<h4><a name="id-upd-propagate-namespace" id="id-upd-propagate-namespace"/>3.2.6 upd:propagateNamespace</h4><dl><dt class="label"><span class="diff-add" at="">Parameters</span></dt><dd><div class="diff-add" source="gitem/def"><div class="exampleInner"><pre>upd:propagateNamespace(
   $element as element(), 
   $prefix as xs:NCName, 
   $uri as xs:anyURI)</pre></div></div></dd><dt class="label"><span class="diff-add" at="">Constraints</span></dt><dd><div class="diff-add" source="gitem/def"><p>None</p></div></dd><dt class="label"><span class="diff-add" at="">Summary</span></dt><dd><div class="diff-add" source="gitem/def"><p>Propagates a namespace binding to all descendants of an element.</p></div></dd><dt class="label"><span class="diff-add" at="">Semantics</span></dt><dd><div class="diff-add" source="gitem/def"><p>For each element <code>$child</code> among the children of <code>$element</code> that does not have a namespace binding for <code>$prefix</code>,</p><ol class="enumar"><li><p>add a namespace binding <code>($prefix, $uri)</code> to <code>$child</code></p></li><li><p>call <code>upd:propagateNamespace($child, $prefix, $uri)</code></p></li></ol></div></dd></dl></div></div></div></div><div class="div1">
<h2><a name="id-update-static" id="id-update-static"/>4 Static Typing Feature</h2><p>XQuery 1.0 includes an optional static typing feature. This section
describes the static typing feature for the
XQuery Update Facility 1.0. Implementations of this specification that support
optional static typing must implement the following static typing
rules, along with the XQuery 1.0 static typing rules defined in
<a href="#xquery-semantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>.</p><div class="div2">
<h3><a name="id-update-overview" id="id-update-overview"/>4.1 Overview and notations</h3><p>The concepts and notations used in this specification are the same
as those used to define the static typing feature for XQuery 1.0. For
convenience, we recall here some of the main concepts and
notations. We refer the reader to <a href="#xquery-semantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a> for a more detailed introduction.</p><p>The static typing feature for the XQuery Update Facility 1.0 is defined based on a
processing model similar to the one of XQuery 1.0. We first define the
XQuery Update Facility 1.0 <em>Core</em>, as a subset of the XQuery Update Facility 1.0. Then for
each kind of updating expression, we give the normalization rules from
the XQuery Update Facility 1.0 into that Core, as well as the inference rules that
compute the type for each Core expression.</p><p><b>Notation</b></p><p id="jd_map_expr">Normalization rules map expressions in the
      XQuery Update Facility 1.0 into expressions in the XQuery Update Facility 1.0 Core. They are
      written as follows.</p><div align="center"><table summary="" cellspacing="0" cellpadding="0"><tr><td> </td></tr><tr><td align="center" style="margin-right:1cm;">
      	      <font size="6">[</font><em>Expr</em><font size="6">]</font><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
      	    </td></tr><tr><td align="center"><b>==</b></td></tr><tr><td align="center" style="margin-right:1cm;">
      	      <em>CoreExpr</em>
      	    </td></tr></table></div><p><b>Notation</b></p><p>The static semantics is specified through a
      <b>judgment</b> which gives for each expression its
      corresponding static type. The meaning of that judgment is
      defined through <b>inference rules</b> as in <a href="#xquery-semantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>.</p><p id="jd_has_type">The judgment</p><div align="center">
      <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a><b> |- </b><em>Expr</em> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_has_type" class="judgment"><b>:</b></a> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a>
      </div><p>holds when, in the static environment <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a>, the
      expression <em>Expr</em> has type <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a>.</p><p><b>Notation</b></p><p> The static environment is the same as the one defined in
      <a href="#xquery-semantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>, extended with an entry
      corresponding to the revalidation mode, as follows.</p><table summary="" class="figure" cellpadding="5"><col width="10%" span="1"/><col width="15%" span="1"/><col width="65%" align="justify" span="1"/><col width="10%" span="1"/><tbody><tr><td/><td valign="top"><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_revalidation_mode_env" class="env">revalidationMode</a></td><td>
            <table summary=""><tbody><tr><td>The <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_revalidation_mode_env" class="env">revalidationMode</a> environment
                component designates the <b>revalidation mode</b> in
                the XQuery Update Facility 1.0 static context.</td></tr><tr><td>The <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_revalidation_mode_env" class="env">revalidationMode</a> environment
                component is one of <b>strict</b>,
                <b>lax</b>, or <b>skip</b>.</td></tr></tbody></table>
          </td><td/></tr></tbody></table></div><div class="div2">
<h3><a name="id-static-typing-changes" id="id-static-typing-changes"/>4.2 Change to Static Typing Rules of XQuery 1.0</h3><p>XQuery 1.0 specifies that err:XPST0005 is raised if the Static Typing Feature is in effect and the static type assigned to an expression other than <code>( )</code> or <code>data(( ))</code> is <code>empty-sequence( )</code>. XQuery Update Facility 1.0 modifies this rule so that it applies only to <a title="simple expression" href="#dt-simple-expression">simple expressions</a> (i.e., it does not apply to <a title="updating expression" href="#dt-updating-expression">updating expressions</a>.)</p></div><div class="div2">
<h3><a name="id-update-core" id="id-update-core"/>4.3 Core Grammar</h3><p>We extend the
XQuery Core defined in <a href="#xquery-semantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a> with five
expressions needed to support the XQuery Update Facility 1.0: insert, delete, rename,
replace, and transform.</p>
<h5><a name="d8e5622" id="d8e5622"/></h5><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-core-ExprSingle" id="doc-core-ExprSingle"/>[<small>23 (Core)</small>]   </td><td><code>ExprSingle</code></td><td>   ::=   </td><td><code><a href="#prod-core-FLWORExpr">FLWORExpr</a><br/>|  <a href="#prod-core-QuantifiedExpr">QuantifiedExpr</a><br/>|  <a href="#prod-core-TypeswitchExpr">TypeswitchExpr</a><br/>|  <a href="#prod-core-IfExpr">IfExpr</a><br/>|  <a href="#doc-core-InsertExpr">InsertExpr</a><br/>|  <a href="#doc-core-DeleteExpr">DeleteExpr</a><br/>|  <a href="#doc-core-RenameExpr">RenameExpr</a><br/>|  <a href="#doc-core-ReplaceExpr">ReplaceExpr</a><br/>|  <a href="#doc-core-TransformExpr">TransformExpr</a><br/>|  <a href="#prod-core-OrExpr">OrExpr</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-core-InsertExpr" id="doc-core-InsertExpr"/>[<small>99 (Core)</small>]   </td><td><code>InsertExpr</code></td><td>   ::=   </td><td><code>"insert"  "nodes"  <a href="#doc-core-SourceExpr">SourceExpr</a>  <a href="#doc-core-InsertExprTargetChoice">InsertExprTargetChoice</a>  <a href="#doc-core-TargetExpr">TargetExpr</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-core-InsertExprTargetChoice" id="doc-core-InsertExprTargetChoice"/>[<small>98 (Core)</small>]   </td><td><code>InsertExprTargetChoice</code></td><td>   ::=   </td><td><code>(("as"  ("first"  |  "last"))?  "into")<br/>|  "after"<br/>|  "before"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-core-SourceExpr" id="doc-core-SourceExpr"/>[<small>103 (Core)</small>]   </td><td><code>SourceExpr</code></td><td>   ::=   </td><td><code><a href="#doc-core-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-core-TargetExpr" id="doc-core-TargetExpr"/>[<small>104 (Core)</small>]   </td><td><code>TargetExpr</code></td><td>   ::=   </td><td><code><a href="#doc-core-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-core-DeleteExpr" id="doc-core-DeleteExpr"/>[<small>100 (Core)</small>]   </td><td><code>DeleteExpr</code></td><td>   ::=   </td><td><code>"delete"  "nodes"  <a href="#doc-core-TargetExpr">TargetExpr</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-core-ReplaceExpr" id="doc-core-ReplaceExpr"/>[<small>101 (Core)</small>]   </td><td><code>ReplaceExpr</code></td><td>   ::=   </td><td><code>"replace"  ("value"  "of")?  "node"  <a href="#doc-core-TargetExpr">TargetExpr</a>  "with"  <a href="#doc-core-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-core-RenameExpr" id="doc-core-RenameExpr"/>[<small>102 (Core)</small>]   </td><td><code>RenameExpr</code></td><td>   ::=   </td><td><code>"rename"  "node"  <a href="#doc-core-TargetExpr">TargetExpr</a>  "as"  <a href="#doc-core-NewNameExpr">NewNameExpr</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-core-NewNameExpr" id="doc-core-NewNameExpr"/>[<small>105 (Core)</small>]   </td><td><code>NewNameExpr</code></td><td>   ::=   </td><td><code><a href="#doc-core-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-core-TransformExpr" id="doc-core-TransformExpr"/>[<small>106 (Core)</small>]   </td><td><code>TransformExpr</code></td><td>   ::=   </td><td><code>"copy"  "$"  <a href="#prod-core-VarName">VarName</a>  ":="  <a href="#doc-core-ExprSingle">ExprSingle</a>  (","  "$"  <a href="#prod-core-VarName">VarName</a>  ":="  <a href="#doc-core-ExprSingle">ExprSingle</a>)*  "modify"  <a href="#doc-core-ExprSingle">ExprSingle</a>  "return"  <a href="#doc-core-ExprSingle">ExprSingle</a></code></td></tr></tbody></table><ul><li><p id="prod-core-IfExpr">The core grammar production for <code>IfExpr</code> can be found in <a href="#xquery-semantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a></p></li><li><p id="prod-core-OrExpr">The core grammar production for <code>OrExpr</code> can be found in <a href="#xquery-semantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a></p></li><li><p id="prod-core-FLWORExpr">The core grammar production for <code>FLWORExpr</code> can be found in <a href="#xquery-semantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a></p></li><li><p id="prod-core-QuantifiedExpr">The core grammar production for <code>QuantifiedExpr</code> can be found in <a href="#xquery-semantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a></p></li><li><p id="prod-core-TypeswitchExpr">The core grammar production for <code>TypeswitchExpr</code> can be found in <a href="#xquery-semantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a></p></li><li><p id="prod-core-VarName">The core grammar production for <code>VarName</code> can be found in <a href="#xquery-semantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a></p></li></ul></div><div class="div2">
<h3><a name="id-update-norm-prolog" id="id-update-norm-prolog"/>4.4 XQuery Update Facility 1.0 Prolog</h3><p>In addition to the normalization rules defined in <a href="#xquery-semantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a> for the XQuery 1.0 prolog, the
  following normalization rules apply to the revalidation mode
  setter.</p><p><b><a href="http://www.w3.org/TR/xquery-semantics/#processing_normalization" class="processing">Normalization</a></b></p><p>Revalidation declarations are left unchanged through
    normalization.</p><div align="center"><table summary="" cellspacing="0" cellpadding="0"><tr><td> </td></tr><tr><td align="center" style="margin-right:1cm;">
       <font size="6">[</font><em>RevalidationDecl</em><font size="6">]</font><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_map_prolog" class="judgment"><sub><font size="2">PrologDecl</font></sub></a>
      </td></tr><tr><td align="center"><b>==</b></td></tr><tr><td align="center" style="margin-right:1cm;">
        <em>RevalidationDecl</em>
      </td></tr></table></div><p><b><a href="http://www.w3.org/TR/xquery-semantics/#processing_context" class="processing">Static Context Processing</a></b></p><p>The revalidation declaration modifies the revalidation mode
    in the static context.</p><div align="center"><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td>
                <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub> =
                  <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_revalidation_mode_env" class="env">revalidationMode</a>(
                    <em>RevalidationMode</em>) 
              </td></tr><tr><td><hr style="color:black" size="1" noshade="noshade"/></td></tr><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a><b> |- </b>declare revalidation <em>RevalidationMode</em>
              <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub></td></tr></table></td></tr></table></td></tr></table><br/></div></div><div class="div2">
<h3><a name="id-update-norm-expr" id="id-update-norm-expr"/>4.5 XQuery Update Facility 1.0 Expressions</h3><p>In addition to the normalization and static typing rules
    defined in <a href="#xquery-semantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a> for XQuery 1.0
    expressions, the normalization and static typing rules described in
    this specification apply to the expressions in the XQuery Update Facility 1.0. For
    each expression except the transform expression, the final type is
    the empty type which corresponds to the value being returned. In
    each case, the static typing rules check that every sub-expression
    is well-typed, and that the resulting value is consistent with the
    constraints specific to each expression. For instance, the
    expression used in a delete must return a sequence of nodes.</p><div class="div3">
<h4><a name="id-update-typing-insert" id="id-update-typing-insert"/>4.5.1 Insert</h4><p><b><a href="http://www.w3.org/TR/xquery-semantics/#processing_normalization" class="processing">Normalization</a></b></p><p>The following normalization rules apply to insert
      expressions. Note that whether the expression is written using
      the 'nodes' or 'node' modifier, the normalized expression always
      uses the 'nodes' modifier.</p><div align="center"><table summary="" cellspacing="0" cellpadding="0"><tr><td> </td></tr><tr><td align="center" style="margin-right:1cm;">
         <font size="6">[</font>insert (node|nodes) <em>Expr</em><sub><font size="2">1</font></sub> <em>InsertExprTargetChoice</em> <em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
        </td></tr><tr><td align="center"><b>==</b></td></tr><tr><td align="center" style="margin-right:1cm;">
         insert nodes <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a>(<font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)
      	 <em>InsertExprTargetChoice</em>
         <font size="6">[</font><em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
        </td></tr></table></div><p>Where <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a> is the special function used
      for computing element content and is defined in <a href="#xquery-semantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>.</p><p><b><a href="http://www.w3.org/TR/xquery-semantics/#processing_static" class="processing">Static Type Analysis</a></b></p><p>The static typing rule for insert depends on whether it is an
      insert <code>into</code>, or an insert <code>before</code> or
      <code>after</code>.</p><p>In the case of an insert <code>into</code>, the inference
      depends on whether the target node is an element or a document
      node (in which case it does not allow attribute nodes to be
      inserted). This is expressed by the two following rules.</p><div align="center"><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a> <b> |- </b><em>Expr</em><sub><font size="2">1</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_has_type" class="judgment"><b>:</b></a> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub></td></tr><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a><b> |- </b><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
                (attribute *)*, (element * | text | comment | processing-instruction *)*</td></tr><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a> <b> |- </b><em>Expr</em><sub><font size="2">2</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_has_type" class="judgment"><b>:</b></a> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub></td></tr><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a><b> |- </b><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_subtype_of" class="judgment"><b>&lt;:</b></a> (element *)?</td></tr></table></td></tr></table></td></tr><tr><td><hr style="color:black" size="1" noshade="noshade"/></td></tr><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>insert nodes <em>Expr</em><sub><font size="2">1</font></sub> ((as (first | last))? into) <em>Expr</em><sub><font size="2">2</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_has_type" class="judgment"><b>:</b></a> <code>empty</code></td></tr></table></td></tr></table></td></tr></table><br/></div><div align="center"><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a> <b> |- </b><em>Expr</em><sub><font size="2">1</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_has_type" class="judgment"><b>:</b></a> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub></td></tr><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a><b> |- </b><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
                (element * | text | comment | processing-instruction *)*</td></tr><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a> <b> |- </b><em>Expr</em><sub><font size="2">2</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_has_type" class="judgment"><b>:</b></a> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub></td></tr><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a><b> |- </b><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <font size="6">[</font>document-node()?<font size="6">]</font><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a></td></tr></table></td></tr></table></td></tr><tr><td><hr style="color:black" size="1" noshade="noshade"/></td></tr><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>insert nodes <em>Expr</em><sub><font size="2">1</font></sub> ((as (first | last))?
    	 into) <em>Expr</em><sub><font size="2">2</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_has_type" class="judgment"><b>:</b></a> <code>empty</code></td></tr></table></td></tr></table></td></tr></table><br/></div><p>In the case of an insert <code>before</code> or
        <code>after</code>, the type of the target node must be either
        an element, text, comment or processing-instruction node. This
        is expressed by the following rule.</p><div align="center"><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a> <b> |- </b><em>Expr</em><sub><font size="2">1</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_has_type" class="judgment"><b>:</b></a> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub></td></tr><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a><b> |- </b><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
                (attribute *)*, (element * | text | comment | processing-instruction *)*</td></tr><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a> <b> |- </b><em>Expr</em><sub><font size="2">2</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_has_type" class="judgment"><b>:</b></a> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub></td></tr><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a><b> |- </b><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_subtype_of" class="judgment"><b>&lt;:</b></a> (element * | text | comment | processing-instruction *)?</td></tr></table></td></tr></table></td></tr><tr><td><hr style="color:black" size="1" noshade="noshade"/></td></tr><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>insert nodes <em>Expr</em><sub><font size="2">1</font></sub> (after | before) <em>Expr</em><sub><font size="2">2</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_has_type" class="judgment"><b>:</b></a> <code>empty</code></td></tr></table></td></tr></table></td></tr></table><br/></div></div><div class="div3">
<h4><a name="id-update-typing-delete" id="id-update-typing-delete"/>4.5.2 Delete</h4><p><b><a href="http://www.w3.org/TR/xquery-semantics/#processing_normalization" class="processing">Normalization</a></b></p><p>The following normalization rule applies to delete
      expressions.  Note that whether the expression is written using
      the 'nodes' or 'node' modifier, the normalized expression always
      uses the 'nodes' modifier.</p><div align="center"><table summary="" cellspacing="0" cellpadding="0"><tr><td> </td></tr><tr><td align="center" style="margin-right:1cm;">
       <font size="6">[</font>delete (node|nodes) <em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
      </td></tr><tr><td align="center"><b>==</b></td></tr><tr><td align="center" style="margin-right:1cm;">
       delete nodes <font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
      </td></tr></table></div><p><b><a href="http://www.w3.org/TR/xquery-semantics/#processing_static" class="processing">Static Type Analysis</a></b></p><p>The static typing rule for delete is as follows.</p><div align="center"><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a> <b> |- </b><em>Expr</em> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_has_type" class="judgment"><b>:</b></a> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a></td></tr><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a><b> |- </b><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <font size="6">[</font>node()*<font size="6">]</font><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a></td></tr></table></td></tr></table></td></tr><tr><td><hr style="color:black" size="1" noshade="noshade"/></td></tr><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>delete (node|nodes) <em>Expr</em> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_has_type" class="judgment"><b>:</b></a> <code>empty</code></td></tr></table></td></tr></table></td></tr></table><br/></div></div><div class="div3">
<h4><a name="id-update-typing-replace" id="id-update-typing-replace"/>4.5.3 Replace</h4><p><b><a href="http://www.w3.org/TR/xquery-semantics/#processing_normalization" class="processing">Normalization</a></b></p><p>The following normalization rules applies to replace
      expressions.</p><div align="center"><table summary="" cellspacing="0" cellpadding="0"><tr><td> </td></tr><tr><td align="center" style="margin-right:1cm;">
       <font size="6">[</font>replace node <em>Expr</em><sub><font size="2">1</font></sub> with <em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
      </td></tr><tr><td align="center"><b>==</b></td></tr><tr><td align="center" style="margin-right:1cm;">
       replace node <font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> with <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a>(<font size="6">[</font><em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)
      </td></tr></table></div><p>Normalization of replace value of expressions.</p><div align="center"><table summary="" cellspacing="0" cellpadding="0"><tr><td> </td></tr><tr><td align="center" style="margin-right:1cm;">
       <font size="6">[</font>replace value of node <em>Expr</em><sub><font size="2">1</font></sub> with <em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
      </td></tr><tr><td align="center"><b>==</b></td></tr><tr><td align="center" style="margin-right:1cm;">
       replace value of node <font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> with
      <font size="6">[</font>text { <em>Expr</em><sub><font size="2">2</font></sub> }<font size="6">]</font><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
      </td></tr></table></div><p><b><a href="http://www.w3.org/TR/xquery-semantics/#processing_static" class="processing">Static Type Analysis</a></b></p><p>If the <code>value of</code> modifier is not specified, a
    replace expression replaces one node with a new sequence of zero
    or more nodes.</p><p>An attribute node can be replaced only by zero or more
    attribute nodes.</p><div align="center"><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a> <b> |- </b><em>Expr</em><sub><font size="2">1</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_has_type" class="judgment"><b>:</b></a> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub></td></tr><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a><b> |- </b><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_subtype_of" class="judgment"><b>&lt;:</b></a> (attribute *)?</td></tr><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a> <b> |- </b><em>Expr</em><sub><font size="2">2</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_has_type" class="judgment"><b>:</b></a> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub></td></tr><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a><b> |- </b><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_subtype_of" class="judgment"><b>&lt;:</b></a> (attribute *)*</td></tr></table></td></tr></table></td></tr><tr><td><hr style="color:black" size="1" noshade="noshade"/></td></tr><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>replace node <em>Expr</em><sub><font size="2">1</font></sub> with <em>Expr</em><sub><font size="2">2</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_has_type" class="judgment"><b>:</b></a> <code>empty</code></td></tr></table></td></tr></table></td></tr></table><br/></div><p>An element, text, comment, or processing instruction node can
    be replaced only by zero or more element, text, comment, or
    processing instruction nodes.</p><div align="center"><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a> <b> |- </b><em>Expr</em><sub><font size="2">1</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_has_type" class="judgment"><b>:</b></a> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub></td></tr><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a><b> |- </b><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_subtype_of" class="judgment"><b>&lt;:</b></a> (element * | text | comment | processing-instruction *)?</td></tr><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a> <b> |- </b><em>Expr</em><sub><font size="2">2</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_has_type" class="judgment"><b>:</b></a> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub></td></tr><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a><b> |- </b><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_subtype_of" class="judgment"><b>&lt;:</b></a> (element * | text | comment | processing-instruction *)*</td></tr></table></td></tr></table></td></tr><tr><td><hr style="color:black" size="1" noshade="noshade"/></td></tr><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>replace node <em>Expr</em><sub><font size="2">1</font></sub> with <em>Expr</em><sub><font size="2">2</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_has_type" class="judgment"><b>:</b></a> <code>empty</code></td></tr></table></td></tr></table></td></tr></table><br/></div><p>If the <code>value of</code> modifier is specified, a
    	replace expression replaces the content of a single node,
    	which must not be a document node by either a single text node
    	or empty.</p><div align="center"><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a> <b> |- </b><em>Expr</em><sub><font size="2">1</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_has_type" class="judgment"><b>:</b></a> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub></td></tr><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a><b> |- </b><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_subtype_of" class="judgment"><b>&lt;:</b></a> (attribute *| element * | text | comment | processing-instruction *)?</td></tr><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a> <b> |- </b><em>Expr</em><sub><font size="2">2</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_has_type" class="judgment"><b>:</b></a> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub></td></tr><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a><b> |- </b><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_subtype_of" class="judgment"><b>&lt;:</b></a> text?</td></tr></table></td></tr></table></td></tr><tr><td><hr style="color:black" size="1" noshade="noshade"/></td></tr><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>replace value of node <em>Expr</em><sub><font size="2">1</font></sub> with <em>Expr</em><sub><font size="2">2</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_has_type" class="judgment"><b>:</b></a> <code>empty</code></td></tr></table></td></tr></table></td></tr></table><br/></div></div><div class="div3">
<h4><a name="id-update-typing-rename" id="id-update-typing-rename"/>4.5.4 Rename</h4><p><b><a href="http://www.w3.org/TR/xquery-semantics/#processing_normalization" class="processing">Normalization</a></b></p><p>The following normalization rule applies to rename
      expressions.</p><div align="center"><table summary="" cellspacing="0" cellpadding="0"><tr><td> </td></tr><tr><td align="center" style="margin-right:1cm;">
       <font size="6">[</font>rename node <em>Expr</em><sub><font size="2">1</font></sub> as <em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
      </td></tr><tr><td align="center"><b>==</b></td></tr><tr><td align="center" style="margin-right:1cm;">
       rename node <font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> as <code>fn:data</code>(<font size="6">[</font><em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)
      </td></tr></table></div><p><b><a href="http://www.w3.org/TR/xquery-semantics/#processing_static" class="processing">Static Type Analysis</a></b></p><p>The target of a rename expression must be either an
    	element, attribute or processing-instruction, and its new name
    	must be either of type <code>xs:QName</code>, <code>xs:string</code>, or
    	<a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>.</p><div align="center"><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a> <b> |- </b><em>Expr</em><sub><font size="2">1</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_has_type" class="judgment"><b>:</b></a> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub></td></tr><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a><b> |- </b><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_subtype_of" class="judgment"><b>&lt;:</b></a> (attribute *| element * | processing-instruction *)?</td></tr><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a> <b> |- </b><em>Expr</em><sub><font size="2">2</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_has_type" class="judgment"><b>:</b></a> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub></td></tr><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a><b> |- </b><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_subtype_of" class="judgment"><b>&lt;:</b></a> (<code>xs:QName</code> | <code>xs:string</code> | <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#dt-xs_untypedAtomic"><code>xs:untypedAtomic</code></a>)</td></tr></table></td></tr></table></td></tr><tr><td><hr style="color:black" size="1" noshade="noshade"/></td></tr><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>rename node <em>Expr</em><sub><font size="2">1</font></sub> as <em>Expr</em><sub><font size="2">2</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_has_type" class="judgment"><b>:</b></a> <code>empty</code></td></tr></table></td></tr></table></td></tr></table><br/></div></div><div class="div3">
<h4><a name="id-update-typing-transform" id="id-update-typing-transform"/>4.5.5 Transform</h4><p><b><a href="http://www.w3.org/TR/xquery-semantics/#processing_normalization" class="processing">Normalization</a></b></p><p>The following normalization rule applies to transform
      expressions.</p><div align="center"><table summary="" cellspacing="0" cellpadding="0"><tr><td> </td></tr><tr><td align="center" style="margin-right:1cm;">
       <font size="6">[</font>
        <table summary=""><tbody><tr><td>copy</td></tr><tr><td>  <em>VarName</em><sub><font size="2">1</font></sub> := <em>Expr</em><sub><font size="2">1</font></sub></td></tr><tr><td>    ...</td></tr><tr><td>  <em>VarName</em><sub><font size="2">n</font></sub> := <em>Expr</em><sub><font size="2">n</font></sub></td></tr><tr><td>  modify <em>Expr</em><sub><font size="2">0</font></sub> return <em>Expr</em><sub><font size="2">r</font></sub></td></tr></tbody></table>
       <font size="6">]</font><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
      </td></tr><tr><td align="center"><b>==</b></td></tr><tr><td align="center" style="margin-right:1cm;">
        <table summary=""><tbody><tr><td>copy</td></tr><tr><td>  <em>VarName</em><sub><font size="2">1</font></sub> := <span title="Bug 5666 comment 1" class="diff-del"><!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a>(</span></span><font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a><span class="diff-del"><!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>)</span></span></td></tr><tr><td>    ...</td></tr><tr><td>  <em>VarName</em><sub><font size="2">n</font></sub> := <span title="Bug 5666 comment 1" class="diff-del"><!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a>(</span></span><font size="6">[</font><em>Expr</em><sub><font size="2">n</font></sub><font size="6">]</font><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a><span class="diff-del"><!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>)</span></span></td></tr><tr><td>  modify <font size="6">[</font><em>Expr</em><sub><font size="2">0</font></sub><font size="6">]</font><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> return <font size="6">[</font><em>Expr</em><sub><font size="2">r</font></sub><font size="6">]</font><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a></td></tr></tbody></table>
      </td></tr></table></div><p><b><a href="http://www.w3.org/TR/xquery-semantics/#processing_static" class="processing">Static Type Analysis</a></b></p><p>The transform expression is type checked using the following
      inference rule.</p><div align="center"><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a> <b> |- </b><em>Expr</em><sub><font size="2">1</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_has_type" class="judgment"><b>:</b></a> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub></td></tr><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a><b> |- </b> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <font size="6">[</font>node()<font size="6">]</font><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a></td></tr><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a><b> |- </b><em>VarName</em><sub><font size="2">1</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a> <em>Variable</em><sub><font size="2">1</font></sub>
 	        </td></tr><tr align="center" valign="middle"><td>
                    <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub> =
                    <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a> + <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_type_env" class="env">varType</a>(<em>Variable</em><sub><font size="2">1</font></sub> =&gt; <span title="Bug 6677 comment 4" class="diff-del"><!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub></span></span><span title="Bug 6677 comment 4" class="diff-add"><!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span><font size="6">[</font>node()<font size="6">]</font><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a></span></span>) 
                  </td></tr><tr align="center" valign="middle"><td>...</td></tr><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">n-1</font></sub><b> |- </b> <em>Expr</em><sub><font size="2">n</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_has_type" class="judgment"><b>:</b></a> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub> </td></tr><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">n-1</font></sub><b> |- </b> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <font size="6">[</font>node()<font size="6">]</font><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a></td></tr><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a><b> |- </b><em>VarName</em><sub><font size="2">n</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a> <em>Variable</em><sub><font size="2">n</font></sub>
 	        </td></tr><tr align="center" valign="middle"><td>
                    <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">n</font></sub> =
                    <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">n-1</font></sub> + <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_type_env" class="env">varType</a>(<em>Variable</em><sub><font size="2">n</font></sub> =&gt; <span title="Bug 6677 comment 4" class="diff-del"><!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub></span></span><span title="Bug 6677 comment 4" class="diff-add"><!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span><font size="6">[</font>node()<font size="6">]</font><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a></span></span>) 
                  </td></tr><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">n</font></sub><b> |- </b> <em>Expr</em><sub><font size="2">0</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_has_type" class="judgment"><b>:</b></a> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub> </td></tr><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">n</font></sub><b> |- </b> <em>Expr</em><sub><font size="2">r</font></sub> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_has_type" class="judgment"><b>:</b></a> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">r</font></sub> </td></tr></table></td></tr></table></td></tr><tr><td><hr style="color:black" size="1" noshade="noshade"/></td></tr><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><table summary="" cellspacing="0" cellpadding="0"><tr align="center" valign="middle"><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
        <table summary=""><tbody><tr><td>copy</td></tr><tr><td>  <em>VarName</em><sub><font size="2">1</font></sub> := <em>Expr</em><sub><font size="2">1</font></sub></td></tr><tr><td>    ...</td></tr><tr><td>  <em>VarName</em><sub><font size="2">n</font></sub> := <em>Expr</em><sub><font size="2">n</font></sub></td></tr><tr><td>  modify <em>Expr</em><sub><font size="2">0</font></sub> return <em>Expr</em><sub><font size="2">r</font></sub></td></tr><tr><td><a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#jd_has_type" class="judgment"><b>:</b></a> <a href="http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/#doc-fs-Type"><em>Type</em></a><sub><font size="2">r</font></sub></td></tr></tbody></table>
      </td></tr></table></td></tr></table></td></tr></table><br/></div></div><div class="div3">
<h4><a name="id-update-typing-examples" id="id-update-typing-examples"/>4.5.6 Examples</h4><p><b>Examples</b></p><p>Here are a few example queries and their corresponding
       static typing. In each case, if the query passes static typing,
       its static type is the empty type.</p><ul><li><p><code>insert node &lt;x/&gt; into &lt;a/&gt;</code></p><p>Passes static typing</p></li><li><p><code>insert node 1 into &lt;a/&gt;</code></p><p>Passes static typing</p></li><li><p><code>insert node 1 into (&lt;a/&gt;,&lt;a/&gt;)</code></p><p>Fails static typing because the target expression does
  not return a single node</p></li><li><p><code>insert node (element a {()}, attribute b {()}) into &lt;doc/&gt;</code></p><p>Fails static typing because the attribute node is not
  at the head of the insertion list</p></li><li><p><code>insert node &lt;x/&gt; into //a</code></p><p>Fails static typing because the target expression must not
  return a single node (assuming the schema allows <code>//a</code>
  to return multiple <code>a</code> elements)</p></li><li><p><code>rename node &lt;a/&gt; as "b"</code></p><p>Passes static typing</p></li><li><p><code>rename node &lt;a/&gt; as 1</code></p><p>Fails static typing because the new name does not have
  one of the permissible types</p></li></ul></div></div></div><div class="div1">
<h2><a name="id-xquery-update-conformance" id="id-xquery-update-conformance"/>5 Conformance</h2><p>This section defines the conformance criteria for an XQuery processor. In this section, the
        following terms are used to indicate the requirement levels defined in
        <a href="#RFC2119">[RFC 2119]</a>. [<a name="must" id="must" title="must">Definition</a>: 
            <b>MUST</b> means that the item is an absolute requirement of the specification.]
        [<a name="may" id="may" title="may">Definition</a>: 
            <b>MAY</b> means that an item is truly optional.]
        [<a name="should" id="should" title="should">Definition</a>: 
            <b>SHOULD</b> means that there may exist valid reasons in particular circumstances
            to ignore a particular item, but the full implications must be understood and carefully
            weighed before choosing a different course.]
    </p><p>An XQuery processor that claims to conform to this specification
        <a title="must" href="#must">MUST</a> include a claim of Minimal Conformance as defined in
        <a href="#id-minimal-conformance"><b>[5.1 Minimal Conformance]</b></a>. In addition to a claim of Minimal Conformance, it
        <a title="may" href="#may">MAY</a> claim conformance to one or more optional features
        defined in <a href="#id-conform-optional-features"><b>[5.2 Optional Features]</b></a>.</p><div class="div2">
<h3><a name="id-minimal-conformance" id="id-minimal-conformance"/>5.1 Minimal Conformance</h3><p>Minimal Conformance to this specification <a title="must" href="#must">MUST</a> include all
            of the following items:</p><ol class="enumar"><li><p>Minimal Conformance to <a href="#xquery">[XQuery 1.0]</a>.</p></li><li><p>Support for everything specified in this document
                except those features specified in <a href="#id-conform-optional-features"><b>[5.2 Optional Features]</b></a> to be optional
                and <a href="#id-xquf-xqueryx"><b>[E XML Syntax (XQueryX) for XQuery Update Facility 1.0]</b></a>. If an
                implementation does not provide a given optional
                feature, it <a title="must" href="#must">MUST</a>
                implement any requirements specified in <a href="#id-conform-optional-features"><b>[5.2 Optional Features]</b></a> for
                implementations that do not provide that feature.</p></li><li><p>A definition of every item specified to be implementation-defined,
	      unless that item is part of an optional feature that is
	      not supported by the implementation. A list of implementation-defined
	      items can be found in <a href="#id-impl-defs"><b>[B Implementation-Defined Items]</b></a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Implementations are not required to define
                    items specified to be implementation-dependent.</p></div></li></ol></div><div class="div2">
<h3><a name="id-conform-optional-features" id="id-conform-optional-features"/>5.2 Optional Features</h3><p>An implementation of XQuery that includes the Update
	    Facility   <a title="may" href="#may">MAY</a> also support the Optional Features of <a href="#xquery">[XQuery 1.0]</a>. These are Schema Import Feature, Schema
	    Validation Feature, Static Typing Feature, Full Axis
	    Feature, Module Feature, and Serialization Feature.</p><p>If an implementation claims support of the Static
	    Typing Feature, then it   <a title="may" href="#may">MAY</a> also claim support of the
	    Update Facility Static Typing Feature.</p><div class="div3">
<h4><a name="id-update-facility-static-typing-feature" id="id-update-facility-static-typing-feature"/>5.2.1 Update Facility Static Typing Feature</h4><p>
                [<a name="upd-static-typing-feature" id="upd-static-typing-feature" title="static typing feature">Definition</a>: The <b>Update
                Facility Static Typing Feature</b> provides support
                for the static semantics defined in <a href="#id-update-static"><b>[4 Static Typing Feature]</b></a>,
                and requires implementations to detect and report type errors
                during the static analysis phase.]
                </p><p>If an implementation does not support the <a title="static typing feature" href="#upd-static-typing-feature">Update Static Typing
            Feature</a>, but can nevertheless determine during
            the static analysis phase that an expression, if
            evaluated, will necessarily raise a type error at run
            time, the implementation <a title="may" href="#may">MAY</a>
            raise that error during the static analysis phase. The
            choice of whether to raise such an error at analysis time
            is implementation-dependent.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>An implementation that does not support the
                <a title="static typing feature" href="#upd-static-typing-feature">Update Static Typing
                Feature</a> is not required to raise type errors
                during the static analysis phase; however, it <a title="must" href="#must">MUST</a> detect and raise
                non-type-related static errors during the static
                analysis phase.</p></div></div></div></div><div class="div1">
<h2><a name="id-xqueryx-update-conformance" id="id-xqueryx-update-conformance"/>6 XQueryX Conformance</h2><p>This section defines the conformance criteria for an XQueryX processor 
that includes the Update Facility.</p><p>In this section, the terms <a title="must" href="#must">MUST</a>, <a title="may" href="#may">MAY</a>, and <a title="should" href="#should">SHOULD</a> are used as
defined in <a href="#id-xquery-update-conformance"><b>[5 Conformance]</b></a>.</p><p>An XQueryX processor that claims to conform to this specification
<a title="must" href="#must">MUST</a> implement the XQueryX syntax as defined
in <a href="#id-xquf-xqueryx"><b>[E XML Syntax (XQueryX) for XQuery Update Facility 1.0]</b></a> and include a claim of Minimal
Conformance as defined in <a href="#id-minimal-conformance"><b>[5.1 Minimal Conformance]</b></a>. 
In addition to a claim of
Minimal Conformance, it <a title="may" href="#may">MAY</a> claim conformance to one or more optional
features defined in <a href="#id-conform-optional-features"><b>[5.2 Optional Features]</b></a>.</p></div></div><div class="back"><div class="div1">
<h2><a name="id-grammar" id="id-grammar"/>A EBNF for XQuery 1.0 Grammar with Update extensions</h2><p>The EBNF in this document and in this section is aligned with
the current XML Query 1.0 grammar (see <a href="#xquery">[XQuery 1.0]</a>).</p>
<h5><a name="d8e7652" id="d8e7652"/></h5><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="prod-xquery-Module" id="prod-xquery-Module"/>[<small>1</small>]   </td><td><code>Module</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-VersionDecl">VersionDecl</a>?  (<a href="#prod-xquery-LibraryModule">LibraryModule</a>  |  <a href="#prod-xquery-MainModule">MainModule</a>)</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-VersionDecl" id="prod-xquery-VersionDecl"/>[<small>2</small>]   </td><td><code>VersionDecl</code></td><td>   ::=   </td><td><code>"xquery"  "version"  <a href="#prod-xquery-StringLiteral">StringLiteral</a>  ("encoding"  <a href="#prod-xquery-StringLiteral">StringLiteral</a>)?  <a href="#prod-xquery-Separator">Separator</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-MainModule" id="prod-xquery-MainModule"/>[<small>3</small>]   </td><td><code>MainModule</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-Prolog">Prolog</a>  <a href="#prod-xquery-QueryBody">QueryBody</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-LibraryModule" id="prod-xquery-LibraryModule"/>[<small>4</small>]   </td><td><code>LibraryModule</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-ModuleDecl">ModuleDecl</a>  <a href="#prod-xquery-Prolog">Prolog</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-ModuleDecl" id="prod-xquery-ModuleDecl"/>[<small>5</small>]   </td><td><code>ModuleDecl</code></td><td>   ::=   </td><td><code>"module"  "namespace"  <a href="#prod-xquery-NCName">NCName</a>  "="  <a href="#prod-xquery-URILiteral">URILiteral</a>  <a href="#prod-xquery-Separator">Separator</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-Prolog" id="prod-xquery-Prolog"/>[<small>6</small>]   </td><td><code>Prolog</code></td><td>   ::=   </td><td><code>((<a href="#prod-xquery-DefaultNamespaceDecl">DefaultNamespaceDecl</a>  |  <a href="#prod-xquery-Setter">Setter</a>  |  <a href="#prod-xquery-NamespaceDecl">NamespaceDecl</a>  |  <a href="#prod-xquery-Import">Import</a>)  <a href="#prod-xquery-Separator">Separator</a>)*  ((<a href="#prod-xquery-VarDecl">VarDecl</a>  |  <a href="#prod-xquery-FunctionDecl">FunctionDecl</a>  |  <a href="#prod-xquery-OptionDecl">OptionDecl</a>)  <a href="#prod-xquery-Separator">Separator</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-Setter" id="prod-xquery-Setter"/>[<small>7</small>]   </td><td><code><a href="#doc-xquery-Setter"><a href="#doc-xquery-Setter">Setter</a></a></code></td><td>   ::=   </td><td><code><a href="#prod-xquery-BoundarySpaceDecl">BoundarySpaceDecl</a>  |  <a href="#prod-xquery-DefaultCollationDecl">DefaultCollationDecl</a>  |  <a href="#prod-xquery-BaseURIDecl">BaseURIDecl</a>  |  <a href="#prod-xquery-ConstructionDecl">ConstructionDecl</a>  |  <a href="#prod-xquery-OrderingModeDecl">OrderingModeDecl</a>  |  <a href="#prod-xquery-EmptyOrderDecl">EmptyOrderDecl</a>  |  <a href="#prod-xquery-RevalidationDecl">RevalidationDecl</a>  |  <a href="#prod-xquery-CopyNamespacesDecl">CopyNamespacesDecl</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-Import" id="prod-xquery-Import"/>[<small>8</small>]   </td><td><code>Import</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-SchemaImport">SchemaImport</a>  |  <a href="#prod-xquery-ModuleImport">ModuleImport</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-Separator" id="prod-xquery-Separator"/>[<small>9</small>]   </td><td><code>Separator</code></td><td>   ::=   </td><td><code>";"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-NamespaceDecl" id="prod-xquery-NamespaceDecl"/>[<small>10</small>]   </td><td><code>NamespaceDecl</code></td><td>   ::=   </td><td><code>"declare"  "namespace"  <a href="#prod-xquery-NCName">NCName</a>  "="  <a href="#prod-xquery-URILiteral">URILiteral</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-BoundarySpaceDecl" id="prod-xquery-BoundarySpaceDecl"/>[<small>11</small>]   </td><td><code>BoundarySpaceDecl</code></td><td>   ::=   </td><td><code>"declare"  "boundary-space"  ("preserve"  |  "strip")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-DefaultNamespaceDecl" id="prod-xquery-DefaultNamespaceDecl"/>[<small>12</small>]   </td><td><code>DefaultNamespaceDecl</code></td><td>   ::=   </td><td><code>"declare"  "default"  ("element"  |  "function")  "namespace"  <a href="#prod-xquery-URILiteral">URILiteral</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-OptionDecl" id="prod-xquery-OptionDecl"/>[<small>13</small>]   </td><td><code>OptionDecl</code></td><td>   ::=   </td><td><code>"declare"  "option"  <a href="#prod-xquery-QName">QName</a>  <a href="#prod-xquery-StringLiteral">StringLiteral</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-OrderingModeDecl" id="prod-xquery-OrderingModeDecl"/>[<small>14</small>]   </td><td><code>OrderingModeDecl</code></td><td>   ::=   </td><td><code>"declare"  "ordering"  ("ordered"  |  "unordered")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-EmptyOrderDecl" id="prod-xquery-EmptyOrderDecl"/>[<small>15</small>]   </td><td><code>EmptyOrderDecl</code></td><td>   ::=   </td><td><code>"declare"  "default"  "order"  "empty"  ("greatest"  |  "least")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-CopyNamespacesDecl" id="prod-xquery-CopyNamespacesDecl"/>[<small>16</small>]   </td><td><code>CopyNamespacesDecl</code></td><td>   ::=   </td><td><code>"declare"  "copy-namespaces"  <a href="#prod-xquery-PreserveMode">PreserveMode</a>  ","  <a href="#prod-xquery-InheritMode">InheritMode</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-PreserveMode" id="prod-xquery-PreserveMode"/>[<small>17</small>]   </td><td><code>PreserveMode</code></td><td>   ::=   </td><td><code>"preserve"  |  "no-preserve"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-InheritMode" id="prod-xquery-InheritMode"/>[<small>18</small>]   </td><td><code>InheritMode</code></td><td>   ::=   </td><td><code>"inherit"  |  "no-inherit"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-DefaultCollationDecl" id="prod-xquery-DefaultCollationDecl"/>[<small>19</small>]   </td><td><code>DefaultCollationDecl</code></td><td>   ::=   </td><td><code>"declare"  "default"  "collation"  <a href="#prod-xquery-URILiteral">URILiteral</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-BaseURIDecl" id="prod-xquery-BaseURIDecl"/>[<small>20</small>]   </td><td><code>BaseURIDecl</code></td><td>   ::=   </td><td><code>"declare"  "base-uri"  <a href="#prod-xquery-URILiteral">URILiteral</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-SchemaImport" id="prod-xquery-SchemaImport"/>[<small>21</small>]   </td><td><code>SchemaImport</code></td><td>   ::=   </td><td><code>"import"  "schema"  <a href="#prod-xquery-SchemaPrefix">SchemaPrefix</a>?  <a href="#prod-xquery-URILiteral">URILiteral</a>  ("at"  <a href="#prod-xquery-URILiteral">URILiteral</a>  (","  <a href="#prod-xquery-URILiteral">URILiteral</a>)*)?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-SchemaPrefix" id="prod-xquery-SchemaPrefix"/>[<small>22</small>]   </td><td><code>SchemaPrefix</code></td><td>   ::=   </td><td><code>("namespace"  <a href="#prod-xquery-NCName">NCName</a>  "=")  |  ("default"  "element"  "namespace")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-ModuleImport" id="prod-xquery-ModuleImport"/>[<small>23</small>]   </td><td><code>ModuleImport</code></td><td>   ::=   </td><td><code>"import"  "module"  ("namespace"  <a href="#prod-xquery-NCName">NCName</a>  "=")?  <a href="#prod-xquery-URILiteral">URILiteral</a>  ("at"  <a href="#prod-xquery-URILiteral">URILiteral</a>  (","  <a href="#prod-xquery-URILiteral">URILiteral</a>)*)?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-VarDecl" id="prod-xquery-VarDecl"/>[<small>24</small>]   </td><td><code>VarDecl</code></td><td>   ::=   </td><td><code>"declare"  "variable"  "$"  <a href="#prod-xquery-QName">QName</a>  <a href="#prod-xquery-TypeDeclaration">TypeDeclaration</a>?  ((":="  <a href="#prod-xquery-ExprSingle">ExprSingle</a>)  |  "external")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-ConstructionDecl" id="prod-xquery-ConstructionDecl"/>[<small>25</small>]   </td><td><code>ConstructionDecl</code></td><td>   ::=   </td><td><code>"declare"  "construction"  ("strip"  |  "preserve")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-FunctionDecl" id="prod-xquery-FunctionDecl"/>[<small>26</small>]   </td><td><code><a href="#doc-xquery-FunctionDecl"><a href="#doc-xquery-FunctionDecl">FunctionDecl</a></a></code></td><td>   ::=   </td><td><code>"declare"  "updating"?  "function"  <a href="#prod-xquery-QName">QName</a>  "("  <a href="#prod-xquery-ParamList">ParamList</a>?  ")"  ("as"  <a href="#prod-xquery-SequenceType">SequenceType</a>)?  (<a href="#prod-xquery-EnclosedExpr">EnclosedExpr</a>  |  "external")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-ParamList" id="prod-xquery-ParamList"/>[<small>27</small>]   </td><td><code>ParamList</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-Param">Param</a>  (","  <a href="#prod-xquery-Param">Param</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-Param" id="prod-xquery-Param"/>[<small>28</small>]   </td><td><code>Param</code></td><td>   ::=   </td><td><code>"$"  <a href="#prod-xquery-QName">QName</a>  <a href="#prod-xquery-TypeDeclaration">TypeDeclaration</a>?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-EnclosedExpr" id="prod-xquery-EnclosedExpr"/>[<small>29</small>]   </td><td><code>EnclosedExpr</code></td><td>   ::=   </td><td><code>"{"  <a href="#prod-xquery-Expr">Expr</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-QueryBody" id="prod-xquery-QueryBody"/>[<small>30</small>]   </td><td><code>QueryBody</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-Expr">Expr</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-Expr" id="prod-xquery-Expr"/>[<small>31</small>]   </td><td><code>Expr</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-ExprSingle">ExprSingle</a>  (","  <a href="#prod-xquery-ExprSingle">ExprSingle</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-ExprSingle" id="prod-xquery-ExprSingle"/>[<small>32</small>]   </td><td><code><a href="#doc-xquery-ExprSingle"><a href="#doc-xquery-ExprSingle">ExprSingle</a></a></code></td><td>   ::=   </td><td><code><a href="#prod-xquery-FLWORExpr">FLWORExpr</a><br/>|  <a href="#prod-xquery-QuantifiedExpr">QuantifiedExpr</a><br/>|  <a href="#prod-xquery-TypeswitchExpr">TypeswitchExpr</a><br/>|  <a href="#prod-xquery-IfExpr">IfExpr</a><br/>|  <a href="#prod-xquery-InsertExpr">InsertExpr</a><br/>|  <a href="#prod-xquery-DeleteExpr">DeleteExpr</a><br/>|  <a href="#prod-xquery-RenameExpr">RenameExpr</a><br/>|  <a href="#prod-xquery-ReplaceExpr">ReplaceExpr</a><br/>|  <a href="#prod-xquery-TransformExpr">TransformExpr</a><br/>|  <a href="#prod-xquery-OrExpr">OrExpr</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-FLWORExpr" id="prod-xquery-FLWORExpr"/>[<small>33</small>]   </td><td><code>FLWORExpr</code></td><td>   ::=   </td><td><code>(<a href="#prod-xquery-ForClause">ForClause</a>  |  <a href="#prod-xquery-LetClause">LetClause</a>)+  <a href="#prod-xquery-WhereClause">WhereClause</a>?  <a href="#prod-xquery-OrderByClause">OrderByClause</a>?  "return"  <a href="#prod-xquery-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-ForClause" id="prod-xquery-ForClause"/>[<small>34</small>]   </td><td><code>ForClause</code></td><td>   ::=   </td><td><code>"for"  "$"  <a href="#prod-xquery-VarName">VarName</a>  <a href="#prod-xquery-TypeDeclaration">TypeDeclaration</a>?  <a href="#prod-xquery-PositionalVar">PositionalVar</a>?  "in"  <a href="#prod-xquery-ExprSingle">ExprSingle</a>  (","  "$"  <a href="#prod-xquery-VarName">VarName</a>  <a href="#prod-xquery-TypeDeclaration">TypeDeclaration</a>?  <a href="#prod-xquery-PositionalVar">PositionalVar</a>?  "in"  <a href="#prod-xquery-ExprSingle">ExprSingle</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-PositionalVar" id="prod-xquery-PositionalVar"/>[<small>35</small>]   </td><td><code>PositionalVar</code></td><td>   ::=   </td><td><code>"at"  "$"  <a href="#prod-xquery-VarName">VarName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-LetClause" id="prod-xquery-LetClause"/>[<small>36</small>]   </td><td><code>LetClause</code></td><td>   ::=   </td><td><code>"let"  "$"  <a href="#prod-xquery-VarName">VarName</a>  <a href="#prod-xquery-TypeDeclaration">TypeDeclaration</a>?  ":="  <a href="#prod-xquery-ExprSingle">ExprSingle</a>  (","  "$"  <a href="#prod-xquery-VarName">VarName</a>  <a href="#prod-xquery-TypeDeclaration">TypeDeclaration</a>?  ":="  <a href="#prod-xquery-ExprSingle">ExprSingle</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-WhereClause" id="prod-xquery-WhereClause"/>[<small>37</small>]   </td><td><code>WhereClause</code></td><td>   ::=   </td><td><code>"where"  <a href="#prod-xquery-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-OrderByClause" id="prod-xquery-OrderByClause"/>[<small>38</small>]   </td><td><code>OrderByClause</code></td><td>   ::=   </td><td><code>(("order"  "by")  |  ("stable"  "order"  "by"))  <a href="#prod-xquery-OrderSpecList">OrderSpecList</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-OrderSpecList" id="prod-xquery-OrderSpecList"/>[<small>39</small>]   </td><td><code>OrderSpecList</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-OrderSpec">OrderSpec</a>  (","  <a href="#prod-xquery-OrderSpec">OrderSpec</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-OrderSpec" id="prod-xquery-OrderSpec"/>[<small>40</small>]   </td><td><code>OrderSpec</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-ExprSingle">ExprSingle</a>  <a href="#prod-xquery-OrderModifier">OrderModifier</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-OrderModifier" id="prod-xquery-OrderModifier"/>[<small>41</small>]   </td><td><code>OrderModifier</code></td><td>   ::=   </td><td><code>("ascending"  |  "descending")?  ("empty"  ("greatest"  |  "least"))?  ("collation"  <a href="#prod-xquery-URILiteral">URILiteral</a>)?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-QuantifiedExpr" id="prod-xquery-QuantifiedExpr"/>[<small>42</small>]   </td><td><code>QuantifiedExpr</code></td><td>   ::=   </td><td><code>("some"  |  "every")  "$"  <a href="#prod-xquery-VarName">VarName</a>  <a href="#prod-xquery-TypeDeclaration">TypeDeclaration</a>?  "in"  <a href="#prod-xquery-ExprSingle">ExprSingle</a>  (","  "$"  <a href="#prod-xquery-VarName">VarName</a>  <a href="#prod-xquery-TypeDeclaration">TypeDeclaration</a>?  "in"  <a href="#prod-xquery-ExprSingle">ExprSingle</a>)*  "satisfies"  <a href="#prod-xquery-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-TypeswitchExpr" id="prod-xquery-TypeswitchExpr"/>[<small>43</small>]   </td><td><code>TypeswitchExpr</code></td><td>   ::=   </td><td><code>"typeswitch"  "("  <a href="#prod-xquery-Expr">Expr</a>  ")"  <a href="#prod-xquery-CaseClause">CaseClause</a>+  "default"  ("$"  <a href="#prod-xquery-VarName">VarName</a>)?  "return"  <a href="#prod-xquery-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-CaseClause" id="prod-xquery-CaseClause"/>[<small>44</small>]   </td><td><code>CaseClause</code></td><td>   ::=   </td><td><code>"case"  ("$"  <a href="#prod-xquery-VarName">VarName</a>  "as")?  <a href="#prod-xquery-SequenceType">SequenceType</a>  "return"  <a href="#prod-xquery-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-IfExpr" id="prod-xquery-IfExpr"/>[<small>45</small>]   </td><td><code>IfExpr</code></td><td>   ::=   </td><td><code>"if"  "("  <a href="#prod-xquery-Expr">Expr</a>  ")"  "then"  <a href="#prod-xquery-ExprSingle">ExprSingle</a>  "else"  <a href="#prod-xquery-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-OrExpr" id="prod-xquery-OrExpr"/>[<small>46</small>]   </td><td><code>OrExpr</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-AndExpr">AndExpr</a> ( "or"  <a href="#prod-xquery-AndExpr">AndExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-AndExpr" id="prod-xquery-AndExpr"/>[<small>47</small>]   </td><td><code>AndExpr</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-ComparisonExpr">ComparisonExpr</a> ( "and"  <a href="#prod-xquery-ComparisonExpr">ComparisonExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-ComparisonExpr" id="prod-xquery-ComparisonExpr"/>[<small>48</small>]   </td><td><code>ComparisonExpr</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-RangeExpr">RangeExpr</a> ( (<a href="#prod-xquery-ValueComp">ValueComp</a><br/>|  <a href="#prod-xquery-GeneralComp">GeneralComp</a><br/>|  <a href="#prod-xquery-NodeComp">NodeComp</a>)  <a href="#prod-xquery-RangeExpr">RangeExpr</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-RangeExpr" id="prod-xquery-RangeExpr"/>[<small>49</small>]   </td><td><code>RangeExpr</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-AdditiveExpr">AdditiveExpr</a> ( "to"  <a href="#prod-xquery-AdditiveExpr">AdditiveExpr</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-AdditiveExpr" id="prod-xquery-AdditiveExpr"/>[<small>50</small>]   </td><td><code>AdditiveExpr</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-MultiplicativeExpr">MultiplicativeExpr</a> ( ("+"  |  "-")  <a href="#prod-xquery-MultiplicativeExpr">MultiplicativeExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-MultiplicativeExpr" id="prod-xquery-MultiplicativeExpr"/>[<small>51</small>]   </td><td><code>MultiplicativeExpr</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-UnionExpr">UnionExpr</a> ( ("*"  |  "div"  |  "idiv"  |  "mod")  <a href="#prod-xquery-UnionExpr">UnionExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-UnionExpr" id="prod-xquery-UnionExpr"/>[<small>52</small>]   </td><td><code>UnionExpr</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-IntersectExceptExpr">IntersectExceptExpr</a> ( ("union"  |  "|")  <a href="#prod-xquery-IntersectExceptExpr">IntersectExceptExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-IntersectExceptExpr" id="prod-xquery-IntersectExceptExpr"/>[<small>53</small>]   </td><td><code>IntersectExceptExpr</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-InstanceofExpr">InstanceofExpr</a> ( ("intersect"  |  "except")  <a href="#prod-xquery-InstanceofExpr">InstanceofExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-InstanceofExpr" id="prod-xquery-InstanceofExpr"/>[<small>54</small>]   </td><td><code>InstanceofExpr</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-TreatExpr">TreatExpr</a> ( "instance"  "of"  <a href="#prod-xquery-SequenceType">SequenceType</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-TreatExpr" id="prod-xquery-TreatExpr"/>[<small>55</small>]   </td><td><code>TreatExpr</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-CastableExpr">CastableExpr</a> ( "treat"  "as"  <a href="#prod-xquery-SequenceType">SequenceType</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-CastableExpr" id="prod-xquery-CastableExpr"/>[<small>56</small>]   </td><td><code>CastableExpr</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-CastExpr">CastExpr</a> ( "castable"  "as"  <a href="#prod-xquery-SingleType">SingleType</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-CastExpr" id="prod-xquery-CastExpr"/>[<small>57</small>]   </td><td><code>CastExpr</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-UnaryExpr">UnaryExpr</a> ( "cast"  "as"  <a href="#prod-xquery-SingleType">SingleType</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-UnaryExpr" id="prod-xquery-UnaryExpr"/>[<small>58</small>]   </td><td><code>UnaryExpr</code></td><td>   ::=   </td><td><code>("-"  |  "+")* <a href="#prod-xquery-ValueExpr">ValueExpr</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-ValueExpr" id="prod-xquery-ValueExpr"/>[<small>59</small>]   </td><td><code>ValueExpr</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-ValidateExpr">ValidateExpr</a>  |  <a href="#prod-xquery-PathExpr">PathExpr</a>  |  <a href="#prod-xquery-ExtensionExpr">ExtensionExpr</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-GeneralComp" id="prod-xquery-GeneralComp"/>[<small>60</small>]   </td><td><code>GeneralComp</code></td><td>   ::=   </td><td><code>"="  |  "!="  |  "&lt;"  |  "&lt;="  |  "&gt;"  |  "&gt;="</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-ValueComp" id="prod-xquery-ValueComp"/>[<small>61</small>]   </td><td><code>ValueComp</code></td><td>   ::=   </td><td><code>"eq"  |  "ne"  |  "lt"  |  "le"  |  "gt"  |  "ge"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-NodeComp" id="prod-xquery-NodeComp"/>[<small>62</small>]   </td><td><code>NodeComp</code></td><td>   ::=   </td><td><code>"is"  |  "&lt;&lt;"  |  "&gt;&gt;"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-ValidateExpr" id="prod-xquery-ValidateExpr"/>[<small>63</small>]   </td><td><code>ValidateExpr</code></td><td>   ::=   </td><td><code>"validate"  <a href="#prod-xquery-ValidationMode">ValidationMode</a>?  "{"  <a href="#prod-xquery-Expr">Expr</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-ValidationMode" id="prod-xquery-ValidationMode"/>[<small>64</small>]   </td><td><code>ValidationMode</code></td><td>   ::=   </td><td><code>"lax"  |  "strict"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-ExtensionExpr" id="prod-xquery-ExtensionExpr"/>[<small>65</small>]   </td><td><code>ExtensionExpr</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-Pragma">Pragma</a>+  "{"  <a href="#prod-xquery-Expr">Expr</a>?  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-Pragma" id="prod-xquery-Pragma"/>[<small>66</small>]   </td><td><code>Pragma</code></td><td>   ::=   </td><td><code>"(#"  <a href="#prod-xquery-S">S</a>?  <a href="#prod-xquery-QName">QName</a>  (<a href="#prod-xquery-S">S</a>  <a href="#prod-xquery-PragmaContents">PragmaContents</a>)?  "#)"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-PragmaContents" id="prod-xquery-PragmaContents"/>[<small>67</small>]   </td><td><code>PragmaContents</code></td><td>   ::=   </td><td><code>(<a href="#prod-xquery-Char">Char</a>* - (Char* '#)' Char*))</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-PathExpr" id="prod-xquery-PathExpr"/>[<small>68</small>]   </td><td><code>PathExpr</code></td><td>   ::=   </td><td><code>("/"  <a href="#prod-xquery-RelativePathExpr">RelativePathExpr</a>?)<br/>|  ("//"  <a href="#prod-xquery-RelativePathExpr">RelativePathExpr</a>)<br/>|  <a href="#prod-xquery-RelativePathExpr">RelativePathExpr</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-RelativePathExpr" id="prod-xquery-RelativePathExpr"/>[<small>69</small>]   </td><td><code>RelativePathExpr</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-StepExpr">StepExpr</a>  (("/"  |  "//")  <a href="#prod-xquery-StepExpr">StepExpr</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-StepExpr" id="prod-xquery-StepExpr"/>[<small>70</small>]   </td><td><code>StepExpr</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-FilterExpr">FilterExpr</a>  |  <a href="#prod-xquery-AxisStep">AxisStep</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-AxisStep" id="prod-xquery-AxisStep"/>[<small>71</small>]   </td><td><code>AxisStep</code></td><td>   ::=   </td><td><code>(<a href="#prod-xquery-ReverseStep">ReverseStep</a>  |  <a href="#prod-xquery-ForwardStep">ForwardStep</a>)  <a href="#prod-xquery-PredicateList">PredicateList</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-ForwardStep" id="prod-xquery-ForwardStep"/>[<small>72</small>]   </td><td><code>ForwardStep</code></td><td>   ::=   </td><td><code>(<a href="#prod-xquery-ForwardAxis">ForwardAxis</a>  <a href="#prod-xquery-NodeTest">NodeTest</a>)  |  <a href="#prod-xquery-AbbrevForwardStep">AbbrevForwardStep</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-ForwardAxis" id="prod-xquery-ForwardAxis"/>[<small>73</small>]   </td><td><code>ForwardAxis</code></td><td>   ::=   </td><td><code>("child"  "::")<br/>|  ("descendant"  "::")<br/>|  ("attribute"  "::")<br/>|  ("self"  "::")<br/>|  ("descendant-or-self"  "::")<br/>|  ("following-sibling"  "::")<br/>|  ("following"  "::")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-AbbrevForwardStep" id="prod-xquery-AbbrevForwardStep"/>[<small>74</small>]   </td><td><code>AbbrevForwardStep</code></td><td>   ::=   </td><td><code>"@"?  <a href="#prod-xquery-NodeTest">NodeTest</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-ReverseStep" id="prod-xquery-ReverseStep"/>[<small>75</small>]   </td><td><code>ReverseStep</code></td><td>   ::=   </td><td><code>(<a href="#prod-xquery-ReverseAxis">ReverseAxis</a>  <a href="#prod-xquery-NodeTest">NodeTest</a>)  |  <a href="#prod-xquery-AbbrevReverseStep">AbbrevReverseStep</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-ReverseAxis" id="prod-xquery-ReverseAxis"/>[<small>76</small>]   </td><td><code>ReverseAxis</code></td><td>   ::=   </td><td><code>("parent"  "::")<br/>|  ("ancestor"  "::")<br/>|  ("preceding-sibling"  "::")<br/>|  ("preceding"  "::")<br/>|  ("ancestor-or-self"  "::")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-AbbrevReverseStep" id="prod-xquery-AbbrevReverseStep"/>[<small>77</small>]   </td><td><code>AbbrevReverseStep</code></td><td>   ::=   </td><td><code>".."</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-NodeTest" id="prod-xquery-NodeTest"/>[<small>78</small>]   </td><td><code>NodeTest</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-KindTest">KindTest</a>  |  <a href="#prod-xquery-NameTest">NameTest</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-NameTest" id="prod-xquery-NameTest"/>[<small>79</small>]   </td><td><code>NameTest</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-QName">QName</a>  |  <a href="#prod-xquery-Wildcard">Wildcard</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-Wildcard" id="prod-xquery-Wildcard"/>[<small>80</small>]   </td><td><code>Wildcard</code></td><td>   ::=   </td><td><code>"*"<br/>|  (<a href="#prod-xquery-NCName">NCName</a>  ":"  "*")<br/>|  ("*"  ":"  <a href="#prod-xquery-NCName">NCName</a>)</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-FilterExpr" id="prod-xquery-FilterExpr"/>[<small>81</small>]   </td><td><code>FilterExpr</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-PrimaryExpr">PrimaryExpr</a>  <a href="#prod-xquery-PredicateList">PredicateList</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-PredicateList" id="prod-xquery-PredicateList"/>[<small>82</small>]   </td><td><code>PredicateList</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-Predicate">Predicate</a>*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-Predicate" id="prod-xquery-Predicate"/>[<small>83</small>]   </td><td><code>Predicate</code></td><td>   ::=   </td><td><code>"["  <a href="#prod-xquery-Expr">Expr</a>  "]"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-PrimaryExpr" id="prod-xquery-PrimaryExpr"/>[<small>84</small>]   </td><td><code>PrimaryExpr</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-Literal">Literal</a>  |  <a href="#prod-xquery-VarRef">VarRef</a>  |  <a href="#prod-xquery-ParenthesizedExpr">ParenthesizedExpr</a>  |  <a href="#prod-xquery-ContextItemExpr">ContextItemExpr</a>  |  <a href="#prod-xquery-FunctionCall">FunctionCall</a>  |  <a href="#prod-xquery-OrderedExpr">OrderedExpr</a>  |  <a href="#prod-xquery-UnorderedExpr">UnorderedExpr</a>  |  <a href="#prod-xquery-Constructor">Constructor</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-Literal" id="prod-xquery-Literal"/>[<small>85</small>]   </td><td><code>Literal</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-NumericLiteral">NumericLiteral</a>  |  <a href="#prod-xquery-StringLiteral">StringLiteral</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-NumericLiteral" id="prod-xquery-NumericLiteral"/>[<small>86</small>]   </td><td><code>NumericLiteral</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-IntegerLiteral">IntegerLiteral</a>  |  <a href="#prod-xquery-DecimalLiteral">DecimalLiteral</a>  |  <a href="#prod-xquery-DoubleLiteral">DoubleLiteral</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-VarRef" id="prod-xquery-VarRef"/>[<small>87</small>]   </td><td><code>VarRef</code></td><td>   ::=   </td><td><code>"$"  <a href="#prod-xquery-VarName">VarName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-VarName" id="prod-xquery-VarName"/>[<small>88</small>]   </td><td><code>VarName</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-QName">QName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-ParenthesizedExpr" id="prod-xquery-ParenthesizedExpr"/>[<small>89</small>]   </td><td><code>ParenthesizedExpr</code></td><td>   ::=   </td><td><code>"("  <a href="#prod-xquery-Expr">Expr</a>?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-ContextItemExpr" id="prod-xquery-ContextItemExpr"/>[<small>90</small>]   </td><td><code>ContextItemExpr</code></td><td>   ::=   </td><td><code>"."</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-OrderedExpr" id="prod-xquery-OrderedExpr"/>[<small>91</small>]   </td><td><code>OrderedExpr</code></td><td>   ::=   </td><td><code>"ordered"  "{"  <a href="#prod-xquery-Expr">Expr</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-UnorderedExpr" id="prod-xquery-UnorderedExpr"/>[<small>92</small>]   </td><td><code>UnorderedExpr</code></td><td>   ::=   </td><td><code>"unordered"  "{"  <a href="#prod-xquery-Expr">Expr</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-FunctionCall" id="prod-xquery-FunctionCall"/>[<small>93</small>]   </td><td><code>FunctionCall</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-QName">QName</a>  "("  (<a href="#prod-xquery-ExprSingle">ExprSingle</a>  (","  <a href="#prod-xquery-ExprSingle">ExprSingle</a>)*)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-Constructor" id="prod-xquery-Constructor"/>[<small>94</small>]   </td><td><code>Constructor</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-DirectConstructor">DirectConstructor</a><br/>|  <a href="#prod-xquery-ComputedConstructor">ComputedConstructor</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-DirectConstructor" id="prod-xquery-DirectConstructor"/>[<small>95</small>]   </td><td><code>DirectConstructor</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-DirElemConstructor">DirElemConstructor</a><br/>|  <a href="#prod-xquery-DirCommentConstructor">DirCommentConstructor</a><br/>|  <a href="#prod-xquery-DirPIConstructor">DirPIConstructor</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-DirElemConstructor" id="prod-xquery-DirElemConstructor"/>[<small>96</small>]   </td><td><code>DirElemConstructor</code></td><td>   ::=   </td><td><code>"&lt;"  <a href="#prod-xquery-QName">QName</a>  <a href="#prod-xquery-DirAttributeList">DirAttributeList</a>  ("/&gt;"  |  ("&gt;"  <a href="#prod-xquery-DirElemContent">DirElemContent</a>*  "&lt;/"  <a href="#prod-xquery-QName">QName</a>  <a href="#prod-xquery-S">S</a>?  "&gt;"))</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-DirAttributeList" id="prod-xquery-DirAttributeList"/>[<small>97</small>]   </td><td><code>DirAttributeList</code></td><td>   ::=   </td><td><code>(<a href="#prod-xquery-S">S</a>  (<a href="#prod-xquery-QName">QName</a>  <a href="#prod-xquery-S">S</a>?  "="  <a href="#prod-xquery-S">S</a>?  <a href="#prod-xquery-DirAttributeValue">DirAttributeValue</a>)?)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-DirAttributeValue" id="prod-xquery-DirAttributeValue"/>[<small>98</small>]   </td><td><code>DirAttributeValue</code></td><td>   ::=   </td><td><code>('"'  (<a href="#prod-xquery-EscapeQuot">EscapeQuot</a>  |  <a href="#prod-xquery-QuotAttrValueContent">QuotAttrValueContent</a>)*  '"')<br/>|  ("'"  (<a href="#prod-xquery-EscapeApos">EscapeApos</a>  |  <a href="#prod-xquery-AposAttrValueContent">AposAttrValueContent</a>)*  "'")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-QuotAttrValueContent" id="prod-xquery-QuotAttrValueContent"/>[<small>99</small>]   </td><td><code>QuotAttrValueContent</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-QuotAttrContentChar">QuotAttrContentChar</a><br/>|  <a href="#prod-xquery-CommonContent">CommonContent</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-AposAttrValueContent" id="prod-xquery-AposAttrValueContent"/>[<small>100</small>]   </td><td><code>AposAttrValueContent</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-AposAttrContentChar">AposAttrContentChar</a><br/>|  <a href="#prod-xquery-CommonContent">CommonContent</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-DirElemContent" id="prod-xquery-DirElemContent"/>[<small>101</small>]   </td><td><code>DirElemContent</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-DirectConstructor">DirectConstructor</a><br/>|  <a href="#prod-xquery-CDataSection">CDataSection</a><br/>|  <a href="#prod-xquery-CommonContent">CommonContent</a><br/>|  <a href="#prod-xquery-ElementContentChar">ElementContentChar</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-CommonContent" id="prod-xquery-CommonContent"/>[<small>102</small>]   </td><td><code>CommonContent</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-PredefinedEntityRef">PredefinedEntityRef</a>  |  <a href="#prod-xquery-CharRef">CharRef</a>  |  "{{"  |  "}}"  |  <a href="#prod-xquery-EnclosedExpr">EnclosedExpr</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-DirCommentConstructor" id="prod-xquery-DirCommentConstructor"/>[<small>103</small>]   </td><td><code>DirCommentConstructor</code></td><td>   ::=   </td><td><code>"&lt;!--"  <a href="#prod-xquery-DirCommentContents">DirCommentContents</a>  "--&gt;"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-DirCommentContents" id="prod-xquery-DirCommentContents"/>[<small>104</small>]   </td><td><code>DirCommentContents</code></td><td>   ::=   </td><td><code>((<a href="#prod-xquery-Char">Char</a> - '-')  |  ('-'  (<a href="#prod-xquery-Char">Char</a> - '-')))*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-DirPIConstructor" id="prod-xquery-DirPIConstructor"/>[<small>105</small>]   </td><td><code>DirPIConstructor</code></td><td>   ::=   </td><td><code>"&lt;?"  <a href="#prod-xquery-PITarget">PITarget</a>  (<a href="#prod-xquery-S">S</a>  <a href="#prod-xquery-DirPIContents">DirPIContents</a>)?  "?&gt;"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-DirPIContents" id="prod-xquery-DirPIContents"/>[<small>106</small>]   </td><td><code>DirPIContents</code></td><td>   ::=   </td><td><code>(<a href="#prod-xquery-Char">Char</a>* - (Char* '?&gt;' Char*))</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-CDataSection" id="prod-xquery-CDataSection"/>[<small>107</small>]   </td><td><code>CDataSection</code></td><td>   ::=   </td><td><code>"&lt;![CDATA["  <a href="#prod-xquery-CDataSectionContents">CDataSectionContents</a>  "]]&gt;"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-CDataSectionContents" id="prod-xquery-CDataSectionContents"/>[<small>108</small>]   </td><td><code>CDataSectionContents</code></td><td>   ::=   </td><td><code>(<a href="#prod-xquery-Char">Char</a>* - (Char* ']]&gt;' Char*))</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-ComputedConstructor" id="prod-xquery-ComputedConstructor"/>[<small>109</small>]   </td><td><code>ComputedConstructor</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-CompDocConstructor">CompDocConstructor</a><br/>|  <a href="#prod-xquery-CompElemConstructor">CompElemConstructor</a><br/>|  <a href="#prod-xquery-CompAttrConstructor">CompAttrConstructor</a><br/>|  <a href="#prod-xquery-CompTextConstructor">CompTextConstructor</a><br/>|  <a href="#prod-xquery-CompCommentConstructor">CompCommentConstructor</a><br/>|  <a href="#prod-xquery-CompPIConstructor">CompPIConstructor</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-CompDocConstructor" id="prod-xquery-CompDocConstructor"/>[<small>110</small>]   </td><td><code>CompDocConstructor</code></td><td>   ::=   </td><td><code>"document"  "{"  <a href="#prod-xquery-Expr">Expr</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-CompElemConstructor" id="prod-xquery-CompElemConstructor"/>[<small>111</small>]   </td><td><code>CompElemConstructor</code></td><td>   ::=   </td><td><code>"element"  (<a href="#prod-xquery-QName">QName</a>  |  ("{"  <a href="#prod-xquery-Expr">Expr</a>  "}"))  "{"  <a href="#prod-xquery-ContentExpr">ContentExpr</a>?  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-ContentExpr" id="prod-xquery-ContentExpr"/>[<small>112</small>]   </td><td><code>ContentExpr</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-Expr">Expr</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-CompAttrConstructor" id="prod-xquery-CompAttrConstructor"/>[<small>113</small>]   </td><td><code>CompAttrConstructor</code></td><td>   ::=   </td><td><code>"attribute"  (<a href="#prod-xquery-QName">QName</a>  |  ("{"  <a href="#prod-xquery-Expr">Expr</a>  "}"))  "{"  <a href="#prod-xquery-Expr">Expr</a>?  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-CompTextConstructor" id="prod-xquery-CompTextConstructor"/>[<small>114</small>]   </td><td><code>CompTextConstructor</code></td><td>   ::=   </td><td><code>"text"  "{"  <a href="#prod-xquery-Expr">Expr</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-CompCommentConstructor" id="prod-xquery-CompCommentConstructor"/>[<small>115</small>]   </td><td><code>CompCommentConstructor</code></td><td>   ::=   </td><td><code>"comment"  "{"  <a href="#prod-xquery-Expr">Expr</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-CompPIConstructor" id="prod-xquery-CompPIConstructor"/>[<small>116</small>]   </td><td><code>CompPIConstructor</code></td><td>   ::=   </td><td><code>"processing-instruction"  (<a href="#prod-xquery-NCName">NCName</a>  |  ("{"  <a href="#prod-xquery-Expr">Expr</a>  "}"))  "{"  <a href="#prod-xquery-Expr">Expr</a>?  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-SingleType" id="prod-xquery-SingleType"/>[<small>117</small>]   </td><td><code>SingleType</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-AtomicType">AtomicType</a>  "?"?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-TypeDeclaration" id="prod-xquery-TypeDeclaration"/>[<small>118</small>]   </td><td><code>TypeDeclaration</code></td><td>   ::=   </td><td><code>"as"  <a href="#prod-xquery-SequenceType">SequenceType</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-SequenceType" id="prod-xquery-SequenceType"/>[<small>119</small>]   </td><td><code>SequenceType</code></td><td>   ::=   </td><td><code>("empty-sequence"  "("  ")")<br/>|  (<a href="#prod-xquery-ItemType">ItemType</a>  <a href="#prod-xquery-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-OccurrenceIndicator" id="prod-xquery-OccurrenceIndicator"/>[<small>120</small>]   </td><td><code>OccurrenceIndicator</code></td><td>   ::=   </td><td><code>"?"  |  "*"  |  "+"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-ItemType" id="prod-xquery-ItemType"/>[<small>121</small>]   </td><td><code>ItemType</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-KindTest">KindTest</a>  |  ("item"  "("  ")")  |  <a href="#prod-xquery-AtomicType">AtomicType</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-AtomicType" id="prod-xquery-AtomicType"/>[<small>122</small>]   </td><td><code>AtomicType</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-QName">QName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-KindTest" id="prod-xquery-KindTest"/>[<small>123</small>]   </td><td><code>KindTest</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-DocumentTest">DocumentTest</a><br/>|  <a href="#prod-xquery-ElementTest">ElementTest</a><br/>|  <a href="#prod-xquery-AttributeTest">AttributeTest</a><br/>|  <a href="#prod-xquery-SchemaElementTest">SchemaElementTest</a><br/>|  <a href="#prod-xquery-SchemaAttributeTest">SchemaAttributeTest</a><br/>|  <a href="#prod-xquery-PITest">PITest</a><br/>|  <a href="#prod-xquery-CommentTest">CommentTest</a><br/>|  <a href="#prod-xquery-TextTest">TextTest</a><br/>|  <a href="#prod-xquery-AnyKindTest">AnyKindTest</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-AnyKindTest" id="prod-xquery-AnyKindTest"/>[<small>124</small>]   </td><td><code>AnyKindTest</code></td><td>   ::=   </td><td><code>"node"  "("  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-DocumentTest" id="prod-xquery-DocumentTest"/>[<small>125</small>]   </td><td><code>DocumentTest</code></td><td>   ::=   </td><td><code>"document-node"  "("  (<a href="#prod-xquery-ElementTest">ElementTest</a>  |  <a href="#prod-xquery-SchemaElementTest">SchemaElementTest</a>)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-TextTest" id="prod-xquery-TextTest"/>[<small>126</small>]   </td><td><code>TextTest</code></td><td>   ::=   </td><td><code>"text"  "("  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-CommentTest" id="prod-xquery-CommentTest"/>[<small>127</small>]   </td><td><code>CommentTest</code></td><td>   ::=   </td><td><code>"comment"  "("  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-PITest" id="prod-xquery-PITest"/>[<small>128</small>]   </td><td><code>PITest</code></td><td>   ::=   </td><td><code>"processing-instruction"  "("  (<a href="#prod-xquery-NCName">NCName</a>  |  <a href="#prod-xquery-StringLiteral">StringLiteral</a>)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-AttributeTest" id="prod-xquery-AttributeTest"/>[<small>129</small>]   </td><td><code>AttributeTest</code></td><td>   ::=   </td><td><code>"attribute"  "("  (<a href="#prod-xquery-AttribNameOrWildcard">AttribNameOrWildcard</a>  (","  <a href="#prod-xquery-TypeName">TypeName</a>)?)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-AttribNameOrWildcard" id="prod-xquery-AttribNameOrWildcard"/>[<small>130</small>]   </td><td><code>AttribNameOrWildcard</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-AttributeName">AttributeName</a>  |  "*"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-SchemaAttributeTest" id="prod-xquery-SchemaAttributeTest"/>[<small>131</small>]   </td><td><code>SchemaAttributeTest</code></td><td>   ::=   </td><td><code>"schema-attribute"  "("  <a href="#prod-xquery-AttributeDeclaration">AttributeDeclaration</a>  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-AttributeDeclaration" id="prod-xquery-AttributeDeclaration"/>[<small>132</small>]   </td><td><code>AttributeDeclaration</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-AttributeName">AttributeName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-ElementTest" id="prod-xquery-ElementTest"/>[<small>133</small>]   </td><td><code>ElementTest</code></td><td>   ::=   </td><td><code>"element"  "("  (<a href="#prod-xquery-ElementNameOrWildcard">ElementNameOrWildcard</a>  (","  <a href="#prod-xquery-TypeName">TypeName</a>  "?"?)?)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-ElementNameOrWildcard" id="prod-xquery-ElementNameOrWildcard"/>[<small>134</small>]   </td><td><code>ElementNameOrWildcard</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-ElementName">ElementName</a>  |  "*"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-SchemaElementTest" id="prod-xquery-SchemaElementTest"/>[<small>135</small>]   </td><td><code>SchemaElementTest</code></td><td>   ::=   </td><td><code>"schema-element"  "("  <a href="#prod-xquery-ElementDeclaration">ElementDeclaration</a>  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-ElementDeclaration" id="prod-xquery-ElementDeclaration"/>[<small>136</small>]   </td><td><code>ElementDeclaration</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-ElementName">ElementName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-AttributeName" id="prod-xquery-AttributeName"/>[<small>137</small>]   </td><td><code>AttributeName</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-QName">QName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-ElementName" id="prod-xquery-ElementName"/>[<small>138</small>]   </td><td><code>ElementName</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-QName">QName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-TypeName" id="prod-xquery-TypeName"/>[<small>139</small>]   </td><td><code>TypeName</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-QName">QName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-URILiteral" id="prod-xquery-URILiteral"/>[<small>140</small>]   </td><td><code>URILiteral</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-StringLiteral">StringLiteral</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-RevalidationDecl" id="prod-xquery-RevalidationDecl"/>[<small>141</small>]   </td><td><code><a href="#doc-xquery-RevalidationDecl"><a href="#doc-xquery-RevalidationDecl">RevalidationDecl</a></a></code></td><td>   ::=   </td><td><code>"declare"  "revalidation"  ("strict"  |  "lax"  |  "skip")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-InsertExprTargetChoice" id="prod-xquery-InsertExprTargetChoice"/>[<small>142</small>]   </td><td><code><a href="#doc-xquery-InsertExprTargetChoice"><a href="#doc-xquery-InsertExprTargetChoice">InsertExprTargetChoice</a></a></code></td><td>   ::=   </td><td><code>(("as"  ("first"  |  "last"))?  "into")<br/>|  "after"<br/>|  "before"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-InsertExpr" id="prod-xquery-InsertExpr"/>[<small>143</small>]   </td><td><code><a href="#doc-xquery-InsertExpr"><a href="#doc-xquery-InsertExpr">InsertExpr</a></a></code></td><td>   ::=   </td><td><code>"insert"  ("node"  |  "nodes")  <a href="#prod-xquery-SourceExpr">SourceExpr</a>  <a href="#prod-xquery-InsertExprTargetChoice">InsertExprTargetChoice</a>  <a href="#prod-xquery-TargetExpr">TargetExpr</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-DeleteExpr" id="prod-xquery-DeleteExpr"/>[<small>144</small>]   </td><td><code><a href="#doc-xquery-DeleteExpr"><a href="#doc-xquery-DeleteExpr">DeleteExpr</a></a></code></td><td>   ::=   </td><td><code>"delete"  ("node"  |  "nodes")  <a href="#prod-xquery-TargetExpr">TargetExpr</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-ReplaceExpr" id="prod-xquery-ReplaceExpr"/>[<small>145</small>]   </td><td><code><a href="#doc-xquery-ReplaceExpr"><a href="#doc-xquery-ReplaceExpr">ReplaceExpr</a></a></code></td><td>   ::=   </td><td><code>"replace"  ("value"  "of")?  "node"  <a href="#prod-xquery-TargetExpr">TargetExpr</a>  "with"  <a href="#prod-xquery-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-RenameExpr" id="prod-xquery-RenameExpr"/>[<small>146</small>]   </td><td><code><a href="#doc-xquery-RenameExpr"><a href="#doc-xquery-RenameExpr">RenameExpr</a></a></code></td><td>   ::=   </td><td><code>"rename"  "node"  <a href="#prod-xquery-TargetExpr">TargetExpr</a>  "as"  <a href="#prod-xquery-NewNameExpr">NewNameExpr</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-SourceExpr" id="prod-xquery-SourceExpr"/>[<small>147</small>]   </td><td><code><a href="#doc-xquery-SourceExpr"><a href="#doc-xquery-SourceExpr">SourceExpr</a></a></code></td><td>   ::=   </td><td><code><a href="#prod-xquery-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-TargetExpr" id="prod-xquery-TargetExpr"/>[<small>148</small>]   </td><td><code><a href="#doc-xquery-TargetExpr"><a href="#doc-xquery-TargetExpr">TargetExpr</a></a></code></td><td>   ::=   </td><td><code><a href="#prod-xquery-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-NewNameExpr" id="prod-xquery-NewNameExpr"/>[<small>149</small>]   </td><td><code><a href="#doc-xquery-NewNameExpr"><a href="#doc-xquery-NewNameExpr">NewNameExpr</a></a></code></td><td>   ::=   </td><td><code><a href="#prod-xquery-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-TransformExpr" id="prod-xquery-TransformExpr"/>[<small>150</small>]   </td><td><code><a href="#doc-xquery-TransformExpr"><a href="#doc-xquery-TransformExpr">TransformExpr</a></a></code></td><td>   ::=   </td><td><code>"copy"  "$"  <a href="#prod-xquery-VarName">VarName</a>  ":="  <a href="#prod-xquery-ExprSingle">ExprSingle</a>  (","  "$"  <a href="#prod-xquery-VarName">VarName</a>  ":="  <a href="#prod-xquery-ExprSingle">ExprSingle</a>)*  "modify"  <a href="#prod-xquery-ExprSingle">ExprSingle</a>  "return"  <a href="#prod-xquery-ExprSingle">ExprSingle</a></code></td></tr></tbody></table><div class="div2">
<h3><a name="id-terminal-symbols" id="id-terminal-symbols"/>A.1 Terminal Symbols</h3>
<h5><a name="d8e9385" id="d8e9385"/></h5><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="prod-xquery-IntegerLiteral" id="prod-xquery-IntegerLiteral"/>[<small>151</small>]   </td><td><code>IntegerLiteral</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-Digits">Digits</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-DecimalLiteral" id="prod-xquery-DecimalLiteral"/>[<small>152</small>]   </td><td><code>DecimalLiteral</code></td><td>   ::=   </td><td><code>("."  <a href="#prod-xquery-Digits">Digits</a>)  |  (<a href="#prod-xquery-Digits">Digits</a>  "."  [0-9]*)</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-DoubleLiteral" id="prod-xquery-DoubleLiteral"/>[<small>153</small>]   </td><td><code>DoubleLiteral</code></td><td>   ::=   </td><td><code>(("."  <a href="#prod-xquery-Digits">Digits</a>)  |  (<a href="#prod-xquery-Digits">Digits</a>  ("."  [0-9]*)?))  [eE]  [+-]?  <a href="#prod-xquery-Digits">Digits</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-StringLiteral" id="prod-xquery-StringLiteral"/>[<small>154</small>]   </td><td><code>StringLiteral</code></td><td>   ::=   </td><td><code>('"'  (<a href="#prod-xquery-PredefinedEntityRef">PredefinedEntityRef</a>  |  <a href="#prod-xquery-CharRef">CharRef</a>  |  <a href="#prod-xquery-EscapeQuot">EscapeQuot</a>  |  [^"&amp;])*  '"')  |  ("'"  (<a href="#prod-xquery-PredefinedEntityRef">PredefinedEntityRef</a>  |  <a href="#prod-xquery-CharRef">CharRef</a>  |  <a href="#prod-xquery-EscapeApos">EscapeApos</a>  |  [^'&amp;])*  "'")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-PredefinedEntityRef" id="prod-xquery-PredefinedEntityRef"/>[<small>155</small>]   </td><td><code>PredefinedEntityRef</code></td><td>   ::=   </td><td><code>"&amp;"  ("lt"  |  "gt"  |  "amp"  |  "quot"  |  "apos")  ";"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-EscapeQuot" id="prod-xquery-EscapeQuot"/>[<small>156</small>]   </td><td><code>EscapeQuot</code></td><td>   ::=   </td><td><code>'""'</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-EscapeApos" id="prod-xquery-EscapeApos"/>[<small>157</small>]   </td><td><code>EscapeApos</code></td><td>   ::=   </td><td><code>"''"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-ElementContentChar" id="prod-xquery-ElementContentChar"/>[<small>158</small>]   </td><td><code>ElementContentChar</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-Char">Char</a> - [{}&lt;&amp;]</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-QuotAttrContentChar" id="prod-xquery-QuotAttrContentChar"/>[<small>159</small>]   </td><td><code>QuotAttrContentChar</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-Char">Char</a> - ["{}&lt;&amp;]</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-AposAttrContentChar" id="prod-xquery-AposAttrContentChar"/>[<small>160</small>]   </td><td><code>AposAttrContentChar</code></td><td>   ::=   </td><td><code><a href="#prod-xquery-Char">Char</a> - ['{}&lt;&amp;]</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-Comment" id="prod-xquery-Comment"/>[<small>161</small>]   </td><td><code>Comment</code></td><td>   ::=   </td><td><code>"(:"  (<a href="#prod-xquery-CommentContents">CommentContents</a>  |  <a href="#prod-xquery-Comment">Comment</a>)*  ":)"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-PITarget" id="prod-xquery-PITarget"/>[<small>162</small>]   </td><td><code>PITarget</code></td><td>   ::=   </td><td><code><a href="http://www.w3.org/TR/REC-xml/#NT-PITarget">[http://www.w3.org/TR/REC-xml#NT-PITarget]</a><sup><small>XML</small></sup></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-CharRef" id="prod-xquery-CharRef"/>[<small>163</small>]   </td><td><code>CharRef</code></td><td>   ::=   </td><td><code><a href="http://www.w3.org/TR/REC-xml/#NT-CharRef">[http://www.w3.org/TR/REC-xml#NT-CharRef]</a><sup><small>XML</small></sup></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-QName" id="prod-xquery-QName"/>[<small>164</small>]   </td><td><code>QName</code></td><td>   ::=   </td><td><code><a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</a><sup><small>Names</small></sup></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-NCName" id="prod-xquery-NCName"/>[<small>165</small>]   </td><td><code>NCName</code></td><td>   ::=   </td><td><code><a href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</a><sup><small>Names</small></sup></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-S" id="prod-xquery-S"/>[<small>166</small>]   </td><td><code>S</code></td><td>   ::=   </td><td><code><a href="http://www.w3.org/TR/REC-xml/#NT-S">[http://www.w3.org/TR/REC-xml#NT-S]</a><sup><small>XML</small></sup></code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-Char" id="prod-xquery-Char"/>[<small>167</small>]   </td><td><code>Char</code></td><td>   ::=   </td><td><code><a href="http://www.w3.org/TR/REC-xml/#NT-Char">[http://www.w3.org/TR/REC-xml#NT-Char]</a><sup><small>XML</small></sup></code></td></tr></tbody></table><p>The following symbols are used only in the definition of
  terminal symbols; they are not terminal symbols in the
  grammar of <a href="#id-grammar"><b>[A EBNF for XQuery 1.0 Grammar with Update extensions]</b></a>.</p>
<h5><a name="d8e9577" id="d8e9577"/></h5><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="prod-xquery-Digits" id="prod-xquery-Digits"/>[<small>168</small>]   </td><td><code>Digits</code></td><td>   ::=   </td><td><code>[0-9]+</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery-CommentContents" id="prod-xquery-CommentContents"/>[<small>169</small>]   </td><td><code>CommentContents</code></td><td>   ::=   </td><td><code>(<a href="#prod-xquery-Char">Char</a>+ - (Char* ('(:' | ':)') Char*))</code></td></tr></tbody></table></div></div><div class="div1">
<h2><a name="id-impl-defs" id="id-impl-defs"/>B Implementation-Defined Items</h2><p>The following items in this specification are implementation-defined:</p><ol class="enumar"><li><p>The revalidation modes that are supported by this implementation.</p></li><li><p>The default revalidation mode for this implementation.</p></li><li class="diff-del"><div class="diff-del"><li><p>Whether the implementation raises dynamic error
<span class="diff-del" title="">[<a href="#ERRXUDY0020" title="err:XUDY0020">err:XUDY0020</a>]</span> if a node is deleted that had no parent
before execution of the query began.</p></li></div></li><li><p>The mechanism (if any) by which an external function can return an XDM instance
and/or a pending update list to the invoking query.</p></li><li><p>The semantics of <code>fn:put()</code>, including the kinds of nodes accepted
as operands by this function.</p></li></ol></div><div class="div1">
<h2><a name="References" id="References"/>C References</h2><div class="div2">
<h3><a name="id-normative-references" id="id-normative-references"/>C.1 Normative References</h3><dl><dt class="label"><span><a name="xquery-update-10-requirements" id="xquery-update-10-requirements"/>XQuery Update Facility 1.0 Requirements</span></dt><dd><div>
<a href="http://www.w3.org/TR/xquery-update-10-requirements/"><cite>XQuery Update Facility 1.0 Requirements</cite></a>,
Don Chamberlin and Jonathan Robie, Editors.
World Wide Web Consortium,
25 January 2011.
This version is http://www.w3.org/TR/2011/NOTE-xquery-update-10-requirements-20110125/.
The <a href="http://www.w3.org/TR/xquery-update-10-requirements/">latest version</a>
is available at http://www.w3.org/TR/xquery-update-10-requirements/.</div></dd><dt class="label"><span><a name="xpath-datamodel" id="xpath-datamodel"/>XQuery 1.0 and XPath 2.0 Data Model</span></dt><dd><div>
<a href="http://www.w3.org/TR/xpath-datamodel/"><cite>XQuery 1.0 and XPath 2.0 Data Model (XDM) (Second Edition)</cite></a>,
Norman Walsh, Mary Fernández, Ashok Malhotra, <em>et. al.</em>, Editors.
World Wide Web Consortium,
14 December 2010.
This version is http://www.w3.org/TR/2010/REC-xpath-datamodel-20101214/.
The <a href="http://www.w3.org/TR/xpath-datamodel/">latest version</a>
is available at http://www.w3.org/TR/xpath-datamodel/.</div></dd><dt class="label"><span><a name="xquery" id="xquery"/>XQuery 1.0</span></dt><dd><div>
<a href="http://www.w3.org/TR/xquery/"><cite>XQuery 1.0: An XML Query Language (Second Edition)</cite></a>,
Don Chamberlin, Anders Berglund, Scott Boag, <em>et. al.</em>, Editors.
World Wide Web Consortium,
14 December 2010.
This version is http://www.w3.org/TR/2010/REC-xquery-20101214/.
The <a href="http://www.w3.org/TR/xquery/">latest version</a>
is available at http://www.w3.org/TR/xquery/.</div></dd><dt class="label"><span><a name="xpath-functions" id="xpath-functions"/>XQuery 1.0 and XPath 2.0 Functions and Operators</span></dt><dd><div>
<a href="http://www.w3.org/TR/xpath-functions/"><cite>XQuery 1.0 and XPath 2.0 Functions and Operators (Second Edition)</cite></a>,
Ashok Malhotra, Jim Melton, and Norman Walsh, Editors.
World Wide Web Consortium,
14 December 2010.
This version is http://www.w3.org/TR/2010/REC-xpath-functions-20101214/.
The <a href="http://www.w3.org/TR/xpath-functions/">latest version</a>
is available at http://www.w3.org/TR/xpath-functions/.</div></dd><dt class="label"><span><a name="xqueryx" id="xqueryx"/>XQueryX 1.0</span></dt><dd><div>
<a href="http://www.w3.org/TR/xqueryx/"><cite>XML Syntax for XQuery 1.0 (XQueryX) (Second Edition)</cite></a>,
Jim Melton and Subramanian Muralidhar, Editors.
World Wide Web Consortium,
14 December 2010.
This version is http://www.w3.org/TR/2010/REC-xqueryx-20101214/.
The <a href="http://www.w3.org/TR/xqueryx/">latest version</a>
is available at http://www.w3.org/TR/xqueryx/.</div></dd><dt class="label"><span><a name="xquery-semantics" id="xquery-semantics"/>XQuery 1.0 and XPath 2.0 Formal Semantics</span></dt><dd><div>
<a href="http://www.w3.org/TR/xquery-semantics/"><cite>XQuery 1.0 and XPath 2.0 Formal Semantics (Second Edition)</cite></a>,
Jérôme Siméon, Denise Draper, Peter Frankhauser, <em>et. al.</em>, Editors.
World Wide Web Consortium,
14 December 2010.
This version is http://www.w3.org/TR/2010/REC-xquery-semantics-20101214/.
The <a href="http://www.w3.org/TR/xquery-semantics/">latest version</a>
is available at http://www.w3.org/TR/xquery-semantics/.</div></dd><dt class="label"><span><a name="RFC2119" id="RFC2119"/>RFC 2119</span></dt><dd><div>S. Bradner. 
<em>Key Words for use in RFCs to Indicate Requirement Levels.</em>
IETF RFC 2119. See <a href="http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</a>.</div></dd></dl></div><div class="div2">
<h3><a name="id-non-normative-references" id="id-non-normative-references"/>C.2 Non-normative References</h3><dl><dt class="label"><span><a name="ietf-patches" id="ietf-patches"/>XML Patch Operations</span></dt><dd><div>Internet Engineering Task Force. 
<em>An Extensible Markup Language (XML) 
Patch Operations Framework Utilizing XML Path Language (XPath) Selectors.</em>. 
See <a href="http://datatracker.ietf.org/doc/draft-ietf-simple-xml-patch-ops/">http://datatracker.ietf.org/doc/draft-ietf-simple-xml-patch-ops/
</a>.</div></dd><dt class="label"><span><a name="xquery-update-10-use-cases" id="xquery-update-10-use-cases"/>XQuery Update Facility 1.0 Use Cases</span></dt><dd><div>
<a href="http://www.w3.org/TR/xquery-update-10-use-cases/"><cite>XQuery Update Facility 1.0 Use Cases</cite></a>,
Iona Manolescu and Jonathan Robie, Editors.
World Wide Web Consortium,
25 January 2011.
This version is
http://www.w3.org/TR/2011/NOTE-xquery-update-10-use-cases-20110125/. The
<a href="http://www.w3.org/TR/xquery-update-10-use-cases/">latest version</a>
is available at http://www.w3.org/TR/xquery-update-10-use-cases/.</div></dd></dl></div></div><div class="div1">
<h2><a name="id-errors" id="id-errors"/>D Error Conditions</h2><div class="div2">
<h3><a name="id-new-error-codes" id="id-new-error-codes"/>D.1 New Error Codes</h3><dl><dt><a name="ERRXUST0001"/>err:XUST0001</dt><dd><p>
It is a static error if an <a title="updating expression" href="#dt-updating-expression">updating expression</a> is used in any position other than one of the following:</p><ol class="enumar"><li><p>The topmost expression in the body of a query.</p></li><li><p>The <code>modify</code> clause of a transform expression.</p></li><li><p>The <code>return</code> clause of a FLWOR expression.</p></li><li><p>The <code>return</code> clauses of a typeswitch expression in which every <code>return</code> clause contains an <a title="updating expression" href="#dt-updating-expression">updating expression</a> or a <a title="vacuous expression" href="#dt-vacuous-expression">vacuous expression</a>.</p></li><li><p>The <code>then</code> and <code>else</code> clauses of a conditional statement in which both the <code>then</code> and <code>else</code> clauses contain either an <a title="updating expression" href="#dt-updating-expression">updating expression</a> or a <a title="vacuous expression" href="#dt-vacuous-expression">vacuous expression</a>.</p></li><li><p>An operand of a comma expression in which each operand is either an <a title="updating expression" href="#dt-updating-expression">updating expression</a> or a <a title="vacuous expression" href="#dt-vacuous-expression">vacuous expression</a>.</p></li><li><p>The content of a  parenthesized expression.</p></li><li><p>The body of a function declaration in which the keyword <code>updating</code> is specified.</p></li></ol></dd><dt><a name="ERRXUST0002"/>err:XUST0002</dt><dd><p>
It is a static error if a <a title="simple expression" href="#dt-simple-expression">simple expression</a> that is not a <a title="vacuous expression" href="#dt-vacuous-expression">vacuous expression</a> is used in one of the following positions:</p><ol class="enumar"><li><p>The <code>modify</code> clause of a transform expression.</p></li><li><p>The top-level expression in the body of a function declaration in which the keyword <code>updating</code> is specified.</p></li></ol></dd><dt><a name="ERRXUST0003"/>err:XUST0003</dt><dd><p>
It is a static error if a Prolog contains more than one revalidation declaration.</p></dd><dt><a name="ERRXUTY0004"/>err:XUTY0004</dt><dd><p>
It is a type  error if the insertion sequence of an insert expression contains an attribute node following a node that is not an attribute node.</p></dd><dt><a name="ERRXUTY0005"/>err:XUTY0005</dt><dd><p>
In an insert expression where <code>into</code>, <code>as first into</code>, or <code>as last into</code> is specified, it is a type  error if the target expression returns a non-empty result that does not consist of a single element or document node.</p></dd><dt><a name="ERRXUTY0006"/>err:XUTY0006</dt><dd><p>
In an insert expression where <code>before</code> or <code>after</code> is specified, it is a type  error if the target expression returns a non-empty result that does not consist of a single element, text, comment, or processing instruction node.</p></dd><dt><a name="ERRXUTY0007"/>err:XUTY0007</dt><dd><p>
It is a type  error if the target expression of a delete expression does not return a sequence of zero or more nodes.</p></dd><dt><a name="ERRXUTY0008"/>err:XUTY0008</dt><dd><p>In a replace expression, it is a type error if the target expression returns a non-empty result that does not consist of a single  element, attribute, text, comment, or processing instruction node.</p></dd><dt><a name="ERRXUDY0009"/>err:XUDY0009</dt><dd><p>In a replace expression where <code>value of</code> is not specified, it is a dynamic error if the node returned by the target expression does not have a parent.</p></dd><dt><a name="ERRXUTY0010"/>err:XUTY0010</dt><dd><p>In a replace expression where <code>value of</code> is not specified and the target is an element, text, comment, or processing instruction node, it is a type error if the replacement sequence does not consist of zero or more element, text, comment, or processing instruction nodes.</p></dd><dt><a name="ERRXUTY0011"/>err:XUTY0011</dt><dd><p>In a replace expression where <code>value of</code> is not specified and the target is an attribute node, it is a type error if the replacement sequence does not consist of zero or more attribute nodes.</p></dd><dt><a name="ERRXUTY0012"/>err:XUTY0012</dt><dd><p>In a rename expression, it is a type error if the target expression returns a non-empty result that does not consist of a single element, attribute, or processing instruction node.</p></dd><dt><a name="ERRXUTY0013"/>err:XUTY0013</dt><dd><p>In a transform expression, it is a type error if a source expression in the <code>copy</code> clause does not return a single node.</p></dd><dt><a name="ERRXUDY0014"/>err:XUDY0014</dt><dd><p>In a transform expression, it is a dynamic error if the <code>modify</code> clause modifies any node that was not created by the <code>copy</code> clause.</p></dd><dt><a name="ERRXUDY0015"/>err:XUDY0015</dt><dd><p>It is a dynamic error if any node is the target of more than one <code>rename</code> expression within the same query.</p></dd><dt><a name="ERRXUDY0016"/>err:XUDY0016</dt><dd><p>It is a dynamic error if any node is the target of more than one <code>replace</code> expression (without <code>value of</code> being specified) within the same query.</p></dd><dt><a name="ERRXUDY0017"/>err:XUDY0017</dt><dd><p>It is a dynamic error if any node is the target of more than one <code>replace value of</code> expression within the same query.</p></dd><dt><a name="ERRXUDY0018"/>err:XUDY0018</dt><dd><p>It is a dynamic error if a function that was declared to be <code>external</code> but not <code>updating</code> returns a non-empty pending update list.</p></dd><dt><a name="ERRXUDY0019"/>err:XUDY0019</dt><dd><p>It is a dynamic error if a function that was declared to be both <code>external</code> and <code>updating</code> returns a non-empty data model instance.</p></dd><dt><a name="ERRXUDY0020"/>err:XUDY0020</dt><dd><p>An implementation may (but is not required to) raise a dynamic error if a node is deleted that had no parent before the beginning of the current snapshot.</p></dd><dt><a name="ERRXUDY0021"/>err:XUDY0021</dt><dd><p>It is a dynamic error if the <a title="XDM instance" href="#dt-xdm-instance">XDM instance</a> that would result from
applying all the updates in a query violates any constraint
specified in <a href="#xpath-datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>. In this case, none of the updates in the query are made effective.</p></dd><dt><a name="ERRXUTY0022"/>err:XUTY0022</dt><dd><p>It is a type error if an 
insert expression specifies the insertion of an attribute node into a 
document node.</p></dd><dt><a name="ERRXUDY0023"/>err:XUDY0023</dt><dd><p>It is a dynamic error if an insert, replace, or rename expression affects an element node by introducing a new namespace binding that  <a title="conflict" href="#dt-conflict">conflicts</a> with one of its existing namespace bindings.</p></dd><dt><a name="ERRXUDY0024"/>err:XUDY0024</dt><dd><p>It is a dynamic error if the effect of a set of updating expressions is to introduce <a title="conflict" href="#dt-conflict">conflicting</a> namespace bindings into an element node.</p></dd><dt><a name="ERRXUDY0025"/>err:XUDY0025</dt><dd><p>(Not currently used.)</p></dd><dt><a name="ERRXUST0026"/>err:XUST0026</dt><dd><p>It is a static error if a revalidation declaration in a Prolog specifies a revalidation mode that is not supported by the current implementation.</p></dd><dt><a name="ERRXUDY0027"/>err:XUDY0027</dt><dd><p>It is a dynamic error if the target expression of an insert, replace, or rename expression evaluates to an empty sequence.</p></dd><dt><a name="ERRXUST0028"/>err:XUST0028</dt><dd><p>It is a static error if a function declaration specifies both <code>updating</code> and a return type.</p></dd><dt><a name="ERRXUDY0029"/>err:XUDY0029</dt><dd><p>In an insert expression where <code>before</code> or <code>after</code> is specified, it is a dynamic  error if the node returned by the target expression does not have a parent.</p></dd><dt><a name="ERRXUDY0030"/>err:XUDY0030</dt><dd><p>It is a dynamic error if an 
insert expression specifies the insertion of an attribute node before or after a 
child of a document node.</p></dd><dt><a name="ERRXUDY0031"/>err:XUDY0031</dt><dd><p>It is a dynamic error if multiple calls to <code>fn:put</code> in the same snapshot specify the same URI (after resolution of relative URIs).</p></dd><dt><a name="ERRFOUP0001"/>err:FOUP0001</dt><dd><p>It is a dynamic error if the first operand of <code>fn:put</code> is not a node of a supported kind.</p></dd><dt><a name="ERRFOUP0002"/>err:FOUP0002</dt><dd><p>It is a dynamic error if the second operand of <code>fn:put</code> is not a valid lexical representation of the <code>xs:anyURI</code> type.</p></dd></dl></div><div class="div2">
<h3><a name="id-amended-error-codes" id="id-amended-error-codes"/>D.2 Amendments to Existing Error Codes</h3><dl><dt><a name="ERRXPST0005"/>err:XPST0005</dt><dd><p>During the analysis phase, it is a static error if the static type assigned to a simple expression other than <code>( )</code> or <code>data(( ))</code> is <code>empty-sequence( )</code>.</p></dd><dt><a name="ERRXQDY0026"/>err:XQDY0026</dt><dd><p>It is a dynamic error if a constructor or replace expression would result in a processing instruction node whose content includes the string "<code>?&gt;</code>".</p></dd><dt><a name="ERRXQDY0041"/>err:XQDY0041</dt><dd><p>It is a dynamic error if the name assigned to a processing node by  a constructor or rename expression cannot be cast to the type <code>xs:NCName</code>.</p></dd><dt><a name="ERRXQDY0072"/>err:XQDY0072</dt><dd><p>It is a dynamic error if a constructor or replace expression would result in a comment node whose content ends with a hyphen or contains two adjacent hyphens.</p></dd><dt><a name="ERRXQDY0074"/>err:XQDY0074</dt><dd><p>It is a dynamic error if the value of the name expression in a computed element constructor, computed attribute constructor, or rename expression cannot be converted to an expanded QName (for example, because it contains a namespace prefix not found in the statically known namespaces.)</p></dd></dl></div></div><div class="div1">
<h2><a name="id-xquf-xqueryx" id="id-xquf-xqueryx"/>E XML Syntax (XQueryX) for XQuery Update Facility 1.0</h2><p>
<a href="#xqueryx">[XQueryX 1.0]</a> defines an XML representation of <a href="#xquery">[XQuery 1.0]</a>. 
<a href="#xquery-update-10-requirements">[XQuery Update Facility 1.0 Requirements]</a> states
"The syntax for updates MAY have more than one syntax binding. 
One syntax MUST be convenient for humans to read and write. 
One syntax MUST be expressed in XML in a way that reflects
the underlying structure of the operations."
This appendix specifies an XML Schema that defines the
XML representation of XQuery Update Facility 1.0 by representing the abstract syntax
found in <a href="#id-grammar"><b>[A EBNF for XQuery 1.0 Grammar with Update extensions]</b></a>. 
This XML representation for XQuery Update Facility 1.0 integrates
with the XML representation for XQuery 1.0.</p><p>
The XML Schema specified in this appendix accomplishes its integration by importing
the XML Schema defined for XQueryX in <a href="#xqueryx">[XQueryX 1.0]</a>,
incorporating all of its type and element definitions. 
It then extends that schema by adding definitions of new types and elements
in a namespace belonging to the Update Facility specification, as well as
redefining one complex type. 
</p><div class="div2">
<h3><a name="id-xquf-update-schema" id="id-xquf-update-schema"/>E.1 Schema</h3><p>
This section specifies the two XML Schemas that define the complex types and elements
for XQueryX in support of XQuery Update Facility 1.0, including changes to the prolog
and the addition of several new expressions.</p><div class="exampleInner"><pre>

&lt;xsd:schema
     xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
     xmlns:xqx="http://www.w3.org/2005/XQueryX"
     xmlns:xqxuf="http://www.w3.org/2007/xquery-update-10"
     targetNamespace="http://www.w3.org/2007/xquery-update-10"
     elementFormDefault="qualified" 
     attributeFormDefault="unqualified"&gt;

&lt;!-- Initial creation                  2006-08-17: Jim Melton --&gt;
&lt;!-- Added ufRevalidationDecl          2006-08-21: Jim Melton --&gt;
&lt;!-- Overhaul to bring up to date      2007-08-07: Jim Melton --&gt;
&lt;!-- Reconfirmed correctness for CR    2008-02-27: Jim Melton --&gt;

  &lt;xsd:import namespace="http://www.w3.org/2005/XQueryX"
     schemaLocation="http://www.w3.org/2007/xquery-update-10/
xquery-update-10-xqueryx-redef.xsd"/&gt;


  &lt;!-- Add revalidationDecl to alternatives in prolog setters --&gt;
  &lt;xsd:element name="revalidationDecl"
               substitutionGroup="xqx:prologPartOneItem"&gt;
    &lt;xsd:simpleType&gt;
      &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
        &lt;xsd:enumeration value="strict"/&gt;
        &lt;xsd:enumeration value="lax"/&gt;
        &lt;xsd:enumeration value="skip"/&gt;
      &lt;/xsd:restriction&gt;
    &lt;/xsd:simpleType&gt;
  &lt;/xsd:element&gt;


  &lt;!-- Create substitution group for update facility exprs    --&gt;
  &lt;xsd:complexType name="expr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqx:expr"/&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Make the update facilities subst grp part of expr grp  --&gt;
  &lt;xsd:element name="expr" type="xqxuf:expr" abstract="true"
               substitutionGroup="xqx:expr"/&gt;


  &lt;!-- InsertExpr                                             --&gt;
  &lt;xsd:complexType name="insertExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxuf:expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="sourceExpr"
                       type="xqx:exprWrapper"/&gt;
          &lt;xsd:choice&gt;
            &lt;xsd:element name="insertInto"&gt;
              &lt;xsd:complexType&gt;
                &lt;xsd:sequence minOccurs="0" maxOccurs="1"&gt;
                  &lt;xsd:choice&gt;
                    &lt;xsd:element name="insertAsFirst" 
                                 type="xqx:emptyContent"/&gt;
                    &lt;xsd:element name="insertAsLast" 
                                 type="xqx:emptyContent"/&gt;
                  &lt;/xsd:choice&gt;
                &lt;/xsd:sequence&gt;
              &lt;/xsd:complexType&gt;
            &lt;/xsd:element&gt;
            &lt;xsd:element name="insertAfter"
                         type="xqx:emptyContent"/&gt;
            &lt;xsd:element name="insertBefore"
                         type="xqx:emptyContent"/&gt;
          &lt;/xsd:choice&gt;
          &lt;xsd:element name="targetExpr"
                       type="xqx:exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="insertExpr" type="xqxuf:insertExpr" 
               substitutionGroup="xqxuf:expr"/&gt;


  &lt;!-- DeleteExpr                                             --&gt;
  &lt;xsd:complexType name="deleteExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxuf:expr"&gt;
        &lt;xsd:sequence&gt;
         &lt;xsd:element name="targetExpr"
                      type="xqx:exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="deleteExpr" type="xqxuf:deleteExpr" 
               substitutionGroup="xqxuf:expr"/&gt;


  &lt;!-- ReplaceExpr                                            --&gt;
  &lt;xsd:complexType name="replaceExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxuf:expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="replaceValue"
                       type="xqx:emptyContent"
                       minOccurs="0" maxOccurs="1"/&gt;
          &lt;xsd:element name="targetExpr"
                       type="xqx:exprWrapper"/&gt;
          &lt;xsd:element name="replacementExpr"
                       type="xqx:exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="replaceExpr" type="xqxuf:replaceExpr" 
               substitutionGroup="xqxuf:expr"/&gt;


  &lt;!-- RenameExpr                                             --&gt;
  &lt;xsd:complexType name="renameExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxuf:expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="targetExpr"
                       type="xqx:exprWrapper"/&gt;
          &lt;xsd:element name="newNameExpr"
                       type="xqx:exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="renameExpr" type="xqxuf:renameExpr" 
               substitutionGroup="xqxuf:expr"/&gt;


  &lt;!-- TransformExpr                                          --&gt;
  &lt;xsd:complexType name="transformExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxuf:expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="transformCopies"&gt;
            &lt;xsd:complexType&gt;
              &lt;xsd:sequence&gt;
                &lt;xsd:element name="transformCopy" minOccurs="1" 
                             maxOccurs="unbounded"&gt;
                  &lt;xsd:complexType&gt;
                    &lt;xsd:sequence&gt;
                      &lt;xsd:element ref="xqx:varRef"/&gt;
                      &lt;xsd:element name="copySource"
                                   type="xqx:exprWrapper"/&gt;
                    &lt;/xsd:sequence&gt;
                  &lt;/xsd:complexType&gt;
                &lt;/xsd:element&gt;
              &lt;/xsd:sequence&gt;
            &lt;/xsd:complexType&gt;
          &lt;/xsd:element&gt;
          &lt;xsd:element name="modifyExpr"
                       type="xqx:exprWrapper"/&gt;
          &lt;xsd:element name="returnExpr"
                       type="xqx:exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="transformExpr" type="xqxuf:transformExpr" 
               substitutionGroup="xqxuf:expr"/&gt;


&lt;/xsd:schema&gt;



&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
	            xmlns="http://www.w3.org/2005/XQueryX"
	            targetNamespace="http://www.w3.org/2005/XQueryX"
	            elementFormDefault="qualified" attributeFormDefault="qualified"&gt;

&lt;!-- Redefine one or more components of the XQueryX XML Schema --&gt;
&lt;xsd:redefine schemaLocation="http://www.w3.org/2005/XQueryX/xqueryx.xsd"&gt;

&lt;!-- Redefine the functionDecl complex type --&gt;
  &lt;xsd:complexType name="functionDecl"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="functionDecl"&gt;
        &lt;xsd:attribute name="updatingFunction"
                       type="xsd:boolean" default="false"/&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

&lt;/xsd:redefine&gt;

&lt;/xsd:schema&gt;

</pre></div></div><div class="div2">
<h3><a name="id-xquf-update-stylesheet" id="id-xquf-update-stylesheet"/>E.2 Stylesheet</h3><p>
This section specifies the XSLT stylesheet that defines the semantics of XQueryX
in support of XQuery Update Facility 1.0. It imports the XSLT stylesheet defined in <a href="#xqueryx">[XQueryX 1.0]</a>,
and provides additional templates that
define the semantics of the XQueryX representation of XQuery Update Facility 1.0
by transforming that XQueryX representation into
the human readable syntax of XQuery Update Facility 1.0. 
</p><div class="exampleInner"><pre>

&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:xqxuf="http://www.w3.org/2007/xquery-update-10"
                xmlns:xqx="http://www.w3.org/2005/XQueryX"&gt;

&lt;!-- Initial creation                  2006-08-17: Jim Melton --&gt;
&lt;!-- Added revalidationDecl            2006-08-21: Jim Melton --&gt;
&lt;!-- Bring up to date with spec        2007-08-07: Jim Melton --&gt;
&lt;!-- Surround updating exprs w/parens  2007-09-13: Jim Melton --&gt;


&lt;xsl:import href="http://www.w3.org/2005/XQueryX/xqueryx.xsl"/&gt;


&lt;!-- revalidationDecl                                         --&gt;
&lt;xsl:template match="xqxuf:revalidationDecl"&gt;
  &lt;xsl:text&gt;declare revalidation &lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;!-- insertExpr                                               --&gt;
&lt;xsl:template match="xqxuf:insertExpr"&gt;
  &lt;xsl:value-of select="$LPAREN"/&gt;
  &lt;xsl:text&gt;insert nodes &lt;/xsl:text&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;xsl:apply-templates select="xqxuf:sourceExpr"/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;xsl:apply-templates select="xqxuf:insertInto |
                               xqxuf:insertBefore |
                               xqxuf:insertAfter"/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;xsl:apply-templates select="xqxuf:targetExpr"/&gt;
  &lt;xsl:value-of select="$RPAREN"/&gt;
&lt;/xsl:template&gt;


&lt;!-- sourceExpr                                               --&gt;
&lt;xsl:template match="xqxuf:sourceExpr"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;!-- insertInto                                               --&gt;
&lt;xsl:template match="xqxuf:insertInto"&gt;
  &lt;xsl:if test="child::node()"&gt;
    &lt;xsl:text&gt;as &lt;/xsl:text&gt;
  &lt;/xsl:if&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:text&gt;into &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;!-- insertAsFirst                                            --&gt;
&lt;xsl:template match="xqxuf:insertAsFirst"&gt;
  &lt;xsl:text&gt;first &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;!-- insertAsLast                                             --&gt;
&lt;xsl:template match="xqxuf:insertAsLast"&gt;
  &lt;xsl:text&gt;last &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;!-- insertAfter                                              --&gt;
&lt;xsl:template match="xqxuf:insertAfter"&gt;
  &lt;xsl:text&gt;after &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;!-- insertBefore                                             --&gt;
&lt;xsl:template match="xqxuf:insertBefore"&gt;
  &lt;xsl:text&gt;before &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;!-- targetExpr                                               --&gt;
&lt;xsl:template match="xqxuf:targetExpr"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;!-- deleteExpr                                               --&gt;
&lt;xsl:template match="xqxuf:deleteExpr"&gt;
  &lt;xsl:value-of select="$LPAREN"/&gt;
  &lt;xsl:text&gt;delete nodes &lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:value-of select="$RPAREN"/&gt;
&lt;/xsl:template&gt;


&lt;!-- replaceExpr                                              --&gt;
&lt;xsl:template match="xqxuf:replaceExpr"&gt;
  &lt;xsl:value-of select="$LPAREN"/&gt;
  &lt;xsl:text&gt;replace &lt;/xsl:text&gt;
  &lt;xsl:if test="xqxuf:replaceValue"&gt;
    &lt;xsl:text&gt;value of &lt;/xsl:text&gt;
  &lt;/xsl:if&gt;
  &lt;xsl:text&gt;node &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxuf:targetExpr"/&gt;
  &lt;xsl:text&gt; with &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxuf:replacementExpr"/&gt;
  &lt;xsl:value-of select="$RPAREN"/&gt;
&lt;/xsl:template&gt;


&lt;!-- replacementExpr                                          --&gt;
&lt;xsl:template match="xqxuf:replacementExpr"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;!-- renameExpr                                               --&gt;
&lt;xsl:template match="xqxuf:renameExpr"&gt;
  &lt;xsl:value-of select="$LPAREN"/&gt;
  &lt;xsl:text&gt;rename node &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxuf:targetExpr"/&gt;
  &lt;xsl:text&gt; as &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxuf:newNameExpr"/&gt;
  &lt;xsl:value-of select="$RPAREN"/&gt;
&lt;/xsl:template&gt;


&lt;!-- newNameExpr                                              --&gt;
&lt;xsl:template match="xqxuf:newNameExpr"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;!-- transformExpr                                            --&gt;
&lt;xsl:template match="xqxuf:transformExpr"&gt;
  &lt;xsl:value-of select="$LPAREN"/&gt;
  &lt;xsl:text&gt;copy &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxuf:transformCopies"/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;xsl:text&gt;  modify &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxuf:modifyExpr"/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;xsl:text&gt;  return &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxuf:returnExpr"/&gt;
  &lt;xsl:value-of select="$RPAREN"/&gt;
&lt;/xsl:template&gt;


&lt;!-- Part of transformExpr                                    --&gt;
&lt;xsl:template match="xqxuf:transformCopies"&gt;
  &lt;xsl:call-template name="commaSeparatedList"/&gt;
&lt;/xsl:template&gt;


&lt;!-- Part of transformExpr                                    --&gt;
&lt;xsl:template match="xqxuf:transformCopy"&gt;
  &lt;xsl:apply-templates select="xqx:varRef"/&gt;
  &lt;xsl:text&gt; := &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxuf:copySource"/&gt;
&lt;/xsl:template&gt;

&lt;!-- Part of transformExpr                                    --&gt;
&lt;xsl:template match="xqxuf:copySource"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;

&lt;!-- Part of transformExpr                                    --&gt;
&lt;xsl:template match="xqxuf:modifyExpr"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;!-- Part of transformExpr                                    --&gt;
&lt;xsl:template match="xqxuf:returnExpr"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;!-- Over-ride the template for functionDecl in XQueryX.xsd   --&gt;
  &lt;xsl:template match="xqx:functionDecl" priority="100"&gt;
    &lt;xsl:text&gt;declare &lt;/xsl:text&gt;
    &lt;xsl:if test="@xqx:updatingFunction and
                  @xqx:updatingFunction = 'true'"&gt;
      &lt;xsl:text&gt;updating &lt;/xsl:text&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:text&gt;function &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:functionName"/&gt;
    &lt;xsl:apply-templates select="xqx:paramList"/&gt;
    &lt;xsl:apply-templates select="xqx:typeDeclaration"/&gt;
    &lt;xsl:apply-templates select="xqx:functionBody"/&gt;
    &lt;xsl:if test="xqx:externalDefinition"&gt;
      &lt;xsl:text&gt; external &lt;/xsl:text&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;


&lt;/xsl:stylesheet&gt;

</pre></div></div><div class="div2">
<h3><a name="id-xquf-update-examples" id="id-xquf-update-examples"/>E.3 Example</h3><p>
The following example is based on the data and queries in the use cases
in <a href="#xquery-update-10-use-cases">[XQuery Update Facility 1.0 Use Cases]</a>. 
In this example, we show the English description of the query,
the XQuery Update Facility solution given in <a href="#xquery-update-10-use-cases">[XQuery Update Facility 1.0 Use Cases]</a>,
an XQueryX solution, and the XQuery Update Facility expression
that results from applying the Update Facility XQueryX-to-XQuery Update Facility transformation
defined by the stylesheet in <a href="#id-xquf-update-stylesheet"><b>[E.2 Stylesheet]</b></a>
to the Update Facility XQueryX solution.
The XQuery Update Facility expression that is produced is presented only as a sanity-check—the
intent of the stylesheet is not to recreate the original
XQuery expression, but to produce <em>a</em> valid
XQuery expression with the same semantics. 
The semantics of the Update Facility XQueryX solution are determined by the
semantics of the XQuery Update Facility expression that
results from that transformation. 
The "correctness" of that transformation is determined by
asking the following the question:
Can some Update Facility XQueryX processor QX process some
Update Facility XQueryX document D1 to produce results R1,
after which the stylesheet is used to translate D1 into an
XQuery Update Facility expression E1 that, when processed by some
XQuery Update Facility processor Q, produces results R2 that are equivalent
(under some meaningful definition of "equivalent") to results R1?
</p><p>Comparison of the results of the Update Facility XQueryX-to-XQuery Update Facility
transformation given in this document with the XQuery Update Facility solutions
in <a href="#xquery-update-10-use-cases">[XQuery Update Facility 1.0 Use Cases]</a> may be helpful in evaluating
the correctness of the Update Facility XQueryX solution in each example. </p><p>The XQuery Update Facility Use Cases solution given for each
example is provided only to assist readers of this
document in understanding the Update Facility XQueryX solution. 
There is no intent to imply that this
document specifies a "compilation" or "transformation" of
XQuery Update Facility syntax into Update Facility XQueryX syntax. 
</p><p>In the following example, note that path expressions are expanded to show their
structure. Also, note that the prefix syntax for binary operators like "and" makes the
precedence explicit. In general, humans find it easier to read an XML representation
that does not expand path expressions, but it is less convenient for programmatic
representation and manipulation.  XQueryX is designed as a language that is convenient
for production and modification by software, and not as a convenient syntax for humans to
read and write. </p><p>Finally, please note that white space, including new lines, have been added to
some of the Update Facility XQueryX documents and XQuery Update Facility expressions for readability. 
That additional white space is not produced by the
Update Facility XQueryX-to-XQuery Update Facility transformation.</p><p>This example is based on Q6 from <a href="#xquery-update-10-use-cases">[XQuery Update Facility 1.0 Use Cases]</a>,
use case Parts: "modifying recursive documents":</p><div class="div3">
<h4><a name="id-xquery-rep" id="id-xquery-rep"/>E.3.1 XQuery Representation</h4><div class="exampleInner"><pre>
for $keyword at $i in ("car", "skateboard", "canoe"),
    $parent in doc("part-tree.xml")//part[@name=$keyword]
let $descendants := $parent//part
for $p in ($parent, $descendants)
return 
  replace value of node $p/@partid with $i*1000+$p/@partid

</pre></div></div><div class="div3">
<h4><a name="id-xqueryx-rep" id="id-xqueryx-rep"/>E.3.2 XQueryX Representation</h4><div class="exampleInner"><pre>
&lt;?xml version="1.0"?&gt;
&lt;xqx:module xmlns:xqxuf="http://www.w3.org/2007/xquery-update-10"
            xmlns:xqx="http://www.w3.org/2005/XQueryX"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.w3.org/2007/xquery-update-10
    http://www.w3.org/2007/xquery-update-10/xquery-update-10-xqueryx.xsd
    http://www.w3.org/2005/XQueryX
    http://www.w3.org/2005/XQueryX/xqueryx.xsd"&gt;

  &lt;xqx:versionDecl&gt;
    &lt;xqx:version&gt;1.0&lt;/xqx:version&gt;
  &lt;/xqx:versionDecl&gt;
  &lt;xqx:mainModule&gt;
    &lt;xqx:queryBody&gt;
      &lt;xqx:flworExpr&gt;
        &lt;xqx:forClause&gt;
          &lt;xqx:forClauseItem&gt;
            &lt;xqx:typedVariableBinding&gt;
              &lt;xqx:varName&gt;keyword&lt;/xqx:varName&gt;
            &lt;/xqx:typedVariableBinding&gt;
            &lt;xqx:positionalVariableBinding&gt;i
            &lt;/xqx:positionalVariableBinding&gt;
            &lt;xqx:forExpr&gt;
              &lt;xqx:sequenceExpr&gt;
                &lt;xqx:stringConstantExpr&gt;
                  &lt;xqx:value&gt;car&lt;/xqx:value&gt;
                &lt;/xqx:stringConstantExpr&gt;
                &lt;xqx:stringConstantExpr&gt;
                  &lt;xqx:value&gt;skateboard&lt;/xqx:value&gt;
                &lt;/xqx:stringConstantExpr&gt;
                &lt;xqx:stringConstantExpr&gt;
                  &lt;xqx:value&gt;canoe&lt;/xqx:value&gt;
                &lt;/xqx:stringConstantExpr&gt;
              &lt;/xqx:sequenceExpr&gt;
            &lt;/xqx:forExpr&gt;
          &lt;/xqx:forClauseItem&gt;
          &lt;xqx:forClauseItem&gt;
            &lt;xqx:typedVariableBinding&gt;
              &lt;xqx:varName&gt;parent&lt;/xqx:varName&gt;
            &lt;/xqx:typedVariableBinding&gt;
            &lt;xqx:forExpr&gt;
              &lt;xqx:pathExpr&gt;
                &lt;xqx:stepExpr&gt;
                  &lt;xqx:filterExpr&gt;
                    &lt;xqx:functionCallExpr&gt;
                      &lt;xqx:functionName
                        xqx:prefix="fn"&gt;doc&lt;/xqx:functionName&gt;
                      &lt;xqx:arguments&gt;
                        &lt;xqx:stringConstantExpr&gt;
                          &lt;xqx:value&gt;part-tree.xml&lt;/xqx:value&gt;
                        &lt;/xqx:stringConstantExpr&gt;
                      &lt;/xqx:arguments&gt;
                    &lt;/xqx:functionCallExpr&gt;
                  &lt;/xqx:filterExpr&gt;
                &lt;/xqx:stepExpr&gt;
                &lt;xqx:stepExpr&gt;
                  &lt;xqx:xpathAxis&gt;descendant-or-self&lt;/xqx:xpathAxis&gt;
                  &lt;xqx:nameTest&gt;part&lt;/xqx:nameTest&gt;
                  &lt;xqx:predicates&gt;
                    &lt;xqx:equalOp&gt;
                      &lt;xqx:firstOperand&gt;
                        &lt;xqx:pathExpr&gt;
                          &lt;xqx:stepExpr&gt;
                            &lt;xqx:xpathAxis&gt;attribute&lt;/xqx:xpathAxis&gt;
                            &lt;xqx:nameTest&gt;name&lt;/xqx:nameTest&gt;
                          &lt;/xqx:stepExpr&gt;
                        &lt;/xqx:pathExpr&gt;
                      &lt;/xqx:firstOperand&gt;
                      &lt;xqx:secondOperand&gt;
                        &lt;xqx:varRef&gt;
                          &lt;xqx:name&gt;keyword&lt;/xqx:name&gt;
                        &lt;/xqx:varRef&gt;
                      &lt;/xqx:secondOperand&gt;
                    &lt;/xqx:equalOp&gt;
                  &lt;/xqx:predicates&gt;
                &lt;/xqx:stepExpr&gt;
              &lt;/xqx:pathExpr&gt;
            &lt;/xqx:forExpr&gt;
          &lt;/xqx:forClauseItem&gt;
        &lt;/xqx:forClause&gt;
        &lt;xqx:letClause&gt;
          &lt;xqx:letClauseItem&gt;
            &lt;xqx:typedVariableBinding&gt;
              &lt;xqx:varName&gt;descendants&lt;/xqx:varName&gt;
            &lt;/xqx:typedVariableBinding&gt;
            &lt;xqx:letExpr&gt;
              &lt;xqx:pathExpr&gt;
                &lt;xqx:stepExpr&gt;
                  &lt;xqx:filterExpr&gt;
                    &lt;xqx:varRef&gt;
                      &lt;xqx:name&gt;parent&lt;/xqx:name&gt;
                    &lt;/xqx:varRef&gt;
                  &lt;/xqx:filterExpr&gt;
                &lt;/xqx:stepExpr&gt;
                &lt;xqx:stepExpr&gt;
                  &lt;xqx:xpathAxis&gt;descendant-or-self&lt;/xqx:xpathAxis&gt;
                  &lt;xqx:nameTest&gt;part&lt;/xqx:nameTest&gt;
                &lt;/xqx:stepExpr&gt;
              &lt;/xqx:pathExpr&gt;
            &lt;/xqx:letExpr&gt;
          &lt;/xqx:letClauseItem&gt;
        &lt;/xqx:letClause&gt;
        &lt;xqx:forClause&gt;
          &lt;xqx:forClauseItem&gt;
            &lt;xqx:typedVariableBinding&gt;
              &lt;xqx:varName&gt;p&lt;/xqx:varName&gt;
            &lt;/xqx:typedVariableBinding&gt;
            &lt;xqx:forExpr&gt;
              &lt;xqx:sequenceExpr&gt;
                &lt;xqx:varRef&gt;
                  &lt;xqx:name&gt;parent&lt;/xqx:name&gt;
                &lt;/xqx:varRef&gt;
                &lt;xqx:varRef&gt;
                  &lt;xqx:name&gt;descendants&lt;/xqx:name&gt;
                &lt;/xqx:varRef&gt;
              &lt;/xqx:sequenceExpr&gt;
            &lt;/xqx:forExpr&gt;
          &lt;/xqx:forClauseItem&gt;
        &lt;/xqx:forClause&gt;
        &lt;xqx:returnClause&gt;
          &lt;xqxuf:replaceExpr&gt;
            &lt;xqxuf:replaceValue/&gt;
            &lt;xqxuf:targetExpr&gt;
              &lt;xqx:pathExpr&gt;
                &lt;xqx:stepExpr&gt;
                  &lt;xqx:filterExpr&gt;
                    &lt;xqx:varRef&gt;
                      &lt;xqx:name&gt;p&lt;/xqx:name&gt;
                    &lt;/xqx:varRef&gt;
                  &lt;/xqx:filterExpr&gt;
                &lt;/xqx:stepExpr&gt;
                &lt;xqx:stepExpr&gt;
                  &lt;xqx:xpathAxis&gt;attribute&lt;/xqx:xpathAxis&gt;
                  &lt;xqx:nameTest&gt;partid&lt;/xqx:nameTest&gt;
                &lt;/xqx:stepExpr&gt;
              &lt;/xqx:pathExpr&gt;
            &lt;/xqxuf:targetExpr&gt;
            &lt;xqxuf:replacementExpr&gt;
              &lt;xqx:addOp&gt;
                &lt;xqx:firstOperand&gt;
                  &lt;xqx:multiplyOp&gt;
                    &lt;xqx:firstOperand&gt;
                      &lt;xqx:varRef&gt;
                        &lt;xqx:name&gt;i&lt;/xqx:name&gt;
                      &lt;/xqx:varRef&gt;
                    &lt;/xqx:firstOperand&gt;
                    &lt;xqx:secondOperand&gt;
                      &lt;xqx:integerConstantExpr&gt;
                        &lt;xqx:value&gt;1000&lt;/xqx:value&gt;
                      &lt;/xqx:integerConstantExpr&gt;
                    &lt;/xqx:secondOperand&gt;
                  &lt;/xqx:multiplyOp&gt;
                &lt;/xqx:firstOperand&gt;
                &lt;xqx:secondOperand&gt;
                  &lt;xqx:pathExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:filterExpr&gt;
                        &lt;xqx:varRef&gt;
                          &lt;xqx:name&gt;p&lt;/xqx:name&gt;
                        &lt;/xqx:varRef&gt;
                      &lt;/xqx:filterExpr&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;attribute&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:nameTest&gt;partid&lt;/xqx:nameTest&gt;
                    &lt;/xqx:stepExpr&gt;
                  &lt;/xqx:pathExpr&gt;
                &lt;/xqx:secondOperand&gt;
              &lt;/xqx:addOp&gt;
            &lt;/xqxuf:replacementExpr&gt;
          &lt;/xqxuf:replaceExpr&gt;
        &lt;/xqx:returnClause&gt;
      &lt;/xqx:flworExpr&gt;
    &lt;/xqx:queryBody&gt;
  &lt;/xqx:mainModule&gt;
&lt;/xqx:module&gt;

</pre></div></div><div class="div3">
<h4><a name="id-transformed-rep" id="id-transformed-rep"/>E.3.3 Transformed XQuery Representation</h4><p>Application of the stylesheet in <a href="#id-xquf-update-stylesheet"><b>[E.2 Stylesheet]</b></a> to the
Update Facility XQueryX representation results in the following XQuery representation:</p><div class="exampleInner"><pre>
 xquery version "1.0";

( for $keyword at $i in ("car", "skateboard", "canoe"),
 $parent in
   fn:doc("part-tree.xml")/descendant-or-self::part
     [(attribute::name = $keyword)]
 let $descendants:=$parent/descendant-or-self::part
 for $p in ($parent, $descendants)
 return
   replace value of node $p/attribute::partid
     with (($i*1000)+$p/attribute::partid)
)

</pre></div></div></div></div><div class="div1">
<h2><a name="id-glossary" id="id-glossary"/>F Glossary (Non-Normative)</h2><dl><dt><a name="GLdt-xdm-instance"/>XDM instance</dt><dd><p>The term <b>XDM instance</b>
denotes an unconstrained sequence of zero or more nodes and/or atomic values
as defined by the <a title="data model" href="#dt-data-model">data model</a>.</p></dd><dt><a name="GLdt-xquery"/>XQuery</dt><dd><p>Within this document,
the term <b>XQuery</b> refers to the language specified by <a href="#xquery">[XQuery 1.0]</a>.</p></dd><dt><a name="GLdt-basic-updating-expression"/>basic updating expression</dt><dd><p>A <b>basic updating expression</b> is an insert, delete, replace, or rename expression, or a call to an <a title="updating function" href="#dt-updating-function">updating function</a>.</p></dd><dt><a name="GLdt-conflict"/>conflict</dt><dd><p>Two namespace bindings are said to
<b>conflict</b> if their namespace prefixes (or absence thereof) are
the same but their namespace URI's (or absence thereof) are different.</p></dd><dt><a name="GLdt-data-model"/>data model</dt><dd><p>The term <b>data model</b> refers to
the data model specified by <a href="#xpath-datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>.</p></dd><dt><a name="GLdt-implied-namespace-binding"/>implied namespace binding</dt><dd><p>The
<b>implied namespace binding</b> of a QName is the association of its namespace prefix
(or absence thereof) with its namespace URI (or absence thereof).</p></dd><dt><a name="GLdt-mark"/>mark</dt><dd><p>To <b>mark</b> a node means to identify the node as participating in a later operation.</p></dd><dt><a name="GLmay"/>may</dt><dd><p>
            <b>MAY</b> means that an item is truly optional.</p></dd><dt><a name="GLmust"/>must</dt><dd><p>
            <b>MUST</b> means that the item is an absolute requirement of the specification.</p></dd><dt><a name="GLdt-node-identity"/>node identity</dt><dd><p>The term <b>node identity</b>
denotes the unique identity that is a property of every node in an
<a title="XDM instance" href="#dt-xdm-instance">XDM instance</a>
(see <a href="http://www.w3.org/TR/xpath-datamodel/#node-identity">Section 
2.3 Node Identity</a><sup><small>DM</small></sup>.)</p></dd><dt><a name="GLdt-pending-update-list"/>pending update list</dt><dd><p>A <b>pending update list</b> is an unordered collection of <a title="update primitive" href="#dt-update-primitive">update primitives</a>, which represent node state changes that have not yet been applied.</p></dd><dt><a name="GLdt-revalidation-decl"/>revalidation declaration</dt><dd><p>A <b>revalidation declaration</b>
sets the <a title="revalidation mode" href="#dt-revalidation-mode">revalidation mode</a> in the static context,
overriding any implementation-defined default.</p></dd><dt><a name="GLdt-revalidation-mode"/>revalidation mode</dt><dd><p><b>Revalidation mode</b>,
which may be <code>strict</code>, <code>lax</code>, or <code>skip</code>,
is a component of the static context that controls the behavior of the
<code><a href="#id-upd-revalidate">upd:revalidate</a></code> operation.</p></dd><dt><a name="GLshould"/>should</dt><dd><p>
            <b>SHOULD</b> means that there may exist valid reasons in particular circumstances
            to ignore a particular item, but the full implications must be understood and carefully
            weighed before choosing a different course.</p></dd><dt><a name="GLdt-simple-expression"/>simple expression</dt><dd><p>A <b>simple expression</b> is any XQuery expression that is not an <a title="updating expression" href="#dt-updating-expression">updating expression</a>.</p></dd><dt><a name="GLdt-snapshot"/>snapshot</dt><dd><p>A <b>snapshot</b> is a scope within which expressions are evaluated
with respect to a fixed <a title="XDM instance" href="#dt-xdm-instance">XDM instance</a> and updates are held pending.</p></dd><dt><a name="GLupd-static-typing-feature"/>static typing feature</dt><dd><p>The <b>Update
                Facility Static Typing Feature</b> provides support
                for the static semantics defined in <a href="#id-update-static"><b>[4 Static Typing Feature]</b></a>,
                and requires implementations to detect and report type errors
                during the static analysis phase.</p></dd><dt><a name="GLdt-target-node"/>target node</dt><dd><p>The first argument of an update primitive, called its <b>target node</b>, is the principal node to be affected by the update primitive.</p></dd><dt><a name="GLdt-update-operation"/>update operation</dt><dd><p><b>Update operations</b> are used in defining the semantics of XQuery updates, but are not directly available to users. Update operations are defined in <a href="#id-update-operations"><b>[3 Update Operations]</b></a>.</p></dd><dt><a name="GLdt-update-primitive"/>update primitive</dt><dd><p><b>Update primitives</b> are the components of <a title="pending update list" href="#dt-pending-update-list">pending update lists</a>. Each <b>update primitive</b> represents a node state change that has not yet been applied.</p></dd><dt><a name="GLdt-update-routine"/>update routine</dt><dd><p><b>Update routines</b> are sequences of actions that are used in the definition of XQuery semantics but do not appear on <a title="pending update list" href="#dt-pending-update-list">pending update lists</a>.</p></dd><dt><a name="GLdt-updating-expression"/>updating expression</dt><dd><p>An <b>updating expression</b> is a <a title="basic updating expression" href="#dt-basic-updating-expression">basic updating expression</a> or any
expression (other than a transform expression) that directly
contains an <a title="updating expression" href="#dt-updating-expression">updating expression</a>.</p></dd><dt><a name="GLdt-updating-function"/>updating function</dt><dd><p>Functions whose declarations contain the keyword <code>updating</code>, and certain built-in functions including <code>fn:put</code>, are called <b>updating functions</b>.</p></dd><dt><a name="GLdt-vacuous-expression-obsolete"/>vacuous expression</dt><dd><p>A <b>vacuous expression</b> is a <a title="simple expression" href="#dt-simple-expression">simple expression</a> that can only return an empty sequence or raise an error.</p></dd><dt><a name="GLdt-vacuous-expression"/>vacuous expression</dt><dd><p>
Certain expressions are defined in this specification
   to be <b>vacuous expressions</b>. These all have the characteristic that
   they can be determined statically to either return an empty
   sequence or raise an error.</p></dd></dl></div><div class="div1">
<h2><a name="id-precedence-rationale" id="id-precedence-rationale"/>G Rationale for Precedence of Update Primitives (Non-Normative)</h2><p>In <a href="#id-upd-apply-updates"><b>[3.2.2 upd:applyUpdates]</b></a>, semantic rules specify the order in which
  the <a title="update primitive" href="#dt-update-primitive">update primitives</a> on a
  <a title="pending update list" href="#dt-pending-update-list">pending update list</a> are applied. 
  The purpose of this ordering is to ensure that the result of applying the pending update list is deterministic. 
  The order of application of the update primitives was derived from the following reasoning:</p><ul><li><p>
        <code>insertAttribute</code>, <code>replaceValue</code>, and <code>rename</code> primitives do not conflict with any 
        other primitives other than <code>put</code>.</p></li><li><p>
        <code>insertInto</code>primitives must be applied before <code>insertIntoAsFirst/Last</code> and
        <code>insertBefore/After</code>primitives. Reason: if  an unpositioned insert were applied after a 
        positioned insert, it  might interfere with the position established by the earlier positioned insert. 
        For example, suppose node A is inserted "before" node B. 
        A later unpositioned insert into the common parent of A and B might intervene between A and B,
        which is not allowed by the semantics of "insert before."</p></li><li><p>
        <code>insertBefore/After</code>primitives must be applied before <code>replaceNode</code> primitives. 
        Reason: After a node  has been replaced, it no longer has a parent, so "before" and "after" the replaced node
        are no longer defined.</p></li><li><p>
        <code>insertIntoAsFirst/Last</code>primitives must be applied before <code>replaceElementContent</code> primitives. 
        Reason: this was a decision of the working group. 
        The intent of this decision is that, if both of these primitives are applied to the same target node in a query,
        the effective result is determined by the <code>replaceElementContent</code> primitive.</p></li><li><p>
        <code>replaceNode</code>primitives must be applied before <code>replaceElementContent</code> primitives. 
        Reason: if element  content that includes a node N has been replaced, then N no longer has a parent. 
        In this case, "replace node N" is undefined.</p></li><li><p>
        <code>replaceNode</code>primitives must be applied before <code>delete</code> primitives. Reason: After a node has been 
        deleted, it no longer has a parent. Replacing a node that has no parent is undefined.</p></li><li><p>
        <code>put</code>primitives must be applied after all other primitives in order that
        documents stored by a snapshot will reflect all update operations applied by the snapshot.</p></li></ul></div><div class="div1">
<h2><a name="id-revision-log" id="id-revision-log"/>H Revision Log (Non-Normative)</h2><p>The following substantive changes have been made to this document since the Candidate Recommendation of 9 June 2009. 
     Minor editorial changes are not included in this log.</p><ol class="enumar"><li><p>Fixed a bug involving namespace propagation and default
      namespaces. Resolves <a href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=9432#c2">Bug 9432</a>. 
      </p></li><li><p>Added missing parameter to upd:applyUpdates(). Resolves <a href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=9262">Bug
      9262</a>.</p></li><li><p>Added missing text governing namespace binding conflicts when the namespace prefix for an attribute is absent.
      Resolves <a href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=9257">Bug 9257</a>.</p></li><li><p>Fixed two errors governing namespace bindings created by
      upd:replaceNode(). The erroneous text said that the namespace
      binding was created on the attribute itself, rather than the
      parent element. Resolves <a href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=9256">Bug
      9256</a>.</p></li><li><p>Added a note indicating that some examples are rejected by
      implementations that support static typing. See <a href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=8006">Bug
      8006</a>.</p></li></ol><p>The following substantive changes have been  made to this document since the Candidate Recommendation of 14 March 2008.</p><ol class="enumar"><li><p>Added a rule: the expression on the right-hand-side of a variable declaration
      the initializing expression) must be a simple expression. Resolves Bug 5699. 
      Section affected: <a href="#id-variable-declaration"><b>[2.2.2 Variable Declaration]</b></a>.</p></li><li><p>When a rename expression operates on an attribute node, err:XUDY0023 can be raised
      only if the new name of the attribute is in a namespace. 
      Renaming an attribute to a QName that has neither a namespace prefix nor a namespace URI is not an error,
      even if the parent element has a default namespace. 
      Partial resolution of Bug 5629. Section affected: <a href="#id-rename"><b>[2.4.4 Rename]</b></a>.</p></li><li><p>When a <code>upd:rename</code> operation is applied to an element node, and
      the <code>$newname</code> operand is a QName that has neither a namespace prefix nor a namespace URI,
      part of the semantics of the operation is to remove the namespace binding for the empty prefix (if any)
      from the element node. 
      Partial resolution of Bug 5629. 
      Section affected: <a href="#id-upd-rename"><b>[3.1.11 upd:rename]</b></a>.</p></li><li><p>Optional error err:XUDY0020 (deletion of a node that has no parent) is made part of the semantics
      of the delete expression (formerly it was described under the <code>upd:delete</code> primitive). 
      Partial resolution of Bug 5632. 
      Sections affected: <a href="#id-delete"><b>[2.4.2 Delete]</b></a>, <a href="#id-upd-delete"><b>[3.1.7 upd:delete]</b></a>.</p></li><li><p>Error err:XUDY0024 (updates introducing conflicting namespace bindings) is made part of the semantics
      of the insert and replace expressions. 
      Also, consistency constraints on Pending Update Lists, raising err:XUDY0024 if multiple primitives
      on a PUL have conflicting namespace bindings, have been added to the semantics of
      <code>upd:mergeUpdates</code> and <code>upd:applyUpdates</code>. 
      Checks for err:XUDY0024 are no longer part of the semantics of <code>upd:insertAttributes</code>,
      <code>upd:replaceNode</code>, or <code>upd:rename</code>. 
      The net effect of these changes is to enable implementations to catch conflicting namespace bindings
      earlier and to associate them with specific expressions. 
      Dynamic errors are no longer generated by individual update primitives on Pending Update Lists. 
      Partial resolution of Bug 5632. 
      Sections affected: <a href="#id-insert"><b>[2.4.1 Insert]</b></a>, <a href="#id-replace"><b>[2.4.3 Replace]</b></a>,
      <a href="#id-upd-insert-attributes"><b>[3.1.6 upd:insertAttributes]</b></a>, <a href="#id-upd-replacenode"><b>[3.1.8 upd:replaceNode]</b></a>,
      <a href="#id-upd-rename"><b>[3.1.11 upd:rename]</b></a>, <a href="#id-upd-merge-updates"><b>[3.2.1 upd:mergeUpdates]</b></a>,
      <a href="#id-upd-apply-updates"><b>[3.2.2 upd:applyUpdates]</b></a>.</p></li><li><p>The following changes were made to the semantics of <code>fn:put</code> (resolving Bug 5646):</p><ol class="enumla"><li><p><code>fn:put</code> now generates an update primitive called <code>upd:put</code>,
          which is held on the pending update list and applied after all other update primitives. 
          Sections: <a href="#id-func-put"><b>[2.6.1 fn:put]</b></a>, <a href="#id-upd-put"><b>[3.1.12 upd:put]</b></a>.</p></li><li><p>It is an error to invoke <code>fn:put</code> more than once on the same URI within a snapshot. 
          Sections: <a href="#id-compatibility"><b>[2.4.6 Compatibility of Updating Expressions]</b></a>, <a href="#id-upd-merge-updates"><b>[3.2.1 upd:mergeUpdates]</b></a>,
          <a href="#id-upd-apply-updates"><b>[3.2.2 upd:applyUpdates]</b></a>, <a href="#id-new-error-codes"><b>[D.1 New Error Codes]</b></a>.</p></li><li><p><code>fn:put</code> is classified as an updating function. Section: <a href="#id-function-declaration"><b>[2.2.3 Function Declaration]</b></a>.</p></li></ol></li><li><p>Moved the subsection on Function Declarations inside the section on Extensions to the Prolog. 
      Resolves Bug 5701. Section affected: <a href="#id-function-declaration"><b>[2.2.3 Function Declaration]</b></a></p></li><li><p>In the Static Typing Feature for XQuery Update Facility, err:XPST0005 applies only to
      simple expressions (not to updating expressions.) 
      Resolves Bug 5700. Sections affected: <a href="#id-static-typing-changes"><b>[4.2 Change to Static Typing Rules of XQuery 1.0]</b></a>,
      <a href="#id-amended-error-codes"><b>[D.2 Amendments to Existing Error Codes]</b></a>.</p></li><li><p>In the Static Type Analysis for TransformExpr, the static type of each copy-variable
      used to be the type inferred from its source expression; now it's just node().</p></li></ol><p>No substantive changes have been made to this document since the Proposed Recommendation of 25 January 2011.</p></div></div></body></html>