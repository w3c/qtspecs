<?xml version="1.0" encoding="UTF-8"?>
<!--XSLT Processor: Saxonica SAXON HE 9.6.0.7--><html xmlns="http://www.w3.org/1999/xhtml" lang="EN">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      <title>XQuery, XPath, and XSLT Functions and Operators Namespace Document </title>
      <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" /><style type="text/css"> </style><link rel="stylesheet" type="text/css" href="http://www.w3.org/StyleSheets/TR/base.css" />
   </head>
   <body>
      <div class="head">
         <p><a href="http://www.w3.org/"><img src="http://www.w3.org/Icons/w3c_home" alt="W3C" height="48" width="72" /></a></p>
         <h1><a name="title" id="title"></a>XQuery, XPath, and XSLT Functions and Operators Namespace Document
         </h1>
         <h2>21 March 2017</h2>
      </div>
      <nav id="toc">
         
         <h2><a id="contents"></a>Table of Contents
         </h2>
         <ol class="toc">
            <li><a href="#intro"><span class="secno">1 </span><span class="content">Introduction</span></a>
               
               <ol class="toc"></ol>
            </li>
            <li><a href="#fo-summary"><span class="secno">2 </span><span class="content">XQuery and XPath Functions</span></a>
               
               <ol class="toc"></ol>
            </li>
            <li><a href="#xslt-summary"><span class="secno">3 </span><span class="content">XSL Transformations (XSLT) Functions</span></a>
               
               <ol class="toc"></ol>
            </li>
            <li><a href="#xqupdate-summary"><span class="secno">4 </span><span class="content">XQuery Update Functions</span></a>
               
               <ol class="toc"></ol>
            </li>
            <li><a href="#schemas"><span class="secno">5 </span><span class="content">XML Schema</span></a>
               
               <ol class="toc"></ol>
            </li>
            <li><a href="#normrefs"><span class="secno">6 </span><span class="content">Normative References</span></a>
               
               <ol class="toc"></ol>
            </li>
            <li><a href="#nonnormrefs"><span class="secno">7 </span><span class="content">Non-Normative References</span></a>
               
               <ol class="toc"></ol>
            </li>
         </ol>
      </nav>
      <hr />
      <div class="body">
         <div>
            
            <h2><a id="intro"></a>1 Introduction
            </h2>
            <p>This document describes the namespace
               <code>http://www.w3.org/2005/xpath-functions</code> defined by the
               [XPath and XQuery Functions and Operators 3.1] and [XSLT 3.0]
               specifications.
               This namespace is conventionally identified by the namespace prefix <code>fn</code>.
            </p>
            <p>In XQuery, the mapping of the prefix <code>fn</code> to this namespace is predefined.
            </p>
            <p>In XSLT, it is not necessary to use a prefix when invoking functions in this namespace,
               because this namespace is always the default namespace for function calls.
            </p>
            <p>For updated information, please refer to the latest version of the
               [XPath and XQuery Functions and Operators 3.1] and [XSLT 3.0]
               specifications.
            </p>
            <p>The [XQuery Update 1.0] specification defines one additional function in this namespace.</p>
            <p>Functions are uniquely identified by the combination of namespace URI, local name,
               and arity (number of arguments). For the
               purpose of this document, functions having a common namespace URI and local name can
               be considered to
               form a function family. A
               function family can be uniquely identified with a URI of the form:
               “<code>http://www.w3.org/2005/xpath-functions#</code><em>name</em>”
               where <em>name</em> is the local name of a function, such as
               “max”: <code><a href="#max">http://www.w3.org/2005/xpath-functions#max</a></code>.
            </p>
            <p>
               This document describes the names that are defined in this
               namespace at the time of publication. The W3C reserves the right to
               define additional names in this namespace in the future.
               The specifications listed above are the <em>only</em> specifications that may amend this namespace.
               
            </p>
            <p>The specifications referenced in this document are the latest versions at time of
               publication. Older
               versions of these specifications remain in use, and depending on the context, a name
               in this namespace
               may be referring to an older version of the specification than the one cited here.
            </p>
            <p>
               This document contains a directory of links to related resources, using RDDL
               (as defined in [Resource Directory Description Language (RDDL)]). 
               
            </p>
            <p>
               It is GRDDL-enabled (as defined in [Gleaning Resource Descriptions from Dialects of
               Languages (GRDDL)]); that is to
               say that a GRDDL-compliant processor can extract useful RDF
               (as defined in [Resource Description Framework (RDF): Concepts and Abstract Syntax])
               representations of the information contained herein.
               
            </p>
         </div>
         <div class="resource">
            
            <h2><a id="fo-summary"></a>2 XQuery and XPath Functions
            </h2>
            <p>This section lists all of the functions in this namespace that are defined in the
               [XPath and XQuery Functions and Operators 3.1] specification. 
            </p>
            <p>The normative definitions of these functions are in the
               [XPath and XQuery Functions and Operators 3.1] specification.
               For convenience, a very brief, non-normative summary of each
               function is provided. For details, follow the link on the “Summary:”
               introductory text below each function.
            </p>
            <h3><a name="abs" id="abs"></a>abs
            </h3>
            <p><strong>abs</strong>(xs:numeric?) as xs:numeric?
            </p>
            
            <p>Returns the absolute value of <code>$arg</code>.
            </p>
            
            <h3><a name="adjust-dateTime-to-timezone" id="adjust-dateTime-to-timezone"></a>adjust-dateTime-to-timezone
            </h3>
            <p><strong>adjust-dateTime-to-timezone</strong>(xs:dateTime?) as xs:dateTime?
            </p>
            <p><strong>adjust-dateTime-to-timezone</strong>(xs:dateTime?, xs:dayTimeDuration?) as xs:dateTime?
            </p>
            
            <p>Adjusts an <code>xs:dateTime</code> value to a specific timezone, or to no timezone at
               all.
            </p>
            
            <h3><a name="adjust-date-to-timezone" id="adjust-date-to-timezone"></a>adjust-date-to-timezone
            </h3>
            <p><strong>adjust-date-to-timezone</strong>(xs:date?) as xs:date?
            </p>
            <p><strong>adjust-date-to-timezone</strong>(xs:date?, xs:dayTimeDuration?) as xs:date?
            </p>
            
            <p>Adjusts an <code>xs:date</code> value to a specific timezone, or to no timezone at all;
               the result is the date in the target timezone that contains the starting instant of
               the
               supplied date.
            </p>
            
            <h3><a name="adjust-time-to-timezone" id="adjust-time-to-timezone"></a>adjust-time-to-timezone
            </h3>
            <p><strong>adjust-time-to-timezone</strong>(xs:time?) as xs:time?
            </p>
            <p><strong>adjust-time-to-timezone</strong>(xs:time?, xs:dayTimeDuration?) as xs:time?
            </p>
            
            <p>Adjusts an <code>xs:time</code> value to a specific timezone, or to no timezone at
               all.
            </p>
            
            <h3><a name="analyze-string" id="analyze-string"></a>analyze-string
            </h3>
            <p><strong>analyze-string</strong>(xs:string?, xs:string) as element(fn:analyze-string-result)
            </p>
            <p><strong>analyze-string</strong>(xs:string?, xs:string, xs:string) as element(fn:analyze-string-result)
            </p>
            
            <p>Analyzes a string using a regular expression, returning an XML structure that identifies
               which parts of the input string matched or failed to match the regular expression,
               and
               in the case of matched substrings, which substrings matched each capturing group in
               the
               regular expression.
            </p>
            
            <h3><a name="apply" id="apply"></a>apply
            </h3>
            <p><strong>apply</strong>(function(*), array(*)) as item()*
            </p>
            
            <p>Makes a dynamic call on a function with an argument list supplied in the form of an
               array.
            </p>
            
            <h3><a name="available-environment-variables" id="available-environment-variables"></a>available-environment-variables
            </h3>
            <p><strong>available-environment-variables</strong>() as xs:string*
            </p>
            
            <p>Returns a list of environment variable names that are suitable for passing to
               <code>fn:environment-variable</code>, as a (possibly empty) sequence of strings.
            </p>
            
            <h3><a name="avg" id="avg"></a>avg
            </h3>
            <p><strong>avg</strong>(xs:anyAtomicType*) as xs:anyAtomicType?
            </p>
            
            <p>Returns the average of the values in the input sequence <code>$arg</code>, that is, the
               sum of the values divided by the number of values.
            </p>
            
            <h3><a name="base-uri" id="base-uri"></a>base-uri
            </h3>
            <p><strong>base-uri</strong>() as xs:anyURI?
            </p>
            <p><strong>base-uri</strong>(node()?) as xs:anyURI?
            </p>
            
            <p>Returns the base URI of a node.</p>
            
            <h3><a name="boolean" id="boolean"></a>boolean
            </h3>
            <p><strong>boolean</strong>(item()*) as xs:boolean
            </p>
            
            <p>Computes the effective boolean value of the sequence <code>$arg</code>.
            </p>
            
            <h3><a name="ceiling" id="ceiling"></a>ceiling
            </h3>
            <p><strong>ceiling</strong>(xs:numeric?) as xs:numeric?
            </p>
            
            <p>Rounds <code>$arg</code> upwards to a whole number.
            </p>
            
            <h3><a name="codepoint-equal" id="codepoint-equal"></a>codepoint-equal
            </h3>
            <p><strong>codepoint-equal</strong>(xs:string?, xs:string?) as xs:boolean?
            </p>
            
            <p>Returns true if two strings are equal, considered codepoint-by-codepoint.</p>
            
            <h3><a name="codepoints-to-string" id="codepoints-to-string"></a>codepoints-to-string
            </h3>
            <p><strong>codepoints-to-string</strong>(xs:integer*) as xs:string
            </p>
            
            <p>Returns an <code>xs:string</code> whose characters have supplied codepoints.
            </p>
            
            <h3><a name="collation-key" id="collation-key"></a>collation-key
            </h3>
            <p><strong>collation-key</strong>(xs:string) as xs:base64Binary
            </p>
            <p><strong>collation-key</strong>(xs:string, xs:string) as xs:base64Binary
            </p>
            
            <p>Given a string value and a collation, generates an internal value called a collation
               key, with the property that
               the matching and ordering of collation keys reflects the matching and ordering of
               strings under the specified collation.
            </p>
            
            <h3><a name="collection" id="collection"></a>collection
            </h3>
            <p><strong>collection</strong>() as item()*
            </p>
            <p><strong>collection</strong>(xs:string?) as item()*
            </p>
            
            <p>Returns a sequence of items identified by a
               collection URI; or a default collection if no URI is supplied.
            </p>
            
            <h3><a name="compare" id="compare"></a>compare
            </h3>
            <p><strong>compare</strong>(xs:string?, xs:string?) as xs:integer?
            </p>
            <p><strong>compare</strong>(xs:string?, xs:string?, xs:string) as xs:integer?
            </p>
            
            <p>Returns -1, 0, or 1, depending on whether <code>$comparand1</code> collates before,
               equal to, or after <code>$comparand2</code> according to the rules of a selected
               collation.
            </p>
            
            <h3><a name="concat" id="concat"></a>concat
            </h3>
            <p><strong>concat</strong>(xs:anyAtomicType?, xs:anyAtomicType?, xs:anyAtomicType?) as xs:string
            </p>
            
            <p>Returns the concatenation of the string values of the arguments.</p>
            
            <h3><a name="contains" id="contains"></a>contains
            </h3>
            <p><strong>contains</strong>(xs:string?, xs:string?) as xs:boolean
            </p>
            <p><strong>contains</strong>(xs:string?, xs:string?, xs:string) as xs:boolean
            </p>
            
            <p>Returns true if the string <code>$arg1</code> contains <code>$arg2</code> as a
               substring, taking collations into account.
            </p>
            
            <h3><a name="contains-token" id="contains-token"></a>contains-token
            </h3>
            <p><strong>contains-token</strong>(xs:string*, xs:string) as xs:boolean
            </p>
            <p><strong>contains-token</strong>(xs:string*, xs:string, xs:string) as xs:boolean
            </p>
            
            <p>Determines whether or not any of the supplied strings, when tokenized at whitespace
               boundaries, contains the supplied token,
               under the rules of the supplied collation.
            </p>
            
            <h3><a name="count" id="count"></a>count
            </h3>
            <p><strong>count</strong>(item()*) as xs:integer
            </p>
            
            <p>Returns the number of items in a sequence.</p>
            
            <h3><a name="current-date" id="current-date"></a>current-date
            </h3>
            <p><strong>current-date</strong>() as xs:date
            </p>
            
            <p>Returns the current date.</p>
            
            <h3><a name="current-dateTime" id="current-dateTime"></a>current-dateTime
            </h3>
            <p><strong>current-dateTime</strong>() as xs:dateTimeStamp
            </p>
            
            <p>Returns the current date and time (with timezone).</p>
            
            <h3><a name="current-time" id="current-time"></a>current-time
            </h3>
            <p><strong>current-time</strong>() as xs:time
            </p>
            
            <p>Returns the current time.</p>
            
            <h3><a name="data" id="data"></a>data
            </h3>
            <p><strong>data</strong>() as xs:anyAtomicType*
            </p>
            <p><strong>data</strong>(item()*) as xs:anyAtomicType*
            </p>
            
            <p>Returns the result of atomizing a sequence. This process flattens arrays, and replaces
               nodes by their typed values.
            </p>
            
            <h3><a name="dateTime" id="dateTime"></a>dateTime
            </h3>
            <p><strong>dateTime</strong>(xs:date?, xs:time?) as xs:dateTime?
            </p>
            
            <p>Returns an <code>xs:dateTime</code> value created by combining an <code>xs:date</code>
               and an <code>xs:time</code>.
            </p>
            
            <h3><a name="day-from-date" id="day-from-date"></a>day-from-date
            </h3>
            <p><strong>day-from-date</strong>(xs:date?) as xs:integer?
            </p>
            
            <p>Returns the day component of an <code>xs:date</code>.
            </p>
            
            <h3><a name="day-from-dateTime" id="day-from-dateTime"></a>day-from-dateTime
            </h3>
            <p><strong>day-from-dateTime</strong>(xs:dateTime?) as xs:integer?
            </p>
            
            <p>Returns the day component of an <code>xs:dateTime</code>.
            </p>
            
            <h3><a name="days-from-duration" id="days-from-duration"></a>days-from-duration
            </h3>
            <p><strong>days-from-duration</strong>(xs:duration?) as xs:integer?
            </p>
            
            <p>Returns the number of days in a duration.</p>
            
            <h3><a name="deep-equal" id="deep-equal"></a>deep-equal
            </h3>
            <p><strong>deep-equal</strong>(item()*, item()*) as xs:boolean
            </p>
            <p><strong>deep-equal</strong>(item()*, item()*, xs:string) as xs:boolean
            </p>
            
            <p> This function assesses whether two sequences are deep-equal to each other. To be
               deep-equal, they must contain items that are pairwise deep-equal; and for two items
               to
               be deep-equal, they must either be atomic values that compare equal, or nodes of the
               same kind, with the same name, whose children are deep-equal<span>,
                  or maps with matching entries, or arrays with matching members.</span></p>
            
            <h3><a name="default-collation" id="default-collation"></a>default-collation
            </h3>
            <p><strong>default-collation</strong>() as xs:string
            </p>
            
            <p>Returns the value of the default collation property from the static context. </p>
            
            <h3><a name="default-language" id="default-language"></a>default-language
            </h3>
            <p><strong>default-language</strong>() as xs:language
            </p>
            
            <p>Returns the value of the default language property from the dynamic context. </p>
            
            <h3><a name="distinct-values" id="distinct-values"></a>distinct-values
            </h3>
            <p><strong>distinct-values</strong>(xs:anyAtomicType*) as xs:anyAtomicType*
            </p>
            <p><strong>distinct-values</strong>(xs:anyAtomicType*, xs:string) as xs:anyAtomicType*
            </p>
            
            <p>Returns the values that appear in a sequence, with duplicates eliminated.</p>
            
            <h3><a name="doc" id="doc"></a>doc
            </h3>
            <p><strong>doc</strong>(xs:string?) as document-node()?
            </p>
            
            <p>Retrieves a document using a URI supplied as an <code>xs:string</code>, and returns the
               corresponding document node.
            </p>
            
            <h3><a name="doc-available" id="doc-available"></a>doc-available
            </h3>
            <p><strong>doc-available</strong>(xs:string?) as xs:boolean
            </p>
            
            <p>The function returns true if and only if the function call <code>fn:doc($uri)</code>
               would return a document node.
            </p>
            
            <h3><a name="document-uri" id="document-uri"></a>document-uri
            </h3>
            <p><strong>document-uri</strong>() as xs:anyURI?
            </p>
            <p><strong>document-uri</strong>(node()?) as xs:anyURI?
            </p>
            
            <p>Returns the URI of a resource where a document can be found, if available.</p>
            
            <h3><a name="element-with-id" id="element-with-id"></a>element-with-id
            </h3>
            <p><strong>element-with-id</strong>(xs:string*) as element()*
            </p>
            <p><strong>element-with-id</strong>(xs:string*, node()) as element()*
            </p>
            
            <p> Returns the sequence of element nodes that have an <code>ID</code> value matching the
               value of one or more of the <code>IDREF</code> values supplied in <code>$arg</code>.
            </p>
            
            <h3><a name="empty" id="empty"></a>empty
            </h3>
            <p><strong>empty</strong>(item()*) as xs:boolean
            </p>
            
            <p>Returns true if the argument is the empty sequence.</p>
            
            <h3><a name="encode-for-uri" id="encode-for-uri"></a>encode-for-uri
            </h3>
            <p><strong>encode-for-uri</strong>(xs:string?) as xs:string
            </p>
            
            <p>Encodes reserved characters in a string that is intended to be used in the path segment
               of a URI.
            </p>
            
            <h3><a name="ends-with" id="ends-with"></a>ends-with
            </h3>
            <p><strong>ends-with</strong>(xs:string?, xs:string?) as xs:boolean
            </p>
            <p><strong>ends-with</strong>(xs:string?, xs:string?, xs:string) as xs:boolean
            </p>
            
            <p>Returns true if the string <code>$arg1</code> contains <code>$arg2</code> as a trailing
               substring, taking collations into account.
            </p>
            
            <h3><a name="environment-variable" id="environment-variable"></a>environment-variable
            </h3>
            <p><strong>environment-variable</strong>(xs:string) as xs:string?
            </p>
            
            <p>Returns the value of a system environment variable, if it exists.</p>
            
            <h3><a name="error" id="error"></a>error
            </h3>
            <p><strong>error</strong>() as none
            </p>
            <p><strong>error</strong>(xs:QName?) as none
            </p>
            <p><strong>error</strong>(xs:QName?, xs:string) as none
            </p>
            <p><strong>error</strong>(xs:QName?, xs:string, item()*) as none
            </p>
            
            <p>Calling the <code>fn:error</code> function raises an application-defined error.
            </p>
            
            <h3><a name="escape-html-uri" id="escape-html-uri"></a>escape-html-uri
            </h3>
            <p><strong>escape-html-uri</strong>(xs:string?) as xs:string
            </p>
            
            <p>Escapes a URI in the same way that HTML user agents handle attribute values expected
               to
               contain URIs.
            </p>
            
            <h3><a name="exactly-one" id="exactly-one"></a>exactly-one
            </h3>
            <p><strong>exactly-one</strong>(item()*) as item()
            </p>
            
            <p>Returns <code>$arg</code> if it contains exactly one item. Otherwise, raises an error.
               
            </p>
            
            <h3><a name="exists" id="exists"></a>exists
            </h3>
            <p><strong>exists</strong>(item()*) as xs:boolean
            </p>
            
            <p>Returns true if the argument is a non-empty sequence.</p>
            
            <h3><a name="false" id="false"></a>false
            </h3>
            <p><strong>false</strong>() as xs:boolean
            </p>
            
            <p>Returns the <code>xs:boolean</code> value <code>false</code>.
            </p>
            
            <h3><a name="filter" id="filter"></a>filter
            </h3>
            <p><strong>filter</strong>(item()*, function(item()) as xs:boolean) as item()*
            </p>
            
            <p>Returns those items from the sequence <var>$seq</var> for which the supplied function
               <var>$f</var> returns true.
            </p>
            
            <h3><a name="floor" id="floor"></a>floor
            </h3>
            <p><strong>floor</strong>(xs:numeric?) as xs:numeric?
            </p>
            
            <p>Rounds <code>$arg</code> downwards to a whole number.
            </p>
            
            <h3><a name="fold-left" id="fold-left"></a>fold-left
            </h3>
            <p><strong>fold-left</strong>(item()*, item()*, function(item()*, item()) as item()*) as item()*
            </p>
            
            <p>Processes the supplied sequence from left to right, applying the supplied function
               repeatedly to each item in turn, together with an accumulated result value.
            </p>
            
            <h3><a name="fold-right" id="fold-right"></a>fold-right
            </h3>
            <p><strong>fold-right</strong>(item()*, item()*, function(item(), item()*) as item()*) as item()*
            </p>
            
            <p>Processes the supplied sequence from right to left, applying the supplied function
               repeatedly to each item in turn, together with an accumulated result value.
            </p>
            
            <h3><a name="for-each" id="for-each"></a>for-each
            </h3>
            <p><strong>for-each</strong>(item()*, function(item()) as item()*) as item()*
            </p>
            
            <p>Applies the function item <var>$action</var> to every item from the sequence <var>$seq</var>
               in turn, returning the concatenation of the resulting sequences in order.
            </p>
            
            <h3><a name="for-each-pair" id="for-each-pair"></a>for-each-pair
            </h3>
            <p><strong>for-each-pair</strong>(item()*, item()*, function(item(), item()) as item()*) as item()*
            </p>
            
            <p>Applies the function item <var>$action</var> to successive pairs of items taken one from
               <var>$seq1</var> and one from <var>$seq2</var>, returning the concatenation of the
               resulting sequences in order.
            </p>
            
            <h3><a name="format-date" id="format-date"></a>format-date
            </h3>
            <p><strong>format-date</strong>(xs:date?, xs:string) as xs:string?
            </p>
            <p><strong>format-date</strong>(xs:date?, xs:string, xs:string?, xs:string?, xs:string?) as xs:string?
            </p>
            
            <p>Returns a string containing an <code>xs:date</code> value formatted for display.
            </p>
            
            <h3><a name="format-dateTime" id="format-dateTime"></a>format-dateTime
            </h3>
            <p><strong>format-dateTime</strong>(xs:dateTime?, xs:string) as xs:string?
            </p>
            <p><strong>format-dateTime</strong>(xs:dateTime?, xs:string, xs:string?, xs:string?, xs:string?) as xs:string?
            </p>
            
            <p>Returns a string containing an <code>xs:dateTime</code> value formatted for display.
            </p>
            
            <h3><a name="format-integer" id="format-integer"></a>format-integer
            </h3>
            <p><strong>format-integer</strong>(xs:integer?, xs:string) as xs:string
            </p>
            <p><strong>format-integer</strong>(xs:integer?, xs:string, xs:string?) as xs:string
            </p>
            
            <p>Formats an integer according to a given picture string, using the conventions of a
               given
               natural language if specified.
            </p>
            
            <h3><a name="format-number" id="format-number"></a>format-number
            </h3>
            <p><strong>format-number</strong>(xs:numeric?, xs:string) as xs:string
            </p>
            <p><strong>format-number</strong>(xs:numeric?, xs:string, xs:string?) as xs:string
            </p>
            
            <p>Returns a string containing a number formatted according to a given picture string,
               taking account of decimal formats specified in the static context.
            </p>
            
            <h3><a name="format-time" id="format-time"></a>format-time
            </h3>
            <p><strong>format-time</strong>(xs:time?, xs:string) as xs:string?
            </p>
            <p><strong>format-time</strong>(xs:time?, xs:string, xs:string?, xs:string?, xs:string?) as xs:string?
            </p>
            
            <p>Returns a string containing an <code>xs:time</code> value formatted for display.
            </p>
            
            <h3><a name="function-arity" id="function-arity"></a>function-arity
            </h3>
            <p><strong>function-arity</strong>(function(*)) as xs:integer
            </p>
            
            <p>Returns the arity of the function identified by a function item.</p>
            
            <h3><a name="function-lookup" id="function-lookup"></a>function-lookup
            </h3>
            <p><strong>function-lookup</strong>(xs:QName, xs:integer) as function(*)?
            </p>
            
            <p>Returns the function having a given name and arity, if there is one.</p>
            
            <h3><a name="function-name" id="function-name"></a>function-name
            </h3>
            <p><strong>function-name</strong>(function(*)) as xs:QName?
            </p>
            
            <p>Returns the name of the function identified by a function item.</p>
            
            <h3><a name="generate-id" id="generate-id"></a>generate-id
            </h3>
            <p><strong>generate-id</strong>() as xs:string
            </p>
            <p><strong>generate-id</strong>(node()?) as xs:string
            </p>
            
            <p>This function returns a string that uniquely identifies a given node. </p>
            
            <h3><a name="has-children" id="has-children"></a>has-children
            </h3>
            <p><strong>has-children</strong>() as xs:boolean
            </p>
            <p><strong>has-children</strong>(node()?) as xs:boolean
            </p>
            
            <p>Returns true if the supplied node has one or more child nodes (of any kind).</p>
            
            <h3><a name="head" id="head"></a>head
            </h3>
            <p><strong>head</strong>(item()*) as item()?
            </p>
            
            <p>Returns the first item in a sequence. </p>
            
            <h3><a name="hours-from-dateTime" id="hours-from-dateTime"></a>hours-from-dateTime
            </h3>
            <p><strong>hours-from-dateTime</strong>(xs:dateTime?) as xs:integer?
            </p>
            
            <p>Returns the hours component of an <code>xs:dateTime</code>.
            </p>
            
            <h3><a name="hours-from-duration" id="hours-from-duration"></a>hours-from-duration
            </h3>
            <p><strong>hours-from-duration</strong>(xs:duration?) as xs:integer?
            </p>
            
            <p>Returns the number of hours in a duration.</p>
            
            <h3><a name="hours-from-time" id="hours-from-time"></a>hours-from-time
            </h3>
            <p><strong>hours-from-time</strong>(xs:time?) as xs:integer?
            </p>
            
            <p>Returns the hours component of an <code>xs:time</code>.
            </p>
            
            <h3><a name="id" id="id"></a>id
            </h3>
            <p><strong>id</strong>(xs:string*) as element()*
            </p>
            <p><strong>id</strong>(xs:string*, node()) as element()*
            </p>
            
            <p>Returns the sequence of element nodes that have an <code>ID</code> value matching the
               value of one or more of the <code>IDREF</code> values supplied in <code>$arg</code>.
            </p>
            
            <h3><a name="idref" id="idref"></a>idref
            </h3>
            <p><strong>idref</strong>(xs:string*) as node()*
            </p>
            <p><strong>idref</strong>(xs:string*, node()) as node()*
            </p>
            
            <p>Returns the sequence of element or attribute nodes with an <code>IDREF</code> value
               matching the value of one or more of the <code>ID</code> values supplied in
               <code>$arg</code>.
            </p>
            
            <h3><a name="implicit-timezone" id="implicit-timezone"></a>implicit-timezone
            </h3>
            <p><strong>implicit-timezone</strong>() as xs:dayTimeDuration
            </p>
            
            <p>Returns the value of the implicit timezone property from the dynamic context. </p>
            
            <h3><a name="index-of" id="index-of"></a>index-of
            </h3>
            <p><strong>index-of</strong>(xs:anyAtomicType*, xs:anyAtomicType) as xs:integer*
            </p>
            <p><strong>index-of</strong>(xs:anyAtomicType*, xs:anyAtomicType, xs:string) as xs:integer*
            </p>
            
            <p>Returns a sequence of positive integers giving the positions within the sequence
               <code>$seq</code> of items that are equal to <code>$search</code>.
            </p>
            
            <h3><a name="innermost" id="innermost"></a>innermost
            </h3>
            <p><strong>innermost</strong>(node()*) as node()*
            </p>
            
            <p>Returns every node within the input sequence that is not an ancestor of another member
               of the input sequence; the nodes are returned in document order with duplicates
               eliminated.
            </p>
            
            <h3><a name="in-scope-prefixes" id="in-scope-prefixes"></a>in-scope-prefixes
            </h3>
            <p><strong>in-scope-prefixes</strong>(element()) as xs:string*
            </p>
            
            <p>Returns the prefixes of the in-scope namespaces for an element node.</p>
            
            <h3><a name="insert-before" id="insert-before"></a>insert-before
            </h3>
            <p><strong>insert-before</strong>(item()*, xs:integer, item()*) as item()*
            </p>
            
            <p>Returns a sequence constructed by inserting an item or a sequence of items at a given
               position within an existing sequence.
            </p>
            
            <h3><a name="iri-to-uri" id="iri-to-uri"></a>iri-to-uri
            </h3>
            <p><strong>iri-to-uri</strong>(xs:string?) as xs:string
            </p>
            
            <p>Converts a string containing an IRI into a URI according to the rules of [rfc3987].</p>
            
            <h3><a name="json-doc" id="json-doc"></a>json-doc
            </h3>
            <p><strong>json-doc</strong>(xs:string?) as item()?
            </p>
            <p><strong>json-doc</strong>(xs:string?, map(*)) as item()?
            </p>
            
            <p>Reads an external resource containing JSON, and returns the result of parsing the
               resource as JSON.
            </p>
            
            <h3><a name="json-to-xml" id="json-to-xml"></a>json-to-xml
            </h3>
            <p><strong>json-to-xml</strong>(xs:string?) as document-node()?
            </p>
            <p><strong>json-to-xml</strong>(xs:string?, map(*)) as document-node()?
            </p>
            
            <p>Parses a string supplied in the form of a JSON text, returning the results in the
               form
               of an XML <span>document node</span>.
            </p>
            
            <h3><a name="lang" id="lang"></a>lang
            </h3>
            <p><strong>lang</strong>(xs:string?) as xs:boolean
            </p>
            <p><strong>lang</strong>(xs:string?, node()) as xs:boolean
            </p>
            
            <p>This function tests whether the language of <code>$node</code>, or the context item if
               the second argument is omitted, as specified by <code>xml:lang</code> attributes is the
               same as, or is a sublanguage of, the language specified by <code>$testlang</code>.
            </p>
            
            <h3><a name="last" id="last"></a>last
            </h3>
            <p><strong>last</strong>() as xs:integer
            </p>
            
            <p>Returns the context size from the dynamic context.</p>
            
            <h3><a name="load-xquery-module" id="load-xquery-module"></a>load-xquery-module
            </h3>
            <p><strong>load-xquery-module</strong>(xs:string) as map(*)
            </p>
            <p><strong>load-xquery-module</strong>(xs:string, map(*)) as map(*)
            </p>
            
            <p>Provides access to the public functions and global variables of a dynamically-loaded
               XQuery library module.
            </p>
            
            <h3><a name="local-name" id="local-name"></a>local-name
            </h3>
            <p><strong>local-name</strong>() as xs:string
            </p>
            <p><strong>local-name</strong>(node()?) as xs:string
            </p>
            
            <p>Returns the local part of the name of <code>$arg</code> as an <code>xs:string</code>
               that is either the zero-length string, or has the lexical form of an
               <code>xs:NCName</code>.
            </p>
            
            <h3><a name="local-name-from-QName" id="local-name-from-QName"></a>local-name-from-QName
            </h3>
            <p><strong>local-name-from-QName</strong>(xs:QName?) as xs:NCName?
            </p>
            
            <p>Returns the local part of the supplied QName.</p>
            
            <h3><a name="lower-case" id="lower-case"></a>lower-case
            </h3>
            <p><strong>lower-case</strong>(xs:string?) as xs:string
            </p>
            
            <p>Converts a string to lower case.</p>
            
            <h3><a name="matches" id="matches"></a>matches
            </h3>
            <p><strong>matches</strong>(xs:string?, xs:string) as xs:boolean
            </p>
            <p><strong>matches</strong>(xs:string?, xs:string, xs:string) as xs:boolean
            </p>
            
            <p>Returns true if the supplied string matches a given regular expression.</p>
            
            <h3><a name="max" id="max"></a>max
            </h3>
            <p><strong>max</strong>(xs:anyAtomicType*) as xs:anyAtomicType?
            </p>
            <p><strong>max</strong>(xs:anyAtomicType*, xs:string) as xs:anyAtomicType?
            </p>
            
            <p>Returns a value that is equal to the highest value appearing in the input sequence.</p>
            
            <h3><a name="min" id="min"></a>min
            </h3>
            <p><strong>min</strong>(xs:anyAtomicType*) as xs:anyAtomicType?
            </p>
            <p><strong>min</strong>(xs:anyAtomicType*, xs:string) as xs:anyAtomicType?
            </p>
            
            <p>Returns a value that is equal to the lowest value appearing in the input sequence.</p>
            
            <h3><a name="minutes-from-dateTime" id="minutes-from-dateTime"></a>minutes-from-dateTime
            </h3>
            <p><strong>minutes-from-dateTime</strong>(xs:dateTime?) as xs:integer?
            </p>
            
            <p>Returns the minute component of an <code>xs:dateTime</code>.
            </p>
            
            <h3><a name="minutes-from-duration" id="minutes-from-duration"></a>minutes-from-duration
            </h3>
            <p><strong>minutes-from-duration</strong>(xs:duration?) as xs:integer?
            </p>
            
            <p>Returns the number of minutes in a duration.</p>
            
            <h3><a name="minutes-from-time" id="minutes-from-time"></a>minutes-from-time
            </h3>
            <p><strong>minutes-from-time</strong>(xs:time?) as xs:integer?
            </p>
            
            <p>Returns the minutes component of an <code>xs:time</code>.
            </p>
            
            <h3><a name="month-from-date" id="month-from-date"></a>month-from-date
            </h3>
            <p><strong>month-from-date</strong>(xs:date?) as xs:integer?
            </p>
            
            <p>Returns the month component of an <code>xs:date</code>.
            </p>
            
            <h3><a name="month-from-dateTime" id="month-from-dateTime"></a>month-from-dateTime
            </h3>
            <p><strong>month-from-dateTime</strong>(xs:dateTime?) as xs:integer?
            </p>
            
            <p>Returns the month component of an <code>xs:dateTime</code>.
            </p>
            
            <h3><a name="months-from-duration" id="months-from-duration"></a>months-from-duration
            </h3>
            <p><strong>months-from-duration</strong>(xs:duration?) as xs:integer?
            </p>
            
            <p>Returns the number of months in a duration.</p>
            
            <h3><a name="name" id="name"></a>name
            </h3>
            <p><strong>name</strong>() as xs:string
            </p>
            <p><strong>name</strong>(node()?) as xs:string
            </p>
            
            <p>Returns the name of a node, as an <code>xs:string</code> that is either the zero-length
               string, or has the lexical form of an <code>xs:QName</code>. 
            </p>
            
            <h3><a name="namespace-uri" id="namespace-uri"></a>namespace-uri
            </h3>
            <p><strong>namespace-uri</strong>() as xs:anyURI
            </p>
            <p><strong>namespace-uri</strong>(node()?) as xs:anyURI
            </p>
            
            <p>Returns the namespace URI part of the name of <code>$arg</code>, as an
               <code>xs:anyURI</code> value.
            </p>
            
            <h3><a name="namespace-uri-for-prefix" id="namespace-uri-for-prefix"></a>namespace-uri-for-prefix
            </h3>
            <p><strong>namespace-uri-for-prefix</strong>(xs:string?, element()) as xs:anyURI?
            </p>
            
            <p>Returns the namespace URI of one of the in-scope namespaces for <code>$element</code>,
               identified by its namespace prefix.
            </p>
            
            <h3><a name="namespace-uri-from-QName" id="namespace-uri-from-QName"></a>namespace-uri-from-QName
            </h3>
            <p><strong>namespace-uri-from-QName</strong>(xs:QName?) as xs:anyURI?
            </p>
            
            <p>Returns the namespace URI part of the supplied QName.</p>
            
            <h3><a name="nilled" id="nilled"></a>nilled
            </h3>
            <p><strong>nilled</strong>() as xs:boolean?
            </p>
            <p><strong>nilled</strong>(node()?) as xs:boolean?
            </p>
            
            <p>Returns true for an element that is <b>nilled</b>.
            </p>
            
            <h3><a name="node-name" id="node-name"></a>node-name
            </h3>
            <p><strong>node-name</strong>() as xs:QName?
            </p>
            <p><strong>node-name</strong>(node()?) as xs:QName?
            </p>
            
            <p>Returns the name of a node, as an <code>xs:QName</code>.
            </p>
            
            <h3><a name="normalize-space" id="normalize-space"></a>normalize-space
            </h3>
            <p><strong>normalize-space</strong>() as xs:string
            </p>
            <p><strong>normalize-space</strong>(xs:string?) as xs:string
            </p>
            
            <p>Returns the value of <code>$arg</code> with leading and trailing whitespace removed, and
               sequences of internal whitespace reduced to a single space character.
            </p>
            
            <h3><a name="normalize-unicode" id="normalize-unicode"></a>normalize-unicode
            </h3>
            <p><strong>normalize-unicode</strong>(xs:string?) as xs:string
            </p>
            <p><strong>normalize-unicode</strong>(xs:string?, xs:string) as xs:string
            </p>
            
            <p>Returns the value of <code>$arg</code> after applying Unicode normalization.
            </p>
            
            <h3><a name="not" id="not"></a>not
            </h3>
            <p><strong>not</strong>(item()*) as xs:boolean
            </p>
            
            <p>Returns <code>true</code> if the effective boolean value of <code>$arg</code> is
               <code>false</code>, or <code>false</code> if it is <code>true</code>.
            </p>
            
            <h3><a name="number" id="number"></a>number
            </h3>
            <p><strong>number</strong>() as xs:double
            </p>
            <p><strong>number</strong>(xs:anyAtomicType?) as xs:double
            </p>
            
            <p>Returns the value indicated by <code>$arg</code> or, if <code>$arg</code> is not
               specified, the context item after atomization, converted to an <code>xs:double</code>.
               
            </p>
            
            <h3><a name="one-or-more" id="one-or-more"></a>one-or-more
            </h3>
            <p><strong>one-or-more</strong>(item()*) as item()+
            </p>
            
            <p>Returns <code>$arg</code> if it contains one or more items. Otherwise, raises an error.
               
            </p>
            
            <h3><a name="outermost" id="outermost"></a>outermost
            </h3>
            <p><strong>outermost</strong>(node()*) as node()*
            </p>
            
            <p>Returns every node within the input sequence that has no ancestor that is itself a
               member of the input sequence; the nodes are returned in document order with duplicates
               eliminated.
            </p>
            
            <h3><a name="parse-ietf-date" id="parse-ietf-date"></a>parse-ietf-date
            </h3>
            <p><strong>parse-ietf-date</strong>(xs:string?) as xs:dateTime?
            </p>
            
            <p>Parses a string containing the date and time in IETF format, returning the corresponding
               <code>xs:dateTime</code> value.
            </p>
            
            <h3><a name="parse-json" id="parse-json"></a>parse-json
            </h3>
            <p><strong>parse-json</strong>(xs:string?) as item()?
            </p>
            <p><strong>parse-json</strong>(xs:string?, map(*)) as item()?
            </p>
            
            <p>Parses a string supplied in the form of a JSON text, returning the results typically
               in the form
               of a map or array.
            </p>
            
            <h3><a name="parse-xml" id="parse-xml"></a>parse-xml
            </h3>
            <p><strong>parse-xml</strong>(xs:string?) as document-node(element(*))?
            </p>
            
            <p>This function takes as input an XML document represented as a string, and returns
               the
               document node at the root of an XDM tree representing the parsed document.
            </p>
            
            <h3><a name="parse-xml-fragment" id="parse-xml-fragment"></a>parse-xml-fragment
            </h3>
            <p><strong>parse-xml-fragment</strong>(xs:string?) as document-node()?
            </p>
            
            <p>This function takes as input an XML external entity represented as a string, and returns
               the document node at the root of an XDM tree representing the parsed document
               fragment.
            </p>
            
            <h3><a name="path" id="path"></a>path
            </h3>
            <p><strong>path</strong>() as xs:string?
            </p>
            <p><strong>path</strong>(node()?) as xs:string?
            </p>
            
            <p>Returns a path expression that can be used to select the supplied node relative to
               the
               root of its containing document.
            </p>
            
            <h3><a name="position" id="position"></a>position
            </h3>
            <p><strong>position</strong>() as xs:integer
            </p>
            
            <p>Returns the context position from the dynamic context.</p>
            
            <h3><a name="prefix-from-QName" id="prefix-from-QName"></a>prefix-from-QName
            </h3>
            <p><strong>prefix-from-QName</strong>(xs:QName?) as xs:NCName?
            </p>
            
            <p>Returns the prefix component of the supplied QName.</p>
            
            <h3><a name="QName" id="QName"></a>QName
            </h3>
            <p><strong>QName</strong>(xs:string?, xs:string) as xs:QName
            </p>
            
            <p>Returns an <code>xs:QName</code> value formed using a supplied namespace URI and lexical QName.
            </p>
            
            <h3><a name="random-number-generator" id="random-number-generator"></a>random-number-generator
            </h3>
            <p><strong>random-number-generator</strong>() as map(xs:string, item())
            </p>
            <p><strong>random-number-generator</strong>(xs:anyAtomicType?) as map(xs:string, item())
            </p>
            <p>Returns a random number generator, which can be used to generate sequences of random
               numbers.
            </p>
            <h3><a name="remove" id="remove"></a>remove
            </h3>
            <p><strong>remove</strong>(item()*, xs:integer) as item()*
            </p>
            
            <p>Returns a new sequence containing all the items of <code>$target</code> except the item
               at position <code>$position</code>.
            </p>
            
            <h3><a name="replace" id="replace"></a>replace
            </h3>
            <p><strong>replace</strong>(xs:string?, xs:string, xs:string) as xs:string
            </p>
            <p><strong>replace</strong>(xs:string?, xs:string, xs:string, xs:string) as xs:string
            </p>
            
            <p>Returns a string produced from the input string by replacing any substrings that match
               a
               given regular expression with a supplied replacement string.
            </p>
            
            <h3><a name="resolve-QName" id="resolve-QName"></a>resolve-QName
            </h3>
            <p><strong>resolve-QName</strong>(xs:string?, element()) as xs:QName?
            </p>
            
            <p>Returns an <code>xs:QName</code> value (that is, an expanded-QName) by taking an
               <code>xs:string</code> that has the lexical form of an <code>xs:QName</code> (a
               string in the form "prefix:local-name" or "local-name") and resolving it using the
               in-scope namespaces for a given element.
            </p>
            
            <h3><a name="resolve-uri" id="resolve-uri"></a>resolve-uri
            </h3>
            <p><strong>resolve-uri</strong>(xs:string?) as xs:anyURI?
            </p>
            <p><strong>resolve-uri</strong>(xs:string?, xs:string) as xs:anyURI?
            </p>
            
            <p>Resolves a relative IRI reference against an absolute IRI.</p>
            
            <h3><a name="reverse" id="reverse"></a>reverse
            </h3>
            <p><strong>reverse</strong>(item()*) as item()*
            </p>
            
            <p>Reverses the order of items in a sequence. </p>
            
            <h3><a name="root" id="root"></a>root
            </h3>
            <p><strong>root</strong>() as node()
            </p>
            <p><strong>root</strong>(node()?) as node()?
            </p>
            
            <p>Returns the root of the tree to which <code>$arg</code> belongs. This will usually, but
               not necessarily, be a document node.
            </p>
            
            <h3><a name="round" id="round"></a>round
            </h3>
            <p><strong>round</strong>(xs:numeric?) as xs:numeric?
            </p>
            <p><strong>round</strong>(xs:numeric?, xs:integer) as xs:numeric?
            </p>
            
            <p>Rounds a value to a specified number of decimal places, rounding upwards if two such
               values are equally near.
            </p>
            
            <h3><a name="round-half-to-even" id="round-half-to-even"></a>round-half-to-even
            </h3>
            <p><strong>round-half-to-even</strong>(xs:numeric?) as xs:numeric?
            </p>
            <p><strong>round-half-to-even</strong>(xs:numeric?, xs:integer) as xs:numeric?
            </p>
            
            <p>Rounds a value to a specified number of decimal places, rounding to make the last
               digit
               even if two such values are equally near.
            </p>
            
            <h3><a name="seconds-from-dateTime" id="seconds-from-dateTime"></a>seconds-from-dateTime
            </h3>
            <p><strong>seconds-from-dateTime</strong>(xs:dateTime?) as xs:decimal?
            </p>
            
            <p>Returns the seconds component of an <code>xs:dateTime</code>.
            </p>
            
            <h3><a name="seconds-from-duration" id="seconds-from-duration"></a>seconds-from-duration
            </h3>
            <p><strong>seconds-from-duration</strong>(xs:duration?) as xs:decimal?
            </p>
            
            <p>Returns the number of seconds in a duration.</p>
            
            <h3><a name="seconds-from-time" id="seconds-from-time"></a>seconds-from-time
            </h3>
            <p><strong>seconds-from-time</strong>(xs:time?) as xs:decimal?
            </p>
            
            <p>Returns the seconds component of an <code>xs:time</code>.
            </p>
            
            <h3><a name="serialize" id="serialize"></a>serialize
            </h3>
            <p><strong>serialize</strong>(item()*) as xs:string
            </p>
            <p><strong>serialize</strong>(item()*, item()?) as xs:string
            </p>
            
            <p>This function serializes the supplied input sequence <code>$arg</code> as described in
               [xslt-xquery-serialization-31], returning the serialized representation
               of the sequence as a string.
            </p>
            
            <h3><a name="sort" id="sort"></a>sort
            </h3>
            <p><strong>sort</strong>(item()*) as item()*
            </p>
            <p><strong>sort</strong>(item()*, xs:string?) as item()*
            </p>
            <p><strong>sort</strong>(item()*, xs:string?, function(item()) as xs:anyAtomicType*) as item()*
            </p>
            
            <p>Sorts a supplied sequence, based on the value of a sort key supplied as a function.</p>
            
            <h3><a name="starts-with" id="starts-with"></a>starts-with
            </h3>
            <p><strong>starts-with</strong>(xs:string?, xs:string?) as xs:boolean
            </p>
            <p><strong>starts-with</strong>(xs:string?, xs:string?, xs:string) as xs:boolean
            </p>
            
            <p>Returns true if the string <code>$arg1</code> contains <code>$arg2</code> as a leading
               substring, taking collations into account.
            </p>
            
            <h3><a name="static-base-uri" id="static-base-uri"></a>static-base-uri
            </h3>
            <p><strong>static-base-uri</strong>() as xs:anyURI?
            </p>
            
            <p>This function returns the value of the <b>static base URI</b> property from the static
               context.
            </p>
            
            <h3><a name="string" id="string"></a>string
            </h3>
            <p><strong>string</strong>() as xs:string
            </p>
            <p><strong>string</strong>(item()?) as xs:string
            </p>
            
            <p>Returns the value of <code>$arg</code> represented as an <code>xs:string</code>.
            </p>
            
            <h3><a name="string-join" id="string-join"></a>string-join
            </h3>
            <p><strong>string-join</strong>(xs:anyAtomicType*) as xs:string
            </p>
            <p><strong>string-join</strong>(xs:anyAtomicType*, xs:string) as xs:string
            </p>
            
            <p>Returns a string created by concatenating the items in a sequence, with a defined
               separator between adjacent items.
            </p>
            
            <h3><a name="string-length" id="string-length"></a>string-length
            </h3>
            <p><strong>string-length</strong>() as xs:integer
            </p>
            <p><strong>string-length</strong>(xs:string?) as xs:integer
            </p>
            
            <p>Returns the number of characters in a string.</p>
            
            <h3><a name="string-to-codepoints" id="string-to-codepoints"></a>string-to-codepoints
            </h3>
            <p><strong>string-to-codepoints</strong>(xs:string?) as xs:integer*
            </p>
            
            <p>Returns the sequence of codepoints that constitute an
               <code>xs:string</code> value. 
            </p>
            
            <h3><a name="subsequence" id="subsequence"></a>subsequence
            </h3>
            <p><strong>subsequence</strong>(item()*, xs:double) as item()*
            </p>
            <p><strong>subsequence</strong>(item()*, xs:double, xs:double) as item()*
            </p>
            
            <p>Returns the contiguous sequence of items in the value of <code>$sourceSeq</code>
               beginning at the position indicated by the value of <code>$startingLoc</code> and
               continuing for the number of items indicated by the value of <code>$length</code>. 
            </p>
            
            <h3><a name="substring" id="substring"></a>substring
            </h3>
            <p><strong>substring</strong>(xs:string?, xs:double) as xs:string
            </p>
            <p><strong>substring</strong>(xs:string?, xs:double, xs:double) as xs:string
            </p>
            
            <p>Returns the portion of the value of <code>$sourceString</code> beginning at the position
               indicated by the value of <code>$start</code> and continuing for the number of characters indicated by the value of
               <code>$length</code>.
            </p>
            
            <h3><a name="substring-after" id="substring-after"></a>substring-after
            </h3>
            <p><strong>substring-after</strong>(xs:string?, xs:string?) as xs:string
            </p>
            <p><strong>substring-after</strong>(xs:string?, xs:string?, xs:string) as xs:string
            </p>
            
            <p>Returns the part of <code>$arg1</code> that follows the first occurrence of
               <code>$arg2</code>, taking collations into account.
            </p>
            
            <h3><a name="substring-before" id="substring-before"></a>substring-before
            </h3>
            <p><strong>substring-before</strong>(xs:string?, xs:string?) as xs:string
            </p>
            <p><strong>substring-before</strong>(xs:string?, xs:string?, xs:string) as xs:string
            </p>
            
            <p>Returns the part of <code>$arg1</code> that precedes the first occurrence of
               <code>$arg2</code>, taking collations into account.
            </p>
            
            <h3><a name="sum" id="sum"></a>sum
            </h3>
            <p><strong>sum</strong>(xs:anyAtomicType*) as xs:anyAtomicType
            </p>
            <p><strong>sum</strong>(xs:anyAtomicType*, xs:anyAtomicType?) as xs:anyAtomicType?
            </p>
            
            <p>Returns a value obtained by adding together the values in <code>$arg</code>.
            </p>
            
            <h3><a name="tail" id="tail"></a>tail
            </h3>
            <p><strong>tail</strong>(item()*) as item()*
            </p>
            
            <p>Returns all but the first item in a sequence. </p>
            
            <h3><a name="timezone-from-date" id="timezone-from-date"></a>timezone-from-date
            </h3>
            <p><strong>timezone-from-date</strong>(xs:date?) as xs:dayTimeDuration?
            </p>
            
            <p>Returns the timezone component of an <code>xs:date</code>.
            </p>
            
            <h3><a name="timezone-from-dateTime" id="timezone-from-dateTime"></a>timezone-from-dateTime
            </h3>
            <p><strong>timezone-from-dateTime</strong>(xs:dateTime?) as xs:dayTimeDuration?
            </p>
            
            <p>Returns the timezone component of an <code>xs:dateTime</code>.
            </p>
            
            <h3><a name="timezone-from-time" id="timezone-from-time"></a>timezone-from-time
            </h3>
            <p><strong>timezone-from-time</strong>(xs:time?) as xs:dayTimeDuration?
            </p>
            
            <p>Returns the timezone component of an <code>xs:time</code>.
            </p>
            
            <h3><a name="tokenize" id="tokenize"></a>tokenize
            </h3>
            <p><strong>tokenize</strong>(xs:string?) as xs:string*
            </p>
            <p><strong>tokenize</strong>(xs:string?, xs:string) as xs:string*
            </p>
            <p><strong>tokenize</strong>(xs:string?, xs:string, xs:string) as xs:string*
            </p>
            
            <p>Returns a sequence of strings constructed by splitting the input wherever a separator
               is
               found; the separator is any substring that matches a given regular expression.
            </p>
            
            <h3><a name="trace" id="trace"></a>trace
            </h3>
            <p><strong>trace</strong>(item()*) as item()*
            </p>
            <p><strong>trace</strong>(item()*, xs:string) as item()*
            </p>
            
            <p>Provides an execution trace intended to be used in debugging queries.</p>
            
            <h3><a name="transform" id="transform"></a>transform
            </h3>
            <p><strong>transform</strong>(map(*)) as map(*)
            </p>
            
            <p>Invokes a transformation using a dynamically-loaded XSLT stylesheet.</p>
            
            <h3><a name="translate" id="translate"></a>translate
            </h3>
            <p><strong>translate</strong>(xs:string?, xs:string, xs:string) as xs:string
            </p>
            
            <p>Returns the value of <code>$arg</code> modified by replacing or removing individual
               characters. 
            </p>
            
            <h3><a name="true" id="true"></a>true
            </h3>
            <p><strong>true</strong>() as xs:boolean
            </p>
            
            <p>Returns the <code>xs:boolean</code> value <code>true</code>.
            </p>
            
            <h3><a name="unordered" id="unordered"></a>unordered
            </h3>
            <p><strong>unordered</strong>(item()*) as item()*
            </p>
            
            <p>Returns the items of <code>$sourceSeq</code> in an implementation-dependent order.
            </p>
            
            <h3><a name="unparsed-text" id="unparsed-text"></a>unparsed-text
            </h3>
            <p><strong>unparsed-text</strong>(xs:string?) as xs:string?
            </p>
            <p><strong>unparsed-text</strong>(xs:string?, xs:string) as xs:string?
            </p>
            
            <p>The <code>fn:unparsed-text</code> function reads an external resource (for example, a
               file) and returns a string representation of the resource.
            </p>
            
            <h3><a name="unparsed-text-available" id="unparsed-text-available"></a>unparsed-text-available
            </h3>
            <p><strong>unparsed-text-available</strong>(xs:string?) as xs:boolean
            </p>
            <p><strong>unparsed-text-available</strong>(xs:string?, xs:string) as xs:boolean
            </p>
            
            <p>Because errors in evaluating the <code>fn:unparsed-text</code> function are
               non-recoverable, these two functions are provided to allow an application to determine
               whether a call with particular arguments would succeed.
            </p>
            
            <h3><a name="unparsed-text-lines" id="unparsed-text-lines"></a>unparsed-text-lines
            </h3>
            <p><strong>unparsed-text-lines</strong>(xs:string?) as xs:string*
            </p>
            <p><strong>unparsed-text-lines</strong>(xs:string?, xs:string) as xs:string*
            </p>
            
            <p>The <code>fn:unparsed-text-lines</code> function reads an external resource (for
               example, a file) and returns its contents as a sequence of strings, one for each line
               of
               text in the string representation of the resource.
            </p>
            
            <h3><a name="upper-case" id="upper-case"></a>upper-case
            </h3>
            <p><strong>upper-case</strong>(xs:string?) as xs:string
            </p>
            
            <p>Converts a string to upper case.</p>
            
            <h3><a name="uri-collection" id="uri-collection"></a>uri-collection
            </h3>
            <p><strong>uri-collection</strong>() as xs:anyURI*
            </p>
            <p><strong>uri-collection</strong>(xs:string?) as xs:anyURI*
            </p>
            
            <p>Returns a sequence of <code>xs:anyURI</code> values representing the URIs in a URI
               collection.
            </p>
            
            <h3><a name="xml-to-json" id="xml-to-json"></a>xml-to-json
            </h3>
            <p><strong>xml-to-json</strong>(node()?) as xs:string?
            </p>
            <p><strong>xml-to-json</strong>(node()?, map(*)) as xs:string?
            </p>
            
            <p>Converts an XML tree, whose format corresponds to the XML representation of JSON defined
               in this specification, into a string conforming to the JSON grammar.
            </p>
            
            <h3><a name="year-from-date" id="year-from-date"></a>year-from-date
            </h3>
            <p><strong>year-from-date</strong>(xs:date?) as xs:integer?
            </p>
            
            <p>Returns the year component of an <code>xs:date</code>.
            </p>
            
            <h3><a name="year-from-dateTime" id="year-from-dateTime"></a>year-from-dateTime
            </h3>
            <p><strong>year-from-dateTime</strong>(xs:dateTime?) as xs:integer?
            </p>
            
            <p>Returns the year component of an <code>xs:dateTime</code>.
            </p>
            
            <h3><a name="years-from-duration" id="years-from-duration"></a>years-from-duration
            </h3>
            <p><strong>years-from-duration</strong>(xs:duration?) as xs:integer?
            </p>
            
            <p>Returns the number of years in a duration.</p>
            
            <h3><a name="zero-or-one" id="zero-or-one"></a>zero-or-one
            </h3>
            <p><strong>zero-or-one</strong>(item()*) as item()?
            </p>
            
            <p>Returns <code>$arg</code> if it contains zero or one items. Otherwise, raises an
               error.
            </p>
            
         </div>
         <div class="resource">
            
            <h2><a id="xslt-summary"></a>3 XSL Transformations (XSLT) Functions
            </h2>
            <p>This section lists all of the functions in this namespace that are defined in the
               [XSLT 3.0] specification.
            </p>
            <p>The normative definitions of these functions are in the
               [XSLT 3.0] specification.
               For convenience, a very brief, non-normative summary of each
               function is provided. For details, follow the link on the “Summary:”
               introductory text below each function.
            </p>
            <p><em>Note that XSLT 3.0, because it is not dependent on XPath 3.1, also
                  reproduces some of the functions specifications that appear in XPath 3.1. For
                  an XSLT 3.0 processor that works with XPath 3.0, the normative specification
                  in this case is the one that appears in the XSLT 3.0 specification.</em></p>
            <h3><a name="accumulator-after" id="accumulator-after"></a>accumulator-after
            </h3>
            <p><strong>accumulator-after</strong>(xs:string) as item()*
            </p>
            
            <p>Returns the post-descent value of the selected accumulator at the context node.</p>
            
            <h3><a name="accumulator-before" id="accumulator-before"></a>accumulator-before
            </h3>
            <p><strong>accumulator-before</strong>(xs:string) as item()*
            </p>
            
            <p>Returns the pre-descent value of the selected accumulator at the context node.</p>
            
            <h3><a name="available-system-properties" id="available-system-properties"></a>available-system-properties
            </h3>
            <p><strong>available-system-properties</strong>() as xs:QName*
            </p>
            
            <p>Returns a list of system property names that are suitable for passing to
               the <code>system-property</code> function, as a sequence of QNames.
            </p>
            
            <h3><a name="collation-key" id="collation-key"></a>collation-key
            </h3>
            <p><strong>collation-key</strong>(xs:string) as xs:base64Binary
            </p>
            <p><strong>collation-key</strong>(xs:string, xs:string) as xs:base64Binary
            </p>
            
            <p>Given a string value and a collation, generates an internal value called a collation
               key, with the property that
               the matching and ordering of collation keys reflects the matching and ordering of
               strings under the specified collation.
            </p>
            
            <h3><a name="copy-of" id="copy-of"></a>copy-of
            </h3>
            <p><strong>copy-of</strong>() as item()
            </p>
            <p><strong>copy-of</strong>(item()*) as item()*
            </p>
            
            <p>Returns a deep copy of the <span>sequence</span> supplied as the <code>$input</code> argument, or of the
               context <span>item</span> if the argument is absent.
            </p>
            
            <h3><a name="current" id="current"></a>current
            </h3>
            <p><strong>current</strong>() as item()
            </p>
            
            <p>Returns the item that is the context item for the evaluation of the containing XPath
               expression
            </p>
            
            <h3><a name="current-group" id="current-group"></a>current-group
            </h3>
            <p><strong>current-group</strong>() as item()*
            </p>
            
            <p>Returns the group currently being processed by an <code>xsl:for-each-group</code>
               instruction.
            </p>
            
            <h3><a name="current-grouping-key" id="current-grouping-key"></a>current-grouping-key
            </h3>
            <p><strong>current-grouping-key</strong>() as xs:anyAtomicType*
            </p>
            
            <p>Returns the grouping key of the group currently being processed using the
               <code>xsl:for-each-group</code>
               instruction.
            </p>
            
            <h3><a name="current-merge-group" id="current-merge-group"></a>current-merge-group
            </h3>
            <p><strong>current-merge-group</strong>() as item()*
            </p>
            <p><strong>current-merge-group</strong>(xs:string) as item()*
            </p>
            
            <p>Returns the group of items currently being processed by an <code>xsl:merge</code>
               instruction.
            </p>
            
            <h3><a name="current-merge-key" id="current-merge-key"></a>current-merge-key
            </h3>
            <p><strong>current-merge-key</strong>() as xs:anyAtomicType*
            </p>
            
            <p>Returns the <span>merge</span> key of the 
               <span>merge</span> group currently being processed using the
               <code>xsl:merge</code> instruction.
            </p>
            
            <h3><a name="current-output-uri" id="current-output-uri"></a>current-output-uri
            </h3>
            <p><strong>current-output-uri</strong>() as xs:anyURI?
            </p>
            
            <p>Returns the value of the .</p>
            <h3><a name="deep-equal" id="deep-equal"></a>deep-equal
            </h3>
            <p><strong>deep-equal</strong>(item()*, item()*) as xs:boolean
            </p>
            <p><strong>deep-equal</strong>(item()*, item()*, xs:string) as xs:boolean
            </p>
            
            <p>This function assesses whether two sequences are deep-equal to each other. The function
               as described here extends the definition of the XPath 3.0
               <code>deep-equal</code> to explain how it should handle maps; it is
               intended to replace the existing <code>deep-equal</code> function at some
               stage in the future.
            </p>
            
            <h3><a name="document" id="document"></a>document
            </h3>
            <p><strong>document</strong>(item()*) as node()*
            </p>
            <p><strong>document</strong>(item()*, node()) as node()*
            </p>
            
            <p>Provides access to XML documents identified by a URI.</p>
            
            <h3><a name="element-available" id="element-available"></a>element-available
            </h3>
            <p><strong>element-available</strong>(xs:string) as xs:boolean
            </p>
            
            <p>Determines whether a particular instruction is or is not available for use. The function
               is particularly useful for calling within an <code>[xsl:]use-when</code> attribute (see
               ) to test whether a particular  is available.
            </p>
            
            <h3><a name="function-available" id="function-available"></a>function-available
            </h3>
            <p><strong>function-available</strong>(xs:string) as xs:boolean
            </p>
            <p><strong>function-available</strong>(xs:string, xs:integer) as xs:boolean
            </p>
            
            <p>Determines whether a particular function is or is not available for use. The function
               is
               particularly useful for calling within an <code>[xsl:]use-when</code> attribute (see
               ) to test whether a particular  is available.
            </p>
            
            <h3><a name="json-to-xml" id="json-to-xml"></a>json-to-xml
            </h3>
            <p><strong>json-to-xml</strong>(xs:string) as document-node()
            </p>
            <p><strong>json-to-xml</strong>(xs:string, map(*)) as document-node()
            </p>
            
            <p>Parses a string supplied in the form of a JSON text, returning the results in the
               form
               of an XML <span>document node</span>.
            </p>
            
            <h3><a name="key" id="key"></a>key
            </h3>
            <p><strong>key</strong>(xs:string, xs:anyAtomicType*) as node()*
            </p>
            <p><strong>key</strong>(xs:string, xs:anyAtomicType*, node()) as node()*
            </p>
            
            <p>Returns the nodes that match a supplied key value.</p>
            
            <h3><a name="regex-group" id="regex-group"></a>regex-group
            </h3>
            <p><strong>regex-group</strong>(xs:integer) as xs:string
            </p>
            
            <p>Returns the string captured by a parenthesized subexpression of the regular expression
               used during evaluation of the <code>xsl:analyze-string</code> instruction.
            </p>
            
            <h3><a name="snapshot" id="snapshot"></a>snapshot
            </h3>
            <p><strong>snapshot</strong>() as item()
            </p>
            <p><strong>snapshot</strong>(item()*) as item()*
            </p>
            
            <p>Returns a copy of a sequence, retaining copies of the ancestors and descendants of
               any node in the input sequence, together with their
               attributes and namespaces.
            </p>
            
            <h3><a name="stream-available" id="stream-available"></a>stream-available
            </h3>
            <p><strong>stream-available</strong>(xs:string?) as xs:boolean
            </p>
            
            <p>Determines, as far as possible, whether a document is available for streamed processing
               using <code>xsl:source-document</code>.
            </p>
            
            <h3><a name="system-property" id="system-property"></a>system-property
            </h3>
            <p><strong>system-property</strong>(xs:string) as xs:string
            </p>
            
            <p>Returns the value of a system property</p>
            
            <h3><a name="type-available" id="type-available"></a>type-available
            </h3>
            <p><strong>type-available</strong>(xs:string) as xs:boolean
            </p>
            
            
            <p>Used to control how a stylesheet behaves if a particular schema type is or is not
               available in the static context.
            </p>
            
            
            <h3><a name="unparsed-entity-public-id" id="unparsed-entity-public-id"></a>unparsed-entity-public-id
            </h3>
            <p><strong>unparsed-entity-public-id</strong>(xs:string) as xs:string
            </p>
            <p><strong>unparsed-entity-public-id</strong>(xs:string, node()) as xs:string
            </p>
            
            <p>Returns the public identifier of an unparsed entity</p>
            
            <h3><a name="unparsed-entity-uri" id="unparsed-entity-uri"></a>unparsed-entity-uri
            </h3>
            <p><strong>unparsed-entity-uri</strong>(xs:string) as xs:anyURI
            </p>
            <p><strong>unparsed-entity-uri</strong>(xs:string, node()) as xs:anyURI
            </p>
            
            <p>Returns the URI (system identifier) of an unparsed entity</p>
            
            <h3><a name="xml-to-json" id="xml-to-json"></a>xml-to-json
            </h3>
            <p><strong>xml-to-json</strong>(node()?) as xs:string?
            </p>
            <p><strong>xml-to-json</strong>(node()?, map(*)) as xs:string?
            </p>
            
            <p>Converts an XML tree, whose format corresponds to the XML representation of JSON defined
               in this specification, into a string conforming to the JSON grammar.
            </p>
            
         </div>
         <div class="resource">
            
            <h2><a id="xqupdate-summary"></a>4 XQuery Update Functions
            </h2>
            <p>This section lists all of the functions in this namespace that are defined in the
               [XQuery Update 1.0] specification.
            </p>
            <p>The normative definitions of these functions are in the
               [XQuery Update 1.0] specification.
               For convenience, a very brief, non-normative summary of each
               function is provided. For details, follow the link on the “Summary:”
               introductory text below each function.
            </p>
            <h3><a name="put" id="put"></a>put
            </h3>
            <p><strong>put</strong>(node(), xs:string) as empty-sequence()
            </p>
            <p>Stores a document or element to the location specified by <code>$uri</code>. This function is normally invoked to create a resource 
               on an external storage system such as a file system or a database.
            </p>
            <p>The external effects of <code>fn:put</code> are implementation-defined, since they occur outside the domain of XQuery. 
               The intent is that, if <code>fn:put</code> is invoked on a document node and no error is raised, a subsequent query can access
               
               the stored document by invoking <code>fn:doc</code> with the same URI.
            </p>
         </div>
         <div class="resource">
            
            <h2><a id="schemas"></a>5 XML Schema
            </h2>
            <p>Two functions, <code>fn:analyze-string</code> and <code>fn:json-to-xml</code>, return results that
               are always valid according to a defined XSD schema. A third function, <code>fn:xml-to-json</code>,
               requires input that is valid according to this schema.
            </p>
            <p>
               The target namespace of these schema components is <code>http://www.w3.org/2005/xpath-functions</code>. 
               
            </p>
            <p>The schema components are defined in a schema document located at
               <a href="https://www.w3.org/TR/xpath-functions-31/xpath-functions.xsd">https://www.w3.org/TR/xpath-functions-31/xpath-functions.xsd</a>.
            </p>
         </div>
         <div>
            
            <h2><a id="normrefs"></a>6 Normative References
            </h2>
            <p>These documents describe the names that are defined in this namespace at the time
               of publication. 
               The W3C reserves the right to define additional names in this namespace in the future.
               
               
            </p>
            <dl>
               <dt class="label"><span><a name="xpath-functions-31" id="xpath-functions-31"></a>XPath and XQuery Functions and Operators 3.1</span></dt>
               <dd>
                  <div class="resource">
                     
                     <p><a href="https://www.w3.org/TR/xpath-functions-31/">XQuery and XPath Functions and Operators 3.1</a>
                        (21 March 2017 version)
                        
                     </p>
                     
                  </div>
               </dd>
               <dt class="label"><span><a name="xslt-30" id="xslt-30"></a>XSLT 3.0</span></dt>
               <dd>
                  <div class="resource">
                     
                     <p><a href="https://www.w3.org/TR/xslt-30/">XSL Transformations (XSLT) Version 3.0</a>
                        (7 February 2017 version)
                        
                     </p>
                     
                  </div>
               </dd>
               <dt class="label"><span><a name="xquery-update-10" id="xquery-update-10"></a>XQuery Update 1.0</span></dt>
               <dd>
                  <div class="resource">
                     
                     <p><a href="https://www.w3.org/TR/xquery-update-10/">XQuery Update Facility 1.0</a>
                        (25 January 2011 version)
                        
                     </p>
                     
                  </div>
               </dd>
            </dl>
         </div>
         <div>
            
            <h2><a id="nonnormrefs"></a>7 Non-Normative References
            </h2>
            <dl>
               <dt class="label"><span><a name="rddl-ref" id="rddl-ref"></a>Resource Directory Description Language (RDDL)</span></dt>
               <dd>
                  <div class="resource">
                     
                     
                     <p><a href="http://www.rddl.org/">Resource Directory Description Language (RDDL)</a> (4 July 2007)
                     </p>
                     
                     
                  </div>
               </dd>
               <dt class="label"><span><a name="grddl-ref" id="grddl-ref"></a>Gleaning Resource Descriptions from Dialects of Languages (GRDDL)</span></dt>
               <dd>
                  <div class="resource">
                     
                     
                     <p><a href="http://www.w3.org/TR/grddl/">Gleaning Resource Descriptions from Dialects of Languages (GRDDL)</a>
                        (Recommendation of 11 September 2007)
                     </p>
                     
                     
                  </div>
               </dd>
               <dt class="label"><span><a name="rdf-ref" id="rdf-ref"></a>Resource Description Framework (RDF): Concepts and Abstract Syntax</span></dt>
               <dd>
                  <div class="resource">
                     
                     
                     <p><a href="http://www.w3.org/TR/rdf-concepts/">Resource Description Framework (RDF):
                           Concepts and Abstract Syntax</a> (Recommendation of 10 February 2004)
                     </p>
                     
                     
                  </div>
               </dd>
            </dl>
         </div>
      </div><script src="//www.w3.org/scripts/TR/2016/fixup.js"></script></body>
</html>