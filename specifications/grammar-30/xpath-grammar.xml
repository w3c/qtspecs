<?xml version="1.0" encoding="UTF-8"?>
<!--
Copyright (c) 2002 W3C(r) (http://www.w3.org/) (MIT (http://www.lcs.mit.edu/),
INRIA (http://www.inria.fr/), Keio (http://www.keio.ac.jp/)),
All Rights Reserved.
See http://www.w3.org/Consortium/Legal/ipr-notice-20000612#Copyright.
W3C liability
(http://www.w3.org/Consortium/Legal/ipr-notice-20000612#Legal_Disclaimer),
trademark
(http://www.w3.org/Consortium/Legal/ipr-notice-20000612#W3C_Trademarks),
document use
(http://www.w3.org/Consortium/Legal/copyright-documents-19990405),
and software licensing rules
(http://www.w3.org/Consortium/Legal/copyright-software-19980720)
apply.
-->
<!DOCTYPE g:grammar SYSTEM "grammar.dtd">

<g:grammar xmlns:g="http://www.w3.org/2001/03/XPath/grammar">
  <!-- ====================== Meta Information ==================== -->
  <!-- SJB grammar2spec.xsl seems to pick the first of these to create anchor names -->
  <g:language id="xpath1" display-name="XPath 1.0" if="xpath1"/>
  <g:language id="xpath20" display-name="XPath 2.0" if="xpath20"/>
  <g:language id="xpath30" display-name="XPath 3.0" if="xpath30"/>
  <g:language id="xpath31" display-name="XPath 3.1" if="xpath31"/>
  <g:language id="xquery10" display-name="XQuery 1.0" if="xquery10"/>
  <g:language id="xquery30" display-name="XQuery 3.0" if="xquery30"/>
  <g:language id="xquery31" display-name="XQuery 3.1" if="xquery31"/>
  <g:language id="xcore" display-name="XML Processing Formal Semantics Core Language 1.0" if="xcore"/>
  <g:language id="xslt2-patterns" display-name="XSLT 2.0 Patterns" if="xslt2-patterns"/>
  <g:language id="xslt30-patterns" display-name="XSLT 3.0 Patterns" if="xslt30-patterns"/>
  <!-- extensions: -->
  <g:language id="fulltext" display-name="XQuery Full-Text 1.0" if="fulltext"/>
  <g:language id="scripting" display-name="XQuery Scripting Extension 1.0" if="scripting"/>
  <g:language id="update10" display-name="XQuery Update Facility 1.0" if="update10"/>
  <g:language id="update30" display-name="XQuery Update Facility 3.0" if="update30"/>

  <!-- ====================== Entry Point Information ==================== -->
  <g:start name="ExprSingle" state="DEFAULT" if="xpath1"/>
  <g:start name="XPath" state="DEFAULT" if="xpath20 xpath30 xpath31"/>
  <g:start name="Expr" state="DEFAULT" if="xcore"/>
  <g:start name="QueryList" state="DEFAULT" if="xquery10 xquery30 xquery31"/>
  <g:start name="Pattern" state="DEFAULT" if="xslt2-patterns"/>
  <g:start name="Pattern30" state="DEFAULT" if="xslt30-patterns"/>

  <!-- ====================== Grammar Productions ==================== -->

  <!-- [ start XSLT 2.0 Patterns -->

  <g:production name="Pattern" if="xslt2-patterns">
    <g:ref name="PathPattern"/>
    <g:optional name="PathPatternTail">
      <g:string>|</g:string>
      <g:ref name="Pattern"/>
    </g:optional>
  </g:production>

  <g:production name="PathPattern" if="xslt2-patterns" xgc-id="leading-lone-slash">
    <g:choice break="true" name="PathPatternChoices">
      <g:sequence>
        <g:ref name="Slash"/>
        <g:optional name="OptionalRelativePathPattern" lookahead="1">
          <g:ref name="RelativePathPattern"/>
        </g:optional>
      </g:sequence>
      <g:sequence>
        <g:ref name="SlashSlash"/>
        <g:ref name="RelativePathPattern"/>
      </g:sequence>
      <g:sequence lookahead="2">
        <g:ref name="IdKeyPattern"/>
        <g:optional>
          <g:choice>
            <g:ref name="Slash" node-type="void"/>
            <g:ref name="SlashSlash"/>
          </g:choice>
          <g:ref name="RelativePathPattern"/>
        </g:optional>
      </g:sequence>
      <g:ref name="RelativePathPattern"/>
    </g:choice>
  </g:production>

  <g:production name="RelativePathPattern" if="xslt2-patterns" node-type="void">
    <g:ref name="PatternStep"/>
    <g:optional name="RelativePathPatternTail">
      <g:choice name="PatternStepSep">
        <g:ref name="Slash" node-type="void"/>
        <g:ref name="SlashSlash"/>
      </g:choice>
      <g:ref name="RelativePathPattern"/>
    </g:optional>
  </g:production>

  <g:production name="PatternStep" if="xslt2-patterns">
    <g:optional name="OptionalPatternAxis" lookahead="2">
      <g:ref name="PatternAxis"/>
    </g:optional>
    <g:ref name="NodeTest"/>
    <g:ref name="PredicateList"/>
  </g:production>

  <g:production name="PatternAxis" if="xslt2-patterns">
    <g:choice break="true" name="AxisChoice">
      <g:sequence>
        <g:string process-value="yes">child</g:string>
        <g:string>::</g:string>
      </g:sequence>
      <g:sequence>
        <g:string process-value="yes">attribute</g:string>
        <g:string>::</g:string>
      </g:sequence>
      <g:string>@</g:string>
    </g:choice>
  </g:production>

  <g:production name="IdKeyPattern" if="xslt2-patterns">
    <g:choice name="KeyOrIDPattern">
      <g:sequence>
        <g:string process-value="yes">id</g:string>
        <g:string>(</g:string>
        <g:ref name="IdValue"/>
        <g:string>)</g:string>
      </g:sequence>
      <g:sequence>
        <g:string process-value="yes">key</g:string>
        <g:string>(</g:string>
        <g:ref name="StringLiteral"/>
        <g:string>,</g:string>
        <g:ref name="KeyValue"/>
        <g:string>)</g:string>
      </g:sequence>
    </g:choice>
  </g:production>

  <g:production name="IdValue" node-type="void" if="xslt2-patterns">
    <g:choice>
      <g:ref name="StringLiteral"/>
      <g:ref name="VarRef"/>
    </g:choice>
  </g:production>

  <g:production name="KeyValue" node-type="void" if="xslt2-patterns">
    <g:choice>
      <g:ref name="Literal"/>
      <g:ref name="VarRef"/>
    </g:choice>
  </g:production>

  <!-- ] end XSLT 2.0 Patterns -->
  
  <!-- [ start XSLT 3.0 Patterns -->
  
  <g:production name="Pattern30" if="xslt30-patterns">
    <g:choice name="Pattern30Choices">
      <g:ref name="PredicatePattern"/>
      <g:ref name="UnionExprP"/>
    </g:choice> 
  </g:production>
  
  <g:production name="PredicatePattern" if="xslt30-patterns">
    <g:string>.</g:string>
    <g:ref name="PredicateList"/>
  </g:production>
  
  <g:production name="UnionExprP" if="xslt30-patterns">
    <g:ref name="IntersectExceptExprP"/>
    <g:zeroOrMore name="UnionExprPTail">
      <g:choice name="UnionExprPOperator">
        <g:string>union</g:string>
        <g:string>|</g:string>
      </g:choice>
      <g:ref name="IntersectExceptExprP"/>
    </g:zeroOrMore>
  </g:production>
  
  <g:production name="IntersectExceptExprP" if="xslt30-patterns">
    <g:ref name="PathExprP"/>
    <g:zeroOrMore name="IntersectExceptExprPTail">
      <g:choice name="IntersectExceptExprPOperator">
        <g:string>intersect</g:string>
        <g:string>except</g:string>
      </g:choice>
      <g:ref name="PathExprP"/>
    </g:zeroOrMore>
  </g:production>
  
  <g:production name="PathExprP" if="xslt30-patterns" xgc-id="leading-lone-slash">
    <g:choice break="true" name="PathExprPChoices">
      <g:ref name="RootedPath" lookahead="2"/>
      <g:sequence>
        <g:ref name="Slash"/>
        <g:optional name="OptionalRelativePathExprP" lookahead="1">
          <g:ref name="RelativePathExprP"/>
        </g:optional>
      </g:sequence>
      <g:sequence>
        <g:ref name="SlashSlash"/>
        <g:ref name="RelativePathExprP"/>
      </g:sequence>
      <g:ref name="RelativePathExprP"/>
    </g:choice>
  </g:production>
  
  <g:production name="RootedPath" if="xslt30-patterns">
    <g:choice name="VarOrFunctionCall">
      <g:ref name="VarRef"/>
      <g:ref name="FunctionCallP"/>
    </g:choice>
    <g:ref name="PredicateList"/>
    <g:optional>
      <g:choice name="RootedPathOperator">
        <g:ref name="Slash"/>
        <g:ref name="SlashSlash"/>
      </g:choice>
      <g:ref name="RelativePathExprP"/>
    </g:optional>
  </g:production>
  
  <g:production name="FunctionCallP" if="xslt30-patterns">
    <g:ref name="OuterFunctionName"/>
    <g:ref name="ArgumentListP"/>
  </g:production>
  
  <g:production name="OuterFunctionName" if="xslt30-patterns">
    <g:choice name="FNameChoice">
      <g:string process-value="yes">doc</g:string>
      <g:string process-value="yes">id</g:string>
      <g:string process-value="yes">element-with-id</g:string>
      <g:string process-value="yes">key</g:string>
      <g:ref name="URIQualifiedName"/>
    </g:choice>
  </g:production>

  <g:production name="ArgumentListP" if="xslt30-patterns">
    <g:string>(</g:string>
    <g:optional name="ArgListP">
      <g:ref name="ArgumentP"/>
      <g:zeroOrMore name="ArgListTailP">
        <g:string>,</g:string>
        <g:ref name="ArgumentP"/>
      </g:zeroOrMore>
    </g:optional>
    <g:string>)</g:string>
  </g:production>
  
  <g:production name="ArgumentP" if="xslt30-patterns">
    <g:choice name="ArgumentPChoice">
      <g:ref name="VarRef"/>
      <g:ref name="Literal"/>
    </g:choice>
  </g:production>
     
  <g:production name="RelativePathExprP" if="xslt30-patterns" node-type="void">
    <g:ref name="StepExprP"/>
    <g:zeroOrMore name="RelativePathExprPTail">
      <g:choice name="RelativePathExprPOperator">
        <g:ref name="Slash" node-type="void"/>
        <g:ref name="SlashSlash"/>
      </g:choice>
      <g:ref name="StepExprP"/>
    </g:zeroOrMore>
  </g:production>
  
  <g:production name="StepExprP" if="xslt30-patterns" >
    <g:choice name="StepExprPChoice">
      <g:ref name="PostfixExprP"/>
      <g:ref name="AxisStepP"/>
    </g:choice>
  </g:production>
  
  <g:production name="PostfixExprP" if="xslt30-patterns" >
    <g:ref name="ParenthesizedExprP"/>
    <g:ref name="PredicateList"/>
  </g:production>
  
  <g:production name="ParenthesizedExprP" if="xslt30-patterns" >
    <g:string>(</g:string>
    <g:ref name="UnionExprP"/>
    <g:string>)</g:string>
  </g:production>
  
  <g:production name="AxisStepP" if="xslt30-patterns" >
    <g:ref name="ForwardStepP"/>
    <g:ref name="PredicateList"/>
  </g:production>
  
  <g:production name="ForwardStepP"  if="xslt30-patterns" node-type="void">
    <g:choice name="ForwardAxisOrAbbrevP">
      <g:sequence lookahead="2">
        <g:ref name="ForwardAxisP"/>
        <g:ref name="NodeTest"/>
      </g:sequence>
      <g:ref name="AbbrevForwardStep"/>
    </g:choice>
  </g:production>
  
  <g:production name="ForwardAxisP" if="xslt30-patterns">
    <g:choice break="true" name="ForwardAxisPNames">
      <g:sequence>
        <g:string process-value="yes">child</g:string>
        <g:string>::</g:string>
      </g:sequence>
      <g:sequence>
        <g:string process-value="yes">descendant</g:string>
        <g:string>::</g:string>
      </g:sequence>
      <g:sequence>
        <g:string process-value="yes">attribute</g:string>
        <g:string>::</g:string>
      </g:sequence>
      <g:sequence>
        <g:string process-value="yes">self</g:string>
        <g:string>::</g:string>
      </g:sequence>
      <g:sequence>
        <g:string process-value="yes">descendant-or-self</g:string>
        <g:string>::</g:string>
      </g:sequence>
      <g:sequence>
        <g:string process-value="yes">namespace</g:string>
        <g:string>::</g:string>
      </g:sequence>
    </g:choice>
  </g:production>
  
  <!-- ] end XSLT 3.0 Patterns -->

  <!-- ===================================================================== -->

  <!-- The QueryList production is  not in the official grammar,
       and is not shown in the bnf.  It is here only for the purpose
       of testing a series of queries.
    -->
  <g:production name="QueryList" if="xquery10 xquery30 xquery31" show="no">
    <g:ref name="Module"/>
    <g:zeroOrMore name="QueryListTail">
      <g:string>%%%</g:string>
      <g:optional name="OptionalModule">
        <g:ref name="Module"/>
      </g:optional>
    </g:zeroOrMore>
  </g:production>

  <g:production name="XPath" if="xpath20 xpath30 xpath31">
    <g:ref name="Expr"/>
  </g:production>

  <!-- ### Use the name="" names instead of Expr_1() for generated .jj code -->
  <g:production name="Module" if="xquery10 xquery30 xquery31">
    <g:optional name="OptionalVersionDecl" lookahead="2">
      <g:ref name="VersionDecl"/>
    </g:optional>
    <g:choice name="MainOrLibraryModule">
      <g:ref name="LibraryModule" lookahead="2"/>
      <g:ref name="MainModule"/>
    </g:choice>
  </g:production>

<!--
VersionDecl ::= "xquery" (("encoding" StringLiteral) | ("version" StringLiteral
("encoding" StringLiteral)?)) Separator
-->
  <g:production name="VersionDecl" if="xquery10 xquery30 xquery31">
    <g:string>xquery</g:string>
    <g:choice>
      <g:sequence if="xquery30 xquery31">
        <g:string process-value="yes">encoding</g:string>
        <g:ref name="StringLiteral"/>
      </g:sequence>
      <g:sequence>
        <g:string process-value="yes">version</g:string>
        <g:ref name="StringLiteral"/>
        <g:optional name="OptionalEncodingSpec">
          <g:string>encoding</g:string>
          <g:ref name="StringLiteral"/>
        </g:optional>
      </g:sequence>
    </g:choice>
    <g:ref name="Separator"/>
  </g:production>

  <g:production name="MainModule" if="xquery10 xquery30 xquery31">
    <g:ref name="Prolog"/>
    <g:ref name="QueryBody"/>
  </g:production>

  <g:production name="LibraryModule" if="xquery10 xquery30 xquery31">
    <g:ref name="ModuleDecl"/>
    <g:ref name="Prolog"/>
  </g:production>

  <g:production name="ModuleDecl" if="xcore xquery10 xquery30 xquery31">
    <g:string>module</g:string>
    <g:string>namespace</g:string>
    <g:ref name="NCName"/>
    <g:string>=</g:string>
    <g:ref name="URILiteral"/>
    <g:ref name="Separator"/>
  </g:production>

  <!-- [ start Prolog -->

  <g:production name="Prolog" if="xquery10 xquery30 xquery31">
    <g:zeroOrMore name="DeclList" lookahead="2">
      <g:choice name="DeclChoice">
        <g:ref name="DefaultNamespaceDecl" lookahead="3"/>
        <g:ref name="Setter" lookahead="3"/>
        <g:ref name="NamespaceDecl" lookahead="2"/>
        <g:ref name="Import"/>
        <g:ref name="FTOptionDecl" lookahead="2" if="fulltext"/>
      </g:choice>
      <g:ref name="Separator"/>
    </g:zeroOrMore>
    <g:zeroOrMore name="FunctionsAndVarsList" lookahead="2">
      <g:choice name="FunctionOrVar">
        <g:ref name="VarDecl" lookahead="2" if="xquery10"/>
        <g:ref name="ContextItemDecl" lookahead="2" if="xquery30 xquery31"/>
        <g:ref name="FunctionDecl" lookahead="2" if="xquery10"/>
        <g:ref name="AnnotatedDecl" lookahead="2" if="xquery30 xquery31"/>
        <g:ref name="OptionDecl" lookahead="2"/>
      </g:choice>
      <g:ref name="Separator"/>
    </g:zeroOrMore>
  </g:production>

  <g:production name="Separator" if="xcore xquery10 xquery30 xquery31">
    <g:string>;</g:string>
  </g:production>

  <!-- [ start Setter -->

  <g:production name="Setter" if="xquery10 xquery30 xquery31">
    <g:choice name="SetterChoice">
      <g:ref name="BoundarySpaceDecl" lookahead="2"/>
      <g:ref name="DefaultCollationDecl" lookahead="3"/>
      <g:ref name="BaseURIDecl" lookahead="2"/>
      <g:ref name="ConstructionDecl" lookahead="2"/>
      <g:ref name="OrderingModeDecl" lookahead="2"/>
      <g:ref name="EmptyOrderDecl" lookahead="3"/>
      <g:ref name="RevalidationDecl" if="update10 update30" lookahead="2"/>
      <g:ref name="CopyNamespacesDecl" lookahead="2"/>
      <g:ref name="DecimalFormatDecl" lookahead="2" if="xquery30 xquery31"/>
    </g:choice>
  </g:production>

  <g:production name="BoundarySpaceDecl" if="xquery10 xquery30 xquery31">
    <g:string>declare</g:string>
    <g:string>boundary-space</g:string>
    <g:choice name="XMLSpacePreserveOrStrip">
      <g:string process-value="yes">preserve</g:string>
      <g:string process-value="yes">strip</g:string>
    </g:choice>
  </g:production>

  <g:production name="DefaultCollationDecl" if="xcore xquery10 xquery30 xquery31">
    <g:string>declare</g:string>
    <g:string>default</g:string>
    <g:string>collation</g:string>
    <g:ref name="URILiteral"/>
  </g:production>

  <g:production name="BaseURIDecl" if="xcore xquery10 xquery30 xquery31">
    <g:string>declare</g:string>
    <g:string>base-uri</g:string>
    <g:ref name="URILiteral"/>
  </g:production>

  <g:production name="ConstructionDecl" if="xcore xquery10 xquery30 xquery31">
    <g:string>declare</g:string>
    <g:string>construction</g:string>
    <g:choice name="StripOrPreserve">
      <g:string process-value="yes">strip</g:string>
      <g:string process-value="yes">preserve</g:string>
    </g:choice>
  </g:production>

  <g:production name="OrderingModeDecl" if="xcore xquery10 xquery30 xquery31">
    <g:string>declare</g:string>
    <g:string>ordering</g:string>
    <g:choice name="DeclareOrderingArgument">
      <g:string process-value="yes">ordered</g:string>
      <g:string process-value="yes">unordered</g:string>
    </g:choice>
  </g:production>

  <g:production name="EmptyOrderDecl" if="xcore xquery10 xquery30 xquery31">
    <g:string>declare</g:string>
    <g:string>default</g:string>
    <g:string>order</g:string>
    <g:string>empty</g:string>
    <g:choice name="DeclareEmptyOrderArgument">
      <g:ref name="Greatest"/>
      <g:ref name="Least"/>
    </g:choice>
  </g:production>

  <g:production name="CopyNamespacesDecl" if="xcore xquery10 xquery30 xquery31">
    <g:string>declare</g:string>
    <g:string>copy-namespaces</g:string>
    <g:ref name="PreserveMode"/>
    <g:string>,</g:string>
    <g:ref name="InheritMode"/>
  </g:production>

  <g:production name="PreserveMode" if="xcore xquery10 xquery30 xquery31">
    <g:choice name="ChoiceForPreserveMode">
      <g:string process-value="yes">preserve</g:string>
      <g:string process-value="yes">no-preserve</g:string>
    </g:choice>
  </g:production>

  <g:production name="InheritMode" if="xcore xquery10 xquery30 xquery31">
    <g:choice name="ChoiceForInheritMode">
      <g:string process-value="yes">inherit</g:string>
      <g:string process-value="yes">no-inherit</g:string>
    </g:choice>
  </g:production>

  <g:production name="DecimalFormatDecl" if="xquery30 xquery31">
    <g:string>declare</g:string>
    <g:choice>
      <g:sequence>
        <g:string>decimal-format</g:string>
        <g:ref name="_QName_or_EQName" unfold="yes"/>
      </g:sequence>
      <g:sequence>
        <g:string>default</g:string>
        <g:string>decimal-format</g:string>
      </g:sequence>
    </g:choice>
    <g:zeroOrMore>
      <g:ref name="DFPropertyName"/>
      <g:string>=</g:string>
      <g:ref name="StringLiteral"/>
    </g:zeroOrMore>
  </g:production>

  <g:production name="DFPropertyName" if="xquery30 xquery31">
    <g:choice>
      <g:string process-value="yes">decimal-separator</g:string>
      <g:string process-value="yes">grouping-separator</g:string>
      <g:string process-value="yes">infinity</g:string>
      <g:string process-value="yes">minus-sign</g:string>
      <g:string process-value="yes">NaN</g:string>
      <g:string process-value="yes">percent</g:string>
      <g:string process-value="yes">per-mille</g:string>
      <g:string process-value="yes">zero-digit</g:string>
      <g:string process-value="yes">digit</g:string>
      <g:string process-value="yes">pattern-separator</g:string>
      <g:string process-value="yes" if="xquery31">exponent-separator</g:string>
    </g:choice>
  </g:production>

  <!-- ] end Setter -->

  <!-- [ start Import -->

  <g:production name="Import" if="xquery10 xquery30 xquery31">
    <g:choice name="Imports">
      <g:ref name="SchemaImport" lookahead="2"/>
      <g:ref name="ModuleImport"/>
    </g:choice>
  </g:production>

  <g:production name="SchemaImport" if="xcore xquery10 xquery30 xquery31">
    <g:string>import</g:string>
    <g:string>schema</g:string>
    <g:optional name="OptionalSchemaImportPrefixDecl">
      <g:ref name="SchemaPrefix"/>
    </g:optional>
    <g:ref name="URILiteral"/>
    <g:optional name="OptionalLocationHint">
      <g:string>at</g:string>
      <g:ref name="URILiteral"/>
      <g:zeroOrMore name="AdditionalSchemaLocationHints">
        <g:string>,</g:string>
        <g:ref name="URILiteral"/>
      </g:zeroOrMore>
    </g:optional>
  </g:production>

  <g:production name="SchemaPrefix" if="xcore xquery10 xquery30 xquery31">
    <g:choice name="SchemaPrefixNamespaceBinding">
      <g:sequence>
        <g:string>namespace</g:string>
        <g:ref name="NCName"/>
        <g:string>=</g:string>
      </g:sequence>
      <g:sequence>
        <g:string>default</g:string>
        <g:string>element</g:string>
        <g:string>namespace</g:string>
      </g:sequence>
    </g:choice>
  </g:production>

  <g:production name="ModuleImport" if="xcore xquery10 xquery30 xquery31">
    <g:string>import</g:string>
    <g:string>module</g:string>
    <g:optional name="ImportPrefixDecl">
      <g:string>namespace</g:string>
      <g:ref name="NCName"/>
      <g:string>=</g:string>
    </g:optional>
    <g:ref name="URILiteral"/>
    <g:optional name="LocationHint">
      <g:string>at</g:string>
      <g:ref name="URILiteral"/>
      <g:zeroOrMore name="AdditionalModuleLocationHints">
        <g:string>,</g:string>
        <g:ref name="URILiteral"/>
      </g:zeroOrMore>
    </g:optional>
  </g:production>

  <!-- ] end Import -->

  <g:production name="NamespaceDecl" if="xcore xquery10 xquery30 xquery31">
    <g:string>declare</g:string>
    <g:string>namespace</g:string>
    <g:ref name="NCName"/>
    <g:string>=</g:string>
    <g:ref name="URILiteral"/>
  </g:production>

  <g:production name="DefaultNamespaceDecl" if="xcore xquery10 xquery30 xquery31">
    <g:string>declare</g:string>
    <g:string>default</g:string>
    <g:choice name="DeclareDefaultElementOrFunction">
      <g:string process-value="yes">element</g:string>
      <g:string process-value="yes">function</g:string>
    </g:choice>
    <g:string>namespace</g:string>
    <g:ref name="URILiteral"/>
  </g:production>

  <g:production name="FTOptionDecl" if="fulltext" not-if="xpath1 xpath20 xpath30 xpath31 xslt2-patterns xslt30-patterns">
    <g:string>declare</g:string>
    <g:string>ft-option</g:string>
    <g:ref name="FTMatchOptions"/>
  </g:production>

  <g:production name="AnnotatedDecl" if="xquery30 xquery31">
    <g:string>declare</g:string>
    <g:zeroOrMore>
      <g:choice>
        <g:ref name="CompatibilityAnnotation" if="update10 update30"/>
        <g:ref name="Annotation"/>
      </g:choice>
    </g:zeroOrMore>
    <g:choice>
      <g:ref name="VarDecl"/>
      <g:ref name="FunctionDecl"/>
    </g:choice>
  </g:production>

  <g:production name="CompatibilityAnnotation" if="update10 update30" not-if="xquery10">
    <g:string>updating</g:string>
  </g:production>

  <g:production name="Annotation" if="xquery30 xquery31">
    <g:string>%</g:string>
    <g:ref name="_QName_or_EQName" unfold="yes"/>
    <g:optional>
      <g:string>(</g:string>
      <g:ref name="Literal"/>
      <g:zeroOrMore>
        <g:string>,</g:string>
        <g:ref name="Literal"/>
      </g:zeroOrMore>
      <g:string>)</g:string>
    </g:optional>
  </g:production>

  <g:production name="VarDecl" if="xcore xquery10 xquery30 xquery31">
    <g:string if="xcore xquery10">declare</g:string>
    <g:string>variable</g:string>
    <g:string>$</g:string>
    <g:ref name="_QName_or_EQName" unfold="yes" if="xcore xquery10"/>
    <g:ref name="VarName" if="xquery30 xquery31"/>
    <g:optional name="VarDeclOptionalTypeDecl">
      <g:ref name="TypeDeclaration"/>
    </g:optional>
    <g:choice name="VarDeclAssignmentOrExtern">
      <g:sequence>
        <g:string>:=</g:string>
        <g:ref name="ExprSingle" if="xcore xquery10"/>
        <g:ref name="VarValue" if="xquery30 xquery31"/>
      </g:sequence>
      <g:sequence>
        <g:ref name="External"/>
        <g:optional if="xquery30 xquery31">
          <g:string>:=</g:string>
          <g:ref name="VarDefaultValue"/>
        </g:optional>
      </g:sequence>
    </g:choice>
  </g:production>

  <g:production name="VarValue" if="xquery30 xquery31">
    <g:ref name="ExprSingle"/>
  </g:production>

  <g:production name="VarDefaultValue" if="xquery30 xquery31">
    <g:ref name="ExprSingle"/>
  </g:production>

  <g:production name="ContextItemDecl" if="xquery30 xquery31">
    <g:string>declare</g:string>
    <g:string>context</g:string>
    <g:string>item</g:string>
    <g:optional>
      <g:string>as</g:string>
      <g:ref name="ItemType"/>
    </g:optional>
    <g:choice>
      <g:sequence>
        <g:string>:=</g:string>
        <g:ref name="VarValue"/>
      </g:sequence>
      <g:sequence>
        <g:ref name="External"/>
        <g:optional>
          <g:string>:=</g:string>
          <g:ref name="VarDefaultValue"/>
        </g:optional>
      </g:sequence>
    </g:choice>
  </g:production>

  <g:production name="FunctionDecl" if="xcore xquery10 xquery30 xquery31" xgc-id="reserved-function-names">
    <g:string if="xcore xquery10">declare</g:string>
    <g:optional name="optionalUpdateQualifierForFunctionDecl" if="update10 update30" not-if="xquery30 xquery31">
      <g:string process-value="yes">updating</g:string>
    </g:optional>
    <g:string>function</g:string>
    <g:ref name="_Function_QName_or_EQName" unfold="yes"/>
    <g:string>(</g:string>
    <g:optional name="OptionalParamList">
      <g:ref name="ParamList"/>
    </g:optional>
    <g:string>)</g:string>
    <g:optional name="optionFuncType">
      <g:string>as</g:string>
      <g:ref name="SequenceType"/>
    </g:optional>
    <g:choice name="FunctionDeclBody">
      <g:ref name="EnclosedExpr" if="xcore xquery10"/>
      <g:ref name="FunctionBody" if="xquery30 xquery31"/>
      <g:ref name="External"/>
    </g:choice>
  </g:production>

  <g:production name="ParamList" if="xcore xpath30 xpath31 xquery10 xquery30 xquery31 xslt30-patterns">
    <g:ref name="Param"/>
    <g:zeroOrMore name="ParamListTail">
      <g:string>,</g:string>
      <g:ref name="Param"/>
    </g:zeroOrMore>
  </g:production>

  <g:production name="Param" if="xcore xpath30 xpath31 xquery10 xquery30 xquery31 xslt30-patterns">
    <g:string>$</g:string>
    <g:ref name="_QName_or_EQName" unfold="yes"/>
    <g:optional name="OptionalTypeDeclarationForParam">
      <g:ref name="TypeDeclaration"/>
    </g:optional>
  </g:production>

  <g:production name="FunctionBody" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns">
    <g:ref name="EnclosedExpr" not-if="scripting"/>
    <g:ref name="Block" if="scripting"/>
  </g:production>

  <g:production name="EnclosedExpr" if="xcore xpath30 xpath31 xquery10 xquery30 xquery31 xslt30-patterns">
    <g:ref name="Lbrace"/>
    <g:ref name="Expr" not-if="xpath31 xquery31"/>
    <g:optional if="xpath31 xquery31">
      <g:ref name="Expr"/>
    </g:optional>
    <g:ref name="Rbrace"/>
  </g:production>

  <g:production name="OptionDecl" if="xcore xquery10 xquery30 xquery31">
    <g:string>declare</g:string>
    <g:string>option</g:string>
    <g:ref name="_QName_or_EQName" unfold="yes"/>
    <g:ref name="StringLiteral"/>
  </g:production>

  <!-- ] end Prolog -->

  <g:production name="QueryBody" if="xquery10 xquery30 xquery31">
    <g:ref name="Expr"/>
  </g:production>

  <g:production name="Expr" not-if="xpath1">
    <g:ref name="ExprSingle" not-if="scripting"/>
    <g:zeroOrMore not-if="scripting">
      <g:string>,</g:string>
      <g:ref name="ExprSingle"/>
    </g:zeroOrMore>
    <g:ref name="ApplyExpr" if="scripting"/>
  </g:production>

  <g:production name="ApplyExpr" if="scripting">
    <g:ref name="ConcatExpr"/>
    <g:optional>
      <g:string>;</g:string>
      <g:zeroOrMore>
        <g:ref name="ConcatExpr"/>
        <g:string>;</g:string>
      </g:zeroOrMore>
    </g:optional>
  </g:production>

  <g:production name="ConcatExpr" if="scripting">
    <g:ref name="ExprSingle"/>
    <g:zeroOrMore>
      <g:string>,</g:string>
      <g:ref name="ExprSingle"/>
    </g:zeroOrMore>
  </g:production>

  <g:production name="ExprSingle" node-type="void">
    <g:choice break="true" name="ExprSingleChoice">
      <g:ref name="ForExpr" if="xpath20 xpath30 xpath31 xslt2-patterns xslt30-patterns" lookahead="2"/>
      <g:ref name="LetExpr" if="xpath30 xpath31 xslt30-patterns" lookahead="2"/>
      <g:ref name="FLWORExpr10" if="xcore xquery10" lookahead="2"/>
      <g:ref name="FLWORExpr11" if="xquery30 xquery31" lookahead="2"/>
      <g:ref name="QuantifiedExpr" not-if="xpath1" lookahead="2"/>
      <g:ref name="SwitchExpr" if="xquery30 xquery31" lookahead="2"/>
      <g:ref name="TypeswitchExpr" if="xcore xquery10 xquery30 xquery31" lookahead="2"/>
      <g:ref name="IfExpr" not-if="xpath1" lookahead="2"/>
      <g:ref name="TryCatchExpr" if="xquery30 xquery31" lookahead="2"/>
      <g:ref name="InsertExpr" if="update10 update30" lookahead="2"/>
      <g:ref name="DeleteExpr" if="update10 update30" lookahead="2"/>
      <g:ref name="RenameExpr" if="update10 update30" lookahead="2"/>
      <g:ref name="ReplaceExpr" if="update10 update30" lookahead="2"/>
      <g:ref name="UpdatingFunctionCall" if="update30" lookahead="2"/>
      <g:ref name="TransformExpr" if="update10" lookahead="2"/>
      <g:ref name="CopyModifyExpr" if="update30" lookahead="2"/>
      <g:ref name="BlockExpr" if="scripting" lookahead="2"/>
      <g:ref name="AssignmentExpr" if="scripting" lookahead="3"/>
      <g:ref name="ExitExpr" if="scripting" lookahead="2"/>
      <g:ref name="WhileExpr" if="scripting" lookahead="2"/>
      <g:ref name="OrExpr"/>
    </g:choice>
  </g:production>

  <!-- [ XPath has ForExpr and (in 2.1) LetExpr -->

  <g:production name="ForExpr" if="xpath20 xpath30 xpath31 xslt2-patterns xslt30-patterns">
    <g:ref name="SimpleForClause"/>
    <g:string>return</g:string>
    <g:ref name="ExprSingle"/>
  </g:production>

  <g:production name="SimpleForClause" if="xpath20 xpath30 xpath31 xslt2-patterns xslt30-patterns" node-type="void">
    <g:string>for</g:string>
    <g:ref name="SimpleForBinding" unfold="yes" if="xpath20 xslt2-patterns"/>
    <g:ref name="SimpleForBinding" if="xpath30 xpath31 xslt30-patterns"/>
    <g:zeroOrMore name="SimpleForClauseTail">
      <g:string>,</g:string>
      <g:ref name="SimpleForBinding" unfold="yes" if="xpath20 xslt2-patterns"/>
      <g:ref name="SimpleForBinding" if="xpath30 xpath31 xslt30-patterns"/>
    </g:zeroOrMore>
  </g:production>

  <g:production name="SimpleForBinding" if="xpath30 xpath31 xslt30-patterns"><!-- also unfolded for xpath20 xslt2-patterns -->
    <g:string>$</g:string>
    <g:ref name="VarName"/>
    <g:optional if="fulltext">
      <g:ref name="FTScoreVar"/>
    </g:optional>
    <g:string>in</g:string>
    <g:ref name="ExprSingle"/>
  </g:production>

  <g:production name="LetExpr" if="xpath30 xpath31 xslt30-patterns">
    <g:ref name="SimpleLetClause"/>
    <g:string>return</g:string>
    <g:ref name="ExprSingle"/>
  </g:production>

  <g:production name="SimpleLetClause" if="xpath30 xpath31 xslt30-patterns">
    <g:string>let</g:string>
    <g:ref name="SimpleLetBinding"/>
    <g:zeroOrMore>
      <g:string>,</g:string>
      <g:ref name="SimpleLetBinding"/>
    </g:zeroOrMore>
  </g:production>

  <g:production name="SimpleLetBinding" if="xpath30 xpath31 xslt30-patterns">
    <g:string>$</g:string>
    <g:ref name="VarName"/>
    <g:string>:=</g:string>
    <g:ref name="ExprSingle"/>
  </g:production>

  <!-- ] end ForExpr + LetExpr -->

  <!-- [ XQuery has FLWORExpr -->

  <g:production name="FLWORExpr10" exposition-name="FLWORExpr" if="xcore xquery10">
    <g:oneOrMore if="xquery10" name="FLWORClauseList">
      <g:choice name="ForOrLet">
        <g:ref name="ForClause"/>
        <g:ref name="LetClause"/>
      </g:choice>
    </g:oneOrMore>
    <g:choice if="xcore" name="ForOrLetCore">
      <g:ref name="ForClause"/>
      <g:ref name="LetClause"/>
    </g:choice>
    <g:optional if="xquery10" name="OptionalWhere">
      <g:ref name="WhereClause"/>
    </g:optional>
    <g:optional name="OptionalOrderBy" if="xquery10">
      <g:ref name="OrderByClause"/>
    </g:optional>
    <g:string>return</g:string>
    <g:ref name="ExprSingle"/>
  </g:production>

  <g:production name="FLWORExpr11" exposition-name="FLWORExpr" if="xquery30 xquery31">
    <g:ref name="InitialClause"/>
    <g:zeroOrMore>
      <g:ref name="IntermediateClause"/>
    </g:zeroOrMore>
    <g:ref name="ReturnClause"/>
  </g:production>

  <g:production name="InitialClause" if="xquery30 xquery31">
    <g:choice>
      <g:ref name="ForClause" lookahead="2"/>
      <g:ref name="LetClause"/>
      <g:ref name="WindowClause" lookahead="2"/>
    </g:choice>
  </g:production>

  <g:production name="IntermediateClause" if="xquery30 xquery31">
    <g:choice>
      <g:ref name="InitialClause"/>
      <g:ref name="WhereClause"/>
      <g:ref name="GroupByClause"/>
      <g:ref name="OrderByClause"/>
      <g:ref name="CountClause"/>
    </g:choice>
  </g:production>

  <g:production name="ForClause" if="xcore xquery10 xquery30 xquery31">
    <g:string>for</g:string>
    <g:ref name="ForBinding" unfold="yes" if="xcore xquery10"/>
    <g:ref name="ForBinding" if="xquery30 xquery31"/>
    <g:zeroOrMore if="xquery10 xquery30 xquery31" name="ForClauseTail">
      <g:string>,</g:string>
      <g:ref name="ForBinding" unfold="yes" if="xquery10"/>
      <g:ref name="ForBinding" if="xquery30 xquery31"/>
    </g:zeroOrMore>
  </g:production>

  <g:production name="ForBinding" if="xquery30 xquery31"><!-- also unfolded for xcore xquery10 -->
    <g:string>$</g:string>
    <g:ref name="VarName"/>
    <g:optional>
      <g:ref name="TypeDeclaration"/>
    </g:optional>
    <g:optional if="xquery30 xquery31">
      <g:ref name="AllowingEmpty"/>
    </g:optional>
    <g:optional>
      <g:ref name="PositionalVar"/>
    </g:optional>
    <g:optional if="fulltext">
      <g:ref name="FTScoreVar"/>
    </g:optional>
    <g:string>in</g:string>
    <g:ref name="ExprSingle"/>
  </g:production>

  <g:production name="AllowingEmpty" if="xquery30 xquery31">
    <g:string>allowing</g:string>
    <g:string>empty</g:string>
  </g:production>

  <g:production name="PositionalVar" if="xcore xquery10 xquery30 xquery31">
    <g:string>at</g:string>
    <g:string>$</g:string>
    <g:ref name="VarName"/>
  </g:production>

  <g:production name="FTScoreVar" if="fulltext">
    <g:string>score</g:string>
    <g:string>$</g:string>
    <g:ref name="VarName"/>
  </g:production>

  <g:production name="LetClause" if="xcore xquery10 xquery30 xquery31">
    <g:string>let</g:string>
    <g:ref name="LetBinding" unfold="yes" if="xcore xquery10"/>
    <g:ref name="LetBinding" if="xquery30 xquery31"/>
    <g:zeroOrMore if="xquery10 xquery30 xquery31" name="LetClauseTail">
      <g:string>,</g:string>
      <g:ref name="LetBinding" unfold="yes" if="xquery10"/>
      <g:ref name="LetBinding" if="xquery30 xquery31"/>
    </g:zeroOrMore>
  </g:production>

  <g:production name="LetBinding" if="xquery30 xquery31"><!-- also unfolded for xcore xquery10 -->
    <g:choice>
      <g:sequence>
        <g:string>$</g:string>
        <g:ref name="VarName"/>
        <g:optional>
          <g:ref name="TypeDeclaration"/>
        </g:optional>
      </g:sequence>
      <g:ref name="FTScoreVar" if="fulltext"/>
    </g:choice>
    <g:string>:=</g:string>
    <g:ref name="ExprSingle"/>
  </g:production>

  <g:production name="WindowClause" if="xquery30 xquery31">
    <g:string>for</g:string>
    <g:choice>
      <g:ref name="TumblingWindowClause"/>
      <g:ref name="SlidingWindowClause"/>
    </g:choice>
  </g:production>

  <g:production name="TumblingWindowClause" if="xquery30 xquery31">
    <g:string>tumbling</g:string>
    <g:string>window</g:string>
    <g:string>$</g:string>
    <g:ref name="VarName"/>
    <g:optional>
      <g:ref name="TypeDeclaration"/>
    </g:optional>
    <g:string>in</g:string>
    <g:ref name="ExprSingle"/>
    <g:ref name="WindowStartCondition"/>
    <g:optional>
      <g:ref name="WindowEndCondition"/>
    </g:optional>
  </g:production>

  <g:production name="SlidingWindowClause" if="xquery30 xquery31">
    <g:string>sliding</g:string>
    <g:string>window</g:string>
    <g:string>$</g:string>
    <g:ref name="VarName"/>
    <g:optional>
      <g:ref name="TypeDeclaration"/>
    </g:optional>
    <g:string>in</g:string>
    <g:ref name="ExprSingle"/>
    <g:ref name="WindowStartCondition"/>
    <g:ref name="WindowEndCondition"/>
  </g:production>

  <g:production name="WindowStartCondition" if="xquery30 xquery31">
    <g:string>start</g:string>
    <g:ref name="WindowVars"/>
    <g:string>when</g:string>
    <g:ref name="ExprSingle"/>
  </g:production>

  <g:production name="WindowEndCondition" if="xquery30 xquery31">
    <g:optional>
      <g:string process-value="yes">only</g:string>
    </g:optional>
    <g:string>end</g:string>
    <g:ref name="WindowVars"/>
    <g:string>when</g:string>
    <g:ref name="ExprSingle"/>
  </g:production>

  <g:production name="WindowVars" if="xquery30 xquery31">
    <g:optional>
      <g:string>$</g:string>
      <g:ref name="CurrentItem"/>
      <!--
      <g:optional>
        <g:ref name="TypeDeclaration"/>
      </g:optional>
      -->
    </g:optional>
    <g:optional>
      <g:ref name="PositionalVar"/>
    </g:optional>
    <g:optional lookahead="2">
      <g:string>previous</g:string>
      <g:string>$</g:string>
      <g:ref name="PreviousItem"/>
      <!--
      <g:optional>
        <g:ref name="TypeDeclaration"/>
      </g:optional>
      -->
    </g:optional>
    <g:optional lookahead="2">
      <g:string>next</g:string>
      <g:string>$</g:string>
      <g:ref name="NextItem"/>
      <!--
      <g:optional>
        <g:ref name="TypeDeclaration"/>
      </g:optional>
      -->
    </g:optional>
  </g:production>

  <g:production name="CurrentItem" if="xquery30 xquery31">
    <g:ref name="_QName_or_EQName" unfold="yes"/>
  </g:production>

  <g:production name="PreviousItem" if="xquery30 xquery31">
    <g:ref name="_QName_or_EQName" unfold="yes"/>
  </g:production>

  <g:production name="NextItem" if="xquery30 xquery31">
    <g:ref name="_QName_or_EQName" unfold="yes"/>
  </g:production>

  <g:production name="CountClause" if="xquery30 xquery31">
    <g:string>count</g:string>
    <g:string>$</g:string>
    <g:ref name="VarName"/>
  </g:production>

  <g:production name="WhereClause" if="xquery10 xquery30 xquery31">
    <g:string>where</g:string>
    <g:ref name="ExprSingle"/>
  </g:production>

  <g:production name="GroupByClause" if="xquery30 xquery31">
    <g:string>group</g:string>
    <g:string>by</g:string>
    <g:ref name="GroupingSpecList"/>
  </g:production>

  <g:production name="GroupingSpecList" if="xquery30 xquery31">
    <g:ref name="GroupingSpec"/>
    <g:zeroOrMore name="GroupingSpecListTail">
      <g:string>,</g:string>
      <g:ref name="GroupingSpec"/>
    </g:zeroOrMore>
  </g:production>

  <g:production name="GroupingSpec" if="xquery30 xquery31">
    <g:ref name="GroupingVariable"/>
    <g:optional>
      <g:optional>
        <g:ref name="TypeDeclaration"/>
      </g:optional>
      <g:string>:=</g:string>
      <g:ref name="ExprSingle"/>
    </g:optional>
    <g:optional>
      <g:string>collation</g:string>
      <g:ref name="URILiteral"/>
    </g:optional>
  </g:production>

  <g:production name="GroupingVariable" if="xquery30 xquery31">
    <g:string>$</g:string>
    <g:ref name="VarName"/>
  </g:production>


  <g:production name="OrderByClause" if="xcore xquery10 xquery30 xquery31">
    <g:choice break="false" name="OrderByOrOrderByStable">
      <g:sequence>
        <g:string>order</g:string>
        <g:string>by</g:string>
      </g:sequence>
      <g:sequence>
        <g:string process-value="yes">stable</g:string>
        <g:string>order</g:string>
        <g:string>by</g:string>
      </g:sequence>
    </g:choice>
    <g:ref name="OrderSpecList"/>
  </g:production>

  <g:production name="OrderSpecList" if="xcore xquery10 xquery30 xquery31">
    <g:ref name="OrderSpec"/>
    <g:zeroOrMore name="OrderSpecListTail">
      <g:string>,</g:string>
      <g:ref name="OrderSpec"/>
    </g:zeroOrMore>
  </g:production>

  <g:production name="OrderSpec" if="xcore xquery10 xquery30 xquery31">
    <g:ref name="ExprSingle"/>
    <g:ref name="OrderModifier"/>
  </g:production>

  <g:production name="OrderModifier" if="xcore xquery10 xquery30 xquery31">
    <g:optional name="SortDirectionOption">
      <g:choice name="AscendingOrDescending">
        <g:ref name="Ascending"/>
        <g:ref name="Descending"/>
      </g:choice>
    </g:optional>
    <g:optional name="EmptyPosOption">
      <g:string>empty</g:string>
      <g:choice name="EmptyGreatestOrLeast">
        <g:ref name="Greatest"/>
        <g:ref name="Least"/>
      </g:choice>
    </g:optional>
    <g:optional name="CollationSpecOption">
      <g:string>collation</g:string>
      <g:ref name="URILiteral"/>
    </g:optional>
  </g:production>

  <g:production name="ReturnClause" if="xquery30 xquery31">
    <g:string>return</g:string>
    <g:ref name="ExprSingle"/>
  </g:production>

  <!-- ] end FLWORExpr -->

  <g:production name="QuantifiedExpr" not-if="xpath1">
    <g:choice name="SomeOrEvery">
      <g:string process-value="yes">some</g:string>
      <g:string process-value="yes">every</g:string>
    </g:choice>
    <g:string>$</g:string>
    <g:ref name="VarName"/>
    <g:optional if="xcore xquery10 xquery30 xquery31" name="QuantifiedTypeDeclarationOption">
      <g:ref name="TypeDeclaration"/>
    </g:optional>
    <g:string>in</g:string>
    <g:ref name="ExprSingle"/>
    <g:zeroOrMore name="QuantifiedVarDeclListTail">
      <g:string>,</g:string>
      <g:string>$</g:string>
      <g:ref name="VarName"/>
      <g:optional if="xcore xquery10 xquery30 xquery31" name="QuantifiedTailTypeDeclarationOption">
        <g:ref name="TypeDeclaration"/>
      </g:optional>
      <g:string>in</g:string>
      <g:ref name="ExprSingle"/>
    </g:zeroOrMore>
    <g:string>satisfies</g:string>
    <g:ref name="ExprSingle"/>
  </g:production>

  <g:production name="SwitchExpr" if="xquery30 xquery31">
    <g:string>switch</g:string>
    <g:string>(</g:string>
    <g:ref name="Expr"/>
    <g:string>)</g:string>
    <g:oneOrMore>
      <g:ref name="SwitchCaseClause"/>
    </g:oneOrMore>
    <g:string>default</g:string>
    <g:string>return</g:string>
    <g:ref name="ExprSingle"/>
  </g:production>

  <g:production name="SwitchCaseClause" if="xquery30 xquery31">
    <g:oneOrMore>
      <g:string>case</g:string>
      <g:ref name="SwitchCaseOperand"/>
    </g:oneOrMore>
    <g:string>return</g:string>
    <g:ref name="ExprSingle"/>
  </g:production>

  <g:production name="SwitchCaseOperand" if="xquery30 xquery31">
    <g:ref name="ExprSingle"/>
  </g:production>

  <g:production name="TypeswitchExpr" if="xcore xquery10 xquery30 xquery31">
    <g:string>typeswitch</g:string>
    <g:string>(</g:string>
    <g:ref name="Expr"/>
    <g:string>)</g:string>
    <g:oneOrMore name="CaseClauseList">
      <g:ref name="CaseClause"/>
    </g:oneOrMore>
    <g:string>default</g:string>
    <g:optional name="DefaultClauseVarBindingOption" if="xquery10 xquery30 xquery31">
      <g:string>$</g:string>
      <g:ref name="VarName"/>
    </g:optional>
    <g:string if="xcore">$</g:string>
    <g:ref name="VarName" if="xcore"/>
    <g:string>return</g:string>
    <g:ref name="ExprSingle"/>
  </g:production>

  <g:production name="CaseClause" if="xcore xquery10 xquery30 xquery31">
    <g:string>case</g:string>
    <g:optional name="CaseClauseVarBindingOption" if="xquery10 xquery30 xquery31">
      <g:string>$</g:string>
      <g:ref name="VarName"/>
      <g:string>as</g:string>
    </g:optional>
    <g:string if="xcore">$</g:string>
    <g:ref name="VarName" if="xcore"/>
    <g:string if="xcore">as</g:string>
    <g:ref name="SequenceType" if="xcore xquery10"/>
    <g:ref name="SequenceTypeUnion" if="xquery30 xquery31"/>
    <g:string>return</g:string>
    <g:ref name="ExprSingle"/>
  </g:production>

  <g:production name="SequenceTypeUnion" if="xquery30 xquery31">
    <g:ref name="SequenceType"/>
    <g:zeroOrMore>
      <g:string>|</g:string>
      <g:ref name="SequenceType"/>
    </g:zeroOrMore>
  </g:production>

  <g:production name="IfExpr" not-if="xpath1">
    <g:string>if</g:string>
    <g:string>(</g:string>
    <g:ref name="Expr"/>
    <g:string>)</g:string>
    <g:string>then</g:string>
    <g:ref name="ExprSingle"/>
    <g:string>else</g:string>
    <g:ref name="ExprSingle"/>
  </g:production>

  <!-- [ start TryCatchExpr -->

<!--
    TryCatchExpr ::= TryClause CatchClause+
    TryClause ::= "try" "{" TargetExpr "}"
    CatchClause ::= "catch" CatchErrorList "{" Expr "}"
    CatchErrorList ::= (NameTest ("|" NameTest)*)
ErrorCode ::= "$" VarName
ErrorDescr ::= "$" VarName
ErrorVal ::= "$" VarName
-->

  <g:production name="TryCatchExpr" if="xquery30 xquery31">
    <g:ref name="TryClause"/>
    <g:oneOrMore>
      <g:ref name="CatchClause" lookahead="5"/>
    </g:oneOrMore>
  </g:production>

  <g:production name="TryClause" if="xquery30 xquery31">
    <g:string>try</g:string>
    <g:ref name="Lbrace" if="xquery30"/>
    <g:ref name="TryTargetExpr" if="xquery30"/>
    <g:ref name="Rbrace" if="xquery30"/>
    <g:ref name="EnclosedTryTargetExpr" if="xquery31"/>
  </g:production>

  <g:production name="TryTargetExpr" if="xquery30">
    <g:ref name="Expr"/>
  </g:production>

  <g:production name="EnclosedTryTargetExpr" if="xquery31">
    <g:ref name="EnclosedExpr"/>
  </g:production>

  <g:production name="CatchClause" if="xquery30 xquery31">
    <g:string>catch</g:string>
    <g:ref name="CatchErrorList"/>
    <g:ref name="Lbrace" if="xquery30"/>
    <g:ref name="Expr" if="xquery30"/>
    <g:ref name="Rbrace" if="xquery30"/>
    <g:ref name="EnclosedExpr" if="xquery31"/>
  </g:production>

  <g:production name="CatchErrorList" if="xquery30 xquery31">
    <g:ref name="NameTest"/>
    <g:zeroOrMore>
      <g:string>|</g:string>
      <g:ref name="NameTest"/>
    </g:zeroOrMore>
  </g:production>

  <!-- ] end TryCatchExpr -->

  <!-- [ start OrExpr etc -->

  <g:exprProduction name="OperatorExpr" node-type="void">
    <g:level>
      <g:binary name="OrExpr" condition="&gt; 1">
        <g:string>or</g:string>
      </g:binary>
    </g:level>
    <g:level>
      <g:binary name="AndExpr" condition="&gt; 1">
        <g:string>and</g:string>
      </g:binary>
    </g:level>
    <g:level if="xpath1">
      <g:binary name="EqualityExpr" prefix-seq-type="*">
        <g:choice>
          <g:string>=</g:string>
          <g:string>!=</g:string>
        </g:choice>
      </g:binary>
    </g:level>
    <g:level if="xpath1">
      <g:binary name="RelationalExpr" prefix-seq-type="*">
        <g:choice>
          <g:ref name="LeftAngleBracket" token-user-action="/* Careful! */ token_source.SwitchTo(DEFAULT); token_source.stateStack.pop(); "/>
          <g:string>&gt;</g:string>
          <g:string>&lt;=</g:string>
          <g:string>&gt;=</g:string>
        </g:choice>
      </g:binary>
    </g:level>
    <g:level>
      <g:binary name="ComparisonExpr" prefix-seq-type="?" if="xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns" condition="&gt; 1">
        <g:choice break="true" name="ValueOrGeneralOrNodeComp">
          <g:ref name="ValueComp"/>
          <g:ref name="GeneralComp"/>
          <g:ref name="NodeComp"/>
        </g:choice>
      </g:binary>
    </g:level>
    <g:level>
      <g:postfix name="FTContainsExpr" prefix-seq-type="?" condition="&gt; 1" if="fulltext">
        <g:sequence name="FTContainsSeq">
          <g:string>contains</g:string>
          <g:string>text</g:string>
          <g:ref name="FTSelection"/>
          <g:optional name="FTContainsOption">
            <g:ref name="FTIgnoreOption"/>
          </g:optional>
        </g:sequence>
      </g:postfix>
    </g:level>
    <g:level if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns">
      <g:binary name="StringConcatExpr" condition="&gt; 1">
        <g:string>||</g:string>
      </g:binary>
    </g:level>
    <g:level>
      <g:binary name="RangeExpr" if="xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns" prefix-seq-type="?" condition="&gt; 1">
        <g:string>to</g:string>
      </g:binary>
    </g:level>
    <g:level>
      <g:binary name="AdditiveExpr" not-if="xcore" condition="&gt; 1">
        <g:choice name="AdditiveOps">
          <g:ref name="Plus"/>
          <g:ref name="Minus"/>
        </g:choice>
      </g:binary>
    </g:level>
    <g:level>
      <g:binary name="MultiplicativeExpr" not-if="xcore" condition="&gt; 1">
        <g:choice name="MultiplicativeOps">
          <g:string>*</g:string>
          <g:string>div</g:string>
          <g:string not-if="xpath1">idiv</g:string>
          <g:string>mod</g:string>
        </g:choice>
      </g:binary>
    </g:level>
    <g:level>
      <g:binary name="UnionExpr" if="xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns" condition="&gt; 1">
        <g:choice name="UnionOps">
          <g:string if="xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns">union</g:string>
          <g:string>|</g:string>
        </g:choice>
      </g:binary>
    </g:level>
    <g:level>
      <g:binary name="IntersectExceptExpr" if="xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns" condition="&gt; 1">
        <g:choice name="IntersectOps">
          <g:string>intersect</g:string>
          <g:string>except</g:string>
        </g:choice>
      </g:binary>
    </g:level>
    <g:level>
      <g:postfix name="InstanceofExpr" if="xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns" prefix-seq-type="?" condition="&gt; 1">
        <g:sequence name="InstanceOfExprOps">
          <g:string>instance</g:string>
          <g:string>of</g:string>
          <g:ref name="SequenceType"/>
        </g:sequence>
      </g:postfix>
    </g:level>
    <g:level>
      <g:postfix name="TreatExpr" if="xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns" prefix-seq-type="?" condition="&gt; 1">
        <g:sequence name="TreatExprOps">
          <g:string>treat</g:string>
          <g:string>as</g:string>
          <g:ref name="SequenceType"/>
        </g:sequence>
      </g:postfix>
    </g:level>
    <g:level>
      <g:postfix name="CastableExpr" not-if="xpath1" prefix-seq-type="?" condition="&gt; 1">
        <g:sequence name="CastableExprOps">
          <g:string>castable</g:string>
          <g:string>as</g:string>
          <g:ref name="SingleType"/>
        </g:sequence>
      </g:postfix>
    </g:level>
    <g:level>
      <g:postfix name="CastExpr" not-if="xpath1" prefix-seq-type="?" condition="&gt; 1">
        <g:sequence name="CastExprOps">
          <g:string>cast</g:string>
          <g:string>as</g:string>
          <g:ref name="SingleType"/>
        </g:sequence>
      </g:postfix>
    </g:level>
    <g:level>
      <g:postfix name="TransformWithExpr" prefix-seq-type="?" condition="&gt; 1" if="update30">
        <g:sequence>
          <g:string>transform</g:string>
          <g:string>with</g:string>
          <g:ref name="Lbrace"/>
          <g:optional>
            <g:ref name="Expr"/>
          </g:optional>
          <g:ref name="Rbrace"/>
        </g:sequence>
      </g:postfix>
    </g:level>
    <g:level>
      <g:postfix name="ArrowExpr" prefix-seq-type="*" condition="&gt; 1" if="xpath31 xquery31">
        <g:sequence>
          <g:string>=&gt;</g:string>
          <g:ref name="ArrowFunctionSpecifier"/>
          <g:ref name="ArgumentList"/>
        </g:sequence>
      </g:postfix>
    </g:level>
    <g:level node-type="UnaryExpr" level-user-action="boolean keepUnary=false;">
      <g:prefix name="UnaryExpr" not-if="xcore" condition="keepUnary" prefix-seq-type="*">
        <g:choice name="UnaryExprOps">
          <g:ref name="Minus" token-user-action="keepUnary=true;"/>
          <g:ref name="Plus" if="xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns" token-user-action="keepUnary=true;"/>
        </g:choice>
      </g:prefix>
    </g:level>
    <g:level if="xpath1">
      <g:binary name="UnionExpr1">
        <g:string>|</g:string>
      </g:binary>
    </g:level>
    <g:level>
      <g:primary name="ValueExpr">
        <g:choice name="ValueExprChoices">
          <g:sequence lookahead="2" if="xpath1">
            <g:ref name="FilterExpr"/>
            <g:optional>
              <g:choice>
                <g:ref name="Slash"/>
                <g:ref name="SlashSlash"/>
              </g:choice>
              <g:ref name="RelativePathExpr"/>
            </g:optional>
          </g:sequence>
          <g:ref name="ValidateExpr" if="xcore xquery10 xquery30 xquery31" lookahead="2"/>
          <g:ref name="PathExpr" not-if="xcore xpath30 xpath31 xquery30 xquery31 xslt30-patterns"/>
          <g:ref name="StepExpr" if="xcore"/>
          <g:ref name="ExtensionExpr" if="xcore xquery10 xquery30 xquery31"/>
          <g:ref name="SimpleMapExpr" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns"/>
        </g:choice>
      </g:primary>
    </g:level>
  </g:exprProduction>

  <g:production name="GeneralComp" if="xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns" is-binary="yes" node-type="void">
    <g:choice break="false" name="GeneralCompOps">
      <g:string>=</g:string>
      <g:string>!=</g:string>
      <!-- This is a parser-context-based lexical state switch, which is
        very dangerous and not reliable if lookahead is past this point.
        The alternatives have been very carefully considered!
      -->
      <g:ref name="LeftAngleBracket" token-user-action="/* Careful! */ token_source.SwitchTo(DEFAULT); token_source.stateStack.pop(); "/>
      <g:string>&lt;=</g:string>
      <g:string>&gt;</g:string>
      <g:string>&gt;=</g:string>
    </g:choice>
  </g:production>

  <g:production name="ValueComp" if="xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns" is-binary="yes" node-type="void">
    <g:choice break="false" name="ValueCompOps">
      <g:string>eq</g:string>
      <g:string>ne</g:string>
      <g:string>lt</g:string>
      <g:string>le</g:string>
      <g:string>gt</g:string>
      <g:string>ge</g:string>
    </g:choice>
  </g:production>

  <g:production name="NodeComp" if="xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns" is-binary="yes" node-type="void">
    <g:choice break="false" name="NodeCompOps">
      <g:string>is</g:string>
      <g:string>&lt;&lt;</g:string>
      <g:string>&gt;&gt;</g:string>
    </g:choice>
  </g:production>

  <g:production name="ValidateExpr" if="xcore xquery10 xquery30 xquery31">
    <g:string>validate</g:string>
    <g:optional>
      <g:choice>
        <g:ref name="ValidationMode"/>
        <g:sequence if="xquery30 xquery31">
          <g:string>type</g:string>
          <g:ref name="TypeName"/>
        </g:sequence>
      </g:choice>
    </g:optional>
    <g:ref name="Lbrace"/>
    <g:ref name="Expr"/>
    <g:ref name="Rbrace"/>
  </g:production>

  <g:production name="ValidationMode" if="xcore xquery10 xquery30 xquery31">
    <g:choice name="VModeChoice">
      <g:string process-value="yes">lax</g:string>
      <g:string process-value="yes">strict</g:string>
    </g:choice>
  </g:production>

  <g:production name="ExtensionExpr" if="xcore xquery10 xquery30 xquery31">
    <g:oneOrMore name="Pragmas">
      <g:ref name="Pragma"/>
    </g:oneOrMore>
    <g:ref name="Lbrace"/>
    <g:optional name="OptionalExtensionExpr">
      <g:ref name="Expr"/>
    </g:optional>
    <g:ref name="Rbrace"/>
  </g:production>

  <g:production name="Pragma" if="fulltext xcore xquery10 xquery30 xquery31" whitespace-spec="explicit">
    <g:ref name="PragmaOpen"/>
    <g:optional name="OptionalWhitespaceBeforeQNameForPragma">
      <g:ref name="S"/>
    </g:optional>
    <g:ref name="_QName_or_EQName" unfold="yes"/>
    <g:optional>
      <g:ref name="S"/>
      <g:ref name="PragmaContents"/>
    </g:optional>
    <g:ref name="PragmaClose"/>
  </g:production>

  <g:production name="PragmaContents" if="fulltext xcore xquery10 xquery30 xquery31">
    <g:zeroOrMore name="PragmaContent" subtract-reg-expr="(Char* '#)' Char*)">
      <g:ref name="Char"/>
    </g:zeroOrMore>
  </g:production>

  <g:production name="SimpleMapExpr" condition="&gt; 1" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns">
    <g:ref name="PathExpr"/>
    <g:zeroOrMore>
      <g:string>!</g:string>
      <g:ref name="PathExpr"/>
    </g:zeroOrMore>
  </g:production>

  <!-- ] end OrExpr etc -->

  <!-- [ start PathExpr -->

  <g:production name="PathExpr" xgc-id="leading-lone-slash" not-if="xcore">
    <g:choice break="true" name="PathExprChoices">
      <g:sequence>
        <g:ref name="Slash"/>
        <!-- tell the parser to shutup with lookahead="(1)" for "/ * /*" vs. "/*/*" -->
        <g:optional name="OptionalRootExprTail" lookahead="1">
          <g:ref name="RelativePathExpr"/>
        </g:optional>
      </g:sequence>
      <g:sequence>
        <g:ref name="SlashSlash"/>
        <g:ref name="RelativePathExpr"/>
      </g:sequence>
      <g:ref name="RelativePathExpr"/>
    </g:choice>
  </g:production>

  <g:production name="RelativePathExpr" not-if="xcore" node-type="void">
    <g:ref name="StepExpr"/>
    <g:zeroOrMore name="RelativePathExprTail">
      <g:choice name="RelativePathExprStepSep">
        <g:ref name="Slash"/>
        <g:ref name="SlashSlash"/>
      </g:choice>
      <g:ref name="StepExpr"/>
    </g:zeroOrMore>
  </g:production>

  <g:production name="StepExpr" node-type="void">
    <g:choice name="AxisOrFilterStep">
      <!-- Need to look ahead 3 here for computed constructors: "element div {baz}" vs "element div baz". -->
      <g:ref name="FilterExpr" if="xpath20 xquery10 xslt2-patterns" lookahead="3"/>
      <g:ref name="PostfixExpr" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns" lookahead="3"/>
      <g:ref name="PrimaryExpr" if="xcore" lookahead="3"/>
      <g:ref name="AxisStep"/>
      <g:ref name="ContextItemExpr" if="xpath1"/>
      <g:ref name="AbbrevReverseStep" if="xpath1"/>
    </g:choice>
  </g:production>

  <g:production name="AxisStep">
    <g:choice name="ForwardOrReverseStep">
      <g:ref name="ReverseStep" lookahead="2"/>
      <g:ref name="ForwardStep"/>
    </g:choice>
    <g:ref name="PredicateList" not-if="xcore"/>
  </g:production>

  <g:production name="ForwardStep" node-type="void">
    <g:choice name="ForwardAxisOrAbbrev">
      <g:sequence lookahead="2">
        <g:ref name="ForwardAxis"/>
        <g:ref name="NodeTest"/>
      </g:sequence>
      <g:ref name="AbbrevForwardStep" not-if="xcore"/>
    </g:choice>
  </g:production>

  <g:production name="ForwardAxis">
    <g:choice break="true" name="ForwardAxisNames">
      <g:sequence>
        <g:string process-value="yes">child</g:string>
        <g:string>::</g:string>
      </g:sequence>
      <g:sequence>
        <g:string process-value="yes">descendant</g:string>
        <g:string>::</g:string>
      </g:sequence>
      <g:sequence>
        <g:string process-value="yes">attribute</g:string>
        <g:string>::</g:string>
      </g:sequence>
      <g:sequence>
        <g:string process-value="yes">self</g:string>
        <g:string>::</g:string>
      </g:sequence>
      <g:sequence>
        <g:string process-value="yes">descendant-or-self</g:string>
        <g:string>::</g:string>
      </g:sequence>
      <g:sequence not-if="xcore">
        <g:string process-value="yes">following-sibling</g:string>
        <g:string>::</g:string>
      </g:sequence>
      <g:sequence not-if="xcore">
        <g:string process-value="yes">following</g:string>
        <g:string>::</g:string>
      </g:sequence>
      <g:sequence if="xcore xpath1 xpath20 xpath30 xpath31 xslt2-patterns xslt30-patterns">
        <g:string process-value="yes">namespace</g:string>
        <g:string>::</g:string>
      </g:sequence>
    </g:choice>
  </g:production>

  <g:production name="AbbrevForwardStep" not-if="xcore">
    <g:optional name="OptionalAtSugar">
      <g:string process-value="yes">@</g:string>
    </g:optional>
    <g:ref name="NodeTest"/>
  </g:production>

  <g:production name="ReverseStep" node-type="void">
    <g:choice name="ReverseAxisOrAbbrev">
      <g:sequence>
        <g:ref name="ReverseAxis"/>
        <g:ref name="NodeTest"/>
      </g:sequence>
      <g:ref name="AbbrevReverseStep" if="xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns"/>
    </g:choice>
  </g:production>

  <g:production name="ReverseAxis">
    <g:choice break="true" name="ReverseAxisNames">
      <g:sequence>
        <g:string process-value="yes">parent</g:string>
        <g:string>::</g:string>
      </g:sequence>
      <g:sequence>
        <g:string process-value="yes">ancestor</g:string>
        <g:string>::</g:string>
      </g:sequence>
      <g:sequence not-if="xcore">
        <g:string process-value="yes">preceding-sibling</g:string>
        <g:string>::</g:string>
      </g:sequence>
      <g:sequence not-if="xcore">
        <g:string process-value="yes">preceding</g:string>
        <g:string>::</g:string>
      </g:sequence>
      <g:sequence>
        <g:string process-value="yes">ancestor-or-self</g:string>
        <g:string>::</g:string>
      </g:sequence>
    </g:choice>
  </g:production>

  <g:production name="AbbrevReverseStep" not-if="xcore">
    <g:string>..</g:string>
  </g:production>

  <g:production name="NodeTest">
    <g:choice name="KindOrNameTest">
      <g:ref name="KindTest" lookahead="2"/>
      <g:ref name="NameTest"/>
    </g:choice>
  </g:production>

  <g:production name="NameTest">
    <g:choice name="QNameOrWildcard">
      <g:ref name="_QName_or_EQName" unfold="yes"/>
      <g:ref name="Wildcard"/>
    </g:choice>
  </g:production>

  <g:production name="Wildcard" whitespace-spec="explicit">
    <g:choice break="true" name="WildcardChoice">
      <g:string process-value="yes">*</g:string>
      <g:ref name="NCNameColonStar" needs-exposition-parens="yes"/>
      <g:ref name="StarColonNCName" not-if="xpath1" needs-exposition-parens="yes"/>
      <g:ref name="URIQualifiedStar" needs-exposition-parens="yes" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns"/>
    </g:choice>
  </g:production>

  <g:production name="FilterExpr" if="xpath1 xpath20 xquery10 xslt2-patterns xslt30-patterns">
    <g:ref name="PrimaryExpr"/>
    <g:ref name="PredicateList"/>
  </g:production>

  <g:production name="PostfixExpr" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns">
    <g:ref name="PrimaryExpr"/>
    <g:zeroOrMore>
      <g:choice>
        <g:ref name="Predicate"/>
        <g:ref name="ArgumentList"/>
        <g:ref name="Lookup" if="xpath31 xquery31"/>
      </g:choice>
    </g:zeroOrMore>
  </g:production>

  <g:production name="ArgumentList" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns">
    <g:string>(</g:string>
    <g:optional>
      <g:ref name="Argument"/>
      <g:zeroOrMore>
        <g:string>,</g:string>
        <g:ref name="Argument"/>
      </g:zeroOrMore>
    </g:optional>
    <g:string>)</g:string>
  </g:production>

  <g:production name="PredicateList" not-if="xcore" condition="&gt; 0">
    <g:zeroOrMore name="PredicatesListX">
      <g:ref name="Predicate"/>
    </g:zeroOrMore>
  </g:production>

  <g:production name="Predicate" not-if="xcore">
    <g:string>[</g:string>
    <g:ref name="Expr" if="xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns"/>
    <g:ref name="ExprSingle" if="xpath1"/>
    <g:string>]</g:string>
  </g:production>

  <g:production name="Lookup" if="xpath31 xquery31">
    <g:string>?</g:string>
    <g:ref name="KeySpecifier"/>
  </g:production>

  <g:production name="KeySpecifier" if="xpath31 xquery31">
    <g:choice>
      <g:ref name="NCName"/>
      <g:ref name="IntegerLiteral"/>
      <g:ref name="ParenthesizedExpr"/>
      <g:string process-value="yes">*</g:string>
    </g:choice>
  </g:production>

  <g:production name="ArrowFunctionSpecifier" if="xpath31 xquery31">
    <g:choice>
      <g:ref name="EQName"/>
      <g:ref name="VarRef"/>
      <g:ref name="ParenthesizedExpr"/>
    </g:choice>
  </g:production>

  <!-- ] end PathExpr -->

  <!-- [ start PrimaryExpr -->

  <g:production name="PrimaryExpr" node-type="void">
    <g:choice name="PrimaryExprChoices" break="true">
      <g:ref name="Literal"/>
      <g:ref name="VarRef"/>
      <g:ref name="ParenthesizedExpr"/>
      <g:ref name="ContextItemExpr" if="xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns"/>
      <g:ref name="FunctionCall" lookahead="2"/>
      <g:ref name="OrderedExpr" if="xcore xquery10 xquery30 xquery31" lookahead="2"/>
      <g:ref name="UnorderedExpr" if="xcore xquery10 xquery30 xquery31" lookahead="2"/>
      <g:ref name="Constructor" if="xcore xquery10 xquery30" lookahead="2"/>
      <g:ref name="NodeConstructor" if="xquery31" lookahead="2"/>
      <g:ref name="FunctionItemExpr" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns"/>
      <g:ref name="MapConstructor" if="xpath31 xquery31"/>
      <g:ref name="ArrayConstructor" if="xpath31 xquery31"/>
      <g:ref name="StringConstructor" if="xquery31"/>
      <g:ref name="UnaryLookup" if="xpath31 xquery31"/>
    </g:choice>
  </g:production>

  <g:production name="Literal" node-type="void">
    <g:choice name="NumericOrStringLit">
      <g:ref name="NumericLiteral"/>
      <g:ref name="StringLiteral"/>
    </g:choice>
  </g:production>

  <g:production name="NumericLiteral" node-type="void">
    <g:choice name="NumericLitChoice">
      <g:ref name="IntegerLiteral"/>
      <g:ref name="DecimalLiteral"/>
      <g:ref name="DoubleLiteral" not-if="xpath1"/>
    </g:choice>
  </g:production>

  <g:production name="VarRef" node-type="void">
    <g:string>$</g:string>
    <g:ref name="VarName"/>
  </g:production>

  <g:production name="VarName">
    <g:ref name="_QName_or_EQName" unfold="yes"/>
  </g:production>

  <g:production name="ParenthesizedExpr">
    <g:string>(</g:string>
    <g:optional name="OptionalExpr" not-if="xpath1">
      <g:ref name="Expr"/>
    </g:optional>
    <g:ref name="ExprSingle" if="xpath1"/>
    <g:string>)</g:string>
  </g:production>

  <g:production name="ContextItemExpr" not-if="xcore">
    <g:string process-value="yes">.</g:string>
  </g:production>

  <g:production name="OrderedExpr" if="xcore xquery10 xquery30 xquery31">
    <g:string>ordered</g:string>
    <g:ref name="Lbrace" not-if="xquery31"/>
    <g:ref name="Expr" not-if="xquery31"/>
    <g:ref name="Rbrace" not-if="xquery31"/>
    <g:ref name="EnclosedExpr" if="xquery31"/>
  </g:production>

  <g:production name="UnorderedExpr" if="xcore xquery10 xquery30 xquery31">
    <g:string>unordered</g:string>
    <g:ref name="Lbrace" not-if="xquery31"/>
    <g:ref name="Expr" not-if="xquery31"/>
    <g:ref name="Rbrace" not-if="xquery31"/>
    <g:ref name="EnclosedExpr" if="xquery31"/>
  </g:production>

  <g:production name="FunctionCall" comment-id="parens" xgc-id="reserved-function-names">
    <g:ref name="_Function_QName_or_EQName" unfold="yes"/>
    <g:choice>
      <g:sequence if="xcore xpath1 xpath20 xquery10 xslt2-patterns">
        <g:string>(</g:string>
        <g:optional name="ArgList">
          <g:ref name="ExprSingle"/>
          <g:zeroOrMore name="ArgListTail">
            <g:string>,</g:string>
            <g:ref name="ExprSingle"/>
          </g:zeroOrMore>
        </g:optional>
        <g:string>)</g:string>
      </g:sequence>
      <g:ref name="ArgumentList" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns"/>
    </g:choice>
  </g:production>

  <g:production name="Argument" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns">
    <g:choice>
      <g:ref name="ExprSingle" if="xpath30 xquery30 xslt30-patterns"/>
      <g:ref name="ExprSingle" lookahead="2" if="xpath31 xquery31"/><!-- because UnaryLookup starts with "?" -->
      <g:ref name="ArgumentPlaceholder"/>
    </g:choice>
  </g:production>

  <g:production name="ArgumentPlaceholder" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns">
    <g:string process-value="yes">?</g:string>
  </g:production>

  <!-- [ start Constructor -->

  <g:production name="Constructor" if="xcore xquery10 xquery30">
    <g:choice break="true" name="ConstructorChoice">
      <g:ref name="DirectConstructor" if="xquery10 xquery30"/>
      <g:ref name="ComputedConstructor"/>
    </g:choice>
  </g:production>

  <g:production name="NodeConstructor" if="xquery31">
    <g:choice break="true">
      <g:ref name="DirectConstructor"/>
      <g:ref name="ComputedConstructor"/>
    </g:choice>
  </g:production>

  <g:production name="DirectConstructor" if="xquery10 xquery30 xquery31">
    <g:choice break="true" name="DirectConstructorChoice">
      <g:ref name="DirElemConstructor"/>
      <g:ref name="DirCommentConstructor"/>
      <g:ref name="DirPIConstructor"/>
    </g:choice>
  </g:production>

  <g:production name="DirElemConstructor" if="xquery10 xquery30 xquery31" whitespace-spec="explicit">
    <g:ref name="LeftAngleBracket"/>
    <g:ref name="TagQName" token-user-action="_elementStack.push(token.image); "/>
    <g:ref name="DirAttributeList"/>
    <g:choice name="TagClose">
      <g:ref name="EmptyTagClose" token-user-action="_elementStack.pop(); "/>
      <g:sequence name="TagContent">
        <g:ref name="StartTagClose"/>
        <g:zeroOrMore name="ElementContentBody">
          <g:ref name="DirElemContent"/>
        </g:zeroOrMore>
        <g:ref name="EndTagOpen" node-type="void"/>
        <g:ref name="EndTagQName"
            token-user-action="if(!token.image.equals(_elementStack.pop())) throw new ParseException(&quot;Error: In a direct element constructor, the name used in the end tag must exactly match the name used in the corresponding start tag, including its prefix or absence of a prefix. Line: &quot; + token.beginLine); "/>
        <g:optional name="OptionalWhitespaceBeforeEndTagClose">
          <g:ref name="S" node-type="void"/>
        </g:optional>
        <g:ref name="EndTagClose" node-type="void"/>
      </g:sequence>
    </g:choice>
  </g:production>

  <g:production name="DirAttributeList" if="xquery10 xquery30 xquery31" whitespace-spec="explicit">
    <g:zeroOrMore name="OptionalAttributeList">
      <g:ref name="S"/>
      <g:optional name="OptionalAttribute">
        <g:ref name="TagQName"/>
        <g:optional name="OptionalWhitespaceBeforeValueIndicator">
          <g:ref name="S"/>
        </g:optional>
        <g:ref name="ValueIndicator"/>
        <g:optional name="OptionalWhitespaceBeforeAttributeValue">
          <g:ref name="S"/>
        </g:optional>
        <g:ref name="DirAttributeValue"/>
      </g:optional>
    </g:zeroOrMore>
  </g:production>

  <g:production name="DirAttributeValue" if="xquery10 xquery30 xquery31" whitespace-spec="explicit">
    <g:choice break="true" name="AttributeValueComponent">
      <g:sequence>
        <g:ref name="OpenQuot"/>
        <g:zeroOrMore name="QuotAttributeValueContents">
          <g:choice name="QuotContentOrEscape">
            <g:ref name="EscapeQuot"/>
            <g:ref name="QuotAttrValueContent"/>
          </g:choice>
        </g:zeroOrMore>
        <g:ref name="CloseQuot"/>
      </g:sequence>
      <g:sequence>
        <g:ref name="OpenApos"/>
        <g:zeroOrMore name="AposAttributeValueContents">
          <g:choice name="AposContentOrEscape">
            <g:ref name="EscapeApos"/>
            <g:ref name="AposAttrValueContent"/>
          </g:choice>
        </g:zeroOrMore>
        <g:ref name="CloseApos"/>
      </g:sequence>
    </g:choice>
  </g:production>

  <g:production name="QuotAttrValueContent" if="xquery10 xquery30 xquery31">
    <g:choice break="true" name="QuotAttrValueComponent">
      <g:ref name="QuotAttrContentChar"/>
      <g:ref name="CommonContent"/>
    </g:choice>
  </g:production>

  <g:production name="AposAttrValueContent" if="xquery10 xquery30 xquery31">
    <g:choice break="true" name="AposAttrValueComponent">
      <g:ref name="AposAttrContentChar"/>
      <g:ref name="CommonContent"/>
    </g:choice>
  </g:production>

  <g:production name="DirElemContent" if="xquery10 xquery30 xquery31">
    <g:choice break="true" name="ElementContentComponents">
      <g:ref name="DirectConstructor"/>
      <g:ref name="CDataSection"/>
      <g:ref name="CommonContent"/>
      <g:ref name="ElementContentChar"/>
    </g:choice>
  </g:production>

  <g:production name="CommonContent" if="xquery10 xquery30 xquery31">
    <g:choice name="CommonContentChoice">
      <g:ref name="PredefinedEntityRef"/>
      <g:ref name="CharRef" token-user-action="checkCharRef(token.image);"/>
      <g:ref name="LCurlyBraceEscape"/>
      <g:ref name="RCurlyBraceEscape"/>
      <g:ref name="EnclosedExpr"/>
    </g:choice>
  </g:production>

  <g:production name="DirCommentConstructor" if="xquery10 xquery30 xquery31" whitespace-spec="explicit">
    <g:ref name="DirCommentStart"/>
    <g:ref name="DirCommentContents"/>
    <g:ref name="DirCommentEnd"/>
  </g:production>

  <g:production name="DirCommentContents" if="xquery10 xquery30 xquery31" whitespace-spec="explicit">
    <g:zeroOrMore name="XmlCommentContents">
      <g:choice name="XmlCommentContentsChar">
        <g:ref name="DirCommentContentChar"/>
        <g:ref name="DirCommentContentDashChar" needs-exposition-parens="yes"/>
      </g:choice>
    </g:zeroOrMore>
  </g:production>

  <g:production name="DirPIConstructor" if="xquery10 xquery30 xquery31" whitespace-spec="explicit">
    <g:ref name="ProcessingInstructionStart"/>
    <g:ref name="PITarget"/>
    <g:optional name="OptionalPIContent">
      <g:ref name="S"/>
      <g:ref name="DirPIContents"/>
    </g:optional>
    <g:ref name="ProcessingInstructionEnd"/>
  </g:production>

  <g:production name="DirPIContents" if="xquery10 xquery30 xquery31" whitespace-spec="explicit">
    <g:zeroOrMore name="XmlPIContentBody" subtract-reg-expr="(Char* '?&gt;' Char*)">
      <g:ref name="Char"/>
    </g:zeroOrMore>
  </g:production>

  <g:production name="CDataSection" if="xquery10 xquery30 xquery31" whitespace-spec="explicit">
    <g:ref name="CdataSectionStart"/>
    <g:ref name="CDataSectionContents"/>
    <g:ref name="CdataSectionEnd"/>
  </g:production>

  <g:production name="CDataSectionContents" if="xquery10 xquery30 xquery31" whitespace-spec="explicit">
    <g:zeroOrMore name="CdataSectionBody" subtract-reg-expr="(Char* ']]&gt;' Char*)">
      <g:ref name="Char"/>
    </g:zeroOrMore>
  </g:production>

  <g:production name="ComputedConstructor" if="xcore xquery10 xquery30 xquery31">
    <g:choice break="true" name="ComputedConstructorChoice">
      <g:ref name="CompDocConstructor"/>
      <g:ref name="CompElemConstructor"/>
      <g:ref name="CompAttrConstructor"/>
      <g:ref name="CompNamespaceConstructor" if="xquery30 xquery31"/>
      <g:ref name="CompTextConstructor"/>
      <g:ref name="CompCommentConstructor"/>
      <g:ref name="CompPIConstructor"/>
    </g:choice>
  </g:production>

  <g:production name="CompDocConstructor" if="xcore xquery10 xquery30 xquery31">
    <g:string>document</g:string>
    <g:ref name="Lbrace" not-if="xquery31"/>
    <g:ref name="Expr" not-if="xquery31"/>
    <g:ref name="Rbrace" not-if="xquery31"/>
    <g:ref name="EnclosedExpr" if="xquery31"/>
  </g:production>

  <g:production name="CompElemConstructor" if="xcore xquery10 xquery30 xquery31">
    <g:string>element</g:string>
    <g:choice name="CompElemConstructorSpec">
      <g:ref name="_QName_or_EQName" unfold="yes"/>
      <g:sequence>
        <g:ref name="Lbrace"/>
        <g:ref name="Expr"/>
        <g:ref name="Rbrace"/>
      </g:sequence>
    </g:choice>
    <g:ref name="Lbrace" if="xcore xquery10 xquery30"/>
    <g:optional if="xquery10 xquery30" name="OptionalContentExpr">
      <g:ref name="ContentExpr"/>
    </g:optional>
    <g:ref if="xcore" name="ContentExpr"/>
    <g:ref name="Rbrace" if="xcore xquery10 xquery30"/>
    <g:ref name="EnclosedContentExpr" if="xquery31"/>
    <g:ref if="xcore" name="Lbrace"/>
    <g:ref if="xcore" name="LocalNamespaceDecls"/>
    <g:ref if="xcore" name="Rbrace"/>
  </g:production>

  <g:production if="xcore" name="LocalNamespaceDecls">
    <g:zeroOrMore>
      <g:ref name="LocalNamespaceDecl"/>
    </g:zeroOrMore>
  </g:production>

  <g:production if="xcore" name="LocalNamespaceDecl">
    <g:string>namespace</g:string>
    <g:ref name="NCName"/>
    <g:ref name="Lbrace"/>
    <g:ref name="URILiteral"/>
    <g:ref name="Rbrace"/>
  </g:production>

  <g:production name="ContentExpr" if="xcore xquery10 xquery30">
    <g:ref name="Expr"/>
  </g:production>

  <g:production name="EnclosedContentExpr" if="xquery31">
    <g:ref name="EnclosedExpr"/>
  </g:production>

  <g:production name="CompAttrConstructor" if="xcore xquery10 xquery30 xquery31">
    <g:string>attribute</g:string>
    <g:choice name="CompAttrConstructorOpening">
      <g:ref name="_QName_or_EQName" unfold="yes"/>
      <g:sequence>
        <g:ref name="Lbrace"/>
        <g:ref name="Expr"/>
        <g:ref name="Rbrace"/>
      </g:sequence>
    </g:choice>
    <g:ref name="Lbrace" if="xcore xquery10 xquery30"/>
    <g:optional if="xquery10 xquery30" name="OptionalCompAttrValExpr">
      <g:ref name="Expr"/>
    </g:optional>
    <g:ref if="xcore" name="Expr"/>
    <g:ref name="Rbrace" if="xcore xquery10 xquery30"/>
    <g:ref name="EnclosedExpr" if="xquery31"/>
  </g:production>

  <g:production name="CompNamespaceConstructor" if="xquery30 xquery31">
    <g:string>namespace</g:string>
    <g:choice name="CompNamespaceConstructorOpening">
      <g:ref name="Prefix"/>
      <g:sequence if="xquery30">
        <g:ref name="Lbrace"/>
        <g:ref name="PrefixExpr"/>
        <g:ref name="Rbrace"/>
      </g:sequence>
      <g:ref name="EnclosedPrefixExpr" if="xquery31"/>
    </g:choice>
    <g:ref name="Lbrace" if="xquery30"/>
    <g:ref name="URIExpr" if="xquery30"/>
    <g:ref name="Rbrace" if="xquery30"/>
    <g:ref name="EnclosedURIExpr" if="xquery31"/>
  </g:production>

  <g:production name="Prefix" if="xquery30 xquery31">
    <g:ref name="NCName"/>
  </g:production>

  <g:production name="PrefixExpr" if="xquery30">
    <g:ref name="Expr"/>
  </g:production>

  <g:production name="EnclosedPrefixExpr" if="xquery31">
    <g:ref name="EnclosedExpr"/>
  </g:production>

  <g:production name="URIExpr" if="xquery30">
    <g:ref name="Expr"/>
  </g:production>

  <g:production name="EnclosedURIExpr" if="xquery31">
    <g:ref name="EnclosedExpr"/>
  </g:production>

  <g:production name="CompTextConstructor" if="xcore xquery10 xquery30 xquery31">
    <g:string>text</g:string>
    <g:ref name="Lbrace" not-if="xquery31"/>
    <g:ref name="Expr" not-if="xquery31"/>
    <g:ref name="Rbrace" not-if="xquery31"/>
    <g:ref name="EnclosedExpr" if="xquery31"/>
  </g:production>

  <g:production name="CompCommentConstructor" if="xcore xquery10 xquery30 xquery31">
    <g:string>comment</g:string>
    <g:ref name="Lbrace" not-if="xquery31"/>
    <g:ref name="Expr" not-if="xquery31"/>
    <g:ref name="Rbrace" not-if="xquery31"/>
    <g:ref name="EnclosedExpr" if="xquery31"/>
  </g:production>

  <g:production name="CompPIConstructor" if="xcore xquery10 xquery30 xquery31">
    <g:string>processing-instruction</g:string>
    <g:choice name="CompXmlPIOpening">
      <g:ref name="NCName"/>
      <g:sequence>
        <g:ref name="Lbrace"/>
        <g:ref name="Expr"/>
        <g:ref name="Rbrace"/>
      </g:sequence>
    </g:choice>
    <g:ref name="Lbrace" not-if="xquery31"/>
    <g:optional name="OptionalCompXmlPIExpr" not-if="xquery31">
      <g:ref name="Expr"/>
    </g:optional>
    <g:ref name="Rbrace" not-if="xquery31"/>
    <g:ref name="EnclosedExpr" if="xquery31"/>
  </g:production>

  <!-- ] end Constructor -->

  <!-- [ start Function Items -->

  <g:production name="FunctionItemExpr" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns">
    <g:choice lookahead="2">
      <g:ref name="NamedFunctionRef"/>
      <g:ref name="InlineFunctionExpr"/>
    </g:choice>
  </g:production>

  <g:production name="NamedFunctionRef" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns" xgc-id="reserved-function-names">
    <g:ref name="_Function_QName_or_EQName" unfold="yes"/>
    <g:string>#</g:string>
    <g:ref name="IntegerLiteral"/>
  </g:production>

  <g:production name="InlineFunctionExpr" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns">
    <g:zeroOrMore if="xquery30 xquery31">
      <g:ref name="Annotation"/>
    </g:zeroOrMore>
    <g:string>function</g:string>
    <g:string>(</g:string>
    <g:optional>
      <g:ref name="ParamList"/>
    </g:optional>
    <g:string>)</g:string>
    <g:optional>
      <g:string>as</g:string>
      <g:ref name="SequenceType"/>
    </g:optional>
    <g:ref name="FunctionBody"/>
  </g:production>

  <!-- ] end Function Items -->

  <g:production name="MapConstructor" if="xpath31 xquery31">
    <g:string>map</g:string>
    <g:ref name="Lbrace"/>
    <g:optional>
      <g:ref name="MapConstructorEntry"/>
      <g:zeroOrMore>
        <g:string>,</g:string>
        <g:ref name="MapConstructorEntry"/>
      </g:zeroOrMore>
    </g:optional>
    <g:ref name="Rbrace"/>
  </g:production>

  <g:production name="MapConstructorEntry" if="xpath31 xquery31">
    <g:ref name="MapKeyExpr"/>
    <g:string>:</g:string>
    <g:ref name="MapValueExpr"/>
  </g:production>

  <g:production name="MapKeyExpr" if="xpath31 xquery31">
    <g:ref name="ExprSingle"/>
  </g:production>

  <g:production name="MapValueExpr" if="xpath31 xquery31">
    <g:ref name="ExprSingle"/>
  </g:production>

  <g:production name="ArrayConstructor" if="xpath31 xquery31">
    <g:choice>
      <g:ref name="SquareArrayConstructor"/>
      <g:ref name="CurlyArrayConstructor"/>
    </g:choice>
  </g:production>

  <g:production name="SquareArrayConstructor" if="xpath31 xquery31">
    <g:string>[</g:string>
    <g:optional>
      <g:ref name="ExprSingle"/>
      <g:zeroOrMore>
        <g:string>,</g:string>
        <g:ref name="ExprSingle"/>
      </g:zeroOrMore>
    </g:optional>
    <g:string>]</g:string>
  </g:production>

  <g:production name="CurlyArrayConstructor" if="xpath31 xquery31">
    <g:string>array</g:string>
    <g:ref name="EnclosedExpr"/>
  </g:production>

  <g:production name="StringConstructor" if="xquery31" whitespace-spec="explicit">
    <g:ref name="StringConstructorStart"/>
    <g:ref name="StringConstructorContent"/>
    <g:ref name="StringConstructorEnd"/>
  </g:production>

  <g:production name="StringConstructorContent" if="xquery31" whitespace-spec="explicit">
    <g:ref name="StringConstructorChars"/>
    <g:zeroOrMore>
      <g:ref name="StringConstructorInterpolation"/>
      <g:ref name="StringConstructorChars"/>
    </g:zeroOrMore>
  </g:production>

  <g:production name="StringConstructorChars" if="xquery31" whitespace-spec="explicit">
    <g:zeroOrMore subtract-reg-expr="(Char* ('`{' | ']``') Char*)">
      <g:ref name="Char"/>
    </g:zeroOrMore>
  </g:production>

  <g:production name="StringConstructorInterpolation" if="xquery31">
    <g:ref name="StringConstructorInterpolationStart"/>
    <g:optional>
      <g:ref name="Expr"/>
    </g:optional>
    <g:ref name="StringConstructorInterpolationEnd"/>
  </g:production>

  <g:production name="UnaryLookup" if="xpath31 xquery31">
    <g:string>?</g:string>
    <g:ref name="KeySpecifier"/>
  </g:production>

  <!-- ] end PrimaryExpr -->

  <!-- [ start Types + Tests -->

  <g:production name="SingleType" not-if="xpath1">
    <g:ref name="AtomicType" not-if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns"/>
    <g:ref name="SimpleTypeName" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns"/>
    <g:optional name="OptionalOccurrenceIndicator">
      <g:string process-value="yes">?</g:string>
    </g:optional>
  </g:production>

  <g:production name="TypeDeclaration" if="xcore xpath30 xpath31 xquery10 xquery30 xquery31 xslt30-patterns">
    <g:string>as</g:string>
    <g:ref name="SequenceType"/>
  </g:production>

  <g:production name="SequenceType" not-if="xpath1">
    <g:choice break="true" name="ItemTypeOrEmpty">
      <g:sequence lookahead="2">
        <g:string process-value="yes">empty-sequence</g:string>
        <g:string>(</g:string>
        <g:string>)</g:string>
      </g:sequence>
      <g:sequence>
        <g:ref name="ItemType"/>
        <g:optional name="OptionalOccurrenceIndicatorForSequenceType" lookahead="1">
          <g:ref name="OccurrenceIndicator"/>
        </g:optional>
      </g:sequence>
    </g:choice>
  </g:production>

  <g:production name="OccurrenceIndicator" xgc-id="occurrence-indicators" not-if="xpath1">
    <g:choice name="OccurrenceIndicatorOps">
      <g:string process-value="yes">?</g:string>
      <g:string process-value="yes">*</g:string>
      <g:ref node-type="void" name="Plus"/>
    </g:choice>
  </g:production>

  <g:production name="ItemType" not-if="xpath1">
    <g:choice break="false" name="ItemTypeChoice">
      <g:ref name="KindTest" lookahead="2"/>
      <g:sequence lookahead="2">
        <g:string process-value="yes">item</g:string>
        <g:string>(</g:string>
        <g:string>)</g:string>
      </g:sequence>
      <g:ref name="FunctionTest" lookahead="2" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns"/>
      <g:ref name="MapTest" lookahead="2" if="xpath31 xquery31"/>
      <g:ref name="ArrayTest" lookahead="2" if="xpath31 xquery31"/>
      <g:ref name="AtomicType" not-if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns"/>
      <g:ref name="AtomicOrUnionType" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns"/>
      <g:ref name="ParenthesizedItemType" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns"/>
    </g:choice>
  </g:production>

  <g:production name="AtomicType" not-if="xpath1 xpath30 xpath31 xquery30 xquery31 xslt30-patterns">
    <g:ref name="_QName_or_EQName" unfold="yes"/>
  </g:production>

  <g:production name="AtomicOrUnionType" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns">
    <g:ref name="_QName_or_EQName" unfold="yes"/>
  </g:production>

  <g:production name="KindTest" node-type="void">
    <g:choice break="true" name="KindTestChoice">
      <g:ref name="DocumentTest" not-if="xpath1"/>
      <g:ref name="ElementTest" not-if="xpath1"/>
      <g:ref name="AttributeTest" not-if="xpath1"/>
      <g:ref name="SchemaElementTest" not-if="xpath1"/>
      <g:ref name="SchemaAttributeTest" not-if="xpath1"/>
      <g:ref name="PITest"/>
      <g:ref name="CommentTest"/>
      <g:ref name="TextTest"/>
      <g:ref name="NamespaceNodeTest" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns"/>
      <g:ref name="AnyKindTest"/>
    </g:choice>
  </g:production>

  <g:production name="AnyKindTest">
    <g:string>node</g:string>
    <g:string>(</g:string>
    <g:string>)</g:string>
  </g:production>

  <g:production name="DocumentTest" not-if="xpath1">
    <g:string>document-node</g:string>
    <g:string>(</g:string>
    <g:optional name="OptionalDocumentTestBody">
      <g:choice name="DocumentTestBodyChoice">
        <g:ref name="ElementTest"/>
        <g:ref name="SchemaElementTest"/>
      </g:choice>
    </g:optional>
    <g:string>)</g:string>
  </g:production>

  <g:production name="TextTest">
    <g:string>text</g:string>
    <g:string>(</g:string>
    <g:string>)</g:string>
  </g:production>

  <g:production name="CommentTest">
    <g:string>comment</g:string>
    <g:string>(</g:string>
    <g:string>)</g:string>
  </g:production>

  <g:production name="NamespaceNodeTest" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns">
    <g:string>namespace-node</g:string>
    <g:string>(</g:string>
    <g:string>)</g:string>
  </g:production>

  <g:production name="PITest">
    <g:string>processing-instruction</g:string>
    <g:string>(</g:string>
    <g:optional name="OptionalPITestBody">
      <g:choice name="NCNameForPIOrStringLit">
        <g:ref name="NCName" not-if="xpath1"/>
        <g:ref name="StringLiteral"/>
      </g:choice>
    </g:optional>
    <g:string>)</g:string>
  </g:production>

  <g:production name="AttributeTest" not-if="xpath1">
    <g:string>attribute</g:string>
    <g:string>(</g:string>
    <g:optional name="OptionalAttributeTestBody">
      <g:ref name="AttribNameOrWildcard"/>
      <g:optional name="AttributeTestBodyOptionalParam">
        <g:string>,</g:string>
        <g:ref name="TypeName"/>
      </g:optional>
    </g:optional>
    <g:string>)</g:string>
  </g:production>

  <g:production name="AttribNameOrWildcard" not-if="xpath1">
    <g:choice name="AttrNameOrWildcardChoice">
      <g:ref name="AttributeName"/>
      <g:string process-value="yes">*</g:string>
    </g:choice>
  </g:production>

  <g:production name="SchemaAttributeTest" not-if="xpath1">
    <g:string>schema-attribute</g:string>
    <g:string>(</g:string>
    <g:ref name="AttributeDeclaration"/>
    <g:string>)</g:string>
  </g:production>

  <g:production name="AttributeDeclaration" not-if="xpath1">
    <g:ref name="AttributeName"/>
  </g:production>

  <g:production name="ElementTest" not-if="xpath1">
    <g:string>element</g:string>
    <g:string>(</g:string>
    <g:optional name="OptionalElementTestBody">
      <g:ref name="ElementNameOrWildcard"/>
      <g:optional name="ElementTestBodyOptionalParam">
        <g:string>,</g:string>
        <g:ref name="TypeName"/>
        <g:optional name="Nillable">
          <g:string process-value="yes">?</g:string>
        </g:optional>
      </g:optional>
    </g:optional>
    <g:string>)</g:string>
  </g:production>

  <g:production name="ElementNameOrWildcard" not-if="xpath1">
    <g:choice name="ElemNameOrWildcardChoice">
      <g:ref name="ElementName"/>
      <g:string process-value="yes">*</g:string>
    </g:choice>
  </g:production>

  <g:production name="SchemaElementTest" not-if="xpath1">
    <g:string>schema-element</g:string>
    <g:string>(</g:string>
    <g:ref name="ElementDeclaration"/>
    <g:string>)</g:string>
  </g:production>

  <g:production name="ElementDeclaration" not-if="xpath1">
    <g:ref name="ElementName"/>
  </g:production>

  <g:production name="AttributeName" not-if="xpath1">
    <g:ref name="_QName_or_EQName" unfold="yes"/>
  </g:production>

  <g:production name="ElementName" not-if="xpath1">
    <g:ref name="_QName_or_EQName" unfold="yes"/>
  </g:production>

  <g:production name="SimpleTypeName" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns">
    <g:ref name="TypeName"/>
  </g:production>

  <g:production name="TypeName" not-if="xpath1">
    <g:ref name="_QName_or_EQName" unfold="yes"/>
  </g:production>

  <g:production name="FunctionTest" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns">
    <g:zeroOrMore if="xquery30 xquery31">
      <g:ref name="Annotation"/>
    </g:zeroOrMore>
    <g:choice break="true" lookahead="4">
      <g:ref name="AnyFunctionTest"/>
      <g:ref name="TypedFunctionTest"/>
    </g:choice>
  </g:production>

  <g:production name="AnyFunctionTest" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns">
    <g:string>function</g:string>
    <g:string>(</g:string>
    <g:string>*</g:string>
    <g:string>)</g:string>
  </g:production>

  <g:production name="TypedFunctionTest" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns">
    <g:string>function</g:string>
    <g:string>(</g:string>
    <g:optional>
      <g:ref name="SequenceType"/>
      <g:zeroOrMore>
        <g:string>,</g:string>
        <g:ref name="SequenceType"/>
      </g:zeroOrMore>
    </g:optional>
    <g:string>)</g:string>
    <g:string>as</g:string>
    <g:ref name="SequenceType"/>
  </g:production>

  <g:production name="MapTest" if="xpath31 xquery31">
    <g:choice>
      <g:ref name="AnyMapTest" lookahead="3"/>
      <g:ref name="TypedMapTest"/>
    </g:choice>
  </g:production>

  <g:production name="AnyMapTest" if="xpath31 xquery31">
    <g:string>map</g:string>
    <g:string>(</g:string>
    <g:string>*</g:string>
    <g:string>)</g:string>
  </g:production>

  <g:production name="TypedMapTest" if="xpath31 xquery31">
    <g:string>map</g:string>
    <g:string>(</g:string>
    <g:ref name="AtomicOrUnionType"/>
    <g:string>,</g:string>
    <g:ref name="SequenceType"/>
    <g:string>)</g:string>
  </g:production>

  <g:production name="ArrayTest" if="xpath31 xquery31">
    <g:choice>
      <g:ref name="AnyArrayTest" lookahead="3"/>
      <g:ref name="TypedArrayTest"/>
    </g:choice>
  </g:production>

  <g:production name="AnyArrayTest" if="xpath31 xquery31">
    <g:string>array</g:string>
    <g:string>(</g:string>
    <g:string>*</g:string>
    <g:string>)</g:string>
  </g:production>

  <g:production name="TypedArrayTest" if="xpath31 xquery31">
    <g:string>array</g:string>
    <g:string>(</g:string>
    <g:ref name="SequenceType"/>
    <g:string>)</g:string>
  </g:production>

  <g:production name="ParenthesizedItemType" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns">
    <g:string>(</g:string>
    <g:ref name="ItemType"/>
    <g:string>)</g:string>
  </g:production>

  <!-- ] end Types + Tests -->

  <g:production name="URILiteral" if="fulltext xcore xquery10 xquery30 xquery31" inline="false">
    <g:ref name="StringLiteral"/>
  </g:production>

  <!-- ===================================================================== -->

  <!-- [ start Full Text -->

  <g:production name="FTSelection" if="fulltext">
    <g:ref name="FTOr"/>
    <g:zeroOrMore name="FTSelectionzeroOrMore">
      <g:ref name="FTPosFilter"/>
    </g:zeroOrMore>
  </g:production>

  <g:production name="FTWeight" if="fulltext">
    <g:string>weight</g:string>
    <g:ref name="Lbrace"/>
    <g:ref name="Expr"/>
    <g:ref name="Rbrace"/>
  </g:production>

  <g:exprProduction name="FTOrExpr" if="fulltext">
    <g:level>
      <g:binary name="FTOr" condition="&gt; 1">
        <g:string>ftor</g:string>
      </g:binary>
    </g:level>
    <g:level>
      <g:binary name="FTAnd" condition="&gt; 1">
        <g:string>ftand</g:string>
      </g:binary>
    </g:level>
    <g:level>
      <g:binary name="FTMildNot" condition="&gt; 1">
        <g:sequence>
          <g:string>not</g:string>
          <g:string>in</g:string>
        </g:sequence>
      </g:binary>
    </g:level>
    <g:level node-type="FTUnaryNot" level-user-action="boolean keepUnary=false;">
      <g:prefix name="FTUnaryNot" prefix-seq-type="?" condition="keepUnary">
        <g:sequence>
          <g:string token-user-action="keepUnary=true;">ftnot</g:string>
        </g:sequence>
      </g:prefix>
    </g:level>
    <g:level>
      <g:primary name="FTPrimaryWithOptions">
        <g:sequence>
          <g:ref name="FTPrimary"/>
          <g:optional name="FTMatchOptionsOpt" lookahead="2">
            <g:ref name="FTMatchOptions"/>
          </g:optional>
          <g:optional name="FTWeightOptional">
            <g:ref name="FTWeight"/>
          </g:optional>
        </g:sequence>
      </g:primary>
    </g:level>
  </g:exprProduction>

  <g:production name="FTPrimary" if="fulltext">
    <g:choice name="FTPrimaryChoice">
      <g:sequence>
        <g:ref name="FTWords"/>
        <g:optional name="FTTimesOption">
          <g:ref name="FTTimes"/>
        </g:optional>
      </g:sequence>
      <g:sequence>
        <g:string>(</g:string>
        <g:ref name="FTSelection"/>
        <g:string>)</g:string>
      </g:sequence>
      <g:ref name="FTExtensionSelection"/>
    </g:choice>
  </g:production>

  <g:production name="FTWords" if="fulltext">
    <g:ref name="FTWordsValue"/>
    <g:optional name="FTWordsOption">
      <g:ref name="FTAnyallOption"/>
    </g:optional>
  </g:production>

  <g:production name="FTWordsValue" if="fulltext">
    <g:choice name="FTWordExpr">
      <g:ref name="StringLiteral"/>
      <g:sequence name="FTEnclosedExpr">
        <g:ref name="Lbrace"/>
        <g:ref name="Expr"/>
        <g:ref name="Rbrace"/>
      </g:sequence>
    </g:choice>
  </g:production>

  <g:production name="FTExtensionSelection" if="fulltext">
    <g:oneOrMore name="FTPragmas">
      <g:ref name="Pragma"/>
    </g:oneOrMore>
    <g:ref name="Lbrace"/>
    <g:optional name="OptionalFTSelection">
      <g:ref name="FTSelection"/>
    </g:optional>
    <g:ref name="Rbrace"/>
  </g:production>

  <g:production name="FTAnyallOption" if="fulltext">
    <g:choice name="FTAnyallOptionChoice" break="false">
      <g:sequence>
        <g:string process-value="yes">any</g:string>
        <g:optional name="FTAnyWordOption">
          <g:string process-value="yes">word</g:string>
        </g:optional>
      </g:sequence>
      <g:sequence>
        <g:string process-value="yes">all</g:string>
        <g:optional name="FTAllWordsOption">
          <g:string process-value="yes">words</g:string>
        </g:optional>
      </g:sequence>
      <g:string process-value="yes">phrase</g:string>
    </g:choice>
  </g:production>

  <g:production name="FTTimes" if="fulltext">
    <g:string>occurs</g:string>
    <g:ref name="FTRange"/>
    <g:string>times</g:string>
  </g:production>

  <g:production name="FTRange" if="fulltext">
    <g:choice name="FTRangeChoice" break="true">
      <g:sequence>
        <g:string process-value="yes">exactly</g:string>
        <g:ref name="AdditiveExpr"/>
      </g:sequence>
      <g:sequence lookahead="2">
        <g:string>at</g:string>
        <g:ref name="Least" node-type="void"/>
        <g:ref name="AdditiveExpr"/>
      </g:sequence>
      <g:sequence lookahead="2">
        <g:string>at</g:string>
        <g:string process-value="yes">most</g:string>
        <g:ref name="AdditiveExpr"/>
      </g:sequence>
      <g:sequence>
        <g:string process-value="yes">from</g:string>
        <g:ref name="AdditiveExpr"/>
        <g:string>to</g:string>
        <g:ref name="AdditiveExpr"/>
      </g:sequence>
    </g:choice>
  </g:production>

  <!-- [ start FT positional filters -->

  <g:production name="FTPosFilter" if="fulltext">
    <g:choice name="FTPosFilterChoice">
      <g:ref name="FTOrder"/>
      <g:ref name="FTWindow"/>
      <g:ref name="FTDistance"/>
      <g:ref name="FTScope"/>
      <g:ref name="FTContent"/>
    </g:choice>
  </g:production>

  <g:production name="FTOrder" if="fulltext">
    <g:string>ordered</g:string>
  </g:production>

  <g:production name="FTWindow" if="fulltext">
    <g:string>window</g:string>
    <g:ref name="AdditiveExpr"/>
    <g:ref name="FTUnit"/>
  </g:production>

  <g:production name="FTDistance" if="fulltext">
    <g:string>distance</g:string>
    <g:ref name="FTRange"/>
    <g:ref name="FTUnit"/>
  </g:production>

  <g:production name="FTUnit" if="fulltext">
    <g:choice name="FTUnitOption">
      <g:string process-value="yes">words</g:string>
      <g:string process-value="yes">sentences</g:string>
      <g:string process-value="yes">paragraphs</g:string>
    </g:choice>
  </g:production>

  <g:production name="FTScope" if="fulltext">
    <g:choice name="FTScopeChoice">
      <g:string process-value="yes">same</g:string>
      <g:string process-value="yes">different</g:string>
    </g:choice>
    <g:ref name="FTBigUnit"/>
  </g:production>

  <g:production name="FTBigUnit" if="fulltext">
    <g:choice name="FTBigUnitOption">
      <g:string process-value="yes">sentence</g:string>
      <g:string process-value="yes">paragraph</g:string>
    </g:choice>
  </g:production>

  <g:production name="FTContent" if="fulltext">
    <g:choice name="FTStartEndEntireChoice" break="false">
      <g:sequence lookahead="2">
        <g:string>at</g:string>
        <g:string process-value="yes">start</g:string>
      </g:sequence>
      <g:sequence lookahead="2">
        <g:string>at</g:string>
        <g:string process-value="yes">end</g:string>
      </g:sequence>
      <g:sequence>
        <g:string process-value="yes">entire</g:string>
        <g:string>content</g:string>
      </g:sequence>
    </g:choice>
  </g:production>

  <!-- ] end FT positional filters -->

  <!-- [ start FTMatchOptions -->

  <g:production name="FTMatchOptions" if="fulltext">
    <!-- lookahead needed to distinguish "case" option from CaseClause -->
    <g:oneOrMore name="FTMatchOptionList" lookahead="2">
      <g:string>using</g:string>
      <g:ref name="FTMatchOption"/>
    </g:oneOrMore>
  </g:production>

  <g:production name="FTMatchOption" if="fulltext">
    <g:choice name="FTMatchOptionChoice" break="true" lookahead="2">
      <g:ref name="FTLanguageOption"/>
      <g:ref name="FTWildCardOption"/>
      <g:ref name="FTThesaurusOption"/>
      <g:ref name="FTStemOption"/>
      <g:ref name="FTCaseOption"/>
      <g:ref name="FTDiacriticsOption"/>
      <g:ref name="FTStopWordOption"/>
      <g:ref name="FTExtensionOption"/>
    </g:choice>
  </g:production>

  <g:production name="FTCaseOption" if="fulltext">
    <g:choice name="FTCaseOptionChoice" break="true">
      <g:sequence lookahead="2">
        <g:string>case</g:string>
        <g:string process-value="yes">insensitive</g:string>
      </g:sequence>
      <g:sequence lookahead="2">
        <g:string>case</g:string>
        <g:string process-value="yes">sensitive</g:string>
      </g:sequence>
      <g:string process-value="yes">lowercase</g:string>
      <g:string process-value="yes">uppercase</g:string>
    </g:choice>
  </g:production>

  <g:production name="FTDiacriticsOption" if="fulltext">
    <g:choice name="FTDiacriticsOptionChoice" break="true">
      <g:sequence lookahead="2">
        <g:string>diacritics</g:string>
        <g:string process-value="yes">insensitive</g:string>
      </g:sequence>
      <g:sequence lookahead="2">
        <g:string>diacritics</g:string>
        <g:string process-value="yes">sensitive</g:string>
      </g:sequence>
    </g:choice>
  </g:production>

  <g:production name="FTStemOption" if="fulltext">
    <g:choice name="FTStemOptionChoice">
      <g:string>stemming</g:string>
      <g:sequence>
        <g:string process-value="yes">no</g:string>
        <g:string>stemming</g:string>
      </g:sequence>
    </g:choice>
  </g:production>

  <g:production name="FTThesaurusOption" if="fulltext">
    <g:choice name="FTThesaurusChoice" break="true">
      <g:sequence name="FTWithThesaurusSeq" lookahead="3">
        <g:string>thesaurus</g:string>
        <g:choice name="FTThesaurusIDChoice">
          <g:ref name="FTThesaurusID"/>
          <g:string process-value="yes">default</g:string>
        </g:choice>
      </g:sequence>
      <g:sequence name="FTWithThesaurusGroupSeq" lookahead="3">
        <g:string>thesaurus</g:string>
        <g:string>(</g:string>
        <g:choice name="FTThesaurusIDChoice2">
          <g:ref name="FTThesaurusID"/>
          <g:string process-value="yes">default</g:string>
        </g:choice>
        <g:zeroOrMore name="FTThesaurusIDZeroOrMore">
          <g:string>,</g:string>
          <g:ref name="FTThesaurusID"/>
        </g:zeroOrMore>
        <g:string>)</g:string>
      </g:sequence>
      <g:sequence>
        <g:string process-value="yes">no</g:string>
        <g:string>thesaurus</g:string>
      </g:sequence>
    </g:choice>
  </g:production>

  <g:production name="FTThesaurusID" if="fulltext">
    <g:string>at</g:string>
    <g:ref name="URILiteral"/>
    <g:optional name="FTRelationshipOption">
      <g:string>relationship</g:string>
      <g:ref name="StringLiteral"/>
    </g:optional>
    <g:optional name="FTRangeOption" lookahead="2">
      <g:ref name="FTLiteralRange"/>
      <g:string>levels</g:string>
    </g:optional>
  </g:production>

  <g:production name="FTLiteralRange" if="fulltext">
    <g:choice break="true">
      <g:sequence>
        <g:string process-value="yes">exactly</g:string>
        <g:ref name="IntegerLiteral"/>
      </g:sequence>
      <g:sequence lookahead="2">
        <g:string>at</g:string>
        <g:ref name="Least" node-type="void"/>
        <g:ref name="IntegerLiteral"/>
      </g:sequence>
      <g:sequence lookahead="2">
        <g:string>at</g:string>
        <g:string process-value="yes">most</g:string>
        <g:ref name="IntegerLiteral"/>
      </g:sequence>
      <g:sequence>
        <g:string process-value="yes">from</g:string>
        <g:ref name="IntegerLiteral"/>
        <g:string>to</g:string>
        <g:ref name="IntegerLiteral"/>
      </g:sequence>
    </g:choice>
  </g:production>

  <g:production name="FTStopWordOption" if="fulltext">
    <g:choice name="FTStopWordOptionChoice" break="true">
      <g:sequence lookahead="3">
        <g:string>stop</g:string>
        <g:string>words</g:string>
        <g:ref name="FTStopWords"/>
        <g:zeroOrMore name="FTStopWordsInclExclZeroOrMore">
          <g:ref name="FTStopWordsInclExcl"/>
        </g:zeroOrMore>
      </g:sequence>
      <g:sequence lookahead="3">
        <g:string>stop</g:string>
        <g:string>words</g:string>
        <g:string process-value="yes">default</g:string>
        <g:zeroOrMore name="FTStopWordsInclExclZeroOrMoreTWO">
          <g:ref name="FTStopWordsInclExcl"/>
        </g:zeroOrMore>
      </g:sequence>
      <g:sequence>
        <g:string process-value="yes">no</g:string>
        <g:string>stop</g:string>
        <g:string>words</g:string>
      </g:sequence>
    </g:choice>
  </g:production>

  <g:production name="FTStopWords" if="fulltext">
    <g:choice name="FTStopWordsChoice" break="true">
      <g:sequence>
        <g:string process-value="yes">at</g:string>
        <g:ref name="URILiteral"/>
      </g:sequence>
      <g:sequence>
        <g:string>(</g:string>
        <g:ref name="StringLiteral"/>
        <g:zeroOrMore name="FTCommaOption">
          <g:string>,</g:string>
          <g:ref name="StringLiteral"/>
        </g:zeroOrMore>
        <g:string>)</g:string>
      </g:sequence>
    </g:choice>
  </g:production>

  <g:production name="FTStopWordsInclExcl" if="fulltext">
    <g:choice name="FTUnionChoice">
      <g:string process-value="yes">union</g:string>
      <g:string process-value="yes">except</g:string>
    </g:choice>
    <g:ref name="FTStopWords"/>
  </g:production>

  <g:production name="FTLanguageOption" if="fulltext">
    <g:string>language</g:string>
    <g:ref name="StringLiteral"/>
  </g:production>

  <g:production name="FTWildCardOption" if="fulltext">
    <g:choice name="FTWildCardOptionChoice" break="false">
      <g:string>wildcards</g:string>
      <g:sequence>
        <g:string process-value="yes">no</g:string>
        <g:string>wildcards</g:string>
      </g:sequence>
    </g:choice>
  </g:production>

  <g:production name="FTExtensionOption" if="fulltext">
    <g:string>option</g:string>
    <g:ref name="_QName_or_EQName" unfold="yes"/>
    <g:ref name="StringLiteral"/>
  </g:production>

  <!-- ] end FTMatchOptions -->

  <g:production name="FTIgnoreOption" if="fulltext">
    <g:string>without</g:string>
    <g:string>content</g:string>
    <g:ref name="UnionExpr"/>
  </g:production>

  <!-- ] end Full Text -->

  <!-- ===================================================================== -->

  <!-- [ start XQuery Update Facility -->

  <g:production name="RevalidationDecl" if="update10 update30" not-if="xpath1 xpath20 xpath30 xpath31 xslt2-patterns xslt30-patterns">
    <g:string>declare</g:string>
    <g:string>revalidation</g:string>
    <g:choice name="RevalidationChoice">
      <g:string process-value="yes">strict</g:string>
      <g:string process-value="yes">lax</g:string>
      <g:string process-value="yes">skip</g:string>
    </g:choice>
  </g:production>

  <g:production name="InsertExprTargetChoice" if="update10 update30">
    <g:choice break="true">
      <g:sequence>
        <g:optional name="InsertExprAsOption">
          <g:string>as</g:string>
          <g:choice name="InsertExprAsChoice">
            <g:string process-value="yes">first</g:string>
            <g:string process-value="yes">last</g:string>
          </g:choice>
        </g:optional>
        <g:string>into</g:string>
      </g:sequence>
      <g:string process-value="yes">after</g:string>
      <g:string process-value="yes">before</g:string>
    </g:choice>
  </g:production>

  <g:production name="InsertExpr" if="update10 update30">
    <g:string>insert</g:string>
    <g:choice>
      <g:string>node</g:string>
      <g:string>nodes</g:string>
    </g:choice>
    <g:ref name="SourceExpr"/>
    <g:ref name="InsertExprTargetChoice"/>
    <g:ref name="TargetExpr"/>
  </g:production>

  <g:production name="DeleteExpr" if="update10 update30">
    <g:string>delete</g:string>
    <g:choice>
      <g:string>node</g:string>
      <g:string>nodes</g:string>
    </g:choice>
    <g:ref name="TargetExpr"/>
  </g:production>

  <g:production name="ReplaceExpr" if="update10 update30">
    <g:string>replace</g:string>
    <g:optional name="ReplaceValueOfOption" lookahead="2">
      <g:string process-value="yes">value</g:string>
      <g:string>of</g:string>
    </g:optional>
    <g:string>node</g:string>
    <g:ref name="TargetExpr"/>
    <g:string>with</g:string>
    <g:ref name="ExprSingle"/>
  </g:production>

  <g:production name="RenameExpr" if="update10 update30">
    <g:string>rename</g:string>
    <g:string>node</g:string>
    <g:ref name="TargetExpr"/>
    <g:string>as</g:string>
    <g:ref name="NewNameExpr"/>
  </g:production>

  <g:production name="SourceExpr" if="update10 update30">
    <g:ref name="ExprSingle"/>
  </g:production>

  <g:production name="TargetExpr" if="update10 update30">
    <g:ref name="ExprSingle"/>
  </g:production>

  <g:production name="NewNameExpr" if="update10 update30">
    <g:ref name="ExprSingle"/>
  </g:production>

  <g:production name="UpdatingFunctionCall" if="update30">
    <g:string>invoke</g:string>
    <g:string>updating</g:string>
    <g:ref name="PrimaryExpr"/>
    <g:string>(</g:string>
    <g:optional>
      <g:ref name="ExprSingle"/>
      <g:zeroOrMore>
        <g:string>,</g:string>
        <g:ref name="ExprSingle"/>
      </g:zeroOrMore>
    </g:optional>
    <g:string>)</g:string>
  </g:production>

  <g:production name="TransformExpr" if="update10">
    <g:string>copy</g:string>
    <g:string>$</g:string>
    <g:ref name="VarName"/>
    <g:string>:=</g:string>
    <g:ref name="ExprSingle"/>
    <g:zeroOrMore name="TransformExprVarDeclsRest">
      <g:string>,</g:string>
      <g:string>$</g:string>
      <g:ref name="VarName"/>
      <g:string>:=</g:string>
      <g:ref name="ExprSingle"/>
    </g:zeroOrMore>
    <g:string>modify</g:string>
    <g:ref name="ExprSingle"/>
    <g:string>return</g:string>
    <g:ref name="ExprSingle"/>
  </g:production>

  <g:production name="CopyModifyExpr" if="update30">
    <g:string>copy</g:string>
    <g:string>$</g:string>
    <g:ref name="VarName"/>
    <g:string>:=</g:string>
    <g:ref name="ExprSingle"/>
    <g:zeroOrMore>
      <g:string>,</g:string>
      <g:string>$</g:string>
      <g:ref name="VarName"/>
      <g:string>:=</g:string>
      <g:ref name="ExprSingle"/>
    </g:zeroOrMore>
    <g:string>modify</g:string>
    <g:ref name="ExprSingle"/>
    <g:string>return</g:string>
    <g:ref name="ExprSingle"/>
  </g:production>

  <!-- ] end XQuery Update Facility -->

  <!-- ===================================================================== -->

  <!-- [ start XQuery Scripting Extension -->

  <g:production name="BlockExpr" if="scripting">
    <g:string>block</g:string>
    <g:ref name="Block"/>
  </g:production>

  <g:production name="Block" if="scripting">
    <g:ref name="Lbrace"/>
    <g:ref name="BlockDecls"/>
    <g:ref name="BlockBody"/>
    <g:ref name="Rbrace"/>
  </g:production>

  <g:production name="BlockDecls" if="scripting">
    <g:zeroOrMore lookahead="2">
      <g:ref name="BlockVarDecl"/>
      <g:string>;</g:string>
    </g:zeroOrMore>
  </g:production>

  <g:production name="BlockVarDecl" if="scripting">
    <g:string>declare</g:string>
    <g:string>$</g:string>
    <g:ref name="VarName"/>
    <g:optional>
      <g:ref name="TypeDeclaration"/>
    </g:optional>
    <g:optional>
      <g:string>:=</g:string>
      <g:ref name="ExprSingle"/>
    </g:optional>
    <g:zeroOrMore>
      <g:string>,</g:string>
      <g:string>$</g:string>
      <g:ref name="VarName"/>
      <g:optional>
        <g:ref name="TypeDeclaration"/>
      </g:optional>
      <g:optional>
        <g:string>:=</g:string>
        <g:ref name="ExprSingle"/>
      </g:optional>
    </g:zeroOrMore>
  </g:production>

  <g:production name="BlockBody" if="scripting">
    <g:ref name="Expr"/>
  </g:production>

  <g:production name="AssignmentExpr" if="scripting">
    <g:string>$</g:string>
    <g:ref name="VarName"/>
    <g:string>:=</g:string>
    <g:ref name="ExprSingle"/>
  </g:production>

  <g:production name="ExitExpr" if="scripting">
    <g:string>exit</g:string>
    <g:string>returning</g:string>
    <g:ref name="ExprSingle"/>
  </g:production>

  <g:production name="WhileExpr" if="scripting">
    <g:string>while</g:string>
    <g:string>(</g:string>
    <g:ref name="ExprSingle"/>
    <g:string>)</g:string>
    <g:ref name="WhileBody"/>
  </g:production>

  <g:production name="WhileBody" if="scripting">
    <g:ref name="Block"/>
  </g:production>

  <!-- ] end XQuery Scripting Extension -->

  <!-- XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX -->

  <!-- [ start quasi-lexical productions with show="no" -->

  <!--
      We don't want this production (_QName_or_EQName) to appear in
      any extracted grammar: it should only be used via unfold="yes".
      (So, its *content* will appear in extracted grammars, but not the
      production itself. The production is like a extraction-time macro.)

      So how do we indicate that a production should not appear in any
      extracted grammar?

      The natural thing would be to mark the production with if="", but
      if we try that, the grammar doesn't validate, because attribute 'if'
      is of type IDREFS, so it must contain a reference to at least one ID.
      But we should be fine as long as we use an ID other than those
      defined by the <g:language> elements at the top. The ID defined
      by this production itself is an easy candidate.

      (Note that while show="no" would prevent the production from being
      rendered in specification EBNF, it wouldn't prevent the production
      from appearing in extracted grammars. So, e.g. it would still appear
      in the javacc input and jjdoc.html.)
  -->
  <g:production name="_QName_or_EQName" if="_QName_or_EQName">
    <g:ref name="QName" if="xcore xpath1 xpath20 xquery10 xslt2-patterns"/>
    <g:ref name="EQName" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns"/>
  </g:production>

  <g:production name="_Function_QName_or_EQName" if="_Function_QName_or_EQName">
    <g:ref name="FunctionQName" if="xcore xpath1 xpath20 xquery10 xslt2-patterns"/>
    <g:ref name="FunctionEQName" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns"/>
  </g:production>

  <g:production name="EQName" node-type="void" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns">
    <g:choice>
      <g:ref name="QName"/>
      <g:ref name="URIQualifiedName"/>
    </g:choice>
  </g:production>

  <g:production name="FunctionEQName" exposition-name="EQName" show="no" node-type="void" whitespace-spec="explicit" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns">
    <g:choice>
      <g:ref name="FunctionQName"/>
      <g:ref name="URIQualifiedName"/>
    </g:choice>
  </g:production>

  <g:production name="NCName" show="no">
    <!-- TODO: For right now, parser has to flag NCName with ":" in it!  -->
    <!-- One would like to structure QName as a multi-part production... however, the problem with this
        is it makes it necessary to make a look-ahead of 4 for many choices... for instance, functionCall:
        foo:baz(). Also whitespace is easier to control if QName is a single token!  -->
    <g:ref name="QName"/>
  </g:production>

  <g:production name="QName" show="no">
    <g:choice name="QNameChoiceList">
      <g:ref name="FunctionQName"/>
      <!-- -->
      <g:string process-value="yes" if="xpath31 xquery31">array</g:string>
      <g:string process-value="yes" not-if="xpath1">attribute</g:string>
      <g:string process-value="yes">comment</g:string>
      <g:string process-value="yes" not-if="xpath1">document-node</g:string>
      <g:string process-value="yes" not-if="xpath1">element</g:string>
      <g:string process-value="yes" not-if="xpath1">empty-sequence</g:string>
      <g:string process-value="yes" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns">function</g:string>
      <g:string process-value="yes" not-if="xpath1">if</g:string>
      <g:string process-value="yes" not-if="xpath1">item</g:string>
      <g:string process-value="yes" if="xpath31 xquery31">map</g:string>
      <g:string process-value="yes" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns">namespace-node</g:string>
      <g:string process-value="yes">node</g:string>
      <g:string process-value="yes">processing-instruction</g:string>
      <g:string process-value="yes" not-if="xpath1">schema-attribute</g:string>
      <g:string process-value="yes" not-if="xpath1">schema-element</g:string>
      <g:string process-value="yes" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns">switch</g:string>
      <g:string process-value="yes">text</g:string>
      <g:string process-value="yes" if="xcore xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt30-patterns">typeswitch</g:string>
      <g:string process-value="yes" if="scripting">while</g:string>
    </g:choice>
  </g:production>

  <g:production name="FunctionQName" exposition-name="QName" show="no">
    <g:choice name="FunctionQNameChoiceList">
      <g:ref name="QNameToken" show="no"/>
      <!-- -->
      <g:ref name="Ascending" node-type="void" if="xcore xquery10 xquery30 xquery31"/>
      <g:ref name="Descending" node-type="void" if="xcore xquery10 xquery30 xquery31"/>
      <g:ref name="External" node-type="void" if="xcore xquery10 xquery30 xquery31"/>
      <g:ref name="Greatest" node-type="void" if="xcore xquery10 xquery30 xquery31"/>
      <g:ref name="Least" node-type="void" if="fulltext xcore xquery10 xquery30 xquery31"/>
      <g:string process-value="yes" if="xquery30 xquery31">NaN</g:string>
      <g:string process-value="yes" if="update10 update30">after</g:string>
      <g:string process-value="yes" if="fulltext">all</g:string>
      <g:string process-value="yes" if="xquery30 xquery31">allowing</g:string>
      <g:string process-value="yes">ancestor</g:string>
      <g:string process-value="yes">ancestor-or-self</g:string>
      <g:string process-value="yes">and</g:string>
      <g:string process-value="yes" if="fulltext">any</g:string>
      <g:string process-value="yes" if="update10 update30 xcore xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns">as</g:string>
      <g:string process-value="yes" if="fulltext xcore xquery10 xquery30 xquery31">at</g:string>
      <g:string process-value="yes" if="xpath1">attribute</g:string>
      <g:string process-value="yes" if="xcore xquery10 xquery30 xquery31">base-uri</g:string>
      <g:string process-value="yes" if="update10 update30">before</g:string>
      <g:string process-value="yes" if="scripting">block</g:string>
      <g:string process-value="yes" if="xquery10 xquery30 xquery31">boundary-space</g:string>
      <g:string process-value="yes" if="xcore xquery10 xquery30 xquery31">by</g:string>
      <g:string process-value="yes" if="fulltext xcore xquery10 xquery30 xquery31">case</g:string>
      <g:string process-value="yes" not-if="xpath1">cast</g:string>
      <g:string process-value="yes" not-if="xpath1">castable</g:string>
      <g:string process-value="yes" if="xquery30 xquery31">catch</g:string>
      <g:string process-value="yes">child</g:string>
      <g:string process-value="yes" if="xcore xquery10 xquery30 xquery31">collation</g:string>
      <g:string process-value="yes" if="xcore xquery10 xquery30 xquery31">construction</g:string>
      <g:string process-value="yes" if="fulltext">contains</g:string>
      <g:string process-value="yes" if="fulltext">content</g:string>
      <g:string process-value="yes" if="xquery30 xquery31">context</g:string>
      <g:string process-value="yes" if="update10 update30">copy</g:string>
      <g:string process-value="yes" if="xcore xquery10 xquery30 xquery31">copy-namespaces</g:string>
      <g:string process-value="yes" if="xquery30 xquery31">count</g:string>
      <g:string process-value="yes" if="xquery30 xquery31">decimal-format</g:string>
      <g:string process-value="yes" if="xquery30 xquery31">decimal-separator</g:string>
      <g:string process-value="yes" if="scripting xcore xquery10 xquery30 xquery31">declare</g:string>
      <g:string process-value="yes" if="fulltext xcore xquery10 xquery30 xquery31">default</g:string>
      <g:string process-value="yes" if="update10 update30">delete</g:string>
      <g:string process-value="yes">descendant</g:string>
      <g:string process-value="yes">descendant-or-self</g:string>
      <g:string process-value="yes" if="fulltext">diacritics</g:string>
      <g:string process-value="yes" if="fulltext">different</g:string>
      <g:string process-value="yes" if="xquery30 xquery31">digit</g:string>
      <g:string process-value="yes" if="fulltext">distance</g:string>
      <g:string process-value="yes" not-if="xcore">div</g:string>
      <g:string process-value="yes" if="xslt30-patterns">doc</g:string>
      <g:string process-value="yes" if="xcore xquery10 xquery30 xquery31">document</g:string>
      <g:string process-value="yes" if="xslt30-patterns">element-with-id</g:string>
      <g:string process-value="yes" not-if="xpath1">else</g:string>
      <g:string process-value="yes" if="xcore xquery10 xquery30 xquery31">empty</g:string>
      <g:string process-value="yes" if="xquery10 xquery30 xquery31">encoding</g:string>
      <g:string process-value="yes" if="fulltext xquery30 xquery31">end</g:string>
      <g:string process-value="yes" if="fulltext">entire</g:string>
      <g:string process-value="yes" if="xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns">eq</g:string>
      <g:string process-value="yes" not-if="xpath1">every</g:string>
      <g:string process-value="yes" if="fulltext">exactly</g:string>
      <g:string process-value="yes" if="fulltext xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns">except</g:string>
      <g:string process-value="yes" if="scripting">exit</g:string>
      <g:string process-value="yes" if="xquery31">exponent-separator</g:string>
      <g:string process-value="yes" if="update10 update30">first</g:string>
      <g:string process-value="yes" not-if="xcore">following</g:string>
      <g:string process-value="yes" not-if="xcore">following-sibling</g:string>
      <g:string process-value="yes" not-if="xpath1">for</g:string>
      <g:string process-value="yes" if="fulltext">from</g:string>
      <g:string process-value="yes" if="fulltext" not-if="xpath1 xpath20 xpath30 xpath31 xslt2-patterns xslt30-patterns">ft-option</g:string>
      <g:string process-value="yes" if="fulltext">ftand</g:string>
      <g:string process-value="yes" if="fulltext">ftnot</g:string>
      <g:string process-value="yes" if="fulltext">ftor</g:string>
      <g:string process-value="yes" if="xcore xquery10">function</g:string>
      <g:string process-value="yes" if="xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns">ge</g:string>
      <g:string process-value="yes" if="xquery30 xquery31">group</g:string>
      <g:string process-value="yes" if="xquery30 xquery31">grouping-separator</g:string>
      <g:string process-value="yes" if="xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns">gt</g:string>
      <g:string process-value="yes" if="xslt2-patterns xslt30-patterns">id</g:string>
      <g:string process-value="yes" if="xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns">idiv</g:string>
      <g:string process-value="yes" if="xcore xquery10 xquery30 xquery31">import</g:string>
      <g:string process-value="yes" if="fulltext xcore xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns">in</g:string>
      <g:string process-value="yes" if="xquery30 xquery31">infinity</g:string>
      <g:string process-value="yes" if="xcore xquery10 xquery30 xquery31">inherit</g:string>
      <g:string process-value="yes" if="fulltext">insensitive</g:string>
      <g:string process-value="yes" if="update10 update30">insert</g:string>
      <g:string process-value="yes" if="xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns">instance</g:string>
      <g:string process-value="yes" if="xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns">intersect</g:string>
      <g:string process-value="yes" if="update10 update30">into</g:string>
      <g:string process-value="yes" if="update30">invoke</g:string>
      <g:string process-value="yes" if="xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns">is</g:string>
      <g:string process-value="yes" if="xslt2-patterns xslt30-patterns">key</g:string>
      <g:string process-value="yes" if="fulltext">language</g:string>
      <g:string process-value="yes" if="update10 update30">last</g:string>
      <g:string process-value="yes" if="xcore xquery10 xquery30 xquery31">lax</g:string>
      <g:string process-value="yes" if="xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns">le</g:string>
      <g:string process-value="yes" if="xcore xpath30 xpath31 xquery10 xquery30 xquery31 xslt30-patterns">let</g:string>
      <g:string process-value="yes" if="fulltext">levels</g:string>
      <g:string process-value="yes" if="fulltext">lowercase</g:string>
      <g:string process-value="yes" if="xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns">lt</g:string>
      <g:string process-value="yes" if="xquery30 xquery31">minus-sign</g:string>
      <g:string process-value="yes" not-if="xcore">mod</g:string>
      <g:string process-value="yes" if="update10 update30">modify</g:string>
      <g:string process-value="yes" if="xcore xquery10 xquery30 xquery31">module</g:string>
      <g:string process-value="yes" if="fulltext">most</g:string>
      <g:string process-value="yes">namespace</g:string>
      <g:string process-value="yes" if="xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns">ne</g:string>
      <g:string process-value="yes" if="xquery30 xquery31">next</g:string>
      <g:string process-value="yes" if="fulltext">no</g:string>
      <g:string process-value="yes" if="xcore xquery10 xquery30 xquery31">no-inherit</g:string>
      <g:string process-value="yes" if="xcore xquery10 xquery30 xquery31">no-preserve</g:string>
      <g:string process-value="yes" if="update10 update30">nodes</g:string>
      <g:string process-value="yes" if="fulltext">not</g:string>
      <g:string process-value="yes" if="fulltext">occurs</g:string>
      <g:string process-value="yes" if="update10 update30 xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns">of</g:string>
      <g:string process-value="yes" if="xquery30 xquery31">only</g:string>
      <g:string process-value="yes" if="fulltext xcore xquery10 xquery30 xquery31">option</g:string>
      <g:string process-value="yes">or</g:string>
      <g:string process-value="yes" if="xcore xquery10 xquery30 xquery31">order</g:string>
      <g:string process-value="yes" if="fulltext xcore xquery10 xquery30 xquery31">ordered</g:string>
      <g:string process-value="yes" if="xcore xquery10 xquery30 xquery31">ordering</g:string>
      <g:string process-value="yes" if="fulltext">paragraph</g:string>
      <g:string process-value="yes" if="fulltext">paragraphs</g:string>
      <g:string process-value="yes">parent</g:string>
      <g:string process-value="yes" if="xquery30 xquery31">pattern-separator</g:string>
      <g:string process-value="yes" if="xquery30 xquery31">per-mille</g:string>
      <g:string process-value="yes" if="xquery30 xquery31">percent</g:string>
      <g:string process-value="yes" if="fulltext">phrase</g:string>
      <g:string process-value="yes" not-if="xcore">preceding</g:string>
      <g:string process-value="yes" not-if="xcore">preceding-sibling</g:string>
      <g:string process-value="yes" if="xcore xquery10 xquery30 xquery31">preserve</g:string>
      <g:string process-value="yes" if="xquery30 xquery31">previous</g:string>
      <g:string process-value="yes" if="fulltext">relationship</g:string>
      <g:string process-value="yes" if="update10 update30">rename</g:string>
      <g:string process-value="yes" if="update10 update30">replace</g:string>
      <g:string process-value="yes" if="update10 update30 xcore xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns">return</g:string>
      <g:string process-value="yes" if="scripting">returning</g:string>
      <g:string process-value="yes" if="update10 update30" not-if="xpath1 xpath20 xpath30 xpath31 xslt2-patterns xslt30-patterns">revalidation</g:string>
      <g:string process-value="yes" if="fulltext">same</g:string>
      <g:string process-value="yes" not-if="xpath1">satisfies</g:string>
      <g:string process-value="yes" if="xcore xquery10 xquery30 xquery31">schema</g:string>
      <g:string process-value="yes" if="fulltext">score</g:string>
      <g:string process-value="yes">self</g:string>
      <g:string process-value="yes" if="fulltext">sensitive</g:string>
      <g:string process-value="yes" if="fulltext">sentence</g:string>
      <g:string process-value="yes" if="fulltext">sentences</g:string>
      <g:string process-value="yes" if="update10 update30" not-if="xpath1 xpath20 xpath30 xpath31 xslt2-patterns xslt30-patterns">skip</g:string>
      <g:string process-value="yes" if="xquery30 xquery31">sliding</g:string>
      <g:string process-value="yes" not-if="xpath1">some</g:string>
      <g:string process-value="yes" if="xcore xquery10 xquery30 xquery31">stable</g:string>
      <g:string process-value="yes" if="fulltext xquery30 xquery31">start</g:string>
      <g:string process-value="yes" if="fulltext">stemming</g:string>
      <g:string process-value="yes" if="fulltext">stop</g:string>
      <g:string process-value="yes" if="xcore xquery10 xquery30 xquery31">strict</g:string>
      <g:string process-value="yes" if="xcore xquery10 xquery30 xquery31">strip</g:string>
      <g:string process-value="yes" not-if="xpath1">then</g:string>
      <g:string process-value="yes" if="fulltext">thesaurus</g:string>
      <g:string process-value="yes" if="fulltext">times</g:string>
      <g:string process-value="yes" if="fulltext xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns">to</g:string>
      <g:string process-value="yes" if="update30">transform</g:string>
      <g:string process-value="yes" if="xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns">treat</g:string>
      <g:string process-value="yes" if="xquery30 xquery31">try</g:string>
      <g:string process-value="yes" if="xquery30 xquery31">tumbling</g:string>
      <g:string process-value="yes" if="xquery30 xquery31">type</g:string>
      <g:string process-value="yes" if="fulltext xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns">union</g:string>
      <g:string process-value="yes" if="xcore xquery10 xquery30 xquery31">unordered</g:string>
      <g:string process-value="yes" if="update10 update30">updating</g:string>
      <g:string process-value="yes" if="fulltext">uppercase</g:string>
      <g:string process-value="yes" if="fulltext">using</g:string>
      <g:string process-value="yes" if="xcore xquery10 xquery30 xquery31">validate</g:string>
      <g:string process-value="yes" if="update10 update30">value</g:string>
      <g:string process-value="yes" if="xcore xquery10 xquery30 xquery31">variable</g:string>
      <g:string process-value="yes" if="xquery10 xquery30 xquery31">version</g:string>
      <g:string process-value="yes" if="fulltext">weight</g:string>
      <g:string process-value="yes" if="xquery30 xquery31">when</g:string>
      <g:string process-value="yes" if="xquery10 xquery30 xquery31">where</g:string>
      <g:string process-value="yes" if="fulltext">wildcards</g:string>
      <g:string process-value="yes" if="fulltext xquery30 xquery31">window</g:string>
      <g:string process-value="yes" if="update10 update30">with</g:string>
      <g:string process-value="yes" if="fulltext">without</g:string>
      <g:string process-value="yes" if="fulltext">word</g:string>
      <g:string process-value="yes" if="fulltext">words</g:string>
      <g:string process-value="yes" if="xquery10 xquery30 xquery31">xquery</g:string>
      <g:string process-value="yes" if="xquery30 xquery31">zero-digit</g:string>
    </g:choice>
  </g:production>

  <!-- ] end quasi-lexical productions with show="no" -->


  <!-- ====================== Lexical Specifications ==================== -->

  <!--
    @subtract-reg-expr
    ~~~~~~~~~~~~~~~~~~

    Several elements in this file have the attribute 'subtract-reg-expr',
    indicating that certain character sequences are excluded from the set
    that the element would otherwise derive.

    When a specification document is built, grammar2spec.xsl handles
    'subtract-reg-expr' by emitting notation of the form "(A - B)".

    However, when javacc.xsl builds a parser (or, more precisely, when
    it creates the input for the JavaCC parser-generator), it ignores
    'subtract-reg-expr'. It has to, because the input language for JavaCC
    doesn't have a good way to express its meaning. But we still need the
    parser to enforce the restriction, so here's how we do that...

    In the simplest set of cases, 'subtract-reg-expr' is used to specify
    (roughly):
        any sequence of characters that doesn't contain
        the terminator for the parent construct
    Specifically:
        PragmaContents       ::= (Char* - (Char* '#)'  Char*))
        DirPIContents        ::= (Char* - (Char* '?>'  Char*))
        CDataSectionContents ::= (Char* - (Char* ']]>' Char*))
    In these cases, the lexical state machine has a state in which it
    recognizes a Char or the terminator. Of course, each character in
    the terminator is also a Char, so an occurrence of the terminator
    in the input could conceivably be recognized as a sequence of Chars.
    What prevents this is that JavaCC's lexer, in any given state,
    will always prefer the longest match. (This is true for many/most
    lexical analyzers.) Since the terminator is multi-character, the
    lexer will always prefer to recognize it over a single-character Char.
    Thus, the lexer will terminate the construct at the first (leftmost)
    occurrence of the terminator, equivalent to ensuring that the construct
    doesn't contain a sequence of characters matching the terminator.

    The case for Comments is a slight variation:
        CommentContents ::= (Char+ - (Char* ('(:' | ':)') Char*))
    Here, the lexical state recognizes 3 things: Char, the comment
    terminator, and the starter for a nested comment. Because the
    latter two are multi-character, the lexer will always recognize
    them as such, rather than as a sequence of Char.

    Similarly for StringConstructorChars:
      StringConstructorChars ::= Char* - (Char* ('`{' | ']``') Char*)

    It starts to get trickier when we consider DirCommentConstructors:
        DirCommentContents ::= ((Char - '-') | ('-' (Char - '-')))*
    Note that here, it's not simply a matter of excluding the 3-character
    terminator (which I can't write here because it would terminate this
    comment!); if it were, it would be handled the same as the above cases.
    Instead, the production excludes even the 2-character prefix of the
    terminator. To handle this, we create an ad-hoc symbol (not visible in
    the published grammar) deriving the disallowed double-dash, and add it
    to the appropriate lexical state. Since it matches 2 characters, the
    lexer will always prefer to recognize it over Char. But since the
    DirCommentContents production isn't expecting it, the parser will always
    raise a syntax error when it occurs. Of course, if the input has a
    double-dash followed by a right-angle-bracket, the lexer will prefer the
    3-character DirComment-terminator over the 2-character DoubleDash token,
    as desired.

    (Note that the DirCommentContents production also disallows any sequence
    of characters ending with a dash. It turns out that the DoubleDash token
    will also be recognized (and thus cause an error) in such cases.)

    The last cases we consider are these:
        ElementContentChar  ::= Char - [{}<&]
        QuotAttrContentChar ::= Char - ["{}<&]
        AposAttrContentChar ::= Char - ['{}<&]
    For these, we could almost use JavaCC's '~' modifier:
        If the character list is prefixed by the "~" symbol,
        the set of characters it represents is any UNICODE
        character not in the specified set.
    However, we want the complement with respect to Char, not all of
    Unicode, which is not the same thing. So we proceed as in the previous
    case, creating ad hoc symbols for the disallowed characters and adding
    them to the appropriate lexical state. (Actually, not for *all* of the
    disallowed characters, as some of them already have valid transitions.
    In practice, we only need to create such symbols for '}', '<', and '&'.)
    However, because they match single-character tokens, we can't rely on
    the lexer's "longest match" rule to prefer them over Char. Instead, we
    rely on the lexer's tie-breaking rule, which is to prefer the symbol
    that was declared earliest in the parser-input. The declaration-order
    in the parser-input is the same as the order of <g:token> elements in
    this file, so we just need to ensure that the <g:token> elements for
    'error' symbols occur before the ones for:
        ElementContentChar, QuotAttrContentChar, and AposAttrContentChar

    (Actually, for the same reason, we also need to ensure that the
    *non*-error single-character symbols recognized in those lexical states
    are declared early.)

    All of which is to explain why the first of the <g:token> elements are
    the ones for error symbols:
  -->

  <g:token name="DirCommentContentDoubleDashError" delimiter-type="hide" if="xcore xquery10 xquery30 xquery31">
    <g:char force-quote="single">-</g:char>
    <g:char force-quote="single">-</g:char>
  </g:token>

  <g:token name="RbraceError" if="xcore xquery10 xquery30 xquery31">
    <g:string>}</g:string>
  </g:token>

  <g:token name="LeftAngleBracketError" if="xquery10 xquery30 xquery31">
    <g:string>&lt;</g:string>
  </g:token>

  <g:token name="AmpersandError" if="xcore xquery10 xquery30 xquery31" show="no">
    <g:string>&amp;</g:string>
  </g:token>

  <!--
    Note that "XML" is disallowed as a PITarget via prose in the XQuery
    specification, not via a 'subtract-reg-expr' attribute in the grammar.
    However, we use the same technique to implement the disallowance:
    create an 'error' symbol, add it to the appropriate lexical state,
    and ensure that it's declared before any symbol that it needs to
    take precedence over (in this case, PITarget).
  -->
  <g:token name="PITargetError" if="xcore xquery10 xquery30 xquery31">
    <g:choice name="PITargetErrorVariations">
      <g:string>XML</g:string>
      <g:string>XMl</g:string>
      <g:string>XmL</g:string>
      <g:string>Xml</g:string>
      <g:string>xML</g:string>
      <g:string>xMl</g:string>
      <g:string>xmL</g:string>
      <g:string>xml</g:string>
    </g:choice>
  </g:token>

  <!--
    The XQuery and XPath specs say that when a numeric literal is followed by a
    keyword with no intervening whitespace/comment, it's a syntax error.
    E.g.: 10div 3
    However, your typical lexer would happily recognize the IntegerLiteral '10'
    immediately followed by the keyword 'div'. Therefore, we need to take extra
    effort to enforce the restriction. That's what this error-symbol
    (NumericLiteralError, abbreviated NLE) is for.

    The production is contructed so that:
    (a) If the input contains an occurrence of the invalid syntax, NLE will
        match one more character than the appropriate numeric literal symbol.
        (E.g., for "10div 3", NLE matches "10d", but IntergerLiteral only "10".)
        So (in such cases), the lexer will always prefer NLE, which the parser
        is never expecting, so it will raise a syntax error, as required.

    (b) If the input does not contain an occurrence of the invalid syntax, NLE
        will either not match at all, or will match fewer characters than the
        appropriate numeric literal symbol.
        (E.g., for "10 div 3", NLE doesn't match at all; for "10e2 div 3", NLE
        matches "10e", but DoubleLiteral matches "10e2".)
        So (in such cases), the lexer will never prefer NLE.

    Since the longest-match rule takes care of things, the declared-earliest
    rule doesn't come into play, so it doesn't matter where we declare NLE, but
    we might as well declare it with the other error-symbols.
  -->
  <g:token name="NumericLiteralError" show="no">
    <g:choice name="DoubleStringNumericLiteralError">
      <g:sequence>
        <g:string>.</g:string>
        <g:ref name="Digits"/>
      </g:sequence>
      <g:sequence>
        <g:ref name="Digits"/>
        <g:optional name="DoubleOptionFractionPartNumericLiteralError">
          <g:string>.</g:string>
          <g:zeroOrMore name="DoubleFractionPartNumericLiteralError">
            <g:charClass>
              <g:charRange minChar="0" maxChar="9"/>
            </g:charClass>
          </g:zeroOrMore>
        </g:optional>
      </g:sequence>
    </g:choice>
    <g:optional name="NumericLiteralErrorOptionalFractionPart">
      <g:charClass>
        <g:char>e</g:char>
        <g:char>E</g:char>
      </g:charClass>
      <g:optional name="DoubleNegOrPosNumericLiteralError">
        <g:charClass>
          <g:char>+</g:char>
          <g:char>-</g:char>
        </g:charClass>
      </g:optional>
      <g:ref name="Digits"/>
    </g:optional>
    <g:charClass>
      <g:charRange minChar="a" maxChar="z"/>
      <g:charRange minChar="A" maxChar="Z"/>
    </g:charClass>
  </g:token>

  <!--
    The following productions define symbols that are expanded
    in-place when they are referenced by the main grammar.
    (This happens because they either are marked with inline="true"
    or don't have an 'inline' attribute.)
    Thus, the productions do not appear as such in the specification document.

    They are arranged roughly in the order of their first reference from the
    main grammar.
  -->

  <g:token name="Slash">
    <g:string>/</g:string>
  </g:token>

  <g:token name="SlashSlash">
    <g:string>//</g:string>
  </g:token>

  <g:token name="Greatest" if="xcore xquery10 xquery30 xquery31">
    <g:string>greatest</g:string>
  </g:token>

  <g:token name="Least" if="fulltext xcore xquery10 xquery30 xquery31">
    <g:string>least</g:string>
  </g:token>

  <g:token name="External" value-type="id" if="xcore xquery10 xquery30 xquery31">
    <g:string>external</g:string>
  </g:token>

  <g:token name="Lbrace" if="fulltext update10 update30 xcore xpath30 xpath31 xquery10 xquery30 xquery31 xslt30-patterns">
    <g:string>{</g:string>
  </g:token>

  <g:token name="Rbrace" if="fulltext xcore xpath30 xpath31 xquery10 xquery30 xquery31 xslt30-patterns">
    <g:string>}</g:string>
  </g:token>

  <g:token name="Ascending" if="xcore xquery10 xquery30 xquery31">
    <g:string>ascending</g:string>
  </g:token>

  <g:token name="Descending" if="xcore xquery10 xquery30 xquery31">
    <g:string>descending</g:string>
  </g:token>

  <g:token name="LeftAngleBracket">
    <g:string>&lt;</g:string>
  </g:token>

  <g:token name="Plus" value-type="id">
    <g:string>+</g:string>
  </g:token>

  <g:token name="Minus" value-type="id">
    <g:string>-</g:string>
  </g:token>

  <g:token name="PragmaOpen" if="fulltext xcore xquery10 xquery30 xquery31">
    <g:string>(#</g:string>
  </g:token>

  <g:token name="PragmaClose" if="fulltext xcore xquery10 xquery30 xquery31">
    <g:string>#)</g:string>
  </g:token>

  <g:token name="URIQualifiedStar" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns" inline="true">
    <g:ref name="BracedURILiteral"/>
    <g:string>*</g:string>
  </g:token>

  <g:token name="NCNameColonStar" value-type="string" inline="true">
    <g:ref name="NCNameTok"/>
    <g:string not-if="xpath31 xquery31">:</g:string>
    <g:string not-if="xpath31 xquery31">*</g:string>
    <g:string if="xpath31 xquery31">:*</g:string>
  </g:token>

  <g:token name="StarColonNCName" value-type="string" not-if="xpath1" inline="true">
    <g:string not-if="xpath31 xquery31">*</g:string>
    <g:string not-if="xpath31 xquery31">:</g:string>
    <g:string if="xpath31 xquery31">*:</g:string>
    <g:ref name="NCNameTok"/>
  </g:token>

  <g:token name="TagQName" if="xquery10 xquery30 xquery31">
    <g:ref name="QNameToken"/>
  </g:token>

  <g:token name="StartTagClose" if="xquery10 xquery30 xquery31">
    <g:string>&gt;</g:string>
  </g:token>

  <g:token name="EmptyTagClose" if="xquery10 xquery30 xquery31">
    <g:string>/&gt;</g:string>
  </g:token>

  <g:token name="EndTagOpen" if="xquery10 xquery30 xquery31">
    <g:string>&lt;/</g:string>
  </g:token>

  <g:token name="EndTagQName" if="xquery10 xquery30 xquery31">
    <g:ref name="QNameToken"/>
  </g:token>

  <g:token name="EndTagClose" if="xquery10 xquery30 xquery31">
    <g:string>&gt;</g:string>
  </g:token>

  <g:token name="ValueIndicator" if="xquery10 xquery30 xquery31">
    <g:string>=</g:string>
  </g:token>

  <g:token name="OpenQuot" delimiter-type="hide" if="xcore xquery10 xquery30 xquery31">
    <g:string>"</g:string>
  </g:token>

  <g:token name="CloseQuot" delimiter-type="hide" if="xcore xquery10 xquery30 xquery31">
    <g:string>"</g:string>
  </g:token>

  <g:token name="OpenApos" delimiter-type="hide" if="xquery10 xquery30 xquery31">
    <g:string>'</g:string>
  </g:token>

  <g:token name="CloseApos" delimiter-type="hide" if="xquery10 xquery30 xquery31">
    <g:string>'</g:string>
  </g:token>

  <g:token name="LCurlyBraceEscape" delimiter-type="hide" if="xquery10 xquery30 xquery31">
    <g:string>{{</g:string>
  </g:token>

  <g:token name="RCurlyBraceEscape" delimiter-type="hide" if="xquery10 xquery30 xquery31">
    <g:string>}}</g:string>
  </g:token>

  <g:token name="DirCommentStart" if="xquery10 xquery30 xquery31">
    <g:string>&lt;!--</g:string>
  </g:token>

  <g:token name="DirCommentEnd" if="xquery10 xquery30 xquery31">
    <g:string>--&gt;</g:string>
  </g:token>

  <g:token name="DirCommentContentChar" delimiter-type="hide" if="xcore xquery10 xquery30 xquery31">
    <g:ref name="Char" subtract-reg-expr="'-'"/>
  </g:token>

  <g:token name="DirCommentContentDashChar" delimiter-type="hide" if="xcore xquery10 xquery30 xquery31">
    <g:char force-quote="single">-</g:char>
    <g:ref name="Char" subtract-reg-expr="'-'"/>
  </g:token>

  <g:token name="ProcessingInstructionStart" if="xcore xquery10 xquery30 xquery31">
    <g:string>&lt;?</g:string>
  </g:token>

  <g:token name="ProcessingInstructionEnd" if="xcore xquery10 xquery30 xquery31">
    <g:string>?&gt;</g:string>
  </g:token>

  <g:token name="CdataSectionStart" if="xcore xquery10 xquery30 xquery31">
    <g:string>&lt;![CDATA[</g:string>
  </g:token>

  <!-- Recognizing it in content disallows ]]> in content same as XML. -->
  <g:token name="CdataSectionEnd" if="xcore xquery10 xquery30 xquery31">
    <g:string>]]&gt;</g:string>
  </g:token>

  <g:token name="StringConstructorStart" if="xquery31">
    <g:string>``[</g:string>
  </g:token>

  <g:token name="StringConstructorEnd" if="xquery31">
    <g:string>]``</g:string>
  </g:token>

  <g:token name="StringConstructorInterpolationStart" if="xquery31">
    <g:string>`{</g:string>
  </g:token>

  <g:token name="StringConstructorInterpolationEnd" if="xquery31">
    <g:string>}`</g:string>
  </g:token>

  <!-- ======================= A.2.1 Terminal Symbols ====================== -->
  <!--
    The following productions appear in A.2.1 Terminal Symbols,
    because they are marked with inline="false".
  -->

  <g:token name="IntegerLiteral" inline="false" value-type="number" delimiter-type="nondelimiting">
    <g:ref name="Digits"/>
  </g:token>

  <g:token name="DecimalLiteral" inline="false" value-type="number" whitespace-spec="explicit" delimiter-type="nondelimiting">
    <g:choice name="DecimalString">
      <g:sequence>
        <g:string>.</g:string>
        <g:ref name="Digits"/>
      </g:sequence>
      <g:sequence>
        <g:ref name="Digits"/>
        <g:string>.</g:string>
        <g:zeroOrMore name="DecimalFractionPart">
          <g:charClass>
            <g:charRange minChar="0" maxChar="9"/>
          </g:charClass>
        </g:zeroOrMore>
      </g:sequence>
    </g:choice>
  </g:token>

  <g:token name="DoubleLiteral" inline="false" delimiter-type="nondelimiting" value-type="number" whitespace-spec="explicit" not-if="xpath1">
    <g:choice name="DoubleString">
      <g:sequence>
        <g:string>.</g:string>
        <g:ref name="Digits"/>
      </g:sequence>
      <g:sequence>
        <g:ref name="Digits"/>
        <g:optional name="DoubleOptionFractionPart">
          <g:string>.</g:string>
          <g:zeroOrMore name="DoubleFractionPart">
            <g:charClass>
              <g:charRange minChar="0" maxChar="9"/>
            </g:charClass>
          </g:zeroOrMore>
        </g:optional>
      </g:sequence>
    </g:choice>
    <g:charClass>
      <g:char>e</g:char>
      <g:char>E</g:char>
    </g:charClass>
    <g:optional name="DoubleNegOrPos">
      <g:charClass>
        <g:char>+</g:char>
        <g:char>-</g:char>
      </g:charClass>
    </g:optional>
    <g:ref name="Digits"/>
  </g:token>

  <g:token name="StringLiteral" inline="false" value-type="string"
      whitespace-spec="explicit" delimiter-type="delimiting">
    <g:choice name="StringDilimitType">
      <g:sequence>
        <g:string>"</g:string>
        <g:zeroOrMore name="CharsInQuote">
          <g:choice name="QuoteTypeChar">
            <g:ref name="PredefinedEntityRef" if="xquery10 xquery30 xquery31"/>
            <g:ref name="CharRef" if="xquery10 xquery30 xquery31" token-user-action="checkCharRef(token.image);"/>
            <g:ref name="EscapeQuot" not-if="xpath1"/>
            <g:complement>
              <g:charClass>
                <g:char>"</g:char>
                <g:char if="xquery10 xquery30 xquery31">&amp;</g:char>
              </g:charClass>
            </g:complement>
          </g:choice>
        </g:zeroOrMore>
        <g:string>"</g:string>
      </g:sequence>
      <g:sequence>
        <g:string>'</g:string>
        <g:zeroOrMore name="CharsInApos">
          <g:choice name="AposTypeChar">
            <g:ref name="PredefinedEntityRef" if="xquery10 xquery30 xquery31"/>
            <g:ref name="CharRef" if="xquery10 xquery30 xquery31" token-user-action="checkCharRef(token.image);"/>
            <g:ref name="EscapeApos" not-if="xpath1"/>
            <g:complement>
              <g:charClass>
                <g:char>'</g:char>
                <g:char if="xquery10 xquery30 xquery31">&amp;</g:char>
              </g:charClass>
            </g:complement>
          </g:choice>
        </g:zeroOrMore>
        <g:string>'</g:string>
      </g:sequence>
    </g:choice>
  </g:token>

  <g:token name="URIQualifiedName" inline="false" whitespace-spec="explicit" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns">
    <g:ref name="BracedURILiteral"/>
    <g:ref name="NCNameTok"/>
  </g:token>

  <g:token name="BracedURILiteral" inline="false" whitespace-spec="explicit" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns">
    <g:string>Q</g:string>
    <g:string>{</g:string>
    <g:zeroOrMore>
      <g:choice>
        <g:ref name="PredefinedEntityRef" if="xquery30 xquery31"/>
        <g:ref name="CharRef" if="xquery30 xquery31" token-user-action="checkCharRef(token.image);"/>
        <g:complement>
          <g:charClass>
            <g:char if="xquery30 xquery31">&amp;</g:char>
            <g:char>{</g:char>
            <g:char>}</g:char>
          </g:charClass>
        </g:complement>
      </g:choice>
    </g:zeroOrMore>
    <g:string>}</g:string>
  </g:token>

  <g:token name="PredefinedEntityRef" if="xquery10 xquery30 xquery31" inline="false" whitespace-spec="explicit" delimiter-type="hide">
    <g:string>&amp;</g:string>
    <g:choice name="PredefinedEntityNames">
      <g:string>lt</g:string>
      <g:string>gt</g:string>
      <g:string>amp</g:string>
      <g:string>quot</g:string>
      <g:string>apos</g:string>
    </g:choice>
    <g:string>;</g:string>
  </g:token>

  <g:token name="EscapeQuot" inline="false" delimiter-type="hide" not-if="xpath1">
    <g:string>""</g:string>
  </g:token>

  <g:token name="EscapeApos" inline="false" delimiter-type="hide" not-if="xpath1">
    <g:string>''</g:string>
  </g:token>

  <g:token name="ElementContentChar" delimiter-type="hide" if="xcore xquery10 xquery30 xquery31" inline="false" value-type="string">
    <g:ref name="Char" subtract-reg-expr="[{}&lt;&amp;]"/>
  </g:token>

  <g:token name="QuotAttrContentChar" delimiter-type="hide" if="xcore xquery10 xquery30 xquery31" inline="false" value-type="string">
    <g:ref name="Char" subtract-reg-expr="[&quot;{}&lt;&amp;]"/>
  </g:token>

  <g:token name="AposAttrContentChar" delimiter-type="hide" if="xcore xquery10 xquery30 xquery31" inline="false" value-type="string">
    <g:ref name="Char" subtract-reg-expr="['{}&lt;&amp;]"/>
  </g:token>

  <g:token name="Comment" if="xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns" inline="false" comment-id="comments" exposition-only="yes" whitespace-spec="explicit" delimiter-type="hide">
    <g:ref name="CommentStart"/>
    <g:zeroOrMore name="OptionalCommentContent">
      <g:choice name="CharOrComment">
        <g:ref name="CommentContents"/>
        <g:ref name="Comment"/>
      </g:choice>
    </g:zeroOrMore>
    <g:ref name="CommentEnd"/>
  </g:token>

  <!--
    In the XQuery spec, 6 symbols:
        PITarget, CharRef, QName, NCName, S, Char
    are defined by reference to productions in other specifications ("XML" or
    "Namespaces in XML"). So, each of the next 6 g:token elements includes
    attributes 'is-xml' and 'xhref' to define that external reference.
    In addition, each also supplies EBNF for the symbol being defined. The
    EBNF isn't rendered in the spec document, but javacc.xsl uses it to
    generate the parser.
  -->

  <g:token name="PITarget" delimiter-type="hide" inline="false" if="xcore xquery10 xquery30 xquery31" value-type="string" is-xml="yes" xhref="http://www.w3.org/TR/REC-xml#NT-PITarget" xgc-id="xml-version">
    <g:ref name="NCNameTok"/>
  </g:token>

  <g:token name="CharRef" if="xquery10 xquery30 xquery31" inline="false" is-xml="yes" xhref="http://www.w3.org/TR/REC-xml#NT-CharRef" xgc-id="xml-version" delimiter-type="hide">
    <g:string>&amp;#</g:string>
    <g:choice name="CharRefChars">
      <g:ref name="Digits"/>
      <g:sequence>
        <g:string>x</g:string>
        <g:ref name="HexDigits"/>
      </g:sequence>
    </g:choice>
    <g:string>;</g:string>
  </g:token>

  <g:token name="QNameToken" exposition-name="QName" delimiter-type="nondelimiting" inline="false" node-type="void" is-xml="yes" xhref="http://www.w3.org/TR/REC-xml-names/#NT-QName" xgc-id="xml-version">
    <g:optional name="QNamePrefixAndDelimiter">
      <g:ref name="NCNameTok"/>
      <g:string>:</g:string>
    </g:optional>
    <g:ref name="LocalPart"/>
  </g:token>

  <g:token name="NCNameTok" exposition-name="NCName" delimiter-type="nondelimiting" inline="false" value-type="string" is-xml="yes" xhref="http://www.w3.org/TR/REC-xml-names/#NT-NCName" xgc-id="xml-version">
    <g:ref name="Nmstart"/>
    <g:zeroOrMore name="NCNameTail">
      <g:ref name="Nmchar"/>
    </g:zeroOrMore>
  </g:token>

  <g:token name="S" inline="false" if="fulltext xcore xquery10 xquery30 xquery31" is-xml="yes" xgc-id="xml-version" xhref="http://www.w3.org/TR/REC-xml#NT-S" delimiter-type="delimiting">
    <g:oneOrMore name="SignificantWhitespace">
      <g:ref name="WhitespaceChar"/>
    </g:oneOrMore>
  </g:token>

  <g:token name="Char" inline="false" delimiter-type="hide" value-type="string" is-xml="yes" xgc-id="xml-version" xhref="http://www.w3.org/TR/REC-xml#NT-Char">
    <g:charClass>
      <g:charCode value="0009"/>
      <g:charCode value="000D"/>
      <g:charCode value="000A"/>
      <!-- This isn't quite right, but JavaCC doesn't understand surrogates. -->
      <g:charCodeRange minValue="0020" maxValue="FFFD"/>
    </g:charClass>
  </g:token>

  <!--
    "The following symbols are used only in the definition of terminal symbols;
    they are not terminal symbols in the grammar of A.1 EBNF."
  -->

  <g:token name="Digits" delimiter-type="hide" inline="false" is-local-to-terminal-symbol="yes">
    <g:oneOrMore name="DigitsString">
      <g:charClass>
        <g:charRange minChar="0" maxChar="9"/>
      </g:charClass>
    </g:oneOrMore>
  </g:token>

  <g:token name="CommentContents" exposition-only="yes" delimiter-type='hide' inline="false" if="xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns" is-local-to-terminal-symbol="yes">
    <g:oneOrMore name="CommentContentBody" subtract-reg-expr="(Char* ('(:' | ':)') Char*)">
      <g:ref name="CommentContent"/>
    </g:oneOrMore>
  </g:token>

  <!-- =================== end of A.2.1 Terminal Symbols =================== -->
  <!--
    The remaining productions are invisible.
    Mostly they define symbols referenced by the 'external reference'
    productions above.
  --> 

  <g:token name="HexDigits" inline="false" if="xquery10 xquery30 xquery31" show="no">
    <g:oneOrMore name="HexDigitsString">
      <g:charClass>
        <g:charRange minChar="0" maxChar="9"/>
        <g:charRange minChar="a" maxChar="f"/>
        <g:charRange minChar="A" maxChar="F"/>
      </g:charClass>
    </g:oneOrMore>
  </g:token>

  <!-- It would be nice to not take character content runs one character
       at a time.  However, it seems difficult to say, "all these characters
       but these three", at least in JavaCC. -->
  <g:token name="WhitespaceChar" inline="false" show="no">
    <g:charClass>
      <!-- NOTE: From XML 1.1: -->
      <!-- To simplify the tasks of applications, the XML processor MUST behave as if it normalized  -->
      <!-- all line breaks in external parsed entities (including the document entity) on input,  -->
      <!-- before parsing, by translating all of the following to a single #xA character: -->
      <!-- 1. the two-character sequence #xD #xA -->
      <!-- 2. the two-character sequence #xD #x85 -->
      <!-- 3. the single character #x85 -->
      <!-- 4. the single character #x2028 -->
      <!-- 5. any #xD character that is not immediately followed by #xA or #x85. -->
      <g:charCode value="0009"/>
      <g:charCode value="000D"/>
      <g:charCode value="000A"/>
      <!-- char xml:space="preserve"> </g:char -->
      <!-- SGML mode in EMacs doesn't like xml:space, so
                             we avoid it for now. -->
      <g:charCode value="0020"/>
    </g:charClass>
  </g:token>

  <g:token name="LocalPart" value-type="string" show="no" is-xml="yes" xhref="http://www.w3.org/TR/REC-xml-names/#NT-LocalPart" xgc-id="xml-version">
    <g:ref name="NCNameTok"/>
  </g:token>

  <g:token name="Nmstart" inline="false" show="no">
    <g:choice name="NmstartChar">
      <g:ref name="Letter"/>
      <g:string>_</g:string>
    </g:choice>
  </g:token>

  <g:token name="Nmchar" inline="false" show="no">
    <g:choice name="NmcharChoice">
      <g:ref name="Letter"/>
      <g:ref name="CombiningChar"/>
      <g:ref name="Extender"/>
      <g:ref name="Digit"/>
      <g:string>.</g:string>
      <g:string>-</g:string>
      <g:string>_</g:string>
    </g:choice>
  </g:token>

  <g:token name="Letter" inline="false" is-macro="yes" is-xml="yes" xhref="http://www.w3.org/TR/REC-xml#NT-Letter" xgc-id="xml-version" show="no">
    <g:choice name="LetterChars">
      <g:ref name="BaseChar"/>
      <g:ref name="Ideographic"/>
    </g:choice>
  </g:token>

  <g:token name="BaseChar" inline="false" is-macro="yes" is-xml="yes" xhref="http://www.w3.org/TR/REC-xml#NT-BaseChar" xgc-id="xml-version" show="no">
    <g:charClass>
      <g:charCodeRange minValue="0041" maxValue="005a"/>
      <g:charCodeRange minValue="0061" maxValue="007a"/>
      <g:charCodeRange minValue="00c0" maxValue="00d6"/>
      <g:charCodeRange minValue="00d8" maxValue="00f6"/>
      <g:charCodeRange minValue="00f8" maxValue="00ff"/>
      <g:charCodeRange minValue="0100" maxValue="0131"/>
      <g:charCodeRange minValue="0134" maxValue="013e"/>
      <g:charCodeRange minValue="0141" maxValue="0148"/>
      <g:charCodeRange minValue="014a" maxValue="017e"/>
      <g:charCodeRange minValue="0180" maxValue="01c3"/>
      <g:charCodeRange minValue="01cd" maxValue="01f0"/>
      <g:charCodeRange minValue="01f4" maxValue="01f5"/>
      <g:charCodeRange minValue="01fa" maxValue="0217"/>
      <g:charCodeRange minValue="0250" maxValue="02a8"/>
      <g:charCodeRange minValue="02bb" maxValue="02c1"/>
      <g:charCode value="0386"/>
      <g:charCodeRange minValue="0388" maxValue="038a"/>
      <g:charCode value="038c"/>
      <g:charCodeRange minValue="038e" maxValue="03a1"/>
      <g:charCodeRange minValue="03a3" maxValue="03ce"/>
      <g:charCodeRange minValue="03d0" maxValue="03d6"/>
      <g:charCode value="03da"/>
      <g:charCode value="03dc"/>
      <g:charCode value="03de"/>
      <g:charCode value="03e0"/>
      <g:charCodeRange minValue="03e2" maxValue="03f3"/>
      <g:charCodeRange minValue="0401" maxValue="040c"/>
      <g:charCodeRange minValue="040e" maxValue="044f"/>
      <g:charCodeRange minValue="0451" maxValue="045c"/>
      <g:charCodeRange minValue="045e" maxValue="0481"/>
      <g:charCodeRange minValue="0490" maxValue="04c4"/>
      <g:charCodeRange minValue="04c7" maxValue="04c8"/>
      <g:charCodeRange minValue="04cb" maxValue="04cc"/>
      <g:charCodeRange minValue="04d0" maxValue="04eb"/>
      <g:charCodeRange minValue="04ee" maxValue="04f5"/>
      <g:charCodeRange minValue="04f8" maxValue="04f9"/>
      <g:charCodeRange minValue="0531" maxValue="0556"/>
      <g:charCode value="0559"/>
      <g:charCodeRange minValue="0561" maxValue="0586"/>
      <g:charCodeRange minValue="05d0" maxValue="05ea"/>
      <g:charCodeRange minValue="05f0" maxValue="05f2"/>
      <g:charCodeRange minValue="0621" maxValue="063a"/>
      <g:charCodeRange minValue="0641" maxValue="064a"/>
      <g:charCodeRange minValue="0671" maxValue="06b7"/>
      <g:charCodeRange minValue="06ba" maxValue="06be"/>
      <g:charCodeRange minValue="06c0" maxValue="06ce"/>
      <g:charCodeRange minValue="06d0" maxValue="06d3"/>
      <g:charCode value="06d5"/>
      <g:charCodeRange minValue="06e5" maxValue="06e6"/>
      <g:charCodeRange minValue="0905" maxValue="0939"/>
      <g:charCode value="093d"/>
      <g:charCodeRange minValue="0958" maxValue="0961"/>
      <g:charCodeRange minValue="0985" maxValue="098c"/>
      <g:charCodeRange minValue="098f" maxValue="0990"/>
      <g:charCodeRange minValue="0993" maxValue="09a8"/>
      <g:charCodeRange minValue="09aa" maxValue="09b0"/>
      <g:charCode value="09b2"/>
      <g:charCodeRange minValue="09b6" maxValue="09b9"/>
      <g:charCodeRange minValue="09dc" maxValue="09dd"/>
      <g:charCodeRange minValue="09df" maxValue="09e1"/>
      <g:charCodeRange minValue="09f0" maxValue="09f1"/>
      <g:charCodeRange minValue="0a05" maxValue="0a0a"/>
      <g:charCodeRange minValue="0a0f" maxValue="0a10"/>
      <g:charCodeRange minValue="0a13" maxValue="0a28"/>
      <g:charCodeRange minValue="0a2a" maxValue="0a30"/>
      <g:charCodeRange minValue="0a32" maxValue="0a33"/>
      <g:charCodeRange minValue="0a35" maxValue="0a36"/>
      <g:charCodeRange minValue="0a38" maxValue="0a39"/>
      <g:charCodeRange minValue="0a59" maxValue="0a5c"/>
      <g:charCode value="0a5e"/>
      <g:charCodeRange minValue="0a72" maxValue="0a74"/>
      <g:charCodeRange minValue="0a85" maxValue="0a8b"/>
      <g:charCode value="0a8d"/>
      <g:charCodeRange minValue="0a8f" maxValue="0a91"/>
      <g:charCodeRange minValue="0a93" maxValue="0aa8"/>
      <g:charCodeRange minValue="0aaa" maxValue="0ab0"/>
      <g:charCodeRange minValue="0ab2" maxValue="0ab3"/>
      <g:charCodeRange minValue="0ab5" maxValue="0ab9"/>
      <g:charCode value="0abd"/>
      <g:charCode value="0ae0"/>
      <g:charCodeRange minValue="0b05" maxValue="0b0c"/>
      <g:charCodeRange minValue="0b0f" maxValue="0b10"/>
      <g:charCodeRange minValue="0b13" maxValue="0b28"/>
      <g:charCodeRange minValue="0b2a" maxValue="0b30"/>
      <g:charCodeRange minValue="0b32" maxValue="0b33"/>
      <g:charCodeRange minValue="0b36" maxValue="0b39"/>
      <g:charCode value="0b3d"/>
      <g:charCodeRange minValue="0b5c" maxValue="0b5d"/>
      <g:charCodeRange minValue="0b5f" maxValue="0b61"/>
      <g:charCodeRange minValue="0b85" maxValue="0b8a"/>
      <g:charCodeRange minValue="0b8e" maxValue="0b90"/>
      <g:charCodeRange minValue="0b92" maxValue="0b95"/>
      <g:charCodeRange minValue="0b99" maxValue="0b9a"/>
      <g:charCode value="0b9c"/>
      <g:charCodeRange minValue="0b9e" maxValue="0b9f"/>
      <g:charCodeRange minValue="0ba3" maxValue="0ba4"/>
      <g:charCodeRange minValue="0ba8" maxValue="0baa"/>
      <g:charCodeRange minValue="0bae" maxValue="0bb5"/>
      <g:charCodeRange minValue="0bb7" maxValue="0bb9"/>
      <g:charCodeRange minValue="0c05" maxValue="0c0c"/>
      <g:charCodeRange minValue="0c0e" maxValue="0c10"/>
      <g:charCodeRange minValue="0c12" maxValue="0c28"/>
      <g:charCodeRange minValue="0c2a" maxValue="0c33"/>
      <g:charCodeRange minValue="0c35" maxValue="0c39"/>
      <g:charCodeRange minValue="0c60" maxValue="0c61"/>
      <g:charCodeRange minValue="0c85" maxValue="0c8c"/>
      <g:charCodeRange minValue="0c8e" maxValue="0c90"/>
      <g:charCodeRange minValue="0c92" maxValue="0ca8"/>
      <g:charCodeRange minValue="0caa" maxValue="0cb3"/>
      <g:charCodeRange minValue="0cb5" maxValue="0cb9"/>
      <g:charCode value="0cde"/>
      <g:charCodeRange minValue="0ce0" maxValue="0ce1"/>
      <g:charCodeRange minValue="0d05" maxValue="0d0c"/>
      <g:charCodeRange minValue="0d0e" maxValue="0d10"/>
      <g:charCodeRange minValue="0d12" maxValue="0d28"/>
      <g:charCodeRange minValue="0d2a" maxValue="0d39"/>
      <g:charCodeRange minValue="0d60" maxValue="0d61"/>
      <g:charCodeRange minValue="0e01" maxValue="0e2e"/>
      <g:charCode value="0e30"/>
      <g:charCodeRange minValue="0e32" maxValue="0e33"/>
      <g:charCodeRange minValue="0e40" maxValue="0e45"/>
      <g:charCodeRange minValue="0e81" maxValue="0e82"/>
      <g:charCode value="0e84"/>
      <g:charCodeRange minValue="0e87" maxValue="0e88"/>
      <g:charCode value="0e8a"/>
      <g:charCode value="0e8d"/>
      <g:charCodeRange minValue="0e94" maxValue="0e97"/>
      <g:charCodeRange minValue="0e99" maxValue="0e9f"/>
      <g:charCodeRange minValue="0ea1" maxValue="0ea3"/>
      <g:charCode value="0ea5"/>
      <g:charCode value="0ea7"/>
      <g:charCodeRange minValue="0eaa" maxValue="0eab"/>
      <g:charCodeRange minValue="0ead" maxValue="0eae"/>
      <g:charCode value="0eb0"/>
      <g:charCodeRange minValue="0eb2" maxValue="0eb3"/>
      <g:charCode value="0ebd"/>
      <g:charCodeRange minValue="0ec0" maxValue="0ec4"/>
      <g:charCodeRange minValue="0f40" maxValue="0f47"/>
      <g:charCodeRange minValue="0f49" maxValue="0f69"/>
      <g:charCodeRange minValue="10a0" maxValue="10c5"/>
      <g:charCodeRange minValue="10d0" maxValue="10f6"/>
      <g:charCode value="1100"/>
      <g:charCodeRange minValue="1102" maxValue="1103"/>
      <g:charCodeRange minValue="1105" maxValue="1107"/>
      <g:charCode value="1109"/>
      <g:charCodeRange minValue="110b" maxValue="110c"/>
      <g:charCodeRange minValue="110e" maxValue="1112"/>
      <g:charCode value="113c"/>
      <g:charCode value="113e"/>
      <g:charCode value="1140"/>
      <g:charCode value="114c"/>
      <g:charCode value="114e"/>
      <g:charCode value="1150"/>
      <g:charCodeRange minValue="1154" maxValue="1155"/>
      <g:charCode value="1159"/>
      <g:charCodeRange minValue="115f" maxValue="1161"/>
      <g:charCode value="1163"/>
      <g:charCode value="1165"/>
      <g:charCode value="1167"/>
      <g:charCode value="1169"/>
      <g:charCodeRange minValue="116d" maxValue="116e"/>
      <g:charCodeRange minValue="1172" maxValue="1173"/>
      <g:charCode value="1175"/>
      <g:charCode value="119e"/>
      <g:charCode value="11a8"/>
      <g:charCode value="11ab"/>
      <g:charCodeRange minValue="11ae" maxValue="11af"/>
      <g:charCodeRange minValue="11b7" maxValue="11b8"/>
      <g:charCode value="11ba"/>
      <g:charCodeRange minValue="11bc" maxValue="11c2"/>
      <g:charCode value="11eb"/>
      <g:charCode value="11f0"/>
      <g:charCode value="11f9"/>
      <g:charCodeRange minValue="1e00" maxValue="1e9b"/>
      <g:charCodeRange minValue="1ea0" maxValue="1ef9"/>
      <g:charCodeRange minValue="1f00" maxValue="1f15"/>
      <g:charCodeRange minValue="1f18" maxValue="1f1d"/>
      <g:charCodeRange minValue="1f20" maxValue="1f45"/>
      <g:charCodeRange minValue="1f48" maxValue="1f4d"/>
      <g:charCodeRange minValue="1f50" maxValue="1f57"/>
      <g:charCode value="1f59"/>
      <g:charCode value="1f5b"/>
      <g:charCode value="1f5d"/>
      <g:charCodeRange minValue="1f5f" maxValue="1f7d"/>
      <g:charCodeRange minValue="1f80" maxValue="1fb4"/>
      <g:charCodeRange minValue="1fb6" maxValue="1fbc"/>
      <g:charCode value="1fbe"/>
      <g:charCodeRange minValue="1fc2" maxValue="1fc4"/>
      <g:charCodeRange minValue="1fc6" maxValue="1fcc"/>
      <g:charCodeRange minValue="1fd0" maxValue="1fd3"/>
      <g:charCodeRange minValue="1fd6" maxValue="1fdb"/>
      <g:charCodeRange minValue="1fe0" maxValue="1fec"/>
      <g:charCodeRange minValue="1ff2" maxValue="1ff4"/>
      <g:charCodeRange minValue="1ff6" maxValue="1ffc"/>
      <g:charCode value="2126"/>
      <g:charCodeRange minValue="212a" maxValue="212b"/>
      <g:charCode value="212e"/>
      <g:charCodeRange minValue="2180" maxValue="2182"/>
      <g:charCodeRange minValue="3041" maxValue="3094"/>
      <g:charCodeRange minValue="30a1" maxValue="30fa"/>
      <g:charCodeRange minValue="3105" maxValue="312c"/>
      <g:charCodeRange minValue="ac00" maxValue="d7a3"/>
    </g:charClass>
  </g:token>

  <g:token name="Ideographic" inline="false" is-macro="yes" is-xml="yes" xhref="http://www.w3.org/TR/REC-xml#NT-Ideographic" xgc-id="xml-version" show="no">
    <g:charClass>
      <g:charCodeRange minValue="4e00" maxValue="9fa5"/>
      <g:charCode value="3007"/>
      <g:charCodeRange minValue="3021" maxValue="3029"/>
    </g:charClass>
  </g:token>

  <g:token name="CombiningChar" inline="false" is-macro="yes" is-xml="yes" xhref="http://www.w3.org/TR/REC-xml#NT-CombiningChar" xgc-id="xml-version" show="no">
    <g:charClass>
      <g:charCodeRange minValue="0300" maxValue="0345"/>
      <g:charCodeRange minValue="0360" maxValue="0361"/>
      <g:charCodeRange minValue="0483" maxValue="0486"/>
      <g:charCodeRange minValue="0591" maxValue="05a1"/>
      <g:charCodeRange minValue="05a3" maxValue="05b9"/>
      <g:charCodeRange minValue="05bb" maxValue="05bd"/>
      <g:charCode value="05bf"/>
      <g:charCodeRange minValue="05c1" maxValue="05c2"/>
      <g:charCode value="05c4"/>
      <g:charCodeRange minValue="064b" maxValue="0652"/>
      <g:charCode value="0670"/>
      <g:charCodeRange minValue="06d6" maxValue="06dc"/>
      <g:charCodeRange minValue="06dd" maxValue="06df"/>
      <g:charCodeRange minValue="06e0" maxValue="06e4"/>
      <g:charCodeRange minValue="06e7" maxValue="06e8"/>
      <g:charCodeRange minValue="06ea" maxValue="06ed"/>
      <g:charCodeRange minValue="0901" maxValue="0903"/>
      <g:charCode value="093c"/>
      <g:charCodeRange minValue="093e" maxValue="094c"/>
      <g:charCode value="094d"/>
      <g:charCodeRange minValue="0951" maxValue="0954"/>
      <g:charCodeRange minValue="0962" maxValue="0963"/>
      <g:charCodeRange minValue="0981" maxValue="0983"/>
      <g:charCode value="09bc"/>
      <g:charCode value="09be"/>
      <g:charCode value="09bf"/>
      <g:charCodeRange minValue="09c0" maxValue="09c4"/>
      <g:charCodeRange minValue="09c7" maxValue="09c8"/>
      <g:charCodeRange minValue="09cb" maxValue="09cd"/>
      <g:charCode value="09d7"/>
      <g:charCodeRange minValue="09e2" maxValue="09e3"/>
      <g:charCode value="0a02"/>
      <g:charCode value="0a3c"/>
      <g:charCode value="0a3e"/>
      <g:charCode value="0a3f"/>
      <g:charCodeRange minValue="0a40" maxValue="0a42"/>
      <g:charCodeRange minValue="0a47" maxValue="0a48"/>
      <g:charCodeRange minValue="0a4b" maxValue="0a4d"/>
      <g:charCodeRange minValue="0a70" maxValue="0a71"/>
      <g:charCodeRange minValue="0a81" maxValue="0a83"/>
      <g:charCode value="0abc"/>
      <g:charCodeRange minValue="0abe" maxValue="0ac5"/>
      <g:charCodeRange minValue="0ac7" maxValue="0ac9"/>
      <g:charCodeRange minValue="0acb" maxValue="0acd"/>
      <g:charCodeRange minValue="0b01" maxValue="0b03"/>
      <g:charCode value="0b3c"/>
      <g:charCodeRange minValue="0b3e" maxValue="0b43"/>
      <g:charCodeRange minValue="0b47" maxValue="0b48"/>
      <g:charCodeRange minValue="0b4b" maxValue="0b4d"/>
      <g:charCodeRange minValue="0b56" maxValue="0b57"/>
      <g:charCodeRange minValue="0b82" maxValue="0b83"/>
      <g:charCodeRange minValue="0bbe" maxValue="0bc2"/>
      <g:charCodeRange minValue="0bc6" maxValue="0bc8"/>
      <g:charCodeRange minValue="0bca" maxValue="0bcd"/>
      <g:charCode value="0bd7"/>
      <g:charCodeRange minValue="0c01" maxValue="0c03"/>
      <g:charCodeRange minValue="0c3e" maxValue="0c44"/>
      <g:charCodeRange minValue="0c46" maxValue="0c48"/>
      <g:charCodeRange minValue="0c4a" maxValue="0c4d"/>
      <g:charCodeRange minValue="0c55" maxValue="0c56"/>
      <g:charCodeRange minValue="0c82" maxValue="0c83"/>
      <g:charCodeRange minValue="0cbe" maxValue="0cc4"/>
      <g:charCodeRange minValue="0cc6" maxValue="0cc8"/>
      <g:charCodeRange minValue="0cca" maxValue="0ccd"/>
      <g:charCodeRange minValue="0cd5" maxValue="0cd6"/>
      <g:charCodeRange minValue="0d02" maxValue="0d03"/>
      <g:charCodeRange minValue="0d3e" maxValue="0d43"/>
      <g:charCodeRange minValue="0d46" maxValue="0d48"/>
      <g:charCodeRange minValue="0d4a" maxValue="0d4d"/>
      <g:charCode value="0d57"/>
      <g:charCode value="0e31"/>
      <g:charCodeRange minValue="0e34" maxValue="0e3a"/>
      <g:charCodeRange minValue="0e47" maxValue="0e4e"/>
      <g:charCode value="0eb1"/>
      <g:charCodeRange minValue="0eb4" maxValue="0eb9"/>
      <g:charCodeRange minValue="0ebb" maxValue="0ebc"/>
      <g:charCodeRange minValue="0ec8" maxValue="0ecd"/>
      <g:charCodeRange minValue="0f18" maxValue="0f19"/>
      <g:charCode value="0f35"/>
      <g:charCode value="0f37"/>
      <g:charCode value="0f39"/>
      <g:charCode value="0f3e"/>
      <g:charCode value="0f3f"/>
      <g:charCodeRange minValue="0f71" maxValue="0f84"/>
      <g:charCodeRange minValue="0f86" maxValue="0f8b"/>
      <g:charCodeRange minValue="0f90" maxValue="0f95"/>
      <g:charCode value="0f97"/>
      <g:charCodeRange minValue="0f99" maxValue="0fad"/>
      <g:charCodeRange minValue="0fb1" maxValue="0fb7"/>
      <g:charCode value="0fb9"/>
      <g:charCodeRange minValue="20d0" maxValue="20dc"/>
      <g:charCode value="20e1"/>
      <g:charCodeRange minValue="302a" maxValue="302f"/>
      <g:charCode value="3099"/>
      <g:charCode value="309a"/>
    </g:charClass>
  </g:token>

  <g:token name="Digit" inline="false" is-macro="yes" is-xml="yes" xhref="http://www.w3.org/TR/REC-xml#NT-Digit" show="no">
    <g:charClass>
      <g:charCodeRange minValue="0030" maxValue="0039"/>
      <g:charCodeRange minValue="0660" maxValue="0669"/>
      <g:charCodeRange minValue="06f0" maxValue="06f9"/>
      <g:charCodeRange minValue="0966" maxValue="096f"/>
      <g:charCodeRange minValue="09e6" maxValue="09ef"/>
      <g:charCodeRange minValue="0a66" maxValue="0a6f"/>
      <g:charCodeRange minValue="0ae6" maxValue="0aef"/>
      <g:charCodeRange minValue="0b66" maxValue="0b6f"/>
      <g:charCodeRange minValue="0be7" maxValue="0bef"/>
      <g:charCodeRange minValue="0c66" maxValue="0c6f"/>
      <g:charCodeRange minValue="0ce6" maxValue="0cef"/>
      <g:charCodeRange minValue="0d66" maxValue="0d6f"/>
      <g:charCodeRange minValue="0e50" maxValue="0e59"/>
      <g:charCodeRange minValue="0ed0" maxValue="0ed9"/>
      <g:charCodeRange minValue="0f20" maxValue="0f29"/>
    </g:charClass>
  </g:token>

  <g:token name="Extender" inline="false" is-macro="yes" is-xml="yes" xhref="http://www.w3.org/TR/REC-xml#NT-Extender" xgc-id="xml-version" show="no">
    <g:charClass>
      <g:charCode value="00b7"/>
      <g:charCode value="02d0"/>
      <g:charCode value="02d1"/>
      <g:charCode value="0387"/>
      <g:charCode value="0640"/>
      <g:charCode value="0e46"/>
      <g:charCode value="0ec6"/>
      <g:charCode value="3005"/>
      <g:charCodeRange minValue="3031" maxValue="3035"/>
      <g:charCodeRange minValue="309d" maxValue="309e"/>
      <g:charCodeRange minValue="30fc" maxValue="30fe"/>
    </g:charClass>
  </g:token>

  <g:token name="CommentStart" token-kind="skip" inline="true" comment-id="comments">
    <g:string>(:</g:string>
  </g:token>

  <g:token name="CommentEnd" token-kind="skip" inline="true">
    <g:string>:)</g:string>
  </g:token>

  <g:token name="CommentContent" token-kind="skip" inline="true">
    <g:ref name="Char"/>
  </g:token>

  <g:token name="ImplicitlyAllowedWhitespace" token-kind="skip" show="no">
    <g:oneOrMore>
      <g:ref name="WhitespaceChar"/>
    </g:oneOrMore>
  </g:token>

  <!-- ================================================
       These states define the lex-time disambiguations of tokens.  The are
       probably non-normative.
  ================================================ -->
  <g:state-list>

    <g:state name="ANY" show="no">
      <g:description>
        This is not an actual state, but rather a collection of
        sub-terminals that are referenced by g:token rules.
        In the file that is generated for input to JavaCC,
        each becomes a "private regular expression".
        (It would be better to make this distinction
        in the g:token element.)
      </g:description>
      <g:transition>
        <g:description>No state change.</g:description>
        <g:tref name="BracedURILiteral" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns"/>
        <g:tref name="WhitespaceChar"/>
        <g:tref name="Nmstart"/>
        <g:tref name="NCNameTok"/>
        <g:tref name="Nmchar"/>
        <g:tref name="LocalPart"/>
        <g:tref name="Digits"/>
        <g:tref name="Letter"/>
        <g:tref name="BaseChar"/>
        <g:tref name="Ideographic"/>
        <g:tref name="CombiningChar"/>
        <g:tref name="Digit"/>
        <g:tref name="Extender"/>
        <g:tref name="HexDigits"/>
        <g:tref name="Comment"/>
        <g:tref name="CommentContents" if="xpath20 xpath30 xpath31 xquery10 xquery30 xquery31 xslt2-patterns xslt30-patterns"/>
        <g:tref name="EscapeQuot" if="xpath20 xpath30 xpath31 xslt2-patterns xslt30-patterns"/>
        <g:tref name="EscapeApos" if="xpath20 xpath30 xpath31 xslt2-patterns xslt30-patterns"/>
        <g:tref name="Char" if="xpath1 xpath20 xpath30 xpath31 xslt2-patterns xslt30-patterns"/>
      </g:transition>
    </g:state>

    <g:state name="DEFAULT">
      <g:description>XXX</g:description>
      <g:transition next-state="XML_COMMENT" action="pushState" if="xcore xquery10 xquery30 xquery31">
        <g:tref name="DirCommentStart"/>
      </g:transition>
      <g:transition next-state="EXPR_COMMENT" action="pushState">
        <g:tref name="CommentStart"/>
      </g:transition>
      <g:transition next-state="PROCESSING_INSTRUCTION" action="pushState" if="xcore xquery10 xquery30 xquery31">
        <g:tref name="ProcessingInstructionStart"/>
      </g:transition>
      <g:transition next-state="CDATA_SECTION" action="pushState" if="xcore xquery10 xquery30 xquery31">
        <g:tref name="CdataSectionStart"/>
      </g:transition>
      <g:transition next-state="START_TAG" action="pushState" if="xcore xquery10 xquery30 xquery31">
        <g:tref name="LeftAngleBracket"/>
      </g:transition>
      <g:transition next-state="DEFAULT" action="pushState" if="xpath1 xpath20 xpath30 xpath31 xslt2-patterns xslt30-patterns">
        <g:tref name="LeftAngleBracket"/>
      </g:transition>
      <g:transition next-state="PRAGMA_1" if="fulltext xcore xquery10 xquery30 xquery31">
        <g:tref name="PragmaOpen"/>
      </g:transition>
      <g:transition next-state="STRING_CONSTRUCTOR" if="xquery31">
        <g:tref name="StringConstructorStart"/>
      </g:transition>
      <g:transition next-state="STRING_CONSTRUCTOR" if="xquery31">
        <g:tref name="StringConstructorInterpolationEnd"/>
      </g:transition>
      <g:transition action="popState">
        <g:tref name="Rbrace"/>
      </g:transition>
      <g:transition next-state="DEFAULT" action="pushState">
        <g:tref name="Lbrace"/>
      </g:transition>
      <g:transition>
        <g:tref name="ImplicitlyAllowedWhitespace"/>
        <g:tref name="Slash"/>
        <g:tref name="SlashSlash"/>
        <g:tref name="URIQualifiedName" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns"/>
        <g:tref name="IntegerLiteral"/>
        <g:tref name="DecimalLiteral"/>
        <g:tref name="DoubleLiteral" not-if="xpath1"/>
        <g:tref name="StringLiteral"/>
        <g:tref name="QNameToken"/>
        <g:tref name="NCNameColonStar"/>
        <g:tref name="StarColonNCName"/>
        <g:tref name="URIQualifiedStar" if="xpath30 xpath31 xquery30 xquery31 xslt30-patterns"/>
        <g:tref name="NumericLiteralError"/>
        <g:tref name="Minus"/>
        <g:tref name="Plus"/>
        <g:tref name="External" if="xcore xquery10 xquery30 xquery31"/>
        <g:tref name="Ascending" if="xcore xquery10 xquery30 xquery31"/>
        <g:tref name="Descending" if="xcore xquery10 xquery30 xquery31"/>
        <g:tref name="Greatest" if="xcore xquery10 xquery30 xquery31"/>
        <g:tref name="Least" if="fulltext xcore xquery10 xquery30 xquery31"/>
      </g:transition>
    </g:state>

    <g:state name="EXPR_COMMENT">
      <g:description>The "(:" token marks the beginning of an expression
                Comment, and the ":)" token marks the end. This allows no special
                interpretation of other characters in this state.</g:description>
      <g:transition action="popState">
        <g:tref name="CommentEnd"/>
      </g:transition>
      <g:transition next-state="EXPR_COMMENT" action="pushState">
        <g:tref name="CommentStart"/>
      </g:transition>
      <g:transition>
        <g:description>No state change.</g:description>
        <g:tref name="CommentContent"/>
      </g:transition>
    </g:state>

    <!-- states pertaining to DirElemConstructor: -->

    <g:state name="START_TAG" if="xcore xquery10 xquery30 xquery31">
      <g:description>This state allows attributes in the native XML syntax,
                and marks the beginning of an element construction. Element
                constructors also push the current state, popping it at the
                conclusion of an end tag. In the START_TAG state, the string "&gt;" is
                recognized as a token which is associated with the transition to
                the original state. </g:description>
      <g:transition action="popState">
        <g:tref name="EmptyTagClose"/>
      </g:transition>
      <g:transition next-state="ELEMENT_CONTENT">
        <g:tref name="StartTagClose"/>
      </g:transition>
      <g:transition next-state="QUOT_ATTRIBUTE_CONTENT">
        <g:tref name="OpenQuot"/>
      </g:transition>
      <g:transition next-state="APOS_ATTRIBUTE_CONTENT">
        <g:tref name="OpenApos"/>
      </g:transition>
      <g:transition>
        <g:description>No state change.</g:description>
        <g:tref name="S"/>
        <g:tref name="TagQName"/>
        <g:tref name="ValueIndicator"/>
      </g:transition>
    </g:state>

    <g:state name="QUOT_ATTRIBUTE_CONTENT" if="xcore xquery10 xquery30 xquery31">
      <g:description>This state allows content valid for attributes. The
                character "{" marks a transition to the OPERAND state, i.e. the
                start of an embedded expression, and the "}" character pops back to
                the original state. To allow curly braces to be used as character
                content, a double left or right curly brace is interpreted as a
                single curly brace character. This state is the same as
                APOS_ATTRIBUTE_CONTENT, except that apostrophes are allowed without
                escaping, and an unescaped quote marks the end of the
                state.</g:description>
      <g:transition next-state="START_TAG">
        <g:tref name="CloseQuot"/>
      </g:transition>
      <g:transition next-state="DEFAULT" action="pushState">
        <g:description>Transition to an Attribute Value
                    Template.</g:description>
        <g:tref name="Lbrace"/>
        <g:tref name="RbraceError"/>
        <g:tref name="LeftAngleBracketError"/>
      </g:transition>
      <g:transition>
        <g:description>No state change.</g:description>
        <g:tref name="EscapeQuot"/>
        <g:tref name="QuotAttrContentChar"/>
        <g:tref name="AmpersandError"/>
        <g:tref name="PredefinedEntityRef" if="xquery10 xquery30 xquery31"/>
        <g:tref name="CharRef"/>
        <g:tref name="LCurlyBraceEscape" if="xquery10 xquery30 xquery31"/>
        <g:tref name="RCurlyBraceEscape" if="xquery10 xquery30 xquery31"/>
      </g:transition>
    </g:state>

    <g:state name="APOS_ATTRIBUTE_CONTENT" if="xcore xquery10 xquery30 xquery31">
      <g:description>This state is the same as QUOT_ATTRIBUTE_CONTENT, except
                that quotes are allowed, and an unescaped apostrophe marks the end
                of the state.</g:description>
      <g:transition next-state="START_TAG">
        <g:tref name="CloseApos"/>
      </g:transition>
      <g:transition next-state="DEFAULT" action="pushState">
        <g:description>Transition to an Attribute Value
                    Template.</g:description>
        <g:tref name="Lbrace"/>
        <g:tref name="RbraceError"/>
        <g:tref name="LeftAngleBracketError"/>
      </g:transition>
      <g:transition>
        <g:description>No state change.</g:description>
        <g:tref name="EscapeApos"/>
        <g:tref name="AposAttrContentChar"/>
        <g:tref name="AmpersandError"/>
        <g:tref name="PredefinedEntityRef" if="xquery10 xquery30 xquery31"/>
        <g:tref name="CharRef"/>
        <g:tref name="LCurlyBraceEscape" if="xquery10 xquery30 xquery31"/>
        <g:tref name="RCurlyBraceEscape" if="xquery10 xquery30 xquery31"/>
      </g:transition>
    </g:state>

    <g:state name="ELEMENT_CONTENT" if="xcore xquery10 xquery30 xquery31">
      <g:description>This state allows XML-like content, without these
                characters being misinterpreted as expressions. The character "{"
                marks a transition to the OPERAND state, i.e. the start of an
                embedded expression, and the "}" character pops back to the
                ELEMENT_CONTENT state. To allow curly braces to be used as
                character content, a double left or right curly brace is
                interpreted as a single curly brace character. The string "&lt;/"
                is interpreted as the beginning of an end tag, which is associated
                with a transition to the END_TAG state.</g:description>
      <g:transition next-state="END_TAG">
        <g:tref name="EndTagOpen"/>
      </g:transition>
      <g:transition next-state="DEFAULT" action="pushState">
        <g:description>Transition to an Element Value
                    Template.</g:description>
        <g:tref name="Lbrace"/>
        <g:tref name="RbraceError"/>
      </g:transition>
      <g:transition next-state="XML_COMMENT" action="pushState">
        <g:tref name="DirCommentStart"/>
      </g:transition>
      <g:transition next-state="PROCESSING_INSTRUCTION" action="pushState">
        <g:tref name="ProcessingInstructionStart"/>
      </g:transition>
      <g:transition next-state="CDATA_SECTION" action="pushState">
        <g:tref name="CdataSectionStart"/>
      </g:transition>
      <g:transition next-state="START_TAG" action="pushState">
        <g:tref name="LeftAngleBracket"/>
      </g:transition>
      <g:transition>
        <g:description>No state change.</g:description>
        <g:tref name="ElementContentChar"/>
        <g:tref name="PredefinedEntityRef" if="xquery10 xquery30 xquery31"/>
        <g:tref name="CharRef"/>
        <g:tref name="LCurlyBraceEscape" if="xquery10 xquery30 xquery31"/>
        <g:tref name="RCurlyBraceEscape" if="xquery10 xquery30 xquery31"/>
        <g:tref name="AmpersandError"/>
      </g:transition>
    </g:state>

    <g:state name="END_TAG" if="xcore xquery10 xquery30 xquery31">
      <g:description>When the end tag is terminated, the state is popped to
                the state that was pushed at the start of the corresponding start
                tag.</g:description>
      <g:transition action="popState">
        <g:tref name="EndTagClose"/>
      </g:transition>
      <g:transition>
        <g:description>No state change.</g:description>
        <g:tref name="S"/>
        <g:tref name="EndTagQName"/>
      </g:transition>
    </g:state>

    <!-- state pertaining to DirCommentConstructor: -->

    <g:state name="XML_COMMENT" if="xcore xquery10 xquery30 xquery31">
      <g:description>The "&lt;--" token marks the beginning of an XML
                Comment, and the "--&gt;" token marks the end. This allows no special
                interpretation of other characters in this state.</g:description>
      <g:transition action="popState">
        <g:tref name="DirCommentEnd"/>
      </g:transition>
      <g:transition>
        <g:description>No state change.</g:description>
        <g:tref name="DirCommentContentChar"/>
        <g:tref name="DirCommentContentDashChar"/>
        <g:tref name="DirCommentContentDoubleDashError"/>
      </g:transition>
    </g:state>

    <!-- states pertaining to DirPIConstructor: -->

    <g:state name="PROCESSING_INSTRUCTION" if="xcore xquery10 xquery30 xquery31">
      <g:description>In this state, only patterns that are valid in a
                processing instruction name are recognized.</g:description>
      <g:transition next-state="PROCESSING_INSTRUCTION_CONTENT">
        <g:tref name="S"/>
      </g:transition>
      <g:transition action="popState">
        <g:tref name="ProcessingInstructionEnd"/>
      </g:transition>
      <g:transition>
        <g:description>No state change.</g:description>
        <g:tref name="PITargetError"/>
        <g:tref name="PITarget"/>
      </g:transition>
    </g:state>

    <g:state name="PROCESSING_INSTRUCTION_CONTENT" if="xcore xquery10 xquery30 xquery31">
      <g:description>In this state, only characters are that are valid in
                processing instruction content are recognized.</g:description>
      <g:transition action="popState">
        <g:tref name="ProcessingInstructionEnd"/>
      </g:transition>
      <g:transition>
        <g:description>No state change.</g:description>
        <g:tref name="Char"/>
      </g:transition>
    </g:state>

    <!-- state pertaining to CDataSection: -->

    <g:state name="CDATA_SECTION" if="xcore xquery10 xquery30 xquery31">
      <g:description>In this state, only lexemes that are valid in a CDATA
                section are recognized.</g:description>
      <g:transition action="popState">
        <g:tref name="CdataSectionEnd"/>
      </g:transition>
      <g:transition>
        <g:description>No state change.</g:description>
        <g:tref name="Char"/>
      </g:transition>
    </g:state>

    <!-- states pertaining to Pragma: -->

    <g:state name="PRAGMA_1" if="fulltext xcore xquery10 xquery30 xquery31">
      <g:description>This state is entered in a a pragma expression, and recognizes a
                     QName that transits to a PRAGMA_3 state rather than a OPERATOR state.</g:description>
      <g:transition next-state="PRAGMA_2">
        <g:tref name="QNameToken"/>
        <g:tref name="URIQualifiedName" if="xquery30 xquery31"/>
      </g:transition>
      <g:transition>
        <g:description>No state change.</g:description>
        <g:tref name="S"/>
      </g:transition>
    </g:state>

    <g:state name="PRAGMA_2" if="fulltext xcore xquery10 xquery30 xquery31">
      <g:description>This state recognizes the space(s) required to preceed pragma contents.  If you don't have
        this, and try to recognize S in PRAGMA_3, then Char will be recognized first,
        and the pragma production won't work properly.</g:description>
      <g:transition next-state="DEFAULT">
        <g:tref name="PragmaClose"/>
      </g:transition>
      <g:transition next-state="PRAGMA_3">
        <g:tref name="S"/>
      </g:transition>
    </g:state>

    <g:state name="PRAGMA_3" if="fulltext xcore xquery10 xquery30 xquery31">
      <g:description>This state recognizes characters in pragma content, and transits out of this
                     state when a '#)' pattern is recognized.</g:description>
      <g:transition next-state="DEFAULT">
        <g:tref name="PragmaClose"/>
      </g:transition>
      <g:transition>
        <g:tref name="Char"/>
      </g:transition>
    </g:state>

    <!-- states pertaining to StringConstructor: -->

    <g:state name="STRING_CONSTRUCTOR" if="xquery31">
      <g:transition next-state="DEFAULT">
        <g:tref name="StringConstructorEnd"/>
      </g:transition>
      <g:transition next-state="DEFAULT">
        <g:tref name="StringConstructorInterpolationStart"/>
      </g:transition>
      <g:transition>
        <g:tref name="Char"/>
      </g:transition>
    </g:state>

  </g:state-list>

</g:grammar>
<!-- vim: sw=2 ts=2 expandtab
-->
