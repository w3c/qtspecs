<?xml version="1.0" encoding="utf-8"?><!--{xml-fix} XSLT Processor: SAXON 9.1.0.2 from Saxonica SAXON SA 9.1.0.2--><!--This document was created at 20110311 1646--><html xmlns="http://www.w3.org/1999/xhtml" lang="EN"><head><title>XQuery and XPath Full Text 1.0 -- Review Version</title><style type="text/css">
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

div.issue
p.title        { margin-left: -2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }

li p           { margin-top: 0.3em;
                 margin-bottom: 0.3em; }

sup small      { font-style: italic;
                 color: #8F8F8F;
               }
    
div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}

div.issue { border-bottom-color: black;
            border-bottom-style: solid;
	    border-bottom-width: 1pt;
	    margin-bottom: 20pt;
}

th.issue-toc-head { border-bottom-color: black;
                    border-bottom-style: solid;
                    border-bottom-width: 1pt;
}

      
table.small    { font-size: x-small; }
    .diff-add  { background-color: #99ff99 }
.diff-del  { background-color: #ff9999; text-decoration: line-through }
.diff-chg  { background-color: #ffff99 }
.diff-off  {  }table.small                             { font-size: x-small; }
a.judgment:visited, a.judgment:link     { font-family: sans-serif;
                              	          color: black; 
                              	          text-decoration: none }
a.processing:visited, a.processing:link { color: black; 
                              		        text-decoration: none }
a.env:visited, a.env:link               { color: black; 
                                          text-decoration: none }</style><link rel="stylesheet" type="text/css" href="http://www.w3.org/StyleSheets/TR/W3C-REC.css"/></head><body><div><p>The presentation of this document has been augmented to
            identify changes from a previous version. Three kinds of changes
            are highlighted: <span class="diff-add">new, added text</span>,
              <span class="diff-chg">changed text</span>, and
              <span class="diff-del">deleted text</span>.</p><hr/></div><div class="head"><p><a href="http://www.w3.org/"><img src="http://www.w3.org/Icons/w3c_home" alt="W3C" height="48" width="72"/></a></p>
<h1><a name="title" id="title"/>XQuery and XPath Full Text 1.0</h1>
<h2><a name="w3c-doctype" id="w3c-doctype"/>W3C Recommendation 13 March 2011</h2><dl><dt>This version:</dt><dd>
         <a href="http://www.w3.org/TR/2011/REC-xpath-full-text-10-20110313/">http://www.w3.org/TR/2011/REC-xpath-full-text-10-20110313/</a>
      </dd><dt>Latest version:</dt><dd>
         <a href="http://www.w3.org/TR/xpath-full-text-10/">http://www.w3.org/TR/xpath-full-text-10/</a>
      </dd><div class="diff-chg"><dt>Previous version:</dt><dd>
         <a href="http://www.w3.org/TR/2011/PR-xpath-full-text-10-20110125/">http://www.w3.org/TR/2011/PR-xpath-full-text-10-20110125/</a>
         
</dd></div><dt>Editors:</dt><!--xmlspec, match="author"--><dd>Pat Case, Library of Congress</dd><!--xmlspec, match="author"--><dd>Michael Dyck, Invited Expert</dd><!--xmlspec, match="author"--><dd>Mary Holstege, Mark Logic Corporation</dd><!--xmlspec, match="author"--><dd>Sihem Amer-Yahia, AT&amp;T Labs - Research</dd><!--xmlspec, match="author"--><dd>Chavdar Botev, Invited Expert</dd><!--xmlspec, match="author"--><dd>Stephen Buxton, Mark Logic Corporation</dd><!--xmlspec, match="author"--><dd>Jochen Doerre, IBM</dd><!--xmlspec, match="author"--><dd>Jim Melton, Oracle</dd><!--xmlspec, match="author"--><dd>Michael Rys, Microsoft</dd><!--xmlspec, match="author"--><dd>Jayavel Shanmugasundaram, Invited Expert</dd></dl><p>Please refer to the <a href="http://www.w3.org/XML/2012/qt-errata/xpath-full-text-10-errata.html"><strong>errata</strong></a> for this document, which may
      include some normative corrections.</p><p>See also <a href="http://www.w3.org/2003/03/Translations/byTechnology?technology=xpath-full-text-10"><strong>translations</strong></a>.</p><div class="diff-chg"><p>This document is also available in these non-normative formats: <a href="http://www.w3.org/TR/2011/REC-xpath-full-text-10-20110313/xpath-full-text-10.xml">XML</a> and <a href="http://www.w3.org/TR/2011/REC-xpath-full-text-10-20110313/Overview-diff.html">Changes since Candidate Recommendation</a>.</p></div><p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2011 <a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href="http://www.ercim.eu/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p></div><hr/><div>
<h2><a name="abstract" id="abstract"/>Abstract</h2><p>This document defines the syntax and formal semantics of XQuery and XPath Full Text 1.0,
which is a language that extends XQuery 1.0 <a href="#xquery">[XQuery 1.0: An XML Query Language (Second Edition)]</a>
and XPath 2.0 <a href="#xpath20">[XML Path Language (XPath) 2.0 (Second Edition)]</a> with full-text search capabilities.</p></div><div>
<h2><a name="status" id="status"/>Status of this Document</h2><p>
            <em>This section describes the status of this
         document at the time of its publication.
         Other documents may supersede this document.
         A list of current W3C publications and the latest
         revision of this technical report can be found in the
         <a href="http://www.w3.org/TR/">W3C technical reports index</a>
         at http://www.w3.org/TR/.</em>
         </p><p>This is a <a href="http://www.w3.org/2005/10/Process-20051014/tr.html#RecsW3C">Recommendation</a> of the W3C. 
  It was jointly developed by the W3C 
<a href="http://www.w3.org/XML/Query/">XML Query Working Group</a> and the W3C <a href="http://www.w3.org/Style/XSL/">XSL Working Group</a>, each of which is part of the <a href="http://www.w3.org/XML/Activity">XML Activity</a>.</p><p>This document incorporates minor changes made against the Proposed Recommendation
                               of 25 January 2011. 
                               Changes to this document since the Proposed Recommendation are detailed in
                               <a href="#id-xqft-changelog"><b>J Change Log</b></a>.
                               A Java applet that parses XQuery and XPath Full Text 1.0 expressions is available at
                               <a href="http://www.w3.org/2010/02/qt-applets/xquery10-fulltext/">
                               http://www.w3.org/2010/02/qt-applets/xquery10-fulltext/</a>.</p><p>A Test Suite has been created for this document.
Implementors are encouraged to run this test suite and report their results.
The Test Suite can be found at <a href="http://dev.w3.org/cvsweb/2007/xpath-full-text-10-test-suite/">http://dev.w3.org/cvsweb/2007/xpath-full-text-10-test-suite/</a>. 
An implementation report is available at
<a href="http://dev.w3.org/2007/xpath-full-text-10-test-suite/PublicPagesStagingArea/ReportedResults/XQFTTSReport.html">http://dev.w3.org/2007/xpath-full-text-10-test-suite/PublicPagesStagingArea/ReportedResults/XQFTTSReport.html</a>.</p><p>No substantive changes have been made to this specification
since its publication as a Proposed Recommendation.</p><p>Please report errors in this document using W3C's
         <a href="http://www.w3.org/Bugs/Public/">public Bugzilla system</a>
         (instructions can be found at
         <a href="http://www.w3.org/XML/2005/04/qt-bugzilla">http://www.w3.org/XML/2005/04/qt-bugzilla</a>).
         If access to that system is not feasible, you may send your comments
         to the W3C XSLT/XPath/XQuery public comments mailing list,
         <a href="mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</a>.
         It will be very helpful if you include the string 
         “[FT]”
         in the subject line of your report, whether made in Bugzilla or in email.
         Please use multiple Bugzilla entries (or, if necessary, multiple email messages)
         if you have more than one comment to make.
         Archives of the comments and responses are available at
         <a href="http://lists.w3.org/Archives/Public/public-qt-comments/">http://lists.w3.org/Archives/Public/public-qt-comments/</a>. </p><p>This document has been reviewed by W3C Members, by
software developers, and by other W3C groups and interested parties,
and is endorsed by the Director as a W3C Recommendation. 
It is a stable document and may be used as reference material or cited from
another document. 
W3C's role in making the Recommendation is to draw attention to
the specification and to promote its widespread deployment. 
This enhances the functionality and interoperability of
the Web.</p><p>This document was produced by groups operating under the
   <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004
   W3C Patent Policy</a>.
   W3C maintains a <a href="http://www.w3.org/2004/01/pp-impl/18797/status#disclosures">public list of any 
   patent disclosures</a> made in connection with the deliverables of the 
   XML Query Working Group and also maintains a <a href="http://www.w3.org/2004/01/pp-impl/19552/status#disclosures">public list of any patent 
   disclosures</a> made in connection with the deliverables of the XSL 
   Working Group; those pages also include instructions for
   disclosing a patent.
   An individual who has actual knowledge of a patent which the individual believes
   contains
   <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential Claim(s)</a>
   must disclose the information in accordance with
   <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section 6 of the W3C Patent Policy</a>. </p></div><div class="toc">
<h2><a name="contents" id="contents"/>Table of Contents</h2><p class="toc">1 <a href="#introduction">Introduction</a><br/>
    1.1 <a href="#tq-ftsearch-xml">Full-Text Search and XML</a><br/>
    1.2 <a href="#tq-ft-organization">Organization of this document</a><br/>
    1.3 <a href="#tq-ft-namespaces">A word about namespaces</a><br/>
2 <a href="#tq-extensions">Full-Text Extensions to XQuery and XPath</a><br/>
    2.1 <a href="#processing-model">Processing Model</a><br/>
    2.2 <a href="#section-ftcontainsexpr">Full-Text Contains Expression</a><br/>
        2.2.1 <a href="#section-ftcontainsexpr-description">Description</a><br/>
        2.2.2 <a href="#section-ftcontainsexpr-examples">Examples</a><br/>
    2.3 <a href="#section-score-variables">Score Variables</a><br/>
        2.3.1 <a href="#section-using-weights"><span class="diff-chg">Using Weights Within a Scored FTContainsExpr</span></a><br/>
    2.4 <a href="#section-extensions-static-context">Extensions to the Static Context</a><br/>
3 <a href="#ftselections"><span class="diff-chg">Full-Text Selections</span></a><br/>
    3.1 <a href="#ftprimary">Primary Full-Text Selections</a><br/>
        3.1.1 <a href="#ftweight"><span class="diff-chg">Weights</span></a><br/>
    3.2 <a href="#ftwords"><span class="diff-chg">Search Tokens and Phrases</span></a><br/>
    3.3 <a href="#fttimes">Cardinality Selection</a><br/>
    3.4 <a href="#ftmatchoptions"><span class="diff-chg">Match Options</span></a><br/>
        3.4.1 <a href="#ftlanguageoption">Language Option</a><br/>
        3.4.2 <a href="#ftwildcardoption">Wildcard Option</a><br/>
        3.4.3 <a href="#ftthesaurusoption"><span class="diff-chg">Thesaurus Option</span></a><br/>
        3.4.4 <a href="#ftstemoption">Stemming Option</a><br/>
        3.4.5 <a href="#ftcaseoption">Case Option</a><br/>
        3.4.6 <a href="#ftdiacriticsoption">Diacritics Option</a><br/>
        3.4.7 <a href="#ftstopwordoption"><span class="diff-chg">Stop Word Option</span></a><br/>
        3.4.8 <a href="#ftextensionoption">Extension Option</a><br/>
    3.5 <a href="#logical_ftoperators">Logical Full-Text Operators</a><br/>
        3.5.1 <a href="#sec-ftor">Or-Selection</a><br/>
        3.5.2 <a href="#sec-ftand">And-Selection</a><br/>
        3.5.3 <a href="#sec-ftmildnot">Mild-Not Selection</a><br/>
        3.5.4 <a href="#sec-ftnot">Not-Selection</a><br/>
    3.6 <a href="#ftposfilter"><span class="diff-chg">Positional Filters</span></a><br/>
        3.6.1 <a href="#ftorder">Ordered Selection</a><br/>
        3.6.2 <a href="#ftwindow">Window Selection</a><br/>
        3.6.3 <a href="#ftdistance">Distance Selection</a><br/>
        3.6.4 <a href="#ftscope">Scope Selection</a><br/>
        3.6.5 <a href="#ftcontent">Anchoring Selection</a><br/>
    3.7 <a href="#ftignoreoption">Ignore Option</a><br/>
    3.8 <a href="#id-extension-selections">Extension Selections</a><br/>
4 <a href="#tq-semantics">Semantics</a><br/>
    4.1 <a href="#TokenizationSec">Tokenization</a><br/>
        4.1.1 <a href="#tq-ft-Tokenization-examples">Examples</a><br/>
        4.1.2 <a href="#TokenizationRepresentationsSec"><span class="diff-chg">Representations of Tokenized Text and Matching</span></a><br/>
    4.2 <a href="#FTSelectionEvalSec">Evaluation of FTSelections</a><br/>
        4.2.1 <a href="#AllMatchesSec">AllMatches</a><br/>
            4.2.1.1 <a href="#tq-ft-formalmodel">Formal Model</a><br/>
            4.2.1.2 <a href="#tq-ft-AllMatches-examples">Examples</a><br/>
            4.2.1.3 <a href="#tq-ft-XML-representation">XML representation</a><br/>
        4.2.2 <a href="#FTSelectionsXMLSec">XML Representation</a><br/>
        4.2.3 <a href="#tq-ft-evaluate-function">The evaluate function</a><br/>
        4.2.4 <a href="#tq-ft-fs-FTWords">FTWords</a><br/>
        4.2.5 <a href="#FTMatchOptionsSec">Match Options Semantics</a><br/>
            4.2.5.1 <a href="#tq-ft-matchopt-types">Types</a><br/>
            4.2.5.2 <a href="#tq-ft-matchopt-highlevel">High-Level Semantics</a><br/>
            4.2.5.3 <a href="#options-sem-functions"><span class="diff-chg">Formal Semantics Functions</span></a><br/>
            4.2.5.4 <a href="#tq-ft-matchopt-FTCaseOption">FTCaseOption</a><br/>
            4.2.5.5 <a href="#tq-ft-matchopt-FTDiacriticsOption">FTDiacriticsOption</a><br/>
            4.2.5.6 <a href="#tq-ft-matchopt-FTStemOption">FTStemOption</a><br/>
            4.2.5.7 <a href="#tq-ft-matchopt-FTThesaurusOption">FTThesaurusOption</a><br/>
            4.2.5.8 <a href="#tq-ft-matchopt-FTStopWordOption"><span class="diff-chg">FTStopWordOption</span></a><br/>
            4.2.5.9 <a href="#tq-ft-matchopt-FTLanguageOption">FTLanguageOption</a><br/>
            4.2.5.10 <a href="#tq-ft-matchopt-FTWildCardOption">FTWildCardOption</a><br/>
        4.2.6 <a href="#FTOperatorsSemanticsSec">Full-Text Operators Semantics</a><br/>
            4.2.6.1 <a href="#tq-ft-fs-FTOr">FTOr</a><br/>
            4.2.6.2 <a href="#tq-ft-fs-FTAnd">FTAnd</a><br/>
            4.2.6.3 <a href="#tq-ft-fs-FTUnaryNot">FTUnaryNot</a><br/>
            4.2.6.4 <a href="#tq-ft-fs-FTMildNot">FTMildNot</a><br/>
            4.2.6.5 <a href="#tq-ft-fs-FTOrder">FTOrder</a><br/>
            4.2.6.6 <a href="#tq-ft-fs-FTScope"><span class="diff-chg">FTScope</span></a><br/>
            4.2.6.7 <a href="#tq-ft-fs-FTContent">FTContent</a><br/>
            4.2.6.8 <a href="#tq-ft-fs-FTWindow">FTWindow</a><br/>
            4.2.6.9 <a href="#tq-ft-fs-FTDistance">FTDistance</a><br/>
            4.2.6.10 <a href="#tq-ft-fs-FTTimes">FTTimes</a><br/>
    4.3 <a href="#FTContainsSec">FTContainsExpr</a><br/>
    4.4 <a href="#ScoreSec">Scoring</a><br/>
    4.5 <a href="#tq-ft-FTContainsExpr-example">Example</a><br/>
5 <a href="#id-tq-conformance">Conformance</a><br/>
    5.1 <a href="#id-minimal-conformance">Minimal Conformance</a><br/>
    5.2 <a href="#id-conform-optional-features">Optional Features</a><br/>
        5.2.1 <a href="#id-ftmildnot-option">FTMildNot Operator</a><br/>
        5.2.2 <a href="#id-unary-not-option">FTUnaryNot Operator</a><br/>
        5.2.3 <a href="#id-ftunit-option">FTUnit and FTBigUnit</a><br/>
        5.2.4 <a href="#id-ftorder-option">FTOrder Operator</a><br/>
        5.2.5 <a href="#id-ftscope-option">FTScope Operator</a><br/>
        5.2.6 <a href="#id-ftwindow-option">FTWindow Operator</a><br/>
        5.2.7 <a href="#id-ftdistance-option">FTDistance Operator</a><br/>
        5.2.8 <a href="#id-fttimes-option">FTTimes Operator</a><br/>
        5.2.9 <a href="#id-ftcontent-option">FTContent Operator</a><br/>
        5.2.10 <a href="#id-ftcase-option">FTCaseOption</a><br/>
        5.2.11 <a href="#id-ftstopword-option">FTStopWordOption</a><br/>
        5.2.12 <a href="#id-ftlanguage-option">FTLanguageOption</a><br/>
        5.2.13 <a href="#id-ftignore-option">FTIgnoreOption</a><br/>
        5.2.14 <a href="#id-scoring-option">Scoring</a><br/>
        5.2.15 <a href="#id-weights-conf">Weights</a><br/>
6 <a href="#id-xqueryx-full-text-conformance"><span class="diff-chg">XQueryX Conformance</span></a><br/>
</p>
<h3><a name="appendices" id="appendices"/>Appendices</h3><p class="toc">A <a href="#id-grammar">EBNF for XQuery 1.0 Grammar with Full Text extensions</a><br/>
    A.1 <a href="#grammar-terminals">Terminal Symbols</a><br/>
B <a href="#id-xpath-grammar">EBNF for XPath 2.0 Grammar with Full-Text
		extensions</a><br/>
    B.1 <a href="#xpath-grammar-terminals">Terminal Symbols</a><br/>
C <a href="#id-xqft-static-context-components">Static Context Components</a><br/>
D <a href="#id-errors"><span class="diff-chg">Error Conditions</span></a><br/>
E <a href="#id-xqft-xqueryx">XML Syntax (XQueryX) for XQuery and XPath Full Text 1.0</a><br/>
    E.1 <a href="#id-xqft-full-text-schema">XQueryX representation of XQuery and XPath Full Text 1.0</a><br/>
    E.2 <a href="#id-xqft-full-text-stylesheet">XQueryX stylesheet for XQuery and XPath Full Text 1.0</a><br/>
    E.3 <a href="#id-xqft-full-text-examples">XQueryX for XQuery and XPath Full Text 1.0 example</a><br/>
        E.3.1 <a href="#Example1">Example</a><br/>
            E.3.1.1 <a href="#Example1-XQuery-Full-Text">XQuery solution in XQuery and XPath Full Text 1.0 Use Cases:</a><br/>
            E.3.1.2 <a href="#Example1-Full-Text-XQueryX">A Solution in Full Text XQueryX:</a><br/>
            E.3.1.3 <a href="#Example1-Full-Text-Transformation">Transformation of Full Text XQueryX Solution into XQuery Full Text</a><br/>
F <a href="#References">References</a><br/>
    F.1 <a href="#id-normative-references">Normative References</a><br/>
    F.2 <a href="#id-non-normative-references">Non-normative References</a><br/>
G <a href="#ft-acknowledgements">Acknowledgements</a> (Non-Normative)<br/>
H <a href="#ft-glossary">Glossary</a> (Non-Normative)<br/>
I <a href="#impl-def"><span class="diff-chg">Checklist of Implementation-Defined Features</span></a> (Non-Normative)<br/>
J <a href="#id-xqft-changelog">Change Log</a> (Non-Normative)<br/>
</p></div><hr/><div class="body"><div class="div1">
<h2><a name="introduction" id="introduction"/>1 Introduction</h2><p>This document defines the language and the formal semantics of
  XQuery and XPath Full Text 1.0. This language is designed to meet the requirements
  identified in W3C XQuery and XPath Full Text Requirements
  <a href="#xpath-full-text-10-requirements">[XQuery and XPath Full Text 1.0 Requirements]</a> and to support the queries in
  the W3C XQuery and XPath Full Text Use Cases <a href="#xpath-full-text-10-use-cases">[XQuery and XPath Full Text 1.0 Use Cases]</a>. </p><p>In this document, examples and material labeled as "Note" are provided for
     explanatory purposes and are not normative. </p><p>XQuery and XPath Full Text 1.0 extends the syntax and semantics of XQuery 1.0 and
  XPath 2.0. </p><p>Additionally, this document defines an XML syntax for XQuery and XPath Full Text 1.0. 
  The most recent versions of the two XQueryX XML Schemas and the
  XQueryX XSLT stylesheet for XQuery and XPath Full Text 1.0 are available at
  <a href="http://www.w3.org/2007/xpath-full-text/xpath-full-text-10-xqueryx.xsd">http://www.w3.org/2007/xpath-full-text/xpath-full-text-10-xqueryx.xsd</a>,
  <a href="http://www.w3.org/2007/xpath-full-text/xpath-full-text-10-xqueryx-ftmatchoption-extensions.xsd">http://www.w3.org/2007/xpath-full-text/xpath-full-text-10-xqueryx-ftmatchoption-extensions.xsd</a>,
  and <a href="http://www.w3.org/2007/xpath-full-text/xpath-full-text-10-xqueryx.xsl">http://www.w3.org/2007/xpath-full-text/xpath-full-text-10-xqueryx.xsl</a>,
  respectively.</p><div class="div2">
<h3><a name="tq-ftsearch-xml" id="tq-ftsearch-xml"/>1.1 Full-Text Search and XML</h3><p>As XML becomes mainstream, users expect to be able to 
search their XML documents. This requires a standard way to do
full-text search, as well as structured searches, against XML
documents.  A similar requirement for full-text search led ISO to
define the SQL/MM-FT <a href="#sqlmm">[SQL/MM]</a> standard.
SQL/MM-FT defines extensions to SQL to express
full-text searches providing functionality similar to that defined in this full-text
language extension to XQuery 1.0 and XPath 2.0.
</p><p>XML documents may contain highly structured data (fixed schemas, known types
such as numbers, dates), semi-structured data (flexible schemas and types),
markup data (text with embedded tags), and unstructured data (untagged
free-flowing text). Where a document contains unstructured
or semi-structured data, it is important to be able to search using
Information Retrieval techniques such as scoring and weighting.</p><p>Full-text search is different from substring search in many ways:</p><ol class="enumar"><li><p>A full-text search searches for tokens and phrases
rather than substrings. A substring search for news items that contain
the string "lease" will return a news item that contains "Foobar
Corporation releases version 20.9 ...". A full-text search for the
token "lease" will not. </p></li><li><p>There is an expectation that a full-text search will support
language-based searches which substring search cannot. An
example of a language-based search is "find me all the news items that
contain a token with the same linguistic stem as 'mouse'" (finds "mouse"
and "mice"). Another example based on token proximity is "find me all
the news items that contain the tokens 'XML' and
'Query' allowing up to 3 intervening tokens".</p></li><li><p>Full-text search must address the vagaries and nuances of
language. Search results  are often of varying usefulness. When
you search a web site for cameras that cost less than $100, this
is an exact search.  There is a set of cameras that matches this search,
and a set that does not.  Similarly, when you do a string search across
news items for "mouse", there is only 1 expected result set. When you
do a full-text search for all the news items that contain the
token "mouse", you probably expect to find news items containing the token
"mice", and possibly "rodents", or possibly "computers".  Not
all results are equal. Some results are more "mousey" than others.
Because full-text search may be inexact, we have the notion of score
or relevance. We generally expect to see the most relevant results at
the top of the results list.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>As XQuery and XPath evolve, they may apply the notion of
score to querying structured data. For example, when making travel
plans or shopping for cameras, it is sometimes useful to get an
ordered list of near matches in addition to exact matches. 
If XQuery and XPath define a generalized 
inexact match, we expect XQuery and XPath to utilize the scoring
framework provided by XQuery and XPath Full Text 1.0.
</p></div><p>
               [<a name="Full-TextQueriesDef" id="Full-TextQueriesDef" title="Full-TextQueries">Definition</a>: 
                  <b>Full-text queries</b> are 
   performed on tokens and phrases. Tokens and phrases are produced via
   tokenization.] Informally, tokenization breaks a character string into a 
    sequence of tokens, units of punctuation, and spaces.</p><p>
Tokenization, in general terms, is the process of converting a text
string into smaller units that are used in query processing. Those
units, called tokens, are the most basic text units that a full-text
search can refer to. Full-text operators typically work on sequences
of tokens found in the target text of a
search. These tokens are characterized by
integers that capture the relative position(s) of the token inside the
string, the relative position(s) of the sentence containing the token,
and the relative position(s) of the paragraph containing the token.  The
positions typically comprise a start and an end position.</p><p>
Tokenization, including the definition of the term "tokens", <a title="should" href="#should">SHOULD</a> be
<a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>. 
Implementations <a title="should" href="#should">SHOULD</a> expose the rules and sample
results of tokenization as much as possible to enable users to predict and
interpret the results of tokenization. 
Tokenization operates on the string
value of an item; for element nodes this does not include the content of
attribute nodes, but for attribute nodes it does.
Tokenization is defined more formally in
<a href="#TokenizationSec"><b>4.1 Tokenization</b></a>.
</p><p>
               [<a name="TokenDef" id="TokenDef" title="Token">Definition</a>: A <b>token</b> is a non-empty sequence of characters
returned by a tokenizer as a basic unit to be searched. 
Beyond that, tokens are <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.]
               [<a name="PhraseDef" id="PhraseDef" title="Phrase">Definition</a>: A <b>phrase</b> is an ordered sequence of any number of tokens. 
Beyond that, phrases are <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.]
            </p><div class="note"><p class="prefix"><b>Note:</b></p><p>Consecutive tokens need not be separated by either punctuation or
space, and tokens may overlap.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>In some natural languages, tokens and words can be used
interchangeably.</p></div><p>
               [<a name="SentenceDef" id="SentenceDef" title="Sentence">Definition</a>: A <b>sentence</b> is an ordered sequence
of any number of tokens. 
Beyond that, sentences are <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>. 
A tokenizer is not required to support sentences.]
            </p><p>
               [<a name="ParagraphDef" id="ParagraphDef" title="Paragraph">Definition</a>: A <b>paragraph</b> is an ordered sequence
of any number of tokens. 
Beyond that, paragraphs are <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>. 
A tokenizer is not required to support paragraphs.]
            </p><p>
Some XML elements represent semantic markup, e.g., &lt;title&gt;. 
Others represent formatting markup, e.g., &lt;b&gt; to indicate bold. 
Semantic markup serves well as token boundaries. 
Some formatting markup serves well as token boundaries;
for example, paragraphs are most commonly delimited by formatting markup. 
Other formatting markup may not serve well as token boundaries. 
Implementations are free to provide <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> ways to differentiate between 
the markup's effect on token boundaries during tokenization. 
In the absence of an implementation-defined way to differentiate, element markup
(start tags, end tags, and empty-element tags) creates token boundaries.
</p><p>
A sample tokenization is used for the examples in this document. 
The results might be different for other tokenizations. </p><p>Tokenization enables functions and operators that operate on a
part or the root of the token (e.g., wildcards, stemming). </p><p>Tokenization enables functions and operators which work with the
relative positions of tokens (e.g., proximity operators). </p><p>
This specification focuses on functionality that serves all
languages. It also selectively includes functionalities useful within
specific families of languages. For example, searching within
sentences and paragraphs is useful to many western languages and to
some non-western languages, so that functionality is incorporated into
this specification.
</p><p>Certain aspects of language
		processing are described in this specification as
		<b>implementation-defined</b> or
		<b>implementation-dependent</b>.</p><ul><li><p>
                     [<a name="dt-implementation-defined" id="dt-implementation-defined" title="implementation defined">Definition</a>: 
                        <b>Implementation-defined</b>
		indicates an aspect that may differ between
		implementations, but must be specified by the
		implementor for each particular
		implementation.]
                  </p></li><li><p>
                     [<a name="dt-implementation-dependent" id="dt-implementation-dependent" title="implementation   dependent">Definition</a>: 
                        <b>Implementation-dependent</b>
		indicates an aspect that may differ between
		implementations, is not specified by this or any W3C
		specification, and is not required to be specified by
		the implementor for any particular
		implementation.]
                  </p></li></ul></div><div class="div2">
<h3><a name="tq-ft-organization" id="tq-ft-organization"/>1.2 Organization of this document</h3><p>This document is organized as follows. We first present a <a href="#tq-extensions">high level syntax</a> for the XQuery and XPath Full Text 1.0
language along with some examples. Then, we present the <a href="#ftselections">syntax and examples</a> of the
basic primitives in the XQuery and XPath Full Text 1.0 language. This is followed by the
<a href="#tq-semantics">semantics</a> of the XQuery and XPath Full Text 1.0
language. The appendix contains a section that provides an <a href="#id-xpath-grammar">EBNF for the XPath 2.0 Grammar with Full-Text
Extensions</a>, an <a href="#id-grammar">EBNF for XQuery 1.0
Grammar with Full-Text Extensions</a>, <a href="#ft-acknowledgements">acknowledgements</a> and a <a href="#ft-glossary">glossary</a>.</p></div><div class="div2">
<h3><a name="tq-ft-namespaces" id="tq-ft-namespaces"/>1.3 A word about namespaces</h3><p>Certain namespace prefixes are predeclared by XQuery 1.0 and, by implication, by this specification,
and bound to fixed namespace URIs. These namespace prefixes are as follows:
</p><ul><li><p>
                     <code>xml = http://www.w3.org/XML/1998/namespace</code>
                  </p></li><li><p>
                     <code>xs = http://www.w3.org/2001/XMLSchema</code>
                  </p></li><li><p>
                     <code>xsi = http://www.w3.org/2001/XMLSchema-instance</code>
                  </p></li><li><p>
                     <code>fn = http://www.w3.org/2005/xpath-functions</code>
                  </p></li><li><p>
                     <code>local = http://www.w3.org/2005/xquery-local-functions</code>
                  </p></li></ul><p>
In addition to the prefixes in the above list, this document uses the prefix
<code>err</code> to represent the namespace URI <code>http://www.w3.org/2005/xqt-errors</code>, 
This namespace prefix is not predeclared and its use in this document is not normative. 
Error codes that are not defined in this document are defined in other XQuery 1.0 and XPath 2.0
specifications, particularly <a href="#xpath20">[XML Path Language (XPath) 2.0 (Second Edition)]</a> and <a href="#xpath-functions">[XQuery 1.0 and XPath 2.0 Functions and Operators (Second Edition)]</a>. 
</p><p>
Finally, this document uses the prefix <code>fts</code> to represent a namespace
containing a number of functions used in this document to describe the semantics
of XQuery and XPath Full Text functions. There is no
requirement that these functions be implemented, therefore no URI is associated with that prefix. 
</p></div></div><div class="div1">
<h2><a name="tq-extensions" id="tq-extensions"/>2 Full-Text Extensions to XQuery and XPath</h2><p>XQuery and XPath Full Text 1.0 extends the languages of XQuery 1.0 and XPath 2.0 in three ways. It:</p><ol class="enumar"><li><p>Adds a new expression called FTContainsExpr;</p></li><li><p>Enhances the syntax of FLWOR expressions in XQuery 1.0 and
  <code>for</code> expressions in XPath 2.0 with optional score
  variables; and</p></li><li><p>Adds static context declarations for full-text match
  options to the query prolog.</p></li></ol><p>Additionally, it extends the data model and processing models in
various ways.</p><div class="div2">
<h3><a name="processing-model" id="processing-model"/>2.1 Processing Model</h3><p>
A <a title="full-text contains expression" href="#dt-ftcontains">full-text contains expression</a>
(<a href="#section-ftcontainsexpr"><b>2.2 Full-Text Contains Expression</b></a>)
is composed of several parts:</p><ol class="enumar"><li><p>
  An XPath 2.0 or XQuery 1.0 expression (RangeExpr) that
  specifies the sequence of items to be searched. 
  [<a name="dt-search-context" id="dt-search-context" title="search context">Definition</a>: 
  Those items are called
  the <b>search context</b>.]
                  </p></li><li><p>
  The full-text selection to be applied (<a href="#ftselections"><b>3 Full-Text Selections</b></a>).
  <b>Full-text selections</b> 
  are, syntactically and semantically, fully composable and contain:
  </p><ul><li><p>
    Required:</p><ul><li><p>
      Tokens and phrases for which a search is performed (<a href="#ftwords"><b>3.2 Search Tokens and Phrases</b></a>).</p></li></ul></li><li><p>
    Optional:</p><ul><li><p>
      Match options, such as indicators for case sensitivity and stop
      words (<a href="#ftmatchoptions"><b>3.4 Match Options</b></a>);</p></li><li><p>
      Boolean full-text operators, that compose a full-text selection from
      simpler full-text selections (<a href="#logical_ftoperators"><b>3.5 Logical Full-Text Operators</b></a>);</p></li><li><p>
      Other full-text operators that are constraints on the positions of
      matches, such as indicators for distance between tokens and for the
      cardinality of matches (<a href="#ftposfilter"><b>3.6 Positional Filters</b></a> and 
      <a href="#fttimes"><b>3.3 Cardinality Selection</b></a>); and</p></li><li><p>
      The weighting information. Each individual search term in a
      full-text selection may be annotated with optional weight
      information. This information may be used during the evaluation
      of the full-text selections to
      calculate scoring, information that quantifies the relevance of the
      result to the given search criteria.</p></li></ul></li></ul></li><li><p>
  An optional XPath 2.0 or XQuery 1.0 expression (UnionExpr) that
  specifies the set of nodes, descendents of the RangeExp, whose
  contents must be ignored for the purpose of determining a match
  during the search (<a href="#ftignoreoption"><b>3.7 Ignore Option</b></a>).</p></li></ol><p>
The results of the evaluation of the full-text selection operators are
instances of the AllMatches model, which complements the XQuery Data
Model (XDM) for processing full-text queries. An AllMatches instance
describes all possible solutions to the full-text query for a given
search context item. Each solution is described by a Match instance. A
Match instance contains the tokens from the search context that must
be included (described using StringInclude instances which model the
positive terms) and the tokens from search context item that must be
excluded (described using StringExclude instances which model the
negative terms). Each negative or positive term is modeled as a tuple:
the position of the query token or phrase in the full-text selection, and a
TokenInfo structure that describes a set of tokens in the text string which match the query token or phrase.
</p><img src="images/ProcMod-XQueryFT.gif" alt="Processing Model Extensions"/><p>Figure 1 provides a schematic overview of the XQuery and XPath Full Text 1.0 processing steps that are discussed in detail below. 
Some of these steps are completely outside the domain of XQuery; in
Figure 1, these are depicted outside the black line that represents
the boundaries of the language. The diagram only shows the central pieces
of the XQuery Processing Model (see <a href="http://www.w3.org/TR/xquery/#id-processing-model">Section 
2.2 Processing
                         Model</a><sup><small>XQ</small></sup>), however zooms in on the Execution Engine
where the processing of the full-text extensions takes place. The
full-text processing steps are labeled as FTn within the diagram and
are referenced within the text.</p><p>
Like all XQuery expressions, an FTContainsExpr returns an XDM
Instance (see Fig. 1). With the exception of FTWords, which consumes TokenInfos,
all full-text selections are closed under the AllMatches data model,
i.e., their input and output are AllMatches instances. Tokenization transforms an XDM
instance into TokenInfos, which ultimately get converted into AllMatches
instances by the evaluation of full-text selections. Thus, the evaluation of
nested full-text and XQuery expressions instances moves back and forth
between these two models.
</p><p>
The resulting AllMatches instance obtained by the evaluation of an FTContainsExpr 
is converted into a Boolean value before being
returned to the enclosing XPath or XQuery operation as follows. If at
least one member of the disjunction contains only positive terms then
value returned is true. If all members of the disjunction contain
negative terms the result is false.
</p><p>
Weighting information, in an <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> fashion, may be
used when calculating the scoring information computed and made
available by FTContainsExpr to the optional score construct.
</p><p>
Given the components of a given full-text contains expression, the evaluation
algorithm will proceed according to the following steps, also referenced in
the processing model diagram as steps FT<em>n</em> (see Fig. 1):
</p><ol class="enumar"><li><p>
  Evaluate the search context expression
  (resulting in the sequence of search context items),
  the ignore option, if any
  (resulting in the set of ignored nodes),
  and any other XQuery/XPath exprssions nested within the full-text contains expression.
  (FT1)
  </p></li><li><p>
  Tokenize the query string(s). (FT2.1)</p></li><li><p>
  For each search context item:</p><ol class="enumla"><li><p>
  Delete the ignored nodes from the search context item.</p></li><li><p>
    Tokenize the result of the previous step.
    This produces a sequence of tokens. (FT2.2)
    Note that implementations may (as an optimization) perform tokenization
    as part of the External Processing that is described in the XQuery Processing Model,
    when an XML document is parsed into an Infoset/PSVI
    and ultimately into a XQuery Data Model instance.</p></li><li><p>
    Evaluate the FTSelection against the tokens of the search context. (FT3, FT4)</p></li></ol></li><li><p>
  Convert the topmost AllMatches instances into a Boolean value. (FT5)</p><p>
  The additional scoring information (also part of FT5) that is produced
  by the evaluation 
  of the full-text contains expression is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> and is not
  specified in this document. The scoring information is made available at the same time the
  Boolean value is returned.
  </p></li></ol><p>
(A more detailed version of the above procedure
appears in Section <a href="#FTContainsSec"><b>4.3 FTContainsExpr</b></a>.)
</p><p>
Section <a href="#ftselections"><b>3 Full-Text Selections</b></a>
describes the syntax and the informal semantics of full-text operators. 
Their formal semantics as well as the formal definition of the
AllMatches data model are given in Section <a href="#tq-semantics"><b>4 Semantics</b></a>.
</p></div><div class="div2">
<h3><a name="section-ftcontainsexpr" id="section-ftcontainsexpr"/>2.2 Full-Text Contains Expression</h3><p>
               [<a name="dt-ftcontains" id="dt-ftcontains" title="full-text contains expression">Definition</a>: A
<b>full-text contains expression</b> is a expression that evaluates a
sequence of items against a full-text selection.
]
            </p><p>As a syntactic construct, a full-text contains expression
(grammar symbol: <a href="#doc-xquery10-FTContainsExpr">FTContainsExpr</a>) 
behaves like a
comparison expression (see <a href="http://www.w3.org/TR/xquery/#id-general-comparisons">Section 
3.5.2 General Comparisons</a><sup><small>XQ</small></sup>).
This grammar rule introduces <a href="#doc-xquery10-FTContainsExpr">FTContainsExpr</a>.</p><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="noid_d4e645.doc-xquery10-ComparisonExpr" id="noid_d4e645.doc-xquery10-ComparisonExpr"/>[50]   </td><td><code><a href="#prod-xquery10-ComparisonExpr">ComparisonExpr</a></code></td><td>   ::=   </td><td><code>
                     <a href="#doc-xquery10-FTContainsExpr">FTContainsExpr</a> ( (<a href="#prod-xquery10-ValueComp">ValueComp</a>
                     <br/>|  <a href="#prod-xquery10-GeneralComp">GeneralComp</a>
                     <br/>|  <a href="#prod-xquery10-NodeComp">NodeComp</a>)  <a href="#doc-xquery10-FTContainsExpr">FTContainsExpr</a> )?</code></td></tr></tbody></table><p>A full-text contains expression may be used anywhere a
ComparisonExpr may be 
used. The <code>contains text</code> operator has higher precedence than
other comparison operators,  so the results of <code>contains text</code>
expressions may be compared without enclosing them in parentheses.</p><div class="div3">
<h4><a name="section-ftcontainsexpr-description" id="section-ftcontainsexpr-description"/>2.2.1 Description</h4><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTContainsExpr" id="doc-xquery10-FTContainsExpr"/>[51]   </td><td><code><a href="#prod-xquery10-FTContainsExpr"><a href="#prod-xquery10-FTContainsExpr">FTContainsExpr</a></a></code></td><td>   ::=   </td><td><code>
                        <a href="#prod-xquery10-RangeExpr">RangeExpr</a> ( "contains"  "text"  <a href="#doc-xquery10-FTSelection">FTSelection</a>  
                        <a href="#doc-xquery10-FTIgnoreOption">FTIgnoreOption</a>? )?</code></td></tr></tbody></table><p>A full-text contains expression returns a Boolean
value. It returns true if there is some item returned by
the RangeExpr that, after 
<a href="#TokenizationSec">tokenization</a>, 
matches the full-text selection <a href="#doc-xquery10-FTSelection">FTSelection</a>. 
Since tokenization includes tokens derived only from the string values of
items, a full-text contains expression searches the text of element nodes
and of their descendant elements. The string value of other kinds of nodes,
such as attributes and comments, will not be included unless the attribute or
comment node itself is the target (RangeExpr) of the full-text contains
expression. 
See Section <a href="#ftselections"><b>3 Full-Text Selections</b></a> for more details. 
For the purpose of determining
a match, certain descendants of nodes (identified by 
<a href="#doc-xquery10-FTIgnoreOption">FTIgnoreOption</a>) in 
the RangeExpr may be ignored, as specified in Section
<a href="#ftignoreoption"><b>3.7 Ignore Option</b></a>.</p><p>An XQuery and XPath Full Text 1.0 processor <a title="should" href="#should">SHOULD</a> try to use the
information available in xml:lang for processing of collations, as well as
the various match options defined in Section <a href="#ftmatchoptions"><b>3.4 Match Options</b></a>. 
</p></div><div class="div3">
<h4><a name="section-ftcontainsexpr-examples" id="section-ftcontainsexpr-examples"/>2.2.2 Examples</h4><p>The following example in XQuery 1.0 Full Text returns the author of
each book with a title containing a token with the same root as
<code>dog</code> and the token
<code>cat</code>.

		</p><div class="xquery"><div class="exampleInner"><pre>
for $b in /books/book
where $b/title contains text ("dog" using stemming) ftand "cat" 
return $b/author</pre></div></div><p>The same example in XPath 2.0 Full Text is written as:

		</p><div class="xpath"><div class="exampleInner"><pre>

/books/book[title contains text ("dog" using stemming) ftand "cat"]/author</pre></div></div><p>In the next example a ComparisonExpr is combined with an FTContainsExpr 
using the logical XQuery operator <code>and</code>. The query
selects books that have a price of less than 50 and a title which contains 
a token with the same root as <code>train</code>:</p><div class="xquery"><div class="exampleInner"><pre>
/books/book[price &lt; 50 and title contains text ("train" using stemming)]
</pre></div></div><p>The following example shows the combination of two <code>contains text</code>
expressions the results of which are compared using the not-equals operator. 
The query
selects books where either the title contains the token
<code>dog</code> and the token <code>cat</code> and the content
does not contain a token with the same root as <code>train</code>, or where the
title fails to have one of the matching tokens but the content does:</p><div class="xquery"><div class="exampleInner"><pre>
/books/book[title contains text "dog" ftand "cat" ne
            content contains text ("train" using stemming)]
</pre></div></div></div></div><div class="div2">
<h3><a name="section-score-variables" id="section-score-variables"/>2.3 Score Variables</h3><p>Besides specifying a match of a full-text 
        query as a Boolean condition, full-text query applications
        typically also have the ability to associate scores with
        the results. [<a name="Score" id="Score" title="Score">Definition</a>: The <b>score</b> of a full-text query result expresses its relevance to
        the search conditions.]
            </p><p>XQuery and XPath Full Text 1.0 extends the languages of
        XQuery 1.0 and XPath 2.0 further  by adding optional 
        <code>score</code> variables to the <code>for</code> and
        <code>let</code> clauses of FLWOR expressions.</p><p>The production for the extended <code>for</code> clause in XQuery 1.0 follows.


</p><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery10-ForClause" id="doc-xquery10-ForClause"/>[35]   </td><td><code><a href="#prod-xquery10-ForClause"><a href="#prod-xquery10-ForClause">ForClause</a></a></code></td><td>   ::=   </td><td><code>"for"  "$"  <a href="#prod-xquery10-VarName">VarName</a>  
                        <a href="#prod-xquery10-TypeDeclaration">TypeDeclaration</a>?  <a href="#prod-xquery10-PositionalVar">PositionalVar</a>?  <a href="#doc-xquery10-FTScoreVar">FTScoreVar</a>?  "in"  <a href="#prod-xquery10-ExprSingle">ExprSingle</a>  (","  "$"  <a href="#prod-xquery10-VarName">VarName</a>  
                        <a href="#prod-xquery10-TypeDeclaration">TypeDeclaration</a>?  <a href="#prod-xquery10-PositionalVar">PositionalVar</a>?  <a href="#doc-xquery10-FTScoreVar">FTScoreVar</a>?  "in"  <a href="#prod-xquery10-ExprSingle">ExprSingle</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTScoreVar" id="doc-xquery10-FTScoreVar"/>[37]   </td><td><code><a href="#prod-xquery10-FTScoreVar"><a href="#prod-xquery10-FTScoreVar">FTScoreVar</a></a></code></td><td>   ::=   </td><td><code>"score"  "$"  <a href="#prod-xquery10-VarName">VarName</a>
                     </code></td></tr></tbody></table><p>In XPath 2.0, the SimpleForClause is extended similarly.</p><p>When a <code>score</code> variable is present in a <code>for</code> 
clause the evaluation of the expression following the <code>in</code>
keyword not only needs to determine the result sequence of the
expression, i.e., the sequence of items which are iteratively
bound to the <code>for</code> variable. It must also determine in each
iteration the relevance "score" value of the current item
and bind the <code>score</code> variable to that value. </p><p>
The scope of a score variable bound in a for or let clause comprises all
subexpressions of the containing FLWOR expression that appear after the
variable binding. The scope does not include the expression to which the
variable is bound.
The for and let clauses of a given FLWOR expression may bind the same score
variable name more than once. In this case, each new binding occludes the
previous one, which becomes inaccessible in the remainder of the FLWOR
expression. 
</p><p>
The expanded QName of a score variable bound in a for clause must be distinct
from both the expanded 
QName of the variable with which it is associated and the expanded QName of any
positional variable with which it is associated
[<a href="http://www.w3.org/TR/xquery/#ERRXQST0089" title="err:XQST0089">err:XQST0089</a>]<sup><small>XQ</small></sup>.
</p><p>The semantics of scoring and how it relates to second-order functions is 
discussed in Section <a href="#ScoreSec"><b>4.4 Scoring</b></a>.</p><p>In the following example <code>book</code> elements are determined that satisfy
the condition <code>[content contains text "web site" ftand "usability" and
.//chapter/title contains text "testing"]</code>. The scores assigned to the
<code>book</code> elements are returned.

		</p><div class="xquery"><div class="exampleInner"><pre>
for $b score $s 
    in /books/book[content contains text "web site" ftand "usability" 
                   and .//chapter/title contains text "testing"]
return $s
</pre></div></div><p>The example above is
also a valid example of the XPath 2.0 extension.</p><p>Scores are typically used to order results, as in the 
following, more complete example.
		</p><div class="xquery"><div class="exampleInner"><pre>
for $b score $s 
    in /books/book[content contains text "web site" ftand "usability"]
where $s &gt; 0.5
order by $s descending
return &lt;result&gt;  
          &lt;title&gt; {$b//title} &lt;/title&gt; 
          &lt;score&gt; {$s} &lt;/score&gt; 
       &lt;/result&gt;
</pre></div></div><p>Note that the score variable gets <em>one</em> score value for each item
in the value of the expression after the <code>in</code> keyword,
regardless of the number of FTContainsExprs in that expression. 
In the following example, two separate full-text contains expressions are
used to select the matching paragraphs. There is still just one score for each
<code>para</code> returned.  The highest scoring paragraphs will be returned
first:
</p><div class="xquery"><div class="exampleInner"><pre>
for $p score $s in 
  //book[title contains text "software"]/para[. contains text "usability"]
     order by $s descending
  return $p
</pre></div></div><p>The following more elaborate example uses multiple score variables to
return the matching paragraphs ordered so that those from the highest scoring
books precede those from the lowest scoring books, where the highest scoring
paragraphs of each book are returned before the lower scoring paragraphs of
that book:
</p><div class="xquery"><div class="exampleInner"><pre>
for $b score $score1 in //book[title contains text "software"]
    order by $score1 descending
return
    for $p score $score2 in $b/para[. contains text "usability"]
       order by $score2 descending
    return $p
</pre></div></div><p>The <code>score</code> variable is bound to a value which reflects
the relevance of the match criteria in the 
full-text selections to the items returned by the respective RangeExprs. The
calculation of relevance is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>, but score
evaluation must follow these rules:</p><ol class="enumar"><li><p>Score values are of type <code>xs:double</code> in the range
[0, 1].</p></li><li><p>For score values greater than 0, a higher score must imply a
higher degree of relevance </p></li></ol><p>Similarly to their use in a <code>for</code> clause, score variables
may be specified in a <code>let</code> clause. A score variable in a
<code>let</code> clause is also bound to the score of the expression
evaluation, but in the <code>let</code> clause one score is determined
for the complete result. </p><p>The production for the extended <code>let</code> clause follows.


</p><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery10-LetClause" id="doc-xquery10-LetClause"/>[38]   </td><td><code><a href="#prod-xquery10-LetClause"><a href="#prod-xquery10-LetClause">LetClause</a></a></code></td><td>   ::=   </td><td><code>"let"  (("$"  <a href="#prod-xquery10-VarName">VarName</a>  
                        <a href="#prod-xquery10-TypeDeclaration">TypeDeclaration</a>?)  |  <a href="#doc-xquery10-FTScoreVar">FTScoreVar</a>)  ":="  <a href="#prod-xquery10-ExprSingle">ExprSingle</a>  (","  (("$"  <a href="#prod-xquery10-VarName">VarName</a>  
                        <a href="#prod-xquery10-TypeDeclaration">TypeDeclaration</a>?)  |  <a href="#doc-xquery10-FTScoreVar">FTScoreVar</a>)  ":="  <a href="#prod-xquery10-ExprSingle">ExprSingle</a>)*</code></td></tr></tbody></table><p>When using the score option in a <code>for</code> clause the
expression following the <code>in</code> keyword has the dual purpose
of filtering, i.e., driving the iteration, and determining the scores. 
It is possible to separately specify expressions for filtering and
scoring by combining a simple <code>for</code> clause with a
<code>let</code> clause that uses scoring. The following is 
an example of this.

		</p><div class="xquery"><div class="exampleInner"><pre>
for $b in /books/book[.//chapter/title contains text "testing"]
let score $s := $b/content contains text "web site" ftand "usability" 
order by $s descending
return &lt;result score="{$s}"&gt;{$b}&lt;/result&gt;
</pre></div></div><p>
This example returns <code>book</code> elements with chapter titles that contain "testing". 
Along with the <code>book</code> elements scores are returned. 
These scores, however, reflect whether the book content contains "web site" and "usability".</p><p>Note that it is not a requirement of the score of an 
FTContainsExpr to be 0, if the expression evaluates to false, nor to
be non-zero, if the expression evaluates to true.
Hence, in the example above it is not possible to infer the Boolean
value of the FTContainsExpr in the <code>let</code> clause from the
calculated score of a returned <code>result</code> element. For instance, an
implementation may want to assign a non-zero score to a book that
contained "web site", but not "usability", as this may be
considered more relevant than a book that does not contain "web site" or "usability".
</p><p>
The expression ExprSingle associated with the score variable is passed to
the scoring algorithm. 
The scoring algorithm calculates the score value based on the passed expression
(not on the value returned by evaluating the expression). 
The set of expressions supported by the scoring algorithm is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>. 
If an expression not supported by the scoring algorithm is passed to the scoring algorithm,
the result is implementation-defined.
</p><p>The use of <code>score</code> variables introduces a second-order
aspect to the evaluation of expressions which cannot be emulated by
(first-order) XQuery functions. Consider the following replacement of
the clause <code>let score $s := FTContainsExpr</code>
            </p><div class="exampleInner"><pre>
let $s := score(FTContainsExpr)
</pre></div><p>where a function <code>score</code> is applied to some
FTContainsExpr. If the function <code>score</code> were first-order, it
would only be applied to the result of the evaluation of 
its argument, which is one of the Boolean constants <code>true</code>
or <code>false</code>. Hence, there would be at most two possible
values such a <code>score</code> function would be able to return and
no further differentiation would be possible. </p><div class="div3">
<h4><a name="section-using-weights" id="section-using-weights"/>2.3.1 Using Weights Within a Scored FTContainsExpr</h4><p>
                  [<a name="WeightDeclarationsDef" id="WeightDeclarationsDef" title="WeightDeclarations">Definition</a>: Scoring may be influenced
by adding <b>weight declarations</b> to search tokens, phrases, and expressions.] 
Weight declarations are introduced syntactically in the FTPrimaryWithOptions
production, described in Section <a href="#ftweight"><b>3.1.1 Weights</b></a>.
</p><p>The weights assigned are not related to any absolute standard,
but typically have a relationship to other weights within the same FTContains expression.</p><p>The effect of weights on the resulting score is
<a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>. However, scoring algorithms <a title="must" href="#must">MUST</a> conform to 
the constraint<span class="diff-del">s:</span> 
                  <span class="diff-add">that when no explicit weight is specified, the default weight is 1.0.</span>
               </p><div class="diff-del"><ol class="enumar"><li><p>When no explicit weight is specified, the default weight is
1.0; and</p></li><li><p>
Weight declarations in an FTContainsExpr for which no scores are
evaluated are ignored. 
</p></li></ol></div><p>The following example illustrates how different weights can be used
for different search terms.
		</p><div class="xquery"><div class="exampleInner"><pre>
for $b in /books/book
let score $s := $b/content contains text ("web site" weight {0.5})
                                ftand ("usability" weight {2})
return &lt;result score="{$s}"&gt;{$b}&lt;/result&gt;
</pre></div></div></div></div><div class="div2">
<h3><a name="section-extensions-static-context" id="section-extensions-static-context"/>2.4 Extensions to the Static Context</h3><p>
The XQuery Static Context is extended with a component for each
full-text <a title="match option group" href="#dt-match-option-group">match option group</a>.
The settings of these components can be changed
by using the following declaration syntax in the Prolog.
</p><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery10-Prolog" id="doc-xquery10-Prolog"/>[6]   </td><td><code><a href="#prod-xquery10-Prolog"><a href="#prod-xquery10-Prolog">Prolog</a></a></code></td><td>   ::=   </td><td><code>((<a href="#prod-xquery10-DefaultNamespaceDecl">DefaultNamespaceDecl</a>  |  <a href="#prod-xquery10-Setter">Setter</a>  |  <a href="#prod-xquery10-NamespaceDecl">NamespaceDecl</a>  |  <a href="#prod-xquery10-Import">Import</a>  |  <a href="#doc-xquery10-FTOptionDecl">FTOptionDecl</a>)  <a href="#prod-xquery10-Separator">Separator</a>)*  ((<a href="#prod-xquery10-VarDecl">VarDecl</a>  |  <a href="#prod-xquery10-FunctionDecl">FunctionDecl</a>  |  <a href="#prod-xquery10-OptionDecl">OptionDecl</a>)  <a href="#prod-xquery10-Separator">Separator</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTOptionDecl" id="doc-xquery10-FTOptionDecl"/>[24]   </td><td><code><a href="#prod-xquery10-FTOptionDecl"><a href="#prod-xquery10-FTOptionDecl">FTOptionDecl</a></a></code></td><td>   ::=   </td><td><code>"declare"  "ft-option"  <a href="#doc-xquery10-FTMatchOptions">FTMatchOptions</a>
                     </code></td></tr></tbody></table><p>
Match options modify the match semantics of full-text
expressions. They are described in detail in  
Section <a href="#ftmatchoptions"><b>3.4 Match Options</b></a>. When a match
option is specified explicitly in a full-text expression,
it overrides the setting of the respective component in the
static context.
</p></div></div><div class="div1">
<h2><a name="ftselections" id="ftselections"/>3 Full-Text Selections</h2><p>This section describes the
full-text selections which contain the full-text
operators in a <a title="full-text contains expression" href="#dt-ftcontains">full-text contains
expression</a>  
(<a href="#doc-xquery10-FTContainsExpr">FTContainsExpr</a>), as 
well as the match options which modify the matching semantics of the 
full-text selections. In the following, the syntax for each type of
full-text selection is given together with an informal statement of
its meaning.</p><p>
            [<a name="ftselection" id="ftselection" title="full-text selection">Definition</a>: A 
<b>full-text selection</b> specifies the conditions of a full-text search.
]
         </p><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTSelection" id="doc-xquery10-FTSelection"/>[144]   </td><td><code><a href="#prod-xquery10-FTSelection"><a href="#prod-xquery10-FTSelection">FTSelection</a></a></code></td><td>   ::=   </td><td><code>
                  <a href="#doc-xquery10-FTOr">FTOr</a>  
                  <a href="#doc-xquery10-FTPosFilter">FTPosFilter</a>*</code></td></tr></tbody></table><p>As shown in the grammar, a full-text selection consists of search 
conditions possibly involving logical operators (<a href="#doc-xquery10-FTOr">FTOr</a>), followed by an 
arbitrary number of positional filters (<a href="#doc-xquery10-FTPosFilter">FTPosFilter</a>).
</p><p>The syntax and semantics of the individual full-text selection
operators follow.</p><p>This XML document
is the source document for examples in this section. </p><div class="exampleInner"><pre>
&lt;books&gt;
  &lt;book number="1"&gt;
    &lt;title shortTitle="Improving Web Site Usability"&gt;Improving  
        the Usability of a Web Site Through Expert Reviews and
        Usability Testing&lt;/title&gt;
    &lt;author&gt;Millicent Marigold&lt;/author&gt;
    &lt;author&gt;Montana Marigold&lt;/author&gt;
    &lt;editor&gt;Véra Tudor-Medina&lt;/editor&gt;
    &lt;content&gt;
      &lt;p&gt;The usability of a Web site is how well the  
          site supports the users in achieving specified  
          goals. A Web site should facilitate learning,  
          and enable efficient and effective task  
          completion, while propagating few errors.
      &lt;/p&gt;
      &lt;note&gt;This book has been approved by the Web Site  
          Users Association.
      &lt;/note&gt;
    &lt;/content&gt;
  &lt;/book&gt;
&lt;/books&gt;
</pre></div><p>Tokenization is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>. A sample tokenization is
used for the examples in this section. 
This sample tokenization uses white space, punctuation and XML tags as word-breakers<span class="diff-add">, periods followed by a space as sentence boundaries,</span> and 
<code>&lt;p&gt;</code> for paragraph boundaries. <span class="diff-add">The first sentence and paragraph start at the beginning of the document, and the last sentence and paragraph end at the end of the document.</span>
The results may be different
for other tokenizations.</p><p>The first five tokens in this example using the sample tokenization would be "Improving", "the", "usability", "of", and "a".</p><p>Unless stated otherwise, the results
assume a case-insensitive match.</p><div class="div2">
<h3><a name="ftprimary" id="ftprimary"/>3.1 Primary Full-Text Selections</h3><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTPrimary" id="doc-xquery10-FTPrimary"/>[151]   </td><td><code><a href="#prod-xquery10-FTPrimary"><a href="#prod-xquery10-FTPrimary">FTPrimary</a></a></code></td><td>   ::=   </td><td><code>(<a href="#doc-xquery10-FTWords">FTWords</a>  
                     <a href="#doc-xquery10-FTTimes">FTTimes</a>?)  |  ("("  <a href="#doc-xquery10-FTSelection">FTSelection</a>  ")")  |  <a href="#doc-xquery10-FTExtensionSelection">FTExtensionSelection</a>
                  </code></td></tr></tbody></table><p>
               [<a name="dt-ftprimary" id="dt-ftprimary" title="primary full-text selection">Definition</a>: A 
<b>primary full-text selection</b> is the basic form of a 
full-text selection. It specifies tokens and phrases as search 
conditions (<a href="#doc-xquery10-FTWords">FTWords</a>), optionally followed by a cardinality constraint 
(<a href="#doc-xquery10-FTTimes">FTTimes</a>). An <a href="#doc-xquery10-FTSelection">FTSelection</a> 
in parentheses and the <a href="#doc-xquery10-FTExtensionSelection">FTExtensionSelection</a>
are also a primary full-text selections.]
            </p><div class="div3">
<h4><a name="ftweight" id="ftweight"/>3.1.1 Weights</h4><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="noid_d4e1070.doc-xquery10-FTPrimaryWithOptions" id="noid_d4e1070.doc-xquery10-FTPrimaryWithOptions"/>[150]   </td><td><code><a href="#prod-xquery10-FTPrimaryWithOptions">FTPrimaryWithOptions</a></code></td><td>   ::=   </td><td><code>
                        <a href="#doc-xquery10-FTPrimary">FTPrimary</a>  
                        <a href="#doc-xquery10-FTMatchOptions">FTMatchOptions</a>?  <a href="#doc-xquery10-FTWeight">FTWeight</a>?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTWeight" id="doc-xquery10-FTWeight"/>[145]   </td><td><code><a href="#prod-xquery10-FTWeight"><a href="#prod-xquery10-FTWeight">FTWeight</a></a></code></td><td>   ::=   </td><td><code>"weight"  "{"  <a href="#prod-xquery10-Expr">Expr</a>  "}"</code></td></tr></tbody></table><p>As shown in the grammar, a full-text primary selection
may be optionally followed by match options (which are discussed in
<a href="#ftmatchoptions"><b>3.4 Match Options</b></a>) and
by a "weight" value that is specified using an expression enclosed in braces.
The Expr is evaluated as if it were an argument to a function 
with an expected type <code>xs:double</code>.
The weight <a title="must" href="#must">MUST</a> have an absolute value between 0.0 and 1000.0 inclusive.
If the absolute value of the weight is greater than 1000.0, an
error is raised: [<a href="#ERRFTDY0016" title="err:FTDY0016">err:FTDY0016</a>]. 
</p><div class="note"><p class="prefix"><b>Note:</b></p><div class="diff-add"><p>As a consequence of the flexibility given to implementations 
under <a href="http://www.w3.org/TR/xquery/#id-errors-and-opt">Section 
2.3.4 Errors and
      Optimization</a><sup><small>XQ</small></sup>, it is possible that 
evaluation 
of weight declarations in an FTContainsExpr for which no scores are evaluated
may be skipped by the implementation and errors with them may go unreported.
</p></div></div></div></div><div class="div2">
<h3><a name="ftwords" id="ftwords"/>3.2 Search Tokens and Phrases</h3><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTWords" id="doc-xquery10-FTWords"/>[152]   </td><td><code><a href="#prod-xquery10-FTWords"><a href="#prod-xquery10-FTWords">FTWords</a></a></code></td><td>   ::=   </td><td><code>
                     <a href="#doc-xquery10-FTWordsValue">FTWordsValue</a>  
                     <a href="#doc-xquery10-FTAnyallOption">FTAnyallOption</a>?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTWordsValue" id="doc-xquery10-FTWordsValue"/>[153]   </td><td><code><a href="#prod-xquery10-FTWordsValue"><a href="#prod-xquery10-FTWordsValue">FTWordsValue</a></a></code></td><td>   ::=   </td><td><code>
                     <a href="#prod-xquery10-StringLiteral">StringLiteral</a>  |  ("{"  <a href="#prod-xquery10-Expr">Expr</a>  "}")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTAnyallOption" id="doc-xquery10-FTAnyallOption"/>[155]   </td><td><code><a href="#prod-xquery10-FTAnyallOption"><a href="#prod-xquery10-FTAnyallOption">FTAnyallOption</a></a></code></td><td>   ::=   </td><td><code>("any"  "word"?)  |  ("all"  "words"?)  |  "phrase"</code></td></tr></tbody></table><p>
               <a href="#doc-xquery10-FTWords">FTWords</a> finds matches that contain the specified 
tokens and phrases.</p><p>FTWords consists of two parts: a mandatory <a href="#doc-xquery10-FTWordsValue">
FTWordsValue</a> part and an optional <a href="#doc-xquery10-FTAnyallOption">
FTAnyallOption</a> part. <a href="#doc-xquery10-FTWordsValue">FTWordsValue</a> specifies the tokens and phrases
that must be contained in the matches. <a href="#doc-xquery10-FTAnyallOption">FTAnyallOption</a> specifies how 
containment is checked. </p><p>In general, the tokens and phrases in <a href="#doc-xquery10-FTWordsValue">
FTWordsValue</a> are specified using a nested XQuery expression. 
To simplify notation, the enclosing braces may be omitted if <a href="#doc-xquery10-FTWordsValue">FTWordsValue</a> consists of a single <span class="diff-add">string</span> literal.
</p><p>The following rules specify how an <a href="#doc-xquery10-FTWordsValue">FTWordsValue</a>
matches tokens and phrases. First, the 
<a href="#doc-xquery10-FTWordsValue">FTWordsValue</a> is converted to a sequence of
strings as though it were an argument to a function with the expected
type of <code>xs:string*</code>.
If the sequence is empty, the FTWords yields no matches.
Otherwise, each of those strings is tokenized into a
sequence of tokens as 
described in <a href="#TokenizationSec">Section 4.1 Tokenization</a>.
Then, <a href="#doc-xquery10-FTAnyallOption">FTAnyallOption</a> is checked.</p><p>If <a href="#doc-xquery10-FTAnyallOption">FTAnyallOption</a> is "any", the sequence of tokens for each string is
considered as a phrase.
If the sequence of tokens is empty,
then the phrase contributes nothing to the set of matches for the FTWords.
Otherwise, a match is found in the tokenized form of 
the text being searched, whenever that form contains a subsequence of tokens
that corresponds to the sequence of query tokens in an implementation-defined
way and that subsequence of tokens covers consecutive token positions in 
the tokenized text. If the value of the FTWordsValue contains more 
than one string, 
the different strings are considered to be alternatives, i.e., the search context
must contain at least one of the generated phrases.
Each resulting match will contain exactly one such phrase.</p><p>If <a href="#doc-xquery10-FTAnyallOption">FTAnyallOption</a> is "all", the sequence of tokens for each string is
considered as a phrase.
If any such sequence of tokens is empty, the FTWords yields no matches.
The resulting matches must contain all of the 
generated phrases.</p><p>If <a href="#doc-xquery10-FTAnyallOption">FTAnyallOption</a> is "phrase", the tokens from all the strings are
concatenated in a single sequence, which is considered as a phrase.
If the sequence of tokens is empty, the FTWords yields no matches.
The
resulting matches must contain the generated phrase.</p><p>If <a href="#doc-xquery10-FTAnyallOption">FTAnyallOption</a> is "any word", the tokens from all the strings are
combined into a single set.
If the set is empty, the FTWords yields no matches.
The search context must contain at least
one of the tokens in the set.
Each resulting match will contain exactly one such token.</p><p>If <a href="#doc-xquery10-FTAnyallOption">FTAnyallOption</a> is "all words", the tokens from all the strings are
combined into a single set.
If the set is empty, the FTWords yields no matches.
The resulting matches must contain all
of the tokens in the set.</p><p>If the <a href="#doc-xquery10-FTWordsValue">FTWordsValue</a> evaluates to
a single string, the use of "any", "all", and "phrase" in
<a href="#doc-xquery10-FTAnyallOption">FTAnyallOption</a> produces the same
results.</p><p>If <a href="#doc-xquery10-FTAnyallOption">FTAnyallOption</a> is omitted, "any" is 
the default.</p><p>The following expression returns the sample <code>book</code> element,
because its <code>title</code>
element contains the token "Expert":</p><div class="xpath"><div class="exampleInner"><pre>//book[./title contains text "Expert"]</pre></div></div><p>The following expression returns the sample <code>book</code> element,
because its <code>title</code>
element contains the phrase "Expert Reviews":</p><div class="xpath"><div class="exampleInner"><pre>//book[./title contains text "Expert Reviews"]</pre></div></div><p>The following expression returns the sample <code>book</code> element, 
because its <code>title</code> 
element contains the two tokens "Expert" and "Reviews":</p><div class="xpath"><div class="exampleInner"><pre>//book[./title contains text {"Expert", "Reviews"} all]</pre></div></div><p>The following expression returns false for our sample document, because 
the <code>p</code> element doesn't
contain the phrase "Web Site Usability" although it contains all of the tokens
in the phrase:</p><div class="xpath"><div class="exampleInner"><pre>//book//p contains text "Web Site Usability"</pre></div></div><p>The following expression returns book numbers of <code>book</code> elements by
"Marigold" with a title about "Web Site Usability", sorting them in descending
score order: </p><div class="xquery"><div class="exampleInner"><pre>for $book in /books/book[.//author contains text "Marigold"] 
let score $score := $book/title/@shortTitle contains text "Web Site Usability" 
where $score &gt; 0.8 
order by $score descending
return $book/@number</pre></div></div></div><div class="div2">
<h3><a name="fttimes" id="fttimes"/>3.3 Cardinality Selection</h3><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTTimes" id="doc-xquery10-FTTimes"/>[156]   </td><td><code><a href="#prod-xquery10-FTTimes"><a href="#prod-xquery10-FTTimes">FTTimes</a></a></code></td><td>   ::=   </td><td><code>"occurs"  <a href="#doc-xquery10-FTRange">FTRange</a>  "times"</code></td></tr></tbody></table><p>
               [<a name="dt-cardinality-selection" id="dt-cardinality-selection" title="cardinality selection">Definition</a>: A
<b>cardinality selection</b> consist of an 
<a href="#doc-xquery10-FTWords">FTWords</a> followed
by the <a href="#doc-xquery10-FTTimes">FTTimes</a> postfix operator.]
A cardinality selection selects matches for which the operand 
<a href="#doc-xquery10-FTWords">FTWords</a> is matched a specified number of
times. </p><p>A cardinality selection limits the number of different
matches of <a href="#doc-xquery10-FTWords">FTWords</a> within the
specified range. The semantics of FTRange are described in 
<a href="#ftdistance"><b>3.6.3 Distance Selection</b></a>. </p><p>In the document fragment "very very big":</p><ol class="enumar"><li><p>
The <a href="#doc-xquery10-FTWords">FTWords</a> 
                     <code>"very big"</code> has 1
match consisting of the second "very" and "big".
</p></li><li><p>
The <a href="#doc-xquery10-FTWords">FTWords</a> 
                     <code>{"very", "big"} all</code>
has 2 matches; one consisting of the first "very" and "big", and
the other containing the second "very" and "big".
</p></li><li><p>
The <a href="#doc-xquery10-FTWords">FTWords</a> 
                     <code>{"very", "big"} any</code> 
has 3 matches. 
</p></li></ol><p>The following expression returns the example <code>book</code> element's 
number, because the <code>book</code> element contains 2 or more occurrences 
of "usability":</p><div class="xpath"><div class="exampleInner"><pre>//book[. contains text "usability" occurs at least 2 times]/@number</pre></div></div><p>The following expression returns the empty sequence, because there are 
3 occurrences of <code>{"usability", "testing"} any</code> in the designated 
<code>title</code>:</p><div class="xpath"><div class="exampleInner"><pre>//book[@number="1" and title contains text {"usability", 
"testing"} any occurs at most 2 times] </pre></div></div></div><div class="div2">
<h3><a name="ftmatchoptions" id="ftmatchoptions"/>3.4 Match Options</h3><p>Full-text match options modify the matching behaviour of 
the <a title="primary full-text selection" href="#dt-ftprimary">primary full-text selection</a> to which 
they are applied. </p><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTPrimaryWithOptions" id="doc-xquery10-FTPrimaryWithOptions"/>[150]   </td><td><code><a href="#prod-xquery10-FTPrimaryWithOptions"><a href="#prod-xquery10-FTPrimaryWithOptions">FTPrimaryWithOptions</a></a></code></td><td>   ::=   </td><td><code>
                     <a href="#doc-xquery10-FTPrimary">FTPrimary</a>  
                     <a href="#doc-xquery10-FTMatchOptions">FTMatchOptions</a>?  <a href="#doc-xquery10-FTWeight">FTWeight</a>?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTMatchOptions" id="doc-xquery10-FTMatchOptions"/>[166]   </td><td><code><a href="#prod-xquery10-FTMatchOptions"><a href="#prod-xquery10-FTMatchOptions">FTMatchOptions</a></a></code></td><td>   ::=   </td><td><code>("using"  <a href="#doc-xquery10-FTMatchOption">FTMatchOption</a>)+</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTMatchOption" id="doc-xquery10-FTMatchOption"/>[167]   </td><td><code><a href="#prod-xquery10-FTMatchOption"><a href="#prod-xquery10-FTMatchOption">FTMatchOption</a></a></code></td><td>   ::=   </td><td><code>
                     <a href="#doc-xquery10-FTLanguageOption">FTLanguageOption</a>
                     <br/>|  <a href="#doc-xquery10-FTWildCardOption">FTWildCardOption</a>
                     <br/>|  <a href="#doc-xquery10-FTThesaurusOption">FTThesaurusOption</a>
                     <br/>|  <a href="#doc-xquery10-FTStemOption">FTStemOption</a>
                     <br/>|  <a href="#doc-xquery10-FTCaseOption">FTCaseOption</a>
                     <br/>|  <a href="#doc-xquery10-FTDiacriticsOption">FTDiacriticsOption</a>
                     <br/>|  <a href="#doc-xquery10-FTStopWordOption">FTStopWordOption</a>
                     <br/>|  <a href="#doc-xquery10-FTExtensionOption">FTExtensionOption</a>
                  </code></td></tr></tbody></table><p>
               [<a name="dt-match-options" id="dt-match-options" title="match option">Definition</a>: 
                  <b>Match options</b> modify the set of tokens
      in the query, or how they are matched against tokens in the
      text.] 
            </p><p>
               [<a name="dt-match-option-group" id="dt-match-option-group" title="match option group">Definition</a>: 
Each of the <span class="diff-del">seven</span> alternatives of production 
<a href="#doc-xquery10-FTMatchOption">FTMatchOption</a>
                  <span class="diff-add">other than <a href="#doc-xquery10-FTExtensionOption">FTExtensionOption</a>
                  </span>
corresponds to one <b>match option group</b>. ]
The match options from any given group are mutually exclusive, i.e., 
only one of these settings can be in effect, whereas match options of
different groups can be combined freely.</p><p>
It is a static error
[<a href="#ERRFTST0019" title="err:FTST0019">err:FTST0019</a>] 
if, within a single <a href="#doc-xquery10-FTMatchOptions">FTMatchOptions</a>,
there is more than one match option of any given 
<a title="match option group" href="#dt-match-option-group">match option group</a>.
For example, if the <a href="#doc-xquery10-FTCaseOption">FTCaseOption</a> "lowercase" 
is specified, then "uppercase" cannot also be specified as part of the same 
<a href="#doc-xquery10-FTMatchOptions">FTMatchOptions</a>.
</p><p>Although match options only take effect in the application of 
<a href="#doc-xquery10-FTWords">FTWords</a>, the syntax also allows to specify 
match options that modify the non-primitive full-text selection 
<code>"(" FTSelection ")"</code>. Such a higher-level match option
provides a default for the respective match option group for any
embedded <a href="#doc-xquery10-FTPrimary">FTPrimary</a>, just as
<a href="#doc-xquery10-FTOptionDecl">match option declarations</a>
in the <a href="#doc-xquery10-Prolog">Prolog</a>
provide default match options for the whole query. 
</p><p>
Match options are propagated through the query via the static context.
For each of the seven match option groups,
the static context has a component
that contains one option from that group.
The seven settings are initialized by the implementation
in accordance with the table in 
Appendix <a href="#id-xqft-static-context-components"><b>C Static Context Components</b></a>,
and are modified
by any <a href="#doc-xquery10-FTOptionDecl">FTOptionDecl</a>s
in the <a href="#doc-xquery10-Prolog">Prolog</a>.
The resulting settings are then propagated unchanged
to every <a href="#doc-xquery10-FTContainsExpr">FTContainsExpr</a> in the module
(including those in <code>VarDecl</code>s and <code>FunctionDecl</code>s,
and including any that happen to be nested within
another <code>FTContainsExpr</code>).
At any given <code>FTContainsExpr</code>,
the settings from the static context
are copied to the <code>FTContainsExpr</code>'s inner settings,
which are then propagated down the syntax tree.
At each <a href="#doc-xquery10-FTPrimaryWithOptions">FTPrimaryWithOptions</a>,
the locally specified match options (if any)
overwrite the corresponding inner setting(s).
At each <a href="#doc-xquery10-FTWords">FTWords</a>,
the inner settings are used
as the effective match options
for tokenizing the query strings
and matching them against the tokens in the text.
(These inner settings could be seen
as a parallel set of components in the static context,
but Section <a href="#tq-semantics"><b>4 Semantics</b></a> models them
as structures that get passed as parameters
to various semantic functions.)
</p><p>
Thus, when a match option appears in an <a href="#doc-xquery10-FTSelection">FTSelection</a>,
it applies to the associated <a href="#doc-xquery10-FTPrimary">FTPrimary</a>,
but not to any <code>FTContainsExpr</code>s
that happen to be embedded within that <code>FTPrimary</code>.
Instead, for a nested <code>FTContainsExpr</code>,
the default match options are those declared in the <code>Prolog</code>
or, if not declared in the <code>Prolog</code>,
then supplied by the implementation's initial values. 
</p><p>
An <a href="#doc-xquery10-FTMatchOption">FTMatchOption</a>
applies to the <a href="#doc-xquery10-FTPrimary">FTPrimary</a> that immediately precedes it.
That FTPrimary is either
an <a href="#doc-xquery10-FTWords">FTWords</a> (possibly qualified by an <a href="#doc-xquery10-FTTimes">FTTimes</a>),
an <a href="#doc-xquery10-FTExtensionSelection">FTExtensionSelection</a>, or
a parenthesized <a href="#doc-xquery10-FTSelection">FTSelection</a>.
</p><p>
               [<a name="dt-match-option-order" id="dt-match-option-order" title="match option application order">Definition</a>: 
The order in which effective match options for an 
<a href="#doc-xquery10-FTWords">FTWords</a> are applied 
 is called the <b>match option application order</b>.]
This order is significant
because match options are not always commutative.
For example,
    synonym(stem(word))
is not always the same as
    stem(synonym(word)).
</p><p>
The match option application order is subject to some constraints:
</p><ol class="enumar"><li><p>The Language Option must be applied first</p></li><li><p>The Stemming Option must be applied before the Case Option and the
Diacritics Option</p></li></ol><p>
Aside from these constraints, the full order of the application of match
options is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.
</p><p>
 More information on
their semantics is given in <a href="#FTMatchOptionsSec"><b>4.2.5 Match Options Semantics</b></a>.</p><p>If no match options declarations are present in the prolog and the
implementation does not define any overwriting of the static context
components for the match options, the query:</p><div class="xpath"><div class="exampleInner"><pre>/books/book/title contains text "usability" </pre></div></div><p>is, assuming "de" is the <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> default language,
equivalent to the query:</p><div class="xpath"><div class="exampleInner"><pre>/books/book/title contains text "usability" 
    using language "de"
    using no wildcards
    using no thesaurus
    using no stemming
    using case insensitive 
    using diacritics insensitive 
    using no stop words</pre></div></div><p> We describe each match option group in more detail in the following
sections.</p><div class="div3">
<h4><a name="ftlanguageoption" id="ftlanguageoption"/>3.4.1 Language Option</h4><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTLanguageOption" id="doc-xquery10-FTLanguageOption"/>[177]   </td><td><code><a href="#prod-xquery10-FTLanguageOption"><a href="#prod-xquery10-FTLanguageOption">FTLanguageOption</a></a></code></td><td>   ::=   </td><td><code>"language"  <a href="#prod-xquery10-StringLiteral">StringLiteral</a>
                     </code></td></tr></tbody></table><p>
                  [<a name="dt-ftlanguageoption" id="dt-ftlanguageoption" title="language option">Definition</a>: A 
<b>language option</b> 
modifies token matching by specifying the language of search tokens and 
phrases.]
               </p><p>The StringLiteral following the keyword <code>language</code>
designates one language. It must be castable to <code>xs:language</code>; otherwise, an
error is raised: [<a href="http://www.w3.org/TR/xpath20/#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]<sup><small>XP</small></sup>. </p><p>The "language" option influences tokenization, stemming, and stop
words in an <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> way. The "language" option <a title="may" href="#may">MAY</a> influence the behavior of other match options in an <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> way.</p><p>The set of standardized language identifiers is defined in <a href="#BCP47">[BCP 47]</a>.
The set of valid language identifiers among the standardized set is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>. 
An implementation <a title="may" href="#may">MAY</a> choose to use private extensions introduced by a
singleton 'x' for additional language identifiers, or other singletons
for registered extensions as described in sec. 2.2.6 of <a href="#BCP47">[BCP 47]</a>.
It is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> what additional language identifiers, if any, are valid. 
If an invalid language identifier is specified, then the behavior is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>. 
If the implementation chooses to raise an error in that case,
it must raise [<a href="#ERRFTST0009" title="err:FTST0009">err:FTST0009</a>].
</p><p>The default language is specified in the static context. </p><p>When an XQuery and XPath Full Text processor evaluates text in a document
that is governed by an xml:lang attribute and
the portion of the full-text query doing that evaluation contains an FTLanguageOption that
specifies a different language from the language specified by the governing xml:lang attribute,
the language-related behavior of that full-text query is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>. </p><p>This is an example where
the language option is used to select the appropriate stop word list: </p><div class="xpath"><div class="exampleInner"><pre>//book[@number="1"]/content//p contains text "salon de thé"
using stop words default using language "fr"</pre></div></div></div><div class="div3">
<h4><a name="ftwildcardoption" id="ftwildcardoption"/>3.4.2 Wildcard Option</h4><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTWildCardOption" id="doc-xquery10-FTWildCardOption"/>[178]   </td><td><code><a href="#prod-xquery10-FTWildCardOption"><a href="#prod-xquery10-FTWildCardOption">FTWildCardOption</a></a></code></td><td>   ::=   </td><td><code>"wildcards"  |  ("no"  "wildcards")</code></td></tr></tbody></table><p>
                  [<a name="dt-ftwildcardoption" id="dt-ftwildcardoption" title="wildcard option">Definition</a>: A 
<b>wildcard option</b>
modifies token and phrase matching by specifying whether or not
wildcards are recognized in query strings.]
               </p><p>When the "wildcards" option is used,
wildcard syntax may be included within query strings.
A wildcard consists of
an indicator (a period or full stop, "."),
optionally followed by a qualifier.
Each wildcard in a query token will match zero or more characters
within a token in the text being searched, as described below.
The number of characters that can be matched depends on the qualifier.
The forms of wildcard syntax specified by this document are:
</p><ol class="enumar"><li><p>
A single period, without any qualifiers:
Matches a single arbitrary character.
</p></li><li><p>
A period immediately followed by a single question mark, "?":
Matches either no characters or one character.
</p></li><li><p>
A period immediately followed by a single asterisk, "*":
Matches zero or more characters.
</p></li><li><p>
A period immediately followed by a single plus sign, "+":
Matches one or more characters.
</p></li><li><p>
A period immediately followed by a sequence of characters
that matches the regular expression <code>{[0-9]+,[0-9]+}</code>:
Matches a number of characters, where the number is
no less than
the number represented by the series of digits before the comma,
and
no greater than
the number represented by the series of digits following the comma.
</p><p>
If a period in the query string
is immediately followed by a left curly brace,
but the subsequent characters
do not conform to the given regular expression,
then an error is raised: 
[<a href="#ERRFTDY0020" title="err:FTDY0020">err:FTDY0020</a>]. 
</p></li></ol><p>
A question mark, asterisk, plus sign, or left curly brace
that is not immediately preceded by a period
is not treated as a qualifier.
For example, using the sample tokenization and "wildcards",
the query string "wil+"
does not match the search text "will" or "willlllll",
but only matches the search text "wil".
(The sample tokenization treats the plus sign as punctuation.)
</p><p>
When "wildcards" is used,
any character in a query string
can be "escaped" by immediately preceding it with a backslash, "\".
That is,
a backslash immediately followed by any character
represents that character literally,
preventing any special interpretation
that the "wildcards" option might otherwise attach to it.
In particular:
</p><ol class="enumar"><li><p>
Escaping a period prevents its interpretation as a wildcard.
</p></li><li><p>
Escaping a question mark, asterisk, plus sign, or left curly brace
ensures that it is not interpreted as a qualifier.
</p></li><li><p>
An escaped backslash ("\\") represents a literal backslash.
</p></li><li><p>
If a query string is terminated by an unescaped backslash,
an error is raised:
[<a href="#ERRFTDY0020" title="err:FTDY0020">err:FTDY0020</a>]. 
</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>
A query string of the form <code>"abc\"xyz"</code>
does <em>not</em> represent
the three characters "abc"
followed by a literal double-quote
followed by the three characters "xyz".
Instead, this is a malformed StringLiteral,
and the processor will report a syntax error
[<a href="http://www.w3.org/TR/xpath20/#ERRXPST0003" title="err:XPST0003">err:XPST0003</a>]<sup><small>XP</small></sup>.
</p></div><p>
When the "no wildcards" option is used,
no wildcards are recognized in query strings.
Periods, question marks, asterisks, plus signs, left curly braces,
and backslashes
are always recognized as ordinary text characters.
</p><p>The default is "no wildcards".</p><p>The following expression returns true, because the <code>p</code> element
contains "well":</p><div class="xpath"><div class="exampleInner"><pre>//book[@number="1"]/p contains text "w.ll" using wildcards</pre></div></div><p>The following expression returns true, because the <code>title</code> element
contains "site":</p><div class="xpath"><div class="exampleInner"><pre>//book[@number="1"]/title contains text ".?site" using wildcards</pre></div></div><p>The following expression returns true, because the <code>title</code> element
contains "improving":</p><div class="xpath"><div class="exampleInner"><pre>//book[@number="1"]/title contains text "improv.*" using wildcards</pre></div></div><p>The following expression raises error [<a href="#ERRFTDY0020" title="err:FTDY0020">err:FTDY0020</a>],
because the query string uses incorrect syntax:</p><div class="xpath"><div class="exampleInner"><pre>//book[@number="1"]/p contains text "wi.{5,7]" using wildcards</pre></div></div><p>The following expression returns true,
because the title contains "site":</p><div class="xpath"><div class="exampleInner"><pre>//book[@number="1"]/title contains text "\s\i\t\e" using wildcards</pre></div></div><p>The following expression returns true,
because the title contains "Usability":</p><div class="xpath"><div class="exampleInner"><pre>//book[@number="1"]/title contains text "Usab.+\\" using wildcards</pre></div></div><p>
(Note that "\\" represents a literal backslash,
which the sample tokenization treats as punctuation.)
</p><p>The following expression raises error [<a href="#ERRFTDY0020" title="err:FTDY0020">err:FTDY0020</a>],
because the query string ends with an unescaped backslash:</p><div class="xpath"><div class="exampleInner"><pre>//book[@number="1"]/p contains text "will\" using wildcards</pre></div></div><p>The following expression returns false, because the <code>p</code> element
does not contain the phrase "w ll":</p><div class="xpath"><div class="exampleInner"><pre>//book[@number="1"]/p contains text "w.ll" using no wildcards</pre></div></div><p>
(Note that, without wildcards, the sample tokenization
will treat the period in "w.ll" as punctuation,
thus producing "w" and "ll" as separate tokens.)
</p></div><div class="div3">
<h4><a name="ftthesaurusoption" id="ftthesaurusoption"/>3.4.3 Thesaurus Option</h4><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTThesaurusOption" id="doc-xquery10-FTThesaurusOption"/>[171]   </td><td><code><a href="#prod-xquery10-FTThesaurusOption"><a href="#prod-xquery10-FTThesaurusOption">FTThesaurusOption</a></a></code></td><td>   ::=   </td><td><code>("thesaurus"  (<a href="#doc-xquery10-FTThesaurusID">FTThesaurusID</a>  |  "default"))<br/>|  ("thesaurus"  "("  (<a href="#doc-xquery10-FTThesaurusID">FTThesaurusID</a>  |  "default")  (","  <a href="#doc-xquery10-FTThesaurusID">FTThesaurusID</a>)*  ")")<br/>|  ("no"  "thesaurus")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTThesaurusID" id="doc-xquery10-FTThesaurusID"/>[172]   </td><td><code><a href="#prod-xquery10-FTThesaurusID"><a href="#prod-xquery10-FTThesaurusID">FTThesaurusID</a></a></code></td><td>   ::=   </td><td><code>"at"  <a href="#doc-xquery10-URILiteral">URILiteral</a>  ("relationship"  <a href="#prod-xquery10-StringLiteral">StringLiteral</a>)?  (<a href="#doc-xquery10-FTLiteralRange">FTLiteralRange</a>  "levels")?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-xquery10-URILiteral" id="doc-xquery10-URILiteral"/>[143]   </td><td><code><a href="#prod-xquery10-URILiteral"><a href="#prod-xquery10-URILiteral">URILiteral</a></a></code></td><td>   ::=   </td><td><code>
                        <a href="#prod-xquery10-StringLiteral">StringLiteral</a>
                     </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTLiteralRange" id="doc-xquery10-FTLiteralRange"/>[173]   </td><td><code><a href="#prod-xquery10-FTLiteralRange"><a href="#prod-xquery10-FTLiteralRange">FTLiteralRange</a></a></code></td><td>   ::=   </td><td><code>("exactly"  <a href="#prod-xquery10-IntegerLiteral">IntegerLiteral</a>)<br/>|  ("at"  "least"  <a href="#prod-xquery10-IntegerLiteral">IntegerLiteral</a>)<br/>|  ("at"  "most"  <a href="#prod-xquery10-IntegerLiteral">IntegerLiteral</a>)<br/>|  ("from"  <a href="#prod-xquery10-IntegerLiteral">IntegerLiteral</a>  "to"  <a href="#prod-xquery10-IntegerLiteral">IntegerLiteral</a>)</code></td></tr></tbody></table><p>
                  [<a name="dt-ftthesaurusoption" id="dt-ftthesaurusoption" title="thesaurus option">Definition</a>: A 
<b>thesaurus option</b>
modifies token and phrase matching by specifying whether a thesaurus is used or
not.]
If thesauri are used, the thesaurus option specifies information to locate 
the thesauri either by default or through a URI
reference. It also states the relationship to be applied and how many
levels within the thesaurus to be traversed.</p><div class="diff-add"><p>If the thesaurus option specifies a thesaurus with a relative URI,
that relative URI is resolved to an absolute URI using the base URI in 
the static context and that absolute URI is used to identify the thesaurus.
</p></div><p>
If the URI specifies a thesaurus that is not found in the statically
known thesauri, an error is raised [<a href="#ERRFTST0018" title="err:FTST0018">err:FTST0018</a>]. 
</p><p>Thesauri add related tokens and phrases to the query or change query tokens.  
Thus, the
user may narrow, broaden, or otherwise modify the query using
synonyms, hypernyms (more generic terms), etc. The search is performed
as though the user has specified all related query tokens and phrases
in a disjunction (FTOr). </p><div class="note"><p class="prefix"><b>Note:</b></p><p>A thesaurus may be standards-based or locally-defined. It may be a
traditional thesaurus, or a taxonomy, soundex, ontology, or topic
map. How the thesaurus is represented is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>.</p></div><p>
                  <span class="diff-chg">
An FTThesaurusID may optionally contain a StringLiteral to specify
</span>
the relationship sought between
tokens and phrases written in the query
and terms in the thesaurus.
Relationships include, but are not limited to, the relationships
and their abbreviations presented in <a href="#iso-2788">[ISO 2788]</a> and
their equivalents in other languages. The set of relationships supported by an
implementation is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>, but
implementations <a title="should" href="#should">SHOULD</a> support the relationships
defined in <a href="#iso-2788">[ISO 2788]</a>. The following list of terms have the
meanings 
defined in <a href="#iso-2788">[ISO 2788]</a>. If a query specifies thesaurus
relationships <span class="diff-del">or levels</span> not supported by the thesaurus, or does not specify a
relationship, 
the behavior is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.
</p><ol class="enumar"><li><p> 
                        <em>equivalence relationships (synonyms):</em> PREFERRED TERM (USE), 
NONPREFERRED USED FOR TERM (UF);</p></li><li><p> 
                        <em>hierarchical relationships:</em> BROADER TERM (BT), 
NARROWER TERM (NT),  BROADER TERM GENERIC (BTG), NARROWER TERM GENERIC (NTG), 
BROADER TERM PARTITIVE (BTP), NARROWER TERM PARTITIVE (NTP), 
TOP Terms (TT); and</p></li><li><p> 
                        <em>associative relationships:</em> RELATED TERM (RT).</p></li></ol><p>
                  <span class="diff-chg">
An FTThesaurusID may also optionally include an FTLiteralRange to specify
the number of levels to be queried in hierarchical relationships.
</span>
                  <span class="diff-add">
An FTLiteralRange is a constrained form of <a href="#doc-xquery10-FTRange">FTRange</a>,
and specifies a (possibly empty) range of integer values according to the same rules.
</span>
               </p><div class="diff-add"><div class="note"><p class="prefix"><b>Note:</b></p><p>
For historical reasons,
an implementation <a title="may" href="#may">MAY</a> allow an FTLiteralRange
to have subexpressions more general than IntegerLiterals,
and <a title="may" href="#may">MAY</a> even allow
its subexpressions to be dynamically evaluated.
</p></div></div><div class="diff-chg"><p>
                  <span class="diff-add">
The effect of specifying a particular range of levels in an FTThesaurusID
is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.
This includes cases involving empty ranges, negative levels, or
</span>
levels not supported by the thesaurus.
</p></div><p>
If no levels are specified,
the default is to query all levels in hierarchical relationships
<span class="diff-add">or to query an <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> number of levels
in hierarchical relationships</span>.
</p><p>The "thesaurus" option specifies that string matches include
tokens that can be found in one of the specified thesauri.
When "default" is used in place of a FTThesaurusID, the thesauri
specified in the static context are used, which are either given by the 
prolog declaration for the thesaurus option, or, if no such
declaration exists a system-defined default thesaurus with a 
system-defined relationship. The
default thesaurus may be used in combination with other explicitly
specified thesauri.</p><p>The "no thesaurus" option specifies that no thesaurus will be
used. </p><p>The default is "no thesaurus". </p><p>The following expression returns true, because it finds a <code>content</code>
element containing "task" which the thesaurus identified as a synonym for
"duty":</p><div class="xpath"><div class="exampleInner"><pre>.//book/content contains text "duty" using
thesaurus at "http://bstore1.example.com/UsabilityThesaurus.xml"
relationship "UF"</pre></div></div><p>The following expression returns a <code>book</code> element, because it finds a
<code>content</code> element containing "users", which is a
narrower term of "people":</p><div class="xpath"><div class="exampleInner"><pre>doc("http://bstore1.example.com/full-text.xml")
/books/book[./content contains text "people" using
thesaurus at "http://bstore1.example.com/UsabilityThesaurus.xml"
relationship "NT" at most 2 levels]</pre></div></div><p>Assuming the thesaurus available at URL 
"http://bstore1.example.com/UsabilitySoundex.xml" 
contains soundex capabilities, the following query
returns a <code>book</code> element containing "Marigold" which
sounds like "Merrygould":</p><div class="xpath"><div class="exampleInner"><pre>doc("http://bstore1.example.com/full-text.xml")
/books/book[. contains text "Merrygould" using thesaurus at
"http://bstore1.example.com/UsabilitySoundex.xml" relationship
"sounds like"]</pre></div></div></div><div class="div3">
<h4><a name="ftstemoption" id="ftstemoption"/>3.4.4 Stemming Option</h4><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTStemOption" id="doc-xquery10-FTStemOption"/>[170]   </td><td><code><a href="#prod-xquery10-FTStemOption"><a href="#prod-xquery10-FTStemOption">FTStemOption</a></a></code></td><td>   ::=   </td><td><code>"stemming"  |  ("no"  "stemming")</code></td></tr></tbody></table><p>
                  [<a name="dt-ftstemoption" id="dt-ftstemoption" title="stemming option">Definition</a>: A <b>stemming option</b>
modifies token and
phrase matching by specifying whether stemming is applied or not.
]
               </p><p>The "stemming" option specifies that matches may contain tokens
that have the same stem as the tokens and phrases written in the
query. It is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> what a stem of a token is. </p><p>The "no stemming" option specifies that the tokens and
phrases are not stemmed. </p><p>It is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> whether the stemming is based on an
algorithm, dictionary, or mixed approach. </p><p>The default is "no stemming". </p><p>The following expression returns true, because the <code>title</code> of the specified
<code>book</code> contains "improving" which has the same stem as
"improve":</p><div class="xpath"><div class="exampleInner"><pre>/books/book[@number="1"]/title contains text "improve" using stemming </pre></div></div></div><div class="div3">
<h4><a name="ftcaseoption" id="ftcaseoption"/>3.4.5 Case Option</h4><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTCaseOption" id="doc-xquery10-FTCaseOption"/>[168]   </td><td><code><a href="#prod-xquery10-FTCaseOption"><a href="#prod-xquery10-FTCaseOption">FTCaseOption</a></a></code></td><td>   ::=   </td><td><code>("case"  "insensitive")<br/>|  ("case"  "sensitive")<br/>|  "lowercase"<br/>|  "uppercase"</code></td></tr></tbody></table><p>
                  [<a name="dt-ftcaseoption" id="dt-ftcaseoption" title="case option">Definition</a>: A <b>case option</b>
modifies the matching of tokens and phrases by specifying how uppercase and 
lowercase characters are considered.]
               </p><p>There are four possible character case options:</p><ol class="enumar"><li><p> Using the option "case insensitive", tokens and phrases are matched,
regardless of the case of characters of the query tokens and phrases.</p></li><li><p> Using the option "case sensitive", tokens and phrases are matched,
if and only if the case of their characters is the same as written in the
query.</p></li><li><p> Using the option "lowercase", tokens and phrases are matched, if
and only if they match the query without regard to character case, but contain 
only lowercase characters.</p></li><li><p> Using the option "uppercase", tokens and phrases are matched, if
and only if they match the query without regard to character case, but contain 
only uppercase characters.</p></li></ol><p>The default is "case insensitive". </p><p>The effect of the case options is also influenced by the query's 
default collation 
(see <a href="http://www.w3.org/TR/xquery/#static_context">Section 
2.1.1 Static Context</a><sup><small>XQ</small></sup> and
 <a href="http://www.w3.org/TR/xquery/#id-default-collation-declaration">Section 
4.4 Default Collation Declaration</a><sup><small>XQ</small></sup>).
The following table summarizes how these interact.</p><table border="1" summary="Case Matrix"><caption>Case Matrix</caption><thead><tr><th colspan="1">Case option \ Default collation</th><th colspan="1">UCC (Unicode Codepoint Collation)</th><th colspan="1">CCS (some generic case-sensitive collation)</th><th colspan="1">CCI (some generic case-insensitive collation) </th></tr></thead><tbody><tr><th colspan="1">case insensitive</th><td>compare as if both lower</td><td>case-insensitive variant of CCS if it exists, else error</td><td>CCI</td></tr><tr><th colspan="1">case sensitive</th><td>UCC</td><td>CCS</td><td>case-sensitive variant of CCI if it exists, else error</td></tr><tr><th colspan="1">lowercase</th><td>compare using UCC after applying fn:lower-case() to the query 
           string
        </td><td>compare using CCS after applying fn:lower-case() to the query 
           string</td><td>CCI</td></tr><tr><th colspan="1">uppercase</th><td>compare using UCC after applying fn:upper-case() to the query 
           string</td><td>compare using CCS after applying fn:upper-case() to the query 
           string</td><td>CCI</td></tr></tbody></table><div class="note"><p class="prefix"><b>Note:</b></p><p>In this table, "else error" means "Otherwise, an error
is raised: [<a href="http://www.w3.org/TR/xpath-functions/#ERRFOCH0002" title="err:FOCH0002">err:FOCH0002</a>]<sup><small>FO</small></sup>". 
The phrase "if it exists" is used, because
the case-sensitive collation CCS does not always have a
case-insensitive variant (and, even if one exists, it may not be
possible to determine it algorithmically), and because the
case-insensitive collation CCI does not always have a case-sensitive
variant (and, even if one exists, it may not be possible to determine
it algorithmically).</p></div><p>The following expression returns false, because the <code>title</code> element
doesn't contain "usability" in lower-case characters:</p><div class="xpath"><div class="exampleInner"><pre>//book[@number="1"]/title contains text "Usability" using lowercase </pre></div></div><p>The following expression returns true, because the character case is not
considered:</p><div class="xpath"><div class="exampleInner"><pre>//book[@number="1"]/title contains text "usability" using case insensitive</pre></div></div></div><div class="div3">
<h4><a name="ftdiacriticsoption" id="ftdiacriticsoption"/>3.4.6 Diacritics Option</h4><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTDiacriticsOption" id="doc-xquery10-FTDiacriticsOption"/>[169]   </td><td><code><a href="#prod-xquery10-FTDiacriticsOption"><a href="#prod-xquery10-FTDiacriticsOption">FTDiacriticsOption</a></a></code></td><td>   ::=   </td><td><code>("diacritics"  "insensitive")<br/>|  ("diacritics"  "sensitive")</code></td></tr></tbody></table><p>
                  [<a name="dt-ftdiacriticsoption" id="dt-ftdiacriticsoption" title="diacritics option">Definition</a>: A 
<b>diacritics option</b>
modifies token and phrase matching by specifying how diacritics are considered.
]
               </p><p>There are two possible diacritics options:</p><ol class="enumar"><li><p>The option "diacritics" "insensitive" matches tokens and
phrases with and without diacritics. Whether diacritics are written in
the query or not is not considered.</p></li><li><p>The option "diacritics" "sensitive" matches tokens and phrases only
if they contain the diacritics as they are written in the query.</p></li></ol><p>The default is "diacritics insensitive". </p><p>The effect of the diacritics options is also influenced by the query's 
default collation 
(see <a href="http://www.w3.org/TR/xquery/#static_context">Section 
2.1.1 Static Context</a><sup><small>XQ</small></sup> and
 <a href="http://www.w3.org/TR/xquery/#id-default-collation-declaration">Section 
4.4 Default Collation Declaration</a><sup><small>XQ</small></sup>).
The following table summarizes how these interact.</p><table border="1" summary="Diacritics Matrix"><caption>Diacritics Matrix</caption><thead><tr><th colspan="1">Diacritics option \ Default collation</th><th colspan="1">UCC (Unicode Codepoint Collation)</th><th colspan="1">CDS (some generic diacritics-sensitive collation)</th><th colspan="1">CDI (some generic diacritics-insensitive collation) </th></tr></thead><tbody><tr><th colspan="1">diacritics insensitive</th><td>UCC comparison, but without considering diacritics</td><td>diacritics-insensitive variant of CDS
                                  if it exists, else error</td><td>CDI</td></tr><tr><th colspan="1">diacritics sensitive</th><td>UCC</td><td>CDS</td><td>diacritics-sensitive variant of CDI if it exists, else error</td></tr></tbody></table><div class="note"><p class="prefix"><b>Note:</b></p><p>In this table, "else error" means "Otherwise, an error
is raised: [<a href="http://www.w3.org/TR/xpath-functions/#ERRFOCH0002" title="err:FOCH0002">err:FOCH0002</a>]<sup><small>FO</small></sup>". 
The phrase "if it exists" is used, because
the diacritics-sensitive collation CDS does not always have a
diacritics-insensitive variant (and, even if one exists, it may not be
possible to determine it algorithmically), and because the
diacritics-insensitive collation CDI does not always have a
diacritics-sensitive variant (and, even if one exists, it may not be
possible to determine it algorithmically).</p></div><p>The following expression returns true, because the token "Véra" in the
<code>editor</code> element is matched, as the acute accent is not 
considered in the comparison:</p><div class="xpath"><div class="exampleInner"><pre>//book[@number="1"]//editor contains text "Vera" using diacritics insensitive</pre></div></div><p>This returns false, because the <code>editor</code> element does not
contain the token "Vera" in this exact form, i.e. without any diacritics:</p><div class="xpath"><div class="exampleInner"><pre>//book[@number="1"]/editors contains text "Vera" using diacritics sensitive</pre></div></div></div><div class="div3">
<h4><a name="ftstopwordoption" id="ftstopwordoption"/>3.4.7 Stop Word Option</h4><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTStopWordOption" id="doc-xquery10-FTStopWordOption"/>[174]   </td><td><code><a href="#prod-xquery10-FTStopWordOption"><a href="#prod-xquery10-FTStopWordOption">FTStopWordOption</a></a></code></td><td>   ::=   </td><td><code>("stop"  "words"  <a href="#doc-xquery10-FTStopWords">FTStopWords</a>  
                        <a href="#doc-xquery10-FTStopWordsInclExcl">FTStopWordsInclExcl</a>*)<br/>|  ("stop"  "words"  "default"  <a href="#doc-xquery10-FTStopWordsInclExcl">FTStopWordsInclExcl</a>*)<br/>|  ("no"  "stop"  "words")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTStopWords" id="doc-xquery10-FTStopWords"/>[175]   </td><td><code><a href="#prod-xquery10-FTStopWords"><a href="#prod-xquery10-FTStopWords">FTStopWords</a></a></code></td><td>   ::=   </td><td><code>("at"  <a href="#doc-xquery10-URILiteral">URILiteral</a>)<br/>|  ("("  <a href="#prod-xquery10-StringLiteral">StringLiteral</a>  (","  <a href="#prod-xquery10-StringLiteral">StringLiteral</a>)*  ")")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTStopWordsInclExcl" id="doc-xquery10-FTStopWordsInclExcl"/>[176]   </td><td><code><a href="#prod-xquery10-FTStopWordsInclExcl"><a href="#prod-xquery10-FTStopWordsInclExcl">FTStopWordsInclExcl</a></a></code></td><td>   ::=   </td><td><code>("union"  |  "except")  <a href="#doc-xquery10-FTStopWords">FTStopWords</a>
                     </code></td></tr></tbody></table><p>
                  [<a name="dt-ftstopwordoption" id="dt-ftstopwordoption" title="stop word option">Definition</a>: A 
<b>stop word option</b>
controls matching of <span class="diff-chg">tokens</span> by specifying whether stop words are used or not. 
Stop words are tokens in the query that match any token in the text being
searched. 
]
                  <span class="diff-add">More precisely,
a stop word option defines a collection of stop words according to the rules below.
Then, in every FTWords to which the stop word option applies, 
each query token is checked:
if it appears
(using an <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> comparison)
in the specified collection of stop words,
it is considered a stop word.</span>
               </p><p>
Normally a stop word matches 
exactly one token, but there may be <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> conditions, under
which a stop word may match a different number of tokens.</p><div class="diff-add"><p>
Tokens matched by stop words
retain their position numbers
and are counted by
<a href="#doc-xquery10-FTDistance">FTDistance</a>
and
<a href="#doc-xquery10-FTWindow">FTWindow</a> filters.</p></div><p>
                  <a href="#doc-xquery10-FTStopWords">FTStopWords</a> specifies the list
of stop words either explicitly as a comma-separated list of string
literals, or by the keyword <code>at</code> followed by a literal URI.
If the URI specifies a list of stop words that is not found in the statically
known stop word lists, an error is raised [<a href="#ERRFTST0008" title="err:FTST0008">err:FTST0008</a>]. 
Whether the stop word
list is resolved from the statically known stop word lists or given explicitly,
no tokenization is performed on the stop words: they are used as they occur  
in the list.
</p><div class="diff-chg"><p>
If the stop words option specifies a stop word list with a relative URI,
that relative URI is resolved to an absolute URI using the base URI in 
the static context and that absolute URI is used to identify the stop word list.
</p></div><p>Multiple stop word lists may be combined using "union" or "except".
The keywords "union" and "except" are applied from left to right. If "union" is specified, every string occurring in the lists  
specified by the left-hand side or the right-hand side is a stop 
word. If "except" is specified, only strings occurring in the list  
specified by the left-hand side but not in the list specified
by the right-hand side are stop words. </p><p>The <span class="diff-chg">"stop words default"</span> option specifies that an
<a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> collection of stop words is used. </p><p>The "no stop words" option specifies that no stop words are
used. This is equivalent to specifying an empty list of stop
words.</p><p>The default is "no stop words". </p><div class="note"><p class="prefix"><b>Note:</b></p><p>
Some implementations may apply stop word lists during indexing and be
unable to comply with query-time requests to not apply those stop words. An
implementation may still support stop-word options (and therefore not raise
[<a href="#ERRFTST0006" title="err:FTST0006">err:FTST0006</a>])
by applying any additional stop words specified in the query.
Pre-application of irrevocable stop word lists falls under
implementation-defined tokenization behavior in this case, and a query that
specifies "no stop words" may still have some words ignored.
</p></div><p>The following expression returns true, because the document contains the phrase
"propagating few errors":</p><div class="xpath"><div class="exampleInner"><pre>/books/book[@number="1"]//p contains text "propagating of errors"
using stop words ("a", "the", "of") </pre></div></div><p>Note the asymmetry in the stop word semantics: the property of
being a stop word is only relevant to query terms, not to document
terms. Hence, it is irrelevant for the above-mentioned match whether
"few" is a stop word or not, and on the other hand we do not want the
query above to match "propagating" followed by 2 stop words, or even a
sequence of 3 stop words in the document.</p><p>The following expression returns false. In this case specifying "few" as 
a stop word has no effect, since "few" does not appear in the query.
Although the words "propagating" and "errors" appear in the text being
searched, the phrase  
"propagating errors" cannot be matched, since that phrase does not occur.</p><div class="xpath"><div class="exampleInner"><pre>/books/book[@number="1"]//p contains text "propagating errors" 
using stop words ("few")</pre></div></div><p>The following expression returns false, because "of" is not in the <code>p</code>
element between "propagating" and "errors":</p><div class="xpath"><div class="exampleInner"><pre>/books/book[@number="1"]//p contains text "propagating of errors" 
using no stop words</pre></div></div><p>The following expression uses the stop words list specified at the
URL. Assuming that the specified stop word list contains the word
"then", this query
is reduced to a query on the phrase "planning X conducting", allowing any
token as a substitute for X.  It returns a <code>book</code> element,
because its <code>content</code> element contains "planning then
conducting". It would also return the <code>book</code> if the
phrases "planning and conducting" and "planning before conducting"
had been in its <code>content</code>:</p><div class="xpath"><div class="exampleInner"><pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[.//content contains text "planning then 
conducting" using stop words at 
"http://bstore1.example.com/StopWordList.xml"]
</pre></div></div><p>The following expression returns <code>book</code>s containing "planning then
conducting", but not does not return <code>book</code>s containing "planning
and conducting", since it is exempting "then" from being a stop word: </p><div class="xpath"><div class="exampleInner"><pre>
doc("http://bstore1.example.com/full-text.xml")
/books/book[.//content contains text "planning then conducting"
using stop words at "http://bstore1.example.com/StopWordList.xml"
except ("the", "then")]
</pre></div></div></div><div class="div3">
<h4><a name="ftextensionoption" id="ftextensionoption"/>3.4.8 Extension Option</h4><p>
                  [<a name="dt-ftextensionoption" id="dt-ftextensionoption" title="extension option">Definition</a>: An
<b>extension option</b> is a match option that acts in an
<a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> way.
]
               </p><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTExtensionOption" id="doc-xquery10-FTExtensionOption"/>[179]   </td><td><code><a href="#prod-xquery10-FTExtensionOption"><a href="#prod-xquery10-FTExtensionOption">FTExtensionOption</a></a></code></td><td>   ::=   </td><td><code>"option"  <a href="#prod-xquery10-QName">QName</a>  
                        <a href="#prod-xquery10-StringLiteral">StringLiteral</a>
                     </code></td></tr></tbody></table><p>An extension option consists of an identifying QName and a StringLiteral.
Typically, a particular option will be recognized by some implementations and
not by others. The syntax is designed so that option declarations can be
successfully parsed by all implementations.
</p><p>The QName of an extension option must resolve to a namespace URI
and local name, using 
the statically known namespaces.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>There is no default namespace for options.</p></div><p>Each implementation recognizes an 
<a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>
set of namespace
URIs used to denote extension options.</p><p>If the namespace part of the QName is not a namespace recognized by the
implementation as one used to denote extension option, then the extension option
is ignored.</p><p>Otherwise, the effect of the extension option, including its error behavior,
is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.
For example, if the local part of the QName is
not recognized, or if the StringLiteral does not conform to the rules
defined by the implementation for the particular extension option, the implementation may choose
whether to report an error, ignore the extension option, or take some
other action.</p><p>Implementations may impose rules on where particular extension options may
appear relative to other match options, and the
interpretation of an option declaration may depend on its position.</p><p>An extension option must not be used to change the syntax accepted by the
processor, or to suppress the detection of static errors. However, it may be
used without restriction to modify the set of tokens in the query or how they
are matched against tokens in the text being searched. 
An extension option has the same scope as other match options.
</p><p>The following examples illustrate several possible uses for extension
options:</p><p>This extension option is set as part of the static context of all 
full-text expressions in the module and might be used to ensure that 
queries are insensitive to Arabic short-vowels.
</p><div class="exampleInner"><pre>
declare namespace exq = "http://example.org/XQueryImplementation";

declare ft-option using option exq:diacritics "short-vowel insensitive";
</pre></div><p>This extension option applies only to the matching in the full-text
selection in which it is found and might be used to specify how compound words
should be matched.
</p><div class="xquery"><div class="exampleInner"><pre>
declare namespace exq = "http://example.org/XQueryImplementation";

//para[. contains text
         ("Kinder" ftand "Platz" distance exactly 1 words)
         using stemming
	 using option exq:compounds "distance=1" ]
</pre></div></div></div></div><div class="div2">
<h3><a name="logical_ftoperators" id="logical_ftoperators"/>3.5 Logical Full-Text Operators</h3><p>
Full-text selections can be combined with the logical connectives
<code>ftor</code> (full-text or), <code>ftand</code> (full-text and), <code>not in</code> (mild not),
and <code>ftnot</code> (unary full-text not).</p><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTOr" id="doc-xquery10-FTOr"/>[146]   </td><td><code><a href="#prod-xquery10-FTOr"><a href="#prod-xquery10-FTOr">FTOr</a></a></code></td><td>   ::=   </td><td><code>
                     <a href="#doc-xquery10-FTAnd">FTAnd</a> ( "ftor"  <a href="#doc-xquery10-FTAnd">FTAnd</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTAnd" id="doc-xquery10-FTAnd"/>[147]   </td><td><code><a href="#prod-xquery10-FTAnd"><a href="#prod-xquery10-FTAnd">FTAnd</a></a></code></td><td>   ::=   </td><td><code>
                     <a href="#doc-xquery10-FTMildNot">FTMildNot</a> ( "ftand"  <a href="#doc-xquery10-FTMildNot">FTMildNot</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTMildNot" id="doc-xquery10-FTMildNot"/>[148]   </td><td><code><a href="#prod-xquery10-FTMildNot"><a href="#prod-xquery10-FTMildNot">FTMildNot</a></a></code></td><td>   ::=   </td><td><code>
                     <a href="#doc-xquery10-FTUnaryNot">FTUnaryNot</a> ( "not"  "in"  <a href="#doc-xquery10-FTUnaryNot">FTUnaryNot</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTUnaryNot" id="doc-xquery10-FTUnaryNot"/>[149]   </td><td><code><a href="#prod-xquery10-FTUnaryNot"><a href="#prod-xquery10-FTUnaryNot">FTUnaryNot</a></a></code></td><td>   ::=   </td><td><code>("ftnot")? <a href="#doc-xquery10-FTPrimaryWithOptions">FTPrimaryWithOptions</a>
                  </code></td></tr></tbody></table><div class="div3">
<h4><a name="sec-ftor" id="sec-ftor"/>3.5.1 Or-Selection</h4><p>
                  [<a name="dt-or-selection" id="dt-or-selection" title="or-selection">Definition</a>: An
<b>or-selection</b> combines two full-text selections using the 
<code>ftor</code> operator.]
               </p><p>An or-selection finds all matches that satisfy at least
one of the operand full-text selections. </p><p>The following expression returns the <code>book</code> element written by
"Millicent":</p><div class="xpath"><div class="exampleInner"><pre>//book[.//author contains text "Millicent" ftor "Voltaire"]</pre></div></div></div><div class="div3">
<h4><a name="sec-ftand" id="sec-ftand"/>3.5.2 And-Selection</h4><p>
                  [<a name="dt-and-selection" id="dt-and-selection" title="and-selection">Definition</a>: An
<b>and-selection</b> combines two full-text selections using the 
<code>ftand</code> operator.]
               </p><p>An and-selection finds matches that satisfy all of the operand full-text 
selections simultaneously. A match of an and-selection is formed by combining
matches for each of the operand full-text selections as described in
<a href="#tq-ft-fs-FTAnd"><b>4.2.6.2 FTAnd</b></a>. </p><p>For example, <code>"usability" ftand "testing"</code> will find two 
matches
in <code>//book[@number="1"]/title</code>: each of the two matches for the
FTWords selection <code>"usability"</code> (the two occurrences of 
 "usability" in the string value of the title element) is combined 
with the single match for the FTWords <code>"testing"</code> (only one 
occurrence of "testing" in the title).
Since the above and-selection has at least one match, the following
expression will return "true". </p><div class="xpath"><div class="exampleInner"><pre>//book[@number="1"]/title contains text ("usability" ftand "testing")</pre></div></div><p>The following expression returns false, because "Millicent" and "Montana" are not
contained by the same <code>author</code> element in any <code>book</code>
element:</p><div class="xpath"><div class="exampleInner"><pre>//book/author contains text "Millicent" ftand "Montana"</pre></div></div><p>No <code>author</code> element in any <code>book</code> element 
contains both "Millicent" and "Montana". Therefore, for any such 
<code>author</code> element, there are either one match for the 
FTWords <code>"Millicent"</code> and zero matches for the FTWords 
<code>"Montana"</code>, or vice versa, or no matches for both
of them. In any of these cases, the and-selection will have zero 
matches.</p></div><div class="div3">
<h4><a name="sec-ftmildnot" id="sec-ftmildnot"/>3.5.3 Mild-Not Selection</h4><p>
                  [<a name="dt-mild-not-selection" id="dt-mild-not-selection" title="mild-not selection">Definition</a>: A
<b>mild-not selection</b> combines two full-text selections 
using the <code>not in</code> operator.]
               </p><p>The <code>not in</code> operator is a milder form of the operator combination
<code>ftand ftnot</code>. The selection <code>A not in B</code> matches a token
sequence that matches <code>A</code>, but not when it is a part of a 
match of <code>B</code>. 
In contrast, <code>A ftand ftnot B</code> only finds matches when the token 
sequence contains <code>A</code> and does not contain <code>B</code>.</p><p>
As an example, consider a search for <code>"Mexico" not in "New Mexico"</code>.
This may return, among others, a document
which is all about "Mexico" but mentions at the end that "New Mexico
was named after Mexico". The occurrence of "Mexico" in "New Mexico" is not 
considered, but other occurrences of "Mexico" are matched. Note that this
document would not be matched by the full-text selection 
<code>"Mexico" ftand ftnot "New Mexico"</code>.</p><p> A match to a mild-not selection must
contain at least one token that satisfies the first
condition and does not satisfy the second condition. If it contains a
token that satisfies both the first and the second
condition, the token is not considered as a match.</p><p>The following expression returns true, because "usability" appears in the
<code>title</code> and the <code>p</code> elements and the token within
the phrase "Usability Testing" in the <code>title</code> element is not
considered:</p><div class="xpath"><div class="exampleInner"><pre>/books/book contains text "usability" not in "usability testing"</pre></div></div><p>If either operand of a mild-not selection
yields an <b>AllMatches</b> that contains a <b>Match</b> that contains a <b>StringExclude</b>,
then a dynamic error [<a href="#ERRFTDY0017" title="err:FTDY0017">err:FTDY0017</a>] is raised.
</p><div class="note"><p class="prefix"><b>Note:</b></p><p>
This situation can arise if the operand contains 
a not-selection
or
a cardinality constraint (<a href="#doc-xquery10-FTTimes">FTTimes</a>) involving
<code>exactly</code>,
<code>at most</code>, or
<code>from ... to</code>.
</p></div></div><div class="div3">
<h4><a name="sec-ftnot" id="sec-ftnot"/>3.5.4 Not-Selection</h4><p>
                  [<a name="dt-unary-not-selection" id="dt-unary-not-selection" title="not-selection">Definition</a>: A
<b>not-selection</b> is a full-text selection starting with the prefix 
operator <code>ftnot</code>.]
               </p><p>A not-selection selects matches that do not
satisfy the operand full-text selection.
Details about how such matches are constructed are given in <a href="#tq-ft-fs-FTUnaryNot"><b>4.2.6.3 FTUnaryNot</b></a>.
</p><p>The following expression returns the empty sequence, because all <code>book</code>
elements contain "usability":</p><div class="xpath"><div class="exampleInner"><pre>//book[. contains text ftnot "usability"]</pre></div></div><p>The following expression returns true, because <code>book</code> elements contain
"improving" and "usability" but not "improving usability":</p><div class="xpath"><div class="exampleInner"><pre>//book contains text "improving" ftand
"usability" ftand ftnot "improving usability"</pre></div></div><p>The following expression returns <code>book</code> elements containing "web site
usability" but not "usability testing":</p><div class="xpath"><div class="exampleInner"><pre>//book[title/@shortTitle contains text "web site usability" ftand 
ftnot "usability testing"]</pre></div></div></div></div><div class="div2">
<h3><a name="ftposfilter" id="ftposfilter"/>3.6 Positional Filters</h3><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTPosFilter" id="doc-xquery10-FTPosFilter"/>[158]   </td><td><code><a href="#prod-xquery10-FTPosFilter"><a href="#prod-xquery10-FTPosFilter">FTPosFilter</a></a></code></td><td>   ::=   </td><td><code>
                     <a href="#doc-xquery10-FTOrder">FTOrder</a>  |  <a href="#doc-xquery10-FTWindow">FTWindow</a>  |  <a href="#doc-xquery10-FTDistance">FTDistance</a>  |  <a href="#doc-xquery10-FTScope">FTScope</a>  |  <a href="#doc-xquery10-FTContent">FTContent</a>
                  </code></td></tr></tbody></table><p>
               [<a name="dt-ftposfilter" id="dt-ftposfilter" title="positional filter">Definition</a>: 
                  <b>Positional filters</b> are postfix operators that serve to
filter matches based on various constraints on their positional
information.]
            </p><p>
Recall that the grammar rule for <a href="#doc-xquery10-FTSelection">FTSelection</a>
allows an arbitrary number of positional filters to follow an
<a href="#doc-xquery10-FTOr">FTOr</a>.  <span class="diff-chg">In a group of multiple adjacent positional filters,
<a href="#doc-xquery10-FTOrder">FTOrder</a> filters are applied first, and then the other
positional filters are applied from left to right, skipping the 
<a href="#doc-xquery10-FTOrder">FTOrder</a> filters.
That is, the first filter is applied to the</span>
result of the <a href="#doc-xquery10-FTOr">FTOr</a>, the second is applied to the
result of that first application, and so on.
</p><p>
An <a href="#doc-xquery10-FTOr">FTOr</a> consists of
one or more <a href="#doc-xquery10-FTAnd">FTAnd</a>s (separated by <code>ftor</code>),
each of which could be
an <a href="#doc-xquery10-FTPosFilter">FTPosFilter</a> applied to an embedded FTOr, enclosed in parentheses.
</p><div class="div3">
<h4><a name="ftorder" id="ftorder"/>3.6.1 Ordered Selection</h4><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTOrder" id="doc-xquery10-FTOrder"/>[159]   </td><td><code><a href="#prod-xquery10-FTOrder"><a href="#prod-xquery10-FTOrder">FTOrder</a></a></code></td><td>   ::=   </td><td><code>"ordered"</code></td></tr></tbody></table><p>
                  [<a name="dt-ordered-selection" id="dt-ordered-selection" title="ordered selection">Definition</a>: An
<b>ordered selection</b> consists of a full-text selection followed by 
the postfix operator "ordered".]

An ordered selection constrains the order of tokens and
phrases to be the same as the order in which they are written in the
operand selection.
</p><p> The default is unordered. Unordered is in effect when ordered is
not specified in the query. Unordered cannot be written explicitly in
the query.  </p><p>An ordered selection selects matches which satisfy the operand full-text
selection and which also satisfy the following constraint: the order
that the matching tokens or phrases have in the text being searched
is the same order that the corresponding query tokens or phrases have in the
operand selection. In both cases, the ordering is determined from the minimum
start positions of the constituent tokens.
</p><p>The following expression returns true, because titles of <code>book</code> elements
contain "web site" and "usability" in the order in which they are written in
the query, i.e., "web site" must precede "usability":</p><div class="xpath"><div class="exampleInner"><pre>//book/title contains text ("web site" ftand "usability") ordered</pre></div></div><p>The following expression returns false, because although "Montana" and "Millicent"
both appear in the <code>book</code> element, they do not appear in the order they
are written in the query:</p><div class="xpath"><div class="exampleInner"><pre>//book[@number="1"] contains text ("Montana" ftand "Millicent") ordered</pre></div></div></div><div class="div3">
<h4><a name="ftwindow" id="ftwindow"/>3.6.2 Window Selection</h4><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTWindow" id="doc-xquery10-FTWindow"/>[160]   </td><td><code><a href="#prod-xquery10-FTWindow"><a href="#prod-xquery10-FTWindow">FTWindow</a></a></code></td><td>   ::=   </td><td><code>"window"  <a href="#prod-xquery10-AdditiveExpr">AdditiveExpr</a>  
                        <a href="#doc-xquery10-FTUnit">FTUnit</a>
                     </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTUnit" id="doc-xquery10-FTUnit"/>[162]   </td><td><code><a href="#prod-xquery10-FTUnit"><a href="#prod-xquery10-FTUnit">FTUnit</a></a></code></td><td>   ::=   </td><td><code>"words"  |  "sentences"  |  "paragraphs"</code></td></tr></tbody></table><p>
                  [<a name="dt-window-selection" id="dt-window-selection" title="window selection">Definition</a>: A
<b>window selection</b> consists of a full-text selection followed
by one of the (complex) postfix operators derived from <a href="#doc-xquery10-FTWindow">FTWindow</a>.] 
A window selection selects matches which satisfy the operand full-text
selection and for which the matched tokens and phrases, more precisely the 
individual StringIncludes of that match, are found
within a number of <a href="#doc-xquery10-FTUnit">FTUnit</a>s (words, sentences, and paragraphs). 
The number of <a href="#doc-xquery10-FTUnit">FTUnit</a>s is
specified by an AdditiveExpr that is converted as though it were an argument to a
function with the expected type of <code>xs:integer</code>.</p><p>A window selection may cross element
boundaries. The size of the window is not affected by the presence or
absence of element boundaries. Stop words are included in the
computation of the window size whether they are ignored by the query or not.</p><p>
A window selection examines the matches generated by the preceding
portion of the <a href="#doc-xquery10-FTSelection">FTSelection</a>, and selects those for
which the matched 
tokens and phrases (more precisely, the individual StringIncludes of
that match) are all found within a window whose size is a specified
number of FTUnits (words, sentences, or paragraphs); for each such
window, the window selection then generates a match containing the
merge of those StringIncludes, plus any StringExcludes that fall
within the window.
</p><p>The following expression returns true, because "web", "site", and "usability" are
within a window of 5 tokens in the <code>title</code> element:</p><div class="xpath"><div class="exampleInner"><pre>/books/book/title contains text "web" ftand "site"
ftand "usability" window 5 words</pre></div></div><p>The following expression returns true, because "web" and "site" in the order they are
written in the query and either "usability" or "testing" are within a
window of at most 10 tokens:</p><div class="xpath"><div class="exampleInner"><pre>/books/book contains text ("web" ftand "site" ordered)
ftand ("usability" ftor "testing") window 10 words</pre></div></div><p>The following expression returns false, because the
instances of "web site" and "usability" in the <code>title</code> element are
not within a window of 3.  The phrase "Web Site Usability" in the attribute
does not apply because the attribute is not part of the string value of the node.
A similar query with a window of 5 would return true.
</p><div class="xpath"><div class="exampleInner"><pre>/books/book//title contains text "web site" ftand
"usability" window 3 words</pre></div></div><p>The following expression returns the sample <code>book</code> element, 
because its <code>number</code> attribute is 1 and it contains a
window of 2 words which contains an occurrence of "efficient"
but not an occurrence of "and". There is just one such matching window
in the sample text and it contains "enable efficient".</p><div class="xpath"><div class="exampleInner"><pre>/books/book[@number="1" and . contains text "efficient" 
ftand ftnot "and" window 2 words]</pre></div></div><p>The following expression returns the empty sequence, because in the selected
<code>book</code> element, there is no occurrence of "efficient"
within a window of 3 tokens which would not also contain an occurrence
of "and":</p><div class="xpath"><div class="exampleInner"><pre>/books/book[@number="1" and . contains text "efficient" 
ftand ftnot "and" window 3 words]</pre></div></div><p>
In order to allow meaningful results for nested positional filters,
e.g., a window selection embedded inside a distance selection, the
resulting matches for window selections are formed from the input matches
that satisfy the window constraint as follows. All StringIncludes of
such a match are coerced into a single StringInclude that spans all
token positions from the smallest to the largest position of any input
StringIncludes. This is explained in more detail in Section <a href="#ftdistance"><b>3.6.3 Distance Selection</b></a>.
</p></div><div class="div3">
<h4><a name="ftdistance" id="ftdistance"/>3.6.3 Distance Selection</h4><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTDistance" id="doc-xquery10-FTDistance"/>[161]   </td><td><code><a href="#prod-xquery10-FTDistance"><a href="#prod-xquery10-FTDistance">FTDistance</a></a></code></td><td>   ::=   </td><td><code>"distance"  <a href="#doc-xquery10-FTRange">FTRange</a>  
                        <a href="#doc-xquery10-FTUnit">FTUnit</a>
                     </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTRange" id="doc-xquery10-FTRange"/>[157]   </td><td><code><a href="#prod-xquery10-FTRange"><a href="#prod-xquery10-FTRange">FTRange</a></a></code></td><td>   ::=   </td><td><code>("exactly"  <a href="#prod-xquery10-AdditiveExpr">AdditiveExpr</a>)<br/>|  ("at"  "least"  <a href="#prod-xquery10-AdditiveExpr">AdditiveExpr</a>)<br/>|  ("at"  "most"  <a href="#prod-xquery10-AdditiveExpr">AdditiveExpr</a>)<br/>|  ("from"  <a href="#prod-xquery10-AdditiveExpr">AdditiveExpr</a>  "to"  <a href="#prod-xquery10-AdditiveExpr">AdditiveExpr</a>)</code></td></tr></tbody></table><p>
                  [<a name="dt-distance-selection" id="dt-distance-selection" title="distance selection">Definition</a>: A
<b>distance selection</b> consists of a full-text selection followed
by one of the (complex) postfix operators derived from <a href="#doc-xquery10-FTDistance">FTDistance</a>.] 
               </p><p>A distance selection selects matches which satisfy the operand full-text
selection and for which the matched tokens and phrases satisfy the
specified distance conditions.</p><p>Distances in the search context are measured in units of
tokens, sentences, or paragraphs.
Roughly speaking, the distance between two matches
is the number of intervening units,
so a distance of zero tokens (sentences, paragraphs) means
no intervening tokens (sentences, paragraphs).
More precisely,
given two matches,
we first determine their order
by sorting on starting position and if necessary on ending position.
Let M1 be the "earlier" and M2 be the "later".
(If there are overlapping tokens involved,
the designations "earlier" and "later" may not be intuitively obvious.)
Then the distance between the two is
M2's starting position minus M1's ending position, minus 1.
</p><p>
When computing distances
in the search context,
a distance selection
may cross element boundaries;
they affect the distance computed
only to the extent that they affect the tokenization of the search context.
Stop words are counted in those computations whether they are ignored
or not.
</p><p>
When a distance selection applies a distance condition to more than two matches,
the distance condition is required to hold on each successive pair of matches.
</p><p>
An <a href="#doc-xquery10-FTDistance">FTDistance</a> expresses a distance condition in terms of
an <a href="#doc-xquery10-FTUnit">FTUnit</a> and an <a href="#doc-xquery10-FTRange">FTRange</a>.
An <a href="#doc-xquery10-FTUnit">FTUnit</a> can be
<code>words</code>, <code>sentences</code>, or <code>paragraphs</code>,
where <code>words</code> refers to a distance measured in tokens.
</p><p>
An <a href="#doc-xquery10-FTRange">FTRange</a> specifies a range of integer values
by providing a minimum and/or maximum value for some integer quantity.
(Here, where the FTRange appears in an FTDistance, that quantity is a distance.
When it appears in an FTTimes, the quantity is a number of occurrences.)
Each one of the AdditiveExpr
specified in an <a href="#doc-xquery10-FTRange">FTRange</a> is converted as though it were an
argument to a function with the expected parameter type of
<code>xs:integer</code>.</p><p>Let the value of the first (or only) operand be M.  If "from" is
specified, let the value of the second operand be N. 
</p><p>If "exactly" is specified, then the range is the closed interval [M, 
M].  If "at least" is specified, then the range is the half-closed interval 
[M, unbounded).  If "at most" is specified, then the range is the half-closed 
interval (unbounded, M].  If "from-to" is specified, then the range is the closed 
interval [M, N]. Note: If M is greater than N, the range is empty. </p><p>Here are some examples of  <a href="#doc-xquery10-FTRange">FTRange</a>s:</p><ol class="enumar"><li><p>'exactly 0' specifies the range [0, 0].</p></li><li><p>'at least 1' specifies the range [1,unbounded).</p></li><li><p>'at most 1' specifies the range (unbounded, 1]. </p></li><li><p>'from 5 to 10' specifies the range [5, 10].</p></li></ol><p>The following expression returns false, because "completion" and "errors" are
less than 11 tokens apart:</p><div class="xpath"><div class="exampleInner"><pre>/books/book contains text ("completion" ftand "errors" 
distance at least 11 words)</pre></div></div><p>The following expression returns true:</p><div class="xpath"><div class="exampleInner"><pre>/books/book contains text "web" ftand "site" ftand
"usability" distance at most 2 words</pre></div></div><p>
The search context contains two occurrences of the phrase
"the usability of a web site"
(once in the &lt;title&gt; and once in the &lt;content&gt;).
In this phrase, 
the tokens "usability" and "web" have a distance of 2 words,
and the tokens "web" and "site" have a distance of 0 words,
both of which satisfy the constraint <code>distance at most 2 words</code>.
(The tokens "usability" and "site" have a distance of 3 words,
but this does not cause the distance filter to fail,
because these are not successive matches.)
Thus, the full-text selection yields two matches,
and the whole expression yields true.
(The phrase "Improving Web Site Usability" would also satisfy the given full-text selection,
but in the sample document it occurs in an attribute value,
and so does not contribute to the string value or the tokenization of the book element.)
</p><p>The following expression returns the empty sequence, because 
between any token "usability" and the token in any occurrence of the phrase 
"web site" that is the nearest to the token "usability" there is always more 
than one intervening token: </p><div class="xpath"><div class="exampleInner"><pre>/books/book[.//p contains text "web site"
ftand "usability" distance at most 1 words] </pre></div></div><p>The following expression returns the <code>book</code> title, because for 
the occurrences of the tokens "web" and "users" in the <code>note</code> 
element only one intervening token appears: </p><div class="xpath"><div class="exampleInner"><pre>/books/book[. contains text "web"
ftand "users" distance at most 1 words]/title </pre></div></div><p>
In order to allow meaningful results for nested positional filters,
e.g., a distance selection embedded inside another distance selection, the
resulting matches for distance selections are formed from the input matches
that satisfy the distance constraint as follows. All StringIncludes of
such a match are coerced into a single StringInclude that spans all
token positions from the smallest to the largest position of any input
StringIncludes. Thus, a distance selection that embeds a window or a
distance selection takes the result of the embedded selection as a
single unit.
</p><p>
The following gives an example of nested distance selections:
</p><div class="xpath"><div class="exampleInner"><pre>/books/book contains text ((("richard" ftand "nixon") distance at most 2 words) 
                   ftand 
                   (("george" ftand "bush") distance at most 2 words) 
                  distance at least 20 words)</pre></div></div><p>
This expression allows to find <code>book</code> elements that contain, for instance, 
"Richard M. Nixon"  and "George W. Bush" at least 20 words apart. The
matches for the inner distance selections are treated as single units
(represented by StringIncludes) by the outer distance
selection. Suppose such phrases are present in 
the search context, then the outer distance selection
enforces a constraint on the number of intervening tokens ("at least
20") between the
last token of "Richard M. Nixon" and the first token of "George
W. Bush".
</p></div><div class="div3">
<h4><a name="ftscope" id="ftscope"/>3.6.4 Scope Selection</h4><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTScope" id="doc-xquery10-FTScope"/>[163]   </td><td><code><a href="#prod-xquery10-FTScope"><a href="#prod-xquery10-FTScope">FTScope</a></a></code></td><td>   ::=   </td><td><code>("same"  |  "different")  <a href="#doc-xquery10-FTBigUnit">FTBigUnit</a>
                     </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTBigUnit" id="doc-xquery10-FTBigUnit"/>[164]   </td><td><code><a href="#prod-xquery10-FTBigUnit"><a href="#prod-xquery10-FTBigUnit">FTBigUnit</a></a></code></td><td>   ::=   </td><td><code>"sentence"  |  "paragraph"</code></td></tr></tbody></table><p>
                  [<a name="dt-scope-selection" id="dt-scope-selection" title="scope selection">Definition</a>: A
<b>scope selection</b> consists of a full-text selection followed
by one of the (complex) postfix operators derived from <a href="#doc-xquery10-FTScope">FTScope</a>.] 
               </p><p>A scope selection selects matches which satisfy the operand full-text
selection and for which the matched tokens and phrases are
contained in the same scope or in different scopes. </p><p> Possible scopes are sentences and paragraphs. </p><p> By default, there are no restrictions on the scope of the
matches. </p><p>The following expression returns false, because the tokens "usability" and "Marigold"
are not contained within the same sentence:</p><div class="xpath"><div class="exampleInner"><pre>//book contains text "usability" ftand "Marigold" same sentence</pre></div></div><p>The following expression returns true, because the tokens "usability" and "Marigold"
are contained within different sentences: </p><div class="xpath"><div class="exampleInner"><pre>//book contains text "usability" ftand "Marigold" different sentence</pre></div></div><p>The following expression returns a <code>book</code> element, because it contains
"usability" and "testing" in the same paragraph:</p><div class="xpath"><div class="exampleInner"><pre>//book[. contains text "usability" ftand "testing" same paragraph] </pre></div></div><p>The following expression returns a <code>book</code> element, because "site" and
"errors" appear in the same sentence:</p><div class="xpath"><div class="exampleInner"><pre>//book[. contains text "site" ftand "errors" same sentence] </pre></div></div><p>It is possible that both "same sentence" and "different sentence" conditions are
simultaneously safisfied for several tokens and/or phrases within the same 
document fragment. This can be observed if there are occurrences of the tokens
and/or phrases both within the same sentence and within difference sentences. For
example, consider the following document fragment. </p><div class="exampleInner"><pre>
&lt;introduction&gt;
... The usability of a Web site is how well the site supports the user in
achieving specified goals. ... Expert reviews and usability testing are methods of
identifying problems in layout, terminology, and navigation. ...
&lt;/introduction&gt;
</pre></div><p>This sample will satisfy both conditions <code>("usability" ftand "reviews")
different sentence</code> and <code>("usability" ftand "reviews") same
sentence</code>. The tokens "usability" and "reviews" occur both in different sentences
(the first and second shown sentences) and in the same sentence (the second shown
sentences.) </p><p>The above observation also holds for the "same paragraph" and "different paragraph"
conditions.</p></div><div class="div3">
<h4><a name="ftcontent" id="ftcontent"/>3.6.5 Anchoring Selection</h4><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTContent" id="doc-xquery10-FTContent"/>[165]   </td><td><code><a href="#prod-xquery10-FTContent"><a href="#prod-xquery10-FTContent">FTContent</a></a></code></td><td>   ::=   </td><td><code>("at"  "start")  |  ("at"  "end")  |  ("entire"  "content")</code></td></tr></tbody></table><p>
                  [<a name="dt-anchoring-selection" id="dt-anchoring-selection" title="anchoring selection">Definition</a>: An
<b>anchoring selection</b> consists of a full-text selection followed
by one of the postfix operators "at start", "at end", or "entire content".] 
               </p><p>An anchoring selection selects matches which satisfy the operand full-text
selection and for which the matched tokens and phrases are
the first, last, or all tokens in the tokenized form of the items being searched.
</p><ul><li><p> Using the "at start" operator, tokens or phrases are matched, if they 
cover the first token position in the tokenized string value 
of the item being searched.</p></li><li><p> Using the "at end" operator, tokens or phrases are matched, if they
cover the last token position in the tokenized string value of the
item being searched.</p></li><li><p>Using the "entire content" operator, tokens or phrases are matched, if they
cover all token positions of the tokenized string value of the 
item being searched.</p></li></ul><p>The following expression returns each <code>title</code> element starting with the
phrase "improving the usability of a web site":</p><div class="xpath"><div class="exampleInner"><pre>/books//title[. contains text "improving the usability
of a web site" at start]</pre></div></div><p>The following expression returns the <code>p</code> element of the sample, 
because it ends with the phrase
"propagating few errors":</p><div class="xpath"><div class="exampleInner"><pre>/books//p[. contains text "propagat.*" using wildcards ftand "few
errors" distance at most 2 words at end]</pre></div></div><p>Since the distance operator doesn't imply an ordering, the last example 
would also yield a match if the <code>p</code> element ended with, say, 
"few errors are propagated".
</p><p>The following expression returns each <code>note</code> element whose entire content
is "this book has been approved by the web site users association":</p><div class="xpath"><div class="exampleInner"><pre>/books//note[. contains text "this book has been
approved by the web site users association" entire content]</pre></div></div><p>The following example returns true because
both the <code>content</code> and the <code>note</code> elements match:</p><div class="xpath"><div class="exampleInner"><pre>/books//* contains text "Association" at end</pre></div></div></div></div><div class="div2">
<h3><a name="ftignoreoption" id="ftignoreoption"/>3.7 Ignore Option</h3><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTIgnoreOption" id="doc-xquery10-FTIgnoreOption"/>[180]   </td><td><code><a href="#prod-xquery10-FTIgnoreOption"><a href="#prod-xquery10-FTIgnoreOption">FTIgnoreOption</a></a></code></td><td>   ::=   </td><td><code>"without"  "content"  <a href="#prod-xquery10-UnionExpr">UnionExpr</a>
                  </code></td></tr></tbody></table><p>The <b>ignore option</b> specifies a set of
nodes whose contents are ignored. It is applicable only to a top-level
<a href="#doc-xquery10-FTSelection">FTSelection</a> 
(see <a href="#doc-xquery10-FTContainsExpr">FTContainsExpr</a>). 
[<a name="IgnoredNodesDef" id="IgnoredNodesDef" title="IgnoredNodes">Definition</a>: 
                  <b>Ignored nodes</b> are the set of nodes whose content are 
    ignored.] Ignored nodes are identified
by the XQuery expression UnionExpr.
The value of the UnionExpr must be a sequence of zero or more nodes;
otherwise a type error is raised 
[<a href="http://www.w3.org/TR/xpath20/#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]<sup><small>XP</small></sup>.
</p><p>Let <code>I1, I2, ..., In</code>
be the sequence of items of the search context and let
<code>N1, N2, ..., Nk</code> be the sequence of nodes that
UnionExpr evaluates to. For each <code>Ij (j=1..n)</code> a copy is
made that omits each node <code>Ni (i=1..k)</code>.
Those copies form the new search context. If
UnionExpr evaluates to an empty sequence no nodes are omitted.</p><p>In the following fragment, if <code>$x//annotation</code> is ignored,
"Web Usability" will be found 2 times: once in the <code>title</code>
element and once in the <code>editor</code> element. The 2 occurrences
in the 2 <code>annotation</code> elements are ignored. On the other
hand, "expert" will not be found, as it appears only in an
<code>annotation</code> element.</p><div class="exampleInner"><pre>let $x := &lt;book&gt;
   &lt;title&gt;Web Usability and Practice&lt;/title&gt;
   &lt;author&gt;Montana &lt;annotation&gt; this author is
       an expert in Web Usability&lt;/annotation&gt; Marigold
   &lt;/author&gt;
   &lt;editor&gt;Véra Tudor-Medina on Web &lt;annotation&gt; best
       editor on Web Usability&lt;/annotation&gt; Usability
   &lt;/editor&gt;
 &lt;/book&gt;
 </pre></div><p>By default, no element content is ignored. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>Nodes <a title="may" href="#may">MAY</a> be ignored during
indexing and during query processing. The ignore option applies only
to query processing. Whether and how indexing ignores nodes is  
out of scope for this specification.</p></div></div><div class="div2">
<h3><a name="id-extension-selections" id="id-extension-selections"/>3.8 Extension Selections</h3><p>
               [<a name="dt-extension-selection" id="dt-extension-selection" title="extension selection">Definition</a>: An <b>extension selection</b> is a full-text selection whose semantics are
<a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.] 
Typically, a particular extension will be recognized
by some implementations and not by others. The syntax is designed so that
extension selections can be successfully parsed by all implementations, and
so that fallback behavior can be defined for implementations that do not
recognize a particular extension.</p><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="doc-xquery10-FTExtensionSelection" id="doc-xquery10-FTExtensionSelection"/>[154]   </td><td><code><a href="#prod-xquery10-FTExtensionSelection"><a href="#prod-xquery10-FTExtensionSelection">FTExtensionSelection</a></a></code></td><td>   ::=   </td><td><code>
                     <a href="#doc-xquery10-Pragma">Pragma</a>+  "{"  <a href="#doc-xquery10-FTSelection">FTSelection</a>?  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-xquery10-Pragma" id="doc-xquery10-Pragma"/>[69]   </td><td><code><a href="#prod-xquery10-Pragma"><a href="#prod-xquery10-Pragma">Pragma</a></a></code></td><td>   ::=   </td><td><code>"(#"  <a href="#prod-xquery10-S">S</a>?  <a href="#prod-xquery10-QName">QName</a>  (<a href="#prod-xquery10-S">S</a>  
                     <a href="#doc-xquery10-PragmaContents">PragmaContents</a>)?  "#)"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="doc-xquery10-PragmaContents" id="doc-xquery10-PragmaContents"/>[70]   </td><td><code><a href="#prod-xquery10-PragmaContents"><a href="#prod-xquery10-PragmaContents">PragmaContents</a></a></code></td><td>   ::=   </td><td><code>(<a href="#prod-xquery10-Char">Char</a>* - (Char* '#)' Char*))</code></td></tr></tbody></table><p>An extension selection consists of one or more pragmas followed by a full-text selection enclosed in curly braces. See
<a href="http://www.w3.org/TR/xquery/#id-extension-expressions">Section 
3.14 Extension Expressions</a><sup><small>XQ</small></sup> for information on 
pragmas in general.
A pragma is denoted by the delimiters <code>(#</code> and <code>#)</code>, and
consists of an identifying QName followed by <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>
content.
The content of a pragma may consist of any string of characters that does not contain the ending delimiter <code>#)</code>.  The QName of a 
pragma must resolve to a namespace URI and local name, using the statically known namespaces.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Since there is no default namespace for
pragmas, a pragma QName must include a namespace prefix.</p></div><p>Each implementation recognizes an
<a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> set of namespace
URIs used to denote pragmas.</p><p>If the namespace part of a pragma QName is not recognized by the
implementation as a pragma namespace, then the pragma
is ignored. If all the pragmas in an <a href="#doc-xquery10-FTExtensionSelection">FTExtensionSelection</a> are ignored, then full-text extension selection is just
the full-text selection enclosed in curly braces; if this full-text selection is absent, then a static error is
raised [<a href="http://www.w3.org/TR/xquery/#ERRXQST0079" title="err:XQST0079">err:XQST0079</a>]<sup><small>XQ</small></sup>.</p><p>If an implementation recognizes the namespace of one or more pragmas in an <a href="#doc-xquery10-FTExtensionSelection">FTExtensionSelection</a>, then the value
of the <a href="#doc-xquery10-FTExtensionSelection">FTExtensionSelection</a>, including its error behavior, is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>. For example, an implementation that recognizes the namespace of
a pragma QName, but does not recognize the local part of the QName, might choose
either to raise an error or to ignore the pragma.</p><p>It is a  static error [<a href="http://www.w3.org/TR/xquery/#ERRXQST0013" title="err:XQST0013">err:XQST0013</a>]<sup><small>XQ</small></sup> 
if an implementation recognizes a pragma but
determines that its content is invalid.</p><p>If an implementation recognizes a pragma, it must report any static
errors in the following full-text selection even if it will not apply that
selection.</p><p>The following examples illustrate three ways in which extension selections might be
used.</p><p>A pragma can be used to furnish a hint for how to evaluate the
following full-text selection, without actually changing the result.
For example:</p><div class="xquery"><div class="exampleInner"><pre>
declare namespace exq = "http://example.org/XQueryImplementation";

/books/book/author[name contains text (# exq:use-index #) {'Berners-Lee'}]
</pre></div></div><p>An implementation that recognizes the <code>exq:use-index</code> pragma might use an
index to evaluate the full-text selection that follows. An implementation that
does not recognize this pragma would evaluate the full-text selection in its normal 
way.</p><p>A pragma might be used to modify the semantics of the following
full-text selection in ways that would not (in the absence of the pragma) be
conformant with this specification.  For example, a pragma might be used to 
change distance counting so that adjacent words are at a distance of 1 
(otherwise they would be at a distance of 0):
</p><div class="xquery"><div class="exampleInner"><pre>
declare namespace exq = "http://example.org/XQueryImplementation";

/books/book[.//p contains text (# exq:distance #) { "web site"
ftand "usability" distance at most 1 words }]
</pre></div></div><p>
Such changes to the language
semantics must be scoped to the expression contained within the curly
braces following the pragma.</p><p>A pragma might contain syntactic constructs that are
evaluated in place of the following full-text selection. In this case, the
following selection itself (if it is present) provides a fallback for use by
implementations that do not recognize the pragma. For example:</p><div class="xquery"><div class="exampleInner"><pre>
declare namespace exq = "http://example.org/XQueryImplementation";

//city[. contains text (# exq:classifier with class 'Animals' #) 
       {"animal" using thesaurus at "http://example.org/thesaurus.xml" 
        relationship "RT"}]
</pre></div></div><p>Here an implementation that recognizes the pragma will return the result of
evaluating the proprietary syntax <code>with class 'animals'</code>,
while an implementation that does not recognize the pragma will instead
return the result of the thesaurus option. 
If no fallback expression is required, or
if none is feasible, then the expression between the curly braces may be
omitted, in which case implementations that do not recognize the pragma will
raise a static error.</p></div></div><div class="div1">
<h2><a name="tq-semantics" id="tq-semantics"/>4 Semantics</h2><p>This section describes the formal semantics of XQuery and XPath Full Text 1.0.
        The figure below shows how XQuery and XPath Full Text 1.0 integrates with XQuery 1.0
        and XPath 2.0.</p><p>The following diagram represents the interaction of
    XQuery and XPath Full Text 1.0 with the rest of XQuery 1.0 and XPath 2.0.
		It illustrates how full-text expressions can be nested within XQuery 1.0
		and XPath 2.0 expressions and vice versa. </p><img src="images/XQueryFullTextInteraction.jpg" alt="XQuery and Full Text Interaction diagram"/><ul><li><p>Step 1 represents the composability of XQuery 1.0
        and XPath 2.0 expressions and the fact that such expressions
        evaluate to a sequence of XDM items.  This process is outside the scope of this
        document and will not be discussed further.  </p></li><li><p>Step 2 shows how XQuery 1.0 and XPath 2.0 expressions
          can be nested within full-text expressions. 
          If an XQuery 1.0 and XPath 2.0 expression
          is nested on the left-hand side of an
          <b>FTContains</b> expression or within <b>FTWords</b>,
          the sequence of XDM items that result from evaluation
          of that XQuery 1.0 or XPath 2.0 expression
          are converted to their tokenized form, as described
          in <a href="#TokenizationSec">Tokenization</a>. 
          If the XQuery 1.0 and XPath 2.0 expression is nested
          within another type of <b>FTSelection</b>,
          the items in its result sequence are
          converted to atomic values, as discussed in 
          <a href="#ftselections">FTSelections</a>.</p></li><li><p>Step 3 represents the composability of <b>FTSelection</b>s. 
        Each <b>FTSelection</b> operates on zero or more
        <b>AllMatches</b> and returns an <b>AllMatches</b>. The process is
        described in the <a href="#FTSelectionEvalSec">Evaluation 
        of FTSelections</a> section. </p></li><li><p>Step 4 shows how XQuery and XPath Full Text 1.0 and scoring
        expressions can be nested into XQuery 1.0 and XPath 2.0 expressions.
        The sections <a href="#FTContainsSec"><b>4.3 FTContainsExpr</b></a> and <a href="#ScoreSec"><b>4.4 Scoring</b></a>
        describe how this is achieved.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>In the list above and throughout the rest of this section, bold 
		typeface has been used to distinguish the concepts that are part of the
		<a href="#AllMatchesSec">AllMatches</a> model.</p></div><p>The functions and schemas defined in this section are
		considered to be within the fts: namespace (as discussed in
    section <a href="#tq-ft-namespaces"><b>1.3 A word about namespaces</b></a>). These functions and schemas
		are used only for describing the semantics.  There is no
    requirement that an implementation of this specification must
    use the functions, schemas, or algorithms described in this
    section of this specification.  The only requirement is that
    implementations must achieve the same results that an implementation
    that does use these functions, schemas, and algorithms would
    achieve. </p><p>
    Note that by using XQuery 1.0 and XPath 2.0
    to specify the formal semantics,
    we avoid the need to introduce new formalism.
    We simply reuse the formal semantics of XQuery 1.0 and XPath 2.0.
    </p><div class="xquery"><div class="div2">
<h3><a name="TokenizationSec" id="TokenizationSec"/>4.1 Tokenization</h3><p>
               [<a name="TokenizationDef" id="TokenizationDef" title="Tokenization">Definition</a>: Formally, <b>tokenization</b> is the process 
        of converting
        an XDM item to a collections of tokens, taking any
        structural information of the item into account
        to identify token, sentence, and paragraph boundaries. Each token is
        assigned a starting and ending position.]
            </p><p>Tokenization, including the definition of the term "token",
        <a title="should" href="#should">SHOULD</a> be <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>. 
        Implementations <a title="should" href="#should">SHOULD</a> expose
        the rules and sample results of tokenization as much as possible
        to enable users to predict and interprete the results of tokenization. 
        Tokenization <a title="must" href="#must">MUST</a> conform to these 
        constraints:</p><ol class="enumar"><li><p>Each token <a title="must" href="#must">MUST</a> consist of
              one or more characters.</p></li><li><p>Tokenization of an item
              <a title="must" href="#must">MUST</a> include only tokens derived 
              from the string value of that item.  
              The string value is defined in <a href="#xpath-datamodel">[XQuery 1.0 and XPath 2.0 Data Model (XDM) (Second Edition)]</a> in
              <a href="http://www.w3.org/TR/xpath-datamodel/#StringValue">Section 
2.6.5 String Values</a><sup><small>DM</small></sup>; for element 
              nodes it does not include the contents of attributes, but for
              attribute nodes it does.
              </p></li><li><p>The tokenizer <a title="should" href="#should">SHOULD</a>, when
              tokenizing two equal items, identify the same tokens in each.
              The cases where it does not are <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.
              </p></li><li><p>The starting and ending position of a token
              <a title="must" href="#must">MUST</a> be integers, and the
              starting position <a title="must" href="#must">MUST</a> be
              less than or equal to the ending position.</p></li><li><p>In the tokenization of an item,
              consider the range of token positions
              from the smallest starting position to the largest ending position;
              every token position in that range must be covered by some token in the tokenization.
              That is, for every token position <code>P</code>,
              there must exist some token <code>T</code> such that
              <code>T's starting position &lt;= P &lt;= T's ending position</code>.
              </p></li><li><p>The tokenizer <a title="must" href="#must">MUST</a> preserve
              the containment hierarchy (paragraphs contain sentences contain 
              tokens) by adhering to the following constraints:</p><ol class="enumla"><li><p>
                Each token is contained in at most one sentence and at most
                one paragraph.
		(In particular, this means that
		no tokens of any sentence are contained in any other sentence,
		and
                no tokens of any paragraph are contained in any other paragraph.)
                </p></li><li><p>
                All tokens of a sentence are contained in at most
                one paragraph.
                </p></li><li><p>
                The range of token positions from the smallest starting position
                to the largest ending position in a sentence does not overlap
                with the token position range from any other sentence.
                </p></li><li><p>
                The range of token positions from the smallest starting position
                to the largest ending position in a paragraph does not overlap
                with the token position range from any other paragraph.
                </p></li></ol></li></ol><p>Useful information for tokenizer implementors may be found
        in <a href="#UAX29">[UAX29]</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Usually, the starting and ending positions of a 
        token are the same. 
        For some languages, some tokenizers may identify
        overlapping tokens.  For example, the German word
        "Donaudampfschifffahrtskapitaensmuetze" might be
        tokenized into the following tokens:
        "Donaudampfschifffahrtskapitaensmuetze", "Donau",
        "dampf", "schiff", "dampfschiff", "kapitaen", "muetze",
        "kapitaensmuetze", "schifffahrt", "dampfschifffahrt", 
        and perhaps others.
        In the face of overlapping tokens, it is implementation-dependent what
        positions a tokenizer assigns to each such token. For
        example, a tokenizer might assign the same position value to each of
        the tokens "Donaudampfschifffahrtskapitaensmuetze",
        "Donau", "dampf", "schiff", "dampfshiff", etc.
		In that case, the distance between each (overlapping) token
        assigned the same position is -1. Tokenizers might retain additional
        information about those overlapping tokens that allows the full-text
        implementation to distinguish among them.
        </p><p>Consider the sentence "Ich sehe den Dampfschifffahrtskapitän auf dem
        Fluß." If an implementation tokenizes "Dampfschifffahrtskapitän"
        as overlapping tokens at the same position, then the implementation
        could still determine that the query
        "'Schifffahrt Dampf' window 0 words ordered" fails to match the
        sentence because phrase
        matching is implementation-defined and may make use of additional
        implementation-dependent token information.
        </p><p>Even more complex situations can arise. Consider, for example,
        the German sentence "Er stellte sie vor." A sophisticated tokenizer
        might construct the token "vorstellen" covering positions 2 through 4,
        which overlaps the token "sie" at position 3.  For the purposes of
        distance calculations, tokens are considered in the order of their
        starting positions, so the distance between "vorstellen" and
        "sie" would be 3-4-1=-2. (See <code>fts:wordDistance</code>, below.)</p></div><div class="xquery"><div class="div3">
<h4><a name="tq-ft-Tokenization-examples" id="tq-ft-Tokenization-examples"/>4.1.1 Examples</h4><p>For example, the following example must return false, because the 'secret'
only occurs within an attribute and a comment, neither of which contributes
characters to the string value of the 'p' element node:
</p><div class="xquery"><div class="exampleInner"><pre>
&lt;p kind='secret'&gt;Sensitive material &lt;!-- secret --&gt;&lt;/p&gt; contains text 'secret'

</pre></div></div><p>The following document may lead to overlapping tokens to account for the
ambiguity caused by the hyphen:
</p><div class="exampleInner"><pre>
&lt;p&gt;I will re-
sign tommorow.&lt;/p&gt;

</pre></div><p>The following document fragment is the source document for examples in this section. 
    A sample tokenization is used for the examples in this section. 
    The results might be different for other tokenizations.</p><p>Unless stated otherwise, the results assume a case-insensitive match.</p><div class="exampleInner"><pre>
&lt;offers&gt;
    &lt;offer id="1000" price="10000"&gt;
        Ford Mustang 2000, 65K, excellent condition, runs 
        great, AC, CC, power all
    &lt;/offer&gt;
    &lt;offer id="1001" price="8000"&gt;
        Honda Accord 1999, 78K, A/C, cruise control, runs 
        and looks great, excellent condition
    &lt;/offer&gt;
    &lt;offer id="1005" price="5500"&gt;
        Ford Mustang, 1995, 150K highway mileage, no rust, 
        excellent condition
    &lt;/offer&gt;
&lt;/offers&gt;
        </pre></div><p>In this sample tokenization, tokens are delimited by punctuation and 
		whitespace symbols. </p><ul><li><p>The token "Ford" is at relative position 1.</p></li><li><p>The token "Mustang" is at relative position 2.</p></li><li><p>The token "2000" is at relative position 3.</p></li><li><p>Relative position numbers are assigned sequentially through the 
		end of the document.</p></li></ul><p>Hence in this example each token occupies exactly one position, and no overlapping of 
                tokens occurs. The relative positions of tokens
                are shown
                below in parentheses.</p><div class="exampleInner"><a name="SampleTokenizedDoc" id="SampleTokenizedDoc"/><pre>
&lt;offers&gt;
    &lt;offer id="1000" price="10000"&gt;
        Ford(1) Mustang(2) 2000(3), 65K(4), excellent(5)
        condition(6), runs(7) great(8), AC(9), CC(10), 
        power(11) all(12)
    &lt;/offer&gt;
    &lt;offer id="1001" price="8000"&gt;
        Honda(13) Accord(14) 1999(15), 78K(16), A(17)/C(18),
        cruise(19) control(20), runs(21) and(22) looks(23)
        great(24), excellent(25) condition(26)
    &lt;/offer&gt;
    &lt;offer id="1005" price="5500"&gt;
        Ford(27) Mustang(28), 1995(29), 150K(30) highway(31)
        mileage(32), little(33)  rust(34), excellent(35) 
        condition(36)
    &lt;/offer&gt;
&lt;/offers&gt;
        </pre></div><p>The relative positions of paragraphs are determined similarly. In
		this sample tokenization, the paragraph delimiters are start tags and 
        end tags.</p><ul><li><p>The tokens in the first 'offer' element are assigned relative 
		paragraph number 1.</p></li><li><p>The tokens from the next 'offer' element are assigned relative  
		paragraph number 2.</p></li><li><p>Relative paragraph numbers are assigned sequentially through 
		the end of the document.</p></li></ul><p>The relative positions of sentences are determined similarly using 
        sentence delimiters.</p><p>Implementations may provide for the means to ignore or side-step
           certain structural elements when performing tokenization.  In the
           following example, the implementation has decided to ignore the
           markup for <code>&lt;bold&gt;</code> and prune out the entire
           subtree headed by <code>&lt;deleted&gt;</code>.</p><div class="exampleInner"><pre>
&lt;para&gt;&lt;deleted&gt;This sentence was deleted.&lt;/deleted&gt;
This &lt;bold&gt;entire paragraph&lt;/bold&gt; is one sentence
as far as the tokenizer is concerned.
&lt;/para&gt;
</pre></div><p>Using the same notation as before, this sample tokenization is
        shown below. All the tokens marked with a
        token position also have the same sentence and paragraph relative
        positions. Note that there are no tokens marked for the 
        ignored subtree.
        </p><div class="exampleInner"><pre>
&lt;para&gt;&lt;deleted&gt;This sentence was deleted.&lt;/deleted&gt;
This(1) &lt;bold&gt;entire(2) paragraph(3)&lt;/bold&gt; is(4) one(5) sentence(6)
as(7) far(8) as(9) the(10) tokenizer(11) is(12) concerned(13).
&lt;/para&gt;
</pre></div></div></div><div class="xquery"><div class="div3">
<h4><a name="TokenizationRepresentationsSec" id="TokenizationRepresentationsSec"/>4.1.2 Representations of Tokenized Text and Matching</h4><p>
                  [<a name="QueryItemDef" id="QueryItemDef" title="QueryItem">Definition</a>: A <b>QueryItem</b> is a sequence of
        <b>QueryTokenInfo</b>s representing the collection of tokens derived
        from tokenizing one query string. ]
               </p><p>
                  [<a name="QueryTokenInfoDef" id="QueryTokenInfoDef" title="QueryTokenInfo">Definition</a>: A <b>QueryTokenInfo</b> is the
        identity of a token inside a query string. ]
        Each <b>QueryTokenInfo</b> is
        associated with a <span class="diff-chg">position</span>
        that captures the relative
        position of the query string in the query.</p><p>
                  [<a name="TokenInfoDef" id="TokenInfoDef" title="TokenInfo">Definition</a>: A <b>TokenInfo</b> 
        represents a contiguous collection of tokens from an XML document. 
        ]
        Each <b>TokenInfo</b> is associated with:</p><ul><li><p>
                        <code>startPos</code>: the smallest starting position
                of a token in the sequence</p></li><li><p>
                        <code>endPos</code>: the largest ending position
                of any token of the sequence</p></li><li><p>
                        <code>startSent</code>: the relative position of the 
                sentence containing the token with the smallest starting
                position
                or zero if the tokenizer does not report
                sentences</p></li><li><p>
                        <code>endSent</code>: the relative position of the sentence 
                containing the token with the largest ending position
                or zero if the tokenizer does not report
                sentences</p></li><li><p>
                        <code>startPara</code>: the relative position of the 
                paragraph containing the token with the smallest starting
                position or zero if the tokenizer does not report
                paragraphs</p></li><li><p>
                        <code>endPara</code>: the relative position of the paragraph
                containing the token with the largest ending position or
                zero if the tokenizer does not report paragraphs</p></li></ul><p>The following matching function is the central
        <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> primitive performing the full-text
        retrieval.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:matchTokenInfos (
      $searchContext as item(),
      $matchOptions as element(fts:matchOptions),
      $stopWords as xs:string*,
      $queryTokens as element(fts:queryToken)* )
   as element(fts:tokenInfo)*  external;
            </pre></div></div><p>The above function returns the <b>TokenInfo</b>s in items in
        <code>$searchContext</code> that match the query string represented by
        the sequence <code>$queryTokens</code>, when using the match
        options in <code>$matchOptions</code> and stop words in
        <code>$stopWords</code>. If <code>$queryTokens</code> is a
        sequence of more than one query token, each returned
        <b>TokenInfo</b> must represent a phrase matching that sequence. 
        </p><div class="note"><p class="prefix"><b>Note:</b></p><p>While this matching function assumes a tokenized
      representation of the query strings, it does not assume a tokenized
      representation of the input items in <code>$searchContext</code>,
      i.e. the texts being searched.
      Hence, the tokenization of the search context is implicit in
      this function and coupled to the retrieval of matches. 
      Of course, this does not imply that tokenization of the
      search context cannot be done a priori. 
      The tokenization of each item in <code>$searchContext</code> does not
      necessarily take into account the match options in
      <code>$matchOptions</code> or the query tokens in
      <code>$queryTokens</code>. 
      This allows implementations to tokenize and index input data
      without the knowledge of particular match options
      used in full-text queries.</p></div></div></div></div></div><div class="xquery"><div class="div2">
<h3><a name="FTSelectionEvalSec" id="FTSelectionEvalSec"/>4.2 Evaluation of FTSelections</h3><p>The XQuery 1.0 and XPath 2.0 Data Model is
        inadequate to support fully composable <b>FTSelection</b>s. 
        Full-text operations, such as <b>FTSelection</b>s, operate on linguistic
        units, such as positions of tokens, and which are not captured
        in the XQuery 1.0 and XPath 2.0 Data Model (XDM). </p><p>XQuery and XPath Full Text adds relative token, sentence, and 
		paragraph position numbers via <b>AllMatches</b>. <b>AllMatches</b> make 
		<b>FTSelection</b>s fully composable.</p><div class="xquery"><div class="div3">
<h4><a name="AllMatchesSec" id="AllMatchesSec"/>4.2.1 AllMatches</h4><div class="xquery"><div class="div4">
<h5><a name="tq-ft-formalmodel" id="tq-ft-formalmodel"/>4.2.1.1 Formal Model</h5><p>
                     [<a name="AllMatchesDef" id="AllMatchesDef" title="AllMatches">Definition</a>: An <b>AllMatches</b>
                describes the possible results of an <b>FTSelection</b>.]
                The UML Static Class diagram of <b>AllMatches</b> is shown
                on the diagram given below.</p><img src="images/AllMatchesClassDiagram.png" alt="AllMatches class diagram"/><p>The <b>AllMatches</b> object contains zero or more <b>Match</b>es. </p><p>
                     [<a name="MatchDef" id="MatchDef" title="Match">Definition</a>: Each  
                <b>Match</b> describes one result to the <b>FTSelection</b>.] 
				The result is described in terms of zero or more <b>StringInclude</b>s and zero
                or more <b>StringExclude</b>s.</p><p>
                     [<a name="StringMatchDef" id="StringMatchDef" title="StringMatch">Definition</a>: A
				<b>StringMatch</b> is a
				possible match of a sequence of query
				tokens with a corresponding sequence
				of tokens in a document. A StringMatch may be a <b>StringInclude</b>
				or <b>StringExclude</b>.] The <b>queryPos</b> 
				attribute specifies the position of the query token in the 
				query. This attribute is needed for <b>FTOrder</b>s. The matched
				document token sequence is described in the <b>TokenInfo</b> 
                associated with
				the <b>StringMatch</b>.</p><p>
                     [<a name="StringIncludeDef" id="StringIncludeDef" title="StringInclude">Definition</a>: A <b>StringInclude</b>
				is a <b>StringMatch</b> that describes a <b>TokenInfo</b> that must be
				contained in the document.]
                  </p><p>
                     [<a name="StringExcludeDef" id="StringExcludeDef" title="StringExclude">Definition</a>: A <b>StringExclude</b>
				is a <b>StringMatch</b> that describes a <b>TokenInfo</b> that must not be
				contained in the document.]
                  </p><p>Intuitively, <b>AllMatches</b> specifies the <b>TokenInfo</b>s that a
                search context item contains and does not contain to satisfy an <b>FTSelection</b>.</p><p>The <b>AllMatches</b> structure resembles the Disjunctive Normal
                Form (DNF) in propositional and first-order logic. The
                <b>AllMatches</b> is a disjunction of <b>Match</b>es. Each <b>Match</b> is a
                conjunction of <b>StringInclude</b>s, and <b>StringExclude</b>s. </p></div></div><div class="xquery"><div class="div4">
<h5><a name="tq-ft-AllMatches-examples" id="tq-ft-AllMatches-examples"/>4.2.1.2 Examples</h5><p>Since in most of the examples below the tokens span only a single 
                position, we characterize the <b>TokenInfo</b> instance by simply giving this position, 
                written as "Pos:X". This should be read as the value for both, the 
                <code>startPos</code> and the <code>endPos</code>
                attribute. Furthermore, for expository reasons, we
                include in each <b>StringMatch</b> example an attribute
                "query string", set to the original
                query string, in order to facilitate the association
                from which query string that match came from.</p><p>The simplest example of an <b>FTSelection</b> is an <b>FTWords</b> such 
				as  <code>"Mustang"</code>. The
                <b>AllMatches</b> corresponding to this <b>FTWords</b> is given below. </p><img src="images/SampleAllMatches1.jpg" alt="Sample AllMatches"/><p>As shown, the <b>AllMatches</b> consists of two <b>Match</b>es. Each
                <b>Match</b> represents one possible result of the <b>FTWords</b>
                     <code>"Mustang"</code>. The result represented by the first
                <b>Match</b>, represented as a <b>StringInclude</b>, contains the token
                "Mustang" at position 2. The result described by the second <b>Match</b>
                contains the token "Mustang" at position 28. </p><p>A more complex example of an <b>FTSelection</b> is an <b>FTWords</b> 
				such as <code>"Ford Mustang"</code>. The <b>AllMatches</b> for this 
				<b>FTWords</b> is given below.</p><img src="images/SampleAllMatches2.jpg" alt="Sample AllMatches"/><p>There are two possible results for this <b>FTWords</b>, and
                these are represented by the two <b>Match</b>es. Each of the
                <b>Match</b>es requires two tokens to be matched. The first <b>Match</b> is 
				obtained by matching "Ford" at position 1 and matching "Mustang" at position 2.
                Similarly, the second <b>Match</b> is obtained by
                matching "Ford" at position 27 and "Mustang" at position 28.</p><p>An even more complex example of an <b>FTSelection</b> is an 
				<b>FTSelection</b> such as <code>"Mustang"
                ftand ftnot "rust"</code> that searches for 
                "Mustang" but not "rust". The <b>AllMatches</b> for this
                <b>FTSelection</b> is given below.</p><img src="images/SampleAllMatches3.jpg" alt="Sample AllMatches"/><p>This example introduces <b>StringExclude</b>. <b>StringExclude</b> 
				corresponds to negation in DNF (Disjunctive Normal Form). It specifies that the 
                result described by the corresponding <b>Match</b> must not match the token at 
                the specified position. In this example, the first <b>Match</b> specifies 
                that "Mustang" is matched at position 2, and that the token "rust" 
                at position 34 is not matched.</p></div></div><div class="div4">
<h5><a name="tq-ft-XML-representation" id="tq-ft-XML-representation"/>4.2.1.3 XML representation</h5><p> 
                     <b>AllMatches</b> has a well-defined hierarchical
                structure. Therefore, the <b>AllMatches</b> can be easily
                modeled in XML. 
                This XML representation and those which follow formally describe the
                semantics of <b>FTSelection</b>s. For example, 
                the XML representation of <b>AllMatches</b> formally
                specifies how an <b>FTSelection</b> operates on zero or more
                <b>AllMatches</b> to produce a resulting <b>AllMatches</b>. </p><p>The XML schema for representing <b>AllMatches</b> is
                given below.</p><div class="semfunc-file-allmatches-xsd"><div class="exampleInner"><pre>
&lt;xs:schema 
     xmlns:xs="http://www.w3.org/2001/XMLSchema" 
     xmlns:fts="http://www.w3.org/2007/xpath-full-text"
     targetNamespace="http://www.w3.org/2007/xpath-full-text"
     elementFormDefault="qualified" 
     attributeFormDefault="unqualified"&gt;

  &lt;xs:complexType name="allMatches"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="fts:match" 
                  minOccurs="0" 
                  maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="stokenNum" type="xs:integer" use="required" /&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="allMatches" type="fts:allMatches"/&gt;

  &lt;xs:complexType name="match"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="fts:stringInclude" 
                  minOccurs="0" 
                  maxOccurs="unbounded"/&gt;
      &lt;xs:element ref="fts:stringExclude" 
                  minOccurs="0" 
                  maxOccurs="unbounded"/&gt;
   &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:element name="stringInclude" 
              type="fts:stringMatch" /&gt;

  &lt;xs:element name="stringExclude" 
              type="fts:stringMatch" /&gt;

  &lt;xs:element name="match" type="fts:match"/&gt;

  &lt;xs:complexType name="stringMatch"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="fts:tokenInfo"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="queryPos" 
                  type="xs:integer" 
                  use="required"/&gt;
    &lt;xs:attribute name="isContiguous" 
                  type="xs:boolean" 
                  use="required"/&gt;  
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="tokenInfo"&gt;
    &lt;xs:attribute name="startPos" 
                  type="xs:integer" 
                  use="required"/&gt;
    &lt;xs:attribute name="endPos" 
                  type="xs:integer" 
                  use="required"/&gt;
    &lt;xs:attribute name="startSent" 
                  type="xs:integer" 
                  use="required"/&gt;
    &lt;xs:attribute name="endSent" 
                  type="xs:integer" 
                  use="required"/&gt;
    &lt;xs:attribute name="startPara" 
                  type="xs:integer" 
                  use="required"/&gt;
    &lt;xs:attribute name="endPara" 
                  type="xs:integer" 
                  use="required"/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="tokenInfo" type="fts:tokenInfo"/&gt;

  &lt;xs:complexType name="queryItem"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="fts:queryToken" 
                  minOccurs="0" 
                  maxOccurs="unbounded"/&gt;
   &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="queryTokenInfo"&gt;
    &lt;xs:attribute name="word" 
                  type="xs:string" 
                  use="required"/&gt;
    &lt;xs:attribute name="queryPos" 
                  type="xs:integer" 
                  use="required"/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="queryToken" type="fts:queryTokenInfo"/&gt;
&lt;/xs:schema&gt;
                </pre></div></div><p>The <code>stokenNum</code> attribute in 
	<b>AllMatches</b> is related to the representation of the semantics as XQuery functions. 
	Therefore, it is not considered part of the <b>AllMatches</b> model.
	The <code>stokenNum</code> attribute stores
	the number of query tokens used when evaluating the <b>AllMatches</b>. This 
	value is used to compute the correct value for the <code>queryPos</code>
	attribute in new <b>StringMatch</b>es. </p></div></div></div><div class="xquery"><div class="div3">
<h4><a name="FTSelectionsXMLSec" id="FTSelectionsXMLSec"/>4.2.2 XML Representation</h4><p>
                  <b>FTSelection</b>s are fully composable and may be nested arbitrarily under
        other <b>FTSelection</b>s. Each <b>FTSelection</b> may be associated with
        match options (such as stemming and stop words) and score weights.
        Since score weights are solely interpreted by the formal semantics
        scoring function, they do not influence the semantics of
        <b>FTSelection</b>s. Therefore, score weights are not considered in
        the formal semantics.</p><p>
            The XML structures defined by the following schema
            represent <b>FTSelection</b>s
            within the semantic functions of section <a href="#tq-semantics"><b>4 Semantics</b></a>.
            This representation is used for definitional purposes only
            and should not be confused with
            the XML representation for queries in Appendix <a href="#id-xqft-xqueryx"><b>E XML Syntax (XQueryX) for XQuery and XPath Full Text 1.0</b></a>.
	    Every <b>FTSelection</b>
	    is represented as an XML element. Every nested <b>FTSelection</b> is
	    represented as a nested descendant element. 
	    For binary <b>FTSelection</b>s, e.g., <b>FTAnd</b>, the nested <b>FTSelection</b>s
	    are represented in <code>&lt;left&gt;</code> and <code>&lt;right&gt;
	    </code> descendant elements. For unary <b>FTSelection</b>s, a 
	    <code>&lt;selection&gt;</code> descendant element is used. Additional
	    characteristics of <b>FTSelection</b>s, e.g., the distance unit for
	    <b>FTDistance</b>, are stored in attributes. </p><div class="semfunc-file-ftselection-xsd"><div class="exampleInner"><pre>
&lt;xs:schema
     xmlns:xs="http://www.w3.org/2001/XMLSchema" 
     xmlns:fts="http://www.w3.org/2007/xpath-full-text"
     targetNamespace="http://www.w3.org/2007/xpath-full-text"
     elementFormDefault="qualified" 
     attributeFormDefault="unqualified"&gt;
           
  &lt;xs:include schemaLocation="AllMatches.xsd" /&gt;
  &lt;xs:include schemaLocation="MatchOptions.xsd" /&gt;

  &lt;xs:complexType name="ftSelection"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:choice&gt;
        &lt;xs:element name="ftWords" type="fts:ftWords"/&gt;
        &lt;xs:element name="ftAnd" type="fts:ftAnd"/&gt;
        &lt;xs:element name="ftOr" type="fts:ftOr"/&gt;
        &lt;xs:element name="ftUnaryNot" type="fts:ftUnaryNot"/&gt;
        &lt;xs:element name="ftMildNot" type="fts:ftMildNot"/&gt;
        &lt;xs:element name="ftOrder" type="fts:ftOrder"/&gt;
        &lt;xs:element name="ftScope" type="fts:ftScope"/&gt;
        &lt;xs:element name="ftContent" type="fts:ftContent"/&gt;
        &lt;xs:element name="ftDistance" type="fts:ftDistance"/&gt;
        &lt;xs:element name="ftWindow" type="fts:ftWindow"/&gt;
        &lt;xs:element name="ftTimes" type="fts:ftTimes"/&gt;
      &lt;/xs:choice&gt;
      &lt;xs:element ref="fts:matchOptions" 
                  minOccurs="0"/&gt;
      &lt;xs:element name="weight" 
                  type="xs:double" 
                  minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="selection" type="fts:ftSelection"/&gt;

  &lt;xs:complexType name="ftWords"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="fts:queryItem" 
                  minOccurs="0" 
                  maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="type" 
                  type="fts:ftWordsType" 
                  use="required"/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="queryItem" type="fts:queryItem"/&gt;
  
  &lt;xs:complexType name="ftAnd"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="left" type="fts:ftSelection"/&gt;
      &lt;xs:element name="right" type="fts:ftSelection"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="ftOr"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="left" type="fts:ftSelection"/&gt;
      &lt;xs:element name="right" type="fts:ftSelection"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="ftUnaryNot"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="selection" type="fts:ftSelection"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="ftMildNot"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="left" type="fts:ftSelection"/&gt;
      &lt;xs:element name="right" type="fts:ftSelection"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="ftOrder"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="selection" type="fts:ftSelection"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="ftScope"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="selection" type="fts:ftSelection"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="type" 
                  type="fts:scopeType" 
                  use="required"/&gt;
    &lt;xs:attribute name="scope" 
                  type="fts:scopeSelector" 
                  use="required"/&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="ftContent"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="selection" type="fts:ftSelection"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="type" 
                  type="fts:contentMatchType" 
                  use="required"/&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="ftDistance"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="range" type="fts:ftRangeSpec"/&gt;
      &lt;xs:element name="selection" type="fts:ftSelection"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="type" 
                  type="fts:distanceType" 
                  use="required"/&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="ftWindow"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="selection" type="fts:ftSelection"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="size" 
                  type="xs:integer" 
                  use="required"/&gt;
    &lt;xs:attribute name="type" 
                  type="fts:distanceType" 
                  use="required"/&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="ftTimes"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="range" type="fts:ftRangeSpec"/&gt;
      &lt;xs:element name="selection" type="fts:ftWords"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
    
  &lt;xs:simpleType name="ftWordsType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="any"/&gt;
      &lt;xs:enumeration value="all"/&gt;
      &lt;xs:enumeration value="phrase"/&gt;
      &lt;xs:enumeration value="any word"/&gt;
      &lt;xs:enumeration value="all word"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="scopeType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="same"/&gt;
      &lt;xs:enumeration value="different"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="scopeSelector"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="paragraph"/&gt;
      &lt;xs:enumeration value="sentence"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="distanceType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="paragraph"/&gt;
      &lt;xs:enumeration value="sentence"/&gt;
      &lt;xs:enumeration value="word"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="contentMatchType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="at start"/&gt;
      &lt;xs:enumeration value="at end"/&gt;
      &lt;xs:enumeration value="entire content"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
&lt;/xs:schema&gt;
            </pre></div></div></div></div><div class="xquery"><div class="div3">
<h4><a name="tq-ft-evaluate-function" id="tq-ft-evaluate-function"/>4.2.3 The <code>evaluate</code> function</h4><p>The semantics for the evaluation of
            <b>FTSelection</b>s is defined using the <code>fts:evaluate</code> 
			function. The function takes three
            parameters: (1) an <b>FTSelection</b>, 2) a search
            context item, and 3) the default set of match options
            that apply to the evaluation of the <b>FTSelection</b>.</p><p>The <code>fts:evaluate</code> function returns the
            <b>AllMatches</b> that is the result of evaluating the
            <b>FTSelection</b>. When <code>fts:evaluate</code> is applied to some
            <b>FTSelection</b> X, it calls the function
            <code>fts:ApplyX</code> to build the resulting <b>AllMatches</b>.
            If X is applied on nested <b>FTSelection</b>s, the 
            <code>fts:evaluate</code> function is recursively called on these nested
            <b>FTSelection</b>s and the returned <b>AllMatches</b> are used in the evaluation of
            <code>fts:ApplyX</code>.
            </p><p>The semantics for the <code>fts:evaluate</code> function 
            is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:evaluate (
      $ftSelection as element(*, fts:ftSelection), 
      $searchContext as item(),
      $matchOptions as element(fts:matchOptions),
      $queryTokenNum as xs:integer )
   as element(fts:allMatches)
{
   if (fn:count($ftSelection/fts:matchOptions) &gt; 0) then 
      (: First we deal with all match options that the    :)
      (: FTSelection might bear: we add the match options :)
      (: to the current match options structure, and      :)
      (: pass the new structure to the recursive call.    :)
      let $newFTSelection := 
         &lt;fts:selection&gt;{$ftSelection/*
                           [fn:not(self::fts:matchOptions)]}&lt;/fts:selection&gt;
      return fts:evaluate($newFTSelection, 
                          $searchContext, 
                          fts:replaceMatchOptions($matchOptions, 
                                              $ftSelection/fts:matchOptions),
                          $queryTokenNum)
   else if (fn:count($ftSelection/fts:weight) &gt; 0) then
      (: Weight has no bearing on semantics -- just :)
      (: call "evaluate" on nested FTSelection     :)
      let $newFTSelection := $ftSelection/*[fn:not(self::fts:weight)]
      return fts:evaluate($newFTSelection, 
                          $searchContext, 
                          $matchOptions,
                          $queryTokenNum)
   else
      typeswitch ($ftSelection/*[1]) 
         case $nftSelection as element(fts:ftWords) return
            (: Apply the FTWords in the search context :)
            fts:ApplyFTWords($searchContext,
                             $matchOptions,
                             $nftSelection/@type,
                             $nftSelection/fts:queryItem,
                             $queryTokenNum + 1)
         case $nftSelection as element(fts:ftAnd) return
            let $left := fts:evaluate($nftSelection/fts:left,
                                     $searchContext,
                                     $matchOptions,
                                     $queryTokenNum)
            let $newQueryTokenNum := $left/@stokenNum
            let $right := fts:evaluate($nftSelection/fts:right,
                                      $searchContext,
                                      $matchOptions,
                                      $newQueryTokenNum)
            return fts:ApplyFTAnd($left, $right)
         case $nftSelection as element(fts:ftOr) return
            let $left := fts:evaluate($nftSelection/fts:left,
                                     $searchContext,
                                     $matchOptions,
                                     $queryTokenNum)
            let $newQueryTokenNum := $left/@stokenNum
            let $right := fts:evaluate($nftSelection/fts:right,
                                      $searchContext,
                                      $matchOptions,
                                      $newQueryTokenNum)
            return fts:ApplyFTOr($left, $right)
         case $nftSelection as element(fts:ftUnaryNot) return
            let $nested := fts:evaluate($nftSelection/fts:selection,
                                        $searchContext,
                                        $matchOptions,
                                        $queryTokenNum)
            return fts:ApplyFTUnaryNot($nested)
         case $nftSelection as element(fts:ftMildNot) return
            let $left := fts:evaluate($nftSelection/fts:left,
                                     $searchContext,
                                     $matchOptions,
                                     $queryTokenNum)
            let $newQueryTokenNum := $left/@stokenNum
            let $right := fts:evaluate($nftSelection/fts:right,
                                      $searchContext,
                                      $matchOptions,
                                      $newQueryTokenNum)
            return fts:ApplyFTMildNot($left, $right)
         case $nftSelection as element(fts:ftOrder) return
            let $nested := fts:evaluate($nftSelection/fts:selection,
                                        $searchContext,
                                        $matchOptions,
                                        $queryTokenNum)
            return fts:ApplyFTOrder($nested)
         case $nftSelection as element(fts:ftScope) return
            let $nested := fts:evaluate($nftSelection/fts:selection,
                                        $searchContext,
                                        $matchOptions,
                                        $queryTokenNum)
            return fts:ApplyFTScope($nftSelection/@type, 
                                    $nftSelection/@scope,
                                    $nested)
         case $nftSelection as element(fts:ftContent) return
            let $nested := fts:evaluate($nftSelection/fts:selection,
                                        $searchContext,
                                        $matchOptions,
                                        $queryTokenNum)
            return fts:ApplyFTContent($searchContext,
                                      $nftSelection/@type, 
                                      $nested)
         case $nftSelection as element(fts:ftDistance) return
            let $nested := fts:evaluate($nftSelection/fts:selection,
                                        $searchContext,
                                        $matchOptions,
                                        $queryTokenNum)
            return fts:ApplyFTDistance($nftSelection/@type,
                                       $nftSelection/fts:range,
                                       $nested)
         case $nftSelection as element(fts:ftWindow) return
            let $nested := fts:evaluate($nftSelection/fts:selection,
                                        $searchContext,
                                        $matchOptions,
                                        $queryTokenNum)
            return fts:ApplyFTWindow($nftSelection/@type,
                                     $nftSelection/@size,
                                     $nested)
         case $nftSelection as element(fts:ftTimes) return
            let $nested := fts:evaluate($nftSelection/fts:selection,
                                        $searchContext,
                                        $matchOptions,
                                        $queryTokenNum)
            return fts:ApplyFTTimes($nftSelection/fts:range,
                                    $nested)
         default return &lt;fts:allMatches stokenNum="0" /&gt;
};
            </pre></div></div><p>For
            concreteness, assume that the <b>FTSelection</b> was
            invoked inside an <code>contains text</code> expression such
            as <code>searchContext contains text ftSelection</code>. In order to 
	    determine the
            <b>AllMatches</b> result of <code>ftSelection</code>, the
            <code>fts:evaluate</code> function is invoked as
            follows: <code>fts:evaluate($ftSelection,
            $searchContext, $matchOptions, 0)</code>, where
            <code>$ftSelection</code> is the XML representation of the
            <code>ftSelection</code> and
            <code>$searchContext</code> is bound to the result of
            the evaluation of the XQuery expression
            <code>searchContext</code>. </p><p>Initially, the
            <code>$queryTokensNum</code> is 0, i.e., no
            query tokens have been processed.</p><p>The variable <code>$matchOptions</code> is bound to the 
            list of match options as defined in the static context (see
            Appendix <a href="#id-xqft-static-context-components"><b>C Static Context Components</b></a>).
			Match options embedded in
            <code>$ftSelection</code> modify the match options collection as
            evaluation proceeds. </p><p>Given the invocation of: <code>fts:evaluate($ftSelection,
            $searchContext, $matchOptions)</code>, evaluation proceeds as
            follows. First, <code>$ftSelection</code> is checked to see whether
	    1) it contains a match option,
	    2) it contains a weight specification,
	    3) it is an <b>FTWords</b>, or
	    4) none of the above hold.
            </p><ol class="enumar"><li><p>If <code>$ftSelection</code> contains one or more match options,
            these are combined with the inherited match options
            via a call to <code>fts:replaceMatchOptions</code>
            (see <a href="#FTMatchOptionsSec"><b>4.2.5 Match Options Semantics</b></a>).
            The <code>evaluate</code> function is then invoked on the
            nested <b>FTSelection</b> with the new set of match options,
            and the result of that call is returned.
            </p></li><li><p>If <code>$ftSelection</code> contains a weight
            specification, then the specification is ignored because it
            does not alter the semantics. The <code>evaluate</code>
            function is recursively called on the nested <b>FTSelection</b> and the
            resulting <b>AllMatches</b> is returned. </p></li><li><p>If <code>$ftSelection</code> is an <b>FTWords</b>, then 
			it does
            not have any nested <b>FTSelection</b>s. Consequently, this is the base
            of the recursive call, and the <b>AllMatches</b> result of the <b>FTWords</b>
            is computed and returned. The <b>AllMatches</b> is computed by invoking
            the <code>ApplyFTWords</code> function with the current
            search context and other necessary information. </p></li><li><p>If <code>$ftSelection</code> contains neither a match
            option nor a weight specification and is not an <b>FTWords</b>, the
            <b>FTSelection</b> performs a full-text operation, such as
            <code>ftand</code>, <code>ftor</code>, <code>window</code>.
            These operations are fully-compositional and may be
            invoked on nested <b>FTSelection</b>s. Consequently, evaluation proceeds
            as follows. </p><ul><li><p>First, the <code>evaluate</code> function is
            recursively invoked on each nested <b>FTSelection</b>.
				The result of
            evaluating each nested <b>FTSelection</b> is an <b>AllMatches</b>. </p></li><li><p>The <b>AllMatches</b> are transformed into the resulting 
			<b>AllMatches</b> by applying the full-text operation corresponding to 
			<code>FTSelection1</code> which is
            generically named <code>applyX</code> for some type of
            <b>FTSelection</b> X in the code.  </p></li></ul><p>For example, let
            <code>FTSelection1</code> be <code>FTSelection2 ftand
            FTSelection3 </code>. Here <code>FTSelection2</code> and
            <code>FTSelection3</code> may themselves be arbitrarily nested
            <b>FTSelection</b>s. Thus, <code> evaluate</code> is invoked on
            <code>FTSelection2</code> and <code> FTSelection3</code>, and the
            resulting <b>AllMatches</b> are transformed to the final <b>AllMatches</b>
            using the <code> ApplyFTAnd</code> function corresponding to
            <code>ftand </code>.</p></li></ol><p>The semantics of the <code>ApplyX</code> function for
            each <b>FTSelection</b> kind X is given below.</p></div></div><div class="xquery"><div class="div3">
<h4><a name="tq-ft-fs-FTWords" id="tq-ft-fs-FTWords"/>4.2.4 FTWords</h4><p>An <b>FTWords</b> that consists of a single
            query string consisting of a sequence of token to be
            matched as a phrase is evaluated by 
            the <code>applyQueryTokensAsPhrase</code> function. Its parameters 
            are 1) the search context, 2) the list of match options, 3) the query
            string to be matched as a sequence of <code>fts:queryToken</code>
            items, and 4) the position where the latter query string occurs in the
            query. 
            </p><div class="semfunc-file-ftssimple-xquery"><div class="exampleInner"><pre>
(: simplified version not dealing with special match options :)
declare function fts:applyQueryTokensAsPhrase (
      $searchContext as item(),
      $matchOptions as element(fts:matchOptions),
      $queryTokens as element(fts:queryToken)*,
      $queryPos as xs:integer )
   as element(fts:allMatches)
{
   &lt;fts:allMatches stokenNum="{$queryPos}"&gt; 
   {
      for $tokenInfo in
         fts:matchTokenInfos( 
            $searchContext,
            $matchOptions,
            (),
            $queryTokens )
      return  
         &lt;fts:match&gt;  
            &lt;fts:stringInclude queryPos="{$queryPos}" isContiguous="true"&gt; 
            {$tokenInfo}
            &lt;/fts:stringInclude&gt; 
         &lt;/fts:match&gt;
   } 
   &lt;/fts:allMatches&gt;
};
</pre></div></div><p>If after the application of all the match options, the sequence 
			of query tokens returned for an <b>FTWords</b> is empty, an empty
            <b>AllMatches</b> is returned. </p><p>The <b>AllMatches</b> corresponding to an
            <b>FTWords</b> is a set of <b>Match</b>es. Each of the <b>Match</b>es
            is associated with a starting and an ending position indicating where the corresponding
            query tokens were found. For example, the <b>AllMatches</b>
            result for the <b>FTWords</b> "Mustang" is given
            below. To simplify the presentation in the figures we write
            <code>Pos: N</code>, if the attributes
            <code>startPos</code> and <code>endPos</code> are the same
            with <code>N</code> being that position.</p><img src="images/FTWordEx.jpg" alt="FTWords example"/><p>There are five variations of <b>FTWords</b> depending on how the 
			tokens and phrases in the nested XQuery 1.0 and XPath 2.0 
			expression are matched. </p><ul><li><p>When <code>any word</code> is specified, at 
			least one token in the tokenization of the nested expression must be 
			matched. </p></li><li><p>When <code>all word</code> is specified, all 
			tokens in the tokenization of the nested expression must be 
			matched.</p></li><li><p>When <code>phrase</code> is specified, all 
			tokens in the tokenization of the nested expression must be 
			matched as a phrase.</p></li><li><p>When <code>any</code> is specified, at least one 
			string atomic value in the nested expression must be 
			matched as a phrase.</p></li><li><p>When <code>all</code> is specified, all 
			string atomic values in the nested expression must be 
			matched as a phrase.</p></li></ul><p>The semantics for <b>FTWords</b> when <code>any word</code> is specified 
			is given below. Since <b>FTWords</b>
            does not have nested <b>FTSelection</b>s, the
            <code>ApplyFTWords</code> function does not take 
            <b>AllMatches</b> parameters corresponding to nested
            <b>FTSelection</b> results.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:MakeDisjunction (
      $curRes as element(fts:allMatches),
      $rest as element(fts:allMatches)* ) 
   as element(fts:allMatches) 
{
   if (fn:count($rest) = 0)
   then $curRes
   else 
      let $firstAllMatches := $rest[1]
      let $restAllMatches := fn:subsequence($rest, 2)
      let $newCurRes := fts:ApplyFTOr($curRes, 
                                      $firstAllMatches)
      return fts:MakeDisjunction($newCurRes, 
                                 $restAllMatches)
};

declare function fts:ApplyFTWordsAnyWord (
      $searchContext as item(), 
      $matchOptions as element(fts:matchOptions), 
      $queryItems as element(fts:queryItem)*,
      $queryPos as xs:integer ) 
   as element(fts:allMatches) 
{
   (: Tokenization of query string has already occurred. :)
   (: Get sequence of QueryTokens over all query items. :)
   let $queryTokens := $queryItems/fts:queryToken
   return
      if (fn:count($queryTokens) eq 0) 
      then &lt;fts:allMatches stokenNum="0" /&gt;
      else
         let $allAllMatches := 
            for $queryToken at $pos in $queryTokens
            return fts:applyQueryTokensAsPhrase($searchContext,
                                                 $matchOptions,
                                                 $queryToken,
                                                 $queryPos + $pos - 1)
         let $firstAllMatches := $allAllMatches[1]
         let $restAllMatches := fn:subsequence($allAllMatches, 2)
         return fts:MakeDisjunction($firstAllMatches, $restAllMatches)
};
</pre></div></div><p>The tokenized query strings are passed to
            ApplyFTWordsAnyWord as a sequence of
            <code>fts:queryItem</code>, each containing the tokens of
            a single query string. A single flattened sequence of all
            tokens (of type <code>fts:queryToken</code>) over all
            query items is constructed. For each of these,
            the result of <b>FTWords</b> is computed using
            <code>applyQueryTokensAsPhrase</code>. Finally, the
            disjunction of all resulting <b>AllMatches</b> is computed.</p><p>The semantics for <b>FTWords</b> when <code>all word</code>
            is specified is similar to the above, however composes a
            conjunction. It is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:MakeConjunction ( 
      $curRes as element(fts:allMatches),
      $rest as element(fts:allMatches)* ) 
   as element(fts:allMatches)
{
   if (fn:count($rest) = 0)
   then $curRes
   else 
      let $firstAllMatches := $rest[1]
      let $restAllMatches := fn:subsequence($rest, 2)
      let $newCurRes := fts:ApplyFTAnd($curRes, 
                                       $firstAllMatches)
      return fts:MakeConjunction($newCurRes, 
                                 $restAllMatches)
};

declare function fts:ApplyFTWordsAllWord (
      $searchContext as item(), 
      $matchOptions as element(fts:matchOptions), 
      $queryItems as element(fts:queryItem)*,
      $queryPos as xs:integer ) 
   as element(fts:allMatches) 
{
   (: Tokenization of query strings has already occurred. :)
   (: Get sequence of QueryTokens over all query items :)
   let $queryTokens := $queryItems/fts:queryToken
   return
      if (fn:count($queryTokens) eq 0) 
      then &lt;fts:allMatches stokenNum="0" /&gt;
      else
         let $allAllMatches := 
            for $queryToken at $pos in $queryTokens
            return fts:applyQueryTokensAsPhrase($searchContext,
                                                 $matchOptions,
                                                 $queryToken,
                                                 $queryPos + $pos - 1)
            let $firstAllMatches := $allAllMatches[1]
            let $restAllMatches := fn:subsequence($allAllMatches, 2)
            return fts:MakeConjunction($firstAllMatches, $restAllMatches)
};
</pre></div></div><p>The semantics for <b>FTWords</b> if <code>phrase</code> is specified 
			is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTWordsPhrase (
      $searchContext as item(), 
      $matchOptions as element(fts:matchOptions), 
      $queryItems as element(fts:queryItem)*,
      $queryPos as xs:integer ) 
   as element(fts:allMatches) 
{
   (: Get sequence of QueryTokenInfos over all query items :)
   let $queryTokens := $queryItems/fts:queryToken
   return
      if (fn:count($queryTokens) eq 0) 
      then &lt;fts:allMatches stokenNum="0" /&gt;
      else
         fts:applyQueryTokensAsPhrase($searchContext,
                                       $matchOptions,
                                       $queryTokens,
                                       $queryPos)
};
</pre></div></div><p>The <code>ApplyFTWordsPhrase</code> function
            also flattens the sequence of query items to a sequence of
            query tokens, but then calls
            <code>applyQueryTokensAsPhrase</code> on that
            entire sequence, instead of calling it on each query token
            individually. Hence, the sequence of all query tokens is
            matched as a single phrase and the computed <b>TokenInfo</b>s
            are returned.</p><p>The semantics for <b>FTWords</b> when <code>any</code> is specified is 
			given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTWordsAny (
      $searchContext as item(), 
      $matchOptions as element(fts:matchOptions), 
      $queryItems as element(fts:queryItem)*,
      $queryPos as xs:integer ) 
   as element(fts:allMatches) 
{
   if (fn:count($queryItems) eq 0) 
   then &lt;fts:allMatches stokenNum="0" /&gt;
   else 
      let $firstQueryItem := $queryItems[1]
      let $restQueryItem := fn:subsequence($queryItems, 2)
      let $firstAllMatches := 
         fts:ApplyFTWordsPhrase($searchContext,
                                $matchOptions,
                                $firstQueryItem,
                                $queryPos)
      let $newQueryPos := 
         if ($firstAllMatches//@queryPos) 
         then fn:max($firstAllMatches//@queryPos) + 1
         else $queryPos
      let $restAllMatches :=
         fts:ApplyFTWordsAny($searchContext,
                             $matchOptions,
                             $restQueryItem,
                             $newQueryPos)
      return fts:ApplyFTOr($firstAllMatches, $restAllMatches)
};
</pre></div></div><p>The <b>FTWords</b> with <code>any</code>
            specified forms the disjunction of the <b>AllMatches</b> that
            are the result of the matching of each query item as a phrase.</p><p>The semantics for <b>FTWords</b> when <code>all </code> is specified 
			is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTWordsAll (
      $searchContext as item(), 
      $matchOptions as element(fts:matchOptions), 
      $queryItems as element(fts:queryItem)*,
      $queryPos as xs:integer ) 
   as element(fts:allMatches) 
{
   if (fn:count($queryItems) = 0) 
   then &lt;fts:allMatches stokenNum="0" /&gt;
   else 
      let $firstQueryItem := $queryItems[1]
      let $restQueryItem := fn:subsequence($queryItems, 2)
      let $firstAllMatches := 
         fts:ApplyFTWordsPhrase($searchContext,
                                $matchOptions,
                                $firstQueryItem,
                                $queryPos)
      return
         if ($restQueryItem) then
            let $newQueryPos := 
               if ($firstAllMatches//@queryPos) 
               then fn:max($firstAllMatches//@queryPos) + 1
               else $queryPos
            let $restAllMatches :=
               fts:ApplyFTWordsAll($searchContext,
                                   $matchOptions,
                                   $restQueryItem,
                                   $newQueryPos)
            return 
               fts:ApplyFTAnd($firstAllMatches, $restAllMatches)
         else $firstAllMatches
};
</pre></div></div><p>The difference between <code>all</code> and 
            <code>any</code> is the use of conjunction instead of
            disjunction.</p><p>The <code>ApplyFTWords</code> function combines
            all of these functions.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTWords ( 
      $searchContext as item(),
      $matchOptions as element(fts:matchOptions),
      $type as fts:ftWordsType,
      $queryItems as element(fts:queryItem)*, 
      $queryPos as xs:integer )
   as element(fts:allMatches) 
{
   if ($type eq "any word")
   then fts:ApplyFTWordsAnyWord($searchContext,
                                $matchOptions,
                                $queryItems,
                                $queryPos)
   else if ($type eq "all word")
   then fts:ApplyFTWordsAllWord($searchContext,
                                $matchOptions,
                                $queryItems,
                                $queryPos)
   else if ($type eq "phrase")
   then fts:ApplyFTWordsPhrase($searchContext,
                               $matchOptions,
                               $queryItems,
                               $queryPos)
   else if ($type eq "any")
   then fts:ApplyFTWordsAny($searchContext,
                            $matchOptions,
                            $queryItems,
                            $queryPos)
   else fts:ApplyFTWordsAll($searchContext,
                            $matchOptions,
                            $queryItems,
                            $queryPos)
};
                </pre></div></div></div></div><div class="xquery"><div class="div3">
<h4><a name="FTMatchOptionsSec" id="FTMatchOptionsSec"/>4.2.5 Match Options Semantics</h4><div class="xquery"><div class="div4">
<h5><a name="tq-ft-matchopt-types" id="tq-ft-matchopt-types"/>4.2.5.1 Types</h5><p>XQuery 1.0 functions are used to 
            define the semantics of <b>FTMatchOption</b>s. These functions 
            operate on an XML representation of the <b>FTMatchOption</b>s. 
            The representation closely follows the 
            <a href="#ftmatchoptions">syntax</a>. Each <b>FTMatchOption</b> is 
	    represented by an XML element. Additional characteristics of the match 
	    option are represented as attributes.
	    The schema is given below.</p><div class="exampleInner"><pre>
&lt;xs:schema 
    xmlns:xs="http://www.w3.org/2001/XMLSchema" 
    xmlns:fts="http://www.w3.org/2007/xpath-full-text"
    targetNamespace="http://www.w3.org/2007/xpath-full-text"
    elementFormDefault="qualified" 
    attributeFormDefault="unqualified"&gt;

  &lt;xs:complexType name="ftMatchOptions"&gt;
    &lt;xs:sequence&gt;
       &lt;xs:element ref="fts:thesaurus" minOccurs="0" maxOccurs="1"/&gt;
       &lt;xs:element ref="fts:stopwords" minOccurs="0" maxOccurs="1"/&gt;
       &lt;xs:element ref="fts:case" minOccurs="0" maxOccurs="1"/&gt;
       &lt;xs:element ref="fts:diacritics" minOccurs="0" maxOccurs="1"/&gt;
       &lt;xs:element ref="fts:stem" minOccurs="0" maxOccurs="1"/&gt;
       &lt;xs:element ref="fts:wildcard" minOccurs="0" maxOccurs="1"/&gt;
       &lt;xs:element ref="fts:language" minOccurs="0" maxOccurs="1"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="matchOptions" type="fts:ftMatchOptions"/&gt;

  &lt;xs:element name="case" type="fts:ftCaseOption" /&gt;
  &lt;xs:element name="diacritics" type="fts:ftDiacriticsOption" /&gt;
  &lt;xs:element name="thesaurus" type="fts:ftThesaurusOption" /&gt;
  &lt;xs:element name="stem" type="fts:ftStemOption" /&gt;
  &lt;xs:element name="wildcard" type="fts:ftWildCardOption" /&gt;
  &lt;xs:element name="language" type="fts:ftLanguageOption" /&gt;
  &lt;xs:element name="stopwords" type="fts:ftStopWordOption" /&gt; 

 &lt;xs:complexType name="ftCaseOption"&gt;
   &lt;xs:sequence&gt;
     &lt;xs:element name="value"&gt;
       &lt;xs:simpleType&gt;
         &lt;xs:restriction base="xs:string"&gt;
           &lt;xs:enumeration value="case insensitive"/&gt;
           &lt;xs:enumeration value="case sensitive"/&gt;
           &lt;xs:enumeration value="lowercase"/&gt;
           &lt;xs:enumeration value="uppercase"/&gt;
         &lt;/xs:restriction&gt;
       &lt;/xs:simpleType&gt;
     &lt;/xs:element&gt;
   &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="ftDiacriticsOption"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="value"&gt;
        &lt;xs:simpleType&gt;
          &lt;xs:restriction base="xs:string"&gt;
            &lt;xs:enumeration value="diacritics insensitive"/&gt;
            &lt;xs:enumeration value="diacritics sensitive"/&gt;
          &lt;/xs:restriction&gt;
        &lt;/xs:simpleType&gt;
      &lt;/xs:element&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
       
  &lt;xs:complexType name="ftThesaurusOption"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="thesaurusName" type="xs:string" 
                  minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element name="relationship" type="xs:string" 
                  minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element name="range" type="fts:ftRangeSpec" 
                  minOccurs="0" maxOccurs="1"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="thesaurusIndicator"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:string"&gt;
          &lt;xs:enumeration value="using"/&gt;
          &lt;xs:enumeration value="no"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:attribute&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:complexType name="ftRangeSpec"&gt;
    &lt;xs:attribute name="type" 
                  type="fts:rangeSpecType" 
                  use="required"/&gt;
    &lt;xs:attribute name="m" 
                  type="xs:integer"/&gt;
    &lt;xs:attribute name="n" 
                  type="xs:integer" 
                  use="required"/&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:simpleType name="rangeSpecType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:enumeration value="exactly"/&gt;
      &lt;xs:enumeration value="at least"/&gt;
      &lt;xs:enumeration value="at most"/&gt;
      &lt;xs:enumeration value="from to"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:complexType name="ftStemOption"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="value"&gt;
        &lt;xs:simpleType&gt;
          &lt;xs:restriction base="xs:string"&gt;
            &lt;xs:enumeration value="stemming"/&gt;
            &lt;xs:enumeration value="no stemming"/&gt;
          &lt;/xs:restriction&gt;
        &lt;/xs:simpleType&gt;
      &lt;/xs:element&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:complexType name="ftWildCardOption"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="value"&gt;
        &lt;xs:simpleType&gt;
          &lt;xs:restriction base="xs:string"&gt;
            &lt;xs:enumeration value="wildcards"/&gt;
            &lt;xs:enumeration value="no wildcards"/&gt;
          &lt;/xs:restriction&gt;
        &lt;/xs:simpleType&gt;
      &lt;/xs:element&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
 
  &lt;xs:complexType name="ftLanguageOption"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="value" type="xs:string"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="ftStopWordOption"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:choice&gt;
        &lt;xs:element name="default-stopwords"&gt;
            &lt;xs:complexType /&gt;
        &lt;/xs:element&gt;
        &lt;xs:element name="stopword" type="xs:string" /&gt;
        &lt;xs:element name="uri" type="xs:anyURI" /&gt;
      &lt;/xs:choice&gt;
      &lt;xs:element name="oper" minOccurs="0" maxOccurs="unbounded"&gt;
        &lt;xs:complexType&gt;
          &lt;xs:choice&gt;
            &lt;xs:element name="stopword" type="xs:string" /&gt;
            &lt;xs:element name="uri" type="xs:anyURI" /&gt;
          &lt;/xs:choice&gt;
          &lt;xs:attribute name="type"&gt;
            &lt;xs:simpleType&gt;
              &lt;xs:restriction base="xs:string"&gt;
                &lt;xs:enumeration value="union"/&gt;
                &lt;xs:enumeration value="except"/&gt;
              &lt;/xs:restriction&gt;
            &lt;/xs:simpleType&gt;
          &lt;/xs:attribute&gt;
        &lt;/xs:complexType&gt;
      &lt;/xs:element&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
 
&lt;/xs:schema&gt;            
</pre></div></div></div><div class="xquery"><div class="div4">
<h5><a name="tq-ft-matchopt-highlevel" id="tq-ft-matchopt-highlevel"/>4.2.5.2 High-Level Semantics</h5><p>The previous section described FTSelections without
            giving any details about how <b>FTMatchOption</b>s need to be
            interpreted. All processing of <b>FTMatchOption</b>s was
            delegated to the function
            <code>matchTokenInfos</code>, which is
            <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>. In this section, further details
            on the semantics of <b>FTMatchOption</b>s are given.</p><p>The extension is achieved by modifying an existing 
            function and adding functions that are specific to the
            <b>FTMatchOption</b>s.</p><p>
                     <em>Modifications in the semantics of existing functions</em>
                  </p><p>The semantics of most of the
            <b>FTSelection</b>s remains unmodified. The modifications are
            to the method for matching a sequence of query tokens. </p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:applyQueryTokensAsPhrase (
      $searchContext as item(),
      $matchOptions as element(fts:matchOptions),
      $queryTokens as element(fts:queryToken)*,
      $queryPos as xs:integer )
   as element(fts:allMatches)
{
   let $thesaurusOption := $matchOptions/fts:thesaurus[1]
   return 
      if ($thesaurusOption and 
          $thesaurusOption/@thesaurusIndicator eq "using") then
         let $noThesaurusOptions := 
            &lt;fts:matchOptions&gt;{
               $matchOptions/*[fn:not(self::fts:thesaurus)]
            }&lt;/fts:matchOptions&gt;
         let $lookupRes := fts:applyThesaurusOption($thesaurusOption,
	                                            $noThesaurusOptions,
                                                    $queryTokens)            
         return fts:ApplyFTWordsAny($searchContext,
                                    $noThesaurusOptions,
                                    $lookupRes,
                                    $queryPos)
      else
         (: from here on we have a single sequence of query tokens :)
         (: which is to be matched a phrase; no alternatives anymore :)
         &lt;fts:allMatches stokenNum="{$queryPos}"&gt; 
         {
            for $pos in
               fts:matchTokenInfos( 
                  $searchContext,
                  $matchOptions,
                  fts:applyStopWordOption($matchOptions/fts:stopwords),
                  $queryTokens )
            return  
               &lt;fts:match&gt;  
                  &lt;fts:stringInclude queryPos="{$queryPos}" isContiguous="true"&gt; 
                  {$pos}
                  &lt;/fts:stringInclude&gt; 
               &lt;/fts:match&gt;
         } 
         &lt;/fts:allMatches&gt; 
};
</pre></div></div><p>Two <b>FTMatchOption</b>s need to be
    processed differently than the rest of the <b>FTMatchOption</b>s as
    shown in the function above. </p><ul><li><p>Unlike all other <b>FTMatchOption</b>s the semantics
    of the <b>FTThesaurusOption</b> cannot be formulated as an operation on
    individual query tokens, because a thesaurus lookup may return
    alternative query items for a whole phrase, i.e., a sequence of
    query tokens. Since
    the result of a thesaurus lookup is a sequence of alternatives, 
    there must be a higher level of processing. The above call to
    <code>applyThesaurusOption</code> returns for the given
    sequence of query tokens (representing a phrase) all thesaurus
    expansions for the selected thesaurus, relationship and level
    range as a sequence of query items. The 
    alternative expansions are evaluated as a disjunction using
    the <code>fts:ApplyFTWordsAny</code>.
    The matching of the alternatives is performed with
    <b>FTThesaurusOption</b> turned off to avoid double expansions,
    i.e., expansion of an already expanded token.</p></li><li><p>For the semantics of the <b>FTStopWordOption</b> the list of
    stop words needs to be computed as demanded by the special syntax
    for stop word lists involving the operators "union" and
    "except". </p></li></ul><p>
                     <em>Semantics of new <b>FTMatchOption</b>s functions </em>
                  </p><p>The expansion of <b>FTSelection</b>s also includes adding additional functions
    that are specific to the <b>FTMatchOption</b>s. </p><p>The <code>evaluate</code> function above handles match options
    occurring in the query structure by using a call to the function
    <code>replaceMatchOptions</code> which is defined below. The latter
    function replaces match options from the list given by the first argument
    with match options of the same group in the list given by the second
    argument, if any. If an option is present in the second list but not in
    the first list, the option is included to the resulting list too.
    Intuitively, the <code>replaceMatchOptions</code> computes the
    effective match options for a given <b>FTSelection</b>. The function uses
    the options specified specifically for the current <b>FTSelection</b> (
    <code>$ftSelection/fts:matchOptions</code> to override any options
    of the same group declared up the query tree (<code>$matchOptions</code>).
    </p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:replaceMatchOptions (
      $matchOptions as element(fts:matchOptions),
      $newMatchOptions as element(fts:matchOptions) )
   as element(fts:matchOptions)
{
   &lt;fts:matchOptions&gt;
   {
      (if ($newMatchOptions/fts:thesaurus) then $newMatchOptions/fts:thesaurus
       else $matchOptions/fts:thesaurus),
      (if ($newMatchOptions/fts:stopwords) then $newMatchOptions/fts:stopwords
       else $matchOptions/fts:stopwords),
      (if ($newMatchOptions/fts:case) then $newMatchOptions/fts:case
       else $matchOptions/fts:case),
      (if ($newMatchOptions/fts:diacritics) then $newMatchOptions/fts:diacritics
       else $matchOptions/fts:diacritics),
      (if ($newMatchOptions/fts:stem) then $newMatchOptions/fts:stem
       else $matchOptions/fts:stem),
      (if ($newMatchOptions/fts:wildcard) then $newMatchOptions/fts:wildcard
       else $matchOptions/fts:wildcard),
      (if ($newMatchOptions/fts:language) then $newMatchOptions/fts:language
       else $matchOptions/fts:language)
   }
   &lt;/fts:matchOptions&gt;
};

</pre></div></div><p>This function determines how match
    options of the same group overwrite each other, so that only one
    option of the same group remains.</p><p>The details of the semantics of the remaining <b>FTMatchOption</b>s
    are determined by the <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> function
    <code>matchTokenInfos</code>.</p></div></div><div class="xquery"><div class="div4">
<h5><a name="options-sem-functions" id="options-sem-functions"/>4.2.5.3 Formal Semantics Functions</h5><p>
                     <b>FTMatchOption</b> functions which are necessary to support match
            option processing are given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:resolveStopWordsUri ( $uri as xs:string? ) 
   as xs:string* external;

declare function fts:lookupThesaurus (
      $tokens as element(fts:queryToken)*,
      $thesaurusName as xs:string?, 
      $relationship as xs:string?,
      $range as element(fts:range)?,
      $noThesaurusOptions as element(fts:matchOptions) ) 
   as element(fts:queryItem)* external;
</pre></div></div><p>The function <code>resolveStopWordsUri</code>
            is used to resolve any URI to a sequence of strings to be
            used as stop words.</p><p>The function <code>lookupThesaurus</code> finds
            all expansions related to  <code>$tokens</code>
            in the thesaurus <code>$thesaurusName</code>
                     <span class="diff-del">for the language <code>$thesaurusLanguage</code>
                     </span>
            using the relationship 
            <code>$relationship</code> within the optional number of levels
            <code>$range</code>. If <code>$tokens</code> consists of 
            more than one query token, it is regarded as a
            phrase.
	    <span class="diff-add">The current match options other than the thesaurus option
	    are also passed to the function,
	    via <code>$noThesaurusOptions</code>,
	    allowing the implementation to apply any of those match options
	    (whichever it deems relevant)
	    to the input or output of the actual thesaurus lookup.</span>
                  </p><p>The thesaurus function returns a sequence of expansion
           alternatives. Each alternative is regarded as a new search
           phrase and is represented as a query item.
           Alternatives are treated as though they are connected with
           a disjunction (<b>FTOr</b>). </p></div></div><div class="xquery"><div class="div4">
<h5><a name="tq-ft-matchopt-FTCaseOption" id="tq-ft-matchopt-FTCaseOption"/>4.2.5.4 FTCaseOption</h5><p>
                     <b>FTMatchOption</b>s of type <b>FTCaseOption</b> are passed in the
        <code>$matchOptions</code> parameter to
        <code>matchTokenInfos</code>. If the <b>FTCaseOption</b> is
        "lowercase" the returned <b>TokenInfo</b>s must span
        only tokens that are all lowercase.  If the
        <b>FTCaseOption</b> is
        "uppercase" the returned <b>TokenInfo</b>s must span
        only tokens that are all uppercase.  If the
        <b>FTCaseOption</b> is "case insensitive" the
        function must return all <b>TokenInfo</b>s matching the query
        tokens when disregarding character case. If the
        <b>FTCaseOption</b> is "case sensitive" the
        function must return all <b>TokenInfo</b>s that also accord with
        the query tokens in character case.</p></div></div><div class="xquery"><div class="div4">
<h5><a name="tq-ft-matchopt-FTDiacriticsOption" id="tq-ft-matchopt-FTDiacriticsOption"/>4.2.5.5 FTDiacriticsOption</h5><p>
                     <b>FTMatchOption</b>s of type <b>FTDiacriticsOption</b> are passed in the
        <code>$matchOptions</code> parameter to
        <code>matchTokenInfos</code>. If the
        <b>FTDiacriticsOption</b> is "diacritics insensitive" the function must 
        return all <b>TokenInfo</b>s matching 
        the query tokens when disregarding diacritical marks. If the
        <b>FTDiacriticsOption</b> is "diacritics sensitive" the function must 
        return all <b>TokenInfo</b>s that
        also accord with the query tokens in diacritical marks.</p></div></div><div class="xquery"><div class="div4">
<h5><a name="tq-ft-matchopt-FTStemOption" id="tq-ft-matchopt-FTStemOption"/>4.2.5.6 FTStemOption</h5><p>
                     <b>FTMatchOption</b>s of type <b>FTStemOption</b> are passed in the
        <code>$matchOptions</code> parameter to
        <code>matchTokenInfos</code>. It is
        <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> what the effect of the option 
		"stemming" is on matching tokens, however, it is expected that
        this option allows to match linguistic variants of the query
        tokens. If the <b>FTStemOption</b> is "no stemming" the
        returned <b>TokenInfo</b>s must span exact matches (i.e. not
        including linguistic variations) of the query tokens.</p></div></div><div class="xquery"><div class="div4">
<h5><a name="tq-ft-matchopt-FTThesaurusOption" id="tq-ft-matchopt-FTThesaurusOption"/>4.2.5.7 FTThesaurusOption</h5><p>The semantics for the <b>FTThesaurusOption</b>
			is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:applyThesaurusOption (
      $matchOption as element(fts:thesaurus),
      $noThesaurusOptions as element(fts:matchOptions),
      $queryTokens as element(fts:queryToken)* )
   as element(fts:queryItem)*
{
   if ($matchOption/@thesaurusIndicator = "using") then
      fts:lookupThesaurus( $queryTokens,
                           $matchOption/fts:thesaurusName,
                           $matchOption/fts:relationship,
                           $matchOption/fts:range,
			   $noThesaurusOptions )
   else if ($matchOption/@thesaurusIndicator = "no") then
      &lt;fts:queryItem&gt;
      {$queryTokens}
      &lt;/fts:queryItem&gt;
   else ()
};
</pre></div></div></div></div><div class="xquery"><div class="div4">
<h5><a name="tq-ft-matchopt-FTStopWordOption" id="tq-ft-matchopt-FTStopWordOption"/>4.2.5.8 FTStopWordOption</h5><p>Stop words interact with <b>FTDistance</b> and
			<b>FTWindow</b>. The semantics for the <b>FTStopWordOption</b>
			is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:applyStopWordOption (
      $stopWordOption as element(fts:stopwords)? )
   as xs:string*
{
   if ($stopWordOption) then
      let $swords := 
         typeswitch ($stopWordOption/*[1])
            case $e as element(fts:stopword) 
               return $e/text()
            case $e as element(fts:uri) 
               return fts:resolveStopWordsUri($e/text())
            case element(fts:default-stopwords)
               return fts:resolveStopWordsUri(())
            default return ()
      return fts:calcStopWords( $swords, $stopWordOption/fts:oper )
   else ()
};
declare function fts:calcStopWords ( 
      $stopWords as xs:string*,
      $opers as element(fts:oper)* )
   as xs:string*
{
   if ( fn:empty($opers) ) then $stopWords
   else
      let $swords := 
         typeswitch ($opers[1]/*[1])
            case $e as element(fts:stopword) 
               return $e/text()
            case $e as element(fts:uri) 
               return fts:resolveStopWordsUri($e/text())
            default return ()
      return
         if ($opers[1]/@type eq "union") then
            fts:calcStopWords( ($stopWords, $swords), 
                               $opers[fn:position() gt 2] )
         else (: "except" :)
            fts:calcStopWords( $stopWords[fn:not(.)=$swords],
                               $opers[fn:position() gt 2] )
};
            </pre></div></div><div class="diff-chg"><p>
            Given the applicable setting of the Stop Word Option,
            the function <code>fts:applyStopWordOption</code>
            calls <code>fts:calcStopWords</code>
            to compute the set of stop words,
            and returns that set as an instance of <code>xs:string*</code>.
            This then is passed to <code>fts:matchTokenInfos</code>,
            which uses it to affect the matching of tokens.
            The <code>fts:calcStopWords</code> function uses
            the function <code>fts:resolveStopWordsUri</code> to resolve any URI
            to a sequence of strings.
            </p></div></div></div><div class="xquery"><div class="div4">
<h5><a name="tq-ft-matchopt-FTLanguageOption" id="tq-ft-matchopt-FTLanguageOption"/>4.2.5.9 FTLanguageOption</h5><p>The <b>FTLanguageOption</b> is not associated with a semantics function. It 
                is just a parameter to other semantics functions.</p></div></div><div class="xquery"><div class="div4">
<h5><a name="tq-ft-matchopt-FTWildCardOption" id="tq-ft-matchopt-FTWildCardOption"/>4.2.5.10 FTWildCardOption</h5><p>
                     <b>FTMatchOption</b>s of type <b>FTWildCardOption</b> are passed in the
        <code>$matchOptions</code> parameter to
        <code>matchTokenInfos</code>. If the
        <b>FTWildCardOption</b> is "wildcards" the function must
        return all <b>TokenInfo</b>s in the search context that span tokens,
        such that those tokens are wildcard
        expansions of the corresponding query token. The wildcard
        expansions are described in <a href="#ftwildcardoption">Section 3.2.7 FTWildCardOption</a>. If the
        <b>FTWildCardOption</b> is "no wildcards" all query tokens
        must be matched literally.</p></div></div></div></div><div class="xquery"><div class="div3">
<h4><a name="FTOperatorsSemanticsSec" id="FTOperatorsSemanticsSec"/>4.2.6 Full-Text Operators Semantics</h4><div class="xquery"><div class="div4">
<h5><a name="tq-ft-fs-FTOr" id="tq-ft-fs-FTOr"/>4.2.6.1 FTOr</h5><p>The parameters of the <code>ApplyFTOr</code> 
            function are the two <b>AllMatches</b> parameters 
            corresponding to the results of the two nested 
            <b>FTSelection</b>s. 
            The semantics is given 
			below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTOr (
      $allMatches1 as element(fts:allMatches),
      $allMatches2 as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{fn:max(($allMatches1/@stokenNum, 
                                       $allMatches2/@stokenNum))}"&gt;
   {$allMatches1/fts:match,$allMatches2/fts:match}
   &lt;/fts:allMatches&gt;
};
            </pre></div></div><p>The <code>ApplyFTOr</code> function creates a new <b>AllMatches</b> 
			in which 
            <b>Match</b>es are the union of those found 
            in the input <b>AllMatches</b>. 
			Each <b>Match</b> represents one possible result of the corresponding 
            <b>FTSelection</b>. Thus, a <b>Match</b> from either 
            of the <b>AllMatches</b> is a result. </p><p>For example, consider the <b>FTSelection</b>
                     <code>"Mustang" ftor "Honda"</code>. The 
			<b>AllMatches</b> corresponding to 
            "Mustang" and "Honda" are given below.</p><img src="images/FTOrEx1.jpg" alt="FTOr input AllMatches 1"/><p>
                     <img src="images/FTOrEx2.jpg" alt="FTOr input AllMatches 2"/>
                  </p><p>The <b>AllMatches</b> produced by <code>
            ApplyFTOr</code> is given below.</p><img src="images/FTOrEx3.jpg" alt="FTOr result AllMatches"/></div></div><div class="xquery"><div class="div4">
<h5><a name="tq-ft-fs-FTAnd" id="tq-ft-fs-FTAnd"/>4.2.6.2 FTAnd</h5><p>The parameters of the <code>ApplyFTAnd</code> 
            function are the two <b>AllMatches</b>  
            corresponding to the results of the two nested 
            <b>FTSelection</b>s.
            The semantics is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTAnd (
      $allMatches1 as element(fts:allMatches),
      $allMatches2 as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{fn:max(($allMatches1/@stokenNum, 
                                       $allMatches2/@stokenNum))}" &gt;
   {
      for $sm1 in $allMatches1/fts:match
      for $sm2 in $allMatches2/fts:match
      return &lt;fts:match&gt;
             {$sm1/*, $sm2/*}
             &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
            </pre></div></div><p>The result of the conjunction is a new 
            <b>AllMatches</b> that contains the "Cartesian 
            product" of the matches of the participating 
            <b>FTSelection</b>s. Every resulting <b>Match</b> 
            is formed by the combination of the <b>StringInclude</b> components 
            and <b>StringExclude</b> from the 
            <b>AllMatches</b> of the nested <b>FTSelection</b> 
            . Thus every match contains the positions 
            to satisfy a <b>Match</b> from both original 
            <b>FTSelection</b>s and excludes the positions that 
            violate the same <b>Match</b>es. </p><p>For example, consider the <b>FTSelection</b>
                     <code>"Mustang" ftand "rust"</code>. The 
			source <b>AllMatches</b> are give below.</p><img src="images/FTAndEx1.jpg" alt="FTAnd input AllMatches 1"/><p>
                     <img src="images/FTAndEx2.jpg" alt="FTAnd input AllMatches 2"/>
                  </p><p>The <b>AllMatches</b> produced by <code>ApplyFTAnd</code> is
			given below.</p><img src="images/FTAndEx3.jpg" alt="FTAnd result AllMatches"/></div></div><div class="xquery"><div class="div4">
<h5><a name="tq-ft-fs-FTUnaryNot" id="tq-ft-fs-FTUnaryNot"/>4.2.6.3 FTUnaryNot</h5><p>The <code>ApplyFTUnaryNot</code>
        function
        has one <b>AllMatches</b> parameter corresponding to the
        result of the nested <b>FTSelection</b> to be negated.
        The 
		semantics is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:InvertStringMatch ( $strm as element(*,fts:stringMatch) ) 
   as element(*,fts:stringMatch)
{
   if ($strm instance of element(fts:stringExclude)) then
      &lt;fts:stringInclude queryPos="{$strm/@queryPos}" isContiguous="{$strm/@isContiguous}"&gt;
      {$strm/fts:tokenInfo}
      &lt;/fts:stringInclude&gt;
   else
      &lt;fts:stringExclude queryPos="{$strm/@queryPos}" isContiguous="{$strm/@isContiguous}"&gt;
      {$strm/fts:tokenInfo}
      &lt;/fts:stringExclude&gt;
};

declare function fts:UnaryNotHelper ( $matches as element(fts:match)* )
   as element(fts:match)*
{
   if (fn:empty($matches))
   then &lt;fts:match/&gt;
   else
      for $sm in $matches[1]/*
      for $rest in fts:UnaryNotHelper( fn:subsequence($matches, 2) )
      return 
         &lt;fts:match&gt;
         {
            fts:InvertStringMatch($sm),
            $rest/*
         }
         &lt;/fts:match&gt;
};

declare function fts:ApplyFTUnaryNot (
      $allMatches as element(fts:allMatches) )
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      fts:UnaryNotHelper($allMatches/fts:match)
   }
   &lt;/fts:allMatches&gt;
};
            </pre></div></div><p>The generation of the resulting
            <b>AllMatches</b> of an <b>FTUnaryNot</b> resembles the transformation
            of a negation of prepositional formula in DNF back to DNF.
            The negation of <b>AllMatches</b> requires
            the inversion of all the <b>StringMatch</b>es
            within the <b>AllMatches</b>.</p><p>In the <code>InvertStringMatch</code> function  above, 
			this inversion occurs as follows. </p><ol class="enumar"><li><p>The function <code>fts:invertStringMatch</code>
			inverts a <b>StringInclude </b> into a <b>StringExclude</b> and
			vice versa. </p></li><li><p>The function <code>fts:UnaryNotHelper</code> transforms
			the source <b>Match</b>es into the resulting
			<b>Match</b>es by forming the combinations of the
			inversions of a <b>StringInclude</b> or <b>StringExclude</b>
			component over the source <b>Match</b>es into new <b>Match</b>es.</p></li></ol><p>For example, consider the <b>FTSelection</b>
                     <code>ftnot ("Mustang" ftor "Honda")</code>. The 
			source <b>AllMatches</b> is given below:</p><img src="images/FTNegationEx1.jpg" alt="FTUnaryNot input AllMatches"/><p>The <b>FTUnaryNot</b> transforms the <b>StringInclude</b>s to 
			<b>StringExclude</b>s as illustrated below.</p><img src="images/FTNegationEx2.jpg" alt="FTUnaryNot result AllMatches"/></div></div><div class="xquery"><div class="div4">
<h5><a name="tq-ft-fs-FTMildNot" id="tq-ft-fs-FTMildNot"/>4.2.6.4 FTMildNot</h5><p>The parameters of the <code>ApplyFTMildNot</code>
            function are the two <b>AllMatches</b> parameters corresponding
            to the results of the two nested <b>FTSelection</b>s.
            The semantics is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:CoveredIncludePositions (
       $match as element(fts:match) )
    as xs:integer*
{
    for $strInclude in $match/fts:stringInclude
    return $strInclude/fts:tokenInfo/@startPos
           to $strInclude/fts:tokenInfo/@endPos
};

declare function fts:ApplyFTMildNot (
       $allMatches1 as element(fts:allMatches),
       $allMatches2 as element(fts:allMatches) )
    as element(fts:allMatches)
{
    if (fn:count($allMatches1//fts:stringExclude) gt 0) then
       fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'FTDY0017'), 
                "Invalid expression on the left-hand side of a not-in")
    else if (fn:count($allMatches2//fts:stringExclude) gt 0) then
       fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'FTDY0017'), 
                "Invalid expression on the right-hand side of a not-in")
    else if (fn:count($allMatches2//fts:stringInclude) eq 0) then
       $allMatches1
    else
       &lt;fts:allMatches stokenNum="{$allMatches1/@stokenNum}"&gt;
       {
          $allMatches1/fts:match[
             every $matches2 in $allMatches2/fts:match
             satisfies
                let $posSet1 := fts:CoveredIncludePositions(.)
                let $posSet2 := fts:CoveredIncludePositions($matches2)
                   return some $pos in $posSet1 satisfies fn:not($pos = $posSet2)
          ]
       }
       &lt;/fts:allMatches&gt;
};
            </pre></div></div><p>The resulting <b>AllMatches</b> contains <b>Match</b>es
            of the first operand that do not mention in their
            <b>StringInclude</b> components positions in a <b>StringInclude</b> component 
			in the <b>AllMatches</b> of the second operand.</p><p>For example, consider the <b>FTSelection</b>
                     <code>("Ford" not in "Ford
            Mustang")</code>. The
            source <b>AllMatches</b> for the left-hand side argument is given below.</p><img src="images/FTMildNegationEx1.jpg" alt="FTMildNot input AllMatches 1"/><p>The
            source <b>AllMatches</b> for the right-hand side argument is given below.</p><img src="images/FTMildNegationEx2.jpg" alt="FTMildNot input AllMatches 2"/><p>The <b>FTMildNot</b> will transform these to an empty
            <b>AllMatches</b> because both position 1 and position 27 from
            the first <b>AllMatches</b> contain only <b>TokenInfo</b>s from
            <b>StringInclude</b> components of the second
            <b>AllMatches</b>.</p></div></div><div class="xquery"><div class="div4">
<h5><a name="tq-ft-fs-FTOrder" id="tq-ft-fs-FTOrder"/>4.2.6.5 FTOrder</h5><p>The <code>ApplyFTOrder</code>
            function
            has one <b>AllMatches</b> parameter corresponding to
            the result of the nested <b>FTSelection</b>s.
            The semantics is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTOrder (
      $allMatches as element(fts:allMatches) )
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      where every $stringInclude1 in $match/fts:stringInclude,
                  $stringInclude2 in $match/fts:stringInclude
            satisfies (($stringInclude1/fts:tokenInfo/@startPos &lt;= 
                        $stringInclude2/fts:tokenInfo/@startPos)
                       and
                       ($stringInclude1/@queryPos &lt;= 
                        $stringInclude2/@queryPos))
                      or
                       (($stringInclude1/fts:tokenInfo/@startPos&gt;= 
                         $stringInclude2/fts:tokenInfo/@startPos)
                        and
                        ($stringInclude1/@queryPos &gt;= 
                         $stringInclude2/@queryPos))
      return 
         &lt;fts:match&gt;
         {
            $match/fts:stringInclude,
            for $stringExcl in $match/fts:stringExclude
            where every $stringIncl in $match/fts:stringInclude
                  satisfies (($stringExcl/fts:tokenInfo/@startPos &lt;= 
                              $stringIncl/fts:tokenInfo/@startPos)
                             and
                              ($stringExcl/@queryPos &lt;= 
                               $stringIncl/@queryPos))
                            or
                             (($stringExcl/fts:tokenInfo/@startPos &gt;= 
                               $stringIncl/fts:tokenInfo/@startPos)
                              and
                              ($stringExcl/@queryPos &gt;= 
                               $stringIncl/@queryPos))
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }         
   &lt;/fts:allMatches&gt;
};
            </pre></div></div><p>The resulting <b>AllMatches</b> contains the <b>Match</b>es for which the starting positions 
			in the <b>StringInclude</b> elements are in the order of the
            query positions of their query strings.  
			<b>StringExclude</b>s that preserve the order (with respect to their starting positions) are also retained.</p><p>For example, consider the <b>FTSelection</b>
                     <code>("great" ftand "condition")
            ordered</code>. The source <b>AllMatches</b> is given below.</p><img src="images/FTOrderEx1.jpg" alt="FTOrder input AllMatches"/><img src="images/FTOrderEx2.jpg" alt="FTOrder input AllMatches"/><img src="images/FTOrderEx3.jpg" alt="FTOrder input AllMatches"/><p>The <b>AllMatches</b> for <b>FTOrder</b> are given below.</p><img src="images/FTOrderEx4.jpg" alt="FTOrder result AllMatches"/><img src="images/FTOrderEx5.jpg" alt="FTOrder result AllMatches"/></div></div><div class="xquery"><div class="div4">
<h5><a name="tq-ft-fs-FTScope" id="tq-ft-fs-FTScope"/>4.2.6.6 FTScope</h5><p>The parameters of the <code>ApplyFTScope</code>
            function are 
            1) the type of the scope (same or different), 2) the
            linguistic unit (sentence or paragraph), and 2) one
            <b>AllMatches</b> parameter corresponding to the result of the
            nested <b>FTSelection</b>s.
            The function
            definitions depend on the type of the scope (paragraph,
            sentence) and the scope predicate (same, different).</p><p>The semantics of <code>same sentence</code> is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTScopeSameSentence (
      $allMatches as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      where every $stringInclude1 in $match/fts:stringInclude,
                  $stringInclude2 in $match/fts:stringInclude 
            satisfies $stringInclude1/fts:tokenInfo/@startSent = 
                      $stringInclude2/fts:tokenInfo/@startSent
                  and $stringInclude1/fts:tokenInfo/@startSent = 
                      $stringInclude1/fts:tokenInfo/@endSent
                  and $stringInclude2/fts:tokenInfo/@startSent = 
                      $stringInclude2/fts:tokenInfo/@endSent
                  and $stringInclude1/fts:tokenInfo/@startSent &gt; 0
                  and $stringInclude2/fts:tokenInfo/@startSent &gt; 0
      return 
        &lt;fts:match&gt;
        {
           $match/fts:stringInclude,
           for $stringExcl in $match/fts:stringExclude
           where
              $stringExcl/fts:tokenInfo/@startSent = 0
              or
              ($stringExcl/fts:tokenInfo/@startSent = 
               $stringExcl/fts:tokenInfo/@endSent
               and 
                  (every $stringIncl in $match/fts:stringInclude
                   satisfies $stringIncl/fts:tokenInfo/@startSent = 
                             $stringExcl/fts:tokenInfo/@startSent) )
           return $stringExcl
        }
        &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</pre></div></div><p>An <b>AllMatches</b> returned by the scope <code>same sentence</code> 
             contains those <b>Match</b>es whose <b>StringInclude</b>s span only a single 
             sentence and all span the same sentence. In these <b>Match</b>es only 
             those <b>StringExclude</b>s are retained that also only span a single 
             sentence, which is, in case there are <b>StringInclude</b>s in that <b>Match</b>, 
             the same as the one spanned by the <b>StringInclude</b>s.</p><p>The semantics of <code>different sentence
            </code> is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTScopeDifferentSentence (
      $allMatches as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      where
         count($match/fts:stringInclude) &gt; 1
         and
         (
            every $stringInclude1 in $match/fts:stringInclude,
                  $stringInclude2 in $match/fts:stringInclude  
            satisfies
               $stringInclude1 is $stringInclude2
               or
               (
                     ( $stringInclude1/fts:tokenInfo/@startSent !=  
                       $stringInclude2/fts:tokenInfo/@startSent 
                    or $stringInclude1/fts:tokenInfo/@startSent !=  
                       $stringInclude1/fts:tokenInfo/@endSent 
                    or $stringInclude2/fts:tokenInfo/@startSent !=  
                       $stringInclude2/fts:tokenInfo/@endSent ) 
                   and $stringInclude1/fts:tokenInfo/@startSent &gt; 0 
                   and $stringInclude2/fts:tokenInfo/@endSent &gt; 0
               )
         )
      return 
         &lt;fts:match&gt;
         {
            $match/fts:stringInclude,
            for $stringExcl in $match/fts:stringExclude
            where every $stringIncl in $match/fts:stringInclude
                  satisfies ($stringIncl/fts:tokenInfo/@startSent !=  
                             $stringExcl/fts:tokenInfo/@startSent 
                          or $stringIncl/fts:tokenInfo/@startSent !=  
                             $stringIncl/fts:tokenInfo/@endSent 
                          or $stringExcl/fts:tokenInfo/@startSent !=  
                             $stringExcl/fts:tokenInfo/@endSent ) 
                         and $stringIncl/fts:tokenInfo/@startSent &gt; 0 
                         and $stringExcl/fts:tokenInfo/@endSent &gt; 0
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</pre></div></div><div class="diff-chg"><p>An <b>AllMatches</b> returned by the scope <code>different sentence</code> 
            contains those <b>Match</b>es that have
            at least two StringIncludes,
            no two of which begin and end all in the same sentence.
            In these <b>Match</b>es only those <b>StringExclude</b>s are retained that do not 
            conflict with any of the <b>StringInclude</b>s.</p></div><p>The semantics of <code>same paragraph</code> is analogous to <code>same
            sentence</code> and is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTScopeSameParagraph (
      $allMatches as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      where every $stringInclude1 in $match/fts:stringInclude,
                  $stringInclude2 in $match/fts:stringInclude  
            satisfies $stringInclude1/fts:tokenInfo/@startPara = 
                      $stringInclude2/fts:tokenInfo/@startPara
                  and $stringInclude1/fts:tokenInfo/@startPara = 
                      $stringInclude1/fts:tokenInfo/@endPara
                  and $stringInclude2/fts:tokenInfo/@startPara = 
                      $stringInclude2/fts:tokenInfo/@endPara
                  and $stringInclude1/fts:tokenInfo/@startPara &gt; 0
                  and $stringInclude2/fts:tokenInfo/@endPara &gt; 0
      return 
         &lt;fts:match&gt;
         {
            $match/fts:stringInclude,
            for $stringExcl in $match/fts:stringExclude
            where 
               $stringExcl/fts:tokenInfo/@startPara = 0
               or
               ($stringExcl/fts:tokenInfo/@startPara = 
                $stringExcl/fts:tokenInfo/@endPara
                and
                   (every $stringIncl in $match/fts:stringInclude
                    satisfies $stringIncl/fts:tokenInfo/@startPara = 
                              $stringExcl/fts:tokenInfo/@startPara) )
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</pre></div></div><p>The semantics of <code>different paragraph</code> is analogous to 
            <code>different sentence</code> and is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTScopeDifferentParagraph (
      $allMatches as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      where
         count($match/fts:stringInclude) &gt; 1
         and
         (
            every $stringInclude1 in $match/fts:stringInclude,
                  $stringInclude2 in $match/fts:stringInclude  
            satisfies
               $stringInclude1 is $stringInclude2
               or
               (
                     ( $stringInclude1/fts:tokenInfo/@startPara !=  
                       $stringInclude2/fts:tokenInfo/@startPara 
                    or $stringInclude1/fts:tokenInfo/@startPara !=  
                       $stringInclude1/fts:tokenInfo/@endPara 
                    or $stringInclude2/fts:tokenInfo/@startPara !=  
                       $stringInclude2/fts:tokenInfo/@endPara ) 
                   and $stringInclude1/fts:tokenInfo/@startPara &gt; 0 
                   and $stringInclude2/fts:tokenInfo/@endPara &gt; 0
               )
         )
      return 
         &lt;fts:match&gt;
         {
            $match/fts:stringInclude,
            for $stringExcl in $match/fts:stringExclude
            where every $stringIncl in $match/fts:stringInclude
                  satisfies ($stringIncl/fts:tokenInfo/@startPara !=  
                             $stringExcl/fts:tokenInfo/@startPara 
                          or $stringIncl/fts:tokenInfo/@startPara !=  
                             $stringIncl/fts:tokenInfo/@endPara 
                          or $stringExcl/fts:tokenInfo/@startPara !=  
                             $stringExcl/fts:tokenInfo/@endPara ) 
                         and $stringIncl/fts:tokenInfo/@startPara &gt; 0 
                         and $stringExcl/fts:tokenInfo/@endPara &gt; 0
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</pre></div></div><p>The semantics for the general case is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTScope (
      $type as fts:scopeType,
      $selector as fts:scopeSelector, 
      $allMatches as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   if ($type eq "same" and $selector eq "sentence")
   then fts:ApplyFTScopeSameSentence($allMatches)
   else if ($type eq "different" and $selector eq "sentence")
      then fts:ApplyFTScopeDifferentSentence($allMatches)
   else if ($type eq "same" and $selector eq "paragraph")
      then fts:ApplyFTScopeSameParagraph($allMatches)
   else fts:ApplyFTScopeDifferentParagraph($allMatches)
};
</pre></div></div><p>For example, consider the <b>FTSelection</b>
                     <code>("Mustang" ftand "Honda") same 
            paragraph</code>. The source <b>AllMatches</b> is given below.</p><img src="images/FTScopeEx.jpg" alt="FTScope input AllMatches"/><p>The <b>FTScope</b> returns an empty <b>AllMatches</b> because neither 
			<b>Match</b> contains <b>TokenInfo</b>s from a single sentence.</p></div></div><div class="xquery"><div class="div4">
<h5><a name="tq-ft-fs-FTContent" id="tq-ft-fs-FTContent"/>4.2.6.7 FTContent</h5><p>The parameters of the <code>ApplyFTContent</code>
            function are 1) the search context,
            2) the type of the content
	    match
	    (<code>at start</code>, <code>at end</code>, or <code>entire content</code>),
            and 3) one
            <b>AllMatches</b> parameter corresponding to the result of the
            nested <b>FTSelection</b>s.</p><p>The evaluation of <code>ApplyFTContent</code>
            depends on the type of the content match:</p><ul><li><p>
                           <code>entire content</code>
                retains those <b>Match</b>es such that
                for every token position in the search context,
                some <b>StringInclude</b> in the <b>Match</b> covers that token position.
                </p></li><li><p>
                           <code>at start</code>
                retains those <b>Match</b>es that contain a <b>StringInclude</b>
                that covers the lowest token position in the search context.
                </p></li><li><p>
                           <code>at end</code>
                retains those <b>Match</b>es that contain a <b>StringInclude</b>
                that covers the highest token position in the search context.
                </p></li></ul><p>The semantics is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTContent (
      $searchContext as item(),
      $type as fts:contentMatchType,
      $allMatches as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      $allMatches/fts:match[
         let $start_pos := fts:getLowestTokenPosition($searchContext),
             $end_pos   := fts:getHighestTokenPosition($searchContext),
             $match     := .
         return
            if ($type eq "entire content") then
               every $pos in $start_pos to $end_pos
               satisfies
                  some $si in $match/fts:stringInclude[data(@isContiguous)]
                  satisfies
                     fts:TokenInfoCoversTokenPosition($si/fts:tokenInfo, $pos)
            else
               let $pos :=
                  if ($type eq "at start") then
                     $start_pos
                  else (: $type eq "at end" :)
                     $end_pos
               return
                  some $ti in $match/fts:stringInclude/fts:tokenInfo
                  satisfies
                     fts:TokenInfoCoversTokenPosition($ti, $pos)
      ]
   }
   &lt;/fts:allMatches&gt;
};
</pre></div></div><p>
                     <code>ApplyFTContent</code> depends on the helper function
            <code>fts:TokenInfoCoversTokenPosition</code>,
            which ascertains whether the given <code>$tokenInfo</code>
            covers a particular <code>$tokenPosition</code>.
            </p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:TokenInfoCoversTokenPosition(
      $tokenInfo as element(fts:tokenInfo),
      $tokenPosition as xs:integer )
   as xs:boolean
{
   ($tokenPosition &gt;= $tokenInfo/@startPos)
   and
   ($tokenPosition &lt;= $tokenInfo/@endPos)
};
</pre></div></div><p>
                     <code>ApplyFTContent</code> also depends on two functions
            whose definitions are <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>:
            <code>getLowestTokenPosition</code>
            and
            <code>getHighestTokenPosition</code>
            return (respectively)
            the first and last token positions
            of the item <code>$searchContext</code>.
            </p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:getLowestTokenPosition(
      $searchContext as item() )
   as xs:integer
   external;

declare function fts:getHighestTokenPosition(
      $searchContext as item() )
   as xs:integer
   external;
</pre></div></div><p>
            Note that the way <code>@isContiguous</code>
            is calculated in <code>joinIncludes</code>
            and used in <code>ApplyFTContent</code>
            can lead to counter-intuitive results.
            For example, consider the following query:
            </p><div class="xquery"><div class="exampleInner"><pre>
"one two three four"
contains text
   ("one" ftand "three" window 3 words)
   ftand
   ("two" ftand "four" window 3 words)
   entire content
</pre></div></div><p>
            Even though the four query tokens <em>do</em> cover
            all of the search context's token positions,
            the query yields false,
            because the <b>Match</b>
            that <code>ApplyFTContent</code> receives as input
            has two <b>StringInclude</b>s, each of which is non-contiguous.
            </p></div></div><div class="xquery"><div class="div4">
<h5><a name="tq-ft-fs-FTWindow" id="tq-ft-fs-FTWindow"/>4.2.6.8 FTWindow</h5><p>Before we define the semantics functions of the <b>FTWindow</b> and <b>FTDistance</b> 
		  	 operations, we introduce the auxiliary function <code>joinIncludes</code> that will
		  	 be used in their definitions. <code>joinIncludes</code> takes a sequence of 
		  	 <b>StringInclude</b>s of a <b>Match</b> and transforms it into either the empty sequence, in 
		  	 case the input sequence was empty, or otherwise a single <b>StringInclude</b>
		  	 representing the span from the first position of the match to the last. For the 
		  	 purpose of being able to evaluate an "entire content" operator further up in the 
		  	 tree, we pre-evaluate whether all possible positions between first and last are 
			 covered in the input <b>StringInclude</b>s and store that boolean in the 
			 attribute "isContiguous".</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:joinIncludes(
      $strIncls as element(fts:stringInclude)* )
   as element(fts:stringInclude)?
{
   if (fn:empty($strIncls))
   then 
      $strIncls
   else
      let $posSet := fts:CoveredIncludePositions(&lt;fts:match&gt;$strIncls&lt;/fts:match&gt;),
         $minPos := fn:min($strIncls/fts:tokenInfo/@startPos),
         $maxPos := fn:max($strIncls/fts:tokenInfo/@endPos),
         $isContiguous := 
            ( every $pos in $minPos to $maxPos
              satisfies ($pos = $posSet) )
            and
            ( every $strIncl in $strIncls
              satisfies $strIncl/@isContiguous )
      return
         &lt;fts:stringInclude 
            queryPos="{$strIncls[1]/@queryPos}"
            isContiguous="{$isContiguous}"&gt;
            &lt;fts:tokenInfo
               startPos ="{$minPos}"
               endPos   ="{$maxPos}"
               startSent="{fn:min($strIncls/fts:tokenInfo/@startSent)}"
               endSent  ="{fn:max($strIncls/fts:tokenInfo/@endSent)}"
               startPara="{fn:min($strIncls/fts:tokenInfo/@startPara)}"
               endPara  ="{fn:max($strIncls/fts:tokenInfo/@endPara)}"/&gt;
         &lt;/fts:stringInclude&gt;
};
</pre></div></div><p>The parameters of the
            <code>ApplyFTWindow</code> function are
            1) the unit of
            type <code>fts:distanceType</code>, 2) a size, and 3) one
            <b>AllMatches</b> parameter 
            corresponding to the result of the nested <b>FTSelection</b>s.
            For each unit 
			type a function is defined as follows.</p><p>The semantics of <code>window N words </code> is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTWordWindow (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $minpos := fn:min($match/fts:stringInclude/fts:tokenInfo/@startPos),
          $maxpos := fn:max($match/fts:stringInclude/fts:tokenInfo/@endPos)
      for $windowStartPos in ($maxpos - $n + 1 to $minpos)
      let $windowEndPos := $windowStartPos + $n - 1
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExclude in $match/fts:stringExclude
            where $stringExclude/fts:tokenInfo/@startPos &gt;=
                  $windowStartPos
              and $stringExclude/fts:tokenInfo/@endPos &lt;=
                  $windowEndPos
            return $stringExclude
         }
         &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</pre></div></div><p>The semantics of <code>window N sentences</code> is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTSentenceWindow (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $minpos := fn:min($match/fts:stringInclude/fts:tokenInfo/@startSent),
          $maxpos := fn:max($match/fts:stringInclude/fts:tokenInfo/@endSent)
      for $windowStartPos in ($maxpos - $n + 1 to $minpos)
      let $windowEndPos := $windowStartPos + $n - 1
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExclude in $match/fts:stringExclude
            where $stringExclude/fts:tokenInfo/@startSent &gt;=
                  $windowStartPos
              and $stringExclude/fts:tokenInfo/@endSent &lt;=
                  $windowEndPos
            return $stringExclude
         }
         &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</pre></div></div><p>The semantics of <code>window N paragraphs </code> is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTParagraphWindow (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches)
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $minpos := fn:min($match/fts:stringInclude/fts:tokenInfo/@startPara),
          $maxpos := fn:max($match/fts:stringInclude/fts:tokenInfo/@endPara)
      for $windowStartPos in ($maxpos - $n + 1 to $minpos)
      let $windowEndPos := $windowStartPos + $n - 1
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExclude in $match/fts:stringExclude
            where $stringExclude/fts:tokenInfo/@startPara &gt;=
                  $windowStartPos
              and $stringExclude/fts:tokenInfo/@endPara &lt;=
                  $windowEndPos
            return $stringExclude
         }
         &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</pre></div></div><p>The resulting <b>AllMatches</b> contains 
            <b>Match</b>es of the operand that satisfy the condition that
            there exists a sequence of the specified number of
            consecutive (token, sentence, or paragraph) positions, such
            that all <b>StringInclude</b>s are within that window, and the
            <b>StringExclude</b>s retained are also within that window. For each 
            <b>Match</b> that satisfies the window condition the 
            <b>StringInclude</b>s are joined into a single <b>StringInclude</b>. This 
            enables further window or distance operations to be applied to the
            result in a way that that result is taken as a single entity.</p><p>The semantics for the general function  is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTWindow (
      $type as fts:distanceType,
      $size as xs:integer,
      $allMatches as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   if ($type eq "word") then
      fts:ApplyFTWordWindow($allMatches, $size)
   else if ($type eq "sentence") then 
      fts:ApplyFTSentenceWindow($allMatches, $size)
   else
      fts:ApplyFTParagraphWindow($allMatches, $size)
};
</pre></div></div><p>For example, consider the <b>FTWindow</b> selection
            <code>("Ford Mustang" ftand
            "excellent") window 10 words</code>.
            The <b>Match</b>es of the source <b>AllMatches</b> for
            <code>("Ford Mustang" ftand
            "excellent")</code> are given below.</p><img src="images/FTWindowEx1.jpg" alt="FTWindow AllMatches"/><p>
                     <img src="images/FTWindowEx2.jpg" alt="FTWindow AllMatches"/>
                  </p><img src="images/FTWindowEx3.jpg" alt="FTWindow AllMatches"/><p>
                     <img src="images/FTWindowEx4.jpg" alt="FTWindow AllMatches"/>
                  </p><img src="images/FTWindowEx5.jpg" alt="FTWindow AllMatches"/><p>
                     <img src="images/FTWindowEx6.jpg" alt="FTWindow AllMatches"/>
                  </p><p>The result for the <b>FTWindow</b> selection 
            consists of only the first, the fifth, and the sixth
            <b>Match</b>es because their respective window sizes are 5, 4,
            and 9.</p></div></div><div class="xquery"><div class="div4">
<h5><a name="tq-ft-fs-FTDistance" id="tq-ft-fs-FTDistance"/>4.2.6.9 FTDistance</h5><p>The parameters of the
            <code>ApplyFTDistance</code> function are
            1) one
            <b>AllMatches</b> parameter corresponding to the result of the
            nested <b>FTSelection</b>s, 2) the unit of the distance (tokens,
            sentences, paragraphs), and 3) the range specified.
            The resulting <b>AllMatches</b> contains <b>Match</b>es of the operand
            that satisfy the condition
            that the distance for every pair of consecutive <b>StringInclude</b>s
            is within the specified interval,
            where the distance is measured (in tokens, sentences, or paragraphs)
            from the end of the preceding <b>StringInclude</b>
            to the start of the next.
            
            </p><p>
            An invocation of
            the <code>ApplyFTDistance</code> function
            will call one of twelve helper functions,
            each of which handles a particular unit of distance
            and type of range.
            </p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTDistance (
      $type as fts:distanceType,
      $range as element(fts:range),
      $allMatches as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   if ($type eq "word") then
      if ($range/@type eq "exactly") then
         fts:ApplyFTWordDistanceExactly($allMatches, $range/@n)
      else if ($range/@type eq "at least") then 
         fts:ApplyFTWordDistanceAtLeast($allMatches, $range/@n)
      else if ($range/@type eq "at most") then
         fts:ApplyFTWordDistanceAtMost( $allMatches, $range/@n)
      else
         fts:ApplyFTWordDistanceFromTo( $allMatches, $range/@m, $range/@n)
   else if ($type eq "sentence") then
      if ($range/@type eq "exactly") then
         fts:ApplyFTSentenceDistanceExactly($allMatches, $range/@n)
      else if ($range/@type eq "at least") then
         fts:ApplyFTSentenceDistanceAtLeast($allMatches, $range/@n)
      else if ($range/@type eq "at most") then
         fts:ApplyFTSentenceDistanceAtMost( $allMatches, $range/@n)
      else
         fts:ApplyFTSentenceDistanceFromTo( $allMatches, $range/@m, $range/@n)
   else
      if ($range/@type eq "exactly") then
         fts:ApplyFTParagraphDistanceExactly($allMatches, $range/@n)
      else if ($range/@type eq "at least") then
         fts:ApplyFTParagraphDistanceAtLeast($allMatches, $range/@n)
      else if ($range/@type eq "at most") then
         fts:ApplyFTParagraphDistanceAtMost( $allMatches, $range/@n)
      else
         fts:ApplyFTParagraphDistanceFromTo( $allMatches, $range/@m, $range/@n)
};
</pre></div></div><p>
                     <em>Word Distance</em>
                  </p><p>The semantics of case <code>word distance exactly N</code> 
			is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTWordDistanceExactly(
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startPos ascending,
                              $si/fts:tokenInfo/@endPos ascending
                     return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $idx in 1 to fn:count($sorted) - 1
            satisfies fts:wordDistance(
                         $sorted[$idx]/fts:tokenInfo,
                         $sorted[$idx+1]/fts:tokenInfo
                      ) = $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:wordDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) = $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</pre></div></div><p>The semantics of <code>word distance at least N</code> is given 
			below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTWordDistanceAtLeast (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startPos ascending,
                              $si/fts:tokenInfo/@endPos ascending
                     return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:wordDistance(
                         $sorted[$index]/fts:tokenInfo,
                         $sorted[$index+1]/fts:tokenInfo
                      ) &gt;= $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:wordDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &gt;= $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }           
   &lt;/fts:allMatches&gt;
};
</pre></div></div><p>The semantics of <code>word distance at most N</code> is given 
			below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTWordDistanceAtMost (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startPos ascending,
                              $si/fts:tokenInfo/@endPos ascending
                     return $si
      where
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:wordDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &lt;= $n 
      return 
        &lt;fts:match&gt;
        {
           fts:joinIncludes($match/fts:stringInclude),
           for $stringExcl in $match/fts:stringExclude
           where some $stringIncl in $match/fts:stringInclude
                 satisfies fts:wordDistance(
                               $stringIncl/fts:tokenInfo,
                               $stringExcl/fts:tokenInfo
                           ) &lt;= $n
           return $stringExcl
        }
        &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</pre></div></div><p>The semantics of <code>word distance from M to N</code> is given 
			below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTWordDistanceFromTo (
      $allMatches as element(fts:allMatches),
      $m as xs:integer,
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startPos ascending,
                              $si/fts:tokenInfo/@endPos ascending
                     return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:wordDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &gt;= $m 
                      and
                      fts:wordDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &lt;= $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:wordDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &gt;= $m
                            and
                            fts:wordDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &lt;= $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</pre></div></div><p>The preceding four helper functions all rely on
            <code>fts:wordDistance</code>,
            which returns the number of token positions
            that occur between two <b>TokenInfo</b>s.
            For example,
            two tokens with consecutive positions have a distance of 0 tokens,
            and two overlapping tokens have a distance of -1 tokens.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:wordDistance (
      $tokenInfo1 as element(fts:tokenInfo),
      $tokenInfo2 as element(fts:tokenInfo) )
   as xs:integer
{
   (: Ensure tokens are in order :)
   let $sorted :=
      for $ti in ($tokenInfo1, $tokenInfo2)
      order by $ti/@startPos ascending, $ti/@endPos ascending
      return $ti
   return
      (: -1 because we count starting at 0 :)
      $sorted[2]/@startPos - $sorted[1]/@endPos - 1
};
            </pre></div></div><p>
                     <em>Sentence Distance</em>
                  </p><p>The semantics of <code>sentence distance exactly N</code> 
			is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTSentenceDistanceExactly (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startSent ascending,
                              $si/fts:tokenInfo/@endSent ascending
                     return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:sentenceDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) = $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:sentenceDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) = $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }           
   &lt;/fts:allMatches&gt;
};
</pre></div></div><p>The semantics of <code>sentence distance at least N</code> 
			is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTSentenceDistanceAtLeast (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                    order by $si/fts:tokenInfo/@startSent ascending,
                             $si/fts:tokenInfo/@endSent ascending
                    return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:sentenceDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &gt;= $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:sentenceDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &gt;= $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }           
   &lt;/fts:allMatches&gt;
};
</pre></div></div><p>The semantics of <code>sentence distance at most N</code> 
            is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTSentenceDistanceAtMost (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startSent ascending,
                              $si/fts:tokenInfo/@endSent ascending
                     return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:sentenceDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &lt;= $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:sentenceDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &lt;= $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }           
   &lt;/fts:allMatches&gt;
};
</pre></div></div><p>The semantics of  <code>sentence distance from M to N</code> 
            is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTSentenceDistanceFromTo (
      $allMatches as element(fts:allMatches),
      $m as xs:integer,
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startSent ascending,
                              $si/fts:tokenInfo/@endSent ascending
                     return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:sentenceDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &gt;= $m 
                      and
                      fts:sentenceDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &lt;= $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:sentenceDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &gt;= $m
                            and
                            fts:sentenceDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &lt;= $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</pre></div></div><p>The preceding four helper functions all rely on
            <code>fts:sentenceDistance</code>,
            which returns the number of sentences between two <b>TokenInfo</b>s.
            </p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:sentenceDistance (
      $tokenInfo1 as element(fts:tokenInfo),
      $tokenInfo2 as element(fts:tokenInfo) )
   as xs:integer
{
   (: Ensure tokens are in order :)
   let $sorted :=
      for $ti in ($tokenInfo1, $tokenInfo2)
      order by $ti/@startPos ascending, $ti/@endPos ascending
      return $ti
   return
      (: -1 because we count starting at 0 :)
      $sorted[2]/@startSent - $sorted[1]/@endSent - 1
};
            </pre></div></div><p>
                     <em>Paragraph Distance</em>
                  </p><p>The semantics of <code>paragraph distance exactly N</code> 
			is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTParagraphDistanceExactly (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startPara ascending,
                              $si/fts:tokenInfo/@endPara ascending
                     return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:paraDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) = $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:paraDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) = $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }           
   &lt;/fts:allMatches&gt;
};
</pre></div></div><p>The semantics of <code>paragraph distance at least N</code> 
		is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTParagraphDistanceAtLeast (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startPara ascending,
                              $si/fts:tokenInfo/@endPara ascending
                     return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:paraDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &gt;= $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:paraDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &gt;= $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }           
   &lt;/fts:allMatches&gt;
};
</pre></div></div><p>The semantics of <code>paragraph distance at most N</code>
		is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTParagraphDistanceAtMost (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startPara ascending,
                              $si/fts:tokenInfo/@endPara ascending
                     return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:paraDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &lt;= $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:paraDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &lt;= $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }           
   &lt;/fts:allMatches&gt;
};
</pre></div></div><p>The semantics of <code>paragraph distance from M to N</code>
		is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTParagraphDistanceFromTo (
      $allMatches as element(fts:allMatches),
      $m as xs:integer,
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt;
   {
      for $match in $allMatches/fts:match
      let $sorted := for $si in $match/fts:stringInclude          
                     order by $si/fts:tokenInfo/@startPara ascending,
                              $si/fts:tokenInfo/@endPara ascending
                     return $si
      where 
         if (fn:count($sorted) le 1) then fn:true() else
            every $index in (1 to fn:count($sorted) - 1)
            satisfies fts:paraDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &gt;= $m 
                      and
                      fts:paraDistance(
                          $sorted[$index]/fts:tokenInfo,
                          $sorted[$index+1]/fts:tokenInfo
                      ) &lt;= $n 
      return 
         &lt;fts:match&gt;
         {
            fts:joinIncludes($match/fts:stringInclude),
            for $stringExcl in $match/fts:stringExclude
            where some $stringIncl in $match/fts:stringInclude
                  satisfies fts:paraDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &gt;= $m
                            and
                            fts:paraDistance(
                                $stringIncl/fts:tokenInfo,
                                $stringExcl/fts:tokenInfo
                            ) &lt;= $n
            return $stringExcl
         }
         &lt;/fts:match&gt;
   }
   &lt;/fts:allMatches&gt;
};
</pre></div></div><p>The preceding four helper functions all rely on
            <code>fts:paraDistance</code>,
            which returns the number of paragraphs between two <b>TokenInfo</b>s.
            </p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:paraDistance (
      $tokenInfo1 as element(fts:tokenInfo),
      $tokenInfo2 as element(fts:tokenInfo) )
   as xs:integer
{
   (: Ensure tokens are in order :)
   let $sorted :=
      for $ti in ($tokenInfo1, $tokenInfo2)
      order by $ti/@startPos ascending, $ti/@endPos ascending
      return $ti
   return
      (: -1 because we count starting at 0 :)
      $sorted[2]/@startPara - $sorted[1]/@endPara - 1
};
            </pre></div></div><p>For example, consider the <b>FTDistance</b> selection
            <code>("Ford Mustang" ftand
            "excellent") distance at most 3 words</code>.
            The <b>Match</b>es of the source <b>AllMatches</b> for
            <code>("Ford Mustang" ftand
            "excellent")</code> are given below.</p><img src="images/FTDistanceEx1.jpg" alt="FTDistance input AllMatches"/><p>
                     <img src="images/FTDistanceEx2.jpg" alt="FTDistance input AllMatches"/>
                  </p><img src="images/FTDistanceEx3.jpg" alt="FTDistance input AllMatches"/><p>
                     <img src="images/FTDistanceEx4.jpg" alt="FTDistance input AllMatches"/>
                  </p><img src="images/FTDistanceEx5.jpg" alt="FTDistance input AllMatches"/><p>
                     <img src="images/FTDistanceEx6.jpg" alt="FTDistance input AllMatches"/>
                  </p><p>The result for the <b>FTDistance</b> selection
            consists of only the first <b>Match</b> (with positions 1, 2, and 5) and
            the fifth <b>Match</b> (with positions 25, 27, and 28), because only
            for these <b>Match</b>es the word distance between consecutive
            <b>TokenInfo</b>s  is always less than or equal to 3.
            For the first <b>Match</b>,
	    the word distance between the two <b>TokenInfo</b>s
	    is 2 (<code>startPos</code> 5 - <code>endPos</code> 2 - 1),
            and for the fifth <b>Match</b>,
	    it's 1 (<code>startPos</code> 27 - <code>endPos</code> 25 - 1).
            </p></div></div><div class="xquery"><div class="div4">
<h5><a name="tq-ft-fs-FTTimes" id="tq-ft-fs-FTTimes"/>4.2.6.10 FTTimes</h5><p>The parameters of the <code>ApplyFTTimes</code>
            function are 1) an <b>FTRange</b> specification, and 2)
            a parameter corresponding to the result of the nested
            <b>FTWords</b>. </p><p>The function definitions depend on the range
            specification <b>FTRange</b> to limit the number of
            occurrences. </p><p>The general semantics is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:FormCombinations (
      $sms as element(fts:match)*, 
      $k as xs:integer ) 
   as element(fts:match)*
(:
   Find all combinations of exactly $k elements from $sms, and
   for each such combination, construct a match whose children are
   copies of all the children of all the elements in the combination.
   Return the sequence of all such matches.
:)
{
   if ($k eq 0) then &lt;fts:match/&gt;
   else if (fn:count($sms) lt $k) then ()
   else if (fn:count($sms) eq $k) then &lt;fts:match&gt;{$sms/*}&lt;/fts:match&gt;
   else
      let $first := $sms[1],
          $rest  := fn:subsequence($sms, 2)
      return (
         (: all the combinations that don't involve $first :)
         fts:FormCombinations($rest, $k),

         (: and all the combinations that do involve $first :)
         for $combination in fts:FormCombinations($rest, $k - 1)
         return
            &lt;fts:match&gt;
            {
               $first/*,
               $combination/*
            }
            &lt;/fts:match&gt;
      )
};

declare function fts:FormCombinationsAtLeast (
      $sms as element(fts:match)*,
      $times as xs:integer)
   as element(fts:match)*
(:
   Find all combinations of $times or more elements from $sms, and
   for each such combination, construct a match whose children are
   copies of all the children of all the elements in the combination.
   Return the sequence of all such matches.
:)
{
   for $k in $times to fn:count($sms)
   return fts:FormCombinations($sms, $k)
};

declare function fts:FormRange (
      $sms as element(fts:match)*, 
      $l as xs:integer, 
      $u as xs:integer, 
      $stokenNum as xs:integer ) 
   as element(fts:allMatches)
{
   if ($l &gt; $u) then &lt;fts:allMatches stokenNum="0" /&gt;
   else 
      let $am1 := &lt;fts:allMatches stokenNum="{$stokenNum}"&gt;
                     {fts:FormCombinationsAtLeast($sms, $l)}
                  &lt;/fts:allMatches&gt;
      let $am2 := &lt;fts:allMatches stokenNum="{$stokenNum}"&gt;
                     {fts:FormCombinationsAtLeast($sms, $u+1)}
                  &lt;/fts:allMatches&gt;
      return fts:ApplyFTAnd($am1,
                            fts:ApplyFTUnaryNot($am2))
};
            </pre></div></div><p>The semantics of <code>occurs exactly N times</code> is given 
			below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTTimesExactly (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   fts:FormRange($allMatches/fts:match, $n, $n, $allMatches/@stokenNum)      
};
</pre></div></div><p>The semantics of <code>occurs at least N times</code> is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTTimesAtLeast (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   &lt;fts:allMatches stokenNum="{$allMatches/@stokenNum}"&gt; 
   {fts:FormCombinationsAtLeast($allMatches/fts:match, $n)} 
   &lt;/fts:allMatches&gt;
};
</pre></div></div><p>The semantics of <code>occurs at most N times</code> is given
			below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTTimesAtMost (
      $allMatches as element(fts:allMatches),
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   fts:FormRange($allMatches/fts:match, 0, $n, $allMatches/@stokenNum)
};
</pre></div></div><p>The semantics of <code>occurs from M to N times</code> is given below.</p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTTimesFromTo (
      $allMatches as element(fts:allMatches),
      $m as xs:integer,
      $n as xs:integer ) 
   as element(fts:allMatches) 
{
   fts:FormRange($allMatches/fts:match, $m, $n, $allMatches/@stokenNum)  
};
</pre></div></div><p>The way to ensure that
            there are at least <b>N</b> different matches of an
            <b>FTSelection</b> is to ensure that at least <b>N</b> of
            its <b>Match</b>es occur simultaneously. This is similar to
            forming their conjunction by combining <b>N</b> or more distinct
            <b>Match</b>es into one simple match. Therefore, the <b>AllMatches</b>
            for the selection condition specifying the range qualifier
            <code>at least N </code> contains the possible
            combinations of <b>N</b> or more simple matches of the
            operand.
            This operation
            is performed in the function <code>
            fts:FormCombinationsAtLeast</code>.</p><p>The range [L, U] is represented by the condition 
			<code>at least L and not at least U+1</code>. This transformation
            is performed in the function
            <code>fts:FormRange</code>.</p><p>The semantics for the general case is given below. </p><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:ApplyFTTimes (
      $range as element(fts:range),
      $allMatches as element(fts:allMatches) ) 
   as element(fts:allMatches) 
{
   if (fn:count($allMatches//fts:stringExclude) gt 0) then
      fn:error(fn:QName('http://www.w3.org/2005/xqt-errors',
                        'XPST0003'))
   else if ($range/@type eq "exactly") then
      fts:ApplyFTTimesExactly($allMatches, $range/@n)
   else if ($range/@type eq "at least") then 
      fts:ApplyFTTimesAtLeast($allMatches, $range/@n)
   else if ($range/@type eq "at most") then
      fts:ApplyFTTimesAtMost($allMatches, $range/@n)
   else fts:ApplyFTTimesFromTo($allMatches, 
                               $range/@m, 
                               $range/@n)
};
</pre></div></div><p>The above function performs a sanity check to ensure that the nested 
<b>AllMatches</b> is a result of the evaluation of <b>FTWords</b> as defined in
the grammar rule for <a href="#doc-xquery10-FTPrimary">FTPrimary</a> . 
Otherwise, an error [<a href="http://www.w3.org/TR/xpath20/#ERRXPST0003" title="err:XPST0003">err:XPST0003</a>]<sup><small>XP</small></sup>
is raised. </p><p>For example, consider the <b>FTTimes</b> selection
            <code>"Mustang" occurs at least 2 times</code>. The source 
			<b>AllMatches</b> of the <b>FTWords</b>
            selection <code>"Mustang"</code> is given below.</p><img src="images/FTTimesEx1.jpg" alt="FTTimes input AllMatches"/><p>The result consists of the pairs of the <b>Match</b>es.</p><img src="images/FTTimesEx2.jpg" alt="FTTimes result AllMatches"/></div></div></div></div></div></div><div class="xquery"><div class="div2">
<h3><a name="FTContainsSec" id="FTContainsSec"/>4.3 FTContainsExpr</h3><p>Consider an <b>FTContainsExpr</b> expression of the form
            <code>SearchContext contains text FTSelection</code>,
            where <code>SearchContext</code> is an XQuery 1.0
            expression that returns a sequence of items.
            The <b>FTContainsExpr</b> returns true if and only if
            one of those items
            satisfies the <code>FTSelection</code>.</p><p>If the <b>FTContainsExpr</b> is of the form <code>SearchContext 
	    contains text FTSelection without content IgnoreExpr</code> for
	    some XQuery 1.0 expression <code>IgnoreExpr</code>, then
	    any nodes returned by <code>IgnoreExpr</code>
	    are (notionally) pruned from each search context item
            before attempting to satisfy the <code>FTSelection</code>.</p><p>
        More formally, evaluation of an <b>FTContainsExpr</b>
        proceeds according to the following steps.
        Where appropriate, the explanation includes references to
        arcs labelled "FTn" in the processing model diagram (Figure 1)
        in <a href="#processing-model"><b>2.1 Processing Model</b></a>.
        </p><ol class="enumar"><li><p>
            For each XQuery/XPath expression nested within the FTContainsExpr,
            evaluate it with respect to
            the same dynamic context as the FTContainsExpr (FT1).
            Specifically:
            </p><ol class="enumla"><li><p>
                Evaluate the search context expression (<code>SearchContext</code>),
                resulting in the sequence of search context items.
                </p></li><li><p>
                Evaluate the ignore option (<code>IgnoreExpr</code>) if any,
                resulting in the set of ignored nodes.
                </p></li><li><p>
                At each FTWordsValue,
                evaluate the literal/expression and convert the result to <code>xs:string*</code>.
                </p></li><li><p>
                At each weight specification,
                evaluate the expression and convert the result to <code>xs:double</code>.
                </p></li><li><p>
                At each FTWindow and FTRange,
                evaluate the AdditiveExpr(s) and convert each to <code>xs:integer</code>.
                </p></li></ol></li><li><p>
            Using the settings of the match option components
            in the FTContainsExpr's static context,
            construct an <code>element(fts:matchOptions)</code> structure.
            </p></li><li><p>
            Based on the parse-tree of the FTContainsExpr's FTSelection
            and the results of steps 1c-1e,
            construct an <code>element(*,fts:ftSelection)</code> structure.
            We refer to this as the "operator tree" below.
            In this process:
            </p><ol class="enumla"><li><p>Construct the operator tree from the top down, propagating
        FTMatchOptions down to FTWordsValues.</p></li><li><p>
            Tokenize the query string(s) obtained at 1c. (FT2.1)
            </p></li></ol></li><li><p>
            Call the function <code>fts:FTContainsExpr</code> (see declaration below),
            passing the following arguments to its parameters:
            </p><ul><li><p>
                           <code>$searchContextItems</code>:
                    The sequence of items returned by <code>SearchContext</code>,
                    calculated in step 1a.
                    </p></li><li><p>
                           <code>$ignoreNodes</code>:
                    The sequence of items returned by <code>IgnoreExpr</code> (in 1b),
                    if that expression is present,
                    or the empty sequence otherwise.
                    </p></li><li><p>
                           <code>$ftSelection</code>:
                    The XML node representation of <code>FTSelection</code>
                    (constructed in step 2).
                    </p></li><li><p>
                           <code>$defOptions</code>:
                    The XML representation of the match options
                    in the FTContainsExpr's static context
                    (constructed in step 3).
                    </p></li></ul><p>
            Within the function,
            for each search context item:
            </p><ol class="enumla"><li><p>
                Delete the ignored nodes from the search
                context item.
                [<code>fts:FTContainsExpr</code> calls <code>fts:reconstruct</code>.]
                </p></li><li><p>
                Traverse the operator tree from the top down,
                propagating FTMatchOptions down to FTWordsValues.
                [<code>fts:evaluate</code> calls
                itself and <code>fts:replaceMatchOptions</code>.]
                </p></li><li><p>
                At each FTWordsValue, using the prevailing FTMatchOptions:
                </p><ol class="enumlr"><li><p>
                    Tokenize the search context obtained at 4a. (FT2.2)
                    (Whether this pays any attention to FTMatchOptions is
                    up to the implementation.)
                    [This happens within <code>fts:matchTokenInfos</code>.]
                    </p></li><li><p>
                    Match the search context tokens and the query tokens, 
                    yielding an
                    <code>element(fts:tokenInfo)*</code> structure.
                    [This happens within <code>fts:matchTokenInfos</code>.]
                    </p></li><li><p>
                    Convert that into an <code>element(fts:allMatches)</code>. (FT3)
                    [This happens in <code>fts:applyQueryTokensAsPhrase</code>.]
                    </p></li></ol></li><li><p>
                Traverse the operator tree from the bottom up.
                At each point,
                the <b>AllMatches</b> instances produced by subtrees are taken as input,
                and a new <b>AllMatches</b> instance is obtained as output.
                (FT4)
                [This is most of the section 4 code.]
                </p></li><li><p>
                If the topmost <b>AllMatches</b> instance contains a <b>Match</b> with no <b>StringExclude</b>s,
                then the search context item
                satisfies the full-text condition given by the <b>FTSelection</b>,
                and the call to <code>fts:FTContainsExpr</code> returns <code>true</code>.
                [This is handled by the QuantifiedExpr in <code>fts:FTContainsExpr</code>.]
                </p></li></ol><p>
            [Note that the section 4 code doesn't implement 4b-4d as three sequential steps.
            Instead, they are different aspects of a single traversal of the operator tree.]
            </p><p>
            If none of the topmost <b>AllMatches</b> provides a successful match,
            then <code>fts:FTContainsExpr</code> returns <code>false</code>.
            </p></li><li><p>
            The boolean value returned by the call to <code>fts:FTContainsExpr</code>
            is the value of the FTContainsExpr.
            (FT5)
            </p></li></ol><div class="semfunc-file-fts-xquery"><div class="exampleInner"><pre>
declare function fts:FTContainsExpr (
      $searchContextItems as item()*,
      $ignoreNodes as node()*,
      $ftSelection as element(*,fts:ftSelection),
      $defOptions as element(fts:matchOptions) )
   as xs:boolean 
{ 
   some $searchContext in $searchContextItems
   satisfies 
      let $newSearchContext := fts:reconstruct( $searchContext, $ignoreNodes )
      return
         if (fn:empty($newSearchContext)) then fn:false()
         else
            let $allMatches := fts:evaluate($ftSelection,
                                            $newSearchContext,
                                            $defOptions,
                                            0)
            return 
               some $match in $allMatches/fts:match
               satisfies 
                  fn:count($match/fts:stringExclude) eq 0
};

declare function fts:reconstruct (
      $n as item(),
      $ignore as node()* )
   as item()?
{
   typeswitch ($n)
     case node() return
        if (some $i in $ignore satisfies $n is $i) then ()
        else if ($n instance of element()) then
           let $nodeName := fn:node-name($n)
           let $nodeContent := for $nn in $n/node()
                               return fts:reconstruct($nn,$ignore)
           return element {$nodeName} {$nodeContent}
        else if ($n instance of document-node()) then
           document {
              for $nn in $n/node()
              return fts:reconstruct($nn, $ignore)
           }
        else $n
     default return $n
};
            </pre></div></div></div></div><div class="xquery"><div class="div2">
<h3><a name="ScoreSec" id="ScoreSec"/>4.4 Scoring</h3><p>This section addresses the semantics of 
               scoring variables in XQuery 1.0 <code>for</code> and
               <code>let</code> clauses and XPath 2.0 <code>for</code>
               expressions.</p><p>Scoring variables associate a numeric score with the result of the evaluation
			 of XQuery 1.0 and XPath 2.0 expressions. This numeric score
			 tries to estimate the value of a result item to the user
			 information need expressed using the XQuery 1.0 and XPath 2.0 
			 expression. The numeric score is computed using an
             <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> 
			            <em>scoring algorithm</em>.</p><p>There are numerous scoring algorithms used in practice. Most of
			 the scoring algorithms take as inputs a query and a set of results
			 to the query. In computing the score, these algorithms rely on the
			 structure of the query to estimate the relevance of the results. 
			 </p><p>In the context of defining the semantics of XQuery and XPath 
			 Full Text, passing the structure of the query poses a problem.
			 The query may contain XQuery 1.0 and XPath 2.0 expressions and
			 XQuery and XPath Full Text 1.0 expressions in particular. The 
			 semantics of XQuery 1.0 and XPath 2.0 expressions is
			 defined using (among other things) functions that take as
			 arguments sequences of 
			 items and return sequences of items. They are not aware of what
			 expression produced a particular sequence, i.e., they are not
			 aware of the expression structure.</p><p>To define the semantics of scoring in XQuery and XPath Full Text 1.0 
			 using XQuery 1.0, expressions that produce
			 the query result (or the functions that implement the expressions)
			 must be passed as arguments. In other words, second-order functions
			 are necessary. Currently XQuery 1.0 and XPath 2.0 do
			 not provide such functions. </p><p>Nevertheless, in the interest of the exposition, assume 
               that such second-order functions are present. In particular, that 
               there are two semantic second-order function
               <code>fts:score</code> and <code>fts:scoreSequence</code>
               that take one argument (an expression) and return the
               score value of this expression, respectively a sequence
               of score values, one for each item to which the expression
               evaluates. The scores must satisfy <a href="#section-score-variables">scoring properties</a>.</p><p>A <code>for</code> clause containing a score variable
</p><div class="exampleInner"><pre>
for $result score $score in Expr
...
</pre></div><p>
               is evaluated as
               though it is replaced by the following  the set of clauses.
               
</p><div class="exampleInner"><pre>
let $scoreSeq := fts:scoreSequence(Expr)
for $result at $i in Expr
let $score := $scoreSeq[$i]
...
</pre></div><p>
               Here, <code>$scoreSeq</code> and <code>$i</code> are
               new variables, not appearing elsewhere, and
               <code>fts:scoreSequence</code> is the 
               second-order function.
            </p><p>Similarly, a <code>let</code> clause containing a score variable
</p><div class="exampleInner"><pre>
let score $score := Expr
...
</pre></div><p>
               is evaluated as
               though it is replaced by the following clause.
</p><div class="exampleInner"><pre>
let $score := fts:score(Expr)
...
</pre></div></div></div><div class="xquery"><div class="div2">
<h3><a name="tq-ft-FTContainsExpr-example" id="tq-ft-FTContainsExpr-example"/>4.5 Example</h3><p>This section presents a more complex example for the evaluation of <b>FTContainsExpr</b>. This example uses the same 
			sample document fragment and assigns it <code>$doc</code>. 
            Consider the following <b>FTContainsExpr</b>.</p><div class="xpath"><div class="exampleInner"><pre>
    $doc contains text (
        (
            "Mustang"
            ftand
            ({("great", "excellent")} any word occurs at least 2 times)
            window 11 words
        )
        ftand
        ftnot "rust"
    ) same paragraph
</pre></div></div><p>Begin by evaluating the <b>FTSelection</b> to <b>AllMatches</b>.</p><div class="exampleInner"><pre>
    (
        (
            "Mustang"
            ftand
            ({("great", "excellent")} any word occurs at least 2 times)
            window 11 words
        )
        ftand
        ftnot "rust"
    ) same paragraph
</pre></div><p>Step 1: Evaluate the <b>FTWords</b>
                <code>"Mustang"</code>.
            </p><img src="images/CompleteExample01.jpg" alt="Example, step 1"/><p>Step 2: Evaluate the <b>FTWords</b>
                <code>{"great", "excellent"} any word</code>.
            </p><p>Step 2.1: Match the token "great"</p><img src="images/CompleteExample02.jpg" alt="Example, step 2"/><p>Step 2.2 Match the token "excellent"</p><img src="images/CompleteExample03.jpg" alt="Example, step 3"/><p>Step 2.3 - Combine the above <b>AllMatches</b> as if <b>FTOr</b> is used, i.e., by
                forming  a union of the <b>Match</b>es.</p><img src="images/CompleteExample04.jpg" alt="Example, step 4"/><p>Step 3 - Apply the <b>FTTimes</b>
                <code>{("great", "excellent")} any word occurs at least 2 times</code>
				forming two pairs of <b>Match</b>es.</p><img src="images/CompleteExample05_1.jpg" alt="Example, step 5.1"/><p>
               <img src="images/CompleteExample05_1_2.jpg" alt="Example, step 5.1"/>
            </p><img src="images/CompleteExample05_2.jpg" alt="Example, step 5.2"/><p>Step 4 - Apply the <b>FTAnd</b>
                <code>
                "Mustang" 
                ftand
                ({("great", "excellent")} any word occurs at least 2 times)
                </code> forming all possible pairs of <b>StringMatch</b>es.</p><img src="images/CompleteExample06_1.jpg" alt="Example, step 6.1"/><p>
               <img src="images/CompleteExample06_1_2.jpg" alt="Example, step 6.1"/>
            </p><img src="images/CompleteExample06_2.jpg" alt="Example, step 6.2"/><p>
               <img src="images/CompleteExample06_2_2.jpg" alt="Example, step 6.2"/>
            </p><img src="images/CompleteExample06_3.jpg" alt="Example, step 6.3"/><p>
               <img src="images/CompleteExample06_3_2.jpg" alt="Example, step 6.3"/>
            </p><img src="images/CompleteExample06_4.jpg" alt="Example, step 6.4"/><p>
               <img src="images/CompleteExample06_4_2.jpg" alt="Example, step 6.4"/>
            </p><img src="images/CompleteExample06_5.jpg" alt="Example, step 6.5"/><p>
               <img src="images/CompleteExample06_5_2.jpg" alt="Example, step 6.5"/>
            </p><p>Step 5 - Apply the <b>FTWindow</b>
                <code>
                (
                    "Mustang" 
                    ftand
                    ({("great", "excellent")} any word occurs at least 2 times)
                    window 11 words
                )
                </code>, filtering out <b>Match</b>es 
                for which the window is not less than or equal to 11 tokens.</p><img src="images/CompleteExample07_1.jpg" alt="Example, step 7.1"/><p>
               <img src="images/CompleteExample07_2.jpg" alt="Example, step 7.2"/>
            </p><img src="images/CompleteExample07_2_2.jpg" alt="Example, step 7.2"/><p>Step 6 - Evaluate <b>FTWords</b>
                <code>"rust"</code>.
            </p><img src="images/CompleteExample08.jpg" alt="Example, step 8"/><p>Step 7 - Apply the <b>FTUnaryNot</b>
                <code>ftnot "rust"</code>, 
                transforming the <code>StringInclude</code> into a 
				<code>StringExclude</code>.
            </p><img src="images/CompleteExample09.jpg" alt="Example, step 9"/><p>Step 8 - Apply the <b>FTAnd</b>
                <code>
                (
                    (
                        "Mustang"
                        ftand
                        ({("great", "excellent")} any word occurs at least 2 times)
                        window 11 words
                    )
                    ftand
                    ftnot "rust"
                )
                </code>, forming all
				possible combintations of three <b>StringMatch</b>es from the first
				<b>AllMatches</b> and one <b>StringMatch</b> from the second <b>AllMatches</b>. </p><img src="images/CompleteExample10_1.jpg" alt="Example, step 10.1"/><p>
               <img src="images/CompleteExample10_2.jpg" alt="Example, step 10.2"/>
            </p><img src="images/CompleteExample10_3.jpg" alt="Example, step 10.3"/><p>Step 9: Apply the <b>FTScope</b>,  filtering out <b>
                Match</b>es whose <b>TokenInfo</b>s are not within the same paragraph 
				(assuming the <code>&lt;offer&gt;</code> elements determine
				paragraph boundaries).</p><img src="images/CompleteExample11.jpg" alt="Example, step 11"/><p>The resulting <b>AllMatches</b> contains a <b>Match</b> 
            that does not contain a <b>StringExclude</b>. Therefore, the
            sample <b>FTContainsExpr</b> returns <code>true</code>.</p></div></div></div><div class="div1">
<h2><a name="id-tq-conformance" id="id-tq-conformance"/>5 Conformance</h2><p>This section defines the conformance criteria for a XQuery and XPath Full Text 1.0
       processor.
  </p><p>In this section, the following terms are used to indicate the
     requirement levels defined in <a href="#RFC2119">[RFC 2119]</a>.
      [<a name="must" id="must" title="must">Definition</a>: 
               <b>MUST</b> means that the item is an absolute requirement of the specification.]
            [<a name="may" id="may" title="may">Definition</a>: 
               <b>MAY</b> means that an item is truly optional.]
            [<a name="should" id="should" title="should">Definition</a>: 
               <b>SHOULD</b> means that there may exist valid reasons in particular circumstances
          to ignore a particular item, but the full implications must be understood and carefully
          weighed before choosing a different course.]
         </p><p>An XQuery and XPath Full Text 1.0 processor that claims to conform to 
     this specification <a title="must" href="#must">MUST</a>
     include a claim of Minimal Conformance as defined in 
     <a href="#id-minimal-conformance"><b>5.1 Minimal Conformance</b></a>.
     In addition to a claim of Minimal Conformance, 
     it <a title="may" href="#may">MAY</a>
     claim conformance to one or more optional features defined in 
     <a href="#id-conform-optional-features"><b>5.2 Optional Features</b></a>
         </p><div class="div2">
<h3><a name="id-minimal-conformance" id="id-minimal-conformance"/>5.1 Minimal Conformance</h3><p>Minimal Conformance to this specification 
    <a title="must" href="#must">MUST</a> include all of the following items:</p><ol class="enumar"><li><p>Minimal support for XQuery 1.0 <a href="#xquery">[XQuery 1.0: An XML Query Language (Second Edition)]</a>
        or XPath 2.0 <a href="#xpath20">[XML Path Language (XPath) 2.0 (Second Edition)]</a>. 
        The optional features of XQuery 1.0 <a href="#xquery">[XQuery 1.0: An XML Query Language (Second Edition)]</a> or
        XPath 2.0 <a href="#xpath20">[XML Path Language (XPath) 2.0 (Second Edition)]</a> 
                     <a title="may" href="#may">MAY</a>
        be supported.</p></li><li><p>Support for everything specified in this document except those
          operators and match options specified in 
          <a href="#id-conform-optional-features"><b>5.2 Optional Features</b></a> to be optional.
          If an implementation does not provide a given optional operator or
          match option, it  <a title="must" href="#must">MUST</a>
          implement any requirements specified in 
          <a href="#id-conform-optional-features"><b>5.2 Optional Features</b></a>
          for implementations that do not provide that operator or match
          option.</p></li><li><p>A definition of every item specified to be 
           <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> in 
           <a href="#impl-def"><b>I Checklist of Implementation-Defined Features</b></a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Implementations are not required to define items specified to
              be <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>
                     </p></div></li></ol></div><div class="div2">
<h3><a name="id-conform-optional-features" id="id-conform-optional-features"/>5.2 Optional Features</h3><div class="div3">
<h4><a name="id-ftmildnot-option" id="id-ftmildnot-option"/>5.2.1 FTMildNot Operator</h4><p>It is optional whether the implementation supports the FTMildNot. If
        it does not support FTMildNot and encounters one in a full-text
        query, then it <a title="must" href="#must">MUST</a> raise
        an error [<a href="#ERRFTST0001" title="err:FTST0001">err:FTST0001</a>].</p></div><div class="div3">
<h4><a name="id-unary-not-option" id="id-unary-not-option"/>5.2.2 FTUnaryNot Operator</h4><p>The unrestricted form of negation in FTUnaryNot,
         that can negate every kind of FTSelection, is
         optional. Implementations may choose to support the negation
         operation in a restricted form, enforcing one or both of the
         following restrictions.</p><ul><li><p>
                        [<a name="id-Negation-Restriction-1" id="id-Negation-Restriction-1" title="Negation Restriction 1">Definition</a>: 
                           <b>Negation Restriction 1.</b> An <a href="#doc-xquery10-FTUnaryNot">FTUnaryNot</a>
        expression may only appear as a direct right operand of an
        "ftand" (<a href="#doc-xquery10-FTAnd">FTAnd</a>) operation.]
                     </p></li><li><p>
                        [<a name="id-Negation-Restriction-2" id="id-Negation-Restriction-2" title="Negation Restriction 2">Definition</a>: 
                           <b>Negation Restriction 2.</b> An <a href="#doc-xquery10-FTUnaryNot">FTUnaryNot</a>
        expression may not appear as a descendant of an 
        <a href="#doc-xquery10-FTOr">FTOr</a> that is modified by an 
        <a href="#doc-xquery10-FTPosFilter">FTPosFilter</a>. (An
        FTOr is modified by an FTPosFilter, if it is derived using
        the production for <a href="#doc-xquery10-FTSelection">FTSelection</a> 
         together with that FTPosFilter.)]
                     </p></li></ul><p>Consider the following example FTSelections.</p><div class="exampleInner"><pre>
1. ftnot "web"

2. "web" ftand ( ftnot "information" ftor "retrieval" )

3. "web" ftand ftnot("information" ftand "retrieval")

4. "web" ftand ftnot("information" ftand "retrieval" window 5 words)

5. "web" ftand ("information" ftand ftnot "retrieval" window 5 words)
</pre></div><p>The first two FTSelections both violate restriction 1, while the third and 
the fourth are conform with both restrictions. The fifth one violates 
restriction 2, while obeying restriction 1. Note that in the last example 
the FTSelection to which the window operation is applied is 
<code>"information" ftand ftnot "retrieval"</code>, which contains an FTUnaryNot 
expression.</p><p>If the implementation does enforce
           one or both of these restrictions on FTUnaryNot and encounters a
           full-text query that does not obey the restriction then it 
           <a title="must" href="#must">MUST</a>
           raise an error [<a href="#ERRFTST0002" title="err:FTST0002">err:FTST0002</a>].</p></div><div class="div3">
<h4><a name="id-ftunit-option" id="id-ftunit-option"/>5.2.3 FTUnit and FTBigUnit</h4><p>Support for the "sentences" alternative of <a href="#doc-xquery10-FTUnit">FTUnit</a>
        and the "sentence" alternative of <a href="#doc-xquery10-FTBigUnit">FTBigUnit</a> is
        optional. Similarly, support for the "paragraphs" alternative of FTUnit
        and the "paragraph" alternative of FTBigUnit is optional.
        If an implementation does not support one or
        more choices of FTUnit or FTBigUnit and encounters an unsupported
        FTUnit or FTBigUnit in a full-text query, then it 
        <a title="must" href="#must">MUST</a> raise an error
        [<a href="#ERRFTST0003" title="err:FTST0003">err:FTST0003</a>].</p></div><div class="div3">
<h4><a name="id-ftorder-option" id="id-ftorder-option"/>5.2.4 FTOrder Operator</h4><p>The unrestricted form of the FTOrder postfix operator, that can be 
        applied to any kind of FTSelection, is optional.
        Implementations may choose to enforce the following
        restriction on the use of FTOrder.</p><p>
                  [<a name="id-Order-Operator-Restriction" id="id-Order-Operator-Restriction" title="Order Operator Restriction">Definition</a>: 
                     <b>Order Operator Restriction.</b> FTOrder may only appear directly succeeding 
        an FTWindow or an FTDistance operator.]
               </p><p>If the implementation does enforce this restriction and encounters a
        full-text query that does not obey the restriction then it 
        <a title="must" href="#must">MUST</a>
        raise an error [<a href="#ERRFTST0010" title="err:FTST0010">err:FTST0010</a>].</p></div><div class="div3">
<h4><a name="id-ftscope-option" id="id-ftscope-option"/>5.2.5 FTScope Operator</h4><p>It is optional whether the implementation supports the FTScope
      operator.  If it does not support FTScope and encounters one in a
      full-text query, then it <a title="must" href="#must">MUST</a> raise an
      error [<a href="#ERRFTST0004" title="err:FTST0004">err:FTST0004</a>].</p></div><div class="div3">
<h4><a name="id-ftwindow-option" id="id-ftwindow-option"/>5.2.6 FTWindow Operator</h4><p>The unrestricted form of the FTWindow postfix operator, that can be 
        applied to any kind of FTSelection, is optional.
        Implementations may choose to enforce the following
        restriction on the use of FTWindow.</p><p>
                  [<a name="id-Window-Operator-Restriction" id="id-Window-Operator-Restriction" title="Window Operator Restriction">Definition</a>: 
                     <b>Window Operator Restriction.</b> FTWindow can only be applied to an FTOr that
        is either a single FTWords or a combination of FTWords involving only the 
        operators ftand and ftor.]
               </p><p>If the implementation does enforce this restriction and encounters a
        full-text query that does not obey the restriction then it 
        <a title="must" href="#must">MUST</a>
        raise an error [<a href="#ERRFTST0011" title="err:FTST0011">err:FTST0011</a>].</p></div><div class="div3">
<h4><a name="id-ftdistance-option" id="id-ftdistance-option"/>5.2.7 FTDistance Operator</h4><p>The unrestricted form of the FTDistance postfix operator, that can be 
        applied to any kind of FTSelection, is optional.
        Implementations may choose to enforce the following
        restriction on the use of FTDistance.</p><p>
                  [<a name="id-Distance-Operator-Restriction" id="id-Distance-Operator-Restriction" title="Distance Operator Restriction">Definition</a>: 
                     <b>Distance Operator Restriction.</b> FTDistance can only be applied to an FTOr that
        is either a single FTWords or a combination of FTWords involving only the 
        operators ftand and ftor.]
               </p><p>If the implementation does enforce this restriction and encounters a
        full-text query that does not obey the restriction then it 
        <a title="must" href="#must">MUST</a>
        raise an error [<a href="#ERRFTST0011" title="err:FTST0011">err:FTST0011</a>].</p></div><div class="div3">
<h4><a name="id-fttimes-option" id="id-fttimes-option"/>5.2.8 FTTimes Operator</h4><p>It is optional whether the implementation supports the FTTimes
        operator. If it does not support FTTimes and encounters one in a
        full-text query, then it <a title="must" href="#must">MUST</a> raise an
        error [<a href="#ERRFTST0005" title="err:FTST0005">err:FTST0005</a>].</p></div><div class="div3">
<h4><a name="id-ftcontent-option" id="id-ftcontent-option"/>5.2.9 FTContent Operator</h4><p>It is optional whether the implementation supports the FTContent
      operator.  If it does not support FTContent and encounters one in a
      full-text query, then it <a title="must" href="#must">MUST</a> raise an
      error [<a href="#ERRFTST0012" title="err:FTST0012">err:FTST0012</a>].</p></div><div class="div3">
<h4><a name="id-ftcase-option" id="id-ftcase-option"/>5.2.10 FTCaseOption</h4><p>It is optional whether the implementation supports the
    "lowercase" and "uppercase" choices for the
    FTCaseOption.  If it does not support these choices for the FTCaseOption
    and encounters an unsupported choice in a full-text query, then it 
        <a title="must" href="#must">MUST</a> raise an error
        [<a href="#ERRFTST0015" title="err:FTST0015">err:FTST0015</a>].
    </p></div><div class="div3">
<h4><a name="id-ftstopword-option" id="id-ftstopword-option"/>5.2.11 FTStopWordOption</h4><p>It is optional whether the implementation supports the
        FTStopWordOption. If it does not support FTStopWordOption and
        encounters one in a full-text query, then it 
        <a title="must" href="#must">MUST</a> raise an
        error [<a href="#ERRFTST0006" title="err:FTST0006">err:FTST0006</a>].</p><p>It is optional whether the implementation supports the
        FTStopWordOption in the body of the query. If it supports
        FTStopWordOption in the prolog, but not in the body of a query, and
        encounters one in the body of a query it 
        <a title="must" href="#must">MUST</a> raise an
        error [<a href="#ERRFTST0006" title="err:FTST0006">err:FTST0006</a>].</p><p>It is optional whether the implementation supports the StringLiteral
        alternative of <a href="#doc-xquery10-FTStopWords">FTStopWords</a> in the 
        FTStopWordOption. If it does not support the StringLiteral alternative
        of FTStopWords and encounters such an alternative in a full-text query,
        then it <a title="must" href="#must">MUST</a> raise an
        error [<a href="#ERRFTST0006" title="err:FTST0006">err:FTST0006</a>].</p></div><div class="div3">
<h4><a name="id-ftlanguage-option" id="id-ftlanguage-option"/>5.2.12 FTLanguageOption</h4><p>It is optional whether the implementation supports the unrestricted form 
        of FTLanguageOption. Implementations may choose to enforce the following 
        restriction on the use of FTLanguageOption.</p><p>
                  [<a name="id-Single-Language-Restriction" id="id-Single-Language-Restriction" title="Single Language Restriction">Definition</a>: 
                     <b>Single Language Restriction.</b> If a full-text query contains more than one
        FTLanguageOption in its body and the prolog, then the languages specified 
        must be the same.]
               </p><p>If the implementation does enforce this restriction and encounters a
        full-text query that does not obey the restriction then it 
        <a title="must" href="#must">MUST</a>
        raise an error [<a href="#ERRFTST0013" title="err:FTST0013">err:FTST0013</a>].</p></div><div class="div3">
<h4><a name="id-ftignore-option" id="id-ftignore-option"/>5.2.13 FTIgnoreOption</h4><p>The implementation may constrain the set of ignored nodes.
      If the operand of <a href="#doc-xquery10-FTIgnoreOption">FTIgnoreOption</a> violates
      the <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> restriction on that operand, it 
      <a title="must" href="#must">MUST</a> raise an
      error [<a href="#ERRFTST0007" title="err:FTST0007">err:FTST0007</a>].</p></div><div class="div3">
<h4><a name="id-scoring-option" id="id-scoring-option"/>5.2.14 Scoring</h4><p>The implementation may restrict the allowable expressions used to
      compute scores.  The restrictions are <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.
      </p><p>If the implementation does enforce such restrictions and encounters a
        full-text query that does not obey the restriction then it 
        <a title="must" href="#must">MUST</a>
        raise an error [<a href="#ERRFTST0014" title="err:FTST0014">err:FTST0014</a>].</p></div><div class="div3">
<h4><a name="id-weights-conf" id="id-weights-conf"/>5.2.15 Weights</h4><p>An implementation may constrain the range of valid weights to
    non-negative values. If an implementation does enforce this restriction and
    encounters a full-text query that uses a negative weight, it 
    <a title="must" href="#must">MUST</a> raise an
    error [<a href="#ERRFTDY0016" title="err:FTDY0016">err:FTDY0016</a>].
    </p></div></div></div><div class="diff-add"><div class="div1">
<h2><a name="id-xqueryx-full-text-conformance" id="id-xqueryx-full-text-conformance"/>6 XQueryX Conformance</h2><p>This section defines the conformance criteria for an XQueryX processor 
that includes the Full Text capability.</p><p>In this section, the terms <a title="must" href="#must">MUST</a>, <a title="may" href="#may">MAY</a>, and <a title="should" href="#should">SHOULD</a> are used as
defined in <a href="#id-tq-conformance"><b>5 Conformance</b></a>.</p><p>An XQueryX processor that claims to conform to this specification
<a title="must" href="#must">MUST</a> implement the XQueryX syntax as defined
in <a href="#id-xqft-xqueryx"><b>E XML Syntax (XQueryX) for XQuery and XPath Full Text 1.0</b></a> and include a claim of Minimal
Conformance as defined in <a href="#id-minimal-conformance"><b>5.1 Minimal Conformance</b></a>. 
In addition to a claim of
Minimal Conformance, it <a title="may" href="#may">MAY</a> claim conformance to one or more optional
features defined in <a href="#id-conform-optional-features"><b>5.2 Optional Features</b></a>.</p></div></div></div><div class="back"><div class="div1">
<h2><a name="id-grammar" id="id-grammar"/>A EBNF for XQuery 1.0 Grammar with Full Text extensions</h2><p>The EBNF in this document and in this section is aligned with
the current XML Query 1.0 grammar (see <a href="http://www.w3.org/TR/2010/REC-xquery-20101214/">http://www.w3.org/TR/2010/REC-xquery-20101214/</a>).</p><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="prod-xquery10-Module" id="prod-xquery10-Module"/>[1]   </td><td><code>Module</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-VersionDecl">VersionDecl</a>?  (<a href="#prod-xquery10-LibraryModule">LibraryModule</a>  |  <a href="#prod-xquery10-MainModule">MainModule</a>)</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-VersionDecl" id="prod-xquery10-VersionDecl"/>[2]   </td><td><code>VersionDecl</code></td><td>   ::=   </td><td><code>"xquery"  "version"  <a href="#prod-xquery10-StringLiteral">StringLiteral</a>  ("encoding"  <a href="#prod-xquery10-StringLiteral">StringLiteral</a>)?  <a href="#prod-xquery10-Separator">Separator</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-MainModule" id="prod-xquery10-MainModule"/>[3]   </td><td><code>MainModule</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-Prolog">Prolog</a>  
                  <a href="#prod-xquery10-QueryBody">QueryBody</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-LibraryModule" id="prod-xquery10-LibraryModule"/>[4]   </td><td><code>LibraryModule</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-ModuleDecl">ModuleDecl</a>  
                  <a href="#prod-xquery10-Prolog">Prolog</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-ModuleDecl" id="prod-xquery10-ModuleDecl"/>[5]   </td><td><code>ModuleDecl</code></td><td>   ::=   </td><td><code>"module"  "namespace"  <a href="#prod-xquery10-NCName">NCName</a>  "="  <a href="#prod-xquery10-URILiteral">URILiteral</a>  
                  <a href="#prod-xquery10-Separator">Separator</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-Prolog" id="prod-xquery10-Prolog"/>[6]   </td><td><code><a href="#doc-xquery10-Prolog"><a href="#doc-xquery10-Prolog">Prolog</a></a></code></td><td>   ::=   </td><td><code>((<a href="#prod-xquery10-DefaultNamespaceDecl">DefaultNamespaceDecl</a>  |  <a href="#prod-xquery10-Setter">Setter</a>  |  <a href="#prod-xquery10-NamespaceDecl">NamespaceDecl</a>  |  <a href="#prod-xquery10-Import">Import</a>  |  <a href="#prod-xquery10-FTOptionDecl">FTOptionDecl</a>)  <a href="#prod-xquery10-Separator">Separator</a>)*  ((<a href="#prod-xquery10-VarDecl">VarDecl</a>  |  <a href="#prod-xquery10-FunctionDecl">FunctionDecl</a>  |  <a href="#prod-xquery10-OptionDecl">OptionDecl</a>)  <a href="#prod-xquery10-Separator">Separator</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-Separator" id="prod-xquery10-Separator"/>[7]   </td><td><code>Separator</code></td><td>   ::=   </td><td><code>";"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-Setter" id="prod-xquery10-Setter"/>[8]   </td><td><code>Setter</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-BoundarySpaceDecl">BoundarySpaceDecl</a>  |  <a href="#prod-xquery10-DefaultCollationDecl">DefaultCollationDecl</a>  |  <a href="#prod-xquery10-BaseURIDecl">BaseURIDecl</a>  |  <a href="#prod-xquery10-ConstructionDecl">ConstructionDecl</a>  |  <a href="#prod-xquery10-OrderingModeDecl">OrderingModeDecl</a>  |  <a href="#prod-xquery10-EmptyOrderDecl">EmptyOrderDecl</a>  |  <a href="#prod-xquery10-CopyNamespacesDecl">CopyNamespacesDecl</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-BoundarySpaceDecl" id="prod-xquery10-BoundarySpaceDecl"/>[9]   </td><td><code>BoundarySpaceDecl</code></td><td>   ::=   </td><td><code>"declare"  "boundary-space"  ("preserve"  |  "strip")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-DefaultCollationDecl" id="prod-xquery10-DefaultCollationDecl"/>[10]   </td><td><code>DefaultCollationDecl</code></td><td>   ::=   </td><td><code>"declare"  "default"  "collation"  <a href="#prod-xquery10-URILiteral">URILiteral</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-BaseURIDecl" id="prod-xquery10-BaseURIDecl"/>[11]   </td><td><code>BaseURIDecl</code></td><td>   ::=   </td><td><code>"declare"  "base-uri"  <a href="#prod-xquery10-URILiteral">URILiteral</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-ConstructionDecl" id="prod-xquery10-ConstructionDecl"/>[12]   </td><td><code>ConstructionDecl</code></td><td>   ::=   </td><td><code>"declare"  "construction"  ("strip"  |  "preserve")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-OrderingModeDecl" id="prod-xquery10-OrderingModeDecl"/>[13]   </td><td><code>OrderingModeDecl</code></td><td>   ::=   </td><td><code>"declare"  "ordering"  ("ordered"  |  "unordered")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-EmptyOrderDecl" id="prod-xquery10-EmptyOrderDecl"/>[14]   </td><td><code>EmptyOrderDecl</code></td><td>   ::=   </td><td><code>"declare"  "default"  "order"  "empty"  ("greatest"  |  "least")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-CopyNamespacesDecl" id="prod-xquery10-CopyNamespacesDecl"/>[15]   </td><td><code>CopyNamespacesDecl</code></td><td>   ::=   </td><td><code>"declare"  "copy-namespaces"  <a href="#prod-xquery10-PreserveMode">PreserveMode</a>  ","  <a href="#prod-xquery10-InheritMode">InheritMode</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-PreserveMode" id="prod-xquery10-PreserveMode"/>[16]   </td><td><code>PreserveMode</code></td><td>   ::=   </td><td><code>"preserve"  |  "no-preserve"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-InheritMode" id="prod-xquery10-InheritMode"/>[17]   </td><td><code>InheritMode</code></td><td>   ::=   </td><td><code>"inherit"  |  "no-inherit"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-Import" id="prod-xquery10-Import"/>[18]   </td><td><code>Import</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-SchemaImport">SchemaImport</a>  |  <a href="#prod-xquery10-ModuleImport">ModuleImport</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-SchemaImport" id="prod-xquery10-SchemaImport"/>[19]   </td><td><code>SchemaImport</code></td><td>   ::=   </td><td><code>"import"  "schema"  <a href="#prod-xquery10-SchemaPrefix">SchemaPrefix</a>?  <a href="#prod-xquery10-URILiteral">URILiteral</a>  ("at"  <a href="#prod-xquery10-URILiteral">URILiteral</a>  (","  <a href="#prod-xquery10-URILiteral">URILiteral</a>)*)?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-SchemaPrefix" id="prod-xquery10-SchemaPrefix"/>[20]   </td><td><code>SchemaPrefix</code></td><td>   ::=   </td><td><code>("namespace"  <a href="#prod-xquery10-NCName">NCName</a>  "=")  |  ("default"  "element"  "namespace")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-ModuleImport" id="prod-xquery10-ModuleImport"/>[21]   </td><td><code>ModuleImport</code></td><td>   ::=   </td><td><code>"import"  "module"  ("namespace"  <a href="#prod-xquery10-NCName">NCName</a>  "=")?  <a href="#prod-xquery10-URILiteral">URILiteral</a>  ("at"  <a href="#prod-xquery10-URILiteral">URILiteral</a>  (","  <a href="#prod-xquery10-URILiteral">URILiteral</a>)*)?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-NamespaceDecl" id="prod-xquery10-NamespaceDecl"/>[22]   </td><td><code>NamespaceDecl</code></td><td>   ::=   </td><td><code>"declare"  "namespace"  <a href="#prod-xquery10-NCName">NCName</a>  "="  <a href="#prod-xquery10-URILiteral">URILiteral</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-DefaultNamespaceDecl" id="prod-xquery10-DefaultNamespaceDecl"/>[23]   </td><td><code>DefaultNamespaceDecl</code></td><td>   ::=   </td><td><code>"declare"  "default"  ("element"  |  "function")  "namespace"  <a href="#prod-xquery10-URILiteral">URILiteral</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTOptionDecl" id="prod-xquery10-FTOptionDecl"/>[24]   </td><td><code><a href="#doc-xquery10-FTOptionDecl"><a href="#doc-xquery10-FTOptionDecl">FTOptionDecl</a></a></code></td><td>   ::=   </td><td><code>"declare"  "ft-option"  <a href="#prod-xquery10-FTMatchOptions">FTMatchOptions</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-VarDecl" id="prod-xquery10-VarDecl"/>[25]   </td><td><code>VarDecl</code></td><td>   ::=   </td><td><code>"declare"  "variable"  "$"  <a href="#prod-xquery10-QName">QName</a>  
                  <a href="#prod-xquery10-TypeDeclaration">TypeDeclaration</a>?  ((":="  <a href="#prod-xquery10-ExprSingle">ExprSingle</a>)  |  "external")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FunctionDecl" id="prod-xquery10-FunctionDecl"/>[26]   </td><td><code>FunctionDecl</code></td><td>   ::=   </td><td><code>"declare"  "function"  <a href="#prod-xquery10-QName">QName</a>  "("  <a href="#prod-xquery10-ParamList">ParamList</a>?  ")"  ("as"  <a href="#prod-xquery10-SequenceType">SequenceType</a>)?  (<a href="#prod-xquery10-EnclosedExpr">EnclosedExpr</a>  |  "external")</code></td><td><i>/* 
                  <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                     <a href="http://www.w3.org/TR/xquery/#parse-note-reserved-function-names">xgc: reserved-function-names</a><sup><small>XQ</small></sup>
                  </span>
                */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-ParamList" id="prod-xquery10-ParamList"/>[27]   </td><td><code>ParamList</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-Param">Param</a>  (","  <a href="#prod-xquery10-Param">Param</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-Param" id="prod-xquery10-Param"/>[28]   </td><td><code>Param</code></td><td>   ::=   </td><td><code>"$"  <a href="#prod-xquery10-QName">QName</a>  
                  <a href="#prod-xquery10-TypeDeclaration">TypeDeclaration</a>?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-EnclosedExpr" id="prod-xquery10-EnclosedExpr"/>[29]   </td><td><code>EnclosedExpr</code></td><td>   ::=   </td><td><code>"{"  <a href="#prod-xquery10-Expr">Expr</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-OptionDecl" id="prod-xquery10-OptionDecl"/>[30]   </td><td><code>OptionDecl</code></td><td>   ::=   </td><td><code>"declare"  "option"  <a href="#prod-xquery10-QName">QName</a>  
                  <a href="#prod-xquery10-StringLiteral">StringLiteral</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-QueryBody" id="prod-xquery10-QueryBody"/>[31]   </td><td><code>QueryBody</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-Expr">Expr</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-Expr" id="prod-xquery10-Expr"/>[32]   </td><td><code>Expr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-ExprSingle">ExprSingle</a>  (","  <a href="#prod-xquery10-ExprSingle">ExprSingle</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-ExprSingle" id="prod-xquery10-ExprSingle"/>[33]   </td><td><code>ExprSingle</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-FLWORExpr">FLWORExpr</a>
                  <br/>|  <a href="#prod-xquery10-QuantifiedExpr">QuantifiedExpr</a>
                  <br/>|  <a href="#prod-xquery10-TypeswitchExpr">TypeswitchExpr</a>
                  <br/>|  <a href="#prod-xquery10-IfExpr">IfExpr</a>
                  <br/>|  <a href="#prod-xquery10-OrExpr">OrExpr</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FLWORExpr" id="prod-xquery10-FLWORExpr"/>[34]   </td><td><code>FLWORExpr</code></td><td>   ::=   </td><td><code>(<a href="#prod-xquery10-ForClause">ForClause</a>  |  <a href="#prod-xquery10-LetClause">LetClause</a>)+  <a href="#prod-xquery10-WhereClause">WhereClause</a>?  <a href="#prod-xquery10-OrderByClause">OrderByClause</a>?  "return"  <a href="#prod-xquery10-ExprSingle">ExprSingle</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-ForClause" id="prod-xquery10-ForClause"/>[35]   </td><td><code><a href="#doc-xquery10-ForClause"><a href="#doc-xquery10-ForClause">ForClause</a></a></code></td><td>   ::=   </td><td><code>"for"  "$"  <a href="#prod-xquery10-VarName">VarName</a>  
                  <a href="#prod-xquery10-TypeDeclaration">TypeDeclaration</a>?  <a href="#prod-xquery10-PositionalVar">PositionalVar</a>?  <a href="#prod-xquery10-FTScoreVar">FTScoreVar</a>?  "in"  <a href="#prod-xquery10-ExprSingle">ExprSingle</a>  (","  "$"  <a href="#prod-xquery10-VarName">VarName</a>  
                  <a href="#prod-xquery10-TypeDeclaration">TypeDeclaration</a>?  <a href="#prod-xquery10-PositionalVar">PositionalVar</a>?  <a href="#prod-xquery10-FTScoreVar">FTScoreVar</a>?  "in"  <a href="#prod-xquery10-ExprSingle">ExprSingle</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-PositionalVar" id="prod-xquery10-PositionalVar"/>[36]   </td><td><code>PositionalVar</code></td><td>   ::=   </td><td><code>"at"  "$"  <a href="#prod-xquery10-VarName">VarName</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTScoreVar" id="prod-xquery10-FTScoreVar"/>[37]   </td><td><code><a href="#doc-xquery10-FTScoreVar"><a href="#doc-xquery10-FTScoreVar">FTScoreVar</a></a></code></td><td>   ::=   </td><td><code>"score"  "$"  <a href="#prod-xquery10-VarName">VarName</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-LetClause" id="prod-xquery10-LetClause"/>[38]   </td><td><code><a href="#doc-xquery10-LetClause"><a href="#doc-xquery10-LetClause">LetClause</a></a></code></td><td>   ::=   </td><td><code>"let"  (("$"  <a href="#prod-xquery10-VarName">VarName</a>  
                  <a href="#prod-xquery10-TypeDeclaration">TypeDeclaration</a>?)  |  <a href="#prod-xquery10-FTScoreVar">FTScoreVar</a>)  ":="  <a href="#prod-xquery10-ExprSingle">ExprSingle</a>  (","  (("$"  <a href="#prod-xquery10-VarName">VarName</a>  
                  <a href="#prod-xquery10-TypeDeclaration">TypeDeclaration</a>?)  |  <a href="#prod-xquery10-FTScoreVar">FTScoreVar</a>)  ":="  <a href="#prod-xquery10-ExprSingle">ExprSingle</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-WhereClause" id="prod-xquery10-WhereClause"/>[39]   </td><td><code>WhereClause</code></td><td>   ::=   </td><td><code>"where"  <a href="#prod-xquery10-ExprSingle">ExprSingle</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-OrderByClause" id="prod-xquery10-OrderByClause"/>[40]   </td><td><code>OrderByClause</code></td><td>   ::=   </td><td><code>(("order"  "by")  |  ("stable"  "order"  "by"))  <a href="#prod-xquery10-OrderSpecList">OrderSpecList</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-OrderSpecList" id="prod-xquery10-OrderSpecList"/>[41]   </td><td><code>OrderSpecList</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-OrderSpec">OrderSpec</a>  (","  <a href="#prod-xquery10-OrderSpec">OrderSpec</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-OrderSpec" id="prod-xquery10-OrderSpec"/>[42]   </td><td><code>OrderSpec</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-ExprSingle">ExprSingle</a>  
                  <a href="#prod-xquery10-OrderModifier">OrderModifier</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-OrderModifier" id="prod-xquery10-OrderModifier"/>[43]   </td><td><code>OrderModifier</code></td><td>   ::=   </td><td><code>("ascending"  |  "descending")?  ("empty"  ("greatest"  |  "least"))?  ("collation"  <a href="#prod-xquery10-URILiteral">URILiteral</a>)?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-QuantifiedExpr" id="prod-xquery10-QuantifiedExpr"/>[44]   </td><td><code>QuantifiedExpr</code></td><td>   ::=   </td><td><code>("some"  |  "every")  "$"  <a href="#prod-xquery10-VarName">VarName</a>  
                  <a href="#prod-xquery10-TypeDeclaration">TypeDeclaration</a>?  "in"  <a href="#prod-xquery10-ExprSingle">ExprSingle</a>  (","  "$"  <a href="#prod-xquery10-VarName">VarName</a>  
                  <a href="#prod-xquery10-TypeDeclaration">TypeDeclaration</a>?  "in"  <a href="#prod-xquery10-ExprSingle">ExprSingle</a>)*  "satisfies"  <a href="#prod-xquery10-ExprSingle">ExprSingle</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-TypeswitchExpr" id="prod-xquery10-TypeswitchExpr"/>[45]   </td><td><code>TypeswitchExpr</code></td><td>   ::=   </td><td><code>"typeswitch"  "("  <a href="#prod-xquery10-Expr">Expr</a>  ")"  <a href="#prod-xquery10-CaseClause">CaseClause</a>+  "default"  ("$"  <a href="#prod-xquery10-VarName">VarName</a>)?  "return"  <a href="#prod-xquery10-ExprSingle">ExprSingle</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-CaseClause" id="prod-xquery10-CaseClause"/>[46]   </td><td><code>CaseClause</code></td><td>   ::=   </td><td><code>"case"  ("$"  <a href="#prod-xquery10-VarName">VarName</a>  "as")?  <a href="#prod-xquery10-SequenceType">SequenceType</a>  "return"  <a href="#prod-xquery10-ExprSingle">ExprSingle</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-IfExpr" id="prod-xquery10-IfExpr"/>[47]   </td><td><code>IfExpr</code></td><td>   ::=   </td><td><code>"if"  "("  <a href="#prod-xquery10-Expr">Expr</a>  ")"  "then"  <a href="#prod-xquery10-ExprSingle">ExprSingle</a>  "else"  <a href="#prod-xquery10-ExprSingle">ExprSingle</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-OrExpr" id="prod-xquery10-OrExpr"/>[48]   </td><td><code>OrExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-AndExpr">AndExpr</a> ( "or"  <a href="#prod-xquery10-AndExpr">AndExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-AndExpr" id="prod-xquery10-AndExpr"/>[49]   </td><td><code>AndExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-ComparisonExpr">ComparisonExpr</a> ( "and"  <a href="#prod-xquery10-ComparisonExpr">ComparisonExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-ComparisonExpr" id="prod-xquery10-ComparisonExpr"/>[50]   </td><td><code>ComparisonExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-FTContainsExpr">FTContainsExpr</a> ( (<a href="#prod-xquery10-ValueComp">ValueComp</a>
                  <br/>|  <a href="#prod-xquery10-GeneralComp">GeneralComp</a>
                  <br/>|  <a href="#prod-xquery10-NodeComp">NodeComp</a>)  <a href="#prod-xquery10-FTContainsExpr">FTContainsExpr</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTContainsExpr" id="prod-xquery10-FTContainsExpr"/>[51]   </td><td><code><a href="#doc-xquery10-FTContainsExpr"><a href="#doc-xquery10-FTContainsExpr">FTContainsExpr</a></a></code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-RangeExpr">RangeExpr</a> ( "contains"  "text"  <a href="#prod-xquery10-FTSelection">FTSelection</a>  
                  <a href="#prod-xquery10-FTIgnoreOption">FTIgnoreOption</a>? )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-RangeExpr" id="prod-xquery10-RangeExpr"/>[52]   </td><td><code>RangeExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-AdditiveExpr">AdditiveExpr</a> ( "to"  <a href="#prod-xquery10-AdditiveExpr">AdditiveExpr</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-AdditiveExpr" id="prod-xquery10-AdditiveExpr"/>[53]   </td><td><code>AdditiveExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-MultiplicativeExpr">MultiplicativeExpr</a> ( ("+"  |  "-")  <a href="#prod-xquery10-MultiplicativeExpr">MultiplicativeExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-MultiplicativeExpr" id="prod-xquery10-MultiplicativeExpr"/>[54]   </td><td><code>MultiplicativeExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-UnionExpr">UnionExpr</a> ( ("*"  |  "div"  |  "idiv"  |  "mod")  <a href="#prod-xquery10-UnionExpr">UnionExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-UnionExpr" id="prod-xquery10-UnionExpr"/>[55]   </td><td><code>UnionExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-IntersectExceptExpr">IntersectExceptExpr</a> ( ("union"  |  "|")  <a href="#prod-xquery10-IntersectExceptExpr">IntersectExceptExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-IntersectExceptExpr" id="prod-xquery10-IntersectExceptExpr"/>[56]   </td><td><code>IntersectExceptExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-InstanceofExpr">InstanceofExpr</a> ( ("intersect"  |  "except")  <a href="#prod-xquery10-InstanceofExpr">InstanceofExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-InstanceofExpr" id="prod-xquery10-InstanceofExpr"/>[57]   </td><td><code>InstanceofExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-TreatExpr">TreatExpr</a> ( "instance"  "of"  <a href="#prod-xquery10-SequenceType">SequenceType</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-TreatExpr" id="prod-xquery10-TreatExpr"/>[58]   </td><td><code>TreatExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-CastableExpr">CastableExpr</a> ( "treat"  "as"  <a href="#prod-xquery10-SequenceType">SequenceType</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-CastableExpr" id="prod-xquery10-CastableExpr"/>[59]   </td><td><code>CastableExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-CastExpr">CastExpr</a> ( "castable"  "as"  <a href="#prod-xquery10-SingleType">SingleType</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-CastExpr" id="prod-xquery10-CastExpr"/>[60]   </td><td><code>CastExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-UnaryExpr">UnaryExpr</a> ( "cast"  "as"  <a href="#prod-xquery10-SingleType">SingleType</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-UnaryExpr" id="prod-xquery10-UnaryExpr"/>[61]   </td><td><code>UnaryExpr</code></td><td>   ::=   </td><td><code>("-"  |  "+")* <a href="#prod-xquery10-ValueExpr">ValueExpr</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-ValueExpr" id="prod-xquery10-ValueExpr"/>[62]   </td><td><code>ValueExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-ValidateExpr">ValidateExpr</a>  |  <a href="#prod-xquery10-PathExpr">PathExpr</a>  |  <a href="#prod-xquery10-ExtensionExpr">ExtensionExpr</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-GeneralComp" id="prod-xquery10-GeneralComp"/>[63]   </td><td><code>GeneralComp</code></td><td>   ::=   </td><td><code>"="  |  "!="  |  "&lt;"  |  "&lt;="  |  "&gt;"  |  "&gt;="</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-ValueComp" id="prod-xquery10-ValueComp"/>[64]   </td><td><code>ValueComp</code></td><td>   ::=   </td><td><code>"eq"  |  "ne"  |  "lt"  |  "le"  |  "gt"  |  "ge"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-NodeComp" id="prod-xquery10-NodeComp"/>[65]   </td><td><code>NodeComp</code></td><td>   ::=   </td><td><code>"is"  |  "&lt;&lt;"  |  "&gt;&gt;"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-ValidateExpr" id="prod-xquery10-ValidateExpr"/>[66]   </td><td><code>ValidateExpr</code></td><td>   ::=   </td><td><code>"validate"  <a href="#prod-xquery10-ValidationMode">ValidationMode</a>?  "{"  <a href="#prod-xquery10-Expr">Expr</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-ValidationMode" id="prod-xquery10-ValidationMode"/>[67]   </td><td><code>ValidationMode</code></td><td>   ::=   </td><td><code>"lax"  |  "strict"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-ExtensionExpr" id="prod-xquery10-ExtensionExpr"/>[68]   </td><td><code>ExtensionExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-Pragma">Pragma</a>+  "{"  <a href="#prod-xquery10-Expr">Expr</a>?  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-Pragma" id="prod-xquery10-Pragma"/>[69]   </td><td><code><a href="#doc-xquery10-Pragma"><a href="#doc-xquery10-Pragma">Pragma</a></a></code></td><td>   ::=   </td><td><code>"(#"  <a href="#prod-xquery10-S">S</a>?  <a href="#prod-xquery10-QName">QName</a>  (<a href="#prod-xquery10-S">S</a>  
                  <a href="#prod-xquery10-PragmaContents">PragmaContents</a>)?  "#)"</code></td><td><i>/* 
                  <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                     <a href="http://www.w3.org/TR/xquery/#ws-explicit">ws: explicit</a><sup><small>XQ</small></sup>
                  </span>
                */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-PragmaContents" id="prod-xquery10-PragmaContents"/>[70]   </td><td><code><a href="#doc-xquery10-PragmaContents"><a href="#doc-xquery10-PragmaContents">PragmaContents</a></a></code></td><td>   ::=   </td><td><code>(<a href="#prod-xquery10-Char">Char</a>* - (Char* '#)' Char*))</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-PathExpr" id="prod-xquery10-PathExpr"/>[71]   </td><td><code>PathExpr</code></td><td>   ::=   </td><td><code>("/"  <a href="#prod-xquery10-RelativePathExpr">RelativePathExpr</a>?)<br/>|  ("//"  <a href="#prod-xquery10-RelativePathExpr">RelativePathExpr</a>)<br/>|  <a href="#prod-xquery10-RelativePathExpr">RelativePathExpr</a>
               </code></td><td><i>/* 
                  <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                     <a href="http://www.w3.org/TR/xquery/#parse-note-leading-lone-slash">xgc: leading-lone-slash</a><sup><small>XQ</small></sup>
                  </span>
                */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-RelativePathExpr" id="prod-xquery10-RelativePathExpr"/>[72]   </td><td><code>RelativePathExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-StepExpr">StepExpr</a>  (("/"  |  "//")  <a href="#prod-xquery10-StepExpr">StepExpr</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-StepExpr" id="prod-xquery10-StepExpr"/>[73]   </td><td><code>StepExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-FilterExpr">FilterExpr</a>  |  <a href="#prod-xquery10-AxisStep">AxisStep</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-AxisStep" id="prod-xquery10-AxisStep"/>[74]   </td><td><code>AxisStep</code></td><td>   ::=   </td><td><code>(<a href="#prod-xquery10-ReverseStep">ReverseStep</a>  |  <a href="#prod-xquery10-ForwardStep">ForwardStep</a>)  <a href="#prod-xquery10-PredicateList">PredicateList</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-ForwardStep" id="prod-xquery10-ForwardStep"/>[75]   </td><td><code>ForwardStep</code></td><td>   ::=   </td><td><code>(<a href="#prod-xquery10-ForwardAxis">ForwardAxis</a>  
                  <a href="#prod-xquery10-NodeTest">NodeTest</a>)  |  <a href="#prod-xquery10-AbbrevForwardStep">AbbrevForwardStep</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-ForwardAxis" id="prod-xquery10-ForwardAxis"/>[76]   </td><td><code>ForwardAxis</code></td><td>   ::=   </td><td><code>("child"  "::")<br/>|  ("descendant"  "::")<br/>|  ("attribute"  "::")<br/>|  ("self"  "::")<br/>|  ("descendant-or-self"  "::")<br/>|  ("following-sibling"  "::")<br/>|  ("following"  "::")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-AbbrevForwardStep" id="prod-xquery10-AbbrevForwardStep"/>[77]   </td><td><code>AbbrevForwardStep</code></td><td>   ::=   </td><td><code>"@"?  <a href="#prod-xquery10-NodeTest">NodeTest</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-ReverseStep" id="prod-xquery10-ReverseStep"/>[78]   </td><td><code>ReverseStep</code></td><td>   ::=   </td><td><code>(<a href="#prod-xquery10-ReverseAxis">ReverseAxis</a>  
                  <a href="#prod-xquery10-NodeTest">NodeTest</a>)  |  <a href="#prod-xquery10-AbbrevReverseStep">AbbrevReverseStep</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-ReverseAxis" id="prod-xquery10-ReverseAxis"/>[79]   </td><td><code>ReverseAxis</code></td><td>   ::=   </td><td><code>("parent"  "::")<br/>|  ("ancestor"  "::")<br/>|  ("preceding-sibling"  "::")<br/>|  ("preceding"  "::")<br/>|  ("ancestor-or-self"  "::")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-AbbrevReverseStep" id="prod-xquery10-AbbrevReverseStep"/>[80]   </td><td><code>AbbrevReverseStep</code></td><td>   ::=   </td><td><code>".."</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-NodeTest" id="prod-xquery10-NodeTest"/>[81]   </td><td><code>NodeTest</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-KindTest">KindTest</a>  |  <a href="#prod-xquery10-NameTest">NameTest</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-NameTest" id="prod-xquery10-NameTest"/>[82]   </td><td><code>NameTest</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-QName">QName</a>  |  <a href="#prod-xquery10-Wildcard">Wildcard</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-Wildcard" id="prod-xquery10-Wildcard"/>[83]   </td><td><code>Wildcard</code></td><td>   ::=   </td><td><code>"*"<br/>|  (<a href="#prod-xquery10-NCName">NCName</a>  ":"  "*")<br/>|  ("*"  ":"  <a href="#prod-xquery10-NCName">NCName</a>)</code></td><td><i>/* 
                  <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                     <a href="http://www.w3.org/TR/xquery/#ws-explicit">ws: explicit</a><sup><small>XQ</small></sup>
                  </span>
                */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FilterExpr" id="prod-xquery10-FilterExpr"/>[84]   </td><td><code>FilterExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-PrimaryExpr">PrimaryExpr</a>  
                  <a href="#prod-xquery10-PredicateList">PredicateList</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-PredicateList" id="prod-xquery10-PredicateList"/>[85]   </td><td><code>PredicateList</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-Predicate">Predicate</a>*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-Predicate" id="prod-xquery10-Predicate"/>[86]   </td><td><code>Predicate</code></td><td>   ::=   </td><td><code>"["  <a href="#prod-xquery10-Expr">Expr</a>  "]"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-PrimaryExpr" id="prod-xquery10-PrimaryExpr"/>[87]   </td><td><code>PrimaryExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-Literal">Literal</a>
                  <br/>|  <a href="#prod-xquery10-VarRef">VarRef</a>
                  <br/>|  <a href="#prod-xquery10-ParenthesizedExpr">ParenthesizedExpr</a>
                  <br/>|  <a href="#prod-xquery10-ContextItemExpr">ContextItemExpr</a>
                  <br/>|  <a href="#prod-xquery10-FunctionCall">FunctionCall</a>
                  <br/>|  <a href="#prod-xquery10-OrderedExpr">OrderedExpr</a>
                  <br/>|  <a href="#prod-xquery10-UnorderedExpr">UnorderedExpr</a>
                  <br/>|  <a href="#prod-xquery10-Constructor">Constructor</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-Literal" id="prod-xquery10-Literal"/>[88]   </td><td><code>Literal</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-NumericLiteral">NumericLiteral</a>  |  <a href="#prod-xquery10-StringLiteral">StringLiteral</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-NumericLiteral" id="prod-xquery10-NumericLiteral"/>[89]   </td><td><code>NumericLiteral</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-IntegerLiteral">IntegerLiteral</a>  |  <a href="#prod-xquery10-DecimalLiteral">DecimalLiteral</a>  |  <a href="#prod-xquery10-DoubleLiteral">DoubleLiteral</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-VarRef" id="prod-xquery10-VarRef"/>[90]   </td><td><code>VarRef</code></td><td>   ::=   </td><td><code>"$"  <a href="#prod-xquery10-VarName">VarName</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-VarName" id="prod-xquery10-VarName"/>[91]   </td><td><code>VarName</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-QName">QName</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-ParenthesizedExpr" id="prod-xquery10-ParenthesizedExpr"/>[92]   </td><td><code>ParenthesizedExpr</code></td><td>   ::=   </td><td><code>"("  <a href="#prod-xquery10-Expr">Expr</a>?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-ContextItemExpr" id="prod-xquery10-ContextItemExpr"/>[93]   </td><td><code>ContextItemExpr</code></td><td>   ::=   </td><td><code>"."</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-OrderedExpr" id="prod-xquery10-OrderedExpr"/>[94]   </td><td><code>OrderedExpr</code></td><td>   ::=   </td><td><code>"ordered"  "{"  <a href="#prod-xquery10-Expr">Expr</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-UnorderedExpr" id="prod-xquery10-UnorderedExpr"/>[95]   </td><td><code>UnorderedExpr</code></td><td>   ::=   </td><td><code>"unordered"  "{"  <a href="#prod-xquery10-Expr">Expr</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FunctionCall" id="prod-xquery10-FunctionCall"/>[96]   </td><td><code>FunctionCall</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-QName">QName</a>  "("  (<a href="#prod-xquery10-ExprSingle">ExprSingle</a>  (","  <a href="#prod-xquery10-ExprSingle">ExprSingle</a>)*)?  ")"</code></td><td><i>/* 
                  <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                     <a href="http://www.w3.org/TR/xquery/#parse-note-reserved-function-names">xgc: reserved-function-names</a><sup><small>XQ</small></sup>
                  </span>
                */</i></td></tr><tr valign="baseline"><td/><td/><td/><td/><td><i>/* 
                  <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                     <a href="http://www.w3.org/TR/xquery/#parse-note-parens">gn: parens</a><sup><small>XQ</small></sup>
                  </span>
                */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-Constructor" id="prod-xquery10-Constructor"/>[97]   </td><td><code>Constructor</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-DirectConstructor">DirectConstructor</a>
                  <br/>|  <a href="#prod-xquery10-ComputedConstructor">ComputedConstructor</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-DirectConstructor" id="prod-xquery10-DirectConstructor"/>[98]   </td><td><code>DirectConstructor</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-DirElemConstructor">DirElemConstructor</a>
                  <br/>|  <a href="#prod-xquery10-DirCommentConstructor">DirCommentConstructor</a>
                  <br/>|  <a href="#prod-xquery10-DirPIConstructor">DirPIConstructor</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-DirElemConstructor" id="prod-xquery10-DirElemConstructor"/>[99]   </td><td><code>DirElemConstructor</code></td><td>   ::=   </td><td><code>"&lt;"  <a href="#prod-xquery10-QName">QName</a>  
                  <a href="#prod-xquery10-DirAttributeList">DirAttributeList</a>  ("/&gt;"  |  ("&gt;"  <a href="#prod-xquery10-DirElemContent">DirElemContent</a>*  "&lt;/"  <a href="#prod-xquery10-QName">QName</a>  
                  <a href="#prod-xquery10-S">S</a>?  "&gt;"))</code></td><td><i>/* 
                  <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                     <a href="http://www.w3.org/TR/xquery/#ws-explicit">ws: explicit</a><sup><small>XQ</small></sup>
                  </span>
                */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-DirAttributeList" id="prod-xquery10-DirAttributeList"/>[100]   </td><td><code>DirAttributeList</code></td><td>   ::=   </td><td><code>(<a href="#prod-xquery10-S">S</a>  (<a href="#prod-xquery10-QName">QName</a>  
                  <a href="#prod-xquery10-S">S</a>?  "="  <a href="#prod-xquery10-S">S</a>?  <a href="#prod-xquery10-DirAttributeValue">DirAttributeValue</a>)?)*</code></td><td><i>/* 
                  <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                     <a href="http://www.w3.org/TR/xquery/#ws-explicit">ws: explicit</a><sup><small>XQ</small></sup>
                  </span>
                */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-DirAttributeValue" id="prod-xquery10-DirAttributeValue"/>[101]   </td><td><code>DirAttributeValue</code></td><td>   ::=   </td><td><code>('"'  (<a href="#prod-xquery10-EscapeQuot">EscapeQuot</a>  |  <a href="#prod-xquery10-QuotAttrValueContent">QuotAttrValueContent</a>)*  '"')<br/>|  ("'"  (<a href="#prod-xquery10-EscapeApos">EscapeApos</a>  |  <a href="#prod-xquery10-AposAttrValueContent">AposAttrValueContent</a>)*  "'")</code></td><td><i>/* 
                  <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                     <a href="http://www.w3.org/TR/xquery/#ws-explicit">ws: explicit</a><sup><small>XQ</small></sup>
                  </span>
                */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-QuotAttrValueContent" id="prod-xquery10-QuotAttrValueContent"/>[102]   </td><td><code>QuotAttrValueContent</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-QuotAttrContentChar">QuotAttrContentChar</a>
                  <br/>|  <a href="#prod-xquery10-CommonContent">CommonContent</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-AposAttrValueContent" id="prod-xquery10-AposAttrValueContent"/>[103]   </td><td><code>AposAttrValueContent</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-AposAttrContentChar">AposAttrContentChar</a>
                  <br/>|  <a href="#prod-xquery10-CommonContent">CommonContent</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-DirElemContent" id="prod-xquery10-DirElemContent"/>[104]   </td><td><code>DirElemContent</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-DirectConstructor">DirectConstructor</a>
                  <br/>|  <a href="#prod-xquery10-CDataSection">CDataSection</a>
                  <br/>|  <a href="#prod-xquery10-CommonContent">CommonContent</a>
                  <br/>|  <a href="#prod-xquery10-ElementContentChar">ElementContentChar</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-CommonContent" id="prod-xquery10-CommonContent"/>[105]   </td><td><code>CommonContent</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-PredefinedEntityRef">PredefinedEntityRef</a>  |  <a href="#prod-xquery10-CharRef">CharRef</a>  |  "{{"  |  "}}"  |  <a href="#prod-xquery10-EnclosedExpr">EnclosedExpr</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-DirCommentConstructor" id="prod-xquery10-DirCommentConstructor"/>[106]   </td><td><code>DirCommentConstructor</code></td><td>   ::=   </td><td><code>"&lt;!--"  <a href="#prod-xquery10-DirCommentContents">DirCommentContents</a>  "--&gt;"</code></td><td><i>/* 
                  <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                     <a href="http://www.w3.org/TR/xquery/#ws-explicit">ws: explicit</a><sup><small>XQ</small></sup>
                  </span>
                */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-DirCommentContents" id="prod-xquery10-DirCommentContents"/>[107]   </td><td><code>DirCommentContents</code></td><td>   ::=   </td><td><code>((<a href="#prod-xquery10-Char">Char</a> - '-')  |  ('-'  (<a href="#prod-xquery10-Char">Char</a> - '-')))*</code></td><td><i>/* 
                  <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                     <a href="http://www.w3.org/TR/xquery/#ws-explicit">ws: explicit</a><sup><small>XQ</small></sup>
                  </span>
                */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-DirPIConstructor" id="prod-xquery10-DirPIConstructor"/>[108]   </td><td><code>DirPIConstructor</code></td><td>   ::=   </td><td><code>"&lt;?"  <a href="#prod-xquery10-PITarget">PITarget</a>  (<a href="#prod-xquery10-S">S</a>  
                  <a href="#prod-xquery10-DirPIContents">DirPIContents</a>)?  "?&gt;"</code></td><td><i>/* 
                  <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                     <a href="http://www.w3.org/TR/xquery/#ws-explicit">ws: explicit</a><sup><small>XQ</small></sup>
                  </span>
                */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-DirPIContents" id="prod-xquery10-DirPIContents"/>[109]   </td><td><code>DirPIContents</code></td><td>   ::=   </td><td><code>(<a href="#prod-xquery10-Char">Char</a>* - (Char* '?&gt;' Char*))</code></td><td><i>/* 
                  <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                     <a href="http://www.w3.org/TR/xquery/#ws-explicit">ws: explicit</a><sup><small>XQ</small></sup>
                  </span>
                */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-CDataSection" id="prod-xquery10-CDataSection"/>[110]   </td><td><code>CDataSection</code></td><td>   ::=   </td><td><code>"&lt;![CDATA["  <a href="#prod-xquery10-CDataSectionContents">CDataSectionContents</a>  "]]&gt;"</code></td><td><i>/* 
                  <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                     <a href="http://www.w3.org/TR/xquery/#ws-explicit">ws: explicit</a><sup><small>XQ</small></sup>
                  </span>
                */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-CDataSectionContents" id="prod-xquery10-CDataSectionContents"/>[111]   </td><td><code>CDataSectionContents</code></td><td>   ::=   </td><td><code>(<a href="#prod-xquery10-Char">Char</a>* - (Char* ']]&gt;' Char*))</code></td><td><i>/* 
                  <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                     <a href="http://www.w3.org/TR/xquery/#ws-explicit">ws: explicit</a><sup><small>XQ</small></sup>
                  </span>
                */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-ComputedConstructor" id="prod-xquery10-ComputedConstructor"/>[112]   </td><td><code>ComputedConstructor</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-CompDocConstructor">CompDocConstructor</a>
                  <br/>|  <a href="#prod-xquery10-CompElemConstructor">CompElemConstructor</a>
                  <br/>|  <a href="#prod-xquery10-CompAttrConstructor">CompAttrConstructor</a>
                  <br/>|  <a href="#prod-xquery10-CompTextConstructor">CompTextConstructor</a>
                  <br/>|  <a href="#prod-xquery10-CompCommentConstructor">CompCommentConstructor</a>
                  <br/>|  <a href="#prod-xquery10-CompPIConstructor">CompPIConstructor</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-CompDocConstructor" id="prod-xquery10-CompDocConstructor"/>[113]   </td><td><code>CompDocConstructor</code></td><td>   ::=   </td><td><code>"document"  "{"  <a href="#prod-xquery10-Expr">Expr</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-CompElemConstructor" id="prod-xquery10-CompElemConstructor"/>[114]   </td><td><code>CompElemConstructor</code></td><td>   ::=   </td><td><code>"element"  (<a href="#prod-xquery10-QName">QName</a>  |  ("{"  <a href="#prod-xquery10-Expr">Expr</a>  "}"))  "{"  <a href="#prod-xquery10-ContentExpr">ContentExpr</a>?  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-ContentExpr" id="prod-xquery10-ContentExpr"/>[115]   </td><td><code>ContentExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-Expr">Expr</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-CompAttrConstructor" id="prod-xquery10-CompAttrConstructor"/>[116]   </td><td><code>CompAttrConstructor</code></td><td>   ::=   </td><td><code>"attribute"  (<a href="#prod-xquery10-QName">QName</a>  |  ("{"  <a href="#prod-xquery10-Expr">Expr</a>  "}"))  "{"  <a href="#prod-xquery10-Expr">Expr</a>?  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-CompTextConstructor" id="prod-xquery10-CompTextConstructor"/>[117]   </td><td><code>CompTextConstructor</code></td><td>   ::=   </td><td><code>"text"  "{"  <a href="#prod-xquery10-Expr">Expr</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-CompCommentConstructor" id="prod-xquery10-CompCommentConstructor"/>[118]   </td><td><code>CompCommentConstructor</code></td><td>   ::=   </td><td><code>"comment"  "{"  <a href="#prod-xquery10-Expr">Expr</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-CompPIConstructor" id="prod-xquery10-CompPIConstructor"/>[119]   </td><td><code>CompPIConstructor</code></td><td>   ::=   </td><td><code>"processing-instruction"  (<a href="#prod-xquery10-NCName">NCName</a>  |  ("{"  <a href="#prod-xquery10-Expr">Expr</a>  "}"))  "{"  <a href="#prod-xquery10-Expr">Expr</a>?  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-SingleType" id="prod-xquery10-SingleType"/>[120]   </td><td><code>SingleType</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-AtomicType">AtomicType</a>  "?"?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-TypeDeclaration" id="prod-xquery10-TypeDeclaration"/>[121]   </td><td><code>TypeDeclaration</code></td><td>   ::=   </td><td><code>"as"  <a href="#prod-xquery10-SequenceType">SequenceType</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-SequenceType" id="prod-xquery10-SequenceType"/>[122]   </td><td><code>SequenceType</code></td><td>   ::=   </td><td><code>("empty-sequence"  "("  ")")<br/>|  (<a href="#prod-xquery10-ItemType">ItemType</a>  
                  <a href="#prod-xquery10-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-OccurrenceIndicator" id="prod-xquery10-OccurrenceIndicator"/>[123]   </td><td><code>OccurrenceIndicator</code></td><td>   ::=   </td><td><code>"?"  |  "*"  |  "+"</code></td><td><i>/* 
                  <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                     <a href="http://www.w3.org/TR/xquery/#parse-note-occurrence-indicators">xgc: occurrence-indicators</a><sup><small>XQ</small></sup>
                  </span>
                */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-ItemType" id="prod-xquery10-ItemType"/>[124]   </td><td><code>ItemType</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-KindTest">KindTest</a>  |  ("item"  "("  ")")  |  <a href="#prod-xquery10-AtomicType">AtomicType</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-AtomicType" id="prod-xquery10-AtomicType"/>[125]   </td><td><code>AtomicType</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-QName">QName</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-KindTest" id="prod-xquery10-KindTest"/>[126]   </td><td><code>KindTest</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-DocumentTest">DocumentTest</a>
                  <br/>|  <a href="#prod-xquery10-ElementTest">ElementTest</a>
                  <br/>|  <a href="#prod-xquery10-AttributeTest">AttributeTest</a>
                  <br/>|  <a href="#prod-xquery10-SchemaElementTest">SchemaElementTest</a>
                  <br/>|  <a href="#prod-xquery10-SchemaAttributeTest">SchemaAttributeTest</a>
                  <br/>|  <a href="#prod-xquery10-PITest">PITest</a>
                  <br/>|  <a href="#prod-xquery10-CommentTest">CommentTest</a>
                  <br/>|  <a href="#prod-xquery10-TextTest">TextTest</a>
                  <br/>|  <a href="#prod-xquery10-AnyKindTest">AnyKindTest</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-AnyKindTest" id="prod-xquery10-AnyKindTest"/>[127]   </td><td><code>AnyKindTest</code></td><td>   ::=   </td><td><code>"node"  "("  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-DocumentTest" id="prod-xquery10-DocumentTest"/>[128]   </td><td><code>DocumentTest</code></td><td>   ::=   </td><td><code>"document-node"  "("  (<a href="#prod-xquery10-ElementTest">ElementTest</a>  |  <a href="#prod-xquery10-SchemaElementTest">SchemaElementTest</a>)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-TextTest" id="prod-xquery10-TextTest"/>[129]   </td><td><code>TextTest</code></td><td>   ::=   </td><td><code>"text"  "("  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-CommentTest" id="prod-xquery10-CommentTest"/>[130]   </td><td><code>CommentTest</code></td><td>   ::=   </td><td><code>"comment"  "("  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-PITest" id="prod-xquery10-PITest"/>[131]   </td><td><code>PITest</code></td><td>   ::=   </td><td><code>"processing-instruction"  "("  (<a href="#prod-xquery10-NCName">NCName</a>  |  <a href="#prod-xquery10-StringLiteral">StringLiteral</a>)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-AttributeTest" id="prod-xquery10-AttributeTest"/>[132]   </td><td><code>AttributeTest</code></td><td>   ::=   </td><td><code>"attribute"  "("  (<a href="#prod-xquery10-AttribNameOrWildcard">AttribNameOrWildcard</a>  (","  <a href="#prod-xquery10-TypeName">TypeName</a>)?)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-AttribNameOrWildcard" id="prod-xquery10-AttribNameOrWildcard"/>[133]   </td><td><code>AttribNameOrWildcard</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-AttributeName">AttributeName</a>  |  "*"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-SchemaAttributeTest" id="prod-xquery10-SchemaAttributeTest"/>[134]   </td><td><code>SchemaAttributeTest</code></td><td>   ::=   </td><td><code>"schema-attribute"  "("  <a href="#prod-xquery10-AttributeDeclaration">AttributeDeclaration</a>  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-AttributeDeclaration" id="prod-xquery10-AttributeDeclaration"/>[135]   </td><td><code>AttributeDeclaration</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-AttributeName">AttributeName</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-ElementTest" id="prod-xquery10-ElementTest"/>[136]   </td><td><code>ElementTest</code></td><td>   ::=   </td><td><code>"element"  "("  (<a href="#prod-xquery10-ElementNameOrWildcard">ElementNameOrWildcard</a>  (","  <a href="#prod-xquery10-TypeName">TypeName</a>  "?"?)?)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-ElementNameOrWildcard" id="prod-xquery10-ElementNameOrWildcard"/>[137]   </td><td><code>ElementNameOrWildcard</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-ElementName">ElementName</a>  |  "*"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-SchemaElementTest" id="prod-xquery10-SchemaElementTest"/>[138]   </td><td><code>SchemaElementTest</code></td><td>   ::=   </td><td><code>"schema-element"  "("  <a href="#prod-xquery10-ElementDeclaration">ElementDeclaration</a>  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-ElementDeclaration" id="prod-xquery10-ElementDeclaration"/>[139]   </td><td><code>ElementDeclaration</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-ElementName">ElementName</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-AttributeName" id="prod-xquery10-AttributeName"/>[140]   </td><td><code>AttributeName</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-QName">QName</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-ElementName" id="prod-xquery10-ElementName"/>[141]   </td><td><code>ElementName</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-QName">QName</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-TypeName" id="prod-xquery10-TypeName"/>[142]   </td><td><code>TypeName</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-QName">QName</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-URILiteral" id="prod-xquery10-URILiteral"/>[143]   </td><td><code><a href="#doc-xquery10-URILiteral"><a href="#doc-xquery10-URILiteral">URILiteral</a></a></code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-StringLiteral">StringLiteral</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTSelection" id="prod-xquery10-FTSelection"/>[144]   </td><td><code><a href="#doc-xquery10-FTSelection"><a href="#doc-xquery10-FTSelection">FTSelection</a></a></code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-FTOr">FTOr</a>  
                  <a href="#prod-xquery10-FTPosFilter">FTPosFilter</a>*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTWeight" id="prod-xquery10-FTWeight"/>[145]   </td><td><code><a href="#doc-xquery10-FTWeight"><a href="#doc-xquery10-FTWeight">FTWeight</a></a></code></td><td>   ::=   </td><td><code>"weight"  "{"  <a href="#prod-xquery10-Expr">Expr</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTOr" id="prod-xquery10-FTOr"/>[146]   </td><td><code><a href="#doc-xquery10-FTOr"><a href="#doc-xquery10-FTOr">FTOr</a></a></code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-FTAnd">FTAnd</a> ( "ftor"  <a href="#prod-xquery10-FTAnd">FTAnd</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTAnd" id="prod-xquery10-FTAnd"/>[147]   </td><td><code><a href="#doc-xquery10-FTAnd"><a href="#doc-xquery10-FTAnd">FTAnd</a></a></code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-FTMildNot">FTMildNot</a> ( "ftand"  <a href="#prod-xquery10-FTMildNot">FTMildNot</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTMildNot" id="prod-xquery10-FTMildNot"/>[148]   </td><td><code><a href="#doc-xquery10-FTMildNot"><a href="#doc-xquery10-FTMildNot">FTMildNot</a></a></code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-FTUnaryNot">FTUnaryNot</a> ( "not"  "in"  <a href="#prod-xquery10-FTUnaryNot">FTUnaryNot</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTUnaryNot" id="prod-xquery10-FTUnaryNot"/>[149]   </td><td><code><a href="#doc-xquery10-FTUnaryNot"><a href="#doc-xquery10-FTUnaryNot">FTUnaryNot</a></a></code></td><td>   ::=   </td><td><code>("ftnot")? <a href="#prod-xquery10-FTPrimaryWithOptions">FTPrimaryWithOptions</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTPrimaryWithOptions" id="prod-xquery10-FTPrimaryWithOptions"/>[150]   </td><td><code><a href="#doc-xquery10-FTPrimaryWithOptions"><a href="#doc-xquery10-FTPrimaryWithOptions">FTPrimaryWithOptions</a></a></code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-FTPrimary">FTPrimary</a>  
                  <a href="#prod-xquery10-FTMatchOptions">FTMatchOptions</a>?  <a href="#prod-xquery10-FTWeight">FTWeight</a>?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTPrimary" id="prod-xquery10-FTPrimary"/>[151]   </td><td><code><a href="#doc-xquery10-FTPrimary"><a href="#doc-xquery10-FTPrimary">FTPrimary</a></a></code></td><td>   ::=   </td><td><code>(<a href="#prod-xquery10-FTWords">FTWords</a>  
                  <a href="#prod-xquery10-FTTimes">FTTimes</a>?)  |  ("("  <a href="#prod-xquery10-FTSelection">FTSelection</a>  ")")  |  <a href="#prod-xquery10-FTExtensionSelection">FTExtensionSelection</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTWords" id="prod-xquery10-FTWords"/>[152]   </td><td><code><a href="#doc-xquery10-FTWords"><a href="#doc-xquery10-FTWords">FTWords</a></a></code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-FTWordsValue">FTWordsValue</a>  
                  <a href="#prod-xquery10-FTAnyallOption">FTAnyallOption</a>?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTWordsValue" id="prod-xquery10-FTWordsValue"/>[153]   </td><td><code><a href="#doc-xquery10-FTWordsValue"><a href="#doc-xquery10-FTWordsValue">FTWordsValue</a></a></code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-StringLiteral">StringLiteral</a>  |  ("{"  <a href="#prod-xquery10-Expr">Expr</a>  "}")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTExtensionSelection" id="prod-xquery10-FTExtensionSelection"/>[154]   </td><td><code><a href="#doc-xquery10-FTExtensionSelection"><a href="#doc-xquery10-FTExtensionSelection">FTExtensionSelection</a></a></code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-Pragma">Pragma</a>+  "{"  <a href="#prod-xquery10-FTSelection">FTSelection</a>?  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTAnyallOption" id="prod-xquery10-FTAnyallOption"/>[155]   </td><td><code><a href="#doc-xquery10-FTAnyallOption"><a href="#doc-xquery10-FTAnyallOption">FTAnyallOption</a></a></code></td><td>   ::=   </td><td><code>("any"  "word"?)  |  ("all"  "words"?)  |  "phrase"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTTimes" id="prod-xquery10-FTTimes"/>[156]   </td><td><code><a href="#doc-xquery10-FTTimes"><a href="#doc-xquery10-FTTimes">FTTimes</a></a></code></td><td>   ::=   </td><td><code>"occurs"  <a href="#prod-xquery10-FTRange">FTRange</a>  "times"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTRange" id="prod-xquery10-FTRange"/>[157]   </td><td><code><a href="#doc-xquery10-FTRange"><a href="#doc-xquery10-FTRange">FTRange</a></a></code></td><td>   ::=   </td><td><code>("exactly"  <a href="#prod-xquery10-AdditiveExpr">AdditiveExpr</a>)<br/>|  ("at"  "least"  <a href="#prod-xquery10-AdditiveExpr">AdditiveExpr</a>)<br/>|  ("at"  "most"  <a href="#prod-xquery10-AdditiveExpr">AdditiveExpr</a>)<br/>|  ("from"  <a href="#prod-xquery10-AdditiveExpr">AdditiveExpr</a>  "to"  <a href="#prod-xquery10-AdditiveExpr">AdditiveExpr</a>)</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTPosFilter" id="prod-xquery10-FTPosFilter"/>[158]   </td><td><code><a href="#doc-xquery10-FTPosFilter"><a href="#doc-xquery10-FTPosFilter">FTPosFilter</a></a></code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-FTOrder">FTOrder</a>  |  <a href="#prod-xquery10-FTWindow">FTWindow</a>  |  <a href="#prod-xquery10-FTDistance">FTDistance</a>  |  <a href="#prod-xquery10-FTScope">FTScope</a>  |  <a href="#prod-xquery10-FTContent">FTContent</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTOrder" id="prod-xquery10-FTOrder"/>[159]   </td><td><code><a href="#doc-xquery10-FTOrder"><a href="#doc-xquery10-FTOrder">FTOrder</a></a></code></td><td>   ::=   </td><td><code>"ordered"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTWindow" id="prod-xquery10-FTWindow"/>[160]   </td><td><code><a href="#doc-xquery10-FTWindow"><a href="#doc-xquery10-FTWindow">FTWindow</a></a></code></td><td>   ::=   </td><td><code>"window"  <a href="#prod-xquery10-AdditiveExpr">AdditiveExpr</a>  
                  <a href="#prod-xquery10-FTUnit">FTUnit</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTDistance" id="prod-xquery10-FTDistance"/>[161]   </td><td><code><a href="#doc-xquery10-FTDistance"><a href="#doc-xquery10-FTDistance">FTDistance</a></a></code></td><td>   ::=   </td><td><code>"distance"  <a href="#prod-xquery10-FTRange">FTRange</a>  
                  <a href="#prod-xquery10-FTUnit">FTUnit</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTUnit" id="prod-xquery10-FTUnit"/>[162]   </td><td><code><a href="#doc-xquery10-FTUnit"><a href="#doc-xquery10-FTUnit">FTUnit</a></a></code></td><td>   ::=   </td><td><code>"words"  |  "sentences"  |  "paragraphs"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTScope" id="prod-xquery10-FTScope"/>[163]   </td><td><code><a href="#doc-xquery10-FTScope"><a href="#doc-xquery10-FTScope">FTScope</a></a></code></td><td>   ::=   </td><td><code>("same"  |  "different")  <a href="#prod-xquery10-FTBigUnit">FTBigUnit</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTBigUnit" id="prod-xquery10-FTBigUnit"/>[164]   </td><td><code><a href="#doc-xquery10-FTBigUnit"><a href="#doc-xquery10-FTBigUnit">FTBigUnit</a></a></code></td><td>   ::=   </td><td><code>"sentence"  |  "paragraph"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTContent" id="prod-xquery10-FTContent"/>[165]   </td><td><code><a href="#doc-xquery10-FTContent"><a href="#doc-xquery10-FTContent">FTContent</a></a></code></td><td>   ::=   </td><td><code>("at"  "start")  |  ("at"  "end")  |  ("entire"  "content")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTMatchOptions" id="prod-xquery10-FTMatchOptions"/>[166]   </td><td><code><a href="#doc-xquery10-FTMatchOptions"><a href="#doc-xquery10-FTMatchOptions">FTMatchOptions</a></a></code></td><td>   ::=   </td><td><code>("using"  <a href="#prod-xquery10-FTMatchOption">FTMatchOption</a>)+</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTMatchOption" id="prod-xquery10-FTMatchOption"/>[167]   </td><td><code><a href="#doc-xquery10-FTMatchOption"><a href="#doc-xquery10-FTMatchOption">FTMatchOption</a></a></code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xquery10-FTLanguageOption">FTLanguageOption</a>
                  <br/>|  <a href="#prod-xquery10-FTWildCardOption">FTWildCardOption</a>
                  <br/>|  <a href="#prod-xquery10-FTThesaurusOption">FTThesaurusOption</a>
                  <br/>|  <a href="#prod-xquery10-FTStemOption">FTStemOption</a>
                  <br/>|  <a href="#prod-xquery10-FTCaseOption">FTCaseOption</a>
                  <br/>|  <a href="#prod-xquery10-FTDiacriticsOption">FTDiacriticsOption</a>
                  <br/>|  <a href="#prod-xquery10-FTStopWordOption">FTStopWordOption</a>
                  <br/>|  <a href="#prod-xquery10-FTExtensionOption">FTExtensionOption</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTCaseOption" id="prod-xquery10-FTCaseOption"/>[168]   </td><td><code><a href="#doc-xquery10-FTCaseOption"><a href="#doc-xquery10-FTCaseOption">FTCaseOption</a></a></code></td><td>   ::=   </td><td><code>("case"  "insensitive")<br/>|  ("case"  "sensitive")<br/>|  "lowercase"<br/>|  "uppercase"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTDiacriticsOption" id="prod-xquery10-FTDiacriticsOption"/>[169]   </td><td><code><a href="#doc-xquery10-FTDiacriticsOption"><a href="#doc-xquery10-FTDiacriticsOption">FTDiacriticsOption</a></a></code></td><td>   ::=   </td><td><code>("diacritics"  "insensitive")<br/>|  ("diacritics"  "sensitive")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTStemOption" id="prod-xquery10-FTStemOption"/>[170]   </td><td><code><a href="#doc-xquery10-FTStemOption"><a href="#doc-xquery10-FTStemOption">FTStemOption</a></a></code></td><td>   ::=   </td><td><code>"stemming"  |  ("no"  "stemming")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTThesaurusOption" id="prod-xquery10-FTThesaurusOption"/>[171]   </td><td><code><a href="#doc-xquery10-FTThesaurusOption"><a href="#doc-xquery10-FTThesaurusOption">FTThesaurusOption</a></a></code></td><td>   ::=   </td><td><code>("thesaurus"  (<a href="#prod-xquery10-FTThesaurusID">FTThesaurusID</a>  |  "default"))<br/>|  ("thesaurus"  "("  (<a href="#prod-xquery10-FTThesaurusID">FTThesaurusID</a>  |  "default")  (","  <a href="#prod-xquery10-FTThesaurusID">FTThesaurusID</a>)*  ")")<br/>|  ("no"  "thesaurus")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTThesaurusID" id="prod-xquery10-FTThesaurusID"/>[172]   </td><td><code><a href="#doc-xquery10-FTThesaurusID"><a href="#doc-xquery10-FTThesaurusID">FTThesaurusID</a></a></code></td><td>   ::=   </td><td><code>"at"  <a href="#prod-xquery10-URILiteral">URILiteral</a>  ("relationship"  <a href="#prod-xquery10-StringLiteral">StringLiteral</a>)?  (<a href="#prod-xquery10-FTLiteralRange">FTLiteralRange</a>  "levels")?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTLiteralRange" id="prod-xquery10-FTLiteralRange"/>[173]   </td><td><code><a href="#doc-xquery10-FTLiteralRange"><a href="#doc-xquery10-FTLiteralRange">FTLiteralRange</a></a></code></td><td>   ::=   </td><td><code>("exactly"  <a href="#prod-xquery10-IntegerLiteral">IntegerLiteral</a>)<br/>|  ("at"  "least"  <a href="#prod-xquery10-IntegerLiteral">IntegerLiteral</a>)<br/>|  ("at"  "most"  <a href="#prod-xquery10-IntegerLiteral">IntegerLiteral</a>)<br/>|  ("from"  <a href="#prod-xquery10-IntegerLiteral">IntegerLiteral</a>  "to"  <a href="#prod-xquery10-IntegerLiteral">IntegerLiteral</a>)</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTStopWordOption" id="prod-xquery10-FTStopWordOption"/>[174]   </td><td><code><a href="#doc-xquery10-FTStopWordOption"><a href="#doc-xquery10-FTStopWordOption">FTStopWordOption</a></a></code></td><td>   ::=   </td><td><code>("stop"  "words"  <a href="#prod-xquery10-FTStopWords">FTStopWords</a>  
                  <a href="#prod-xquery10-FTStopWordsInclExcl">FTStopWordsInclExcl</a>*)<br/>|  ("stop"  "words"  "default"  <a href="#prod-xquery10-FTStopWordsInclExcl">FTStopWordsInclExcl</a>*)<br/>|  ("no"  "stop"  "words")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTStopWords" id="prod-xquery10-FTStopWords"/>[175]   </td><td><code><a href="#doc-xquery10-FTStopWords"><a href="#doc-xquery10-FTStopWords">FTStopWords</a></a></code></td><td>   ::=   </td><td><code>("at"  <a href="#prod-xquery10-URILiteral">URILiteral</a>)<br/>|  ("("  <a href="#prod-xquery10-StringLiteral">StringLiteral</a>  (","  <a href="#prod-xquery10-StringLiteral">StringLiteral</a>)*  ")")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTStopWordsInclExcl" id="prod-xquery10-FTStopWordsInclExcl"/>[176]   </td><td><code><a href="#doc-xquery10-FTStopWordsInclExcl"><a href="#doc-xquery10-FTStopWordsInclExcl">FTStopWordsInclExcl</a></a></code></td><td>   ::=   </td><td><code>("union"  |  "except")  <a href="#prod-xquery10-FTStopWords">FTStopWords</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTLanguageOption" id="prod-xquery10-FTLanguageOption"/>[177]   </td><td><code><a href="#doc-xquery10-FTLanguageOption"><a href="#doc-xquery10-FTLanguageOption">FTLanguageOption</a></a></code></td><td>   ::=   </td><td><code>"language"  <a href="#prod-xquery10-StringLiteral">StringLiteral</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTWildCardOption" id="prod-xquery10-FTWildCardOption"/>[178]   </td><td><code><a href="#doc-xquery10-FTWildCardOption"><a href="#doc-xquery10-FTWildCardOption">FTWildCardOption</a></a></code></td><td>   ::=   </td><td><code>"wildcards"  |  ("no"  "wildcards")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTExtensionOption" id="prod-xquery10-FTExtensionOption"/>[179]   </td><td><code><a href="#doc-xquery10-FTExtensionOption"><a href="#doc-xquery10-FTExtensionOption">FTExtensionOption</a></a></code></td><td>   ::=   </td><td><code>"option"  <a href="#prod-xquery10-QName">QName</a>  
                  <a href="#prod-xquery10-StringLiteral">StringLiteral</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-FTIgnoreOption" id="prod-xquery10-FTIgnoreOption"/>[180]   </td><td><code><a href="#doc-xquery10-FTIgnoreOption"><a href="#doc-xquery10-FTIgnoreOption">FTIgnoreOption</a></a></code></td><td>   ::=   </td><td><code>"without"  "content"  <a href="#prod-xquery10-UnionExpr">UnionExpr</a>
               </code></td></tr></tbody></table><div class="div2">
<h3><a name="grammar-terminals" id="grammar-terminals"/>A.1 Terminal Symbols</h3><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="prod-xquery10-IntegerLiteral" id="prod-xquery10-IntegerLiteral"/>[181]   </td><td><code>IntegerLiteral</code></td><td>   ::=   </td><td><code>
                     <a href="#prod-xquery10-Digits">Digits</a>
                  </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-DecimalLiteral" id="prod-xquery10-DecimalLiteral"/>[182]   </td><td><code>DecimalLiteral</code></td><td>   ::=   </td><td><code>("."  <a href="#prod-xquery10-Digits">Digits</a>)  |  (<a href="#prod-xquery10-Digits">Digits</a>  "."  [0-9]*)</code></td><td><i>/* 
                     <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                        <a href="http://www.w3.org/TR/xquery/#ws-explicit">ws: explicit</a><sup><small>XQ</small></sup>
                     </span>
                   */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-DoubleLiteral" id="prod-xquery10-DoubleLiteral"/>[183]   </td><td><code>DoubleLiteral</code></td><td>   ::=   </td><td><code>(("."  <a href="#prod-xquery10-Digits">Digits</a>)  |  (<a href="#prod-xquery10-Digits">Digits</a>  ("."  [0-9]*)?))  [eE]  [+-]?  <a href="#prod-xquery10-Digits">Digits</a>
                  </code></td><td><i>/* 
                     <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                        <a href="http://www.w3.org/TR/xquery/#ws-explicit">ws: explicit</a><sup><small>XQ</small></sup>
                     </span>
                   */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-StringLiteral" id="prod-xquery10-StringLiteral"/>[184]   </td><td><code>StringLiteral</code></td><td>   ::=   </td><td><code>('"'  (<a href="#prod-xquery10-PredefinedEntityRef">PredefinedEntityRef</a>  |  <a href="#prod-xquery10-CharRef">CharRef</a>  |  <a href="#prod-xquery10-EscapeQuot">EscapeQuot</a>  |  [^"&amp;])*  '"')  |  ("'"  (<a href="#prod-xquery10-PredefinedEntityRef">PredefinedEntityRef</a>  |  <a href="#prod-xquery10-CharRef">CharRef</a>  |  <a href="#prod-xquery10-EscapeApos">EscapeApos</a>  |  [^'&amp;])*  "'")</code></td><td><i>/* 
                     <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                        <a href="http://www.w3.org/TR/xquery/#ws-explicit">ws: explicit</a><sup><small>XQ</small></sup>
                     </span>
                   */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-PredefinedEntityRef" id="prod-xquery10-PredefinedEntityRef"/>[185]   </td><td><code>PredefinedEntityRef</code></td><td>   ::=   </td><td><code>"&amp;"  ("lt"  |  "gt"  |  "amp"  |  "quot"  |  "apos")  ";"</code></td><td><i>/* 
                     <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                        <a href="http://www.w3.org/TR/xquery/#ws-explicit">ws: explicit</a><sup><small>XQ</small></sup>
                     </span>
                   */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-EscapeQuot" id="prod-xquery10-EscapeQuot"/>[186]   </td><td><code>EscapeQuot</code></td><td>   ::=   </td><td><code>'""'</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-EscapeApos" id="prod-xquery10-EscapeApos"/>[187]   </td><td><code>EscapeApos</code></td><td>   ::=   </td><td><code>"''"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-ElementContentChar" id="prod-xquery10-ElementContentChar"/>[188]   </td><td><code>ElementContentChar</code></td><td>   ::=   </td><td><code>(<a href="#prod-xquery10-Char">Char</a> - [{}&lt;&amp;])</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-QuotAttrContentChar" id="prod-xquery10-QuotAttrContentChar"/>[189]   </td><td><code>QuotAttrContentChar</code></td><td>   ::=   </td><td><code>(<a href="#prod-xquery10-Char">Char</a> - ["{}&lt;&amp;])</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-AposAttrContentChar" id="prod-xquery10-AposAttrContentChar"/>[190]   </td><td><code>AposAttrContentChar</code></td><td>   ::=   </td><td><code>(<a href="#prod-xquery10-Char">Char</a> - ['{}&lt;&amp;])</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-Comment" id="prod-xquery10-Comment"/>[191]   </td><td><code>Comment</code></td><td>   ::=   </td><td><code>"(:"  (<a href="#prod-xquery10-CommentContents">CommentContents</a>  |  <a href="#prod-xquery10-Comment">Comment</a>)*  ":)"</code></td><td><i>/* 
                     <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                        <a href="http://www.w3.org/TR/xquery/#ws-explicit">ws: explicit</a><sup><small>XQ</small></sup>
                     </span>
                   */</i></td></tr><tr valign="baseline"><td/><td/><td/><td/><td><i>/* 
                     <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                        <a href="http://www.w3.org/TR/xquery/#parse-note-comments">gn: comments</a><sup><small>XQ</small></sup>
                     </span>
                   */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-PITarget" id="prod-xquery10-PITarget"/>[192]   </td><td><code>PITarget</code></td><td>   ::=   </td><td><code>
                     <a href="http://www.w3.org/TR/REC-xml/#NT-PITarget">[http://www.w3.org/TR/REC-xml#NT-PITarget]</a><sup><small>XML</small></sup>
                  </code></td><td><i>/* 
                     <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                        <a href="http://www.w3.org/TR/xquery/#parse-note-xml-version">xgc: xml-version</a><sup><small>XQ</small></sup>
                     </span>
                   */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-CharRef" id="prod-xquery10-CharRef"/>[193]   </td><td><code>CharRef</code></td><td>   ::=   </td><td><code>
                     <a href="http://www.w3.org/TR/REC-xml/#NT-CharRef">[http://www.w3.org/TR/REC-xml#NT-CharRef]</a><sup><small>XML</small></sup>
                  </code></td><td><i>/* 
                     <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                        <a href="http://www.w3.org/TR/xquery/#parse-note-xml-version">xgc: xml-version</a><sup><small>XQ</small></sup>
                     </span>
                   */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-QName" id="prod-xquery10-QName"/>[194]   </td><td><code>QName</code></td><td>   ::=   </td><td><code>
                     <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</a><sup><small>Names</small></sup>
                  </code></td><td><i>/* 
                     <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                        <a href="http://www.w3.org/TR/xquery/#parse-note-xml-version">xgc: xml-version</a><sup><small>XQ</small></sup>
                     </span>
                   */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-NCName" id="prod-xquery10-NCName"/>[195]   </td><td><code>NCName</code></td><td>   ::=   </td><td><code>
                     <a href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</a><sup><small>Names</small></sup>
                  </code></td><td><i>/* 
                     <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                        <a href="http://www.w3.org/TR/xquery/#parse-note-xml-version">xgc: xml-version</a><sup><small>XQ</small></sup>
                     </span>
                   */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-S" id="prod-xquery10-S"/>[196]   </td><td><code>S</code></td><td>   ::=   </td><td><code>
                     <a href="http://www.w3.org/TR/REC-xml/#NT-S">[http://www.w3.org/TR/REC-xml#NT-S]</a><sup><small>XML</small></sup>
                  </code></td><td><i>/* 
                     <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                        <a href="http://www.w3.org/TR/xquery/#parse-note-xml-version">xgc: xml-version</a><sup><small>XQ</small></sup>
                     </span>
                   */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-Char" id="prod-xquery10-Char"/>[197]   </td><td><code>Char</code></td><td>   ::=   </td><td><code>
                     <a href="http://www.w3.org/TR/REC-xml/#NT-Char">[http://www.w3.org/TR/REC-xml#NT-Char]</a><sup><small>XML</small></sup>
                  </code></td><td><i>/* 
                     <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                        <a href="http://www.w3.org/TR/xquery/#parse-note-xml-version">xgc: xml-version</a><sup><small>XQ</small></sup>
                     </span>
                   */</i></td></tr></tbody></table><p>The following symbols are used only in the definition of
  terminal symbols; they are not terminal symbols in the
  grammar of <a href="#id-grammar"><b>A EBNF for XQuery 1.0 Grammar with Full Text extensions</b></a>.</p><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="prod-xquery10-Digits" id="prod-xquery10-Digits"/>[198]   </td><td><code>Digits</code></td><td>   ::=   </td><td><code>[0-9]+</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xquery10-CommentContents" id="prod-xquery10-CommentContents"/>[199]   </td><td><code>CommentContents</code></td><td>   ::=   </td><td><code>(<a href="#prod-xquery10-Char">Char</a>+ - (Char* ('(:' | ':)') Char*))</code></td></tr></tbody></table></div></div><div class="div1">
<h2><a name="id-xpath-grammar" id="id-xpath-grammar"/>B EBNF for XPath 2.0 Grammar with Full-Text
		extensions</h2><p>The EBNF in this document and in this section is aligned with
the current XPath 2.0 grammar (see <a href="http://www.w3.org/TR/2010/REC-xpath20-20101214/">http://www.w3.org/TR/2010/REC-xpath20-20101214/</a>).</p><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="prod-xpath20-XPath" id="prod-xpath20-XPath"/>[1]   </td><td><code>XPath</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-Expr">Expr</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-Expr" id="prod-xpath20-Expr"/>[2]   </td><td><code>Expr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-ExprSingle">ExprSingle</a>  (","  <a href="#prod-xpath20-ExprSingle">ExprSingle</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-ExprSingle" id="prod-xpath20-ExprSingle"/>[3]   </td><td><code>ExprSingle</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-ForExpr">ForExpr</a>
                  <br/>|  <a href="#prod-xpath20-QuantifiedExpr">QuantifiedExpr</a>
                  <br/>|  <a href="#prod-xpath20-IfExpr">IfExpr</a>
                  <br/>|  <a href="#prod-xpath20-OrExpr">OrExpr</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-ForExpr" id="prod-xpath20-ForExpr"/>[4]   </td><td><code>ForExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-SimpleForClause">SimpleForClause</a>  "return"  <a href="#prod-xpath20-ExprSingle">ExprSingle</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-SimpleForClause" id="prod-xpath20-SimpleForClause"/>[5]   </td><td><code>SimpleForClause</code></td><td>   ::=   </td><td><code>"for"  "$"  <a href="#prod-xpath20-VarName">VarName</a>  
                  <a href="#prod-xpath20-FTScoreVar">FTScoreVar</a>?  "in"  <a href="#prod-xpath20-ExprSingle">ExprSingle</a>  (","  "$"  <a href="#prod-xpath20-VarName">VarName</a>  
                  <a href="#prod-xpath20-FTScoreVar">FTScoreVar</a>?  "in"  <a href="#prod-xpath20-ExprSingle">ExprSingle</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTScoreVar" id="prod-xpath20-FTScoreVar"/>[6]   </td><td><code>FTScoreVar</code></td><td>   ::=   </td><td><code>"score"  "$"  <a href="#prod-xpath20-VarName">VarName</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-QuantifiedExpr" id="prod-xpath20-QuantifiedExpr"/>[7]   </td><td><code>QuantifiedExpr</code></td><td>   ::=   </td><td><code>("some"  |  "every")  "$"  <a href="#prod-xpath20-VarName">VarName</a>  "in"  <a href="#prod-xpath20-ExprSingle">ExprSingle</a>  (","  "$"  <a href="#prod-xpath20-VarName">VarName</a>  "in"  <a href="#prod-xpath20-ExprSingle">ExprSingle</a>)*  "satisfies"  <a href="#prod-xpath20-ExprSingle">ExprSingle</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-IfExpr" id="prod-xpath20-IfExpr"/>[8]   </td><td><code>IfExpr</code></td><td>   ::=   </td><td><code>"if"  "("  <a href="#prod-xpath20-Expr">Expr</a>  ")"  "then"  <a href="#prod-xpath20-ExprSingle">ExprSingle</a>  "else"  <a href="#prod-xpath20-ExprSingle">ExprSingle</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-OrExpr" id="prod-xpath20-OrExpr"/>[9]   </td><td><code>OrExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-AndExpr">AndExpr</a> ( "or"  <a href="#prod-xpath20-AndExpr">AndExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-AndExpr" id="prod-xpath20-AndExpr"/>[10]   </td><td><code>AndExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-ComparisonExpr">ComparisonExpr</a> ( "and"  <a href="#prod-xpath20-ComparisonExpr">ComparisonExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-ComparisonExpr" id="prod-xpath20-ComparisonExpr"/>[11]   </td><td><code>ComparisonExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-FTContainsExpr">FTContainsExpr</a> ( (<a href="#prod-xpath20-ValueComp">ValueComp</a>
                  <br/>|  <a href="#prod-xpath20-GeneralComp">GeneralComp</a>
                  <br/>|  <a href="#prod-xpath20-NodeComp">NodeComp</a>)  <a href="#prod-xpath20-FTContainsExpr">FTContainsExpr</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTContainsExpr" id="prod-xpath20-FTContainsExpr"/>[12]   </td><td><code>FTContainsExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-RangeExpr">RangeExpr</a> ( "contains"  "text"  <a href="#prod-xpath20-FTSelection">FTSelection</a>  
                  <a href="#prod-xpath20-FTIgnoreOption">FTIgnoreOption</a>? )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-RangeExpr" id="prod-xpath20-RangeExpr"/>[13]   </td><td><code>RangeExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-AdditiveExpr">AdditiveExpr</a> ( "to"  <a href="#prod-xpath20-AdditiveExpr">AdditiveExpr</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-AdditiveExpr" id="prod-xpath20-AdditiveExpr"/>[14]   </td><td><code>AdditiveExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-MultiplicativeExpr">MultiplicativeExpr</a> ( ("+"  |  "-")  <a href="#prod-xpath20-MultiplicativeExpr">MultiplicativeExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-MultiplicativeExpr" id="prod-xpath20-MultiplicativeExpr"/>[15]   </td><td><code>MultiplicativeExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-UnionExpr">UnionExpr</a> ( ("*"  |  "div"  |  "idiv"  |  "mod")  <a href="#prod-xpath20-UnionExpr">UnionExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-UnionExpr" id="prod-xpath20-UnionExpr"/>[16]   </td><td><code>UnionExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-IntersectExceptExpr">IntersectExceptExpr</a> ( ("union"  |  "|")  <a href="#prod-xpath20-IntersectExceptExpr">IntersectExceptExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-IntersectExceptExpr" id="prod-xpath20-IntersectExceptExpr"/>[17]   </td><td><code>IntersectExceptExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-InstanceofExpr">InstanceofExpr</a> ( ("intersect"  |  "except")  <a href="#prod-xpath20-InstanceofExpr">InstanceofExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-InstanceofExpr" id="prod-xpath20-InstanceofExpr"/>[18]   </td><td><code>InstanceofExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-TreatExpr">TreatExpr</a> ( "instance"  "of"  <a href="#prod-xpath20-SequenceType">SequenceType</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-TreatExpr" id="prod-xpath20-TreatExpr"/>[19]   </td><td><code>TreatExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-CastableExpr">CastableExpr</a> ( "treat"  "as"  <a href="#prod-xpath20-SequenceType">SequenceType</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-CastableExpr" id="prod-xpath20-CastableExpr"/>[20]   </td><td><code>CastableExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-CastExpr">CastExpr</a> ( "castable"  "as"  <a href="#prod-xpath20-SingleType">SingleType</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-CastExpr" id="prod-xpath20-CastExpr"/>[21]   </td><td><code>CastExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-UnaryExpr">UnaryExpr</a> ( "cast"  "as"  <a href="#prod-xpath20-SingleType">SingleType</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-UnaryExpr" id="prod-xpath20-UnaryExpr"/>[22]   </td><td><code>UnaryExpr</code></td><td>   ::=   </td><td><code>("-"  |  "+")* <a href="#prod-xpath20-ValueExpr">ValueExpr</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-ValueExpr" id="prod-xpath20-ValueExpr"/>[23]   </td><td><code>ValueExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-PathExpr">PathExpr</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-GeneralComp" id="prod-xpath20-GeneralComp"/>[24]   </td><td><code>GeneralComp</code></td><td>   ::=   </td><td><code>"="  |  "!="  |  "&lt;"  |  "&lt;="  |  "&gt;"  |  "&gt;="</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-ValueComp" id="prod-xpath20-ValueComp"/>[25]   </td><td><code>ValueComp</code></td><td>   ::=   </td><td><code>"eq"  |  "ne"  |  "lt"  |  "le"  |  "gt"  |  "ge"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-NodeComp" id="prod-xpath20-NodeComp"/>[26]   </td><td><code>NodeComp</code></td><td>   ::=   </td><td><code>"is"  |  "&lt;&lt;"  |  "&gt;&gt;"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-Pragma" id="prod-xpath20-Pragma"/>[27]   </td><td><code>Pragma</code></td><td>   ::=   </td><td><code>"(#"  <a href="#prod-xpath20-S">S</a>?  <a href="#prod-xpath20-QName">QName</a>  (<a href="#prod-xpath20-S">S</a>  
                  <a href="#prod-xpath20-PragmaContents">PragmaContents</a>)?  "#)"</code></td><td><i>/* 
                  <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                     <a href="http://www.w3.org/TR/xpath20/#ws-explicit">ws: explicit</a><sup><small>XP</small></sup>
                  </span>
                */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-PragmaContents" id="prod-xpath20-PragmaContents"/>[28]   </td><td><code>PragmaContents</code></td><td>   ::=   </td><td><code>(<a href="#prod-xpath20-Char">Char</a>* - (Char* '#)' Char*))</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-PathExpr" id="prod-xpath20-PathExpr"/>[29]   </td><td><code>PathExpr</code></td><td>   ::=   </td><td><code>("/"  <a href="#prod-xpath20-RelativePathExpr">RelativePathExpr</a>?)<br/>|  ("//"  <a href="#prod-xpath20-RelativePathExpr">RelativePathExpr</a>)<br/>|  <a href="#prod-xpath20-RelativePathExpr">RelativePathExpr</a>
               </code></td><td><i>/* 
                  <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                     <a href="http://www.w3.org/TR/xpath20/#parse-note-leading-lone-slash">xgc: leading-lone-slash</a><sup><small>XP</small></sup>
                  </span>
                */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-RelativePathExpr" id="prod-xpath20-RelativePathExpr"/>[30]   </td><td><code>RelativePathExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-StepExpr">StepExpr</a>  (("/"  |  "//")  <a href="#prod-xpath20-StepExpr">StepExpr</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-StepExpr" id="prod-xpath20-StepExpr"/>[31]   </td><td><code>StepExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-FilterExpr">FilterExpr</a>  |  <a href="#prod-xpath20-AxisStep">AxisStep</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-AxisStep" id="prod-xpath20-AxisStep"/>[32]   </td><td><code>AxisStep</code></td><td>   ::=   </td><td><code>(<a href="#prod-xpath20-ReverseStep">ReverseStep</a>  |  <a href="#prod-xpath20-ForwardStep">ForwardStep</a>)  <a href="#prod-xpath20-PredicateList">PredicateList</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-ForwardStep" id="prod-xpath20-ForwardStep"/>[33]   </td><td><code>ForwardStep</code></td><td>   ::=   </td><td><code>(<a href="#prod-xpath20-ForwardAxis">ForwardAxis</a>  
                  <a href="#prod-xpath20-NodeTest">NodeTest</a>)  |  <a href="#prod-xpath20-AbbrevForwardStep">AbbrevForwardStep</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-ForwardAxis" id="prod-xpath20-ForwardAxis"/>[34]   </td><td><code>ForwardAxis</code></td><td>   ::=   </td><td><code>("child"  "::")<br/>|  ("descendant"  "::")<br/>|  ("attribute"  "::")<br/>|  ("self"  "::")<br/>|  ("descendant-or-self"  "::")<br/>|  ("following-sibling"  "::")<br/>|  ("following"  "::")<br/>|  ("namespace"  "::")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-AbbrevForwardStep" id="prod-xpath20-AbbrevForwardStep"/>[35]   </td><td><code>AbbrevForwardStep</code></td><td>   ::=   </td><td><code>"@"?  <a href="#prod-xpath20-NodeTest">NodeTest</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-ReverseStep" id="prod-xpath20-ReverseStep"/>[36]   </td><td><code>ReverseStep</code></td><td>   ::=   </td><td><code>(<a href="#prod-xpath20-ReverseAxis">ReverseAxis</a>  
                  <a href="#prod-xpath20-NodeTest">NodeTest</a>)  |  <a href="#prod-xpath20-AbbrevReverseStep">AbbrevReverseStep</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-ReverseAxis" id="prod-xpath20-ReverseAxis"/>[37]   </td><td><code>ReverseAxis</code></td><td>   ::=   </td><td><code>("parent"  "::")<br/>|  ("ancestor"  "::")<br/>|  ("preceding-sibling"  "::")<br/>|  ("preceding"  "::")<br/>|  ("ancestor-or-self"  "::")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-AbbrevReverseStep" id="prod-xpath20-AbbrevReverseStep"/>[38]   </td><td><code>AbbrevReverseStep</code></td><td>   ::=   </td><td><code>".."</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-NodeTest" id="prod-xpath20-NodeTest"/>[39]   </td><td><code>NodeTest</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-KindTest">KindTest</a>  |  <a href="#prod-xpath20-NameTest">NameTest</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-NameTest" id="prod-xpath20-NameTest"/>[40]   </td><td><code>NameTest</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-QName">QName</a>  |  <a href="#prod-xpath20-Wildcard">Wildcard</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-Wildcard" id="prod-xpath20-Wildcard"/>[41]   </td><td><code>Wildcard</code></td><td>   ::=   </td><td><code>"*"<br/>|  (<a href="#prod-xpath20-NCName">NCName</a>  ":"  "*")<br/>|  ("*"  ":"  <a href="#prod-xpath20-NCName">NCName</a>)</code></td><td><i>/* 
                  <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                     <a href="http://www.w3.org/TR/xpath20/#ws-explicit">ws: explicit</a><sup><small>XP</small></sup>
                  </span>
                */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FilterExpr" id="prod-xpath20-FilterExpr"/>[42]   </td><td><code>FilterExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-PrimaryExpr">PrimaryExpr</a>  
                  <a href="#prod-xpath20-PredicateList">PredicateList</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-PredicateList" id="prod-xpath20-PredicateList"/>[43]   </td><td><code>PredicateList</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-Predicate">Predicate</a>*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-Predicate" id="prod-xpath20-Predicate"/>[44]   </td><td><code>Predicate</code></td><td>   ::=   </td><td><code>"["  <a href="#prod-xpath20-Expr">Expr</a>  "]"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-PrimaryExpr" id="prod-xpath20-PrimaryExpr"/>[45]   </td><td><code>PrimaryExpr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-Literal">Literal</a>
                  <br/>|  <a href="#prod-xpath20-VarRef">VarRef</a>
                  <br/>|  <a href="#prod-xpath20-ParenthesizedExpr">ParenthesizedExpr</a>
                  <br/>|  <a href="#prod-xpath20-ContextItemExpr">ContextItemExpr</a>
                  <br/>|  <a href="#prod-xpath20-FunctionCall">FunctionCall</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-Literal" id="prod-xpath20-Literal"/>[46]   </td><td><code>Literal</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-NumericLiteral">NumericLiteral</a>  |  <a href="#prod-xpath20-StringLiteral">StringLiteral</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-NumericLiteral" id="prod-xpath20-NumericLiteral"/>[47]   </td><td><code>NumericLiteral</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-IntegerLiteral">IntegerLiteral</a>  |  <a href="#prod-xpath20-DecimalLiteral">DecimalLiteral</a>  |  <a href="#prod-xpath20-DoubleLiteral">DoubleLiteral</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-VarRef" id="prod-xpath20-VarRef"/>[48]   </td><td><code>VarRef</code></td><td>   ::=   </td><td><code>"$"  <a href="#prod-xpath20-VarName">VarName</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-VarName" id="prod-xpath20-VarName"/>[49]   </td><td><code>VarName</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-QName">QName</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-ParenthesizedExpr" id="prod-xpath20-ParenthesizedExpr"/>[50]   </td><td><code>ParenthesizedExpr</code></td><td>   ::=   </td><td><code>"("  <a href="#prod-xpath20-Expr">Expr</a>?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-ContextItemExpr" id="prod-xpath20-ContextItemExpr"/>[51]   </td><td><code>ContextItemExpr</code></td><td>   ::=   </td><td><code>"."</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FunctionCall" id="prod-xpath20-FunctionCall"/>[52]   </td><td><code>FunctionCall</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-QName">QName</a>  "("  (<a href="#prod-xpath20-ExprSingle">ExprSingle</a>  (","  <a href="#prod-xpath20-ExprSingle">ExprSingle</a>)*)?  ")"</code></td><td><i>/* 
                  <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                     <a href="http://www.w3.org/TR/xpath20/#parse-note-reserved-function-names">xgc: reserved-function-names</a><sup><small>XP</small></sup>
                  </span>
                */</i></td></tr><tr valign="baseline"><td/><td/><td/><td/><td><i>/* 
                  <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                     <a href="http://www.w3.org/TR/xpath20/#parse-note-parens">gn: parens</a><sup><small>XP</small></sup>
                  </span>
                */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-SingleType" id="prod-xpath20-SingleType"/>[53]   </td><td><code>SingleType</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-AtomicType">AtomicType</a>  "?"?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-SequenceType" id="prod-xpath20-SequenceType"/>[54]   </td><td><code>SequenceType</code></td><td>   ::=   </td><td><code>("empty-sequence"  "("  ")")<br/>|  (<a href="#prod-xpath20-ItemType">ItemType</a>  
                  <a href="#prod-xpath20-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-OccurrenceIndicator" id="prod-xpath20-OccurrenceIndicator"/>[55]   </td><td><code>OccurrenceIndicator</code></td><td>   ::=   </td><td><code>"?"  |  "*"  |  "+"</code></td><td><i>/* 
                  <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                     <a href="http://www.w3.org/TR/xpath20/#parse-note-occurrence-indicators">xgc: occurrence-indicators</a><sup><small>XP</small></sup>
                  </span>
                */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-ItemType" id="prod-xpath20-ItemType"/>[56]   </td><td><code>ItemType</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-KindTest">KindTest</a>  |  ("item"  "("  ")")  |  <a href="#prod-xpath20-AtomicType">AtomicType</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-AtomicType" id="prod-xpath20-AtomicType"/>[57]   </td><td><code>AtomicType</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-QName">QName</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-KindTest" id="prod-xpath20-KindTest"/>[58]   </td><td><code>KindTest</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-DocumentTest">DocumentTest</a>
                  <br/>|  <a href="#prod-xpath20-ElementTest">ElementTest</a>
                  <br/>|  <a href="#prod-xpath20-AttributeTest">AttributeTest</a>
                  <br/>|  <a href="#prod-xpath20-SchemaElementTest">SchemaElementTest</a>
                  <br/>|  <a href="#prod-xpath20-SchemaAttributeTest">SchemaAttributeTest</a>
                  <br/>|  <a href="#prod-xpath20-PITest">PITest</a>
                  <br/>|  <a href="#prod-xpath20-CommentTest">CommentTest</a>
                  <br/>|  <a href="#prod-xpath20-TextTest">TextTest</a>
                  <br/>|  <a href="#prod-xpath20-AnyKindTest">AnyKindTest</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-AnyKindTest" id="prod-xpath20-AnyKindTest"/>[59]   </td><td><code>AnyKindTest</code></td><td>   ::=   </td><td><code>"node"  "("  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-DocumentTest" id="prod-xpath20-DocumentTest"/>[60]   </td><td><code>DocumentTest</code></td><td>   ::=   </td><td><code>"document-node"  "("  (<a href="#prod-xpath20-ElementTest">ElementTest</a>  |  <a href="#prod-xpath20-SchemaElementTest">SchemaElementTest</a>)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-TextTest" id="prod-xpath20-TextTest"/>[61]   </td><td><code>TextTest</code></td><td>   ::=   </td><td><code>"text"  "("  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-CommentTest" id="prod-xpath20-CommentTest"/>[62]   </td><td><code>CommentTest</code></td><td>   ::=   </td><td><code>"comment"  "("  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-PITest" id="prod-xpath20-PITest"/>[63]   </td><td><code>PITest</code></td><td>   ::=   </td><td><code>"processing-instruction"  "("  (<a href="#prod-xpath20-NCName">NCName</a>  |  <a href="#prod-xpath20-StringLiteral">StringLiteral</a>)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-AttributeTest" id="prod-xpath20-AttributeTest"/>[64]   </td><td><code>AttributeTest</code></td><td>   ::=   </td><td><code>"attribute"  "("  (<a href="#prod-xpath20-AttribNameOrWildcard">AttribNameOrWildcard</a>  (","  <a href="#prod-xpath20-TypeName">TypeName</a>)?)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-AttribNameOrWildcard" id="prod-xpath20-AttribNameOrWildcard"/>[65]   </td><td><code>AttribNameOrWildcard</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-AttributeName">AttributeName</a>  |  "*"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-SchemaAttributeTest" id="prod-xpath20-SchemaAttributeTest"/>[66]   </td><td><code>SchemaAttributeTest</code></td><td>   ::=   </td><td><code>"schema-attribute"  "("  <a href="#prod-xpath20-AttributeDeclaration">AttributeDeclaration</a>  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-AttributeDeclaration" id="prod-xpath20-AttributeDeclaration"/>[67]   </td><td><code>AttributeDeclaration</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-AttributeName">AttributeName</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-ElementTest" id="prod-xpath20-ElementTest"/>[68]   </td><td><code>ElementTest</code></td><td>   ::=   </td><td><code>"element"  "("  (<a href="#prod-xpath20-ElementNameOrWildcard">ElementNameOrWildcard</a>  (","  <a href="#prod-xpath20-TypeName">TypeName</a>  "?"?)?)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-ElementNameOrWildcard" id="prod-xpath20-ElementNameOrWildcard"/>[69]   </td><td><code>ElementNameOrWildcard</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-ElementName">ElementName</a>  |  "*"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-SchemaElementTest" id="prod-xpath20-SchemaElementTest"/>[70]   </td><td><code>SchemaElementTest</code></td><td>   ::=   </td><td><code>"schema-element"  "("  <a href="#prod-xpath20-ElementDeclaration">ElementDeclaration</a>  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-ElementDeclaration" id="prod-xpath20-ElementDeclaration"/>[71]   </td><td><code>ElementDeclaration</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-ElementName">ElementName</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-AttributeName" id="prod-xpath20-AttributeName"/>[72]   </td><td><code>AttributeName</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-QName">QName</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-ElementName" id="prod-xpath20-ElementName"/>[73]   </td><td><code>ElementName</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-QName">QName</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-TypeName" id="prod-xpath20-TypeName"/>[74]   </td><td><code>TypeName</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-QName">QName</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-URILiteral" id="prod-xpath20-URILiteral"/>[75]   </td><td><code>URILiteral</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-StringLiteral">StringLiteral</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTSelection" id="prod-xpath20-FTSelection"/>[76]   </td><td><code>FTSelection</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-FTOr">FTOr</a>  
                  <a href="#prod-xpath20-FTPosFilter">FTPosFilter</a>*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTWeight" id="prod-xpath20-FTWeight"/>[77]   </td><td><code>FTWeight</code></td><td>   ::=   </td><td><code>"weight"  "{"  <a href="#prod-xpath20-Expr">Expr</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTOr" id="prod-xpath20-FTOr"/>[78]   </td><td><code>FTOr</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-FTAnd">FTAnd</a> ( "ftor"  <a href="#prod-xpath20-FTAnd">FTAnd</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTAnd" id="prod-xpath20-FTAnd"/>[79]   </td><td><code>FTAnd</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-FTMildNot">FTMildNot</a> ( "ftand"  <a href="#prod-xpath20-FTMildNot">FTMildNot</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTMildNot" id="prod-xpath20-FTMildNot"/>[80]   </td><td><code>FTMildNot</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-FTUnaryNot">FTUnaryNot</a> ( "not"  "in"  <a href="#prod-xpath20-FTUnaryNot">FTUnaryNot</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTUnaryNot" id="prod-xpath20-FTUnaryNot"/>[81]   </td><td><code>FTUnaryNot</code></td><td>   ::=   </td><td><code>("ftnot")? <a href="#prod-xpath20-FTPrimaryWithOptions">FTPrimaryWithOptions</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTPrimaryWithOptions" id="prod-xpath20-FTPrimaryWithOptions"/>[82]   </td><td><code>FTPrimaryWithOptions</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-FTPrimary">FTPrimary</a>  
                  <a href="#prod-xpath20-FTMatchOptions">FTMatchOptions</a>?  <a href="#prod-xpath20-FTWeight">FTWeight</a>?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTPrimary" id="prod-xpath20-FTPrimary"/>[83]   </td><td><code>FTPrimary</code></td><td>   ::=   </td><td><code>(<a href="#prod-xpath20-FTWords">FTWords</a>  
                  <a href="#prod-xpath20-FTTimes">FTTimes</a>?)  |  ("("  <a href="#prod-xpath20-FTSelection">FTSelection</a>  ")")  |  <a href="#prod-xpath20-FTExtensionSelection">FTExtensionSelection</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTWords" id="prod-xpath20-FTWords"/>[84]   </td><td><code>FTWords</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-FTWordsValue">FTWordsValue</a>  
                  <a href="#prod-xpath20-FTAnyallOption">FTAnyallOption</a>?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTWordsValue" id="prod-xpath20-FTWordsValue"/>[85]   </td><td><code>FTWordsValue</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-StringLiteral">StringLiteral</a>  |  ("{"  <a href="#prod-xpath20-Expr">Expr</a>  "}")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTExtensionSelection" id="prod-xpath20-FTExtensionSelection"/>[86]   </td><td><code>FTExtensionSelection</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-Pragma">Pragma</a>+  "{"  <a href="#prod-xpath20-FTSelection">FTSelection</a>?  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTAnyallOption" id="prod-xpath20-FTAnyallOption"/>[87]   </td><td><code>FTAnyallOption</code></td><td>   ::=   </td><td><code>("any"  "word"?)  |  ("all"  "words"?)  |  "phrase"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTTimes" id="prod-xpath20-FTTimes"/>[88]   </td><td><code>FTTimes</code></td><td>   ::=   </td><td><code>"occurs"  <a href="#prod-xpath20-FTRange">FTRange</a>  "times"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTRange" id="prod-xpath20-FTRange"/>[89]   </td><td><code>FTRange</code></td><td>   ::=   </td><td><code>("exactly"  <a href="#prod-xpath20-AdditiveExpr">AdditiveExpr</a>)<br/>|  ("at"  "least"  <a href="#prod-xpath20-AdditiveExpr">AdditiveExpr</a>)<br/>|  ("at"  "most"  <a href="#prod-xpath20-AdditiveExpr">AdditiveExpr</a>)<br/>|  ("from"  <a href="#prod-xpath20-AdditiveExpr">AdditiveExpr</a>  "to"  <a href="#prod-xpath20-AdditiveExpr">AdditiveExpr</a>)</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTPosFilter" id="prod-xpath20-FTPosFilter"/>[90]   </td><td><code>FTPosFilter</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-FTOrder">FTOrder</a>  |  <a href="#prod-xpath20-FTWindow">FTWindow</a>  |  <a href="#prod-xpath20-FTDistance">FTDistance</a>  |  <a href="#prod-xpath20-FTScope">FTScope</a>  |  <a href="#prod-xpath20-FTContent">FTContent</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTOrder" id="prod-xpath20-FTOrder"/>[91]   </td><td><code>FTOrder</code></td><td>   ::=   </td><td><code>"ordered"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTWindow" id="prod-xpath20-FTWindow"/>[92]   </td><td><code>FTWindow</code></td><td>   ::=   </td><td><code>"window"  <a href="#prod-xpath20-AdditiveExpr">AdditiveExpr</a>  
                  <a href="#prod-xpath20-FTUnit">FTUnit</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTDistance" id="prod-xpath20-FTDistance"/>[93]   </td><td><code>FTDistance</code></td><td>   ::=   </td><td><code>"distance"  <a href="#prod-xpath20-FTRange">FTRange</a>  
                  <a href="#prod-xpath20-FTUnit">FTUnit</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTUnit" id="prod-xpath20-FTUnit"/>[94]   </td><td><code>FTUnit</code></td><td>   ::=   </td><td><code>"words"  |  "sentences"  |  "paragraphs"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTScope" id="prod-xpath20-FTScope"/>[95]   </td><td><code>FTScope</code></td><td>   ::=   </td><td><code>("same"  |  "different")  <a href="#prod-xpath20-FTBigUnit">FTBigUnit</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTBigUnit" id="prod-xpath20-FTBigUnit"/>[96]   </td><td><code>FTBigUnit</code></td><td>   ::=   </td><td><code>"sentence"  |  "paragraph"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTContent" id="prod-xpath20-FTContent"/>[97]   </td><td><code>FTContent</code></td><td>   ::=   </td><td><code>("at"  "start")  |  ("at"  "end")  |  ("entire"  "content")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTMatchOptions" id="prod-xpath20-FTMatchOptions"/>[98]   </td><td><code>FTMatchOptions</code></td><td>   ::=   </td><td><code>("using"  <a href="#prod-xpath20-FTMatchOption">FTMatchOption</a>)+</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTMatchOption" id="prod-xpath20-FTMatchOption"/>[99]   </td><td><code>FTMatchOption</code></td><td>   ::=   </td><td><code>
                  <a href="#prod-xpath20-FTLanguageOption">FTLanguageOption</a>
                  <br/>|  <a href="#prod-xpath20-FTWildCardOption">FTWildCardOption</a>
                  <br/>|  <a href="#prod-xpath20-FTThesaurusOption">FTThesaurusOption</a>
                  <br/>|  <a href="#prod-xpath20-FTStemOption">FTStemOption</a>
                  <br/>|  <a href="#prod-xpath20-FTCaseOption">FTCaseOption</a>
                  <br/>|  <a href="#prod-xpath20-FTDiacriticsOption">FTDiacriticsOption</a>
                  <br/>|  <a href="#prod-xpath20-FTStopWordOption">FTStopWordOption</a>
                  <br/>|  <a href="#prod-xpath20-FTExtensionOption">FTExtensionOption</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTCaseOption" id="prod-xpath20-FTCaseOption"/>[100]   </td><td><code>FTCaseOption</code></td><td>   ::=   </td><td><code>("case"  "insensitive")<br/>|  ("case"  "sensitive")<br/>|  "lowercase"<br/>|  "uppercase"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTDiacriticsOption" id="prod-xpath20-FTDiacriticsOption"/>[101]   </td><td><code>FTDiacriticsOption</code></td><td>   ::=   </td><td><code>("diacritics"  "insensitive")<br/>|  ("diacritics"  "sensitive")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTStemOption" id="prod-xpath20-FTStemOption"/>[102]   </td><td><code>FTStemOption</code></td><td>   ::=   </td><td><code>"stemming"  |  ("no"  "stemming")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTThesaurusOption" id="prod-xpath20-FTThesaurusOption"/>[103]   </td><td><code>FTThesaurusOption</code></td><td>   ::=   </td><td><code>("thesaurus"  (<a href="#prod-xpath20-FTThesaurusID">FTThesaurusID</a>  |  "default"))<br/>|  ("thesaurus"  "("  (<a href="#prod-xpath20-FTThesaurusID">FTThesaurusID</a>  |  "default")  (","  <a href="#prod-xpath20-FTThesaurusID">FTThesaurusID</a>)*  ")")<br/>|  ("no"  "thesaurus")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTThesaurusID" id="prod-xpath20-FTThesaurusID"/>[104]   </td><td><code>FTThesaurusID</code></td><td>   ::=   </td><td><code>"at"  <a href="#prod-xpath20-URILiteral">URILiteral</a>  ("relationship"  <a href="#prod-xpath20-StringLiteral">StringLiteral</a>)?  (<a href="#prod-xpath20-FTLiteralRange">FTLiteralRange</a>  "levels")?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTLiteralRange" id="prod-xpath20-FTLiteralRange"/>[105]   </td><td><code>FTLiteralRange</code></td><td>   ::=   </td><td><code>("exactly"  <a href="#prod-xpath20-IntegerLiteral">IntegerLiteral</a>)<br/>|  ("at"  "least"  <a href="#prod-xpath20-IntegerLiteral">IntegerLiteral</a>)<br/>|  ("at"  "most"  <a href="#prod-xpath20-IntegerLiteral">IntegerLiteral</a>)<br/>|  ("from"  <a href="#prod-xpath20-IntegerLiteral">IntegerLiteral</a>  "to"  <a href="#prod-xpath20-IntegerLiteral">IntegerLiteral</a>)</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTStopWordOption" id="prod-xpath20-FTStopWordOption"/>[106]   </td><td><code>FTStopWordOption</code></td><td>   ::=   </td><td><code>("stop"  "words"  <a href="#prod-xpath20-FTStopWords">FTStopWords</a>  
                  <a href="#prod-xpath20-FTStopWordsInclExcl">FTStopWordsInclExcl</a>*)<br/>|  ("stop"  "words"  "default"  <a href="#prod-xpath20-FTStopWordsInclExcl">FTStopWordsInclExcl</a>*)<br/>|  ("no"  "stop"  "words")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTStopWords" id="prod-xpath20-FTStopWords"/>[107]   </td><td><code>FTStopWords</code></td><td>   ::=   </td><td><code>("at"  <a href="#prod-xpath20-URILiteral">URILiteral</a>)<br/>|  ("("  <a href="#prod-xpath20-StringLiteral">StringLiteral</a>  (","  <a href="#prod-xpath20-StringLiteral">StringLiteral</a>)*  ")")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTStopWordsInclExcl" id="prod-xpath20-FTStopWordsInclExcl"/>[108]   </td><td><code>FTStopWordsInclExcl</code></td><td>   ::=   </td><td><code>("union"  |  "except")  <a href="#prod-xpath20-FTStopWords">FTStopWords</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTLanguageOption" id="prod-xpath20-FTLanguageOption"/>[109]   </td><td><code>FTLanguageOption</code></td><td>   ::=   </td><td><code>"language"  <a href="#prod-xpath20-StringLiteral">StringLiteral</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTWildCardOption" id="prod-xpath20-FTWildCardOption"/>[110]   </td><td><code>FTWildCardOption</code></td><td>   ::=   </td><td><code>"wildcards"  |  ("no"  "wildcards")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTExtensionOption" id="prod-xpath20-FTExtensionOption"/>[111]   </td><td><code>FTExtensionOption</code></td><td>   ::=   </td><td><code>"option"  <a href="#prod-xpath20-QName">QName</a>  
                  <a href="#prod-xpath20-StringLiteral">StringLiteral</a>
               </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-FTIgnoreOption" id="prod-xpath20-FTIgnoreOption"/>[112]   </td><td><code>FTIgnoreOption</code></td><td>   ::=   </td><td><code>"without"  "content"  <a href="#prod-xpath20-UnionExpr">UnionExpr</a>
               </code></td></tr></tbody></table><div class="div2">
<h3><a name="xpath-grammar-terminals" id="xpath-grammar-terminals"/>B.1 Terminal Symbols</h3><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="prod-xpath20-IntegerLiteral" id="prod-xpath20-IntegerLiteral"/>[113]   </td><td><code>IntegerLiteral</code></td><td>   ::=   </td><td><code>
                     <a href="#prod-xpath20-Digits">Digits</a>
                  </code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-DecimalLiteral" id="prod-xpath20-DecimalLiteral"/>[114]   </td><td><code>DecimalLiteral</code></td><td>   ::=   </td><td><code>("."  <a href="#prod-xpath20-Digits">Digits</a>)  |  (<a href="#prod-xpath20-Digits">Digits</a>  "."  [0-9]*)</code></td><td><i>/* 
                     <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                        <a href="http://www.w3.org/TR/xpath20/#ws-explicit">ws: explicit</a><sup><small>XP</small></sup>
                     </span>
                   */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-DoubleLiteral" id="prod-xpath20-DoubleLiteral"/>[115]   </td><td><code>DoubleLiteral</code></td><td>   ::=   </td><td><code>(("."  <a href="#prod-xpath20-Digits">Digits</a>)  |  (<a href="#prod-xpath20-Digits">Digits</a>  ("."  [0-9]*)?))  [eE]  [+-]?  <a href="#prod-xpath20-Digits">Digits</a>
                  </code></td><td><i>/* 
                     <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                        <a href="http://www.w3.org/TR/xpath20/#ws-explicit">ws: explicit</a><sup><small>XP</small></sup>
                     </span>
                   */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-StringLiteral" id="prod-xpath20-StringLiteral"/>[116]   </td><td><code>StringLiteral</code></td><td>   ::=   </td><td><code>('"'  (<a href="#prod-xpath20-EscapeQuot">EscapeQuot</a>  |  [^"])*  '"')  |  ("'"  (<a href="#prod-xpath20-EscapeApos">EscapeApos</a>  |  [^'])*  "'")</code></td><td><i>/* 
                     <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                        <a href="http://www.w3.org/TR/xpath20/#ws-explicit">ws: explicit</a><sup><small>XP</small></sup>
                     </span>
                   */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-EscapeQuot" id="prod-xpath20-EscapeQuot"/>[117]   </td><td><code>EscapeQuot</code></td><td>   ::=   </td><td><code>'""'</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-EscapeApos" id="prod-xpath20-EscapeApos"/>[118]   </td><td><code>EscapeApos</code></td><td>   ::=   </td><td><code>"''"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-Comment" id="prod-xpath20-Comment"/>[119]   </td><td><code>Comment</code></td><td>   ::=   </td><td><code>"(:"  (<a href="#prod-xpath20-CommentContents">CommentContents</a>  |  <a href="#prod-xpath20-Comment">Comment</a>)*  ":)"</code></td><td><i>/* 
                     <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                        <a href="http://www.w3.org/TR/xpath20/#ws-explicit">ws: explicit</a><sup><small>XP</small></sup>
                     </span>
                   */</i></td></tr><tr valign="baseline"><td/><td/><td/><td/><td><i>/* 
                     <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                        <a href="http://www.w3.org/TR/xpath20/#parse-note-comments">gn: comments</a><sup><small>XP</small></sup>
                     </span>
                   */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-QName" id="prod-xpath20-QName"/>[120]   </td><td><code>QName</code></td><td>   ::=   </td><td><code>
                     <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</a><sup><small>Names</small></sup>
                  </code></td><td><i>/* 
                     <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                        <a href="http://www.w3.org/TR/xpath20/#parse-note-xml-version">xgc: xml-version</a><sup><small>XP</small></sup>
                     </span>
                   */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-NCName" id="prod-xpath20-NCName"/>[121]   </td><td><code>NCName</code></td><td>   ::=   </td><td><code>
                     <a href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</a><sup><small>Names</small></sup>
                  </code></td><td><i>/* 
                     <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                        <a href="http://www.w3.org/TR/xpath20/#parse-note-xml-version">xgc: xml-version</a><sup><small>XP</small></sup>
                     </span>
                   */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-S" id="prod-xpath20-S"/>[122]   </td><td><code>S</code></td><td>   ::=   </td><td><code>
                     <a href="http://www.w3.org/TR/REC-xml/#NT-S">[http://www.w3.org/TR/REC-xml#NT-S]</a><sup><small>XML</small></sup>
                  </code></td><td><i>/* 
                     <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                        <a href="http://www.w3.org/TR/xpath20/#parse-note-xml-version">xgc: xml-version</a><sup><small>XP</small></sup>
                     </span>
                   */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-Char" id="prod-xpath20-Char"/>[123]   </td><td><code>Char</code></td><td>   ::=   </td><td><code>
                     <a href="http://www.w3.org/TR/REC-xml/#NT-Char">[http://www.w3.org/TR/REC-xml#NT-Char]</a><sup><small>XML</small></sup>
                  </code></td><td><i>/* 
                     <!--* This is xmlspec, match="phrase" - - show.diff.markup = 1--><span>
                        <a href="http://www.w3.org/TR/xpath20/#parse-note-xml-version">xgc: xml-version</a><sup><small>XP</small></sup>
                     </span>
                   */</i></td></tr></tbody></table><p>The following symbols are used only in the definition of
  terminal symbols; they are not terminal symbols in the
  grammar of <a href="#id-xpath-grammar"><b>B EBNF for XPath 2.0 Grammar with Full-Text
		extensions</b></a>.</p><table class="scrap" summary="Scrap"><tbody><tr valign="baseline"><td><a name="prod-xpath20-Digits" id="prod-xpath20-Digits"/>[124]   </td><td><code>Digits</code></td><td>   ::=   </td><td><code>[0-9]+</code></td></tr></tbody><tbody><tr valign="baseline"><td><a name="prod-xpath20-CommentContents" id="prod-xpath20-CommentContents"/>[125]   </td><td><code>CommentContents</code></td><td>   ::=   </td><td><code>(<a href="#prod-xpath20-Char">Char</a>+ - (Char* ('(:' | ':)') Char*))</code></td></tr></tbody></table></div></div><div class="div1">
<h2><a name="id-xqft-static-context-components" id="id-xqft-static-context-components"/>C Static Context Components</h2><p>The following table describes the full-text components of
the <b>static context</b> (as defined in <a href="http://www.w3.org/TR/xquery/#static_context">Section 
2.1.1 Static Context</a><sup><small>XQ</small></sup>). 
The following aspects of each
component are described:</p><ul><li><p>
                  <em>Default initial value:</em> This is the initial value of the component if it is not
overridden or augmented by the implementation or by a query.</p></li><li><p>
                  <em>Can be overwritten or augmented by
implementation:</em> Indicates whether an XQuery implementation is
allowed to replace the default initial value of the component by a
different, <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> value
and/or to augment the default initial value by additional
<a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> values.</p></li><li><p>
                  <em>Can be overwritten or augmented by a
query:</em> Indicates whether a query is allowed to replace and/or
augment the initial value provided by default or by the
implementation. If so, indicates how this is accomplished (for
example, by a declaration in the
<b>prolog</b>; as defined in <a href="http://www.w3.org/TR/xquery/#id-query-prolog">Section 
4 Modules and Prologs</a><sup><small>XQ</small></sup>).</p></li><li><p>
                  <em>Scope:</em> Indicates where the
component is applicable. "Global" indicates that the component applies
globally, throughout all the modules used in a query. "Module"
indicates that the component applies throughout a <b>module</b>
(as defined in <a href="http://www.w3.org/TR/xquery/#id-query-prolog">Section 
4 Modules and Prologs</a><sup><small>XQ</small></sup>). "Lexical" indicates that the
component applies within the expression in which it is defined
(equivalent to "module", if the component is declared in a
prolog.)</p></li><li><p>
                  <em>Consistency
Rules:</em> Indicates rules that must be observed in assigning
values to the component. </p></li></ul><div class="small"><table width="100%" border="1" summary="Static Context" class="small"><caption>Static Context Components</caption><tbody><tr><th colspan="1">Component</th><th colspan="1">Default initial value</th><th colspan="1">Can be
overwritten or augmented by implementation?</th><th colspan="1">Can be
overwritten or augmented by a query?</th><th colspan="1">Scope</th><th colspan="1">Consistency rules</th></tr><tr><td>
                     <a href="#ftcaseoption">FTCaseOption</a>
                  </td><td>
                     <code>case
insensitive</code>
                  </td><td>overwriteable</td><td>overwriteable by prolog</td><td>lexical</td><td>Value must be
<code>case insensitive</code>, <code>case sensitive</code>, 
<code>lowercase</code>, or <code>uppercase</code>.</td></tr><tr><td>
                     <a href="#ftdiacriticsoption">FTDiacriticsOption</a>
                  </td><td>
                     <code>diacritics insensitive</code>
                  </td><td>overwriteable</td><td>overwriteable by prolog</td><td>lexical</td><td>Value must be <code>diacritics insensitive</code> or
<code>diacritics sensitive</code>.</td></tr><tr><td>
                     <a href="#ftstemoption">FTStemOption</a>
                  </td><td>
                     <code>no stemming</code>
                  </td><td>overwriteable</td><td>overwriteable by prolog</td><td>lexical</td><td>Value must be <code>stemming</code> or
<code>no stemming</code>.</td></tr><tr><td>
                     <a href="#ftthesaurusoption">FTThesaurusOption</a>
                  </td><td>
                     <code>no thesaurus</code>
                  </td><td>overwriteable</td><td>overwriteable by prolog (refer to default to augment)</td><td>lexical</td><td>Each URI in the value must be found in the
statically known thesauri.</td></tr><tr><td>Statically known thesauri</td><td>none</td><td>augmentable</td><td>cannot be augmented or overwritten by prolog</td><td>module</td><td> Each URI uniquely identifies a thesaurus list.</td></tr><tr><td>
                     <a href="#ftstopwordoption">FTStopWordOption</a>
                  </td><td>
                     <code>no stop words</code>
                  </td><td>overwriteable</td><td>overwriteable by prolog (refer to default to augment)</td><td>lexical</td><td>Each URI in the value must be found in the statically known stop
word lists.</td></tr><tr><td>Statically known stop word lists</td><td>none</td><td>augmentable</td><td>cannot be augmented or overwritten by prolog</td><td>module</td><td>Each URI uniquely identifies a stop word list.</td></tr><tr><td>
                     <a href="#ftlanguageoption">FTLanguageOption</a>
                  </td><td>
                     <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>
                  </td><td>overwriteable</td><td>overwriteable by prolog</td><td>lexical</td><td>Value must be castable to <code>xs:language</code>.</td></tr><tr><td>Statically known languages</td><td>none</td><td>augmentable</td><td>cannot be augmented or overwritten by prolog</td><td>module</td><td>Each string uniquely identifies a language.</td></tr><tr><td>
                     <a href="#ftwildcardoption">FTWildCardOption</a>
                  </td><td>
                     <code>no wildcards</code>
                  </td><td>no</td><td>overwriteable by prolog</td><td>lexical</td><td>Value must be <code>wildcards</code> or <code>no
wildcards</code>.</td></tr></tbody></table></div></div><div class="div1">
<h2><a name="id-errors" id="id-errors"/>D Error Conditions</h2><dl><dt><a name="ERRFTST0001"/>err:FTST0001</dt><dd><p>
An implementation that does not support the FTMildNot operator must raise 
a static error if a full-text query contains a mild not.</p></dd><dt><a name="ERRFTST0002"/>err:FTST0002</dt><dd><p>
An implementation that enforces one of the restrictions on FTUnaryNot must
raise a static error if a full-text query does not obey the restriction.</p></dd><dt><a name="ERRFTST0003"/>err:FTST0003</dt><dd><p>
An implementation that does not support one or more of the choices on FTUnit
and FTBigUnit must
raise a static error if a full-text query contains one of those choices.</p></dd><dt><a name="ERRFTST0004"/>err:FTST0004</dt><dd><p>
An implementation that does not support the FTScope operator must raise
a static error if a full-text query contains a scope.</p></dd><dt><a name="ERRFTST0005"/>err:FTST0005</dt><dd><p>
An implementation that does not support the FTTimes operator must raise
a static error if a full-text query contains a times.</p></dd><dt><a name="ERRFTST0006"/>err:FTST0006</dt><dd><p>
An implementation that restricts the use of FTStopWordOption must raise
a static error if a full-text query contains a stop word option that does not
meet the restriction.</p></dd><dt><a name="ERRFTST0007"/>err:FTST0007</dt><dd><p>
An implementation that restricts the use of FTIgnoreOption must raise
a static error if a full-text query contains an ignore option that does not
meet the restriction.</p></dd><dt><a name="ERRFTST0008"/>err:FTST0008</dt><dd><p>It is a static error if, during the static analysis phase, the query is
found to contain a stop word option that refers to a stop word list that is not
found in the statically known stop word lists.
</p></dd><dt><a name="ERRFTST0009"/>err:FTST0009</dt><dd><p>It may be a static error if, during the static analysis phase, the query is
found to contain a language identifier in a language option that the
implementation does not support. The implementation may choose not to raise
this error and instead provide some other implementation-defined behavior.
</p></dd><dt><a name="ERRFTST0010"/>err:FTST0010</dt><dd><p>It is a static error if, during the static analysis phase,
an expression is found to use an FTOrder operator that does not appear
directly succeeding an FTWindow or an FTDistance operator and the
implementation enforces this restriction.
</p></dd><dt><a name="ERRFTST0011"/>err:FTST0011</dt><dd><p>An implementation may restrict the use of FTWindow and FTDistance to an FTOr
that is either a single FTWords or a combination of FTWords involving
only the operators <span class="diff-chg">ftand and ftor</span>. 
If it a static error if, during the
static analysis phase, an expression is found that violates this restriction
and the implementation enforces this restriction.
</p></dd><dt><a name="ERRFTST0012"/>err:FTST0012</dt><dd><p>
An implementation that does not support the FTContent operator must raise
a static error if a full-text query contains one.
</p></dd><dt><a name="ERRFTST0013"/>err:FTST0013</dt><dd><p>
It is a static error if, during the static analysis phase, 
an implementation that restricts the use of FTLanguageOption to a single
language, encounters more than one distinct language option.
</p></dd><dt><a name="ERRFTST0014"/>err:FTST0014</dt><dd><p>An implementation may constrain the form of the expression used to compute
scores. It is a static error if, during the static analysis phase, 
such an implementation encounters a scoring expression that does not meet
the restriction.
</p></dd><dt><a name="ERRFTST0015"/>err:FTST0015</dt><dd><p>
It is a static error if, during the static analysis phase, 
an implementation that restricts the choices of FTCaseOption
encounters the "lowercase" or "uppercase" option.
</p></dd><dt><a name="ERRFTDY0016"/>err:FTDY0016</dt><dd><p>
It is a dynamic error if a weight value is not within the required range of values;
it is also a dynamic error if an implementation that does not support negative weights
encounters a negative weight value. 
</p></dd><dt><a name="ERRFTDY0017"/>err:FTDY0017</dt><dd><p>
It is a dynamic error if an implementation encounters a mild not 
selection, one of whose operands evaluates to an <b>AllMatches</b> that contains a
<b>StringExclude</b> 
               </p></dd><dt><a name="ERRFTST0018"/>err:FTST0018</dt><dd><p>
It is a static error if, during the static analysis phase, the query is found
to contain a thesaurus option that refers to a thesaurus that is not found in
the statically known thesauri.
</p></dd><dt><a name="ERRFTST0019"/>err:FTST0019</dt><dd><p>
It is a static error if,
within a single <a href="#doc-xquery10-FTMatchOptions">FTMatchOptions</a>,
there is more than one match option of any given 
<a title="match option group" href="#dt-match-option-group">match option group</a>.
</p></dd><dt><a name="ERRFTDY0020"/>err:FTDY0020</dt><dd><p>
It is a dynamic error if,
when "wildcards" is in effect,
a query string violates wildcard syntax.
</p></dd><dt><a name="ERRFOCH0002"/>err:FOCH0002</dt><dd><p>It is a dynamic error if, in a function invocation, the argument corresponding to
the specified function's collation parameter does not identify a supported collation.</p></dd><dt><a name="ERRXPST0003"/>err:XPST0003</dt><dd><p>It is a static error if an expression is not a valid instance of the grammar defined in
<a href="#id-grammar"><b>A EBNF for XQuery 1.0 Grammar with Full Text extensions</b></a> or of the grammar defined in <a href="#id-xpath-grammar"><b>B EBNF for XPath 2.0 Grammar with Full-Text
		extensions</b></a>.</p></dd><dt><a name="ERRXPTY0004"/>err:XPTY0004</dt><dd><p>It is a type error if, during the static analysis phase,
an expression is found to have a static type
that is not appropriate for the context in which the expression occurs, or during the
dynamic evaluation phase, the dynamic type of a value does not match a required type as
specified by the matching rules in <a href="http://www.w3.org/TR/xpath20/#id-sequencetype-matching">Section 
2.5.4 SequenceType Matching</a><sup><small>XP</small></sup>.</p></dd><dt><a name="ERRXQST0013"/>err:XQST0013</dt><dd><p>It is a static error if an implementation recognizes a pragma but determines that its content is invalid.</p></dd><dt><a name="ERRXQST0079"/>err:XQST0079</dt><dd><p>It is a static error if an extension expression contains neither
   a pragma that is recognized by the implementation nor
   an expression enclosed in curly braces.</p></dd></dl></div><div class="div1">
<h2><a name="id-xqft-xqueryx" id="id-xqft-xqueryx"/>E XML Syntax (XQueryX) for XQuery and XPath Full Text 1.0</h2><p>
            <a href="#xqueryx">[XML Syntax for XQuery 1.0 (XQueryX) (Second Edition)]</a> defines an XML representation of <a href="#xquery">[XQuery 1.0: An XML Query Language (Second Edition)]</a>. 
<a href="#xpath-full-text-10-requirements">[XQuery and XPath Full Text 1.0 Requirements]</a>, section 5.4, XML Syntax, states
"XQuery and XPath Full Text MAY have more than one syntax binding. 
One query language syntax MUST be expressed in XML in a way that
reflects the underlying structure of the query. See XML Query Requirements."
This appendix specifies XML Schemas that together define the
XML representation of XQuery and XPath Full Text 1.0 by representing the abstract syntax
found in <a href="#id-grammar"><b>A EBNF for XQuery 1.0 Grammar with Full Text extensions</b></a>.  Because XQuery and XPath Full Text 1.0
integrates seamlessly with XQuery 1.0,
it follows that the XML Syntax for XQuery and XPath Full Text 1.0 must integrate well
with the XML Syntax for XQuery 1.0. 
</p><p>
The XML Schema specified in this appendix accomplishes integration by importing
the XML Schema defined for XQueryX in <a href="http://www.w3.org/TR/xqueryx/#Schema">Section 
4 An XML Schema for the XQuery XML Syntax</a><sup><small>XQX</small></sup>,
incorporating all of its type and element definitions. 
It then extends that schema by adding definitions of new types and elements
in a namespace belonging to the full-text specification. 
</p><p>
The semantics of a Full Text XQueryX document are determined by the
semantics of the XQuery Full Text expression that
results from transforming the XQueryX document into XQuery Full Text
syntax using the XSLT stylesheet that appears in
section <a href="#id-xqft-full-text-stylesheet"><b>E.2 XQueryX stylesheet for XQuery and XPath Full Text 1.0</b></a>. 
The "correctness" of that transformation is determined by
asking the following the question:
Can some Full Text XQueryX processor QX process some
Full Text XQueryX document D1 to produce results R1,
after which the stylesheet is used to translate D1 into an
XQuery Full Text expression E1 that, when processed by some
XQuery Full Text processor Q, produces results R2 that are equivalent
(under some meaningful definition of "equivalent") to results R1?
</p><div class="div2">
<h3><a name="id-xqft-full-text-schema" id="id-xqft-full-text-schema"/>E.1 XQueryX representation of XQuery and XPath Full Text 1.0</h3><p>
The XML Schema that defines the complex types and elements
for XQueryX in support of XQuery and XPath Full Text 1.0, including the ftContainsExpr,
incorporates a second XML Schema that defines
types and elements to support the ftMatchOption. 
Both XML Schemas are defined in this section. 
</p><div class="exampleInner"><pre>

&lt;xsd:schema
     xmlns:xsd="http://www.w3.org/2001/XMLSchema"
     xmlns:xqx="http://www.w3.org/2005/XQueryX"
     xmlns:xqxft="http://www.w3.org/2007/xpath-full-text"
     targetNamespace="http://www.w3.org/2007/xpath-full-text"
     elementFormDefault="qualified"
     attributeFormDefault="unqualified"&gt;

&lt;!-- Initial creation                            2006-08-17: Jim Melton    --&gt;
&lt;!-- Added ftOptionDecl, ftScoreVariableBinding  2006-08-21: Jim Melton    --&gt;
&lt;!-- First version believed complete             2006-08-29: Jim Melton    --&gt;
&lt;!-- Cleaned up naming                           2007-04-27: Mary Holstege --&gt;
&lt;!-- Revised to align with updated syntax        2008-01-14: Jim Melton    --&gt;
&lt;!-- Moved ftOptionDecl: prolog part two to one  2008-01-24: Jim Melton    --&gt;
&lt;!-- Revised position of "weight" in grammar     2008-11-12: Jim Melton    --&gt;

  &lt;xsd:import namespace="http://www.w3.org/2005/XQueryX"
              schemaLocation="http://www.w3.org/2005/XQueryX/xqueryx.xsd"/&gt;

  &lt;xsd:include schemaLocation="./xpath-full-text-10-xqueryx-ftmatchoption-extensions.xsd"/&gt;

  &lt;xsd:element name="ftOptionDecl" substitutionGroup="xqx:prologPartOneItem"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence minOccurs="1" maxOccurs="unbounded"&gt;
        &lt;xsd:element ref="xqxft:ftMatchOption"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;


  &lt;!-- Create a new substitution group for full-text expressions           --&gt;
  &lt;xsd:complexType name="ftExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqx:expr"/&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftExpr" type="xqxft:ftExpr" abstract="true" substitutionGroup="xqx:expr"/&gt;


  &lt;!-- Represents an untyped variable for the "score" clause               --&gt;
  &lt;xsd:element name="ftScoreVariableBinding" type="xqx:QName"
               substitutionGroup="xqx:forLetClauseItemExtensions"/&gt;



  &lt;!-- FTContains ("contains text")                                        --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTContainsExpr ::=                                                --&gt;
  &lt;!--     RangeExpr ( "contains" "text" FTSelection FTIgnoreOption? )?    --&gt;
  &lt;xsd:complexType name="ftContainsExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="ftRangeExpr"
                       type="xqx:exprWrapper" /&gt;
          &lt;xsd:sequence minOccurs="0" maxOccurs="1"&gt;
            &lt;xsd:element name="ftSelectionExpr"
                         type="xqxft:ftSelectionWrapper" /&gt;
            &lt;xsd:element name="ftIgnoreOption"
                         type="xqxft:ftIgnoreOption"
                         minOccurs="0" maxOccurs="1" /&gt;
          &lt;/xsd:sequence&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftContainsExpr" type="xqxft:ftContainsExpr" substitutionGroup="xqxft:ftExpr" /&gt;


  &lt;!-- FTProximity                                                         --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTPosFilter ::=                                                   --&gt;
  &lt;!--     FTOrder | FTWindow | FTDistance | FTScope | FTContent           --&gt;
  &lt;xsd:complexType name="ftProximity" /&gt;

  &lt;xsd:element name="ftProximity" type="xqxft:ftProximity" abstract="true"/&gt;


  &lt;!-- some simple type definitions                                        --&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTUnit ::= "words" | "sentences" | "paragraphs"                   --&gt;
  &lt;xsd:simpleType name="ftUnit"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="paragraph"/&gt;
      &lt;xsd:enumeration value="sentence"/&gt;
      &lt;xsd:enumeration value="word"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTBigUnit ::= "sentence" | "paragraph"                            --&gt;
  &lt;xsd:simpleType name="ftBigUnit"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="paragraph"/&gt;
      &lt;xsd:enumeration value="sentence"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTContent ::= ("at" "start") | ("at" "end") | ("entire" "content")--&gt;
  &lt;xsd:simpleType name="contentLocation"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="at start"/&gt;
      &lt;xsd:enumeration value="at end"/&gt;
      &lt;xsd:enumeration value="entire content"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTScope ::= ("same" | "different") FTBigUnit                      --&gt;
  &lt;xsd:simpleType name="ftScopeType"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="same"/&gt;
      &lt;xsd:enumeration value="different"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;


  &lt;!-- range-related definitions                                           --&gt;
  &lt;xsd:complexType name="unaryRange"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="value" type="xqx:exprWrapper" /&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:complexType name="binaryRange"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="lower" type="xqx:exprWrapper" /&gt;
      &lt;xsd:element name="upper" type="xqx:exprWrapper" /&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:complexType name="unaryLiteralRange"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="value" type="xsd:integer" /&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:complexType name="binaryLiteralRange"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="lower" type="xsd:integer" /&gt;
      &lt;xsd:element name="upper" type="xsd:integer" /&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTRange ::= ("exactly" AdditiveExpr)                              --&gt;
  &lt;!--             | ("at" "least" AdditiveExpr)                           --&gt;
  &lt;!--             | ("at" "most" AdditiveExpr)                            --&gt;
  &lt;!--             | ("from" AdditiveExpr "to" AdditiveExpr)               --&gt;
  &lt;xsd:complexType name="ftRange"&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element name="atLeastRange" type="xqxft:unaryRange" /&gt;
      &lt;xsd:element name="atMostRange" type="xqxft:unaryRange" /&gt;
      &lt;xsd:element name="exactlyRange" type="xqxft:unaryRange" /&gt;
      &lt;xsd:element name="fromToRange" type="xqxft:binaryRange" /&gt;
    &lt;/xsd:choice&gt;
  &lt;/xsd:complexType&gt;


  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTLiteralRange ::= ("exactly" IntegerLiteral)                     --&gt;
  &lt;!--                    | ("at" "least" IntegerLiteral)                  --&gt;
  &lt;!--                    | ("at" "most" IntegerLiteral)                   --&gt;
  &lt;!--                    | ("from" IntegerLiteral "to" IntegerLiteral)    --&gt;
  &lt;xsd:complexType name="ftLiteralRange"&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element name="atLeastLiteralRange" type="xqxft:unaryLiteralRange" /&gt;
      &lt;xsd:element name="atMostLiteralRange" type="xqxft:unaryLiteralRange" /&gt;
      &lt;xsd:element name="exactlyLiteralRange" type="xqxft:unaryLiteralRange" /&gt;
      &lt;xsd:element name="fromToLiteralRange" type="xqxft:binaryLiteralRange" /&gt;
    &lt;/xsd:choice&gt;
  &lt;/xsd:complexType&gt;


  &lt;!-- ftPosFilter alternative: ordered                                    --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTOrder ::= "ordered"                                             --&gt;
  &lt;xsd:complexType name="ftOrdered"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftProximity"&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftOrdered" type="xqxft:ftOrdered" substitutionGroup="xqxft:ftProximity"/&gt;


  &lt;!-- ftPosFilter alternative: window                                     --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTWindow ::= "window" AdditiveExpr FTUnit                         --&gt;
  &lt;xsd:complexType name="ftWindow"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftProximity"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value" type="xqx:exprWrapper" /&gt;
          &lt;xsd:element name="unit" type="xqxft:ftUnit" /&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftWindow" type="xqxft:ftWindow" substitutionGroup="xqxft:ftProximity"/&gt;


  &lt;!-- ftPosFilter alternative: distance                                   --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTDistance ::= "distance" FTRange FTUnit                          --&gt;
  &lt;xsd:complexType name="ftDistance"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftProximity"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="ftRange" type="xqxft:ftRange" /&gt;
          &lt;xsd:element name="unit" type="xqxft:ftUnit" /&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftDistance" type="xqxft:ftDistance" substitutionGroup="xqxft:ftProximity"/&gt;

  &lt;!-- ftPosFilter alternative: scope                                      --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;xsd:complexType name="ftScope"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftProximity"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="type" type="xqxft:ftScopeType" /&gt;
          &lt;xsd:element name="unit" type="xqxft:ftBigUnit" /&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftScope" type="xqxft:ftScope" substitutionGroup="xqxft:ftProximity"/&gt;

  &lt;!-- ftPosFilter alternative: FTContent                                  --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;xsd:complexType name="ftContent"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftProximity"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="location" type="xqxft:contentLocation" /&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftContent" type="xqxft:ftContent" substitutionGroup="xqxft:ftProximity"/&gt;


  &lt;!-- ftPosFilter                                                         --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTPosFilter ::=                                                   --&gt;
  &lt;!--     FTOrder | FTWindow | FTDistance | FTScope | FTContent           --&gt;
  &lt;xsd:complexType name="ftPosFilter"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftExpr"&gt;
        &lt;xsd:sequence minOccurs="0" maxOccurs="unbounded"&gt;
          &lt;xsd:element ref="xqxft:ftProximity" /&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;


  &lt;!-- FTSelection                                                         --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTSelection ::= FTOr FTPosFilter*                                 --&gt;
  &lt;xsd:complexType name="ftSelection" &gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="ftSelectionSource" type="xqx:exprWrapper"/&gt;
          &lt;xsd:element name="ftPosFilter"
                       type="xqxft:ftPosFilter"
                       minOccurs="0" maxOccurs="1" /&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftSelection" type="xqxft:ftSelection" substitutionGroup="xqxft:ftExpr" /&gt;


  &lt;xsd:complexType name="ftSelectionWrapper"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="xqxft:ftSelection"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;


  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTIgnoreOption ::= "without" "content" UnionExpr                  --&gt;
  &lt;xsd:complexType name="ftIgnoreOption"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="xqx:expr"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;


  &lt;!-- Full-Text logical operators                                         --&gt;
  &lt;xsd:element name="ftLogicalOp" type="xqx:binaryOperatorExpr" abstract="true"
               substitutionGroup="xqx:operatorExpr"/&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTOr ::= FTAnd ( "ftor" FTAnd )*                                  --&gt;
  &lt;xsd:element name="ftOr" type="xqx:binaryOperatorExpr"
               substitutionGroup="xqxft:ftLogicalOp"/&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTAnd ::= FTMildNot ( "ftand" FTMildNot )*                        --&gt;
  &lt;xsd:element name="ftAnd" type="xqx:binaryOperatorExpr"
               substitutionGroup="xqxft:ftLogicalOp"/&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   	FTMildNot ::= FTUnaryNot ( "not" "in" FTUnaryNot )*              --&gt;
  &lt;xsd:element name="ftMildNot" type="xqx:binaryOperatorExpr"
               substitutionGroup="xqxft:ftLogicalOp"/&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;xsd:element name="ftLogicalNot" type="xqx:unaryOperatorExpr" abstract="true"
               substitutionGroup="xqx:operatorExpr"/&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTUnaryNot ::= ("ftnot")? FTPrimaryWithOptions                    --&gt;
  &lt;xsd:element name="ftUnaryNot" type="xqx:unaryOperatorExpr"
               substitutionGroup="xqxft:ftLogicalNot"/&gt;


  &lt;!-- Definitions associated with FTWords                                 --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTTimes ::= "occurs" FTRange "times"                              --&gt;
  &lt;xsd:complexType name="ftTimes"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="ftRange" type="xqxft:ftRange"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--  FTAnyallOption ::= ("any" "word"?) | ("all" "words"?) | "phrase"   --&gt;
  &lt;xsd:simpleType name="ftAnyAllOption"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="any"/&gt;
      &lt;xsd:enumeration value="all"/&gt;
      &lt;xsd:enumeration value="any word"/&gt;
      &lt;xsd:enumeration value="all words"/&gt;
      &lt;xsd:enumeration value="phrase"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTWordsValue ::= StringLiteral | ("{" Expr "}")                         --&gt;
  &lt;xsd:complexType name="ftWordsAlternatives"&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element name="ftWordsLiteral" type="xqx:exprWrapper"/&gt;
      &lt;xsd:element name="ftWordsExpression" type="xqx:exprWrapper"/&gt;
    &lt;/xsd:choice&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTWords ::= FTWordsValue FTAnyallOption?                          --&gt;
  &lt;xsd:complexType name="ftWords"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="ftWordsValue" type="xqxft:ftWordsAlternatives" /&gt;
      &lt;xsd:element name="ftAnyAllOption" type="xqxft:ftAnyAllOption"
                   minOccurs="0" maxOccurs="1" /&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--  ... FTWordsValue FTAnyallOption?                                   --&gt;
  &lt;xsd:group name="ftWordsWithTimes"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="ftWords" type="xqxft:ftWords" /&gt;
      &lt;xsd:element name="ftTimes" type="xqxft:ftTimes" minOccurs="0" /&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:group&gt;


  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTExtensionSelection ::= Pragma+ "{" FTSelection? "}"             --&gt;
  &lt;xsd:complexType name="ftExtensionSelection"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="pragma" type="xqx:pragma"
                   minOccurs="1" maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="ftSelection" type="xqxft:ftSelection"
                   minOccurs="0" maxOccurs="1"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTPrimary ::= (FTWords FTTimes?)                                  --&gt;
  &lt;!--               | ("(" FTSelection ")")                               --&gt;
  &lt;!--               | FTExtensionSelection                                --&gt;
  &lt;xsd:complexType name="ftPrimary"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftExpr" &gt;
        &lt;xsd:choice&gt;
          &lt;xsd:element name="parenthesized" type="xqx:exprWrapper"/&gt;
          &lt;xsd:group ref="xqxft:ftWordsWithTimes" /&gt;
          &lt;xsd:element name="ftExtensionSelection" type="xqxft:ftExtensionSelection"/&gt;
        &lt;/xsd:choice&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTPrimaryWithOptions ::= FTPrimary FTMatchOptions? FTWeight?      --&gt;
  &lt;xsd:complexType name="ftPrimaryWithOptions"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="ftPrimary" type="xqxft:ftPrimary"/&gt;
          &lt;xsd:element ref="xqxft:ftMatchOptions"
                       minOccurs="0" maxOccurs="1"/&gt;
          &lt;xsd:element name="weight"
                       type="xqx:exprWrapper"
                       minOccurs="0" maxOccurs="1" /&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftPrimaryWithOptions" type="xqxft:ftPrimaryWithOptions"
               substitutionGroup="xqxft:ftExpr"/&gt;

&lt;/xsd:schema&gt;


</pre></div><div class="exampleInner"><pre>

&lt;xsd:schema
     xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
     xmlns:xqx="http://www.w3.org/2005/XQueryX"
     xmlns:xqxft="http://www.w3.org/2007/xpath-full-text"
     targetNamespace="http://www.w3.org/2007/xpath-full-text"
     elementFormDefault="qualified" 
     attributeFormDefault="unqualified"&gt;

&lt;!-- Initial creation                         2006-08-17: Jim Melton       --&gt;
&lt;!-- First version believed complete          2006-08-29: Jim Melton       --&gt;
&lt;!-- Cleaned up naming                        2007-04-27: Mary Holstege    --&gt;     
&lt;!-- Revised to align with updated syntax     2008-01-14: Jim Melton       --&gt;
&lt;!-- Comments added to clarify each element   2008-11-12: Jim Melton       --&gt;
&lt;!-- Add element decl for ftMatchOptions      2009-07-06: Michael Dyck     --&gt;
&lt;!-- Fixed FTThesaurus for ftLiteralRange     2011-03-08: Jim Melton       --&gt;

  &lt;xsd:import namespace="http://www.w3.org/2005/XQueryX"
              schemaLocation="http://www.w3.org/2005/XQueryX/xqueryx.xsd"/&gt;

  &lt;!-- FTMatchOption                                                       --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTMatchOption ::= FTLanguageOption                                --&gt;
  &lt;!--                   | FTWildCardOption                                --&gt;
  &lt;!--                   | FTThesaurusOption                               --&gt;
  &lt;!--                   | FTStemOption                                    --&gt;
  &lt;!--                   | FTCaseOption                                    --&gt;
  &lt;!--                   | FTDiacriticsOption                              --&gt;
  &lt;!--                   | FTStopWordOption                                --&gt;
  &lt;!--                   | FTExtensionOption                               --&gt;
  &lt;xsd:complexType name="ftMatchOption" /&gt;

  &lt;xsd:element name="ftMatchOption" type="xqxft:ftMatchOption"
               abstract="true" /&gt;
  

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTMatchOptions ::= ( "using" FTMatchOption )+                     --&gt;
  &lt;xsd:complexType name="ftMatchOptions"&gt;
    &lt;xsd:sequence minOccurs="1" maxOccurs="unbounded"&gt;
      &lt;xsd:element ref="xqxft:ftMatchOption"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftMatchOptions" type="xqxft:ftMatchOptions"/&gt;
  

  &lt;!-- ftMatchOption alternative: case                                     --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTCaseOption ::= ("case" "insensitive")                           --&gt;
  &lt;!--                  | ("case" "sensitive")                             --&gt;
  &lt;!--                  | "lowercase"                                      --&gt;
  &lt;!--                  | "uppercase"                                      --&gt;
  &lt;xsd:complexType name="ftCaseOption"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftMatchOption" &gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value"&gt;
            &lt;xsd:simpleType&gt;
              &lt;xsd:restriction base="xsd:string"&gt;
                &lt;xsd:enumeration value="lowercase"/&gt;
                &lt;xsd:enumeration value="uppercase"/&gt;
                &lt;xsd:enumeration value="case sensitive"/&gt;
                &lt;xsd:enumeration value="case insensitive"/&gt;
              &lt;/xsd:restriction&gt;
            &lt;/xsd:simpleType&gt;
          &lt;/xsd:element&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="case" type="xqxft:ftCaseOption"
               substitutionGroup="xqxft:ftMatchOption" /&gt;


  &lt;!-- ftMatchOption alternative: diacritics                               --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTDiacriticsOption ::= ("diacritics" "insensitive")               --&gt;
  &lt;!--                        | ("diacritics" "sensitive")                 --&gt;
  &lt;xsd:complexType name="ftDiacriticsOption"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftMatchOption" &gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value"&gt;
            &lt;xsd:simpleType&gt;
              &lt;xsd:restriction base="xsd:string"&gt;
                &lt;xsd:enumeration value="diacritics sensitive"/&gt;
                &lt;xsd:enumeration value="diacritics insensitive"/&gt;
              &lt;/xsd:restriction&gt;
            &lt;/xsd:simpleType&gt;
          &lt;/xsd:element&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;
  
  &lt;xsd:element name="diacritics" type="xqxft:ftDiacriticsOption"
               substitutionGroup="xqxft:ftMatchOption" /&gt;


  &lt;!-- ftMatchOption alternative: stemming                                 --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTStemOption ::= ("stemming") | ("no" "stemming")                 --&gt;
  &lt;xsd:complexType name="ftStemOption"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftMatchOption" &gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value"&gt;
            &lt;xsd:simpleType&gt;
              &lt;xsd:restriction base="xsd:string"&gt;
                &lt;xsd:enumeration value="stemming" /&gt; 
                &lt;xsd:enumeration value="no stemming" /&gt; 
              &lt;/xsd:restriction&gt;
            &lt;/xsd:simpleType&gt;
          &lt;/xsd:element&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;
  
  &lt;xsd:element name="stem" type="xqxft:ftStemOption"
               substitutionGroup="xqxft:ftMatchOption" /&gt;


  &lt;!-- ftMatchOption alternative: thesaurus                                --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTThesaurusID ::= "at" URILiteral ("relationship" StringLiteral)? --&gt;
  &lt;!--                     (FTLiteralRange "levels")?                      --&gt;
  &lt;xsd:complexType name="ftThesaurusID"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="at" type="xsd:anyURI" /&gt;
      &lt;xsd:element name="relationship" type="xsd:string" minOccurs="0" /&gt;
      &lt;xsd:element name="levels" type="xqxft:ftLiteralRange" minOccurs="0" /&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   ... (FTThesaurusID | "default")                                   --&gt;
  &lt;!--   ... "(" (FTThesaurusID | "default") ("," FTThesaurusID)* ")")     --&gt;
  &lt;xsd:complexType name="thesaurusSpecSequence"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:choice&gt;
        &lt;xsd:element name="default" /&gt;
        &lt;xsd:element name="thesaurusID"
                     type="xqxft:ftThesaurusID" /&gt;
      &lt;/xsd:choice&gt;
      &lt;xsd:element name="thesaurusID" type="xqxft:ftThesaurusID"
                   minOccurs="0" maxOccurs="unbounded" /&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTThesaurusOption ::=                                             --&gt;
  &lt;!--       ("thesaurus" (FTThesaurusID | "default"))                     --&gt;
  &lt;!--     | ("thesaurus"                                                  --&gt;
  &lt;!--          "(" (FTThesaurusID | "default") ("," FTThesaurusID)* ")")  --&gt;
  &lt;!--     | ("no" "thesaurus")                                            --&gt;
  &lt;xsd:complexType name="ftThesaurusOption"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftMatchOption" &gt;
        &lt;xsd:choice&gt;
          &lt;xsd:element name="noThesauri" /&gt;
          &lt;xsd:element name="thesauri" type="xqxft:thesaurusSpecSequence" /&gt;
        &lt;/xsd:choice&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="thesaurus" type="xqxft:ftThesaurusOption"
               substitutionGroup="xqxft:ftMatchOption" /&gt;


  &lt;!-- ftMatchOption alternative: stopwords                                --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--     FTStopWords ::= ("at" URILiteral)                               --&gt;
  &lt;!--   | ("(" StringLiteral ("," StringLiteral)* ")")                    --&gt;
  &lt;xsd:complexType name="ftStopWords"&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element name="ref" type="xsd:anyURI" /&gt;
      &lt;xsd:element name="list"&gt;
        &lt;xsd:complexType&gt;
          &lt;xsd:sequence&gt;
            &lt;xsd:element ref="xqx:stringConstantExpr"
                         minOccurs="1" maxOccurs="unbounded" /&gt;
          &lt;/xsd:sequence&gt;
        &lt;/xsd:complexType&gt;
      &lt;/xsd:element&gt;
    &lt;/xsd:choice&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftStopWords" type="xqxft:ftStopWords" /&gt;


  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   ... "stop" "words" FTStopWords ...                                --&gt;
  &lt;!--   ... "stop" "words" "default" ...                                  --&gt;
  &lt;xsd:group name="baseStopWords"&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element name="default" /&gt;
      &lt;xsd:element ref="xqxft:ftStopWords" /&gt;
    &lt;/xsd:choice&gt;
  &lt;/xsd:group&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTStopWordsInclExcl ::= ("union" | "except") FTStopWords          --&gt;
  &lt;xsd:complexType name="ftStopWordsInclExcl"&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element name="union" type="xqxft:ftStopWords" /&gt;
      &lt;xsd:element name="except" type="xqxft:ftStopWords" /&gt;
    &lt;/xsd:choice&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   ... ("using" "stop" "words" FTStopWords FTStopWordsInclExcl*) ... --&gt;
  &lt;!--   ... ("using" "default" "stop" "words" FTStopWordsInclExcl*) ...   --&gt;
  &lt;xsd:complexType name="stopWordsSpecSequence"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:group ref="xqxft:baseStopWords" /&gt;
      &lt;xsd:element name="ftStopWordsInclExcl"
                   type="xqxft:ftStopWordsInclExcl"
                   minOccurs="0" maxOccurs="unbounded" /&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTStopWordOption ::=                                              --&gt;
  &lt;!--       ("stop" "words" FTStopWords FTStopWordsInclExcl*)             --&gt;
  &lt;!--     | ("stop" "words" "default" FTStopWordsInclExcl*)               --&gt;
  &lt;!--     | ("no" "stop" "words")                                         --&gt;
  &lt;xsd:complexType name="ftStopWordOption"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftMatchOption" &gt;
        &lt;xsd:choice&gt;
          &lt;xsd:element name="noStopwords" /&gt;
          &lt;xsd:element name="stopwords" type="xqxft:stopWordsSpecSequence" /&gt;
        &lt;/xsd:choice&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="stopword" type="xqxft:ftStopWordOption"
               substitutionGroup="xqxft:ftMatchOption" /&gt;


  &lt;!-- ftMatchOption alternative: language                                 --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTLanguageOption ::= "language" StringLiteral                     --&gt;
  &lt;xsd:complexType name="ftLanguageOption"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftMatchOption" &gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value" type="xsd:string" /&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="language" type="xqxft:ftLanguageOption"
               substitutionGroup="xqxft:ftMatchOption" /&gt;


  &lt;!-- ftMatchOption alternative: wildcards                                --&gt;
  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTWildCardOption ::= ("wildcards")                                --&gt;
  &lt;!--                      | ("no" "wildcards")                           --&gt;
  &lt;xsd:complexType name="ftWildCardOption"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftMatchOption"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value"&gt;
            &lt;xsd:simpleType&gt;
              &lt;xsd:restriction base="xsd:string"&gt;
                &lt;xsd:enumeration value="wildcards" /&gt; 
                &lt;xsd:enumeration value="no wildcards" /&gt;
              &lt;/xsd:restriction&gt;
            &lt;/xsd:simpleType&gt;
          &lt;/xsd:element&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="wildcard" type="xqxft:ftWildCardOption"
               substitutionGroup="xqxft:ftMatchOption" /&gt;


  &lt;!-- Represents the following grammar productions:                       --&gt;
  &lt;!--   FTExtensionOption ::= "option" QName StringLiteral                --&gt;
  &lt;xsd:complexType name="ftExtensionOption"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="xqxft:ftMatchOption"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="ftExtensionName" type="xqx:QName"/&gt;
          &lt;xsd:element name="ftExtensionValue" type="xsd:string"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ftExtensionOption" type="xqxft:ftExtensionOption"
               substitutionGroup="xqxft:ftMatchOption" /&gt;

&lt;/xsd:schema&gt;


</pre></div></div><div class="div2">
<h3><a name="id-xqft-full-text-stylesheet" id="id-xqft-full-text-stylesheet"/>E.2 XQueryX stylesheet for XQuery and XPath Full Text 1.0</h3><p>
The XSLT stylesheet that defines the semantics of XQueryX
in support of XQuery and XPath Full Text 1.0 integrates seamlessly with the
XQueryX XSLT stylesheet defined in <a href="http://www.w3.org/TR/xqueryx/#Stylesheet">Section 
B Transforming XQueryX to XQuery</a><sup><small>XQX</small></sup>
by importing the XQueryX XSLT stylesheet. 
It provides additional templates that
define the semantics of the XQueryX representation of XQuery and XPath Full Text 1.0
by transforming that XQueryX representation into
the human readable syntax of XQuery and XPath Full Text 1.0. 
</p><div class="exampleInner"><pre>

&lt;?xml version='1.0'?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:xqxft="http://www.w3.org/2007/xpath-full-text"
                xmlns:xqx="http://www.w3.org/2005/XQueryX"&gt;

&lt;!-- Initial creation                            2006-08-17: Jim Melton   --&gt;
&lt;!-- Added ftOptionDecl, ftScoreVariableBinding  2006-08-21: Jim Melton   --&gt;
&lt;!-- First version believed complete             2006-08-29: Jim Melton   --&gt;
&lt;!-- Revised to align with 2008-01-24 draft      2008-02-08: Jim Melton   --&gt;
&lt;!-- Revised position of "weight" in grammar     2008-11-12: Jim Melton   --&gt;
&lt;!-- Various bug fixes                           2009-07-14: Michael Dyck --&gt;
&lt;!-- ftcontains =&gt; "contains text", Bug 7247     2009-09-17: Jim Melton   --&gt;
&lt;!-- with =&gt; using, stop words default, Bug 7271 2009-09-17: Jim Melton   --&gt;
&lt;!-- {} around weight values, around empty
     selection after pragmas                     2010-09-07: Jim Melton   --&gt;

&lt;xsl:import href="http://www.w3.org/2005/XQueryX/xqueryx.xsl"/&gt;


&lt;!-- ftOptionDecl --&gt;
&lt;xsl:template match="xqxft:ftOptionDecl"&gt;
  &lt;xsl:text&gt;declare ft-option &lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;!-- ftScoreVariableBinding --&gt;
&lt;xsl:template match="xqxft:ftScoreVariableBinding"&gt;
  &lt;xsl:text&gt; score &lt;/xsl:text&gt;
  &lt;xsl:value-of select="$DOLLAR"/&gt;
  &lt;xsl:if test="@xqx:prefix"&gt;
    &lt;xsl:value-of select="@xqx:prefix"/&gt;
    &lt;xsl:value-of select="$COLON"/&gt;
  &lt;/xsl:if&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;


&lt;!-- ftcontains --&gt;
&lt;xsl:template match="xqxft:ftContainsExpr"&gt;
  &lt;xsl:apply-templates select="xqxft:ftRangeExpr"/&gt;
  &lt;xsl:text&gt; contains text &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxft:ftSelectionExpr"/&gt;
  &lt;xsl:apply-templates select="xqxft:ftIgnoreOption"/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:value"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftRangeExpr"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftLiteralRangeExpr"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftSelectionExpr"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftIgnoreOption"&gt;
  &lt;xsl:text&gt;without content &lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftSelection"&gt;
  &lt;xsl:apply-templates select="xqxft:ftSelectionSource"/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;xsl:text&gt;    &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxft:ftPosFilter"/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftSelectionSource"&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftPosFilter"&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;xsl:text&gt;      &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;!-- FTProximity alternative: ordered --&gt;
&lt;xsl:template match="xqxft:ftOrdered"&gt;
  &lt;xsl:text&gt;ordered &lt;/xsl:text&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;

&lt;!-- FTProximity alternative: window --&gt;
&lt;xsl:template match="xqxft:ftWindow"&gt;
  &lt;xsl:text&gt;window &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxft:value"/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
  &lt;xsl:value-of select="xqxft:unit"/&gt;
  &lt;xsl:text&gt;s&lt;/xsl:text&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;

&lt;!-- FTProximity alternative: distance --&gt;
&lt;xsl:template match="xqxft:ftDistance"&gt;
  &lt;xsl:text&gt;distance &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxft:ftRange"/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
  &lt;xsl:value-of select="xqxft:unit"/&gt;
  &lt;xsl:text&gt;s&lt;/xsl:text&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;

&lt;!-- FTProximity alternative: scope --&gt;
&lt;xsl:template match="xqxft:ftScope"&gt;
  &lt;xsl:value-of select="xqxft:type"/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
  &lt;xsl:value-of select="xqxft:unit"/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;

&lt;!-- FTProximity alternative: content --&gt;
&lt;xsl:template match="xqxft:ftContent"&gt;
  &lt;xsl:value-of select="xqxft:location"/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:exactlyRange | xqxft:exactlyLiteralRange"&gt;
  &lt;xsl:text&gt;exactly &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxft:value"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:atLeastRange | xqxft:atLeastLiteralRange"&gt;
  &lt;xsl:text&gt;at least &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxft:value"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:atMostRange | xqxft:atMostLiteralRange"&gt;
  &lt;xsl:text&gt;at most &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxft:value"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:fromToRange | xqxft:fromToLiteralRange"&gt;
  &lt;xsl:text&gt;from &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxft:lower"/&gt;
  &lt;xsl:text&gt; to &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxft:upper"/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:lower"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:upper"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;!-- ftMatchOption alternative: case --&gt;
&lt;xsl:template match="xqxft:case"&gt;
  &lt;xsl:text&gt; using &lt;/xsl:text&gt;
  &lt;xsl:value-of select="xqxft:value"/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;


&lt;!-- ftMatchOption alternative: diacritics --&gt;
&lt;xsl:template match="xqxft:diacritics"&gt;
  &lt;xsl:text&gt; using &lt;/xsl:text&gt;
  &lt;xsl:value-of select="xqxft:value"/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;


&lt;!-- ftMatchOption alternative: stemming --&gt;
&lt;xsl:template match="xqxft:stem"&gt;
  &lt;xsl:text&gt; using &lt;/xsl:text&gt;
  &lt;xsl:value-of select="xqxft:value"/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;


&lt;!-- ftMatchOption alternative: thesaurus --&gt;
&lt;xsl:template match="xqxft:thesaurus"&gt;
  &lt;xsl:text&gt; using &lt;/xsl:text&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="xqxft:noThesauri"&gt;
      &lt;xsl:text&gt;no thesaurus &lt;/xsl:text&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:thesauri"&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
  &lt;xsl:text&gt;thesaurus &lt;/xsl:text&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="child::*[2]"&gt;
      &lt;xsl:call-template name="parenthesizedList"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:default"&gt;
  &lt;xsl:text&gt;default &lt;/xsl:text&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:thesaurusID"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:at"&gt;
  &lt;xsl:text&gt;at "&lt;/xsl:text&gt;
  &lt;xsl:value-of select="."/&gt;
  &lt;xsl:text&gt;" &lt;/xsl:text&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:relationship"&gt;
  &lt;xsl:text&gt;relationship "&lt;/xsl:text&gt;
  &lt;xsl:value-of select="."/&gt;
  &lt;xsl:text&gt;" &lt;/xsl:text&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:levels"&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:text&gt; levels &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;!-- ftMatchOption alternative: stopword --&gt;
&lt;xsl:template match="xqxft:stopword"&gt;
  &lt;xsl:text&gt;using &lt;/xsl:text&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="xqxft:noStopwords"&gt;
      &lt;xsl:text&gt;no stop words &lt;/xsl:text&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt; 
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:stopwords"&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="xqxft:default"&gt;
      &lt;xsl:text&gt;stop words default &lt;/xsl:text&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:text&gt;stop words &lt;/xsl:text&gt;
      &lt;xsl:apply-templates select="xqxft:ftStopWords"/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
  &lt;xsl:apply-templates select="xqxft:ftStopWordsInclExcl"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:ftStopWords"&gt;
  &lt;xsl:call-template name="ftStopWords_type"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template name="ftStopWords_type"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="xqxft:ref"&gt;
      &lt;xsl:text&gt;at "&lt;/xsl:text&gt;
      &lt;xsl:value-of select="xqxft:ref"/&gt;
      &lt;xsl:text&gt;" &lt;/xsl:text&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:list"&gt;
  &lt;xsl:call-template name="parenthesizedList"/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:FTStopWordsInclExcl"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:union"&gt;
  &lt;xsl:text&gt;union &lt;/xsl:text&gt;
  &lt;xsl:call-template name="ftStopWords_type"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="xqxft:except"&gt;
  &lt;xsl:text&gt;except &lt;/xsl:text&gt;
  &lt;xsl:call-template name="ftStopWords_type"/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:language"&gt;
  &lt;xsl:text&gt;using language "&lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:text&gt;"&lt;/xsl:text&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:wildcard"&gt;
  &lt;xsl:text&gt;using &lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:value-of select="$NEWLINE"/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftAnd"&gt;
  &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
  &lt;xsl:text&gt; ftand &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftOr"&gt;
  &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
  &lt;xsl:text&gt; ftor &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftMildNot"&gt;
  &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
  &lt;xsl:text&gt; not in &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftUnaryNot"&gt;
  &lt;xsl:text&gt;ftnot &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqx:operand"/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftPrimaryWithOptions"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftPrimary"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:parenthesized"&gt;
  &lt;xsl:text&gt;( &lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:text&gt; ) &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftWords"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftWordsValue"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftWordsLiteral"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftWordsExpression"&gt;
  &lt;xsl:text&gt; { &lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:text&gt; } &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftAnyAllOption"&gt;
  &lt;xsl:value-of select="."/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftTimes"&gt;
  &lt;xsl:text&gt;occurs &lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:text&gt; times &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftExtensionSelection"&gt;
  &lt;xsl:apply-templates select="xqxft:pragma"/&gt;
  &lt;xsl:text&gt; { &lt;/xsl:text&gt;
  &lt;xsl:apply-templates select="xqxft:ftSelection"/&gt;
  &lt;xsl:text&gt; } &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:pragma"&gt;
  &lt;xsl:value-of select="$PRAGMA_BEGIN"/&gt;
  &lt;xsl:apply-templates select="xqx:pragmaName"/&gt;
  &lt;xsl:value-of select="$SPACE"/&gt;
  &lt;xsl:value-of select="xqx:pragmaContents"/&gt;
  &lt;xsl:value-of select="$PRAGMA_END"/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftExtensionOption"&gt;
  &lt;xsl:text&gt;using option &lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftExtensionName"&gt;
  &lt;xsl:if test="@xqx:prefix"&gt;
    &lt;xsl:value-of select="@xqx:prefix"/&gt;
    &lt;xsl:value-of select="$COLON"/&gt;
  &lt;/xsl:if&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:ftExtensionValue"&gt;
  &lt;xsl:text&gt; "&lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:text&gt;"&lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;xsl:template match="xqxft:weight"&gt;
  &lt;xsl:text&gt; weight { &lt;/xsl:text&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:text&gt; } &lt;/xsl:text&gt;
&lt;/xsl:template&gt;


&lt;/xsl:stylesheet&gt;


</pre></div></div><div class="div2">
<h3><a name="id-xqft-full-text-examples" id="id-xqft-full-text-examples"/>E.3 XQueryX for XQuery and XPath Full Text 1.0 example</h3><p>
The following example is based on the data and queries of one of the use cases
in <a href="#xpath-full-text-10-use-cases">[XQuery and XPath Full Text 1.0 Use Cases]</a>. 
In this example, we show the English description of the query,
the XQuery Full Text solution given in <a href="#xpath-full-text-10-use-cases">[XQuery and XPath Full Text 1.0 Use Cases]</a>,
a Full Text XQueryX solution, and the XQuery Full Text query
that results from applying the Full Text XQueryX-to-XQuery Full Text transformation
defined by the stylesheet in <a href="#id-xqft-full-text-stylesheet"><b>E.2 XQueryX stylesheet for XQuery and XPath Full Text 1.0</b></a>
to the Full Text XQueryX solution.
The latter XQuery Full Text expression is presented only as a sanity-check —
the intent of the stylesheet is not to create the identical
XQuery Full Text expression given in <a href="#xpath-full-text-10-use-cases">[XQuery and XPath Full Text 1.0 Use Cases]</a>,
but to produce <em>a</em> valid
XQuery Full Text expression with the same semantics. 
</p><p>Comparison of the results of the Full Text XQueryX-to-XQuery Full Text
transformation given in this document with the XQuery Full Text solutions
in the <a href="#xpath-full-text-10-use-cases">[XQuery and XPath Full Text 1.0 Use Cases]</a> may be helpful in evaluating
the correctness of the Full Text XQueryX solution in the example. </p><p>The XQuery Full Text Use Cases solution given for the
example is provided only to assist readers of this
document in understanding the Full Text XQueryX solution. 
There is no intent to imply that this
document specifies a "compilation" or "transformation" of
XQuery Full Text syntax into Full Text XQueryX syntax. 
</p><p>In the following example, note that path expressions are expanded to show their
structure. Also, note that the prefix syntax for binary operators like "and" makes the
precedence explicit. In general, humans find it easier to read an XML representation
that does not expand path expressions, but it is less convenient for programmatic
representation and manipulation.  XQueryX is designed as a language that is convenient
for production and modification by software, and not as a convenient syntax for humans to
read and write. </p><p>Finally, please note that white space, including new lines, have been added to
some of the Full Text XQueryX documents and XQuery Full Text expressions for readability. 
That additional white space is not necessarily produced by the
Full Text XQueryX-to-XQuery Full Text transformation. </p><div class="div3">
<h4><a name="Example1" id="Example1"/>E.3.1 Example</h4><p>Here is Q4 from the <a href="#xpath-full-text-10-use-cases">[XQuery and XPath Full Text 1.0 Use Cases]</a>,
    use case SCORE: Find all books with parts about "usability testing".</p><div class="div4">
<h5><a name="Example1-XQuery-Full-Text" id="Example1-XQuery-Full-Text"/>E.3.1.1 XQuery solution in XQuery and XPath Full Text 1.0 Use Cases:</h5><div class="xquery"><div class="exampleInner"><pre>
declare function local:filter ( $nodes 
   as node()*, $exclude as element()* ) as node()*
   {
      for $node in $nodes except $exclude
      return
         typeswitch ($node)
            case $e as element()
               return 
                 element {node-name($e)}
                   {
                       $e/@*,
                      filter( $e/node() except $exclude, 
                      $exclude )
                   }
            default 
               return $node
   };

for $book in doc("http://bstore1.example.com/full-text.xml")
   /books/book
let $irrelevantParts := 
   for $part in $book//part
   let score $score := $part contains text "usability test.*" 
      using wildcards
   where $score &lt; 0.5
   return $part
where count($irrelevantParts) &lt; count($book//part)
return filter($book, $irrelevantParts)
</pre></div></div></div><div class="div4">
<h5><a name="Example1-Full-Text-XQueryX" id="Example1-Full-Text-XQueryX"/>E.3.1.2 A Solution in Full Text XQueryX:</h5><div class="exampleInner"><pre>
&lt;?xml version="1.0"?&gt;
&lt;xqx:module xmlns:xqxft="http://www.w3.org/2007/xpath-full-text"
            xmlns:xqx="http://www.w3.org/2005/XQueryX"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.w3.org/2007/xpath-full-text
                                http://www.w3.org/2007/xpath-full-text/xpath-full-text-10-xqueryx.xsd
                                http://www.w3.org/2005/XQueryX
                                http://www.w3.org/2005/XQueryX/xqueryx.xsd"&gt;

  &lt;xqx:mainModule&gt;
    &lt;xqx:prolog&gt;
      &lt;xqx:functionDecl&gt;
        &lt;xqx:functionName xqx:prefix="local"&gt;filter&lt;/xqx:functionName&gt;
        &lt;xqx:paramList&gt;
          &lt;xqx:param&gt;
            &lt;xqx:varName&gt;nodes&lt;/xqx:varName&gt;
            &lt;xqx:typeDeclaration&gt;
              &lt;xqx:anyKindTest/&gt;&lt;xqx:occurrenceIndicator&gt;*&lt;/xqx:occurrenceIndicator&gt;
            &lt;/xqx:typeDeclaration&gt;
          &lt;/xqx:param&gt;
          &lt;xqx:param&gt;
            &lt;xqx:varName&gt;exclude&lt;/xqx:varName&gt;
            &lt;xqx:typeDeclaration&gt;
              &lt;xqx:elementTest/&gt;&lt;xqx:occurrenceIndicator&gt;*&lt;/xqx:occurrenceIndicator&gt;
            &lt;/xqx:typeDeclaration&gt;
          &lt;/xqx:param&gt;
        &lt;/xqx:paramList&gt;
        &lt;xqx:typeDeclaration&gt;
          &lt;xqx:anyKindTest/&gt;
        &lt;/xqx:typeDeclaration&gt;
        &lt;xqx:functionBody&gt;
          &lt;xqx:flworExpr&gt;
            &lt;xqx:forClause&gt;
              &lt;xqx:forClauseItem&gt;
                &lt;xqx:typedVariableBinding&gt;
                  &lt;xqx:varName&gt;node&lt;/xqx:varName&gt;
                &lt;/xqx:typedVariableBinding&gt;
                &lt;xqx:forExpr&gt;
                  &lt;xqx:exceptOp&gt;
                    &lt;xqx:firstOperand&gt;
                      &lt;xqx:varRef&gt;
                        &lt;xqx:name&gt;nodes&lt;/xqx:name&gt;
                      &lt;/xqx:varRef&gt;
                    &lt;/xqx:firstOperand&gt;
                    &lt;xqx:secondOperand&gt;
                      &lt;xqx:varRef&gt;
                        &lt;xqx:name&gt;exclude&lt;/xqx:name&gt;
                      &lt;/xqx:varRef&gt;
                    &lt;/xqx:secondOperand&gt;
                  &lt;/xqx:exceptOp&gt;
                &lt;/xqx:forExpr&gt;
              &lt;/xqx:forClauseItem&gt;
            &lt;/xqx:forClause&gt;
            &lt;xqx:returnClause&gt;
              &lt;xqx:typeswitchExpr&gt;
                &lt;xqx:argExpr&gt;
                  &lt;xqx:varRef&gt;
                    &lt;xqx:name&gt;node&lt;/xqx:name&gt;
                  &lt;/xqx:varRef&gt;
                &lt;/xqx:argExpr&gt;
                &lt;xqx:typeswitchExprCaseClause&gt;
                  &lt;xqx:variableBinding&gt;e&lt;/xqx:variableBinding&gt;
                  &lt;xqx:sequenceType&gt;
                    &lt;xqx:elementTest/&gt;
                  &lt;/xqx:sequenceType&gt;
                  &lt;xqx:resultExpr&gt;
                    &lt;xqx:computedElementConstructor&gt;
                      &lt;xqx:tagNameExpr&gt;
                        &lt;xqx:functionCallExpr&gt;
                          &lt;xqx:functionName xqx:prefix="fn"&gt;node-name&lt;/xqx:functionName&gt;
                          &lt;xqx:arguments&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;e&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
                          &lt;/xqx:arguments&gt;
                        &lt;/xqx:functionCallExpr&gt;
                      &lt;/xqx:tagNameExpr&gt;
                      &lt;xqx:contentExpr&gt;
                        &lt;xqx:sequenceExpr&gt;
                          &lt;xqx:pathExpr&gt;
                            &lt;xqx:stepExpr&gt;
                              &lt;xqx:filterExpr&gt;
                                &lt;xqx:varRef&gt;
                                  &lt;xqx:name&gt;e&lt;/xqx:name&gt;
                                &lt;/xqx:varRef&gt;
                              &lt;/xqx:filterExpr&gt;
                            &lt;/xqx:stepExpr&gt;
                            &lt;xqx:stepExpr&gt;
                              &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                              &lt;xqx:attributeTest&gt;
                                &lt;xqx:attributeName&gt;
                                  &lt;xqx:star/&gt;
                                &lt;/xqx:attributeName&gt;
                              &lt;/xqx:attributeTest&gt;
                            &lt;/xqx:stepExpr&gt;
                          &lt;/xqx:pathExpr&gt;
                          &lt;xqx:functionCallExpr&gt;
                            &lt;xqx:functionName xqx:prefix="fn"&gt;filter&lt;/xqx:functionName&gt;
                            &lt;xqx:arguments&gt;
                              &lt;xqx:exceptOp&gt;
                                &lt;xqx:firstOperand&gt;
                                  &lt;xqx:pathExpr&gt;
                                    &lt;xqx:stepExpr&gt;
                                      &lt;xqx:filterExpr&gt;
                                        &lt;xqx:varRef&gt;
                                          &lt;xqx:name&gt;e&lt;/xqx:name&gt;
                                        &lt;/xqx:varRef&gt;
                                      &lt;/xqx:filterExpr&gt;
                                    &lt;/xqx:stepExpr&gt;
                                    &lt;xqx:stepExpr&gt;
                                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                      &lt;xqx:anyKindTest/&gt;
                                    &lt;/xqx:stepExpr&gt;
                                  &lt;/xqx:pathExpr&gt;
                                &lt;/xqx:firstOperand&gt;
                                &lt;xqx:secondOperand&gt;
                                  &lt;xqx:varRef&gt;
                                    &lt;xqx:name&gt;exclude&lt;/xqx:name&gt;
                                  &lt;/xqx:varRef&gt;
                                &lt;/xqx:secondOperand&gt;
                              &lt;/xqx:exceptOp&gt;
                              &lt;xqx:varRef&gt;
                                &lt;xqx:name&gt;exclude&lt;/xqx:name&gt;
                              &lt;/xqx:varRef&gt;
                            &lt;/xqx:arguments&gt;
                          &lt;/xqx:functionCallExpr&gt;
                        &lt;/xqx:sequenceExpr&gt;
                      &lt;/xqx:contentExpr&gt;
                    &lt;/xqx:computedElementConstructor&gt;
                  &lt;/xqx:resultExpr&gt;
                &lt;/xqx:typeswitchExprCaseClause&gt;
                &lt;xqx:typeswitchExprDefaultClause&gt;
                  &lt;xqx:resultExpr&gt;
                    &lt;xqx:varRef&gt;
                      &lt;xqx:name&gt;node&lt;/xqx:name&gt;
                    &lt;/xqx:varRef&gt;
                  &lt;/xqx:resultExpr&gt;
                &lt;/xqx:typeswitchExprDefaultClause&gt;
              &lt;/xqx:typeswitchExpr&gt;
            &lt;/xqx:returnClause&gt;
          &lt;/xqx:flworExpr&gt;
        &lt;/xqx:functionBody&gt;
      &lt;/xqx:functionDecl&gt;
    &lt;/xqx:prolog&gt;
    &lt;xqx:queryBody&gt;
      &lt;xqx:flworExpr&gt;
        &lt;xqx:forClause&gt;
          &lt;xqx:forClauseItem&gt;
            &lt;xqx:typedVariableBinding&gt;
              &lt;xqx:varName&gt;book&lt;/xqx:varName&gt;
            &lt;/xqx:typedVariableBinding&gt;
            &lt;xqx:forExpr&gt;
              &lt;xqx:pathExpr&gt;
                &lt;xqx:stepExpr&gt;
                  &lt;xqx:filterExpr&gt;
                    &lt;xqx:functionCallExpr&gt;
                      &lt;xqx:functionName xqx:prefix="fn"&gt;doc&lt;/xqx:functionName&gt;
                      &lt;xqx:arguments&gt;
                        &lt;xqx:stringConstantExpr&gt;
                          &lt;xqx:value&gt;http://bstore1.example.com/full-text.xml&lt;/xqx:value&gt;
                        &lt;/xqx:stringConstantExpr&gt;
                      &lt;/xqx:arguments&gt;
                    &lt;/xqx:functionCallExpr&gt;
                  &lt;/xqx:filterExpr&gt;
                &lt;/xqx:stepExpr&gt;
                &lt;xqx:stepExpr&gt;
                  &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                  &lt;xqx:nameTest&gt;books&lt;/xqx:nameTest&gt;
                &lt;/xqx:stepExpr&gt;
                &lt;xqx:stepExpr&gt;
                  &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                  &lt;xqx:nameTest&gt;book&lt;/xqx:nameTest&gt;
                &lt;/xqx:stepExpr&gt;
              &lt;/xqx:pathExpr&gt;
            &lt;/xqx:forExpr&gt;
          &lt;/xqx:forClauseItem&gt;
        &lt;/xqx:forClause&gt;
        &lt;xqx:letClause&gt;
          &lt;xqx:letClauseItem&gt;
            &lt;xqx:typedVariableBinding&gt;
              &lt;xqx:varName&gt;irrelevantParts&lt;/xqx:varName&gt;
            &lt;/xqx:typedVariableBinding&gt;
            &lt;xqx:letExpr&gt;
              &lt;xqx:flworExpr&gt;
                &lt;xqx:forClause&gt;
                  &lt;xqx:forClauseItem&gt;
                    &lt;xqx:typedVariableBinding&gt;
                      &lt;xqx:varName&gt;part&lt;/xqx:varName&gt;
                    &lt;/xqx:typedVariableBinding&gt;
                    &lt;xqx:forExpr&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;book&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
                          &lt;/xqx:filterExpr&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;descendant-or-self&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;part&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:forExpr&gt;
                  &lt;/xqx:forClauseItem&gt;
                &lt;/xqx:forClause&gt;
                &lt;xqx:letClause&gt;
                  &lt;xqx:letClauseItem&gt;
                    &lt;xqxft:ftScoreVariableBinding&gt;score&lt;/xqxft:ftScoreVariableBinding&gt;
                    &lt;xqx:letExpr&gt;
                      &lt;xqxft:ftContainsExpr&gt;
                        &lt;xqxft:ftRangeExpr&gt;
                          &lt;xqx:varRef&gt;
                            &lt;xqx:name&gt;part&lt;/xqx:name&gt;
                          &lt;/xqx:varRef&gt;
                        &lt;/xqxft:ftRangeExpr&gt;
                        &lt;xqxft:ftSelectionExpr&gt;
                          &lt;xqxft:ftSelection&gt;
                            &lt;xqxft:ftSelectionSource&gt;
                              &lt;xqxft:ftPrimaryWithOptions&gt;
                                &lt;xqxft:ftPrimary&gt;
                                  &lt;xqxft:ftWords&gt;
                                    &lt;xqxft:ftWordsValue&gt;
                                      &lt;xqxft:ftWordsLiteral&gt;
                                        &lt;xqx:stringConstantExpr&gt;
                                          &lt;xqx:value&gt;usability test.*&lt;/xqx:value&gt;
                                        &lt;/xqx:stringConstantExpr&gt;
                                     &lt;/xqxft:ftWordsLiteral&gt;
                                    &lt;/xqxft:ftWordsValue&gt;
                                  &lt;/xqxft:ftWords&gt;
                                &lt;/xqxft:ftPrimary&gt;
                                &lt;xqxft:wildcard&gt;
                                  &lt;xqxft:value&gt;using wildcards&lt;/xqxft:value&gt;
                                &lt;/xqxft:wildcard&gt;
                              &lt;/xqxft:ftPrimaryWithOptions&gt;
                            &lt;/xqxft:ftSelectionSource&gt;
                          &lt;/xqxft:ftSelection&gt;
                        &lt;/xqxft:ftSelectionExpr&gt;
                      &lt;/xqxft:ftContainsExpr&gt;
                    &lt;/xqx:letExpr&gt;
                  &lt;/xqx:letClauseItem&gt;
                &lt;/xqx:letClause&gt;
                &lt;xqx:whereClause&gt;
                  &lt;xqx:lessThanOp&gt;
                    &lt;xqx:firstOperand&gt;
                      &lt;xqx:varRef&gt;
                        &lt;xqx:name&gt;score&lt;/xqx:name&gt;
                      &lt;/xqx:varRef&gt;
                    &lt;/xqx:firstOperand&gt;
                    &lt;xqx:secondOperand&gt;
                      &lt;xqx:decimalConstantExpr&gt;
                        &lt;xqx:value&gt;0.5&lt;/xqx:value&gt;
                      &lt;/xqx:decimalConstantExpr&gt;
                    &lt;/xqx:secondOperand&gt;
                  &lt;/xqx:lessThanOp&gt;
                &lt;/xqx:whereClause&gt;
                &lt;xqx:returnClause&gt;
                  &lt;xqx:varRef&gt;
                    &lt;xqx:name&gt;part&lt;/xqx:name&gt;
                  &lt;/xqx:varRef&gt;
                &lt;/xqx:returnClause&gt;
              &lt;/xqx:flworExpr&gt;
            &lt;/xqx:letExpr&gt;
          &lt;/xqx:letClauseItem&gt;
        &lt;/xqx:letClause&gt;
        &lt;xqx:whereClause&gt;
          &lt;xqx:lessThanOp&gt;
          &lt;xqx:firstOperand&gt;
            &lt;xqx:functionCallExpr&gt;
              &lt;xqx:functionName xqx:prefix="fn"&gt;count&lt;/xqx:functionName&gt;
              &lt;xqx:arguments&gt;
                &lt;xqx:varRef&gt;
                  &lt;xqx:name&gt;irrelevantParts&lt;/xqx:name&gt;
                &lt;/xqx:varRef&gt;
              &lt;/xqx:arguments&gt;
            &lt;/xqx:functionCallExpr&gt;
          &lt;/xqx:firstOperand&gt;
          &lt;xqx:secondOperand&gt;
            &lt;xqx:functionCallExpr&gt;
              &lt;xqx:functionName xqx:prefix="fn"&gt;count&lt;/xqx:functionName&gt;
              &lt;xqx:arguments&gt;
                &lt;xqx:pathExpr&gt;
                  &lt;xqx:stepExpr&gt;
                    &lt;xqx:filterExpr&gt;
                      &lt;xqx:varRef&gt;
                        &lt;xqx:name&gt;book&lt;/xqx:name&gt;
                      &lt;/xqx:varRef&gt;
                    &lt;/xqx:filterExpr&gt;
                  &lt;/xqx:stepExpr&gt;
                  &lt;xqx:stepExpr&gt;
                    &lt;xqx:xpathAxis&gt;descendant-or-self&lt;/xqx:xpathAxis&gt;
                    &lt;xqx:nameTest&gt;part&lt;/xqx:nameTest&gt;
                  &lt;/xqx:stepExpr&gt;
                &lt;/xqx:pathExpr&gt;
              &lt;/xqx:arguments&gt;
            &lt;/xqx:functionCallExpr&gt;
          &lt;/xqx:secondOperand&gt;
          &lt;/xqx:lessThanOp&gt;
        &lt;/xqx:whereClause&gt;
        &lt;xqx:returnClause&gt;
          &lt;xqx:functionCallExpr&gt;
            &lt;xqx:functionName xqx:prefix="local"&gt;filter&lt;/xqx:functionName&gt;
            &lt;xqx:arguments&gt;
              &lt;xqx:varRef&gt;
                &lt;xqx:name&gt;book&lt;/xqx:name&gt;
              &lt;/xqx:varRef&gt;
              &lt;xqx:varRef&gt;
                &lt;xqx:name&gt;irrelevantParts&lt;/xqx:name&gt;
              &lt;/xqx:varRef&gt;
            &lt;/xqx:arguments&gt;
          &lt;/xqx:functionCallExpr&gt;
        &lt;/xqx:returnClause&gt;
      &lt;/xqx:flworExpr&gt;
    &lt;/xqx:queryBody&gt;
  &lt;/xqx:mainModule&gt;
&lt;/xqx:module&gt;
</pre></div></div><div class="div4">
<h5><a name="Example1-Full-Text-Transformation" id="Example1-Full-Text-Transformation"/>E.3.1.3 Transformation of Full Text XQueryX Solution into XQuery Full Text</h5><p>Application of the stylesheet in <a href="#id-xqft-full-text-stylesheet"><b>E.2 XQueryX stylesheet for XQuery and XPath Full Text 1.0</b></a>
          to the Full Text XQueryX solution results in:</p><div class="xquery"><div class="exampleInner"><pre>
declare function local:filter($nodes as node()*, $exclude as element()*) as node()
{
( for $node in ($nodes except $exclude)
  return ( typeswitch($node)
             case $e as element()
               return element {fn:node-name($e)}
                  {( $e/child::attribute(*),
                     fn:filter( ($e/child::node() except $exclude), $exclude ) )}
             default return $node )
)
};

( for $book
    in fn:doc("http://bstore1.example.com/full-text.xml")/child::books/child::book
  let $irrelevantParts:=
  ( for $part in $book/descendant-or-self::part
    let score $score := $part contains text "usability test.*"
        using wildcards
    where ($score &lt; 0.5)
    return $part
)
  where (fn:count($irrelevantParts) &lt; fn:count($book/descendant-or-self::part))
  return local:filter($book, $irrelevantParts)
)
</pre></div></div></div></div></div></div><div class="div1">
<h2><a name="References" id="References"/>F References</h2><div class="div2">
<h3><a name="id-normative-references" id="id-normative-references"/>F.1 Normative References</h3><dl><dt class="label"><span><a name="xquery" id="xquery"/>XQuery 1.0: An XML Query Language (Second Edition)</span></dt><dd><div>
<a href="http://www.w3.org/TR/xquery/"><cite>XQuery 1.0: An XML Query Language (Second Edition)</cite></a>,
Don Chamberlin, Anders Berglund, Scott Boag, <em>et. al.</em>, Editors.
World Wide Web Consortium,
14 December 2010.
This version is http://www.w3.org/TR/2010/REC-xquery-20101214/.
The <a href="http://www.w3.org/TR/xquery/">latest version</a>
is available at http://www.w3.org/TR/xquery/.</div></dd><dt class="label"><span><a name="xpath20" id="xpath20"/>XML Path Language (XPath) 2.0 (Second Edition)</span></dt><dd><div>
<a href="http://www.w3.org/TR/xpath20/"><cite>XML Path Language (XPath) 2.0 (Second Edition)</cite></a>,
Don Chamberlin, Anders Berglund, Scott Boag, <em>et. al.</em>, Editors.
World Wide Web Consortium,
14 December 2010.
This version is http://www.w3.org/TR/2010/REC-xpath20-20101214/.
The <a href="http://www.w3.org/TR/xpath20/">latest version</a>
is available at http://www.w3.org/TR/xpath20/.</div></dd><dt class="label"><span><a name="xpath-functions" id="xpath-functions"/>XQuery 1.0 and XPath 2.0 Functions and Operators (Second Edition)</span></dt><dd><div>
<a href="http://www.w3.org/TR/xpath-functions/"><cite>XQuery 1.0 and XPath 2.0 Functions and Operators (Second Edition)</cite></a>,
Ashok Malhotra, Jim Melton, and Norman Walsh, Editors.
World Wide Web Consortium,
14 December 2010.
This version is http://www.w3.org/TR/2010/REC-xpath-functions-20101214/.
The <a href="http://www.w3.org/TR/xpath-functions/">latest version</a>
is available at http://www.w3.org/TR/xpath-functions/.</div></dd><dt class="label"><span><a name="xpath-datamodel" id="xpath-datamodel"/>XQuery 1.0 and XPath 2.0 Data Model (XDM) (Second Edition)</span></dt><dd><div>
<a href="http://www.w3.org/TR/xpath-datamodel/"><cite>XQuery 1.0 and XPath 2.0 Data Model (XDM) (Second Edition)</cite></a>,
Norman Walsh, Mary Fernández, Ashok Malhotra, <em>et. al.</em>, Editors.
World Wide Web Consortium,
14 December 2010.
This version is http://www.w3.org/TR/2010/REC-xpath-datamodel-20101214/.
The <a href="http://www.w3.org/TR/xpath-datamodel/">latest version</a>
is available at http://www.w3.org/TR/xpath-datamodel/.</div></dd><dt class="label"><span><a name="xqueryx" id="xqueryx"/>XML Syntax for XQuery 1.0 (XQueryX) (Second Edition)</span></dt><dd><div>
<a href="http://www.w3.org/TR/xqueryx/"><cite>XML Syntax for XQuery 1.0 (XQueryX) (Second Edition)</cite></a>,
Jim Melton and Subramanian Muralidhar, Editors.
World Wide Web Consortium,
14 December 2010.
This version is http://www.w3.org/TR/2010/REC-xqueryx-20101214/.
The <a href="http://www.w3.org/TR/xqueryx/">latest version</a>
is available at http://www.w3.org/TR/xqueryx/.</div></dd><dt class="label"><span><a name="xpath-full-text-10-requirements" id="xpath-full-text-10-requirements"/>XQuery and XPath Full Text 1.0 Requirements</span></dt><dd><div>
<a href="http://www.w3.org/TR/xpath-full-text-10-requirements/"><cite>XQuery and XPath Full Text 1.0 Requirements</cite></a>,
Stephen Buxton, Pat Case, and Michael Rys, Editors.
World Wide Web Consortium,
25 January 2011.
This version is http://www.w3.org/TR/2011/NOTE-xpath-full-text-10-requirements-20110125/.
The <a href="http://www.w3.org/TR/xpath-full-text-10-requirements/">latest version</a>
is available at http://www.w3.org/TR/xpath-full-text-10-requirements/.</div></dd><dt class="label"><span><a name="xpath-full-text-10-use-cases" id="xpath-full-text-10-use-cases"/>XQuery and XPath Full Text 1.0 Use Cases</span></dt><dd><div>
<a href="http://www.w3.org/TR/xpath-full-text-10-use-cases/"><cite>XQuery and XPath Full Text 1.0 Use Cases</cite></a>,
Sihem Amer-Yahia and Pat Case, Editors.
World Wide Web Consortium,
25 January 2011.
This version is
http://www.w3.org/TR/2011/NOTE-xpath-full-text-10-use-cases-20110125/. The
<a href="http://www.w3.org/TR/xpath-full-text-10-use-cases/">latest version</a>
is available at http://www.w3.org/TR/xpath-full-text-10-use-cases/.</div></dd><dt class="label"><span><a name="BCP47" id="BCP47"/>BCP 47</span></dt><dd><div>A. Phillips and M. Davis. <em>Tags for Identifying Languages.</em>
IETF BCP 47.
See <a href="http://tools.ietf.org/html/bcp47">http://tools.ietf.org/html/bcp47</a>.
This reference leads to <a href="#RFC4646">[RFC 4646]</a> and <a href="#RFC4647">[RFC 4647]</a> and
replaces <a href="#RFC3066">[RFC 3066]</a>. </div></dd><dt class="label"><span><a name="RFC2119" id="RFC2119"/>RFC 2119</span></dt><dd><div>S. Bradner.
<em>Key Words for use in RFCs to Indicate Requirement Levels.</em> IETF RFC 2119. 
See <a href="http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</a>.</div></dd><dt class="label"><span><a name="RFC3066" id="RFC3066"/>RFC 3066</span></dt><dd><div>H. Alvestrand. <em>Tags for the Identification of Languages.</em>
IETF RFC 3066. See <a href="http://www.ietf.org/rfc/rfc3066.txt">http://www.ietf.org/rfc/rfc3066.txt</a>.</div></dd><dt class="label"><span><a name="RFC4646" id="RFC4646"/>RFC 4646</span></dt><dd><div>A. Phillips and M. Davis. <em>Tags for Identifying Languages.</em>
IETF RFC 4646. See <a href="http://www.ietf.org/rfc/rfc4646.txt">http://www.ietf.org/rfc/rfc4646.txt</a>.</div></dd><dt class="label"><span><a name="RFC4647" id="RFC4647"/>RFC 4647</span></dt><dd><div>A. Phillips and M. Davis. <em>Matching of Language Tags.</em>
IETF RFC 4647. See <a href="http://www.ietf.org/rfc/rfc4647.txt">http://www.ietf.org/rfc/rfc4647.txt</a>.</div></dd></dl></div><div class="div2">
<h3><a name="id-non-normative-references" id="id-non-normative-references"/>F.2 Non-normative References</h3><dl><dt class="label"><span><a name="iso-2788" id="iso-2788"/>ISO 2788</span></dt><dd><div>
Documentation Guidelines for the Establishment and Development of
Monolingual Thesauri, Geneva: International Organization for
Standardization, 2nd edition, 1986.
</div></dd><dt class="label"><span><a name="sqlmm" id="sqlmm"/>SQL/MM</span></dt><dd><div> ISO/IEC 13249-2 Information technology
--- Database languages --- SQL Multimedia and Application Packages ---
Part 2: Full-Text. Geneva: International Organization for
Standardization, 2nd edition, 2003.
</div></dd><dt class="label"><span><a name="UAX29" id="UAX29"/>UAX29</span></dt><dd><div>M. Davis. <em>Unicode Standard Annex #29
Text Boundaries, revision 11, 2006.
</em>  See <a href="http://www.unicode.org/reports/tr29/">http://www.unicode.org/reports/tr29/</a>
               </div></dd></dl></div></div><div class="div1">
<h2><a name="ft-acknowledgements" id="ft-acknowledgements"/>G Acknowledgements (Non-Normative)</h2><p>We would like to thank the members of the XQuery and XPath
Full-Text group for their fruitful discussions. </p><p>We would like to thank the following people for their contributions on earlier drafts of this document.</p><ul><li><p> Andrew Cencini, Microsoft - acencini@microsoft.com </p></li><li><p> Andrew Eisenberg, IBM - andrew.eisenberg@us.ibm.com</p></li><li><p> Nimish Khanolkar, Microsoft - nimishk@exchange.microsoft.com </p></li><li><p> Ashok Malhotra, Oracle - ashok.malhotra@oracle.com </p></li><li><p> Tapas Nayak, Microsoft - tapasnay@exchange.microsoft.com </p></li><li><p> Roland Seiffert, IBM - seiffert@de.ibm.com</p></li></ul></div><div class="div1">
<h2><a name="ft-glossary" id="ft-glossary"/>H Glossary (Non-Normative)</h2><dl><dt><a name="GLAllMatchesDef"/>AllMatches</dt><dd><p>An <b>AllMatches</b>
                describes the possible results of an <b>FTSelection</b>.</p></dd><dt><a name="GLid-Distance-Operator-Restriction"/>Distance Operator Restriction</dt><dd><p>
                     <b>Distance Operator Restriction.</b> FTDistance can only be applied to an FTOr that
        is either a single FTWords or a combination of FTWords involving only the 
        operators ftand and ftor.</p></dd><dt><a name="GLFull-TextQueriesDef"/>Full-TextQueries</dt><dd><p>
                  <b>Full-text queries</b> are 
   performed on tokens and phrases. Tokens and phrases are produced via
   tokenization.</p></dd><dt><a name="GLIgnoredNodesDef"/>IgnoredNodes</dt><dd><p>
                  <b>Ignored nodes</b> are the set of nodes whose content are 
    ignored.</p></dd><dt><a name="GLMatchDef"/>Match</dt><dd><p>Each  
                <b>Match</b> describes one result to the <b>FTSelection</b>.</p></dd><dt><a name="GLid-Negation-Restriction-1"/>Negation Restriction 1</dt><dd><p>
                           <b>Negation Restriction 1.</b> An <a href="#doc-xquery10-FTUnaryNot">FTUnaryNot</a>
        expression may only appear as a direct right operand of an
        "ftand" (<a href="#doc-xquery10-FTAnd">FTAnd</a>) operation.</p></dd><dt><a name="GLid-Negation-Restriction-2"/>Negation Restriction 2</dt><dd><p>
                           <b>Negation Restriction 2.</b> An <a href="#doc-xquery10-FTUnaryNot">FTUnaryNot</a>
        expression may not appear as a descendant of an 
        <a href="#doc-xquery10-FTOr">FTOr</a> that is modified by an 
        <a href="#doc-xquery10-FTPosFilter">FTPosFilter</a>. (An
        FTOr is modified by an FTPosFilter, if it is derived using
        the production for <a href="#doc-xquery10-FTSelection">FTSelection</a> 
         together with that FTPosFilter.)</p></dd><dt><a name="GLid-Order-Operator-Restriction"/>Order Operator Restriction</dt><dd><p>
                     <b>Order Operator Restriction.</b> FTOrder may only appear directly succeeding 
        an FTWindow or an FTDistance operator.</p></dd><dt><a name="GLParagraphDef"/>Paragraph</dt><dd><p>A <b>paragraph</b> is an ordered sequence
of any number of tokens. 
Beyond that, paragraphs are <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>. 
A tokenizer is not required to support paragraphs.</p></dd><dt><a name="GLPhraseDef"/>Phrase</dt><dd><p>A <b>phrase</b> is an ordered sequence of any number of tokens. 
Beyond that, phrases are <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.</p></dd><dt><a name="GLQueryItemDef"/>QueryItem</dt><dd><p>A <b>QueryItem</b> is a sequence of
        <b>QueryTokenInfo</b>s representing the collection of tokens derived
        from tokenizing one query string. </p></dd><dt><a name="GLQueryTokenInfoDef"/>QueryTokenInfo</dt><dd><p>A <b>QueryTokenInfo</b> is the
        identity of a token inside a query string. </p></dd><dt><a name="GLScore"/>Score</dt><dd><p>The <b>score</b> of a full-text query result expresses its relevance to
        the search conditions.</p></dd><dt><a name="GLSentenceDef"/>Sentence</dt><dd><p>A <b>sentence</b> is an ordered sequence
of any number of tokens. 
Beyond that, sentences are <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>. 
A tokenizer is not required to support sentences.</p></dd><dt><a name="GLid-Single-Language-Restriction"/>Single Language Restriction</dt><dd><p>
                     <b>Single Language Restriction.</b> If a full-text query contains more than one
        FTLanguageOption in its body and the prolog, then the languages specified 
        must be the same.</p></dd><dt><a name="GLStringExcludeDef"/>StringExclude</dt><dd><p>A <b>StringExclude</b>
				is a <b>StringMatch</b> that describes a <b>TokenInfo</b> that must not be
				contained in the document.</p></dd><dt><a name="GLStringIncludeDef"/>StringInclude</dt><dd><p>A <b>StringInclude</b>
				is a <b>StringMatch</b> that describes a <b>TokenInfo</b> that must be
				contained in the document.</p></dd><dt><a name="GLStringMatchDef"/>StringMatch</dt><dd><p>A
				<b>StringMatch</b> is a
				possible match of a sequence of query
				tokens with a corresponding sequence
				of tokens in a document. A StringMatch may be a <b>StringInclude</b>
				or <b>StringExclude</b>.</p></dd><dt><a name="GLTokenDef"/>Token</dt><dd><p>A <b>token</b> is a non-empty sequence of characters
returned by a tokenizer as a basic unit to be searched. 
Beyond that, tokens are <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.</p></dd><dt><a name="GLTokenInfoDef"/>TokenInfo</dt><dd><p>A <b>TokenInfo</b> 
        represents a contiguous collection of tokens from an XML document. 
        </p></dd><dt><a name="GLTokenizationDef"/>Tokenization</dt><dd><p>Formally, <b>tokenization</b> is the process 
        of converting
        an XDM item to a collections of tokens, taking any
        structural information of the item into account
        to identify token, sentence, and paragraph boundaries. Each token is
        assigned a starting and ending position.</p></dd><dt><a name="GLWeightDeclarationsDef"/>WeightDeclarations</dt><dd><p>Scoring may be influenced
by adding <b>weight declarations</b> to search tokens, phrases, and expressions.</p></dd><dt><a name="GLid-Window-Operator-Restriction"/>Window Operator Restriction</dt><dd><p>
                     <b>Window Operator Restriction.</b> FTWindow can only be applied to an FTOr that
        is either a single FTWords or a combination of FTWords involving only the 
        operators ftand and ftor.</p></dd><dt><a name="GLdt-anchoring-selection"/>anchoring selection</dt><dd><p>An
<b>anchoring selection</b> consists of a full-text selection followed
by one of the postfix operators "at start", "at end", or "entire content".</p></dd><dt><a name="GLdt-and-selection"/>and-selection</dt><dd><p>An
<b>and-selection</b> combines two full-text selections using the 
<code>ftand</code> operator.</p></dd><dt><a name="GLdt-cardinality-selection"/>cardinality selection</dt><dd><p>A
<b>cardinality selection</b> consist of an 
<a href="#doc-xquery10-FTWords">FTWords</a> followed
by the <a href="#doc-xquery10-FTTimes">FTTimes</a> postfix operator.</p></dd><dt><a name="GLdt-ftcaseoption"/>case option</dt><dd><p>A <b>case option</b>
modifies the matching of tokens and phrases by specifying how uppercase and 
lowercase characters are considered.</p></dd><dt><a name="GLdt-ftdiacriticsoption"/>diacritics option</dt><dd><p>A 
<b>diacritics option</b>
modifies token and phrase matching by specifying how diacritics are considered.
</p></dd><dt><a name="GLdt-distance-selection"/>distance selection</dt><dd><p>A
<b>distance selection</b> consists of a full-text selection followed
by one of the (complex) postfix operators derived from <a href="#doc-xquery10-FTDistance">FTDistance</a>.</p></dd><dt><a name="GLdt-ftextensionoption"/>extension option</dt><dd><p>An
<b>extension option</b> is a match option that acts in an
<a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> way.
</p></dd><dt><a name="GLdt-extension-selection"/>extension selection</dt><dd><p>An <b>extension selection</b> is a full-text selection whose semantics are
<a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.</p></dd><dt><a name="GLdt-ftcontains"/>full-text contains expression</dt><dd><p>A
<b>full-text contains expression</b> is a expression that evaluates a
sequence of items against a full-text selection.
</p></dd><dt><a name="GLftselection"/>full-text selection</dt><dd><p>A 
<b>full-text selection</b> specifies the conditions of a full-text search.
</p></dd><dt><a name="GLdt-implementation-dependent"/>implementation   dependent</dt><dd><p>
                        <b>Implementation-dependent</b>
		indicates an aspect that may differ between
		implementations, is not specified by this or any W3C
		specification, and is not required to be specified by
		the implementor for any particular
		implementation.</p></dd><dt><a name="GLdt-implementation-defined"/>implementation defined</dt><dd><p>
                        <b>Implementation-defined</b>
		indicates an aspect that may differ between
		implementations, but must be specified by the
		implementor for each particular
		implementation.</p></dd><dt><a name="GLdt-ftlanguageoption"/>language option</dt><dd><p>A 
<b>language option</b> 
modifies token matching by specifying the language of search tokens and 
phrases.</p></dd><dt><a name="GLdt-match-options"/>match option</dt><dd><p>
                  <b>Match options</b> modify the set of tokens
      in the query, or how they are matched against tokens in the
      text.</p></dd><dt><a name="GLdt-match-option-order"/>match option application order</dt><dd><p>
The order in which effective match options for an 
<a href="#doc-xquery10-FTWords">FTWords</a> are applied 
 is called the <b>match option application order</b>.</p></dd><dt><a name="GLdt-match-option-group"/>match option group</dt><dd><p>
Each of the <span class="diff-del">seven</span> alternatives of production 
<a href="#doc-xquery10-FTMatchOption">FTMatchOption</a>
                  <span class="diff-add">other than <a href="#doc-xquery10-FTExtensionOption">FTExtensionOption</a>
                  </span>
corresponds to one <b>match option group</b>. </p></dd><dt><a name="GLmay"/>may</dt><dd><p>
               <b>MAY</b> means that an item is truly optional.</p></dd><dt><a name="GLdt-mild-not-selection"/>mild-not selection</dt><dd><p>A
<b>mild-not selection</b> combines two full-text selections 
using the <code>not in</code> operator.</p></dd><dt><a name="GLmust"/>must</dt><dd><p>
               <b>MUST</b> means that the item is an absolute requirement of the specification.</p></dd><dt><a name="GLdt-unary-not-selection"/>not-selection</dt><dd><p>A
<b>not-selection</b> is a full-text selection starting with the prefix 
operator <code>ftnot</code>.</p></dd><dt><a name="GLdt-or-selection"/>or-selection</dt><dd><p>An
<b>or-selection</b> combines two full-text selections using the 
<code>ftor</code> operator.</p></dd><dt><a name="GLdt-ordered-selection"/>ordered selection</dt><dd><p>An
<b>ordered selection</b> consists of a full-text selection followed by 
the postfix operator "ordered".</p></dd><dt><a name="GLdt-ftposfilter"/>positional filter</dt><dd><p>
                  <b>Positional filters</b> are postfix operators that serve to
filter matches based on various constraints on their positional
information.</p></dd><dt><a name="GLdt-ftprimary"/>primary full-text selection</dt><dd><p>A 
<b>primary full-text selection</b> is the basic form of a 
full-text selection. It specifies tokens and phrases as search 
conditions (<a href="#doc-xquery10-FTWords">FTWords</a>), optionally followed by a cardinality constraint 
(<a href="#doc-xquery10-FTTimes">FTTimes</a>). An <a href="#doc-xquery10-FTSelection">FTSelection</a> 
in parentheses and the <a href="#doc-xquery10-FTExtensionSelection">FTExtensionSelection</a>
are also a primary full-text selections.</p></dd><dt><a name="GLdt-scope-selection"/>scope selection</dt><dd><p>A
<b>scope selection</b> consists of a full-text selection followed
by one of the (complex) postfix operators derived from <a href="#doc-xquery10-FTScope">FTScope</a>.</p></dd><dt><a name="GLdt-search-context"/>search context</dt><dd><p>
  Those items are called
  the <b>search context</b>.</p></dd><dt><a name="GLshould"/>should</dt><dd><p>
               <b>SHOULD</b> means that there may exist valid reasons in particular circumstances
          to ignore a particular item, but the full implications must be understood and carefully
          weighed before choosing a different course.</p></dd><dt><a name="GLdt-ftstemoption"/>stemming option</dt><dd><p>A <b>stemming option</b>
modifies token and
phrase matching by specifying whether stemming is applied or not.
</p></dd><dt><a name="GLdt-ftstopwordoption"/>stop word option</dt><dd><p>A 
<b>stop word option</b>
controls matching of <span class="diff-chg">tokens</span> by specifying whether stop words are used or not. 
Stop words are tokens in the query that match any token in the text being
searched. 
</p></dd><dt><a name="GLdt-ftthesaurusoption"/>thesaurus option</dt><dd><p>A 
<b>thesaurus option</b>
modifies token and phrase matching by specifying whether a thesaurus is used or
not.</p></dd><dt><a name="GLdt-ftwildcardoption"/>wildcard option</dt><dd><p>A 
<b>wildcard option</b>
modifies token and phrase matching by specifying whether or not
wildcards are recognized in query strings.</p></dd><dt><a name="GLdt-window-selection"/>window selection</dt><dd><p>A
<b>window selection</b> consists of a full-text selection followed
by one of the (complex) postfix operators derived from <a href="#doc-xquery10-FTWindow">FTWindow</a>.</p></dd></dl></div><div class="div1">
<h2><a name="impl-def" id="impl-def"/>I Checklist of Implementation-Defined Features (Non-Normative)</h2><p>This appendix provides a summary of features defined in this specification
whose effect is explicitly <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>. 
The conformance rules require vendors to provide documentation that
explains how these choices have been exercised.
</p><ol class="enumar"><li><p> 
Tokenization, including the definition of the term "tokens",
<a title="should" href="#should">SHOULD</a> be <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>. 
Implementations <a title="should" href="#should">SHOULD</a> expose the rules and
sample results of tokenization as much as possible to
enable users to predict and interpret the results of tokenization. 
</p></li><li><p>
A phrase is an ordered sequence of any number of tokens. Beyond that, phrases
are <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.
</p></li><li><p>
A sentence is an ordered sequence of any number of tokens. Beyond that,
sentences are <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.  <span class="diff-chg">A tokenizer</span> is not required
to support sentences.
</p></li><li><p>
A  paragraph is an ordered sequence of any number of tokens. Beyond that,
paragraphs are <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.  <span class="diff-chg">A tokenizer</span> is not required
to support paragraphs.
</p></li><li><p> Implementations are free to provide
<a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> ways to differentiate between markup's 
effect on token boundaries during tokenization. </p></li><li><div class="diff-del"><li><p> How text with wildcard indicators and qualifiers is tokenized is
<a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.</p></li></div></li><li><p>
The set of expressions (of form ExprSingle) that can be assigned to a
score variable in a let-clause is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.

<span class="diff-del">
The result of passing an expression to the scoring algorithm that it does not support is
<a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>. 
</span>
                  <span class="diff-add">
If an expression not supported by the scoring algorithm
is passed to the scoring algorithm,
the result is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.
</span>
               </p></li><li><div class="diff-del"><li><p> The <a title="match option application order" href="#dt-match-option-order">match option application order</a>, subject to the
stated constraints, is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>. 
</p></li></div></li><li><div class="diff-del"><li><p>  It is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> what a stem of a token is and 
whether stemming will based on an algorithm, dictionary, or mixed approach. </p></li></div></li><li><div class="diff-del"><li><p> It is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> which thesaurus relationships an
implementation supports.</p></li></div></li><li><div class="diff-add"><li><p>
When a sequence of query tokens is considered as a phrase, it matches
a sequence of tokens in the tokenized form of the text being searched
only if the two sequences
correspond in an <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> way.
</p></li></div></li><li><div class="diff-del"><li><p> The behavior of the implementation when it encounters a combination of
thesauri, levels, and relationships that it does not support is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.</p></li></div></li><li><div class="diff-add"><li><p> The <a title="match option application order" href="#dt-match-option-order">match option application order</a>, subject to the
stated constraints, is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>. 
</p></li></div></li><li><div class="diff-del"><li><p> When the option "using default stop words" is used, an
<a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> collection of stop words is used. </p></li></div></li><li><div class="diff-del"><li><p> When a stop word is specified in a query,
then the number of tokens in the text that are matched by that stop word is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>. </p></li></div></li><li><p> The "language" option influences tokenization, stemming, and stop
words in an <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> way. It 
<a title="may" href="#may">MAY</a> influence the behavior of
other match options in an <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> way.</p></li><li><p> The set of valid language identifiers is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>. </p></li><li><div class="diff-chg"><li><p>
If an invalid language identifier is specified,
then the behavior is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.
</p></li></div></li><li><div class="diff-del"><li><p>Certain values in the static context (see <a href="#id-xqft-static-context-components"><b>C Static Context Components</b></a>)
that can be overwritten or augmented by implementations are
<a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>. </p></li></div></li><li><div class="diff-del"><li><p>Which namespace URIs will be recognized for denoting extension
selection pragmas is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>, as is the syntax
and behavior of recognized pragmas.
</p></li></div></li><li><div class="diff-del"><li><p>Which namespace URIs will be recognized for denoting extension
options is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>, as is the syntax
and behavior of recognized options.
</p></li></div></li><li><div class="diff-add"><li><p>
When a processor evaluates text in a document that is governed by an xml:lang attribute
and the portion of the full-text query doing that evaluation
contains an FTLanguageOption that specifies a different language
from the language specified by the governing xml:lang attribute,
the language-related behavior of that full-text query is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.
</p></li></div></li><li><div class="diff-add"><li><p> It is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> which thesaurus relationships an
implementation supports.</p></li></div></li><li><div class="diff-add"><li><p>
If a query specifies thesaurus relationships not supported by the thesaurus,
or does not specify a relationship,
the behavior is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.
</p></li></div></li><li><div class="diff-add"><li><p>
The effect of specifying a particular range of levels in an FTThesaurusID
is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.
</p></li></div></li><li><div class="diff-add"><li><p>If a query does not specify the number of levels, and the implementation does not follow the default of querying all levels of hierarchical relationships, then the number of levels of hierarchical relationships queries is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.
</p></li></div></li><li><div class="diff-add"><li><p> It is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> what a stem of a token is, and 
whether stemming is based on an algorithm, dictionary, or mixed approach. </p></li></div></li><li><div class="diff-add"><li><p> An <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> comparison is used
to determine whether a query token appears in
the collection of stop words defined by the applicable stop word option. </p></li></div></li><li><div class="diff-add"><li><p>
Normally a stop word matches exactly one token,
but there may be <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> conditions,
under which a stop word may match a different number of tokens.
</p></li></div></li><li><div class="diff-add"><li><p> The "stop words default" option specifies that an
<a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> collection of stop words is used. </p></li></div></li><li><div class="diff-add"><li><p>
An implementation recognizes
an <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> set of namespace URIs
used to denote extension options.
The effect of each,
including its error behavior, is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.
</p></li></div></li><li><div class="diff-add"><li><p>
An implementation recognizes
an <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> set of namespace URIs
used to denote extension selection pragmas.
The effect of each,
including its error behavior, is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.
</p></li></div></li><li><p>The conditions under which tokenization of two equal items produces
different tokens is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.
</p></li><li><div class="diff-add"><li><p>
An implementation may impose an <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> restriction
on the operand of FTIgnoreOption.
</p></li></div></li><li><div class="diff-add"><li><p>
For certain full-text components of the static context
(see <a href="#id-xqft-static-context-components"><b>C Static Context Components</b></a>),
the default initial value of the component
can be overwritten or augmented
with an <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> value or values.
</p></li></div></li></ol></div><div class="div1">
<h2><a name="id-xqft-changelog" id="id-xqft-changelog"/>J Change Log (Non-Normative)</h2><table border="1" summary="Change Log Table"><tbody><tr><td>Michael Dyck</td><td>2008-08-19</td><td>3.6.3 Distance Selection</td><td>
Change the prose around example 2
to agree with the meeting 170 decision
re distance filter applied to n&gt;2 matches.
</td></tr><tr><td>Jim Melton</td><td>2008-08-26</td><td>Sections <a href="#section-using-weights"><b>2.3.1 Using Weights Within a Scored FTContainsExpr</b></a>, <a href="#ftselections"><b>3 Full-Text Selections</b></a>,
and <a href="#id-errors"><b>D Error Conditions</b></a>
                  </td><td>Ensure that all description of weights, valid values, and errors related to invalid values
are captured in one place, and generalize the description of the error raised for invalid values. 
Resolves bug 5812. 
</td></tr><tr><td>Jim Melton</td><td>2008-08-26</td><td>Section <a href="#id-extension-selections"><b>3.8 Extension Selections</b></a>
                  </td><td>Correct syntax of the second and third examples. 
Resolves bug 5879. 
</td></tr><tr><td>Jim Melton</td><td>2008-08-26</td><td>Section <a href="#sec-ftnot"><b>3.5.4 Not-Selection</b></a>
                  </td><td>Rewrite the second example to correspond to the search document content. 
Resolves bug 5884. 
</td></tr><tr><td>Jim Melton</td><td>2008-08-26</td><td>Section <a href="#sec-ftnot"><b>3.5.4 Not-Selection</b></a>
                  </td><td>Rewrite the third example to correspond to the search document structure. 
Resolves bug 5885. 
</td></tr><tr><td>Mary Holstege</td><td>2008-10-30</td><td>Miscellaneous</td><td>Add text to clarify status of attribute searches (bug 5975) and of
scope and constraints on score variables (bug 6094).
</td></tr><tr><td>Mary Holstege</td><td>2008-10-30</td><td>Full-Text Selections</td><td>Change scope of weight variables to FTPrimary rather than FTSelection to 
resolve bug 6178.
</td></tr><tr><td>Michael Dyck</td><td>2008-11-07</td><td>2.3.1 Using Weights Within a Scored FTContainsExpr</td><td>
Collateral changes due to Bug 6178's relocation of FTWeight within grammar.
</td></tr><tr><td>Michael Dyck</td><td>2008-11-07</td><td>
3.4 Match Options,
3.6 Positional Filters
</td><td>
Add text intended to clarify scope of options/filters.
[Bug 5977]
</td></tr><tr><td>Jim Melton</td><td>2008-11-12</td><td>Appendix <a href="#id-xqft-xqueryx"><b>E XML Syntax (XQueryX) for XQuery and XPath Full Text 1.0</b></a>
                  </td><td>Revise Schema and stylesheet to reflect change in position of "weight" in the grammar.
</td></tr><tr><td>Pat Case</td><td>2008-11-23</td><td>Removed count &gt; 0 from examples</td><td>Removed count &gt; 0 from examples in 3.4.3 Thesaurus Option and 3.4.7 Stop Word Option.</td></tr><tr><td>Pat Case</td><td>2008-11-23</td><td>Corrected FTLanguage example</td><td>Corrected the FTLanguage example in Section 3.4.1 to search in content//p and to search for "salon de thé".</td></tr><tr><td>Michael Dyck</td><td>2009-01-08</td><td>4.2.7.9 FTDistance</td><td>
Rewrite the very last sentence.
[Bug 6303]
</td></tr><tr><td>Michael Dyck</td><td>2009-01-08</td><td>Grammar, Full-Text Selections</td><td>
Get rid of "multiple-match-options" as an extra-grammatical constraint,
and instead make it a conventional static error (FTST0019).
</td></tr><tr><td>Jim Melton</td><td>2009-01-28</td><td>Section <a href="#introduction"><b>1 Introduction</b></a>
                  </td><td>Inserted paragraph stating that Notes are not normative.</td></tr><tr><td>Jim Melton</td><td>2009-01-28</td><td>Appendix <a href="#id-errors"><b>D Error Conditions</b></a>
                  </td><td>Added entries and descriptions for errors XPST0003, XQST0013, and XQST0079.</td></tr><tr><td>Mary Holstege</td><td>2009-02-19</td><td>Window Selection <a href="#ftwindow"><b>3.6.2 Window Selection</b></a>
                  </td><td>Provided corrected commentary on windowing example; clarified
non-applicability of contents of attribute in this example.</td></tr><tr><td>Mary Holstege</td><td>2009-02-19</td><td>FTUnit and FTBigUnit <a href="#id-ftunit-option"><b>5.2.3 FTUnit and FTBigUnit</b></a>
                  </td><td>Clarified that we did not mean for 'word' and 'words' to be optional units.
</td></tr><tr><td>Mary Holstege</td><td>2009-02-19</td><td>Thesaurus Option <a href="#ftthesaurusoption"><b>3.4.3 Thesaurus Option</b></a> and Error Conditions <a href="#id-errors"><b>D Error Conditions</b></a>
                  </td><td>Added error FTST0018 for missing thesauri.
</td></tr><tr><td>Michael Dyck</td><td>2009-02-26</td><td>4.2.7.7 FTContent</td><td>
Rewrite fts:ApplyFTContent() to fix 'entire content'.
In the process, introduce
    fts:TokenInfoCoversTokenPosition(),
    fts:getLowestTokenPosition(), &amp;
    fts:getHighestTokenPosition()
and drop
    fts:isStartToken() &amp;
    fts:isEndToken()
</td></tr><tr><td>Michael Dyck</td><td>2009-02-26</td><td>4.2.7.7 FTContent</td><td>
Add example of counter-intuitive behaviour
due to @isContiguous=false.
</td></tr><tr><td>Michael Dyck</td><td>2009-03-16</td><td>4.2.7.9 FTDistance</td><td>
Rearrange the section to bring together the parts about fts:ApplyFTDistance.
</td></tr><tr><td>Michael Dyck</td><td>2009-03-16</td><td>4.2.4 Formal semantics functions &amp; 4.2.7.9 FTDistance</td><td>
Dissolve 4.2.4 and integrate its content into 4.2.7.9 (now 4.2.6.9).
</td></tr><tr><td>Michael Dyck</td><td>2009-03-17</td><td>4.2.6.8 FTWindow</td><td>
Fix two typos in fts:joinIncludes().
(Bug 6386)
</td></tr><tr><td>Michael Dyck</td><td>2009-03-17</td><td>fts:evaluate, fts:FormRange, fts:UnaryNotHelper, fts:calcStopWords</td><td>
Fix some typos that would give static errors or type errors
if you tried to treat these functions as actual XQuery code.
</td></tr><tr><td>Mary Holstege</td><td>2009-03-19</td><td>fts:ApplyFTScopeDifferentSentence, fts:ApplyFTScopeDifferentParagraph</td><td>
Fix code to properly handle the case where there is a single string include.
</td></tr><tr><td>Pat Case</td><td>2009-03-28</td><td>Changed FTStopword examples 1 and 3</td><td>
Removed the stemming match option and changed the operand propagation to propagating in FTStopword examples 1 and 3.
</td></tr><tr><td>Michael Dyck</td><td>2009-04-14</td><td>3.4.1 Language Option</td><td>
Fix typo in example query.
</td></tr><tr><td>Jim Melton</td><td>2009-04-30</td><td>E.3.1.2 A Solution in Full Text XQueryX</td><td>
Fix element names in example.
(Bug 6840)
</td></tr><tr><td>Michael Dyck</td><td>2009-06-06</td><td>3.2 Search Tokens and Phrases</td><td>
Add wording to handle cases involving empty sequences of items or tokens.
(Bug 6813)
</td></tr><tr><td>Michael Dyck</td><td>2009-06-08</td><td>4.2.4 FTWords</td><td>
Fix error in fts:ApplyFTWordsAnyWord().
</td></tr><tr><td>Michael Dyck</td><td>2009-07-05</td><td>3.4.2 Wildcard Option, Appendix D Errors</td><td>
Wording changes, add more examples.
Add error FTDY0020.
</td></tr><tr><td>Michael Dyck</td><td>2009-07-06</td><td>3.4.2 Wildcard Option</td><td>
Delete Note re wildcards and token boundaries.
</td></tr><tr><td>Michael Dyck</td><td>2009-07-06</td><td>E.1 XQueryX representation of XQuery and XPath Full Text 1.0</td><td>
Add element declaration for ftMatchOptions.
</td></tr><tr><td>Michael Dyck</td><td>2009-07-14</td><td>E.2 XQueryX stylesheet for XQuery and XPath Full Text 1.0</td><td>
Bug fixes.
</td></tr><tr><td>Mary Holstege</td><td>2009-09-03</td><td>Various</td><td>
Modify match option syntax to avoid conflicts with XQuery and XQuery Update
Facility: change "with" to "using" and "without"
to "using no", plus adding "using" before other options for
consistency. Change 'ftcontains' to 'contains text'. Bugzilla bugs 7247 and 7271.
</td></tr><tr><td>Jim Melton</td><td>2009-09-18</td><td>E.1 XQueryX representation of XQuery and XPath Full Text 1.0</td><td>
Fixed grammar within a comment re: Bugzilla Bug 7247.
Fixed grammar within comments re: Bugzilla Bug 7271; also fixed enumeration values
and element content names for complex types ftStemOption,
ftThesaurusOption, ftStopwordOption, and ftWildCardOption re: Bugzilla Bug 7271.
</td></tr><tr><td>Jim Melton</td><td>2009-09-18</td><td>E.2 XQueryX stylesheet for XQuery and XPath Full Text 1.0</td><td>
Fixed templates' generated output re: Bugzilla Bug 7247 and Bugzilla Bug 7271. 
</td></tr><tr><td>Jim Melton</td><td>2009-09-18</td><td>E.3 XQueryX for XQuery and XPath Full Text 1.0 example</td><td>
Fixed "original" XQuery, the XQueryX code, and the XQuery resulting from transforming the XQueryC code
re: Bugzilla Bug 7247 and Bugzilla Bug 7271. 
</td></tr><tr><td>Michael Dyck</td><td>2009-10-10</td><td>Sections 3.4.* and Appendix A</td><td>
Change match option syntax to resolve bug 7271.
</td></tr><tr><td>Michael Dyck</td><td>2009-10-10</td><td>Section 2.2.1 and Appendix A</td><td>
Change FTContainsExpr syntax to resolve bug 7247.
</td></tr><tr><td>Pat Case</td><td>2009-11-10</td><td>Section 4.2.5.1 Types</td><td>
Corrected an error in the FTMatchOptions schema for FTDiacriticsOption changing case insensitive to diacritics insensitive and changing case sensitive to diacritics sensitive
</td></tr><tr><td>Michael Dyck</td><td>2009-11-25</td><td>Section 2.3.1 and 3.1.1, Appendix A and B</td><td>
Change syntax of FTWeight: replace RangeExpr with "{" Expr "}".
Change examples and prose accordingly.
</td></tr><tr><td>Mary Holstege</td><td>2009-12-10</td><td>Appendix D, Section 4.2.5</td><td>
Change semantics schema and functions to replace "with/without".
</td></tr><tr><td>Michael Dyck</td><td>2010-01-25</td><td>Section 3.5.3 Mild-Not Selection</td><td>
Clarify that FTDY0017 is a dynamic error, and not statically detectable.
</td></tr><tr><td>Mary Holstege</td><td>2010-05-25</td><td>Sections 3.4.3 Thesaurus Option and 3.4.7 Stop Word Option</td><td>
Resolve [9677] by making it clear the relative URIs for thesauri and stop word
lists should be resolved against the base URI in the static context.
</td></tr><tr><td>Mary Holstege</td><td>2010-05-25</td><td>Appendix D Error Conditions</td><td>
Resolve [9681] by replacing the obsolete operators &amp;&amp; and || by ftand 
and ftor, respectively.
</td></tr><tr><td>Michael Dyck</td><td>2010-07-11</td><td>Sections 3.4.7 Stop Word Option and 4.2.5.8 FTStopWordOption</td><td>
Replace wording that said that stop words are "removed from the search" or "removed from the set of query tokens".
</td></tr><tr><td>Michael Dyck</td><td>2010-07-11</td><td>Sections 3.4.7 Stop Word Option and I Checklist of Implementation-Defined Features (Non-Normative)</td><td>
Change two occurrences of "default stop words" to "stop words default".
(Leftovers from 2009-10-10.)
</td></tr><tr><td>Michael Dyck</td><td>2010-07-13</td><td>Sections 3.4.7 Stop Word Option and I Checklist of Implementation-Defined Features (Non-Normative)</td><td>
Add wording to state that
an implementation-defined comparison is used
to determine whether a query token appears in a collection of stop words.
</td></tr><tr><td>Michael Dyck</td><td>2010-09-06</td><td>4.2.6.6 FTScope</td><td>
Fix the 'where' conditions in
fts:ApplyFTScopeDifferentSentence()
and
fts:ApplyFTScopeDifferentParagraph().
And tweak the prose following the former.
(See Bugzilla Bug 9448.)
</td></tr><tr><td>Jim Melton</td><td>2010-09-07</td><td>E.2 XQueryX stylesheet for XQuery and XPath Full Text 1.0</td><td>
Fixed two templates (weights and extensions). 
</td></tr><tr><td>Michael Dyck</td><td>2010-09-13</td><td>
Section 3.2 (Search Tokens and Phrases),
Appendix A (EBNF for XQuery 1.0 Grammar with Full-Text extensions), and
Appendix B (EBNF for XPath 2.0 Grammar with Full-Text extensions)
</td><td>
In the production for FTWordsValue,
change "Literal" to "StringLiteral"
</td></tr><tr><td>Michael Dyck</td><td>2010-09-16</td><td>
Appendix I (Checklist of Implementation-Defined Features)
</td><td>
Make the list more consistent with
the statements of implementation-defined features in the body of the document.
(Delete 2 items, add 3, reword several, reorder several.)
</td></tr><tr><td>Michael Dyck</td><td>2010-11-29</td><td>
Section 4.2.5.{2,3,7}
</td><td>
Pass $noThesaurusOptions down to fts:lookupThesaurus().
(See Bugzilla bug 11209.)
</td></tr><tr><td>Michael Dyck</td><td>2010-11-29</td><td>
Section 4.2.5.{1,3,7}
</td><td>
Eliminate
the now-redundant $thesaurusLanguage parameter
from fts:lookupThesaurus(),
and
the now-unnecessary (and not syntactically justified) "language" attribute
from complexType ftThesaurusOption.
(Clean-up after previous change.)
</td></tr><tr><td>Mary Holstege</td><td>2010-12-06</td><td>
Section 3.6
</td><td>
Require FTOrder positional filters to be applied before other positional 
filters. 
</td></tr><tr><td>Mary Holstege</td><td>2011-01-04</td><td>
Sections 2.3.1 and 3.1.1.
</td><td>
In resolution of bug 11582, clarify that the second "constraint" on scoring 
algorithms is actually just a specific consequence of the rules for errors 
and optimization.
</td></tr><tr><td>Mary Holstege</td><td>2011-01-04</td><td>
Section 3.4.3
</td><td>
In resolution of bug 11444, change the default from "all levels" to "all levels or to an implementation-defined number of levels."
</td></tr><tr><td>Michael Dyck</td><td>2011-02-28</td><td>
Section 3.4.3
and Appendix I.
</td><td>
Introduce FTLiteralRange for FTThesaurusID.
Clarify implementation-definedness of levels.
(See bugs 11821 and 12036.)
</td></tr><tr><td>Mary Holstege</td><td>2011-03-01</td><td>
Section 3
</td><td>
Resolve bug 12057 by clarifying what the sample tokenization is for the examples
in the specification.
</td></tr><tr><td>Jim Melton</td><td>2011-03-08</td><td>
Appendix E
</td><td>
Updated Full Text XQueryX schemas and stylesheet for bugs 11821 and 12036
</td></tr></tbody></table></div></div></body></html>